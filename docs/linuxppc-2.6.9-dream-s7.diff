diff -Naur linuxppc-2.6.9/arch/ppc/boot/simple/embed_config.c linuxppc-2.6.9-dream/arch/ppc/boot/simple/embed_config.c
--- linuxppc-2.6.9/arch/ppc/boot/simple/embed_config.c	2005-10-01 14:12:16.000000000 +0200
+++ linuxppc-2.6.9-dream/arch/ppc/boot/simple/embed_config.c	2005-06-20 10:46:10.000000000 +0200
@@ -825,8 +825,11 @@
 #ifdef CONFIG_IBM_OPENBIOS
 /* This could possibly work for all treeboot roms.
 */
+
 #if defined(CONFIG_ASH) || defined(CONFIG_BEECH) || defined(CONFIG_BUBINGA)
 #define BOARD_INFO_VECTOR       0xFFF80B50 /* openbios 1.19 moved this vector down  - armin */
+#elif defined(CONFIG_DM7020)
+#define BOARD_INFO_VECTOR	0x03100B50
 #else
 #define BOARD_INFO_VECTOR	0xFFFE0B50
 #endif
@@ -896,7 +899,9 @@
 	 * different object in the structure.  Sincr Redwwood 5
 	 * and Redwood 6 use OpenBIOS, it requires a special value.
 	 */
-#if defined(CONFIG_REDWOOD_5) || defined (CONFIG_REDWOOD_6)
+#if defined(CONFIG_REDWOOD_5) || defined(CONFIG_REDWOOD_6) || \
+	defined(CONFIG_DM56xx) || defined(CONFIG_DM7000) || \
+	defined(CONFIG_DM7020)
 	bd->bi_tbfreq = 27 * 1000 * 1000;
 #endif
 	timebase_period_ns = 1000000000 / bd->bi_tbfreq;
diff -Naur linuxppc-2.6.9/arch/ppc/boot/simple/misc-embedded.c linuxppc-2.6.9-dream/arch/ppc/boot/simple/misc-embedded.c
--- linuxppc-2.6.9/arch/ppc/boot/simple/misc-embedded.c	2004-10-18 23:53:23.000000000 +0200
+++ linuxppc-2.6.9-dream/arch/ppc/boot/simple/misc-embedded.c	2005-06-20 10:46:10.000000000 +0200
@@ -177,6 +177,15 @@
 	 * If we weren't, see if we have a ramdisk.  If so, thats root.
 	 * When in doubt, give them the netroot (root=/dev/nfs rw) -- Tom
 	 */
+#ifdef CONFIG_DM7020
+	if (*bp->bi_cmdline)
+	{
+		char *c = bp->bi_cmdline, *d = cmd_line;
+		while ((*d++ = *c++));
+		puts(cmd_line);
+	} else
+	{
+#endif
 #ifdef CONFIG_CMDLINE_BOOL
 	memcpy (cmd_line, compiled_string, sizeof(compiled_string));
 #else
@@ -187,9 +196,14 @@
 #endif
 	while ( *cp )
 		putc(*cp++);
-	while (timer++ < 5*1000) {
+	while (timer++ < 1500) {
 		if (tstc()) {
 			while ((ch = getc()) != '\n' && ch != '\r') {
+					/* ignore ESC because echoing these makes 
+					 * the user think he can use cursor keys 
+					 */
+				if (ch == '\x1b')
+					continue;
 				if (ch == '\b' || ch == '\177') {
 					if (cp != cmd_line) {
 						cp--;
@@ -211,6 +225,9 @@
 		udelay(1000);  /* 1 msec */
 	}
 	*cp = 0;
+#ifdef CONFIG_DM7020
+	}
+#endif
 	puts("\nUncompressing Linux...");
 
 	gunzip(0, 0x400000, zimage_start, &zimage_size);
diff -Naur linuxppc-2.6.9/arch/ppc/boot/utils/mktree.c linuxppc-2.6.9-dream/arch/ppc/boot/utils/mktree.c
--- linuxppc-2.6.9/arch/ppc/boot/utils/mktree.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/arch/ppc/boot/utils/mktree.c	2005-06-20 10:46:10.000000000 +0200
@@ -113,7 +113,7 @@
 		exit(4);
 	}
 
-	nblks -= (64 * 1024) / IMGBLK;
+	nblks -= (64 * 1024 - sizeof (bt)) / IMGBLK;
 
 	/* And away we go......
 	*/
@@ -122,7 +122,7 @@
 		exit(5);
 	}
 
-	while (nblks-- > 0) {
+	while (--nblks > 0) {
 		if (read(in_fd, tmpbuf, IMGBLK) < 0) {
 			perror("zImage read");
 			exit(5);
diff -Naur linuxppc-2.6.9/arch/ppc/configs/dm500_defconfig linuxppc-2.6.9-dream/arch/ppc/configs/dm500_defconfig
--- linuxppc-2.6.9/arch/ppc/configs/dm500_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/arch/ppc/configs/dm500_defconfig	2005-10-01 14:47:36.000000000 +0200
@@ -0,0 +1,795 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9
+# Thu Dec 23 15:14:14 2004
+#
+CONFIG_MMU=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_IOSCHED_NOOP is not set
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_KMOD is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+# CONFIG_E500 is not set
+CONFIG_MATH_EMULATION=y
+# CONFIG_CPU_FREQ is not set
+CONFIG_4xx=y
+
+#
+# IBM 4xx options
+#
+# CONFIG_ARCTIC2 is not set
+# CONFIG_ASH is not set
+# CONFIG_BUBINGA is not set
+# CONFIG_CPCI405 is not set
+CONFIG_DM500=y
+# CONFIG_DM56x0 is not set
+# CONFIG_DM7000 is not set
+# CONFIG_DM7020 is not set
+# CONFIG_EP405 is not set
+# CONFIG_OAK is not set
+# CONFIG_RAINIER is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_WALNUT is not set
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM_OCP=y
+CONFIG_STB03xxx=y
+CONFIG_IBM_OPENBIOS=y
+CONFIG_PPC4xx_DMA=y
+CONFIG_STBXXX_DMA=y
+CONFIG_OCP=y
+# CONFIG_PM is not set
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+# CONFIG_SERIAL_SICC is not set
+CONFIG_DM56xx=y
+CONFIG_NOT_COHERENT_CACHE=y
+
+#
+# Platform options
+#
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=null root=/dev/mtdblock5 rootfstype=squashfs ro"
+
+#
+# Bus options
+#
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_CONSISTENT_START=0xff100000
+CONFIG_CONSISTENT_SIZE=0x00200000
+CONFIG_BOOT_LOAD=0x00400000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_DREAMBOX=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_PIMSM_V1 is not set
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_OAKNET is not set
+CONFIG_NE2000=y
+# CONFIG_IBM_EMAC is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=720
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=568
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_IBM_GPIO is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_IBM_IIC=y
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_CT65550 is not set
+# CONFIG_FB_S3TRIO is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+# CONFIG_SOUND_BT878 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_TVMIXER is not set
+# CONFIG_SOUND_AD1980 is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_NAND=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+CONFIG_CRAMFS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_EMBEDDED=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=1
+# CONFIG_SQUASHFS_VMALLOC is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=y
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_POSIX is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# IBM 40x options
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+CONFIG_PPC_OCP=y
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
diff -Naur linuxppc-2.6.9/arch/ppc/configs/dm56x0_defconfig linuxppc-2.6.9-dream/arch/ppc/configs/dm56x0_defconfig
--- linuxppc-2.6.9/arch/ppc/configs/dm56x0_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/arch/ppc/configs/dm56x0_defconfig	2005-10-01 14:49:33.000000000 +0200
@@ -0,0 +1,795 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9
+# Thu Dec 23 15:14:14 2004
+#
+CONFIG_MMU=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_IOSCHED_NOOP is not set
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_KMOD is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+# CONFIG_E500 is not set
+CONFIG_MATH_EMULATION=y
+# CONFIG_CPU_FREQ is not set
+CONFIG_4xx=y
+
+#
+# IBM 4xx options
+#
+# CONFIG_ARCTIC2 is not set
+# CONFIG_ASH is not set
+# CONFIG_BUBINGA is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_DM500 is not set
+CONFIG_DM56x0=y
+# CONFIG_DM7000 is not set
+# CONFIG_DM7020 is not set
+# CONFIG_EP405 is not set
+# CONFIG_OAK is not set
+# CONFIG_RAINIER is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_WALNUT is not set
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM_OCP=y
+CONFIG_STB03xxx=y
+CONFIG_IBM_OPENBIOS=y
+CONFIG_PPC4xx_DMA=y
+CONFIG_STBXXX_DMA=y
+CONFIG_OCP=y
+# CONFIG_PM is not set
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+# CONFIG_SERIAL_SICC is not set
+CONFIG_DM56xx=y
+CONFIG_NOT_COHERENT_CACHE=y
+
+#
+# Platform options
+#
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=null root=/dev/mtdblock5 rootfstype=squashfs ro"
+
+#
+# Bus options
+#
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_CONSISTENT_START=0xff100000
+CONFIG_CONSISTENT_SIZE=0x00200000
+CONFIG_BOOT_LOAD=0x00400000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_DREAMBOX=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_PIMSM_V1 is not set
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_OAKNET is not set
+CONFIG_NE2000=y
+# CONFIG_IBM_EMAC is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=720
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=568
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_IBM_GPIO is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_IBM_IIC=y
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_CT65550 is not set
+# CONFIG_FB_S3TRIO is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+# CONFIG_SOUND_BT878 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_TVMIXER is not set
+# CONFIG_SOUND_AD1980 is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_NAND=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+CONFIG_CRAMFS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_EMBEDDED=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=1
+# CONFIG_SQUASHFS_VMALLOC is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=y
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_POSIX is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# IBM 40x options
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+CONFIG_PPC_OCP=y
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
diff -Naur linuxppc-2.6.9/arch/ppc/configs/dm7000_defconfig linuxppc-2.6.9-dream/arch/ppc/configs/dm7000_defconfig
--- linuxppc-2.6.9/arch/ppc/configs/dm7000_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/arch/ppc/configs/dm7000_defconfig	2005-10-01 14:49:35.000000000 +0200
@@ -0,0 +1,1004 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9
+# Mon May  2 21:35:31 2005
+#
+CONFIG_MMU=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_IOSCHED_NOOP is not set
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_KMOD is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+# CONFIG_E500 is not set
+CONFIG_MATH_EMULATION=y
+# CONFIG_CPU_FREQ is not set
+CONFIG_4xx=y
+
+#
+# IBM 4xx options
+#
+# CONFIG_ARCTIC2 is not set
+# CONFIG_ASH is not set
+# CONFIG_BUBINGA is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_DM500 is not set
+# CONFIG_DM56x0 is not set
+CONFIG_DM7000=y
+# CONFIG_DM7020 is not set
+# CONFIG_EP405 is not set
+# CONFIG_OAK is not set
+# CONFIG_RAINIER is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_WALNUT is not set
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM_OCP=y
+CONFIG_STB03xxx=y
+CONFIG_IBM_OPENBIOS=y
+CONFIG_PPC4xx_DMA=y
+CONFIG_STBXXX_DMA=y
+CONFIG_OCP=y
+# CONFIG_PM is not set
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+# CONFIG_SERIAL_SICC is not set
+CONFIG_NOT_COHERENT_CACHE=y
+
+#
+# Platform options
+#
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=null root=/dev/mtdblock5 rootfstype=squashfs ro"
+
+#
+# Bus options
+#
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_CONSISTENT_START=0xff100000
+CONFIG_CONSISTENT_SIZE=0x00200000
+CONFIG_BOOT_LOAD=0x00400000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_DREAMBOX=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_IDE_GENERIC is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDE_STB04xxx=y
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_QLOGIC_1280_1040 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_PIMSM_V1 is not set
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_OAKNET is not set
+CONFIG_SMC91X=y
+# CONFIG_IBM_EMAC is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=720
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=568
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_DIGI is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_IBM_GPIO is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_IBM_IIC=y
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_CT65550=y
+# CONFIG_FB_S3TRIO is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+# CONFIG_SOUND_BT878 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_TVMIXER is not set
+# CONFIG_SOUND_AD1980 is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=m
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+CONFIG_CRAMFS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_EMBEDDED=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=1
+# CONFIG_SQUASHFS_VMALLOC is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_POSIX is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+CONFIG_NLS_ISO8859_5=y
+# CONFIG_NLS_ISO8859_6 is not set
+CONFIG_NLS_ISO8859_7=y
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# IBM 40x options
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+CONFIG_PPC_OCP=y
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
diff -Naur linuxppc-2.6.9/arch/ppc/configs/dm7020_defconfig linuxppc-2.6.9-dream/arch/ppc/configs/dm7020_defconfig
--- linuxppc-2.6.9/arch/ppc/configs/dm7020_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/arch/ppc/configs/dm7020_defconfig	2005-10-01 14:49:39.000000000 +0200
@@ -0,0 +1,1065 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9
+# Tue May  3 01:13:05 2005
+#
+CONFIG_MMU=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_IOSCHED_NOOP is not set
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_KMOD is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+# CONFIG_E500 is not set
+CONFIG_MATH_EMULATION=y
+# CONFIG_CPU_FREQ is not set
+CONFIG_4xx=y
+
+#
+# IBM 4xx options
+#
+# CONFIG_ARCTIC2 is not set
+# CONFIG_ASH is not set
+# CONFIG_BUBINGA is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_DM500 is not set
+# CONFIG_DM56x0 is not set
+# CONFIG_DM7000 is not set
+CONFIG_DM7020=y
+# CONFIG_EP405 is not set
+# CONFIG_OAK is not set
+# CONFIG_RAINIER is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_WALNUT is not set
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM_OCP=y
+CONFIG_STB03xxx=y
+CONFIG_IBM_OPENBIOS=y
+CONFIG_PPC4xx_DMA=y
+CONFIG_STBXXX_DMA=y
+CONFIG_OCP=y
+# CONFIG_PM is not set
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+# CONFIG_SERIAL_SICC is not set
+CONFIG_NOT_COHERENT_CACHE=y
+
+#
+# Platform options
+#
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=null root=/dev/mtdblock3 rootfstype=jffs2 rw"
+
+#
+# Bus options
+#
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_CONSISTENT_START=0xff100000
+CONFIG_CONSISTENT_SIZE=0x00200000
+CONFIG_BOOT_LOAD=0x00400000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_VERIFY_WRITE=y
+CONFIG_MTD_NAND_DM7020=y
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_IDE_GENERIC is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDE_STB04xxx=y
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_QLOGIC_1280_1040 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE=m
+# CONFIG_NET_IPGRE_BROADCAST is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_PIMSM_V1 is not set
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+# CONFIG_IP_NF_CT_ACCT is not set
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_IRC=m
+CONFIG_IP_NF_TFTP=m
+CONFIG_IP_NF_AMANDA=m
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+CONFIG_IP_NF_MATCH_IPRANGE=m
+CONFIG_IP_NF_MATCH_MAC=m
+CONFIG_IP_NF_MATCH_PKTTYPE=m
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_DSCP=m
+CONFIG_IP_NF_MATCH_AH_ESP=m
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+CONFIG_IP_NF_MATCH_HELPER=m
+CONFIG_IP_NF_MATCH_STATE=m
+CONFIG_IP_NF_MATCH_CONNTRACK=m
+CONFIG_IP_NF_MATCH_OWNER=m
+# CONFIG_IP_NF_MATCH_ADDRTYPE is not set
+# CONFIG_IP_NF_MATCH_REALM is not set
+# CONFIG_IP_NF_MATCH_SCTP is not set
+# CONFIG_IP_NF_MATCH_COMMENT is not set
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+# CONFIG_IP_NF_TARGET_LOG is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_SAME=m
+# CONFIG_IP_NF_NAT_LOCAL is not set
+# CONFIG_IP_NF_NAT_SNMP_BASIC is not set
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_NAT_TFTP=m
+CONFIG_IP_NF_NAT_AMANDA=m
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_OAKNET is not set
+CONFIG_NE2000=y
+# CONFIG_IBM_EMAC is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPPOE=m
+# CONFIG_SLIP is not set
+CONFIG_SHAPER=m
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=720
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=568
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_DIGI is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_SYNCLINKMP is not set
+CONFIG_N_HDLC=m
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_IBM_GPIO is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_IBM_IIC=y
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_CT65550=y
+# CONFIG_FB_S3TRIO is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+# CONFIG_SOUND_BT878 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_TVMIXER is not set
+# CONFIG_SOUND_AD1980 is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=m
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_REISERFS_FS=y
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_NAND=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=m
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V4 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=y
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_POSIX is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+CONFIG_NLS_ISO8859_5=y
+# CONFIG_NLS_ISO8859_6 is not set
+CONFIG_NLS_ISO8859_7=y
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# IBM 40x options
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+CONFIG_PPC_OCP=y
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
diff -Naur linuxppc-2.6.9/arch/ppc/kernel/dma-mapping.c linuxppc-2.6.9-dream/arch/ppc/kernel/dma-mapping.c
--- linuxppc-2.6.9/arch/ppc/kernel/dma-mapping.c	2004-10-18 23:53:05.000000000 +0200
+++ linuxppc-2.6.9-dream/arch/ppc/kernel/dma-mapping.c	2005-09-19 20:57:31.000000000 +0200
@@ -362,17 +362,34 @@
 /*
  * make an area consistent.
  */
-void __dma_sync(void *vaddr, size_t size, int direction)
-{
+void __dma_sync(void *vaddr, size_t size, int direction) {
 	unsigned long start = (unsigned long)vaddr;
 	unsigned long end   = start + size;
 
 	switch (direction) {
 	case DMA_NONE:
 		BUG();
+
 	case DMA_FROM_DEVICE:	/* invalidate only */
+#if defined(CONFIG_40x)
+			/* Handle cases where the buffer start and/or end
+			 * are not L1 cache line aligned.
+			 * Some drivers/subsystems (e.g. USB, SCSI) do DMA
+			 * from stack allocated buffers. To prevent
+			 * corruption of other stack variables located
+			 * near the buffer, we flush (instead of invalidate)
+			 * these "dangerous" areas.
+			 * patch from Eugene Surovegin <ebs@ebshome.net>
+			 */
+			if( unlikely(start & (L1_CACHE_LINE_SIZE - 1)) )
+				__asm__ __volatile__("dcbf 0,%0" : : "r" (start));
+
+			if( unlikely(end & (L1_CACHE_LINE_SIZE - 1)) )
+				__asm__ __volatile__("dcbf 0,%0" : : "r" (end));
+#endif
 		invalidate_dcache_range(start, end);
 		break;
+
 	case DMA_TO_DEVICE:		/* writeback only */
 		clean_dcache_range(start, end);
 		break;
diff -Naur linuxppc-2.6.9/arch/ppc/kernel/misc.S linuxppc-2.6.9-dream/arch/ppc/kernel/misc.S
--- linuxppc-2.6.9/arch/ppc/kernel/misc.S	2004-10-18 23:55:07.000000000 +0200
+++ linuxppc-2.6.9-dream/arch/ppc/kernel/misc.S	2005-06-20 10:46:10.000000000 +0200
@@ -900,6 +900,50 @@
 	bne-	10b
 	blr
 
+/* 
+ * Help functions for smc91x driver
+ *
+ */
+_GLOBAL(_fast_outsw)
+	cmpwi	0,r5,0
+	mtctr	r5
+	subi	r4,r4,2
+	blelr-
+00:
+	lhzu	r5,2(r4)
+	eieio
+	sthbrx	r5,0,r3
+	bdnz	00b
+	blr
+
+_GLOBAL(fast_outsl)
+	cmpwi	0,r5,0
+	mtctr	r5
+	subi	r4,r4,4
+	blelr-
+00:
+	lwzu	r5,4(r4)
+	stw	r5,0(r3)
+	bdnz	00b
+	blr
+	
+_GLOBAL(fast_insline)
+	cmpwi	0,r5,0
+	mtctr	r5
+	subi	r4,r4,4
+	blelr-
+00:
+	lwz	r5,0(r3)
+	lwz	r6,4(r3)
+	lwz	r7,8(r3)
+	lwz	r8,12(r3)
+	stwu	r5,4(r4)
+	stwu	r6,4(r4)
+	stwu	r7,4(r4)
+	stwu	r8,4(r4)
+	bdnz	00b
+	blr
+
 /*
  * I/O string operations
  *
diff -Naur linuxppc-2.6.9/arch/ppc/platforms/4xx/dm56xx.c linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/dm56xx.c
--- linuxppc-2.6.9/arch/ppc/platforms/4xx/dm56xx.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/dm56xx.c	2005-06-20 10:46:10.000000000 +0200
@@ -0,0 +1,97 @@
+/*
+ * arch/ppc/platforms/4xx/dm56xx.c
+ *
+ * Copyright (C) 2004 Andreas Oberritter
+ *
+ * Based on redwood6.c
+ * Author: Armin Kuster <akuster@mvista.com>
+ *
+ * 2002 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/init.h>
+#include <linux/pagemap.h>
+#include <asm/ocp.h>
+#include <asm/ibm_ocp.h>
+#include <asm/io.h>
+#include <asm/ppc4xx_pic.h>
+
+/*
+ * Define all of the IRQ senses and polarities.
+ */
+
+static u8 dm56xx_irq_initsenses[] __initdata = {
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 0: RTC/FPC */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 1: Transport */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 2: Audio Dec */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 3: Video Dec */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 4: DMA Chan 0 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 5: DMA Chan 1 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 6: DMA Chan 2 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 7: DMA Chan 3 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 8: SmartCard 0 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 9: IIC0 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 10: IRR */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 11: Cap Timers */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 12: Cmp Timers */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 13: Serial Port */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 14: Soft Modem */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 15: Down Ctrs */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 16: SmartCard 1 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 17: Ext Int 7 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 18: Ext Int 8 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 19: Ext Int 9 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 20: Serial 0 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 21: Serial 1 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 22: Serial 2 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 23: XPT_DMA */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* 24: DCR timeout */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 25: Ext Int 0 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 26: Ext Int 1 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 27: Ext Int 2 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 28: Ext Int 3 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 29: Ext Int 4 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 30: Ext Int 5 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* 31: Ext Int 6 */
+};
+
+static void __init dm56xx_setup_arch(void)
+{
+	ppc4xx_setup_arch();
+
+	ocp_sys_info.opb_bus_freq = 63000000;
+
+	ibm4xxPIC_InitSenses = dm56xx_irq_initsenses;
+	ibm4xxPIC_NumInitSenses = sizeof(dm56xx_irq_initsenses);
+}
+
+static void __init dm56xx_map_io(void)
+{
+	int i;
+
+	ppc4xx_map_io();
+	for (i = 0; i < 16; i++) {
+		unsigned long v, p;
+
+		/* 0x400x0000 -> 0xe00x0000 */
+		p = 0x40000000 | (i << 16);
+		v = STBx25xx_IO_BASE | (i << 16);
+
+		io_block_mapping(v, p, PAGE_SIZE,
+				 _PAGE_NO_CACHE | pgprot_val(PAGE_KERNEL) |
+				 _PAGE_GUARDED);
+	}
+}
+
+void __init platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+			  unsigned long r6, unsigned long r7)
+{
+	ppc4xx_init(r3, r4, r5, r6, r7);
+
+	ppc_md.setup_arch = dm56xx_setup_arch;
+	ppc_md.setup_io_mappings = dm56xx_map_io;
+}
+
diff -Naur linuxppc-2.6.9/arch/ppc/platforms/4xx/dm56xx.h linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/dm56xx.h
--- linuxppc-2.6.9/arch/ppc/platforms/4xx/dm56xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/dm56xx.h	2005-06-20 10:46:10.000000000 +0200
@@ -0,0 +1,51 @@
+/*
+ * arch/ppc/platforms/4xx/dm56xx.h
+ *
+ * Macros, definitions, and data structures specific to the IBM PowerPC
+ * STBx25xx "Redwood6" evaluation board.
+ *
+ * Author: Armin Kuster <akuster@mvista.com>
+ *
+ * 2002 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_DM56XX_H__
+#define __ASM_DM56XX_H__
+
+/* DM56xx has an STBx25xx core */
+#include <platforms/4xx/ibmstbx25.h>
+
+#ifndef __ASSEMBLY__
+typedef struct board_info {
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned int	bi_dummy;		/* field shouldn't exist */
+	unsigned char	bi_enetaddr[6];		/* Ethernet MAC address */
+	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
+	unsigned int	bi_tbfreq;		/* Software timebase freq */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[1];		/* Use fast i2c mode */
+} bd_t;
+#endif				/* !__ASSEMBLY__ */
+
+#ifdef MAX_HWIFS
+#undef MAX_HWIFS
+#endif
+#define MAX_HWIFS	1
+
+#define _IO_BASE	0
+#define _ISA_MEM_BASE	0
+#define PCI_DRAM_OFFSET	0
+
+#define BASE_BAUD		(378000000 / 18 / 16)
+
+#define PPC4xx_MACHINE_NAME	"Dream Multimedia TV Dreambox"
+
+#endif				/* __ASM_DM56XX_H__ */
+#endif				/* __KERNEL__ */
diff -Naur linuxppc-2.6.9/arch/ppc/platforms/4xx/dm70xx.c linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/dm70xx.c
--- linuxppc-2.6.9/arch/ppc/platforms/4xx/dm70xx.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/dm70xx.c	2005-06-20 10:46:10.000000000 +0200
@@ -0,0 +1,90 @@
+/*
+ * arch/ppc/platforms/4xx/dm70xx.c
+ *
+ * Support for the Dream Multimedia TV Dreambox Satellite Receiver
+ *
+ * Based on:
+ * Author: Armin Kuster <akuster@mvista.com>
+ *
+ * 2000-2001 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pagemap.h>
+#include <linux/device.h>
+#include <asm/ocp.h>
+#include <asm/ibm_ocp.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+
+#ifdef CONFIG_DM7000
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.start	= SMC91111_BASE_ADDR,
+		.end	= SMC91111_BASE_ADDR + SMC91111_REG_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= SMC91111_IRQ,
+		.end	= SMC91111_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+static struct platform_device *dm7000_devs[] __initdata = {
+	&smc91x_device,
+};
+
+static int __init dm7000_add_devices(void)
+{
+	return platform_add_devices(dm7000_devs, ARRAY_SIZE(dm7000_devs));
+}
+
+device_initcall(dm7000_add_devices);
+#endif
+
+static void __init dm70xx_setup_arch(void)
+{
+	ppc4xx_setup_arch();
+
+	ocp_sys_info.opb_bus_freq = 63000000;
+}
+
+static void __init dm70xx_map_io(void)
+{
+	int i;
+
+	ppc4xx_map_io();
+
+	for (i = 0; i < 16; i++) {
+		unsigned long v, p;
+
+		/* 0x400x0000 -> 0xe00x0000 */
+		p = 0x40000000 | (i << 16);
+		v = STB04xxx_IO_BASE | (i << 16);
+
+		io_block_mapping(v, p, PAGE_SIZE,
+			_PAGE_NO_CACHE | pgprot_val(PAGE_KERNEL) | _PAGE_GUARDED);
+	}
+}
+
+void __init platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+			  unsigned long r6, unsigned long r7)
+{
+	ppc4xx_init(r3, r4, r5, r6, r7);
+
+	ppc_md.setup_arch = dm70xx_setup_arch;
+	ppc_md.setup_io_mappings = dm70xx_map_io;
+}
+
diff -Naur linuxppc-2.6.9/arch/ppc/platforms/4xx/dm70xx.h linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/dm70xx.h
--- linuxppc-2.6.9/arch/ppc/platforms/4xx/dm70xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/dm70xx.h	2005-06-20 10:46:10.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+ * arch/ppc/platforms/4xx/dm70xx.h
+ *
+ * based on:
+ * Macros, definitions, and data structures specific to the IBM PowerPC
+ * STB03xxx "Redwood" evaluation board.
+ *
+ * Author: Armin Kuster <akuster@mvista.com>
+ *
+ * 2001 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_DM70XX_H__
+#define __ASM_DM70XX_H__
+
+/* The DM70xx has an STB04xxx core */
+#include <platforms/4xx/ibmstb4.h>
+
+#ifdef CONFIG_DM7020
+#ifndef __ASSEMBLY__
+typedef struct board_info {
+	unsigned int	bi_memsize;      /* DRAM installed, in bytes */
+	unsigned char	bi_enetaddr[6];  /* Ethernet MAC address */
+	unsigned int	bi_intfreq;      /* Processor speed, in Hz */
+	unsigned int	bi_busfreq;      /* Bus speed, in Hz */
+	unsigned int	bi_tbfreq;       /* Software timebase freq */
+	unsigned char bi_cmdline[256]; /* kernel cmdline. if empty, use default. */
+	int		bi_iic_fast[2];          /* Use fast i2c mode */
+} bd_t;
+#endif /* !__ASSEMBLY__ */
+#else
+#ifndef __ASSEMBLY__
+typedef struct board_info {
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned int	bi_dummy;		/* field shouldn't exist */
+	unsigned char	bi_enetaddr[6];		/* Ethernet MAC address */
+	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
+	unsigned int	bi_tbfreq;		/* Software timebase freq */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[2];		/* Use fast i2c mode */
+} bd_t;
+#endif /* !__ASSEMBLY__ */
+#endif
+
+#ifdef CONFIG_DM7000
+#define SMC91111_BASE_ADDR	0xf2000300
+#define SMC91111_IRQ		28
+#define SMC91111_REG_SIZE	16
+#endif
+
+#ifdef MAX_HWIFS
+#undef MAX_HWIFS
+#endif
+#define MAX_HWIFS		2
+
+#define _IO_BASE	0
+#define _ISA_MEM_BASE	0
+#define PCI_DRAM_OFFSET	0
+
+#define BASE_BAUD		(378000000 / 18 / 16)
+
+#define PPC4xx_MACHINE_NAME	"Dream Multimedia TV Dreambox"
+
+#endif /* __ASM_DM70XX_H__ */
+#endif /* __KERNEL__ */
diff -Naur linuxppc-2.6.9/arch/ppc/platforms/4xx/ibmstb4.c linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/ibmstb4.c
--- linuxppc-2.6.9/arch/ppc/platforms/4xx/ibmstb4.c	2004-10-18 23:53:21.000000000 +0200
+++ linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/ibmstb4.c	2005-09-19 21:39:56.000000000 +0200
@@ -47,6 +47,7 @@
 	{ .vendor	= OCP_VENDOR_IBM,
 	  .function	= OCP_FUNC_IIC,
 	  .paddr	= IIC0_BASE,
+	  .index	= 0,
 	  .irq		= IIC0_IRQ,
 	  .pm		= IBM_CPM_IIC0,
 	  .additions	= &ibmstb4_iic0_def,
@@ -55,6 +56,7 @@
 	{ .vendor	= OCP_VENDOR_IBM,
 	  .function	= OCP_FUNC_IIC,
 	  .paddr	= IIC1_BASE,
+	  .index	= 1,
 	  .irq		= IIC1_IRQ,
 	  .pm		= IBM_CPM_IIC1,
 	  .additions	= &ibmstb4_iic1_def,
diff -Naur linuxppc-2.6.9/arch/ppc/platforms/4xx/Kconfig linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/Kconfig
--- linuxppc-2.6.9/arch/ppc/platforms/4xx/Kconfig	2005-10-01 14:12:17.000000000 +0200
+++ linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/Kconfig	2005-10-01 14:49:45.000000000 +0200
@@ -29,6 +29,30 @@
 	help
 	  This option enables support for the CPCI405 board.
 
+config DM500
+	bool "DreamBox DM500"
+	help
+	  This option enables support for the Dream Multimedia TV
+	  Dreambox DM500
+
+config DM56x0
+	bool "DreamBox DM5600/DM5620"
+	help
+	  This option enables support for the Dream Multimedia TV
+	  DreamBox DM5600 and DM5620.
+
+config DM7000
+	bool "DreamBox DM7000"
+	help
+	  This option enables support for the Dream Multimedia TV
+	  DreamBox DM7000.
+
+config DM7020
+	bool "DreamBox DM7020"
+	help
+	  This option enables support for the Dream Multimedia TV
+	  DreamBox DM7020.
+
 config EP405
 	bool "EP405/EP405PC"
 	help
@@ -133,7 +157,7 @@
 
 config IBM_OCP
 	bool
-	depends on ARCTIC || ASH || BUBINGA || CPCI405 || EBONY || EP405 || OCOTEA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
+	depends on ARCTIC || ASH || BUBINGA || CPCI405 || DM56xx || DM7000 || DM7020 || EBONY || EP405 || OCOTEA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
 	default y
 
 config IBM_EMAC4
@@ -173,7 +197,7 @@
 
 config STB03xxx
 	bool
-	depends on REDWOOD_5 || REDWOOD_6
+	depends on DM56xx || DM7000 || DM7020 || REDWOOD_5 || REDWOOD_6
 	default y
 
 config EMBEDDEDBOOT
@@ -183,7 +207,7 @@
 
 config IBM_OPENBIOS
 	bool
-	depends on ASH || BUBINGA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
+	depends on ASH || BUBINGA || DM56xx || DM7000 || DM7020 || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
 	default y
 
 config IBM_PIBS
@@ -200,6 +224,11 @@
 	depends on !STB03xxx && PPC4xx_DMA
 	default y
 
+config STBXXX_DMA
+	bool
+	depends on STB03xxx
+	default y
+
 config OCP
 	bool
 	depends on IBM_OCP
@@ -246,4 +275,9 @@
 	depends on 405LP
 	default y
 
+config DM56xx
+	bool
+	depends on DM500 || DM56x0
+	default y
+
 endmenu
diff -Naur linuxppc-2.6.9/arch/ppc/platforms/4xx/Makefile linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/Makefile
--- linuxppc-2.6.9/arch/ppc/platforms/4xx/Makefile	2005-10-01 14:12:17.000000000 +0200
+++ linuxppc-2.6.9-dream/arch/ppc/platforms/4xx/Makefile	2005-06-20 10:46:10.000000000 +0200
@@ -24,3 +24,6 @@
 obj-$(CONFIG_405EP)		+= ibm405ep.o
 obj-$(CONFIG_405GPR)		+= ibm405gpr.o
 obj-$(CONFIG_VIRTEX_II_PRO)	+= virtex-ii_pro.o
+obj-$(CONFIG_DM56xx)		+= dm56xx.o ibmstbx25.o
+obj-$(CONFIG_DM7000)		+= dm70xx.o ibmstb4.o
+obj-$(CONFIG_DM7020)		+= dm70xx.o ibmstb4.o
diff -Naur linuxppc-2.6.9/arch/ppc/syslib/Makefile linuxppc-2.6.9-dream/arch/ppc/syslib/Makefile
--- linuxppc-2.6.9/arch/ppc/syslib/Makefile	2005-10-01 14:12:17.000000000 +0200
+++ linuxppc-2.6.9-dream/arch/ppc/syslib/Makefile	2005-06-20 10:46:10.000000000 +0200
@@ -81,3 +81,4 @@
 obj-$(CONFIG_PCI)		+= indirect_pci.o pci_auto.o
 endif
 obj-$(CONFIG_PPC_MPC52xx)	+= mpc52xx_setup.o mpc52xx_pic.o
+obj-$(CONFIG_STBXXX_DMA) += ppc4xx_stbdma.o
diff -Naur linuxppc-2.6.9/arch/ppc/syslib/ppc4xx_dma.c linuxppc-2.6.9-dream/arch/ppc/syslib/ppc4xx_dma.c
--- linuxppc-2.6.9/arch/ppc/syslib/ppc4xx_dma.c	2004-10-18 23:55:35.000000000 +0200
+++ linuxppc-2.6.9-dream/arch/ppc/syslib/ppc4xx_dma.c	2005-06-20 10:46:10.000000000 +0200
@@ -452,7 +452,7 @@
 		return DMA_STATUS_BAD_CHANNEL;
 	}
 
-#if DCRN_POL > 0
+#ifdef DCRN_POL
 	polarity = mfdcr(DCRN_POL);
 #else
 	polarity = 0;
@@ -466,8 +466,8 @@
 
 	/* clear all polarity signals and then "or" in new signal levels */
 	polarity &= ~GET_DMA_POLARITY(dmanr);
-	polarity |= p_dma_ch->polarity;
-#if DCRN_POL > 0
+	polarity |= p_init->polarity;
+#ifdef DCRN_POL
 	mtdcr(DCRN_POL, polarity);
 #endif
 	mtdcr(DCRN_DMACR0 + (dmanr * 0x8), control);
@@ -512,7 +512,7 @@
 		return DMA_STATUS_BAD_CHANNEL;
 	}
 
-#if DCRN_POL > 0
+#ifdef DCRN_POL
 	polarity = mfdcr(DCRN_POL);
 #else
 	polarity = 0;
diff -Naur linuxppc-2.6.9/arch/ppc/syslib/ppc4xx_stbdma.c linuxppc-2.6.9-dream/arch/ppc/syslib/ppc4xx_stbdma.c
--- linuxppc-2.6.9/arch/ppc/syslib/ppc4xx_stbdma.c	2005-10-01 14:12:17.000000000 +0200
+++ linuxppc-2.6.9-dream/arch/ppc/syslib/ppc4xx_stbdma.c	2005-06-20 10:46:10.000000000 +0200
@@ -33,7 +33,7 @@
 #include <asm/ppc4xx_dma.h>
 
 int
-clr_dma_status(unsigned int dmanr)
+ppc4xx_clr_dma_status(unsigned int dmanr)
 {
 	unsigned int control;
 	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
@@ -69,13 +69,11 @@
  * channels
  */
 int
-map_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan)
+ppc4xx_map_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan)
 {
 	unsigned int map;
 	int connect_port_to_chan, select; 
 
-	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-	
 	connect_port_to_chan = ((ocp_dma & 0x7)*4);
 	
 	select = ocp_dma >> 3;
@@ -100,13 +98,11 @@
 }
 
 int
-disable_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan)
+ppc4xx_disable_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan)
 {
 	unsigned int map;
 	int connect_port_to_chan, select; 
 
-	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-	
 	connect_port_to_chan = ((ocp_dma & 0x7)*4);
 	
 	select = ocp_dma >> 3;
@@ -130,6 +126,6 @@
 	return DMA_STATUS_GOOD;
 }
 
-EXPORT_SYMBOL(disable_dma_port);
-EXPORT_SYMBOL(map_dma_port);
-EXPORT_SYMBOL(clr_dma_status);
+EXPORT_SYMBOL(ppc4xx_disable_dma_port);
+EXPORT_SYMBOL(ppc4xx_map_dma_port);
+EXPORT_SYMBOL(ppc4xx_clr_dma_status);
diff -Naur linuxppc-2.6.9/drivers/i2c/busses/i2c-ibm_iic.c linuxppc-2.6.9-dream/drivers/i2c/busses/i2c-ibm_iic.c
--- linuxppc-2.6.9/drivers/i2c/busses/i2c-ibm_iic.c	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/i2c/busses/i2c-ibm_iic.c	2005-09-19 20:50:45.000000000 +0200
@@ -86,16 +86,21 @@
 	printk(KERN_DEBUG "  cntl     = 0x%02x, mdcntl = 0x%02x\n"
 	       KERN_DEBUG "  sts      = 0x%02x, extsts = 0x%02x\n"
 	       KERN_DEBUG "  clkdiv   = 0x%02x, xfrcnt = 0x%02x\n"
-	       KERN_DEBUG "  xtcntlss = 0x%02x, directcntl = 0x%02x\n",
+	       KERN_DEBUG "  xtcntlss = 0x%02x\n",
 		in_8(&iic->cntl), in_8(&iic->mdcntl), in_8(&iic->sts), 
 		in_8(&iic->extsts), in_8(&iic->clkdiv), in_8(&iic->xfrcnt), 
-		in_8(&iic->xtcntlss), in_8(&iic->directcntl));
+		in_8(&iic->xtcntlss));
+#if !defined(CONFIG_STB03xxx)
+	printk(KERN_DEBUG "directcntl = 0x%02x\n",
+		in_8(&iic->directcntl));
+#endif
 }
 #  define DUMP_REGS(h,dev)	dump_iic_regs((h),(dev))
 #else
 #  define DUMP_REGS(h,dev)	((void)0)
 #endif
 
+#if !defined(CONFIG_STB03xxx)
 /* Bus timings (in ns) for bit-banging */
 static struct i2c_timings {
 	unsigned int hd_sta;
@@ -120,6 +125,7 @@
 	.high 	= 600,
 	.buf	= 1300,
 }};
+#endif
 
 /* Enable/disable interrupt generation */
 static inline void iic_interrupt_mode(struct ibm_iic_private* dev, int enable)
@@ -172,21 +178,13 @@
 	DUMP_REGS("iic_init", dev);
 }
 
-/* 
- * Reset IIC interface
- */
-static void iic_dev_reset(struct ibm_iic_private* dev)
+#if !defined(CONFIG_STB03xxx)
+static void iic_dev_free_bus(struct ibm_iic_private* dev)
 {
 	volatile struct iic_regs *iic = dev->vaddr;
 	int i;
 	u8 dc;
-	
-	DBG("%d: soft reset\n", dev->idx);
-	DUMP_REGS("reset", dev);
-	
-    	/* Place chip in the reset state */
-	out_8(&iic->xtcntlss, XTCNTLSS_SRST);
-	
+
 	/* Check if bus is free */
 	dc = in_8(&iic->directcntl);	
 	if (!DIRCTNL_FREE(dc)){
@@ -212,7 +210,26 @@
 			cond_resched();
 		}
 	}
+}
+#endif
+
+/* 
+ * Reset IIC interface
+ */
+static void iic_dev_reset(struct ibm_iic_private* dev)
+{
+	volatile struct iic_regs *iic = dev->vaddr;
 	
+	DBG("%d: soft reset\n", dev->idx);
+	DUMP_REGS("reset", dev);
+	
+    	/* Place chip in the reset state */
+	out_8(&iic->xtcntlss, XTCNTLSS_SRST);
+
+#if !defined(CONFIG_STB03xxx)
+	iic_dev_free_bus(dev);
+#endif
+
 	/* Remove reset */
 	out_8(&iic->xtcntlss, 0);
 	
@@ -220,6 +237,7 @@
 	iic_dev_init(dev);
 }
 
+#if !defined(CONFIG_STB03xxx)
 /*
  * Do 0-length transaction using bit-banging through IIC_DIRECTCNTL register.
  */
@@ -317,6 +335,7 @@
 	res = -EREMOTEIO;
 	goto out;
 }
+#endif
 
 /*
  * IIC interrupt handler
@@ -412,20 +431,12 @@
 	
 	if (dev->irq >= 0){
 		/* Interrupt mode */
-		wait_queue_t wait;
-    		init_waitqueue_entry(&wait, current);
-		
-		add_wait_queue(&dev->wq, &wait);
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (in_8(&iic->sts) & STS_PT)
-			schedule_timeout(dev->adap.timeout * HZ);
-		set_current_state(TASK_RUNNING);
-		remove_wait_queue(&dev->wq, &wait);
-		
-		if (unlikely(signal_pending(current))){
+		ret = wait_event_interruptible_timeout(dev->wq, 
+			!(in_8(&iic->sts) & STS_PT), dev->adap.timeout * HZ);
+
+		if (unlikely(ret < 0))
 			DBG("%d: wait interrupted\n", dev->idx);
-			ret = -ERESTARTSYS;
-		} else if (unlikely(in_8(&iic->sts) & STS_PT)){
+		else if (unlikely(in_8(&iic->sts) & STS_PT)){
 			DBG("%d: wait timeout\n", dev->idx);
 			ret = -ETIMEDOUT;
 		}
@@ -578,6 +589,7 @@
 	}		
 	for (i = 0; i < num; ++i){
 		if (unlikely(msgs[i].len <= 0)){
+#if !defined(CONFIG_STB03xxx)
 			if (num == 1 && !msgs[0].len){
 				/* Special case for I2C_SMBUS_QUICK emulation.
 				 * IBM IIC doesn't support 0-length transactions
@@ -585,6 +597,7 @@
 				 */
 				return iic_smbus_quick(dev, &msgs[0]);
 			}
+#endif
 			DBG("%d: invalid len %d in msg[%d]\n", dev->idx, 
 				msgs[i].len, i);
 			return -EINVAL;
diff -Naur linuxppc-2.6.9/drivers/i2c/i2c-core.c linuxppc-2.6.9-dream/drivers/i2c/i2c-core.c
--- linuxppc-2.6.9/drivers/i2c/i2c-core.c	2004-10-18 23:53:22.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/i2c/i2c-core.c	2005-06-20 10:46:10.000000000 +0200
@@ -663,9 +663,11 @@
 	int addr,i,found,err;
 	int adap_id = i2c_adapter_id(adapter);
 
+#if 0
 	/* Forget it if we can't probe using SMBUS_QUICK */
 	if (! i2c_check_functionality(adapter,I2C_FUNC_SMBUS_QUICK))
 		return -1;
+#endif
 
 	for (addr = 0x00; addr <= 0x7f; addr++) {
 
@@ -768,11 +770,13 @@
 		if (!found) 
 			continue;
 
+#if 0
 		/* OK, so we really should examine this address. First check
 		   whether there is some client here at all! */
 		if (i2c_smbus_xfer(adapter,addr,0,0,0,I2C_SMBUS_QUICK,NULL) >= 0)
 			if ((err = found_proc(adapter,addr,-1)))
 				return err;
+#endif
 	}
 	return 0;
 }
@@ -808,6 +812,7 @@
 	module_put(adap->owner);
 }
 
+#if 0
 /* The SMBus parts */
 
 #define POLY    (0x1070U << 3) 
@@ -1256,7 +1261,7 @@
 	}
 	return res;
 }
-
+#endif
 
 /* You should always define `functionality'; the 'else' is just for
    backward compatibility. */ 
@@ -1294,6 +1299,7 @@
 EXPORT_SYMBOL(i2c_put_adapter);
 EXPORT_SYMBOL(i2c_probe);
 
+#if 0
 EXPORT_SYMBOL(i2c_smbus_xfer);
 EXPORT_SYMBOL(i2c_smbus_write_quick);
 EXPORT_SYMBOL(i2c_smbus_read_byte);
@@ -1307,6 +1313,7 @@
 EXPORT_SYMBOL(i2c_smbus_write_block_data);
 EXPORT_SYMBOL(i2c_smbus_read_i2c_block_data);
 EXPORT_SYMBOL(i2c_smbus_write_i2c_block_data);
+#endif
 
 EXPORT_SYMBOL(i2c_get_functionality);
 EXPORT_SYMBOL(i2c_check_functionality);
diff -Naur linuxppc-2.6.9/drivers/i2c/i2c-dev.c linuxppc-2.6.9-dream/drivers/i2c/i2c-dev.c
--- linuxppc-2.6.9/drivers/i2c/i2c-dev.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/i2c/i2c-dev.c	2005-09-18 15:46:57.000000000 +0200
@@ -178,11 +178,13 @@
 {
 	struct i2c_client *client = (struct i2c_client *)file->private_data;
 	struct i2c_rdwr_ioctl_data rdwr_arg;
+#if 0
 	struct i2c_smbus_ioctl_data data_arg;
 	union i2c_smbus_data temp;
+#endif
 	struct i2c_msg *rdwr_pa;
 	u8 __user **data_ptrs;
-	int i,datasize,res;
+	int i,/*datasize,*/res;
 	unsigned long funcs;
 
 	dev_dbg(&client->adapter->dev, "i2c-%d ioctl, cmd: 0x%x, arg: %lx.\n",
@@ -291,7 +293,7 @@
 		kfree(data_ptrs);
 		kfree(rdwr_pa);
 		return res;
-
+#if 0
 	case I2C_SMBUS:
 		if (copy_from_user(&data_arg,
 		                   (struct i2c_smbus_ioctl_data __user *) arg,
@@ -363,7 +365,7 @@
 				return -EFAULT;
 		}
 		return res;
-
+#endif
 	default:
 		return i2c_control(client,cmd,arg);
 	}
diff -Naur linuxppc-2.6.9/drivers/ide/arm/icside.c linuxppc-2.6.9-dream/drivers/ide/arm/icside.c
--- linuxppc-2.6.9/drivers/ide/arm/icside.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/arm/icside.c	2005-06-20 10:46:10.000000000 +0200
@@ -1,7 +1,9 @@
 /*
  * linux/drivers/ide/arm/icside.c
  *
- * Copyright (c) 1996-2003 Russell King.
+ * Copyright (c) 1996-2004 Russell King.
+ *
+ * Please note that this platform does not support 32-bit IDE IO.
  */
 
 #include <linux/config.h>
@@ -16,6 +18,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/device.h>
 #include <linux/init.h>
+#include <linux/scatterlist.h>
 
 #include <asm/dma.h>
 #include <asm/ecard.h>
@@ -23,21 +26,21 @@
 
 #define ICS_IDENT_OFFSET		0x2280
 
-#define ICS_ARCIN_V5_INTRSTAT		0x000
-#define ICS_ARCIN_V5_INTROFFSET		0x001
-#define ICS_ARCIN_V5_IDEOFFSET		0xa00
-#define ICS_ARCIN_V5_IDEALTOFFSET	0xae0
-#define ICS_ARCIN_V5_IDESTEPPING	4
-
-#define ICS_ARCIN_V6_IDEOFFSET_1	0x800
-#define ICS_ARCIN_V6_INTROFFSET_1	0x880
-#define ICS_ARCIN_V6_INTRSTAT_1		0x8a4
-#define ICS_ARCIN_V6_IDEALTOFFSET_1	0x8e0
-#define ICS_ARCIN_V6_IDEOFFSET_2	0xc00
-#define ICS_ARCIN_V6_INTROFFSET_2	0xc80
-#define ICS_ARCIN_V6_INTRSTAT_2		0xca4
-#define ICS_ARCIN_V6_IDEALTOFFSET_2	0xce0
-#define ICS_ARCIN_V6_IDESTEPPING	4
+#define ICS_ARCIN_V5_INTRSTAT		0x0000
+#define ICS_ARCIN_V5_INTROFFSET		0x0004
+#define ICS_ARCIN_V5_IDEOFFSET		0x2800
+#define ICS_ARCIN_V5_IDEALTOFFSET	0x2b80
+#define ICS_ARCIN_V5_IDESTEPPING	6
+
+#define ICS_ARCIN_V6_IDEOFFSET_1	0x2000
+#define ICS_ARCIN_V6_INTROFFSET_1	0x2200
+#define ICS_ARCIN_V6_INTRSTAT_1		0x2290
+#define ICS_ARCIN_V6_IDEALTOFFSET_1	0x2380
+#define ICS_ARCIN_V6_IDEOFFSET_2	0x3000
+#define ICS_ARCIN_V6_INTROFFSET_2	0x3200
+#define ICS_ARCIN_V6_INTRSTAT_2		0x3290
+#define ICS_ARCIN_V6_IDEALTOFFSET_2	0x3380
+#define ICS_ARCIN_V6_IDESTEPPING	6
 
 struct cardinfo {
 	unsigned int dataoffset;
@@ -46,28 +49,28 @@
 };
 
 static struct cardinfo icside_cardinfo_v5 = {
-	ICS_ARCIN_V5_IDEOFFSET,
-	ICS_ARCIN_V5_IDEALTOFFSET,
-	ICS_ARCIN_V5_IDESTEPPING
+	.dataoffset	= ICS_ARCIN_V5_IDEOFFSET,
+	.ctrloffset	= ICS_ARCIN_V5_IDEALTOFFSET,
+	.stepping	= ICS_ARCIN_V5_IDESTEPPING,
 };
 
 static struct cardinfo icside_cardinfo_v6_1 = {
-	ICS_ARCIN_V6_IDEOFFSET_1,
-	ICS_ARCIN_V6_IDEALTOFFSET_1,
-	ICS_ARCIN_V6_IDESTEPPING
+	.dataoffset	= ICS_ARCIN_V6_IDEOFFSET_1,
+	.ctrloffset	= ICS_ARCIN_V6_IDEALTOFFSET_1,
+	.stepping	= ICS_ARCIN_V6_IDESTEPPING,
 };
 
 static struct cardinfo icside_cardinfo_v6_2 = {
-	ICS_ARCIN_V6_IDEOFFSET_2,
-	ICS_ARCIN_V6_IDEALTOFFSET_2,
-	ICS_ARCIN_V6_IDESTEPPING
+	.dataoffset	= ICS_ARCIN_V6_IDEOFFSET_2,
+	.ctrloffset	= ICS_ARCIN_V6_IDEALTOFFSET_2,
+	.stepping	= ICS_ARCIN_V6_IDESTEPPING,
 };
 
 struct icside_state {
 	unsigned int channel;
 	unsigned int enabled;
-	unsigned long irq_port;
-	unsigned long slot_port;
+	void __iomem *irq_port;
+	void __iomem *ioc_base;
 	unsigned int type;
 	/* parent device... until the IDE core gets one of its own */
 	struct device *dev;
@@ -87,9 +90,8 @@
 static void icside_irqenable_arcin_v5 (struct expansion_card *ec, int irqnr)
 {
 	struct icside_state *state = ec->irq_data;
-	unsigned int base = state->irq_port;
 
-	outb(0, base + ICS_ARCIN_V5_INTROFFSET);
+	writeb(0, state->irq_port + ICS_ARCIN_V5_INTROFFSET);
 }
 
 /* Prototype: icside_irqdisable_arcin_v5 (struct expansion_card *ec, int irqnr)
@@ -98,9 +100,8 @@
 static void icside_irqdisable_arcin_v5 (struct expansion_card *ec, int irqnr)
 {
 	struct icside_state *state = ec->irq_data;
-	unsigned int base = state->irq_port;
 
-	inb(base + ICS_ARCIN_V5_INTROFFSET);
+	readb(state->irq_port + ICS_ARCIN_V5_INTROFFSET);
 }
 
 static const expansioncard_ops_t icside_ops_arcin_v5 = {
@@ -116,18 +117,18 @@
 static void icside_irqenable_arcin_v6 (struct expansion_card *ec, int irqnr)
 {
 	struct icside_state *state = ec->irq_data;
-	unsigned int base = state->irq_port;
+	void __iomem *base = state->irq_port;
 
 	state->enabled = 1;
 
 	switch (state->channel) {
 	case 0:
-		outb(0, base + ICS_ARCIN_V6_INTROFFSET_1);
-		inb(base + ICS_ARCIN_V6_INTROFFSET_2);
+		writeb(0, base + ICS_ARCIN_V6_INTROFFSET_1);
+		readb(base + ICS_ARCIN_V6_INTROFFSET_2);
 		break;
 	case 1:
-		outb(0, base + ICS_ARCIN_V6_INTROFFSET_2);
-		inb(base + ICS_ARCIN_V6_INTROFFSET_1);
+		writeb(0, base + ICS_ARCIN_V6_INTROFFSET_2);
+		readb(base + ICS_ARCIN_V6_INTROFFSET_1);
 		break;
 	}
 }
@@ -141,8 +142,8 @@
 
 	state->enabled = 0;
 
-	inb (state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
-	inb (state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+	readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
+	readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
 }
 
 /* Prototype: icside_irqprobe(struct expansion_card *ec)
@@ -152,8 +153,8 @@
 {
 	struct icside_state *state = ec->irq_data;
 
-	return inb(state->irq_port + ICS_ARCIN_V6_INTRSTAT_1) & 1 ||
-	       inb(state->irq_port + ICS_ARCIN_V6_INTRSTAT_2) & 1;
+	return readb(state->irq_port + ICS_ARCIN_V6_INTRSTAT_1) & 1 ||
+	       readb(state->irq_port + ICS_ARCIN_V6_INTRSTAT_2) & 1;
 }
 
 static const expansioncard_ops_t icside_ops_arcin_v6 = {
@@ -179,23 +180,28 @@
 	if (state->enabled && !mask) {
 		switch (hwif->channel) {
 		case 0:
-			outb(0, state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
-			inb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+			writeb(0, state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
+			readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
 			break;
 		case 1:
-			outb(0, state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
-			inb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
+			writeb(0, state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+			readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
 			break;
 		}
 	} else {
-		inb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
-		inb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
+		readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+		readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
 	}
 
 	local_irq_restore(flags);
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_ICS
+
+#ifndef CONFIG_IDEDMA_ICS_AUTO
+#warning CONFIG_IDEDMA_ICS_AUTO=n support is obsolete, and will be removed soon.
+#endif
+
 /*
  * SG-DMA support.
  *
@@ -205,44 +211,24 @@
  * here, but we rely on the main IDE driver spotting that both
  * interfaces use the same IRQ, which should guarantee this.
  */
-#define NR_ENTRIES 256
-#define TABLE_SIZE (NR_ENTRIES * 8)
 
 static void icside_build_sglist(ide_drive_t *drive, struct request *rq)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	struct icside_state *state = hwif->hwif_data;
 	struct scatterlist *sg = hwif->sg_table;
-	int nents;
 
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-
-		if (args->command_type == IDE_DRIVE_TASK_RAW_WRITE)
-			hwif->sg_dma_direction = DMA_TO_DEVICE;
-		else
-			hwif->sg_dma_direction = DMA_FROM_DEVICE;
-
-		memset(sg, 0, sizeof(*sg));
-		sg->page   = virt_to_page(rq->buffer);
-		sg->offset = offset_in_page(rq->buffer);
-		sg->length = rq->nr_sectors * SECTOR_SIZE;
-		nents = 1;
-	} else {
-		nents = blk_rq_map_sg(drive->queue, rq, sg);
-
-		if (rq_data_dir(rq) == READ)
-			hwif->sg_dma_direction = DMA_FROM_DEVICE;
-		else
-			hwif->sg_dma_direction = DMA_TO_DEVICE;
-	}
+	ide_map_sg(drive, rq);
 
-	nents = dma_map_sg(state->dev, sg, nents, hwif->sg_dma_direction);
+	if (rq_data_dir(rq) == READ)
+		hwif->sg_dma_direction = DMA_FROM_DEVICE;
+	else
+		hwif->sg_dma_direction = DMA_TO_DEVICE;
 
-	hwif->sg_nents = nents;
+	hwif->sg_nents = dma_map_sg(state->dev, sg, hwif->sg_nents,
+				    hwif->sg_dma_direction);
 }
 
-
 /*
  * Configure the IOMD to give the appropriate timings for the transfer
  * mode being requested.  We take the advice of the ATA standards, and
@@ -402,50 +388,25 @@
 	return get_dma_residue(hwif->hw.dma) != 0;
 }
 
-static int icside_dma_begin(ide_drive_t *drive)
+static void icside_dma_start(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 
 	/* We can not enable DMA on both channels simultaneously. */
 	BUG_ON(dma_channel_active(hwif->hw.dma));
 	enable_dma(hwif->hw.dma);
-	return 0;
 }
 
-/*
- * dma_intr() is the handler for disk read/write DMA interrupts
- */
-static ide_startstop_t icside_dmaintr(ide_drive_t *drive)
-{
-	unsigned int stat;
-	int dma_stat;
-
-	dma_stat = icside_dma_end(drive);
-	stat = HWIF(drive)->INB(IDE_STATUS_REG);
-	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | DRQ_STAT)) {
-		if (!dma_stat) {
-			struct request *rq = HWGROUP(drive)->rq;
-			int i;
-
-			for (i = rq->nr_sectors; i > 0; ) {
-				i -= rq->current_nr_sectors;
-				DRIVER(drive)->end_request(drive, 1, rq->nr_sectors);
-			}
-
-			return ide_stopped;
-		}
-		printk(KERN_ERR "%s: bad DMA status (dma_stat=%x)\n",
-		       drive->name, dma_stat);
-	}
-
-	return DRIVER(drive)->error(drive, __FUNCTION__, stat);
-}
-
-static int
-icside_dma_common(ide_drive_t *drive, struct request *rq,
-		  unsigned int dma_mode)
+static int icside_dma_setup(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq = hwif->hwgroup->rq;
+	unsigned int dma_mode;
+
+	if (rq_data_dir(rq))
+		dma_mode = DMA_MODE_WRITE;
+	else
+		dma_mode = DMA_MODE_READ;
 
 	/*
 	 * We can not enable DMA on both channels.
@@ -462,7 +423,7 @@
 	/*
 	 * Route the DMA signals to the correct interface.
 	 */
-	outb(hwif->select_data, hwif->config_data);
+	writeb(hwif->select_data, hwif->config_data);
 
 	/*
 	 * Select the correct timing for this drive.
@@ -481,79 +442,10 @@
 	return 0;
 }
 
-static int icside_dma_read(ide_drive_t *drive)
+static void icside_dma_exec_cmd(ide_drive_t *drive, u8 cmd)
 {
-	struct request *rq = HWGROUP(drive)->rq;
-	task_ioreg_t cmd;
-
-	if (icside_dma_common(drive, rq, DMA_MODE_READ))
-		return 1;
-
-	if (drive->media != ide_disk)
-		return 0;
-
-	BUG_ON(HWGROUP(drive)->handler != NULL);
-
-	/*
-	 * FIX ME to use only ACB ide_task_t args Struct
-	 */
-#if 0
-	{
-		ide_task_t *args = rq->special;
-		cmd = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-#else
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		cmd = args->tfRegister[IDE_COMMAND_OFFSET];
-	} else if (drive->addressing == 1) {
-		cmd = WIN_READDMA_EXT;
-	} else {
-		cmd = WIN_READDMA;
-	}
-#endif
-	/* issue cmd to drive */
-	ide_execute_command(drive, cmd, icside_dmaintr, 2*WAIT_CMD, NULL);
-
-	return icside_dma_begin(drive);
-}
-
-static int icside_dma_write(ide_drive_t *drive)
-{
-	struct request *rq = HWGROUP(drive)->rq;
-	task_ioreg_t cmd;
-
-	if (icside_dma_common(drive, rq, DMA_MODE_WRITE))
-		return 1;
-
-	if (drive->media != ide_disk)
-		return 0;
-
-	BUG_ON(HWGROUP(drive)->handler != NULL);
-
-	/*
-	 * FIX ME to use only ACB ide_task_t args Struct
-	 */
-#if 0
-	{
-		ide_task_t *args = rq->special;
-		cmd = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-#else
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		cmd = args->tfRegister[IDE_COMMAND_OFFSET];
-	} else if (drive->addressing == 1) {
-		cmd = WIN_WRITEDMA_EXT;
-	} else {
-		cmd = WIN_WRITEDMA;
-	}
-#endif
-
 	/* issue cmd to drive */
-	ide_execute_command(drive, cmd, icside_dmaintr, 2*WAIT_CMD, NULL);
-
-	return icside_dma_begin(drive);
+	ide_execute_command(drive, cmd, ide_dma_intr, 2 * WAIT_CMD, NULL);
 }
 
 static int icside_dma_test_irq(ide_drive_t *drive)
@@ -561,20 +453,12 @@
 	ide_hwif_t *hwif = HWIF(drive);
 	struct icside_state *state = hwif->hwif_data;
 
-	return inb(state->irq_port +
-		   (hwif->channel ?
+	return readb(state->irq_port +
+		     (hwif->channel ?
 			ICS_ARCIN_V6_INTRSTAT_2 :
 			ICS_ARCIN_V6_INTRSTAT_1)) & 1;
 }
 
-static int icside_dma_verbose(ide_drive_t *drive)
-{
-	printk(", %s (peak %dMB/s)",
-		ide_xfer_verbose(drive->current_speed),
-		2000 / drive->drive_data);
-	return 1;
-}
-
 static int icside_dma_timeout(ide_drive_t *drive)
 {
 	printk(KERN_ERR "%s: DMA timeout occurred: ", drive->name);
@@ -594,7 +478,7 @@
 	return 1;
 }
 
-static int icside_dma_init(ide_hwif_t *hwif)
+static void icside_dma_init(ide_hwif_t *hwif)
 {
 	int autodma = 0;
 
@@ -604,11 +488,6 @@
 
 	printk("    %s: SG-DMA", hwif->name);
 
-	hwif->sg_table = kmalloc(sizeof(struct scatterlist) * NR_ENTRIES,
-				 GFP_KERNEL);
-	if (!hwif->sg_table)
-		goto failed;
-
 	hwif->atapi_dma		= 1;
 	hwif->mwdma_mask	= 7; /* MW0..2 */
 	hwif->swdma_mask	= 7; /* SW0..2 */
@@ -623,12 +502,11 @@
 	hwif->ide_dma_off_quietly = icside_dma_off_quietly;
 	hwif->ide_dma_host_on	= icside_dma_host_on;
 	hwif->ide_dma_on	= icside_dma_on;
-	hwif->ide_dma_read	= icside_dma_read;
-	hwif->ide_dma_write	= icside_dma_write;
-	hwif->ide_dma_begin	= icside_dma_begin;
+	hwif->dma_setup		= icside_dma_setup;
+	hwif->dma_exec_cmd	= icside_dma_exec_cmd;
+	hwif->dma_start		= icside_dma_start;
 	hwif->ide_dma_end	= icside_dma_end;
 	hwif->ide_dma_test_irq	= icside_dma_test_irq;
-	hwif->ide_dma_verbose	= icside_dma_verbose;
 	hwif->ide_dma_timeout	= icside_dma_timeout;
 	hwif->ide_dma_lostirq	= icside_dma_lostirq;
 
@@ -636,24 +514,9 @@
 	hwif->drives[1].autodma = hwif->autodma;
 
 	printk(" capable%s\n", hwif->autodma ? ", auto-enable" : "");
-
-	return 1;
-
-failed:
-	printk(" disabled, unable to allocate DMA table\n");
-	return 0;
-}
-
-static void icside_dma_exit(ide_hwif_t *hwif)
-{
-	if (hwif->sg_table) {
-		kfree(hwif->sg_table);
-		hwif->sg_table = NULL;
-	}
 }
 #else
 #define icside_dma_init(hwif)	(0)
-#define icside_dma_exit(hwif)	do { } while (0)
 #endif
 
 static ide_hwif_t *icside_find_hwif(unsigned long dataport)
@@ -679,24 +542,30 @@
 }
 
 static ide_hwif_t *
-icside_setup(unsigned long base, struct cardinfo *info, struct expansion_card *ec)
+icside_setup(void __iomem *base, struct cardinfo *info, struct expansion_card *ec)
 {
-	unsigned long port = base + info->dataoffset;
+	unsigned long port = (unsigned long)base + info->dataoffset;
 	ide_hwif_t *hwif;
 
-	hwif = icside_find_hwif(base);
+	hwif = icside_find_hwif(port);
 	if (hwif) {
 		int i;
 
 		memset(&hwif->hw, 0, sizeof(hw_regs_t));
 
+		/*
+		 * Ensure we're using MMIO
+		 */
+		default_hwif_mmiops(hwif);
+		hwif->mmio = 2;
+
 		for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
 			hwif->hw.io_ports[i] = port;
 			hwif->io_ports[i] = port;
 			port += 1 << info->stepping;
 		}
-		hwif->hw.io_ports[IDE_CONTROL_OFFSET] = base + info->ctrloffset;
-		hwif->io_ports[IDE_CONTROL_OFFSET] = base + info->ctrloffset;
+		hwif->hw.io_ports[IDE_CONTROL_OFFSET] = (unsigned long)base + info->ctrloffset;
+		hwif->io_ports[IDE_CONTROL_OFFSET] = (unsigned long)base + info->ctrloffset;
 		hwif->hw.irq  = ec->irq;
 		hwif->irq     = ec->irq;
 		hwif->noprobe = 0;
@@ -710,14 +579,17 @@
 static int __init
 icside_register_v5(struct icside_state *state, struct expansion_card *ec)
 {
-	unsigned long slot_port;
 	ide_hwif_t *hwif;
+	void __iomem *base;
 
-	slot_port = ecard_address(ec, ECARD_MEMC, 0);
+	base = ioremap(ecard_resource_start(ec, ECARD_RES_MEMC),
+		       ecard_resource_len(ec, ECARD_RES_MEMC));
+	if (!base)
+		return -ENOMEM;
 
-	state->irq_port = slot_port;
+	state->irq_port = base;
 
-	ec->irqaddr  = (unsigned char *)ioaddr(slot_port + ICS_ARCIN_V5_INTRSTAT);
+	ec->irqaddr  = base + ICS_ARCIN_V5_INTRSTAT;
 	ec->irqmask  = 1;
 	ec->irq_data = state;
 	ec->ops      = &icside_ops_arcin_v5;
@@ -725,61 +597,86 @@
 	/*
 	 * Be on the safe side - disable interrupts
 	 */
-	inb(slot_port + ICS_ARCIN_V5_INTROFFSET);
+	icside_irqdisable_arcin_v5(ec, 0);
 
-	hwif = icside_setup(slot_port, &icside_cardinfo_v5, ec);
+	hwif = icside_setup(base, &icside_cardinfo_v5, ec);
+	if (!hwif) {
+		iounmap(base);
+		return -ENODEV;
+	}
 
 	state->hwif[0] = hwif;
 
-	return hwif ? 0 : -ENODEV;
+	probe_hwif_init(hwif);
+	create_proc_ide_interfaces();
+
+	return 0;
 }
 
 static int __init
 icside_register_v6(struct icside_state *state, struct expansion_card *ec)
 {
-	unsigned long slot_port, port;
 	ide_hwif_t *hwif, *mate;
+	void __iomem *ioc_base, *easi_base;
 	unsigned int sel = 0;
+	int ret;
 
-	slot_port = ecard_address(ec, ECARD_IOC, ECARD_FAST);
-	port      = ecard_address(ec, ECARD_EASI, ECARD_FAST);
+	ioc_base = ioremap(ecard_resource_start(ec, ECARD_RES_IOCFAST),
+			   ecard_resource_len(ec, ECARD_RES_IOCFAST));
+	if (!ioc_base) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
-	if (port == 0)
-		port = slot_port;
-	else
+	easi_base = ioc_base;
+
+	if (ecard_resource_flags(ec, ECARD_RES_EASI)) {
+		easi_base = ioremap(ecard_resource_start(ec, ECARD_RES_EASI),
+				    ecard_resource_len(ec, ECARD_RES_EASI));
+		if (!easi_base) {
+			ret = -ENOMEM;
+			goto unmap_slot;
+		}
+
+		/*
+		 * Enable access to the EASI region.
+		 */
 		sel = 1 << 5;
+	}
+
+	writeb(sel, ioc_base);
+
+	ec->irq_data      = state;
+	ec->ops           = &icside_ops_arcin_v6;
 
-	outb(sel, slot_port);
+	state->irq_port   = easi_base;
+	state->ioc_base   = ioc_base;
 
 	/*
 	 * Be on the safe side - disable interrupts
 	 */
-	inb(port + ICS_ARCIN_V6_INTROFFSET_1);
-	inb(port + ICS_ARCIN_V6_INTROFFSET_2);
+	icside_irqdisable_arcin_v6(ec, 0);
 
 	/*
 	 * Find and register the interfaces.
 	 */
-	hwif = icside_setup(port, &icside_cardinfo_v6_1, ec);
-	mate = icside_setup(port, &icside_cardinfo_v6_2, ec);
+	hwif = icside_setup(easi_base, &icside_cardinfo_v6_1, ec);
+	mate = icside_setup(easi_base, &icside_cardinfo_v6_2, ec);
 
-	if (!hwif || !mate)
-		return -ENODEV;
+	if (!hwif || !mate) {
+		ret = -ENODEV;
+		goto unmap_port;
+	}
 
-	state->irq_port   = port;
-	state->slot_port  = slot_port;
 	state->hwif[0]    = hwif;
 	state->hwif[1]    = mate;
 
-	ec->irq_data      = state;
-	ec->ops           = &icside_ops_arcin_v6;
-
 	hwif->maskproc    = icside_maskproc;
 	hwif->channel     = 0;
 	hwif->hwif_data   = state;
 	hwif->mate        = mate;
 	hwif->serialized  = 1;
-	hwif->config_data = slot_port;
+	hwif->config_data = (unsigned long)ioc_base;
 	hwif->select_data = sel;
 	hwif->hw.dma      = ec->dma;
 
@@ -788,7 +685,7 @@
 	mate->hwif_data   = state;
 	mate->mate        = hwif;
 	mate->serialized  = 1;
-	mate->config_data = slot_port;
+	mate->config_data = (unsigned long)ioc_base;
 	mate->select_data = sel | 1;
 	mate->hw.dma      = ec->dma;
 
@@ -797,7 +694,19 @@
 		icside_dma_init(mate);
 	}
 
+	probe_hwif_init(hwif);
+	probe_hwif_init(mate);
+	create_proc_ide_interfaces();
+
 	return 0;
+
+ unmap_port:
+	if (easi_base != ioc_base)
+		iounmap(easi_base);
+ unmap_slot:
+	iounmap(ioc_base);
+ out:
+	return ret;
 }
 
 static int __devinit
@@ -807,10 +716,14 @@
 	void *idmem;
 	int ret;
 
+	ret = ecard_request_resources(ec);
+	if (ret)
+		goto out;
+
 	state = kmalloc(sizeof(struct icside_state), GFP_KERNEL);
 	if (!state) {
 		ret = -ENOMEM;
-		goto out;
+		goto release;
 	}
 
 	memset(state, 0, sizeof(state));
@@ -833,12 +746,12 @@
 
 	switch (state->type) {
 	case ICS_TYPE_A3IN:
-		printk(KERN_WARNING "icside: A3IN unsupported\n");
+		dev_warn(&ec->dev, "A3IN unsupported\n");
 		ret = -ENODEV;
 		break;
 
 	case ICS_TYPE_A3USER:
-		printk(KERN_WARNING "icside: A3USER unsupported\n");
+		dev_warn(&ec->dev, "A3USER unsupported\n");
 		ret = -ENODEV;
 		break;
 
@@ -851,15 +764,19 @@
 		break;
 
 	default:
-		printk(KERN_WARNING "icside: unknown interface type\n");
+		dev_warn(&ec->dev, "unknown interface type\n");
 		ret = -ENODEV;
 		break;
 	}
 
-	if (ret == 0)
+	if (ret == 0) {
 		ecard_set_drvdata(ec, state);
-	else
-		kfree(state);
+		goto out;
+	}
+
+	kfree(state);
+ release:
+	ecard_release_resources(ec);
  out:
 	return ret;
 }
@@ -873,23 +790,19 @@
 		/* FIXME: tell IDE to stop using the interface */
 
 		/* Disable interrupts */
-		inb(state->slot_port + ICS_ARCIN_V5_INTROFFSET);
+		icside_irqdisable_arcin_v5(ec, 0);
 		break;
 
 	case ICS_TYPE_V6:
 		/* FIXME: tell IDE to stop using the interface */
-		icside_dma_exit(state->hwif[1]);
-		icside_dma_exit(state->hwif[0]);
-
 		if (ec->dma != NO_DMA)
 			free_dma(ec->dma);
 
 		/* Disable interrupts */
-		inb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
-		inb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+		icside_irqdisable_arcin_v6(ec, 0);
 
 		/* Reset the ROM pointer/EASI selection */
-		outb(0, state->slot_port);
+		writeb(0, state->ioc_base);
 		break;
 	}
 
@@ -897,28 +810,36 @@
 	ec->ops = NULL;
 	ec->irq_data = NULL;
 
+	if (state->ioc_base)
+		iounmap(state->ioc_base);
+	if (state->ioc_base != state->irq_port)
+		iounmap(state->irq_port);
+
 	kfree(state);
+	ecard_release_resources(ec);
 }
 
 static void icside_shutdown(struct expansion_card *ec)
 {
 	struct icside_state *state = ecard_get_drvdata(ec);
+	unsigned long flags;
 
-	switch (state->type) {
-	case ICS_TYPE_V5:
-		/* Disable interrupts */
-		inb(state->slot_port + ICS_ARCIN_V5_INTROFFSET);
-		break;
-
-	case ICS_TYPE_V6:
-		/* Disable interrupts */
-		inb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
-		inb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+	/*
+	 * Disable interrupts from this card.  We need to do
+	 * this before disabling EASI since we may be accessing
+	 * this register via that region.
+	 */
+	local_irq_save(flags);
+	ec->ops->irqdisable(ec, 0);
+	local_irq_restore(flags);
 
-		/* Reset the ROM pointer/EASI selection */
-		outb(0, state->slot_port);
-		break;
-	}
+	/*
+	 * Reset the ROM pointer so that we can read the ROM
+	 * after a soft reboot.  This also disables access to
+	 * the IDE taskfile via the EASI region.
+	 */
+	if (state->ioc_base)
+		writeb(0, state->ioc_base);
 }
 
 static const struct ecard_id icside_ids[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/arm/rapide.c linuxppc-2.6.9-dream/drivers/ide/arm/rapide.c
--- linuxppc-2.6.9/drivers/ide/arm/rapide.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/arm/rapide.c	2005-06-20 10:46:10.000000000 +0200
@@ -13,32 +13,91 @@
 
 #include <asm/ecard.h>
 
-static int __devinit
-rapide_probe(struct expansion_card *ec, const struct ecard_id *id)
+/*
+ * Something like this really should be in generic code, but isn't.
+ */
+static ide_hwif_t *
+rapide_locate_hwif(void __iomem *base, void *ctrl, unsigned int sz, int irq)
 {
-	unsigned long port = ecard_address (ec, ECARD_MEMC, 0);
-	hw_regs_t hw;
-	int i, ret;
+	unsigned long port = (unsigned long)base;
+	ide_hwif_t *hwif;
+	int index, i;
+
+	for (index = 0; index < MAX_HWIFS; ++index) {
+		hwif = ide_hwifs + index;
+		if (hwif->io_ports[IDE_DATA_OFFSET] == port)
+			goto found;
+	}
+
+	for (index = 0; index < MAX_HWIFS; ++index) {
+		hwif = ide_hwifs + index;
+		if (hwif->io_ports[IDE_DATA_OFFSET] == 0)
+			goto found;
+	}
 
-	memset(&hw, 0, sizeof(hw));
+	return NULL;
 
+ found:
 	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
-		hw.io_ports[i] = port;
-		port += 1 << 4;
+		hwif->hw.io_ports[i] = port;
+		hwif->io_ports[i] = port;
+		port += sz;
 	}
-	hw.io_ports[IDE_CONTROL_OFFSET] = port + 0x206;
-	hw.irq = ec->irq;
+	hwif->hw.io_ports[IDE_CONTROL_OFFSET] = (unsigned long)ctrl;
+	hwif->io_ports[IDE_CONTROL_OFFSET] = (unsigned long)ctrl;
+	hwif->hw.irq = hwif->irq = irq;
+	hwif->mmio = 2;
+	default_hwif_mmiops(hwif);
 
-	ret = ide_register_hw(&hw, NULL);
+	return hwif;
+}
 
+static int __devinit
+rapide_probe(struct expansion_card *ec, const struct ecard_id *id)
+{
+	ide_hwif_t *hwif;
+	void __iomem *base;
+	int ret;
+
+	ret = ecard_request_resources(ec);
 	if (ret)
-		ecard_release(ec);
+		goto out;
+
+	base = ioremap(ecard_resource_start(ec, ECARD_RES_MEMC),
+		       ecard_resource_len(ec, ECARD_RES_MEMC));
+	if (!base) {
+		ret = -ENOMEM;
+		goto release;
+	}
+
+	hwif = rapide_locate_hwif(base, base + 0x818, 1 << 6, ec->irq);
+	if (hwif) {
+		hwif->hwif_data = base;
+		hwif->gendev.parent = &ec->dev;
+		hwif->noprobe = 0;
+		probe_hwif_init(hwif);
+		create_proc_ide_interfaces();
+		ecard_set_drvdata(ec, hwif);
+		goto out;
+	}
+
+	iounmap(base);
+ release:
+	ecard_release_resources(ec);
+ out:
 	return ret;
 }
 
 static void __devexit rapide_remove(struct expansion_card *ec)
 {
-	/* need to do more */
+	ide_hwif_t *hwif = ecard_get_drvdata(ec);
+
+	ecard_set_drvdata(ec, NULL);
+
+	/* there must be a better way */
+	ide_unregister(hwif - ide_hwifs);
+	iounmap(hwif->hwif_data);
+	ecard_release_resources(ec);
 }
 
 static struct ecard_id rapide_ids[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/cris/ide-v10.c linuxppc-2.6.9-dream/drivers/ide/cris/ide-v10.c
--- linuxppc-2.6.9/drivers/ide/cris/ide-v10.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/ide/cris/ide-v10.c	2005-06-20 10:46:10.000000000 +0200
@@ -0,0 +1,842 @@
+/* $Id: ide.c,v 1.4 2004/10/12 07:55:48 starvik Exp $
+ *
+ * Etrax specific IDE functions, like init and PIO-mode setting etc.
+ * Almost the entire ide.c is used for the rest of the Etrax ATA driver.
+ * Copyright (c) 2000-2004 Axis Communications AB
+ *
+ * Authors:    Bjorn Wesen        (initial version)
+ *             Mikael Starvik     (pio setup stuff, Linux 2.6 port)
+ */
+
+/* Regarding DMA:
+ *
+ * There are two forms of DMA - "DMA handshaking" between the interface and the drive,
+ * and DMA between the memory and the interface. We can ALWAYS use the latter, since it's
+ * something built-in in the Etrax. However only some drives support the DMA-mode handshaking
+ * on the ATA-bus. The normal PC driver and Triton interface disables memory-if DMA when the
+ * device can't do DMA handshaking for some stupid reason. We don't need to do that.
+ */
+
+#undef REALLY_SLOW_IO           /* most systems can safely undef this */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/blkdev.h>
+#include <linux/hdreg.h>
+#include <linux/ide.h>
+#include <linux/init.h>
+#include <linux/scatterlist.h>
+
+#include <asm/io.h>
+#include <asm/arch/svinto.h>
+#include <asm/dma.h>
+
+/* number of Etrax DMA descriptors */
+#define MAX_DMA_DESCRS 64
+
+/* number of times to retry busy-flags when reading/writing IDE-registers
+ * this can't be too high because a hung harddisk might cause the watchdog
+ * to trigger (sometimes INB and OUTB are called with irq's disabled)
+ */
+
+#define IDE_REGISTER_TIMEOUT 300
+
+static int e100_read_command = 0;
+
+#define LOWDB(x)
+#define D(x)
+
+static int e100_ide_build_dmatable (ide_drive_t *drive);
+static ide_startstop_t etrax_dma_intr (ide_drive_t *drive);
+
+void
+etrax100_ide_outw(unsigned short data, unsigned long reg) {
+	int timeleft;
+	LOWDB(printk("ow: data 0x%x, reg 0x%x\n", data, reg));
+
+	/* note the lack of handling any timeouts. we stop waiting, but we don't
+	 * really notify anybody.
+	 */
+
+	timeleft = IDE_REGISTER_TIMEOUT;
+	/* wait for busy flag */
+	while(timeleft && (*R_ATA_STATUS_DATA & IO_MASK(R_ATA_STATUS_DATA, busy)))
+		timeleft--;
+
+	/*
+	 * Fall through at a timeout, so the ongoing command will be
+	 * aborted by the write below, which is expected to be a dummy
+	 * command to the command register.  This happens when a faulty
+	 * drive times out on a command.  See comment on timeout in
+	 * INB.
+	 */
+	if(!timeleft)
+		printk("ATA timeout reg 0x%lx := 0x%x\n", reg, data);
+
+	*R_ATA_CTRL_DATA = reg | data; /* write data to the drive's register */
+
+	timeleft = IDE_REGISTER_TIMEOUT;
+	/* wait for transmitter ready */
+	while(timeleft && !(*R_ATA_STATUS_DATA &
+			    IO_MASK(R_ATA_STATUS_DATA, tr_rdy)))
+		timeleft--;
+}
+
+void
+etrax100_ide_outb(unsigned char data, unsigned long reg)
+{
+	etrax100_ide_outw(data, reg);
+}
+
+void
+etrax100_ide_outbsync(ide_drive_t *drive, u8 addr, unsigned long port)
+{
+	etrax100_ide_outw(addr, port);
+}
+
+unsigned short
+etrax100_ide_inw(unsigned long reg) {
+	int status;
+	int timeleft;
+
+	timeleft = IDE_REGISTER_TIMEOUT;
+	/* wait for busy flag */
+	while(timeleft && (*R_ATA_STATUS_DATA & IO_MASK(R_ATA_STATUS_DATA, busy)))
+		timeleft--;
+
+	if(!timeleft) {
+		/*
+		 * If we're asked to read the status register, like for
+		 * example when a command does not complete for an
+		 * extended time, but the ATA interface is stuck in a
+		 * busy state at the *ETRAX* ATA interface level (as has
+		 * happened repeatedly with at least one bad disk), then
+		 * the best thing to do is to pretend that we read
+		 * "busy" in the status register, so the IDE driver will
+		 * time-out, abort the ongoing command and perform a
+		 * reset sequence.  Note that the subsequent OUT_BYTE
+		 * call will also timeout on busy, but as long as the
+		 * write is still performed, everything will be fine.
+		 */
+		if ((reg & IO_MASK (R_ATA_CTRL_DATA, addr))
+		    == IO_FIELD (R_ATA_CTRL_DATA, addr, IDE_STATUS_OFFSET))
+			return BUSY_STAT;
+		else
+			/* For other rare cases we assume 0 is good enough.  */
+			return 0;
+	}
+
+	*R_ATA_CTRL_DATA = reg | IO_STATE(R_ATA_CTRL_DATA, rw, read); /* read data */
+
+	timeleft = IDE_REGISTER_TIMEOUT;
+	/* wait for available */
+	while(timeleft && !((status = *R_ATA_STATUS_DATA) &
+			    IO_MASK(R_ATA_STATUS_DATA, dav)))
+		timeleft--;
+
+	if(!timeleft)
+		return 0;
+
+	LOWDB(printk("inb: 0x%x from reg 0x%x\n", status & 0xff, reg));
+
+        return (unsigned short)status;
+}
+
+unsigned char
+etrax100_ide_inb(unsigned long reg)
+{
+	return (unsigned char)etrax100_ide_inw(reg);
+}
+
+/* PIO timing (in R_ATA_CONFIG)
+ *
+ *                        _____________________________
+ * ADDRESS :     ________/
+ *
+ *                            _______________
+ * DIOR    :     ____________/               \__________
+ *
+ *                               _______________
+ * DATA    :     XXXXXXXXXXXXXXXX_______________XXXXXXXX
+ *
+ *
+ * DIOR is unbuffered while address and data is buffered.
+ * This creates two problems:
+ * 1. The DIOR pulse is to early (because it is unbuffered)
+ * 2. The rise time of DIOR is long
+ *
+ * There are at least three different plausible solutions
+ * 1. Use a pad capable of larger currents in Etrax
+ * 2. Use an external buffer
+ * 3. Make the strobe pulse longer
+ *
+ * Some of the strobe timings below are modified to compensate
+ * for this. This implies a slight performance decrease.
+ *
+ * THIS SHOULD NEVER BE CHANGED!
+ *
+ * TODO: Is this true for the latest LX boards still ?
+ */
+
+#define ATA_DMA2_STROBE  4
+#define ATA_DMA2_HOLD    0
+#define ATA_DMA1_STROBE  4
+#define ATA_DMA1_HOLD    1
+#define ATA_DMA0_STROBE 12
+#define ATA_DMA0_HOLD    9
+#define ATA_PIO4_SETUP   1
+#define ATA_PIO4_STROBE  5
+#define ATA_PIO4_HOLD    0
+#define ATA_PIO3_SETUP   1
+#define ATA_PIO3_STROBE  5
+#define ATA_PIO3_HOLD    1
+#define ATA_PIO2_SETUP   1
+#define ATA_PIO2_STROBE  6
+#define ATA_PIO2_HOLD    2
+#define ATA_PIO1_SETUP   2
+#define ATA_PIO1_STROBE 11
+#define ATA_PIO1_HOLD    4
+#define ATA_PIO0_SETUP   4
+#define ATA_PIO0_STROBE 19
+#define ATA_PIO0_HOLD    4
+
+static int e100_dma_check (ide_drive_t *drive);
+static void e100_dma_start(ide_drive_t *drive);
+static int e100_dma_end (ide_drive_t *drive);
+static void e100_ide_input_data (ide_drive_t *drive, void *, unsigned int);
+static void e100_ide_output_data (ide_drive_t *drive, void *, unsigned int);
+static void e100_atapi_input_bytes(ide_drive_t *drive, void *, unsigned int);
+static void e100_atapi_output_bytes(ide_drive_t *drive, void *, unsigned int);
+static int e100_dma_off (ide_drive_t *drive);
+
+
+/*
+ * good_dma_drives() lists the model names (from "hdparm -i")
+ * of drives which do not support mword2 DMA but which are
+ * known to work fine with this interface under Linux.
+ */
+
+const char *good_dma_drives[] = {"Micropolis 2112A",
+				 "CONNER CTMA 4000",
+				 "CONNER CTT8000-A",
+				 NULL};
+
+static void tune_e100_ide(ide_drive_t *drive, byte pio)
+{
+	pio = 4;
+	/* pio = ide_get_best_pio_mode(drive, pio, 4, NULL); */
+
+	/* set pio mode! */
+
+	switch(pio) {
+		case 0:
+			*R_ATA_CONFIG = ( IO_FIELD( R_ATA_CONFIG, enable,     1 ) |
+					  IO_FIELD( R_ATA_CONFIG, dma_strobe, ATA_DMA2_STROBE ) |
+					  IO_FIELD( R_ATA_CONFIG, dma_hold,   ATA_DMA2_HOLD ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_setup,  ATA_PIO0_SETUP ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_strobe, ATA_PIO0_STROBE ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_hold,   ATA_PIO0_HOLD ) );
+			break;
+		case 1:
+			*R_ATA_CONFIG = ( IO_FIELD( R_ATA_CONFIG, enable,     1 ) |
+					  IO_FIELD( R_ATA_CONFIG, dma_strobe, ATA_DMA2_STROBE ) |
+					  IO_FIELD( R_ATA_CONFIG, dma_hold,   ATA_DMA2_HOLD ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_setup,  ATA_PIO1_SETUP ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_strobe, ATA_PIO1_STROBE ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_hold,   ATA_PIO1_HOLD ) );
+			break;
+		case 2:
+			*R_ATA_CONFIG = ( IO_FIELD( R_ATA_CONFIG, enable,     1 ) |
+					  IO_FIELD( R_ATA_CONFIG, dma_strobe, ATA_DMA2_STROBE ) |
+					  IO_FIELD( R_ATA_CONFIG, dma_hold,   ATA_DMA2_HOLD ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_setup,  ATA_PIO2_SETUP ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_strobe, ATA_PIO2_STROBE ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_hold,   ATA_PIO2_HOLD ) );
+			break;
+		case 3:
+			*R_ATA_CONFIG = ( IO_FIELD( R_ATA_CONFIG, enable,     1 ) |
+					  IO_FIELD( R_ATA_CONFIG, dma_strobe, ATA_DMA2_STROBE ) |
+					  IO_FIELD( R_ATA_CONFIG, dma_hold,   ATA_DMA2_HOLD ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_setup,  ATA_PIO3_SETUP ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_strobe, ATA_PIO3_STROBE ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_hold,   ATA_PIO3_HOLD ) );
+			break;
+		case 4:
+			*R_ATA_CONFIG = ( IO_FIELD( R_ATA_CONFIG, enable,     1 ) |
+					  IO_FIELD( R_ATA_CONFIG, dma_strobe, ATA_DMA2_STROBE ) |
+					  IO_FIELD( R_ATA_CONFIG, dma_hold,   ATA_DMA2_HOLD ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_setup,  ATA_PIO4_SETUP ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_strobe, ATA_PIO4_STROBE ) |
+					  IO_FIELD( R_ATA_CONFIG, pio_hold,   ATA_PIO4_HOLD ) );
+			break;
+	}
+}
+
+static int e100_dma_setup(ide_drive_t *drive)
+{
+	struct request *rq = drive->hwif->hwgroup->rq;
+
+	if (rq_data_dir(rq)) {
+		e100_read_command = 0;
+
+		RESET_DMA(ATA_TX_DMA_NBR); /* sometimes the DMA channel get stuck so we need to do this */
+		WAIT_DMA(ATA_TX_DMA_NBR);
+	} else {
+		e100_read_command = 1;
+
+		RESET_DMA(ATA_RX_DMA_NBR); /* sometimes the DMA channel get stuck so we need to do this */
+		WAIT_DMA(ATA_RX_DMA_NBR);
+	}
+
+	/* set up the Etrax DMA descriptors */
+	if (e100_ide_build_dmatable(drive)) {
+		ide_map_sg(drive, rq);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void e100_dma_exec_cmd(ide_drive_t *drive, u8 command)
+{
+	/* set the irq handler which will finish the request when DMA is done */
+	ide_set_handler(drive, &etrax_dma_intr, WAIT_CMD, NULL);
+
+	/* issue cmd to drive */
+	etrax100_ide_outb(command, IDE_COMMAND_REG);
+}
+
+void __init
+init_e100_ide (void)
+{
+	volatile unsigned int dummy;
+	int h;
+
+	printk("ide: ETRAX 100LX built-in ATA DMA controller\n");
+
+	/* first fill in some stuff in the ide_hwifs fields */
+
+	for(h = 0; h < MAX_HWIFS; h++) {
+		ide_hwif_t *hwif = &ide_hwifs[h];
+		hwif->mmio = 2;
+		hwif->chipset = ide_etrax100;
+		hwif->tuneproc = &tune_e100_ide;
+                hwif->ata_input_data = &e100_ide_input_data;
+                hwif->ata_output_data = &e100_ide_output_data;
+                hwif->atapi_input_bytes = &e100_atapi_input_bytes;
+                hwif->atapi_output_bytes = &e100_atapi_output_bytes;
+                hwif->ide_dma_check = &e100_dma_check;
+                hwif->ide_dma_end = &e100_dma_end;
+		hwif->dma_setup = &e100_dma_setup;
+		hwif->dma_exec_cmd = &e100_dma_exec_cmd;
+		hwif->dma_start = &e100_dma_start;
+		hwif->OUTB = &etrax100_ide_outb;
+		hwif->OUTW = &etrax100_ide_outw;
+		hwif->OUTBSYNC = &etrax100_ide_outbsync;
+		hwif->INB = &etrax100_ide_inb;
+		hwif->INW = &etrax100_ide_inw;
+		hwif->ide_dma_off_quietly = &e100_dma_off;
+	}
+
+	/* actually reset and configure the etrax100 ide/ata interface */
+
+	*R_ATA_CTRL_DATA = 0;
+	*R_ATA_TRANSFER_CNT = 0;
+	*R_ATA_CONFIG = 0;
+
+	genconfig_shadow = (genconfig_shadow &
+			    ~IO_MASK(R_GEN_CONFIG, dma2) &
+			    ~IO_MASK(R_GEN_CONFIG, dma3) &
+			    ~IO_MASK(R_GEN_CONFIG, ata)) |
+		( IO_STATE( R_GEN_CONFIG, dma3, ata    ) |
+		  IO_STATE( R_GEN_CONFIG, dma2, ata    ) |
+		  IO_STATE( R_GEN_CONFIG, ata,  select ) );
+
+	*R_GEN_CONFIG = genconfig_shadow;
+
+        /* pull the chosen /reset-line low */
+
+#ifdef CONFIG_ETRAX_IDE_G27_RESET
+        REG_SHADOW_SET(R_PORT_G_DATA, port_g_data_shadow, 27, 0);
+#endif
+#ifdef CONFIG_ETRAX_IDE_CSE1_16_RESET
+        REG_SHADOW_SET(port_cse1_addr, port_cse1_shadow, 16, 0);
+#endif
+#ifdef CONFIG_ETRAX_IDE_CSP0_8_RESET
+        REG_SHADOW_SET(port_csp0_addr, port_csp0_shadow, 8, 0);
+#endif
+#ifdef CONFIG_ETRAX_IDE_PB7_RESET
+	port_pb_dir_shadow = port_pb_dir_shadow |
+		IO_STATE(R_PORT_PB_DIR, dir7, output);
+	*R_PORT_PB_DIR = port_pb_dir_shadow;
+	REG_SHADOW_SET(R_PORT_PB_DATA, port_pb_data_shadow, 7, 1);
+#endif
+
+	/* wait some */
+
+	udelay(25);
+
+	/* de-assert bus-reset */
+
+#ifdef CONFIG_ETRAX_IDE_CSE1_16_RESET
+	REG_SHADOW_SET(port_cse1_addr, port_cse1_shadow, 16, 1);
+#endif
+#ifdef CONFIG_ETRAX_IDE_CSP0_8_RESET
+	REG_SHADOW_SET(port_csp0_addr, port_csp0_shadow, 8, 1);
+#endif
+#ifdef CONFIG_ETRAX_IDE_G27_RESET
+	REG_SHADOW_SET(R_PORT_G_DATA, port_g_data_shadow, 27, 1);
+#endif
+
+	/* make a dummy read to set the ata controller in a proper state */
+	dummy = *R_ATA_STATUS_DATA;
+
+	*R_ATA_CONFIG = ( IO_FIELD( R_ATA_CONFIG, enable,     1 ) |
+			  IO_FIELD( R_ATA_CONFIG, dma_strobe, ATA_DMA2_STROBE ) |
+			  IO_FIELD( R_ATA_CONFIG, dma_hold,   ATA_DMA2_HOLD ) |
+			  IO_FIELD( R_ATA_CONFIG, pio_setup,  ATA_PIO4_SETUP ) |
+			  IO_FIELD( R_ATA_CONFIG, pio_strobe, ATA_PIO4_STROBE ) |
+			  IO_FIELD( R_ATA_CONFIG, pio_hold,   ATA_PIO4_HOLD ) );
+
+	*R_ATA_CTRL_DATA = ( IO_STATE( R_ATA_CTRL_DATA, rw,   read) |
+			     IO_FIELD( R_ATA_CTRL_DATA, addr, 1   ) );
+
+	while(*R_ATA_STATUS_DATA & IO_MASK(R_ATA_STATUS_DATA, busy)); /* wait for busy flag*/
+
+	*R_IRQ_MASK0_SET = ( IO_STATE( R_IRQ_MASK0_SET, ata_irq0, set ) |
+			     IO_STATE( R_IRQ_MASK0_SET, ata_irq1, set ) |
+			     IO_STATE( R_IRQ_MASK0_SET, ata_irq2, set ) |
+			     IO_STATE( R_IRQ_MASK0_SET, ata_irq3, set ) );
+
+	printk("ide: waiting %d seconds for drives to regain consciousness\n",
+	       CONFIG_ETRAX_IDE_DELAY);
+
+	h = jiffies + (CONFIG_ETRAX_IDE_DELAY * HZ);
+	while(time_before(jiffies, h)) /* nothing */ ;
+
+	/* reset the dma channels we will use */
+
+	RESET_DMA(ATA_TX_DMA_NBR);
+	RESET_DMA(ATA_RX_DMA_NBR);
+	WAIT_DMA(ATA_TX_DMA_NBR);
+	WAIT_DMA(ATA_RX_DMA_NBR);
+
+}
+
+static int e100_dma_off (ide_drive_t *drive)
+{
+	return 0;
+}
+
+static etrax_dma_descr mydescr;
+
+/*
+ * The following routines are mainly used by the ATAPI drivers.
+ *
+ * These routines will round up any request for an odd number of bytes,
+ * so if an odd bytecount is specified, be sure that there's at least one
+ * extra byte allocated for the buffer.
+ */
+static void
+e100_atapi_input_bytes (ide_drive_t *drive, void *buffer, unsigned int bytecount)
+{
+	unsigned long data_reg = IDE_DATA_REG;
+
+	D(printk("atapi_input_bytes, dreg 0x%x, buffer 0x%x, count %d\n",
+		 data_reg, buffer, bytecount));
+
+	if(bytecount & 1) {
+		printk("warning, odd bytecount in cdrom_in_bytes = %d.\n", bytecount);
+		bytecount++; /* to round off */
+	}
+
+	/* make sure the DMA channel is available */
+	RESET_DMA(ATA_RX_DMA_NBR);
+	WAIT_DMA(ATA_RX_DMA_NBR);
+
+	/* setup DMA descriptor */
+
+	mydescr.sw_len = bytecount;
+	mydescr.ctrl   = d_eol;
+	mydescr.buf    = virt_to_phys(buffer);
+
+	/* start the dma channel */
+
+	*R_DMA_CH3_FIRST = virt_to_phys(&mydescr);
+	*R_DMA_CH3_CMD   = IO_STATE(R_DMA_CH3_CMD, cmd, start);
+
+	/* initiate a multi word dma read using PIO handshaking */
+
+	*R_ATA_TRANSFER_CNT = IO_FIELD(R_ATA_TRANSFER_CNT, count, bytecount >> 1);
+
+	*R_ATA_CTRL_DATA = data_reg |
+		IO_STATE(R_ATA_CTRL_DATA, rw,       read) |
+		IO_STATE(R_ATA_CTRL_DATA, src_dst,  dma) |
+		IO_STATE(R_ATA_CTRL_DATA, handsh,   pio) |
+		IO_STATE(R_ATA_CTRL_DATA, multi,    on) |
+		IO_STATE(R_ATA_CTRL_DATA, dma_size, word);
+
+	/* wait for completion */
+
+	LED_DISK_READ(1);
+	WAIT_DMA(ATA_RX_DMA_NBR);
+	LED_DISK_READ(0);
+
+#if 0
+        /* old polled transfer code
+	 * this should be moved into a new function that can do polled
+	 * transfers if DMA is not available
+	 */
+
+        /* initiate a multi word read */
+
+        *R_ATA_TRANSFER_CNT = wcount << 1;
+
+        *R_ATA_CTRL_DATA = data_reg |
+                IO_STATE(R_ATA_CTRL_DATA, rw,       read) |
+                IO_STATE(R_ATA_CTRL_DATA, src_dst,  register) |
+                IO_STATE(R_ATA_CTRL_DATA, handsh,   pio) |
+                IO_STATE(R_ATA_CTRL_DATA, multi,    on) |
+                IO_STATE(R_ATA_CTRL_DATA, dma_size, word);
+
+        /* svinto has a latency until the busy bit actually is set */
+
+        nop(); nop();
+        nop(); nop();
+        nop(); nop();
+        nop(); nop();
+        nop(); nop();
+
+        /* unit should be busy during multi transfer */
+        while((status = *R_ATA_STATUS_DATA) & IO_MASK(R_ATA_STATUS_DATA, busy)) {
+                while(!(status & IO_MASK(R_ATA_STATUS_DATA, dav)))
+                        status = *R_ATA_STATUS_DATA;
+                *ptr++ = (unsigned short)(status & 0xffff);
+        }
+#endif
+}
+
+static void
+e100_atapi_output_bytes (ide_drive_t *drive, void *buffer, unsigned int bytecount)
+{
+	unsigned long data_reg = IDE_DATA_REG;
+
+	D(printk("atapi_output_bytes, dreg 0x%x, buffer 0x%x, count %d\n",
+		 data_reg, buffer, bytecount));
+
+	if(bytecount & 1) {
+		printk("odd bytecount %d in atapi_out_bytes!\n", bytecount);
+		bytecount++;
+	}
+
+	/* make sure the DMA channel is available */
+	RESET_DMA(ATA_TX_DMA_NBR);
+	WAIT_DMA(ATA_TX_DMA_NBR);
+
+	/* setup DMA descriptor */
+
+	mydescr.sw_len = bytecount;
+	mydescr.ctrl   = d_eol;
+	mydescr.buf    = virt_to_phys(buffer);
+
+	/* start the dma channel */
+
+	*R_DMA_CH2_FIRST = virt_to_phys(&mydescr);
+	*R_DMA_CH2_CMD   = IO_STATE(R_DMA_CH2_CMD, cmd, start);
+
+	/* initiate a multi word dma write using PIO handshaking */
+
+	*R_ATA_TRANSFER_CNT = IO_FIELD(R_ATA_TRANSFER_CNT, count, bytecount >> 1);
+
+	*R_ATA_CTRL_DATA = data_reg |
+		IO_STATE(R_ATA_CTRL_DATA, rw,       write) |
+		IO_STATE(R_ATA_CTRL_DATA, src_dst,  dma) |
+		IO_STATE(R_ATA_CTRL_DATA, handsh,   pio) |
+		IO_STATE(R_ATA_CTRL_DATA, multi,    on) |
+		IO_STATE(R_ATA_CTRL_DATA, dma_size, word);
+
+	/* wait for completion */
+
+	LED_DISK_WRITE(1);
+	WAIT_DMA(ATA_TX_DMA_NBR);
+	LED_DISK_WRITE(0);
+
+#if 0
+        /* old polled write code - see comment in input_bytes */
+
+	/* wait for busy flag */
+        while(*R_ATA_STATUS_DATA & IO_MASK(R_ATA_STATUS_DATA, busy));
+
+        /* initiate a multi word write */
+
+        *R_ATA_TRANSFER_CNT = bytecount >> 1;
+
+        ctrl = data_reg |
+                IO_STATE(R_ATA_CTRL_DATA, rw,       write) |
+                IO_STATE(R_ATA_CTRL_DATA, src_dst,  register) |
+                IO_STATE(R_ATA_CTRL_DATA, handsh,   pio) |
+                IO_STATE(R_ATA_CTRL_DATA, multi,    on) |
+                IO_STATE(R_ATA_CTRL_DATA, dma_size, word);
+
+        LED_DISK_WRITE(1);
+
+        /* Etrax will set busy = 1 until the multi pio transfer has finished
+         * and tr_rdy = 1 after each successful word transfer.
+         * When the last byte has been transferred Etrax will first set tr_tdy = 1
+         * and then busy = 0 (not in the same cycle). If we read busy before it
+         * has been set to 0 we will think that we should transfer more bytes
+         * and then tr_rdy would be 0 forever. This is solved by checking busy
+         * in the inner loop.
+         */
+
+        do {
+                *R_ATA_CTRL_DATA = ctrl | *ptr++;
+                while(!(*R_ATA_STATUS_DATA & IO_MASK(R_ATA_STATUS_DATA, tr_rdy)) &&
+                      (*R_ATA_STATUS_DATA & IO_MASK(R_ATA_STATUS_DATA, busy)));
+        } while(*R_ATA_STATUS_DATA & IO_MASK(R_ATA_STATUS_DATA, busy));
+
+        LED_DISK_WRITE(0);
+#endif
+
+}
+
+/*
+ * This is used for most PIO data transfers *from* the IDE interface
+ */
+static void
+e100_ide_input_data (ide_drive_t *drive, void *buffer, unsigned int wcount)
+{
+	e100_atapi_input_bytes(drive, buffer, wcount << 2);
+}
+
+/*
+ * This is used for most PIO data transfers *to* the IDE interface
+ */
+static void
+e100_ide_output_data (ide_drive_t *drive, void *buffer, unsigned int wcount)
+{
+	e100_atapi_output_bytes(drive, buffer, wcount << 2);
+}
+
+/* we only have one DMA channel on the chip for ATA, so we can keep these statically */
+static etrax_dma_descr ata_descrs[MAX_DMA_DESCRS];
+static unsigned int ata_tot_size;
+
+/*
+ * e100_ide_build_dmatable() prepares a dma request.
+ * Returns 0 if all went okay, returns 1 otherwise.
+ */
+static int e100_ide_build_dmatable (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct scatterlist* sg;
+	struct request *rq  = HWGROUP(drive)->rq;
+	unsigned long size, addr;
+	unsigned int count = 0;
+	int i = 0;
+
+	sg = hwif->sg_table;
+
+	ata_tot_size = 0;
+
+	ide_map_sg(drive, rq);
+
+	i = hwif->sg_nents;
+
+	while(i) {
+		/*
+		 * Determine addr and size of next buffer area.  We assume that
+		 * individual virtual buffers are always composed linearly in
+		 * physical memory.  For example, we assume that any 8kB buffer
+		 * is always composed of two adjacent physical 4kB pages rather
+		 * than two possibly non-adjacent physical 4kB pages.
+		 */
+		/* group sequential buffers into one large buffer */
+		addr = page_to_phys(sg->page) + sg->offset;
+		size = sg_dma_len(sg);
+		while (sg++, --i) {
+			if ((addr + size) != page_to_phys(sg->page) + sg->offset)
+				break;
+			size += sg_dma_len(sg);
+		}
+
+		/* did we run out of descriptors? */
+
+		if(count >= MAX_DMA_DESCRS) {
+			printk("%s: too few DMA descriptors\n", drive->name);
+			return 1;
+		}
+
+		/* however, this case is more difficult - R_ATA_TRANSFER_CNT cannot be more
+		   than 65536 words per transfer, so in that case we need to either
+		   1) use a DMA interrupt to re-trigger R_ATA_TRANSFER_CNT and continue with
+		      the descriptors, or
+		   2) simply do the request here, and get dma_intr to only ide_end_request on
+		      those blocks that were actually set-up for transfer.
+		*/
+
+		if(ata_tot_size + size > 131072) {
+			printk("too large total ATA DMA request, %d + %d!\n", ata_tot_size, (int)size);
+			return 1;
+		}
+
+		/* If size > 65536 it has to be splitted into new descriptors. Since we don't handle
+                   size > 131072 only one split is necessary */
+
+		if(size > 65536) {
+ 		        /* ok we want to do IO at addr, size bytes. set up a new descriptor entry */
+                        ata_descrs[count].sw_len = 0;  /* 0 means 65536, this is a 16-bit field */
+                        ata_descrs[count].ctrl = 0;
+                        ata_descrs[count].buf = addr;
+                        ata_descrs[count].next = virt_to_phys(&ata_descrs[count + 1]);
+                        count++;
+                        ata_tot_size += 65536;
+                        /* size and addr should refere to not handled data */
+                        size -= 65536;
+                        addr += 65536;
+                }
+		/* ok we want to do IO at addr, size bytes. set up a new descriptor entry */
+                if(size == 65536) {
+			ata_descrs[count].sw_len = 0;  /* 0 means 65536, this is a 16-bit field */
+                } else {
+			ata_descrs[count].sw_len = size;
+                }
+		ata_descrs[count].ctrl = 0;
+		ata_descrs[count].buf = addr;
+		ata_descrs[count].next = virt_to_phys(&ata_descrs[count + 1]);
+		count++;
+		ata_tot_size += size;
+	}
+
+	if (count) {
+		/* set the end-of-list flag on the last descriptor */
+		ata_descrs[count - 1].ctrl |= d_eol;
+		/* return and say all is ok */
+		return 0;
+	}
+
+	printk("%s: empty DMA table?\n", drive->name);
+	return 1;	/* let the PIO routines handle this weirdness */
+}
+
+static int config_drive_for_dma (ide_drive_t *drive)
+{
+        const char **list;
+        struct hd_driveid *id = drive->id;
+
+        if (id && (id->capability & 1)) {
+                /* Enable DMA on any drive that supports mword2 DMA */
+                if ((id->field_valid & 2) && (id->dma_mword & 0x404) == 0x404) {
+                        drive->using_dma = 1;
+                        return 0;               /* DMA enabled */
+                }
+
+                /* Consult the list of known "good" drives */
+                list = good_dma_drives;
+                while (*list) {
+                        if (!strcmp(*list++,id->model)) {
+                                drive->using_dma = 1;
+                                return 0;       /* DMA enabled */
+                        }
+                }
+        }
+        return 1;       /* DMA not enabled */
+}
+
+/*
+ * etrax_dma_intr() is the handler for disk read/write DMA interrupts
+ */
+static ide_startstop_t etrax_dma_intr (ide_drive_t *drive)
+{
+	LED_DISK_READ(0);
+	LED_DISK_WRITE(0);
+
+	return ide_dma_intr(drive);
+}
+
+/*
+ * Functions below initiates/aborts DMA read/write operations on a drive.
+ *
+ * The caller is assumed to have selected the drive and programmed the drive's
+ * sector address using CHS or LBA.  All that remains is to prepare for DMA
+ * and then issue the actual read/write DMA/PIO command to the drive.
+ *
+ * Returns 0 if all went well.
+ * Returns 1 if DMA read/write could not be started, in which case
+ * the caller should revert to PIO for the current request.
+ */
+
+static int e100_dma_check(ide_drive_t *drive)
+{
+	return config_drive_for_dma (drive);
+}
+
+static int e100_dma_end(ide_drive_t *drive)
+{
+	/* TODO: check if something went wrong with the DMA */
+	return 0;
+}
+
+static void e100_dma_start(ide_drive_t *drive)
+{
+	if (e100_read_command) {
+		/* begin DMA */
+
+		/* need to do this before RX DMA due to a chip bug
+		 * it is enough to just flush the part of the cache that
+		 * corresponds to the buffers we start, but since HD transfers
+		 * usually are more than 8 kB, it is easier to optimize for the
+		 * normal case and just flush the entire cache. its the only
+		 * way to be sure! (OB movie quote)
+		 */
+		flush_etrax_cache();
+		*R_DMA_CH3_FIRST = virt_to_phys(ata_descrs);
+		*R_DMA_CH3_CMD   = IO_STATE(R_DMA_CH3_CMD, cmd, start);
+
+		/* initiate a multi word dma read using DMA handshaking */
+
+		*R_ATA_TRANSFER_CNT =
+			IO_FIELD(R_ATA_TRANSFER_CNT, count, ata_tot_size >> 1);
+
+		*R_ATA_CTRL_DATA =
+			IO_FIELD(R_ATA_CTRL_DATA, data, IDE_DATA_REG) |
+			IO_STATE(R_ATA_CTRL_DATA, rw,       read) |
+			IO_STATE(R_ATA_CTRL_DATA, src_dst,  dma)  |
+			IO_STATE(R_ATA_CTRL_DATA, handsh,   dma)  |
+			IO_STATE(R_ATA_CTRL_DATA, multi,    on)   |
+			IO_STATE(R_ATA_CTRL_DATA, dma_size, word);
+
+		LED_DISK_READ(1);
+
+		D(printk("dma read of %d bytes.\n", ata_tot_size));
+
+	} else {
+		/* writing */
+		/* begin DMA */
+
+		*R_DMA_CH2_FIRST = virt_to_phys(ata_descrs);
+		*R_DMA_CH2_CMD   = IO_STATE(R_DMA_CH2_CMD, cmd, start);
+
+		/* initiate a multi word dma write using DMA handshaking */
+
+		*R_ATA_TRANSFER_CNT =
+			IO_FIELD(R_ATA_TRANSFER_CNT, count, ata_tot_size >> 1);
+
+		*R_ATA_CTRL_DATA =
+			IO_FIELD(R_ATA_CTRL_DATA, data,     IDE_DATA_REG) |
+			IO_STATE(R_ATA_CTRL_DATA, rw,       write) |
+			IO_STATE(R_ATA_CTRL_DATA, src_dst,  dma) |
+			IO_STATE(R_ATA_CTRL_DATA, handsh,   dma) |
+			IO_STATE(R_ATA_CTRL_DATA, multi,    on) |
+			IO_STATE(R_ATA_CTRL_DATA, dma_size, word);
+
+		LED_DISK_WRITE(1);
+
+		D(printk("dma write of %d bytes.\n", ata_tot_size));
+	}
+}
diff -Naur linuxppc-2.6.9/drivers/ide/cris/Makefile linuxppc-2.6.9-dream/drivers/ide/cris/Makefile
--- linuxppc-2.6.9/drivers/ide/cris/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/ide/cris/Makefile	2005-06-20 10:46:10.000000000 +0200
@@ -0,0 +1,3 @@
+EXTRA_CFLAGS				+= -Idrivers/ide
+
+obj-$(CONFIG_ETRAX_ARCH_V10)		+= ide-v10.o
diff -Naur linuxppc-2.6.9/drivers/ide/ide.c linuxppc-2.6.9-dream/drivers/ide/ide.c
--- linuxppc-2.6.9/drivers/ide/ide.c	2005-10-01 14:12:17.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide.c	2005-06-20 10:46:11.000000000 +0200
@@ -153,12 +153,12 @@
 #include <linux/cdrom.h>
 #include <linux/seq_file.h>
 #include <linux/device.h>
+#include <linux/bitops.h>
 
 #include <asm/byteorder.h>
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
-#include <asm/bitops.h>
 
 
 /* default maximum number of failures */
@@ -333,15 +333,26 @@
  *	Returns a guessed speed in MHz.
  */
 
-int ide_system_bus_speed (void)
+static int ide_system_bus_speed(void)
 {
+#ifdef CONFIG_PCI
+	static struct pci_device_id pci_default[] = {
+		{ PCI_DEVICE(PCI_ANY_ID, PCI_ANY_ID) },
+		{ }
+	};
+#else
+#define pci_default 0
+#endif /* CONFIG_PCI */
+
 	if (!system_bus_speed) {
 		if (idebus_parameter) {
 			/* user supplied value */
 			system_bus_speed = idebus_parameter;
-		} else if (pci_find_device(PCI_ANY_ID, PCI_ANY_ID, NULL) != NULL) {
+#ifdef CONFIG_PCI
+		} else if (pci_dev_present(pci_default)) {
 			/* safe default value for PCI */
 			system_bus_speed = 33;
+#endif
 		} else {
 			/* safe default value for VESA and PCI */
 			system_bus_speed = 50;
@@ -353,137 +364,6 @@
 	return system_bus_speed;
 }
 
-/**
- *	current_capacity	-	drive capacity
- *	@drive: drive to query
- *
- *	Return the current capacity (in sectors) of a drive according to
- *	its current geometry/LBA settings. Empty removables are reported
- *	as size zero.
- */
-
-sector_t current_capacity (ide_drive_t *drive)
-{
-	if (!drive->present)
-		return 0;
-	return DRIVER(drive)->capacity(drive);
-}
-
-EXPORT_SYMBOL(current_capacity);
-
-/**
- *	ide_dump_status		-	translate ATA error
- *	@drive: drive the error occured on
- *	@msg: information string
- *	@stat: status byte
- *
- *	Error reporting, in human readable form (luxurious, but a memory hog).
- *	Combines the drive name, message and status byte to provide a
- *	user understandable explanation of the device error.
- */
-
-u8 ide_dump_status (ide_drive_t *drive, const char *msg, u8 stat)
-{
-	ide_hwif_t *hwif = HWIF(drive);
-	unsigned long flags;
-	u8 err = 0;
-
-	local_irq_set(flags);
-	printk(KERN_WARNING "%s: %s: status=0x%02x", drive->name, msg, stat);
-	printk(" { ");
-	if (stat & BUSY_STAT) {
-		printk("Busy ");
-	} else {
-		if (stat & READY_STAT)	printk("DriveReady ");
-		if (stat & WRERR_STAT)	printk("DeviceFault ");
-		if (stat & SEEK_STAT)	printk("SeekComplete ");
-		if (stat & DRQ_STAT)	printk("DataRequest ");
-		if (stat & ECC_STAT)	printk("CorrectedError ");
-		if (stat & INDEX_STAT)	printk("Index ");
-		if (stat & ERR_STAT)	printk("Error ");
-	}
-	printk("}");
-	printk("\n");
-	if ((stat & (BUSY_STAT|ERR_STAT)) == ERR_STAT) {
-		err = hwif->INB(IDE_ERROR_REG);
-		printk("%s: %s: error=0x%02x", drive->name, msg, err);
-		if (drive->media == ide_disk) {
-			printk(" { ");
-			if (err & ABRT_ERR)	printk("DriveStatusError ");
-			if (err & ICRC_ERR)	printk("Bad%s ", (err & ABRT_ERR) ? "CRC" : "Sector");
-			if (err & ECC_ERR)	printk("UncorrectableError ");
-			if (err & ID_ERR)	printk("SectorIdNotFound ");
-			if (err & TRK0_ERR)	printk("TrackZeroNotFound ");
-			if (err & MARK_ERR)	printk("AddrMarkNotFound ");
-			printk("}");
-			if ((err & (BBD_ERR | ABRT_ERR)) == BBD_ERR || (err & (ECC_ERR|ID_ERR|MARK_ERR))) {
-				if ((drive->id->command_set_2 & 0x0400) &&
-				    (drive->id->cfs_enable_2 & 0x0400) &&
-				    (drive->addressing == 1)) {
-					u64 sectors = 0;
-					u32 high = 0;
-					u32 low = ide_read_24(drive);
-					hwif->OUTB(drive->ctl|0x80, IDE_CONTROL_REG);
-					high = ide_read_24(drive);
-
-					sectors = ((u64)high << 24) | low;
-					printk(", LBAsect=%llu, high=%d, low=%d",
-					       (long long) sectors,
-					       high, low);
-				} else {
-					u8 cur = hwif->INB(IDE_SELECT_REG);
-					if (cur & 0x40) {	/* using LBA? */
-						printk(", LBAsect=%ld", (unsigned long)
-						 ((cur&0xf)<<24)
-						 |(hwif->INB(IDE_HCYL_REG)<<16)
-						 |(hwif->INB(IDE_LCYL_REG)<<8)
-						 | hwif->INB(IDE_SECTOR_REG));
-					} else {
-						printk(", CHS=%d/%d/%d",
-						 (hwif->INB(IDE_HCYL_REG)<<8) +
-						  hwif->INB(IDE_LCYL_REG),
-						  cur & 0xf,
-						  hwif->INB(IDE_SECTOR_REG));
-					}
-				}
-				if (HWGROUP(drive) && HWGROUP(drive)->rq)
-					printk(", sector=%llu", (unsigned long long)HWGROUP(drive)->rq->sector);
-			}
-		}
-		printk("\n");
-	}
-	{
-		struct request *rq;
-		int opcode = 0x100;
-
-		spin_lock(&ide_lock);
-		rq = NULL;
-		if (HWGROUP(drive))
-			rq = HWGROUP(drive)->rq;
-		spin_unlock(&ide_lock);
-		if (!rq)
-			goto out;
-		if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK)) {
-			char *args = rq->buffer;
-			if (args)
-				opcode = args[0];
-		} else if (rq->flags & REQ_DRIVE_TASKFILE) {
-			ide_task_t *args = rq->special;
-			if (args) {
-				task_struct_t *tf = (task_struct_t *) args->tfRegister;
-				opcode = tf->command;
-			}
-		}
-
-		printk("ide: failed opcode was %x\n", opcode);
-	}
-out:
-	local_irq_restore(flags);
-	return err;
-}
-
-EXPORT_SYMBOL(ide_dump_status);
-
 static int ide_open (struct inode * inode, struct file * filp)
 {
 	return -ENXIO;
@@ -540,7 +420,7 @@
 #ifdef CONFIG_PROC_FS
 struct proc_dir_entry *proc_ide_root;
 
-ide_proc_entry_t generic_subdriver_entries[] = {
+static ide_proc_entry_t generic_subdriver_entries[] = {
 	{ "capacity",	S_IFREG|S_IRUGO,	proc_ide_read_capacity,	NULL },
 	{ NULL, 0, NULL, NULL }
 };
@@ -668,7 +548,6 @@
 	hwif->cds			= tmp_hwif->cds;
 #endif
 
-	hwif->identify			= tmp_hwif->identify;
 	hwif->tuneproc			= tmp_hwif->tuneproc;
 	hwif->speedproc			= tmp_hwif->speedproc;
 	hwif->selectproc		= tmp_hwif->selectproc;
@@ -685,9 +564,9 @@
 	hwif->atapi_input_bytes		= tmp_hwif->atapi_input_bytes;
 	hwif->atapi_output_bytes	= tmp_hwif->atapi_output_bytes;
 
-	hwif->ide_dma_read		= tmp_hwif->ide_dma_read;
-	hwif->ide_dma_write		= tmp_hwif->ide_dma_write;
-	hwif->ide_dma_begin		= tmp_hwif->ide_dma_begin;
+	hwif->dma_setup			= tmp_hwif->dma_setup;
+	hwif->dma_exec_cmd		= tmp_hwif->dma_exec_cmd;
+	hwif->dma_start			= tmp_hwif->dma_start;
 	hwif->ide_dma_end		= tmp_hwif->ide_dma_end;
 	hwif->ide_dma_check		= tmp_hwif->ide_dma_check;
 	hwif->ide_dma_on		= tmp_hwif->ide_dma_on;
@@ -695,7 +574,6 @@
 	hwif->ide_dma_test_irq		= tmp_hwif->ide_dma_test_irq;
 	hwif->ide_dma_host_on		= tmp_hwif->ide_dma_host_on;
 	hwif->ide_dma_host_off		= tmp_hwif->ide_dma_host_off;
-	hwif->ide_dma_verbose		= tmp_hwif->ide_dma_verbose;
 	hwif->ide_dma_lostirq		= tmp_hwif->ide_dma_lostirq;
 	hwif->ide_dma_timeout		= tmp_hwif->ide_dma_timeout;
 
@@ -712,6 +590,8 @@
 	hwif->INSW			= tmp_hwif->INSW;
 	hwif->INSL			= tmp_hwif->INSL;
 
+	hwif->sg_max_nents		= tmp_hwif->sg_max_nents;
+
 	hwif->mmio			= tmp_hwif->mmio;
 	hwif->rqsize			= tmp_hwif->rqsize;
 	hwif->no_lba48			= tmp_hwif->no_lba48;
@@ -796,9 +676,7 @@
 		DRIVER(drive)->cleanup(drive);
 	}
 
-#ifdef CONFIG_PROC_FS
-	destroy_proc_ide_drives(hwif);
-#endif
+	destroy_proc_ide_interface(hwif);
 
 	hwgroup = hwif->hwgroup;
 	/*
@@ -900,6 +778,7 @@
 		hwif->drives[i].disk = NULL;
 		put_disk(disk);
 	}
+	kfree(hwif->sg_table);
 	unregister_blkdev(hwif->major, hwif->name);
 	spin_lock_irq(&ide_lock);
 
@@ -986,9 +865,10 @@
 }
 
 /**
- *	ide_register_hw		-	register IDE interface
+ *	ide_register_hw_with_fixup	-	register IDE interface
  *	@hw: hardware registers
  *	@hwifp: pointer to returned hwif
+ *	@fixup: fixup function
  *
  *	Register an IDE interface, specifying exactly the registers etc.
  *	Set init=1 iff calling before probes have taken place.
@@ -996,7 +876,7 @@
  *	Returns -1 on error.
  */
 
-int ide_register_hw (hw_regs_t *hw, ide_hwif_t **hwifp)
+int ide_register_hw_with_fixup(hw_regs_t *hw, ide_hwif_t **hwifp, void(*fixup)(ide_hwif_t *hwif))
 {
 	int index, retry = 1;
 	ide_hwif_t *hwif;
@@ -1035,7 +915,7 @@
 	hwif->chipset = hw->chipset;
 
 	if (!initializing) {
-		probe_hwif_init(hwif);
+		probe_hwif_init_with_fixup(hwif, fixup);
 		create_proc_ide_interfaces();
 	}
 
@@ -1045,6 +925,13 @@
 	return (initializing || hwif->present) ? index : -1;
 }
 
+EXPORT_SYMBOL(ide_register_hw_with_fixup);
+
+int ide_register_hw(hw_regs_t *hw, ide_hwif_t **hwifp)
+{
+	return ide_register_hw_with_fixup(hw, hwifp, NULL);
+}
+
 EXPORT_SYMBOL(ide_register_hw);
 
 /*
@@ -1661,8 +1548,9 @@
 			 */
 
 			spin_lock_irqsave(&ide_lock, flags);
-			
-			DRIVER(drive)->abort(drive, "drive reset");
+
+			ide_abort(drive, "drive reset");
+
 			if(HWGROUP(drive)->handler)
 				BUG();
 				
@@ -1672,18 +1560,7 @@
 			HWGROUP(drive)->busy = 1;
 			spin_unlock_irqrestore(&ide_lock, flags);
 			(void) ide_do_reset(drive);
-			if (drive->suspend_reset) {
-/*
- *				APM WAKE UP todo !!
- *				int nogoodpower = 1;
- *				while(nogoodpower) {
- *					check_power1() or check_power2()
- *					nogoodpower = 0;
- *				} 
- *				HWIF(drive)->multiproc(drive);
- */
-				return ioctl_by_bdev(bdev, BLKRRPART, 0);
-			}
+
 			return 0;
 		}
 
@@ -1775,9 +1652,6 @@
 	return 0;	/* zero = nothing matched */
 }
 
-#ifdef CONFIG_BLK_DEV_PDC4030
-static int __initdata probe_pdc4030;
-#endif
 #ifdef CONFIG_BLK_DEV_ALI14XX
 static int __initdata probe_ali14xx;
 extern int ali14xx_init(void);
@@ -1807,7 +1681,7 @@
  *
  * Remember to update Documentation/ide.txt if you change something here.
  */
-int __init ide_setup (char *s)
+static int __init ide_setup(char *s)
 {
 	int i, vals[3];
 	ide_hwif_t *hwif;
@@ -1837,7 +1711,7 @@
 #endif /* CONFIG_BLK_DEV_IDEDOUBLER */
 
 	if (!strcmp(s, "ide=nodma")) {
-		printk("IDE: Prevented DMA\n");
+		printk(" : Prevented DMA\n");
 		noautodma = 1;
 		return 1;
 	}
@@ -1856,7 +1730,7 @@
 	if (s[0] == 'h' && s[1] == 'd' && s[2] >= 'a' && s[2] <= max_drive) {
 		const char *hd_words[] = {
 			"none", "noprobe", "nowerr", "cdrom", "serialize",
-			"autotune", "noautotune", "stroke", "swapdata", "bswap",
+			"autotune", "noautotune", "minus8", "swapdata", "bswap",
 			"minus11", "remap", "remap63", "scsi", NULL };
 		unit = s[2] - 'a';
 		hw   = unit / MAX_DRIVES;
@@ -1886,13 +1760,10 @@
 				goto do_serialize;
 			case -6: /* "autotune" */
 				drive->autotune = IDE_TUNE_AUTO;
-				goto done;
+				goto obsolete_option;
 			case -7: /* "noautotune" */
 				drive->autotune = IDE_TUNE_NOAUTO;
-				goto done;
-			case -8: /* stroke */
-				drive->stroke = 1;
-				goto done;
+				goto obsolete_option;
 			case -9: /* "swapdata" */
 			case -10: /* "bswap" */
 				drive->bswap = 1;
@@ -1946,7 +1817,7 @@
 			"noprobe", "serialize", "autotune", "noautotune", 
 			"reset", "dma", "ata66", "minus8", "minus9",
 			"minus10", "four", "qd65xx", "ht6560b", "cmd640_vlb",
-			"dtc2278", "umc8672", "ali14xx", "dc4030", NULL };
+			"dtc2278", "umc8672", "ali14xx", NULL };
 		hw = s[3] - '0';
 		hwif = &ide_hwifs[hw];
 		i = match_parm(&s[4], ide_words, vals, 3);
@@ -1972,11 +1843,6 @@
 		}
 
 		switch (i) {
-#ifdef CONFIG_BLK_DEV_PDC4030
-			case -18: /* "dc4030" */
-				probe_pdc4030 = 1;
-				goto done;
-#endif
 #ifdef CONFIG_BLK_DEV_ALI14XX
 			case -17: /* "ali14xx" */
 				probe_ali14xx = 1;
@@ -2029,30 +1895,30 @@
 			case -7: /* ata66 */
 #ifdef CONFIG_BLK_DEV_IDEPCI
 				hwif->udma_four = 1;
-				goto done;
+				goto obsolete_option;
 #else
 				goto bad_hwif;
 #endif
 			case -6: /* dma */
 				hwif->autodma = 1;
-				goto done;
+				goto obsolete_option;
 			case -5: /* "reset" */
 				hwif->reset = 1;
-				goto done;
+				goto obsolete_option;
 			case -4: /* "noautotune" */
 				hwif->drives[0].autotune = IDE_TUNE_NOAUTO;
 				hwif->drives[1].autotune = IDE_TUNE_NOAUTO;
-				goto done;
+				goto obsolete_option;
 			case -3: /* "autotune" */
 				hwif->drives[0].autotune = IDE_TUNE_AUTO;
 				hwif->drives[1].autotune = IDE_TUNE_AUTO;
-				goto done;
+				goto obsolete_option;
 			case -2: /* "serialize" */
 			do_serialize:
 				hwif->mate = &ide_hwifs[hw^1];
 				hwif->mate->mate = hwif;
 				hwif->serialized = hwif->mate->serialized = 1;
-				goto done;
+				goto obsolete_option;
 
 			case -1: /* "noprobe" */
 				hwif->noprobe = 1;
@@ -2069,7 +1935,7 @@
 				hwif->irq      = vals[2];
 				hwif->noprobe  = 0;
 				hwif->chipset  = ide_forced;
-				goto done;
+				goto obsolete_option;
 
 			case 0: goto bad_option;
 			default:
@@ -2080,6 +1946,9 @@
 bad_option:
 	printk(" -- BAD OPTION\n");
 	return 1;
+obsolete_option:
+	printk(" -- OBSOLETE OPTION, WILL BE REMOVED SOON!\n");
+	return 1;
 bad_hwif:
 	printk("-- NOT SUPPORTED ON ide%d", hw);
 done:
@@ -2098,7 +1967,6 @@
 #ifdef CONFIG_BLK_DEV_IDEPCI
 	ide_scan_pcibus(ide_scan_direction);
 #endif /* CONFIG_BLK_DEV_IDEPCI */
-
 #ifdef CONFIG_ETRAX_IDE
 	{
 		extern void init_e100_ide(void);
@@ -2111,13 +1979,6 @@
 		ide_probe_for_cmd640x();
 	}
 #endif /* CONFIG_BLK_DEV_CMD640 */
-#ifdef CONFIG_BLK_DEV_PDC4030
-	{
-		extern int pdc4030_init(void);
-		if (probe_pdc4030)
-			(void)pdc4030_init();
-	}
-#endif /* CONFIG_BLK_DEV_PDC4030 */
 #ifdef CONFIG_BLK_DEV_IDE_PMAC
 	{
 		extern void pmac_ide_probe(void);
@@ -2166,16 +2027,12 @@
 		std_ide_cntl_scan();
 	}
 #endif /* CONFIG_BLK_DEV_STD */
-}
-
-/*
- *	Actually unregister the subdriver. Called with the
- *	request lock dropped.
- */
- 
-static int default_cleanup (ide_drive_t *drive)
-{
-	return ide_unregister_subdriver(drive);
+#ifdef CONFIG_BLK_DEV_IDE_STB04xxx
+	{
+		extern int __init stb04xxx_ide_init(void);
+		stb04xxx_ide_init();
+	}
+#endif /* CONFIG_BLK_DEV_IDE_STB04xxx */
 }
 
 static ide_startstop_t default_do_request (ide_drive_t *drive, struct request *rq, sector_t block)
@@ -2189,14 +2046,10 @@
 	return ide_end_request(drive, uptodate, nr_sects);
 }
 
-static u8 default_sense (ide_drive_t *drive, const char *msg, u8 stat)
+static ide_startstop_t
+default_error(ide_drive_t *drive, struct request *rq, u8 stat, u8 err)
 {
-	return ide_dump_status(drive, msg, stat);
-}
-
-static ide_startstop_t default_error (ide_drive_t *drive, const char *msg, u8 stat)
-{
-	return ide_error(drive, msg, stat);
+	return __ide_error(drive, rq, stat, err);
 }
 
 static void default_pre_reset (ide_drive_t *drive)
@@ -2217,17 +2070,9 @@
 	return ide_stopped;
 }
 
-static int default_attach (ide_drive_t *drive)
-{
-	printk(KERN_ERR "%s: does not support hotswap of device class !\n",
-		drive->name);
-
-	return 0;
-}
-
-static ide_startstop_t default_abort (ide_drive_t *drive, const char *msg)
+static ide_startstop_t default_abort(ide_drive_t *drive, struct request *rq)
 {
-	return ide_abort(drive, msg);
+	return __ide_abort(drive, rq);
 }
 
 static ide_startstop_t default_start_power_step(ide_drive_t *drive,
@@ -2239,16 +2084,15 @@
 
 static void setup_driver_defaults (ide_driver_t *d)
 {
-	if (d->cleanup == NULL)		d->cleanup = default_cleanup;
+	BUG_ON(d->attach == NULL || d->cleanup == NULL);
+
 	if (d->do_request == NULL)	d->do_request = default_do_request;
 	if (d->end_request == NULL)	d->end_request = default_end_request;
-	if (d->sense == NULL)		d->sense = default_sense;
 	if (d->error == NULL)		d->error = default_error;
 	if (d->abort == NULL)		d->abort = default_abort;
 	if (d->pre_reset == NULL)	d->pre_reset = default_pre_reset;
 	if (d->capacity == NULL)	d->capacity = default_capacity;
 	if (d->special == NULL)		d->special = default_special;
-	if (d->attach == NULL)		d->attach = default_attach;
 	if (d->start_power_step == NULL)
 		d->start_power_step = default_start_power_step;
 }
@@ -2277,7 +2121,6 @@
 		drive->dsc_overlap = (drive->next != drive && driver->supports_dsc_overlap);
 		drive->nice1 = 1;
 	}
-	drive->suspend_reset = 0;
 #ifdef CONFIG_PROC_FS
 	if (drive->driver != &idedefault_driver) {
 		ide_add_proc_entries(drive->proc, generic_subdriver_entries, drive);
@@ -2435,7 +2278,7 @@
 /*
  * This is gets invoked once during initialization, to set *everything* up
  */
-int __init ide_init (void)
+static int __init ide_init(void)
 {
 	printk(KERN_INFO "Uniform Multi-Platform E-IDE driver " REVISION "\n");
 	devfs_mk_dir("ide");
@@ -2482,8 +2325,8 @@
 }
 
 #ifdef MODULE
-char *options = NULL;
-MODULE_PARM(options,"s");
+static char *options = NULL;
+module_param(options, charp, 0);
 MODULE_LICENSE("GPL");
 
 static void __init parse_options (char *line)
@@ -2510,11 +2353,8 @@
 {
 	int index;
 
-	for (index = 0; index < MAX_HWIFS; ++index) {
+	for (index = 0; index < MAX_HWIFS; ++index)
 		ide_unregister(index);
-		if (ide_hwifs[index].dma_base)
-			(void) ide_release_dma(&ide_hwifs[index]);
-	}
 
 #ifdef CONFIG_PROC_FS
 	proc_ide_destroy();
diff -Naur linuxppc-2.6.9/drivers/ide/ide-cd.c linuxppc-2.6.9-dream/drivers/ide/ide-cd.c
--- linuxppc-2.6.9/drivers/ide/ide-cd.c	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-cd.c	2005-06-20 10:46:10.000000000 +0200
@@ -456,7 +456,7 @@
 				s = "(reserved error code)";
 		}
 
-		printk("  %s -- (asc=0x%02x, ascq=0x%02x)\n",
+		printk(KERN_ERR "  %s -- (asc=0x%02x, ascq=0x%02x)\n",
 			s, sense->asc, sense->ascq);
 
 		if (failed_command != NULL) {
@@ -478,7 +478,7 @@
 					lo = mid+1;
 			}
 
-			printk ("  The failed \"%s\" packet command was: \n  \"", s);
+			printk (KERN_ERR "  The failed \"%s\" packet command was: \n  \"", s);
 			for (i=0; i<sizeof (failed_command->cmd); i++)
 				printk ("%02x ", failed_command->cmd[i]);
 			printk ("\"\n");
@@ -491,13 +491,13 @@
 		 */
 		if (sense->sense_key == NOT_READY && (sense->sks[0] & 0x80)) {
 			int progress = (sense->sks[1] << 8 | sense->sks[2]) * 100;
-			printk("  Command is %02d%% complete\n", progress / 0xffff);
+			printk(KERN_ERR "  Command is %02d%% complete\n", progress / 0xffff);
 
 		}
 
 		if (sense->sense_key == ILLEGAL_REQUEST &&
 		    (sense->sks[0] & 0x80) != 0) {
-			printk("  Error in %s byte %d",
+			printk(KERN_ERR "  Error in %s byte %d",
 				(sense->sks[0] & 0x40) != 0 ?
 				"command packet" : "command data",
 				(sense->sks[1] << 8) + sense->sks[2]);
@@ -519,7 +519,7 @@
 						sense->asc == 0x3a)))
 		return;
 
-	printk("%s: error code: 0x%02x  sense_key: 0x%02x  asc: 0x%02x  ascq: 0x%02x\n",
+	printk(KERN_ERR "%s: error code: 0x%02x  sense_key: 0x%02x  asc: 0x%02x  ascq: 0x%02x\n",
 		drive->name,
 		sense->error_code, sense->sense_key,
 		sense->asc, sense->ascq);
@@ -559,62 +559,6 @@
 	(void) ide_do_drive_cmd(drive, rq, ide_preempt);
 }
 
-/*
- * ide_error() takes action based on the error returned by the drive.
- */
-ide_startstop_t ide_cdrom_error (ide_drive_t *drive, const char *msg, byte stat)
-{
-	struct request *rq;
-	byte err;
-
-	err = ide_dump_atapi_status(drive, msg, stat);
-	if (drive == NULL || (rq = HWGROUP(drive)->rq) == NULL)
-		return ide_stopped;
-	/* retry only "normal" I/O: */
-	if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK | REQ_DRIVE_TASKFILE)) {
-		rq->errors = 1;
-		ide_end_drive_cmd(drive, stat, err);
-		return ide_stopped;
-	}
-
-	if (stat & BUSY_STAT || ((stat & WRERR_STAT) && !drive->nowerr)) {
-		/* other bits are useless when BUSY */
-		rq->errors |= ERROR_RESET;
-	} else {
-		/* add decoding error stuff */
-	}
-	if (HWIF(drive)->INB(IDE_STATUS_REG) & (BUSY_STAT|DRQ_STAT))
-		/* force an abort */
-		HWIF(drive)->OUTB(WIN_IDLEIMMEDIATE,IDE_COMMAND_REG);
-	if (rq->errors >= ERROR_MAX) {
-		DRIVER(drive)->end_request(drive, 0, 0);
-	} else {
-		if ((rq->errors & ERROR_RESET) == ERROR_RESET) {
-			++rq->errors;
-			return ide_do_reset(drive);
-		}
-		++rq->errors;
-	}
-	return ide_stopped;
-}
-
-ide_startstop_t ide_cdrom_abort (ide_drive_t *drive, const char *msg)
-{
-	struct request *rq;
-
-	if (drive == NULL || (rq = HWGROUP(drive)->rq) == NULL)
-		return ide_stopped;
-	/* retry only "normal" I/O: */
-	if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK | REQ_DRIVE_TASKFILE)) {
-		rq->errors = 1;
-		ide_end_drive_cmd(drive, BUSY_STAT, 0);
-		return ide_stopped;
-	}
-	rq->errors |= ERROR_RESET;
-	DRIVER(drive)->end_request(drive, 0, 0);
-	return ide_stopped;
-}
-
 static void cdrom_end_request (ide_drive_t *drive, int uptodate)
 {
 	struct request *rq = HWGROUP(drive)->rq;
@@ -690,7 +634,7 @@
 
 		rq->flags |= REQ_FAILED;
 		cdrom_end_request(drive, 0);
-		DRIVER(drive)->error(drive, "request sense failure", stat);
+		ide_error(drive, "request sense failure", stat);
 		return 1;
 
 	} else if (rq->flags & (REQ_PC | REQ_BLOCK_PC)) {
@@ -801,7 +745,7 @@
 		} else if ((err & ~ABRT_ERR) != 0) {
 			/* Go to the default handler
 			   for other errors. */
-			DRIVER(drive)->error(drive, "cdrom_decode_status",stat);
+			ide_error(drive, "cdrom_decode_status", stat);
 			return 1;
 		} else if ((++rq->errors > ERROR_MAX)) {
 			/* We've racked up too many retries.  Abort. */
@@ -865,20 +809,14 @@
 {
 	ide_startstop_t startstop;
 	struct cdrom_info *info = drive->driver_data;
+	ide_hwif_t *hwif = drive->hwif;
 
 	/* Wait for the controller to be idle. */
 	if (ide_wait_stat(&startstop, drive, 0, BUSY_STAT, WAIT_READY))
 		return startstop;
 
-	if (info->dma) {
-		if (info->cmd == READ) {
-			info->dma = !HWIF(drive)->ide_dma_read(drive);
-		} else if (info->cmd == WRITE) {
-			info->dma = !HWIF(drive)->ide_dma_write(drive);
-		} else {
-			printk("ide-cd: DMA set, but not allowed\n");
-		}
-	}
+	if (info->dma)
+		info->dma = !hwif->dma_setup(drive);
 
 	/* Set up the controller registers. */
 	/* FIXME: for Virtual DMA we must check harder */
@@ -896,8 +834,14 @@
 		ide_execute_command(drive, WIN_PACKETCMD, handler, ATAPI_WAIT_PC, cdrom_timer_expiry);
 		return ide_started;
 	} else {
+		unsigned long flags;
+
 		/* packet command */
-		HWIF(drive)->OUTB(WIN_PACKETCMD, IDE_COMMAND_REG);
+		spin_lock_irqsave(&ide_lock, flags);
+		hwif->OUTBSYNC(drive, WIN_PACKETCMD, IDE_COMMAND_REG);
+		ndelay(400);
+		spin_unlock_irqrestore(&ide_lock, flags);
+
 		return (*handler) (drive);
 	}
 }
@@ -916,6 +860,7 @@
 					  struct request *rq,
 					  ide_handler_t *handler)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	int cmd_len;
 	struct cdrom_info *info = drive->driver_data;
 	ide_startstop_t startstop;
@@ -947,7 +892,7 @@
 
 	/* Start the DMA if need be */
 	if (info->dma)
-		(void) HWIF(drive)->ide_dma_begin(drive);
+		hwif->dma_start(drive);
 
 	return ide_started;
 }
@@ -1013,7 +958,7 @@
 		return 0;
 	else if (ireason == 0) {
 		/* Whoops... The drive is expecting to receive data from us! */
-		printk("%s: read_intr: Drive wants to transfer data the "
+		printk(KERN_ERR "%s: read_intr: Drive wants to transfer data the "
 						"wrong way!\n", drive->name);
 
 		/* Throw some data at the drive so it doesn't hang
@@ -1031,7 +976,7 @@
 		return 0;
 	} else {
 		/* Drive wants a command packet, or invalid ireason... */
-		printk("%s: read_intr: bad interrupt reason %x\n", drive->name,
+		printk(KERN_ERR "%s: read_intr: bad interrupt reason %x\n", drive->name,
 								ireason);
 	}
 
@@ -1069,7 +1014,7 @@
 			ide_end_request(drive, 1, rq->nr_sectors);
 			return ide_stopped;
 		} else
-			return DRIVER(drive)->error(drive, "dma error", stat);
+			return ide_error(drive, "dma error", stat);
 	}
 
 	/* Read the interrupt reason and the transfer length. */
@@ -1084,7 +1029,7 @@
 		/* If we're not done filling the current buffer, complain.
 		   Otherwise, complete the command normally. */
 		if (rq->current_nr_sectors > 0) {
-			printk ("%s: cdrom_read_intr: data underrun (%d blocks)\n",
+			printk (KERN_ERR "%s: cdrom_read_intr: data underrun (%d blocks)\n",
 				drive->name, rq->current_nr_sectors);
 			rq->flags |= REQ_FAILED;
 			cdrom_end_request(drive, 0);
@@ -1101,12 +1046,12 @@
 	   of at least SECTOR_SIZE, as it gets hairy to keep track
 	   of the transfers otherwise. */
 	if ((len % SECTOR_SIZE) != 0) {
-		printk ("%s: cdrom_read_intr: Bad transfer size %d\n",
+		printk (KERN_ERR "%s: cdrom_read_intr: Bad transfer size %d\n",
 			drive->name, len);
 		if (CDROM_CONFIG_FLAGS(drive)->limit_nframes)
-			printk ("  This drive is not supported by this version of the driver\n");
+			printk (KERN_ERR "  This drive is not supported by this version of the driver\n");
 		else {
-			printk ("  Trying to limit transfer sizes\n");
+			printk (KERN_ERR "  Trying to limit transfer sizes\n");
 			CDROM_CONFIG_FLAGS(drive)->limit_nframes = 1;
 		}
 		cdrom_end_request(drive, 0);
@@ -1220,7 +1165,7 @@
 	   paranoid and check. */
 	if (rq->current_nr_sectors < bio_cur_sectors(rq->bio) &&
 	    (rq->sector & (sectors_per_frame - 1))) {
-		printk("%s: cdrom_read_from_buffer: buffer botch (%ld)\n",
+		printk(KERN_ERR "%s: cdrom_read_from_buffer: buffer botch (%ld)\n",
 			drive->name, (long)rq->sector);
 		cdrom_end_request(drive, 0);
 		return -1;
@@ -1255,7 +1200,7 @@
 		/* Sanity check... */
 		if (rq->current_nr_sectors != bio_cur_sectors(rq->bio) &&
 			(rq->sector & (sectors_per_frame - 1))) {
-			printk ("%s: cdrom_start_read_continuation: buffer botch (%u)\n",
+			printk(KERN_ERR "%s: cdrom_start_read_continuation: buffer botch (%u)\n",
 				drive->name, rq->current_nr_sectors);
 			cdrom_end_request(drive, 0);
 			return ide_stopped;
@@ -1480,7 +1425,7 @@
 			rq->sense_len += thislen;
 	} else {
 confused:
-		printk ("%s: cdrom_pc_intr: The drive "
+		printk (KERN_ERR "%s: cdrom_pc_intr: The drive "
 			"appears confused (ireason = 0x%02x)\n",
 			drive->name, ireason);
 		rq->flags |= REQ_FAILED;
@@ -1519,19 +1464,6 @@
 }
 
 
-/* Sleep for TIME jiffies.
-   Not to be called from an interrupt handler. */
-static
-void cdrom_sleep (int time)
-{
-	int sleep = time;
-
-	do {
-		set_current_state(TASK_INTERRUPTIBLE);
-		sleep = schedule_timeout(sleep);
-	} while (sleep);
-}
-
 static
 int cdrom_queue_packet_command(ide_drive_t *drive, struct request *rq)
 {
@@ -1566,7 +1498,7 @@
 				/* The drive is in the process of loading
 				   a disk.  Retry, but wait a little to give
 				   the drive time to complete the load. */
-				cdrom_sleep(2 * HZ);
+				ssleep(2);
 			} else {
 				/* Otherwise, don't retry. */
 				retries = 0;
@@ -1594,7 +1526,7 @@
 		return 0;
 	else if (ireason == 2) {
 		/* Whoops... The drive wants to send data. */
-		printk("%s: write_intr: wrong transfer direction!\n",
+		printk(KERN_ERR "%s: write_intr: wrong transfer direction!\n",
 							drive->name);
 
 		while (len > 0) {
@@ -1604,7 +1536,7 @@
 		}
 	} else {
 		/* Drive wants a command packet, or invalid ireason... */
-		printk("%s: write_intr: bad interrupt reason %x\n",
+		printk(KERN_ERR "%s: write_intr: bad interrupt reason %x\n",
 							drive->name, ireason);
 	}
 
@@ -1670,9 +1602,9 @@
 	 */
 	if (dma) {
 		if (dma_error) {
-			printk("ide-cd: dma error\n");
+			printk(KERN_ERR "ide-cd: dma error\n");
 			__ide_dma_off(drive);
-			return DRIVER(drive)->error(drive, "dma error", stat);
+			return ide_error(drive, "dma error", stat);
 		}
 
 		end_that_request_chunk(rq, 1, rq->data_len);
@@ -1735,7 +1667,7 @@
 		}
 
 		if (!ptr) {
-			printk("%s: confused, missing data\n", drive->name);
+			printk(KERN_ERR "%s: confused, missing data\n", drive->name);
 			break;
 		}
 
@@ -1797,7 +1729,7 @@
 	if (dma) {
 		info->dma = 0;
 		if ((dma_error = HWIF(drive)->ide_dma_end(drive))) {
-			printk("ide-cd: write dma error\n");
+			printk(KERN_ERR "ide-cd: write dma error\n");
 			__ide_dma_off(drive);
 		}
 	}
@@ -1810,7 +1742,7 @@
 	 */
 	if (dma) {
 		if (dma_error)
-			return DRIVER(drive)->error(drive, "dma error", stat);
+			return ide_error(drive, "dma error", stat);
 
 		ide_end_request(drive, 1, rq->nr_sectors);
 		return ide_stopped;
@@ -1830,7 +1762,7 @@
 		 */
 		uptodate = 1;
 		if (rq->current_nr_sectors > 0) {
-			printk("%s: write_intr: data underrun (%d blocks)\n",
+			printk(KERN_ERR "%s: write_intr: data underrun (%d blocks)\n",
 			drive->name, rq->current_nr_sectors);
 			uptodate = 0;
 		}
@@ -1851,7 +1783,7 @@
 		int this_transfer;
 
 		if (!rq->current_nr_sectors) {
-			printk("ide-cd: write_intr: oops\n");
+			printk(KERN_ERR "ide-cd: write_intr: oops\n");
 			break;
 		}
 
@@ -1995,11 +1927,11 @@
 					ide_stall_queue(drive, IDECD_SEEK_TIMER);
 					return ide_stopped;
 				}
-				printk ("%s: DSC timeout\n", drive->name);
+				printk (KERN_ERR "%s: DSC timeout\n", drive->name);
 			}
 			CDROM_CONFIG_FLAGS(drive)->seeking = 0;
 		}
-		if (IDE_LARGE_SEEK(info->last_block, block, IDECD_SEEK_THRESHOLD) && drive->dsc_overlap) {
+		if ((rq_data_dir(rq) == READ) && IDE_LARGE_SEEK(info->last_block, block, IDECD_SEEK_THRESHOLD) && drive->dsc_overlap) {
 			action = cdrom_start_seek(drive, block);
 		} else {
 			if (rq_data_dir(rq) == READ)
@@ -2131,7 +2063,7 @@
 	if (stat != 0 &&
 	    sense->sense_key == ILLEGAL_REQUEST &&
 	    (sense->asc == 0x24 || sense->asc == 0x20)) {
-		printk ("%s: door locking not supported\n",
+		printk (KERN_ERR "%s: door locking not supported\n",
 			drive->name);
 		CDROM_CONFIG_FLAGS(drive)->no_doorlock = 1;
 		stat = 0;
@@ -2249,7 +2181,7 @@
 						    GFP_KERNEL);
 		info->toc = toc;
 		if (toc == NULL) {
-			printk ("%s: No cdrom TOC buffer!\n", drive->name);
+			printk (KERN_ERR "%s: No cdrom TOC buffer!\n", drive->name);
 			return -ENOMEM;
 		}
 	}
@@ -2356,25 +2288,31 @@
 	/* Read the multisession information. */
 	if (toc->hdr.first_track != CDROM_LEADOUT) {
 		/* Read the multisession information. */
-		stat = cdrom_read_tocentry(drive, 0, 1, 1, (char *)&ms_tmp,
+		stat = cdrom_read_tocentry(drive, 0, 0, 1, (char *)&ms_tmp,
 					   sizeof(ms_tmp), sense);
 		if (stat) return stat;
+
+		toc->last_session_lba = be32_to_cpu(ms_tmp.ent.addr.lba);
 	} else {
-		ms_tmp.ent.addr.msf.minute = 0;
-		ms_tmp.ent.addr.msf.second = 2;
-		ms_tmp.ent.addr.msf.frame  = 0;
 		ms_tmp.hdr.first_track = ms_tmp.hdr.last_track = CDROM_LEADOUT;
+		toc->last_session_lba = msf_to_lba(0, 2, 0); /* 0m 2s 0f */
 	}
 
 #if ! STANDARD_ATAPI
-	if (CDROM_CONFIG_FLAGS(drive)->tocaddr_as_bcd)
+	if (CDROM_CONFIG_FLAGS(drive)->tocaddr_as_bcd) {
+		/* Re-read multisession information using MSF format */
+		stat = cdrom_read_tocentry(drive, 0, 1, 1, (char *)&ms_tmp,
+					   sizeof(ms_tmp), sense);
+		if (stat)
+			return stat;
+
 		msf_from_bcd (&ms_tmp.ent.addr.msf);
+		toc->last_session_lba = msf_to_lba(ms_tmp.ent.addr.msf.minute,
+					  	   ms_tmp.ent.addr.msf.second,
+						   ms_tmp.ent.addr.msf.frame);
+	}
 #endif  /* not STANDARD_ATAPI */
 
-	toc->last_session_lba = msf_to_lba (ms_tmp.ent.addr.msf.minute,
-					    ms_tmp.ent.addr.msf.second,
-					    ms_tmp.ent.addr.msf.frame);
-
 	toc->xa_flag = (ms_tmp.hdr.first_track != ms_tmp.hdr.last_track);
 
 	/* Now try to get the total cdrom capacity. */
@@ -2735,9 +2673,9 @@
 	 */
 	if (sense.sense_key == NOT_READY) {
 		if (sense.asc == 0x3a) {
-			if (sense.ascq == 0 || sense.ascq == 1)
+			if (sense.ascq == 1)
 				return CDS_NO_DISC;
-			else if (sense.ascq == 2)
+			else if (sense.ascq == 0 || sense.ascq == 2)
 				return CDS_TRAY_OPEN;
 		}
 	}
@@ -2930,7 +2868,7 @@
 	if (drive->media == ide_optical) {
 		CDROM_CONFIG_FLAGS(drive)->mo_drive = 1;
 		CDROM_CONFIG_FLAGS(drive)->ram = 1;
-		printk("%s: ATAPI magneto-optical drive\n", drive->name);
+		printk(KERN_ERR "%s: ATAPI magneto-optical drive\n", drive->name);
 		return nslots;
 	}
 
@@ -2960,8 +2898,10 @@
 		CDROM_CONFIG_FLAGS(drive)->no_eject = 0;
 	if (cap.cd_r_write)
 		CDROM_CONFIG_FLAGS(drive)->cd_r = 1;
-	if (cap.cd_rw_write)
+	if (cap.cd_rw_write) {
 		CDROM_CONFIG_FLAGS(drive)->cd_rw = 1;
+		CDROM_CONFIG_FLAGS(drive)->ram = 1;
+	}
 	if (cap.test_write)
 		CDROM_CONFIG_FLAGS(drive)->test_write = 1;
 	if (cap.dvd_ram_read || cap.dvd_r_read || cap.dvd_rom)
@@ -3018,7 +2958,7 @@
 
 	/* don't print speed if the drive reported 0.
 	 */
-	printk("%s: ATAPI", drive->name);
+	printk(KERN_INFO "%s: ATAPI", drive->name);
 	if (CDROM_CONFIG_FLAGS(drive)->max_speed)
 		printk(" %dX", CDROM_CONFIG_FLAGS(drive)->max_speed);
 	printk(" %s", CDROM_CONFIG_FLAGS(drive)->dvd ? "DVD-ROM" : "CD-ROM");
@@ -3040,10 +2980,9 @@
 
 	printk(", %dkB Cache", be16_to_cpu(cap.buffer_size));
 
-#ifdef CONFIG_BLK_DEV_IDEDMA
 	if (drive->using_dma)
-		(void) HWIF(drive)->ide_dma_verbose(drive);
-#endif /* CONFIG_BLK_DEV_IDEDMA */
+		ide_dma_verbose(drive);
+
 	printk("\n");
 
 	return nslots;
@@ -3262,7 +3201,7 @@
 #endif
 
 	if (ide_cdrom_register(drive, nslots)) {
-		printk ("%s: ide_cdrom_setup failed to register device with the cdrom driver.\n", drive->name);
+		printk (KERN_ERR "%s: ide_cdrom_setup failed to register device with the cdrom driver.\n", drive->name);
 		info->devinfo.handle = NULL;
 		return 1;
 	}
@@ -3289,7 +3228,7 @@
 	struct gendisk *g = drive->disk;
 
 	if (ide_unregister_subdriver(drive)) {
-		printk("%s: %s: failed to ide_unregister_subdriver\n",
+		printk(KERN_ERR "%s: %s: failed to ide_unregister_subdriver\n",
 			__FUNCTION__, drive->name);
 		return 1;
 	}
@@ -3300,7 +3239,7 @@
 	if (info->changer_info != NULL)
 		kfree(info->changer_info);
 	if (devinfo->handle == drive && unregister_cdrom(devinfo))
-		printk("%s: ide_cdrom_cleanup failed to unregister device from the cdrom driver.\n", drive->name);
+		printk(KERN_ERR "%s: ide_cdrom_cleanup failed to unregister device from the cdrom driver.\n", drive->name);
 	kfree(info);
 	drive->driver_data = NULL;
 	blk_queue_prep_rq(drive->queue, NULL);
@@ -3359,9 +3298,6 @@
 	.supports_dsc_overlap	= 1,
 	.cleanup		= ide_cdrom_cleanup,
 	.do_request		= ide_do_rw_cdrom,
-	.sense			= ide_dump_atapi_status,
-	.error			= ide_cdrom_error,
-	.abort			= ide_cdrom_abort,
 	.capacity		= ide_cdrom_capacity,
 	.attach			= ide_cdrom_attach,
 	.drives			= LIST_HEAD_INIT(ide_cdrom_driver.drives),
@@ -3432,9 +3368,9 @@
 };
 
 /* options */
-char *ignore = NULL;
+static char *ignore = NULL;
 
-MODULE_PARM(ignore, "s");
+module_param(ignore, charp, 0400);
 MODULE_DESCRIPTION("ATAPI CD-ROM Driver");
 
 static int ide_cdrom_attach (ide_drive_t *drive)
@@ -3452,21 +3388,21 @@
 	/* skip drives that we were told to ignore */
 	if (ignore != NULL) {
 		if (strstr(ignore, drive->name)) {
-			printk("ide-cd: ignoring drive %s\n", drive->name);
+			printk(KERN_INFO "ide-cd: ignoring drive %s\n", drive->name);
 			goto failed;
 		}
 	}
 	if (drive->scsi) {
-		printk("ide-cd: passing drive %s to ide-scsi emulation.\n", drive->name);
+		printk(KERN_INFO "ide-cd: passing drive %s to ide-scsi emulation.\n", drive->name);
 		goto failed;
 	}
 	info = (struct cdrom_info *) kmalloc (sizeof (struct cdrom_info), GFP_KERNEL);
 	if (info == NULL) {
-		printk("%s: Can't allocate a cdrom structure\n", drive->name);
+		printk(KERN_ERR "%s: Can't allocate a cdrom structure\n", drive->name);
 		goto failed;
 	}
 	if (ide_register_subdriver(drive, &ide_cdrom_driver)) {
-		printk("%s: Failed to register the driver with ide.c\n",
+		printk(KERN_ERR "%s: Failed to register the driver with ide.c\n",
 			drive->name);
 		kfree(info);
 		goto failed;
@@ -3490,7 +3426,7 @@
 		if (info->changer_info != NULL)
 			kfree(info->changer_info);
 		if (devinfo->handle == drive && unregister_cdrom(devinfo))
-			printk ("%s: ide_cdrom_cleanup failed to unregister device from the cdrom driver.\n", drive->name);
+			printk (KERN_ERR "%s: ide_cdrom_cleanup failed to unregister device from the cdrom driver.\n", drive->name);
 		kfree(info);
 		drive->driver_data = NULL;
 		goto failed;
diff -Naur linuxppc-2.6.9/drivers/ide/ide-cd.h linuxppc-2.6.9-dream/drivers/ide/ide-cd.h
--- linuxppc-2.6.9/drivers/ide/ide-cd.h	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-cd.h	2005-06-20 10:46:10.000000000 +0200
@@ -519,7 +519,7 @@
 
  /* The generic packet command opcodes for CD/DVD Logical Units,
  * From Table 57 of the SFF8090 Ver. 3 (Mt. Fuji) draft standard. */ 
-const struct {
+static const struct {
 	unsigned short packet_command;
 	const char * const text;
 } packet_command_texts[] = {
@@ -577,7 +577,7 @@
 
 
 /* From Table 303 of the SFF8090 Ver. 3 (Mt. Fuji) draft standard. */
-const char * const sense_key_texts[16] = {
+static const char * const sense_key_texts[16] = {
 	"No sense data",
 	"Recovered error",
 	"Not ready",
@@ -597,7 +597,7 @@
 };
 
 /* From Table 304 of the SFF8090 Ver. 3 (Mt. Fuji) draft standard. */
-const struct {
+static const struct {
 	unsigned long asc_ascq;
 	const char * const text;
 } sense_data_texts[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/ide-default.c linuxppc-2.6.9-dream/drivers/ide/ide-default.c
--- linuxppc-2.6.9/drivers/ide/ide-default.c	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-default.c	2005-06-20 10:46:10.000000000 +0200
@@ -23,13 +23,13 @@
 #include <linux/slab.h>
 #include <linux/cdrom.h>
 #include <linux/ide.h>
+#include <linux/bitops.h>
 
 #include <asm/byteorder.h>
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/unaligned.h>
-#include <asm/bitops.h>
 
 #define IDEDEFAULT_VERSION	"0.9.newide"
 /*
@@ -46,6 +46,7 @@
 	.name		=	"ide-default",
 	.version	=	IDEDEFAULT_VERSION,
 	.attach		=	idedefault_attach,
+	.cleanup	=	ide_unregister_subdriver,
 	.drives		=	LIST_HEAD_INIT(idedefault_driver.drives)
 };
 
diff -Naur linuxppc-2.6.9/drivers/ide/ide-disk.c linuxppc-2.6.9-dream/drivers/ide/ide-disk.c
--- linuxppc-2.6.9/drivers/ide/ide-disk.c	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-disk.c	2005-06-20 10:46:10.000000000 +0200
@@ -71,10 +71,6 @@
 #include <asm/io.h>
 #include <asm/div64.h>
 
-/* FIXME: some day we shouldn't need to look in here! */
-
-#include "legacy/pdc4030.h"
-
 /*
  * lba_capacity_is_ok() performs a sanity check on the claimed "lba_capacity"
  * value for this drive (from its reported identification information).
@@ -120,224 +116,11 @@
 	return 0;	/* lba_capacity value may be bad */
 }
 
-#ifndef CONFIG_IDE_TASKFILE_IO
-
-/*
- * read_intr() is the handler for disk read/multread interrupts
- */
-static ide_startstop_t read_intr (ide_drive_t *drive)
-{
-	ide_hwif_t *hwif	= HWIF(drive);
-	u32 i = 0, nsect	= 0, msect = drive->mult_count;
-	struct request *rq;
-	unsigned long flags;
-	u8 stat;
-	char *to;
-
-	/* new way for dealing with premature shared PCI interrupts */
-	if (!OK_STAT(stat=hwif->INB(IDE_STATUS_REG),DATA_READY,BAD_R_STAT)) {
-		if (stat & (ERR_STAT|DRQ_STAT)) {
-			return DRIVER(drive)->error(drive, "read_intr", stat);
-		}
-		/* no data yet, so wait for another interrupt */
-		ide_set_handler(drive, &read_intr, WAIT_CMD, NULL);
-		return ide_started;
-	}
-	
-read_next:
-	rq = HWGROUP(drive)->rq;
-	if (msect) {
-		if ((nsect = rq->current_nr_sectors) > msect)
-			nsect = msect;
-		msect -= nsect;
-	} else
-		nsect = 1;
-	to = ide_map_buffer(rq, &flags);
-	taskfile_input_data(drive, to, nsect * SECTOR_WORDS);
-#ifdef DEBUG
-	printk("%s:  read: sectors(%ld-%ld), buffer=0x%08lx, remaining=%ld\n",
-		drive->name, rq->sector, rq->sector+nsect-1,
-		(unsigned long) rq->buffer+(nsect<<9), rq->nr_sectors-nsect);
-#endif
-	ide_unmap_buffer(rq, to, &flags);
-	rq->sector += nsect;
-	rq->errors = 0;
-	i = (rq->nr_sectors -= nsect);
-	if (((long)(rq->current_nr_sectors -= nsect)) <= 0)
-		ide_end_request(drive, 1, rq->hard_cur_sectors);
-	/*
-	 * Another BH Page walker and DATA INTEGRITY Questioned on ERROR.
-	 * If passed back up on multimode read, BAD DATA could be ACKED
-	 * to FILE SYSTEMS above ...
-	 */
-	if (i > 0) {
-		if (msect)
-			goto read_next;
-		ide_set_handler(drive, &read_intr, WAIT_CMD, NULL);
-                return ide_started;
-	}
-        return ide_stopped;
-}
-
-/*
- * write_intr() is the handler for disk write interrupts
- */
-static ide_startstop_t write_intr (ide_drive_t *drive)
-{
-	ide_hwgroup_t *hwgroup	= HWGROUP(drive);
-	ide_hwif_t *hwif	= HWIF(drive);
-	struct request *rq	= hwgroup->rq;
-	u32 i = 0;
-	u8 stat;
-
-	if (!OK_STAT(stat = hwif->INB(IDE_STATUS_REG),
-			DRIVE_READY, drive->bad_wstat)) {
-		printk("%s: write_intr error1: nr_sectors=%ld, stat=0x%02x\n",
-			drive->name, rq->nr_sectors, stat);
-        } else {
-#ifdef DEBUG
-		printk("%s: write: sector %ld, buffer=0x%08lx, remaining=%ld\n",
-			drive->name, rq->sector, (unsigned long) rq->buffer,
-			rq->nr_sectors-1);
-#endif
-		if ((rq->nr_sectors == 1) ^ ((stat & DRQ_STAT) != 0)) {
-			rq->sector++;
-			rq->errors = 0;
-			i = --rq->nr_sectors;
-			--rq->current_nr_sectors;
-			if (((long)rq->current_nr_sectors) <= 0)
-				ide_end_request(drive, 1, rq->hard_cur_sectors);
-			if (i > 0) {
-				unsigned long flags;
-				char *to = ide_map_buffer(rq, &flags);
-				taskfile_output_data(drive, to, SECTOR_WORDS);
-				ide_unmap_buffer(rq, to, &flags);
-				ide_set_handler(drive, &write_intr, WAIT_CMD, NULL);
-                                return ide_started;
-			}
-                        return ide_stopped;
-		}
-		/* the original code did this here (?) */
-		return ide_stopped;
-	}
-	return DRIVER(drive)->error(drive, "write_intr", stat);
-}
-
-/*
- * ide_multwrite() transfers a block of up to mcount sectors of data
- * to a drive as part of a disk multiple-sector write operation.
- *
- * Note that we may be called from two contexts - __ide_do_rw_disk() context
- * and IRQ context. The IRQ can happen any time after we've output the
- * full "mcount" number of sectors, so we must make sure we update the
- * state _before_ we output the final part of the data!
- *
- * The update and return to BH is a BLOCK Layer Fakey to get more data
- * to satisfy the hardware atomic segment.  If the hardware atomic segment
- * is shorter or smaller than the BH segment then we should be OKAY.
- * This is only valid if we can rewind the rq->current_nr_sectors counter.
- */
-static void ide_multwrite(ide_drive_t *drive, unsigned int mcount)
-{
- 	ide_hwgroup_t *hwgroup	= HWGROUP(drive);
- 	struct request *rq	= &hwgroup->wrq;
- 
-  	do {
-  		char *buffer;
-  		int nsect = rq->current_nr_sectors;
-		unsigned long flags;
- 
-		if (nsect > mcount)
-			nsect = mcount;
-		mcount -= nsect;
-		buffer = ide_map_buffer(rq, &flags);
-
-		rq->sector += nsect;
-		rq->nr_sectors -= nsect;
-		rq->current_nr_sectors -= nsect;
-
-		/* Do we move to the next bh after this? */
-		if (!rq->current_nr_sectors) {
-			struct bio *bio = rq->bio;
-
-			/*
-			 * only move to next bio, when we have processed
-			 * all bvecs in this one.
-			 */
-			if (++bio->bi_idx >= bio->bi_vcnt) {
-				bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-				bio = bio->bi_next;
-			}
-
-			/* end early early we ran out of requests */
-			if (!bio) {
-				mcount = 0;
-			} else {
-				rq->bio = bio;
-				rq->nr_cbio_segments = bio_segments(bio);
-				rq->current_nr_sectors = bio_cur_sectors(bio);
-				rq->hard_cur_sectors = rq->current_nr_sectors;
-			}
-		}
-
-		/*
-		 * Ok, we're all setup for the interrupt
-		 * re-entering us on the last transfer.
-		 */
-		taskfile_output_data(drive, buffer, nsect<<7);
-		ide_unmap_buffer(rq, buffer, &flags);
-	} while (mcount);
-}
-
-/*
- * multwrite_intr() is the handler for disk multwrite interrupts
- */
-static ide_startstop_t multwrite_intr (ide_drive_t *drive)
-{
-	ide_hwgroup_t *hwgroup	= HWGROUP(drive);
-	ide_hwif_t *hwif	= HWIF(drive);
-	struct request *rq	= &hwgroup->wrq;
-	struct bio *bio		= rq->bio;
-	u8 stat;
-
-	stat = hwif->INB(IDE_STATUS_REG);
-	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat)) {
-		if (stat & DRQ_STAT) {
-			/*
-			 *	The drive wants data. Remember rq is the copy
-			 *	of the request
-			 */
-			if (rq->nr_sectors) {
-				ide_multwrite(drive, drive->mult_count);
-				ide_set_handler(drive, &multwrite_intr, WAIT_CMD, NULL);
-				return ide_started;
-			}
-		} else {
-			/*
-			 *	If the copy has all the blocks completed then
-			 *	we can end the original request.
-			 */
-			if (!rq->nr_sectors) {	/* all done? */
-				bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-				rq = hwgroup->rq;
-				ide_end_request(drive, 1, rq->nr_sectors);
-				return ide_stopped;
-			}
-		}
-		bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-		/* the original code did this here (?) */
-		return ide_stopped;
-	}
-	bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-	return DRIVER(drive)->error(drive, "multwrite_intr", stat);
-}
-
 /*
  * __ide_do_rw_disk() issues READ and WRITE commands to a disk,
  * using LBA if supported, or CHS otherwise, to address sectors.
- * It also takes care of issuing special DRIVE_CMDs.
  */
-ide_startstop_t __ide_do_rw_disk (ide_drive_t *drive, struct request *rq, sector_t block)
+static ide_startstop_t __ide_do_rw_disk(ide_drive_t *drive, struct request *rq, sector_t block)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	unsigned int dma	= drive->using_dma;
@@ -348,13 +131,20 @@
 	nsectors.all		= (u16) rq->nr_sectors;
 
 	if (hwif->no_lba48_dma && lba48 && dma) {
-		if (rq->sector + rq->nr_sectors > 1ULL << 28)
+		if (block + rq->nr_sectors > 1ULL << 28)
 			dma = 0;
 	}
 
+	if (!dma) {
+		ide_init_sg_cmd(drive, rq);
+		ide_map_sg(drive, rq);
+	}
+
 	if (IDE_CONTROL_REG)
 		hwif->OUTB(drive->ctl, IDE_CONTROL_REG);
 
+	/* FIXME: SELECT_MASK(drive, 0) ? */
+
 	if (drive->select.b.lba) {
 		if (drive->addressing == 1) {
 			task_ioreg_t tasklets[10];
@@ -419,171 +209,51 @@
 		hwif->OUTB(head|drive->select.all,IDE_SELECT_REG);
 	}
 
-	if (rq_data_dir(rq) == READ) {
-		if (dma && !hwif->ide_dma_read(drive))
-			return ide_started;
-
-		command = ((drive->mult_count) ?
-			   ((lba48) ? WIN_MULTREAD_EXT : WIN_MULTREAD) :
-			   ((lba48) ? WIN_READ_EXT : WIN_READ));
-		ide_execute_command(drive, command, &read_intr, WAIT_CMD, NULL);
-		return ide_started;
-	} else {
-		ide_startstop_t startstop;
-
-		if (dma && !hwif->ide_dma_write(drive))
+	if (dma) {
+		if (!hwif->dma_setup(drive)) {
+			if (rq_data_dir(rq)) {
+				command = lba48 ? WIN_WRITEDMA_EXT : WIN_WRITEDMA;
+				if (drive->vdma)
+					command = lba48 ? WIN_WRITE_EXT: WIN_WRITE;
+			} else {
+				command = lba48 ? WIN_READDMA_EXT : WIN_READDMA;
+				if (drive->vdma)
+					command = lba48 ? WIN_READ_EXT: WIN_READ;
+			}
+			hwif->dma_exec_cmd(drive, command);
+			hwif->dma_start(drive);
 			return ide_started;
-
-		command = ((drive->mult_count) ?
-			   ((lba48) ? WIN_MULTWRITE_EXT : WIN_MULTWRITE) :
-			   ((lba48) ? WIN_WRITE_EXT : WIN_WRITE));
-		hwif->OUTB(command, IDE_COMMAND_REG);
-
-		if (ide_wait_stat(&startstop, drive, DATA_READY,
-				drive->bad_wstat, WAIT_DRQ)) {
-			printk(KERN_ERR "%s: no DRQ after issuing %s\n",
-				drive->name,
-				drive->mult_count ? "MULTWRITE" : "WRITE");
-			return startstop;
 		}
-		if (!drive->unmask)
-			local_irq_disable();
-		if (drive->mult_count) {
-			ide_hwgroup_t *hwgroup = HWGROUP(drive);
-
-			hwgroup->wrq = *rq; /* scratchpad */
-			ide_set_handler(drive, &multwrite_intr, WAIT_CMD, NULL);
-			ide_multwrite(drive, drive->mult_count);
-		} else {
-			unsigned long flags;
-			char *to = ide_map_buffer(rq, &flags);
-			ide_set_handler(drive, &write_intr, WAIT_CMD, NULL);
-			taskfile_output_data(drive, to, SECTOR_WORDS);
-			ide_unmap_buffer(rq, to, &flags);
-		}
-		return ide_started;
-	}
-}
-EXPORT_SYMBOL_GPL(__ide_do_rw_disk);
-
-#else /* CONFIG_IDE_TASKFILE_IO */
-
-static ide_startstop_t chs_rw_disk(ide_drive_t *, struct request *, unsigned long);
-static ide_startstop_t lba_28_rw_disk(ide_drive_t *, struct request *, unsigned long);
-static ide_startstop_t lba_48_rw_disk(ide_drive_t *, struct request *, unsigned long long);
-
-/*
- * __ide_do_rw_disk() issues READ and WRITE commands to a disk,
- * using LBA if supported, or CHS otherwise, to address sectors.
- * It also takes care of issuing special DRIVE_CMDs.
- */
-ide_startstop_t __ide_do_rw_disk (ide_drive_t *drive, struct request *rq, sector_t block)
-{
-	/*
-	 * 268435455  == 137439 MB or 28bit limit
-	 *
-	 * need to add split taskfile operations based on 28bit threshold.
-	 */
-	if (drive->addressing == 1)		/* 48-bit LBA */
-		return lba_48_rw_disk(drive, rq, (unsigned long long) block);
-	if (drive->select.b.lba)		/* 28-bit LBA */
-		return lba_28_rw_disk(drive, rq, (unsigned long) block);
-
-	/* 28-bit CHS : DIE DIE DIE piece of legacy crap!!! */
-	return chs_rw_disk(drive, rq, (unsigned long) block);
-}
-EXPORT_SYMBOL_GPL(__ide_do_rw_disk);
-
-static u8 get_command(ide_drive_t *drive, struct request *rq, ide_task_t *task)
-{
-	unsigned int lba48 = (drive->addressing == 1) ? 1 : 0;
-	unsigned int dma = drive->using_dma;
-
-	if (drive->hwif->no_lba48_dma && lba48 && dma) {
-		if (rq->sector + rq->nr_sectors > 1ULL << 28)
-			dma = 0;
+		/* fallback to PIO */
+		ide_init_sg_cmd(drive, rq);
 	}
 
 	if (rq_data_dir(rq) == READ) {
-		task->command_type = IDE_DRIVE_TASK_IN;
-		if (dma)
-			return lba48 ? WIN_READDMA_EXT : WIN_READDMA;
-		task->handler = &task_in_intr;
+
 		if (drive->mult_count) {
-			task->data_phase = TASKFILE_MULTI_IN;
-			return lba48 ? WIN_MULTREAD_EXT : WIN_MULTREAD;
+			hwif->data_phase = TASKFILE_MULTI_IN;
+			command = lba48 ? WIN_MULTREAD_EXT : WIN_MULTREAD;
+		} else {
+			hwif->data_phase = TASKFILE_IN;
+			command = lba48 ? WIN_READ_EXT : WIN_READ;
 		}
-		task->data_phase = TASKFILE_IN;
-		return lba48 ? WIN_READ_EXT : WIN_READ;
+
+		ide_execute_command(drive, command, &task_in_intr, WAIT_CMD, NULL);
+		return ide_started;
 	} else {
-		task->command_type = IDE_DRIVE_TASK_RAW_WRITE;
-		if (dma)
-			return lba48 ? WIN_WRITEDMA_EXT : WIN_WRITEDMA;
-		task->prehandler = &pre_task_out_intr;
-		task->handler = &task_out_intr;
 		if (drive->mult_count) {
-			task->data_phase = TASKFILE_MULTI_OUT;
-			return lba48 ? WIN_MULTWRITE_EXT : WIN_MULTWRITE;
+			hwif->data_phase = TASKFILE_MULTI_OUT;
+			command = lba48 ? WIN_MULTWRITE_EXT : WIN_MULTWRITE;
+		} else {
+			hwif->data_phase = TASKFILE_OUT;
+			command = lba48 ? WIN_WRITE_EXT : WIN_WRITE;
 		}
-		task->data_phase = TASKFILE_OUT;
-		return lba48 ? WIN_WRITE_EXT : WIN_WRITE;
-	}
-}
-
-static ide_startstop_t chs_rw_disk (ide_drive_t *drive, struct request *rq, unsigned long block)
-{
-	ide_task_t		args;
-	int			sectors;
-	ata_nsector_t		nsectors;
-	unsigned int track	= (block / drive->sect);
-	unsigned int sect	= (block % drive->sect) + 1;
-	unsigned int head	= (track % drive->head);
-	unsigned int cyl	= (track / drive->head);
-
-	nsectors.all = (u16) rq->nr_sectors;
-
-	pr_debug("%s: CHS=%u/%u/%u\n", drive->name, cyl, head, sect);
-
-	memset(&args, 0, sizeof(ide_task_t));
-
-	sectors	= (rq->nr_sectors == 256) ? 0x00 : rq->nr_sectors;
-
-	args.tfRegister[IDE_NSECTOR_OFFSET]	= sectors;
-	args.tfRegister[IDE_SECTOR_OFFSET]	= sect;
-	args.tfRegister[IDE_LCYL_OFFSET]	= cyl;
-	args.tfRegister[IDE_HCYL_OFFSET]	= (cyl>>8);
-	args.tfRegister[IDE_SELECT_OFFSET]	= head;
-	args.tfRegister[IDE_SELECT_OFFSET]	|= drive->select.all;
-	args.tfRegister[IDE_COMMAND_OFFSET]	= get_command(drive, rq, &args);
-	args.rq					= (struct request *) rq;
-	rq->special				= (ide_task_t *)&args;
-	drive->hwif->data_phase = args.data_phase;
-	return do_rw_taskfile(drive, &args);
-}
-
-static ide_startstop_t lba_28_rw_disk (ide_drive_t *drive, struct request *rq, unsigned long block)
-{
-	ide_task_t		args;
-	int			sectors;
-	ata_nsector_t		nsectors;
-
-	nsectors.all = (u16) rq->nr_sectors;
 
-	memset(&args, 0, sizeof(ide_task_t));
-
-	sectors = (rq->nr_sectors == 256) ? 0x00 : rq->nr_sectors;
+		/* FIXME: ->OUTBSYNC ? */
+		hwif->OUTB(command, IDE_COMMAND_REG);
 
-	args.tfRegister[IDE_NSECTOR_OFFSET]	= sectors;
-	args.tfRegister[IDE_SECTOR_OFFSET]	= block;
-	args.tfRegister[IDE_LCYL_OFFSET]	= (block>>=8);
-	args.tfRegister[IDE_HCYL_OFFSET]	= (block>>=8);
-	args.tfRegister[IDE_SELECT_OFFSET]	= ((block>>8)&0x0f);
-	args.tfRegister[IDE_SELECT_OFFSET]	|= drive->select.all;
-	args.tfRegister[IDE_COMMAND_OFFSET]	= get_command(drive, rq, &args);
-	args.rq					= (struct request *) rq;
-	rq->special				= (ide_task_t *)&args;
-	drive->hwif->data_phase = args.data_phase;
-	return do_rw_taskfile(drive, &args);
+		return pre_task_out_intr(drive, rq);
+	}
 }
 
 /*
@@ -592,38 +262,6 @@
  * 1073741822 == 549756 MB or 48bit addressing fake drive
  */
 
-static ide_startstop_t lba_48_rw_disk (ide_drive_t *drive, struct request *rq, unsigned long long block)
-{
-	ide_task_t		args;
-	int			sectors;
-	ata_nsector_t		nsectors;
-
-	nsectors.all = (u16) rq->nr_sectors;
-
-	memset(&args, 0, sizeof(ide_task_t));
-
-	sectors = (rq->nr_sectors == 65536) ? 0 : rq->nr_sectors;
-
-	args.tfRegister[IDE_NSECTOR_OFFSET]	= sectors;
-	args.hobRegister[IDE_NSECTOR_OFFSET]	= sectors >> 8;
-	args.tfRegister[IDE_SECTOR_OFFSET]	= block;	/* low lba */
-	args.tfRegister[IDE_LCYL_OFFSET]	= (block>>=8);	/* mid lba */
-	args.tfRegister[IDE_HCYL_OFFSET]	= (block>>=8);	/* hi  lba */
-	args.tfRegister[IDE_SELECT_OFFSET]	= drive->select.all;
-	args.tfRegister[IDE_COMMAND_OFFSET]	= get_command(drive, rq, &args);
-	args.hobRegister[IDE_SECTOR_OFFSET]	= (block>>=8);	/* low lba */
-	args.hobRegister[IDE_LCYL_OFFSET]	= (block>>=8);	/* mid lba */
-	args.hobRegister[IDE_HCYL_OFFSET]	= (block>>=8);	/* hi  lba */
-	args.hobRegister[IDE_SELECT_OFFSET]	= drive->select.all;
-	args.hobRegister[IDE_CONTROL_OFFSET_HOB]= (drive->ctl|0x80);
-	args.rq					= (struct request *) rq;
-	rq->special				= (ide_task_t *)&args;
-	drive->hwif->data_phase = args.data_phase;
-	return do_rw_taskfile(drive, &args);
-}
-
-#endif /* CONFIG_IDE_TASKFILE_IO */
-
 static ide_startstop_t ide_do_rw_disk (ide_drive_t *drive, struct request *rq, sector_t block)
 {
 	ide_hwif_t *hwif = HWIF(drive);
@@ -641,196 +279,9 @@
 		 block, rq->nr_sectors, (unsigned long)rq->buffer);
 
 	if (hwif->rw_disk)
-		return hwif->rw_disk(drive, rq, block);
-	else
-		return __ide_do_rw_disk(drive, rq, block);
-}
-
-static u8 idedisk_dump_status (ide_drive_t *drive, const char *msg, u8 stat)
-{
-	ide_hwif_t *hwif = HWIF(drive);
-	unsigned long flags;
-	u8 err = 0;
+		hwif->rw_disk(drive, rq);
 
-	local_irq_set(flags);
-	printk("%s: %s: status=0x%02x", drive->name, msg, stat);
-	printk(" { ");
-	if (stat & BUSY_STAT)
-		printk("Busy ");
-	else {
-		if (stat & READY_STAT)	printk("DriveReady ");
-		if (stat & WRERR_STAT)	printk("DeviceFault ");
-		if (stat & SEEK_STAT)	printk("SeekComplete ");
-		if (stat & DRQ_STAT)	printk("DataRequest ");
-		if (stat & ECC_STAT)	printk("CorrectedError ");
-		if (stat & INDEX_STAT)	printk("Index ");
-		if (stat & ERR_STAT)	printk("Error ");
-	}
-	printk("}");
-	printk("\n");
-	if ((stat & (BUSY_STAT|ERR_STAT)) == ERR_STAT) {
-		err = hwif->INB(IDE_ERROR_REG);
-		printk("%s: %s: error=0x%02x", drive->name, msg, err);
-		printk(" { ");
-		if (err & ABRT_ERR)	printk("DriveStatusError ");
-		if (err & ICRC_ERR)
-			printk("Bad%s ", (err & ABRT_ERR) ? "CRC" : "Sector");
-		if (err & ECC_ERR)	printk("UncorrectableError ");
-		if (err & ID_ERR)	printk("SectorIdNotFound ");
-		if (err & TRK0_ERR)	printk("TrackZeroNotFound ");
-		if (err & MARK_ERR)	printk("AddrMarkNotFound ");
-		printk("}");
-		if ((err & (BBD_ERR | ABRT_ERR)) == BBD_ERR ||
-		    (err & (ECC_ERR|ID_ERR|MARK_ERR))) {
-			if (drive->addressing == 1) {
-				__u64 sectors = 0;
-				u32 low = 0, high = 0;
-				low = ide_read_24(drive);
-				hwif->OUTB(drive->ctl|0x80, IDE_CONTROL_REG);
-				high = ide_read_24(drive);
-				sectors = ((__u64)high << 24) | low;
-				printk(", LBAsect=%llu, high=%d, low=%d",
-				       (unsigned long long) sectors,
-				       high, low);
-			} else {
-				u8 cur = hwif->INB(IDE_SELECT_REG);
-				if (cur & 0x40) {	/* using LBA? */
-					printk(", LBAsect=%ld", (unsigned long)
-					 ((cur&0xf)<<24)
-					 |(hwif->INB(IDE_HCYL_REG)<<16)
-					 |(hwif->INB(IDE_LCYL_REG)<<8)
-					 | hwif->INB(IDE_SECTOR_REG));
-				} else {
-					printk(", CHS=%d/%d/%d",
-					 (hwif->INB(IDE_HCYL_REG)<<8) +
-					  hwif->INB(IDE_LCYL_REG),
-					  cur & 0xf,
-					  hwif->INB(IDE_SECTOR_REG));
-				}
-			}
-			if (HWGROUP(drive) && HWGROUP(drive)->rq)
-				printk(", sector=%llu",
-					(unsigned long long)HWGROUP(drive)->rq->sector);
-		}
-	}
-	printk("\n");
-	{
-		struct request *rq;
-		unsigned char opcode = 0;
-		int found = 0;
-
-		spin_lock(&ide_lock);
-		rq = HWGROUP(drive)->rq;
-		spin_unlock(&ide_lock);
-		if (!rq)
-			goto out;
-		if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK)) {
-			char *args = rq->buffer;
-			if (args) {
-				opcode = args[0];
-				found = 1;
-			}
-		} else if (rq->flags & REQ_DRIVE_TASKFILE) {
-			ide_task_t *args = rq->special;
-			if (args) {
-				task_struct_t *tf = (task_struct_t *) args->tfRegister;
-				opcode = tf->command;
-				found = 1;
-			}
-		}
-		printk("ide: failed opcode was: ");
-		if (!found)
-			printk("unknown\n");
-		else
-			printk("0x%02x\n", opcode);
-	}
-out:
-	local_irq_restore(flags);
-	return err;
-}
-
-ide_startstop_t idedisk_error (ide_drive_t *drive, const char *msg, u8 stat)
-{
-	ide_hwif_t *hwif;
-	struct request *rq;
-	u8 err;
-
-	err = idedisk_dump_status(drive, msg, stat);
-
-	if (drive == NULL || (rq = HWGROUP(drive)->rq) == NULL)
-		return ide_stopped;
-
-	hwif = HWIF(drive);
-	/* retry only "normal" I/O: */
-	if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK | REQ_DRIVE_TASKFILE)) {
-		rq->errors = 1;
-		ide_end_drive_cmd(drive, stat, err);
-		return ide_stopped;
-	}
-#ifdef CONFIG_IDE_TASKFILE_IO
-	/* make rq completion pointers new submission pointers */
-	blk_rq_prep_restart(rq);
-#endif
-
-	if (stat & BUSY_STAT || ((stat & WRERR_STAT) && !drive->nowerr)) {
-		/* other bits are useless when BUSY */
-		rq->errors |= ERROR_RESET;
-	} else if (stat & ERR_STAT) {
-		/* err has different meaning on cdrom and tape */
-		if (err == ABRT_ERR) {
-			if (drive->select.b.lba &&
-			    /* some newer drives don't support WIN_SPECIFY */
-			    hwif->INB(IDE_COMMAND_REG) == WIN_SPECIFY)
-				return ide_stopped;
-		} else if ((err & BAD_CRC) == BAD_CRC) {
-			/* UDMA crc error, just retry the operation */
-			drive->crc_count++;
-		} else if (err & (BBD_ERR | ECC_ERR)) {
-			/* retries won't help these */
-			rq->errors = ERROR_MAX;
-		} else if (err & TRK0_ERR) {
-			/* help it find track zero */
-			rq->errors |= ERROR_RECAL;
-		}
-	}
-	if ((stat & DRQ_STAT) && rq_data_dir(rq) == READ)
-		try_to_flush_leftover_data(drive);
-	if (hwif->INB(IDE_STATUS_REG) & (BUSY_STAT|DRQ_STAT)) {
-		/* force an abort */
-		hwif->OUTB(WIN_IDLEIMMEDIATE,IDE_COMMAND_REG);
-	}
-	if (rq->errors >= ERROR_MAX || blk_noretry_request(rq))
-		DRIVER(drive)->end_request(drive, 0, 0);
-	else {
-		if ((rq->errors & ERROR_RESET) == ERROR_RESET) {
-			++rq->errors;
-			return ide_do_reset(drive);
-		}
-		if ((rq->errors & ERROR_RECAL) == ERROR_RECAL)
-			drive->special.b.recalibrate = 1;
-		++rq->errors;
-	}
-	return ide_stopped;
-}
-
-ide_startstop_t idedisk_abort(ide_drive_t *drive, const char *msg)
-{
-	ide_hwif_t *hwif;
-	struct request *rq;
-
-	if (drive == NULL || (rq = HWGROUP(drive)->rq) == NULL)
-		return ide_stopped;
-
-	hwif = HWIF(drive);
-
-	if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK | REQ_DRIVE_TASKFILE)) {
-		rq->errors = 1;
-		ide_end_drive_cmd(drive, BUSY_STAT, 0);
-		return ide_stopped;
-	}
-
-	DRIVER(drive)->end_request(drive, 0, 0);
-	return ide_stopped;
+	return __ide_do_rw_disk(drive, rq, block);
 }
 
 /*
@@ -1006,9 +457,6 @@
 			 capacity, sectors_to_MB(capacity),
 			 set_max, sectors_to_MB(set_max));
 
-	if (!drive->stroke)
-		return;
-
 	if (lba48)
 		set_max = idedisk_set_max_address_ext(drive, set_max);
 	else
@@ -1066,6 +514,8 @@
 	return drive->capacity64 - drive->sect0;
 }
 
+#define IS_PDC4030_DRIVE	0
+
 static ide_startstop_t idedisk_special (ide_drive_t *drive)
 {
 	special_t *s = &drive->special;
@@ -1176,6 +626,7 @@
 	args.tfRegister[IDE_HCYL_OFFSET]	= SMART_HCYL_PASS;
 	args.tfRegister[IDE_COMMAND_OFFSET]	= WIN_SMART;
 	args.command_type			= IDE_DRIVE_TASK_IN;
+	args.data_phase				= TASKFILE_IN;
 	args.handler				= &task_in_intr;
 	(void) smart_enable(drive);
 	return ide_raw_taskfile(drive, &args, buf);
@@ -1605,7 +1056,7 @@
 	printk(", CHS=%d/%d/%d", 
 	       drive->bios_cyl, drive->bios_head, drive->bios_sect);
 	if (drive->using_dma)
-		(void) HWIF(drive)->ide_dma_verbose(drive);
+		ide_dma_verbose(drive);
 	printk("\n");
 
 	drive->mult_count = 0;
@@ -1721,9 +1172,6 @@
 	.supports_dsc_overlap	= 0,
 	.cleanup		= idedisk_cleanup,
 	.do_request		= ide_do_rw_disk,
-	.sense			= idedisk_dump_status,
-	.error			= idedisk_error,
-	.abort			= idedisk_abort,
 	.pre_reset		= idedisk_pre_reset,
 	.capacity		= idedisk_capacity,
 	.special		= idedisk_special,
@@ -1797,7 +1245,7 @@
 static int idedisk_revalidate_disk(struct gendisk *disk)
 {
 	ide_drive_t *drive = disk->private_data;
-	set_capacity(disk, current_capacity(drive));
+	set_capacity(disk, idedisk_capacity(drive));
 	return 0;
 }
 
@@ -1841,7 +1289,7 @@
 	strcpy(g->devfs_name, drive->devfs_name);
 	g->driverfs_dev = &drive->gendev;
 	g->flags = drive->removable ? GENHD_FL_REMOVABLE : 0;
-	set_capacity(g, current_capacity(drive));
+	set_capacity(g, idedisk_capacity(drive));
 	g->fops = &idedisk_ops;
 	add_disk(g);
 	return 0;
diff -Naur linuxppc-2.6.9/drivers/ide/ide-dma.c linuxppc-2.6.9-dream/drivers/ide/ide-dma.c
--- linuxppc-2.6.9/drivers/ide/ide-dma.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-dma.c	2005-06-20 10:46:10.000000000 +0200
@@ -85,6 +85,7 @@
 #include <linux/init.h>
 #include <linux/ide.h>
 #include <linux/delay.h>
+#include <linux/scatterlist.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -115,7 +116,6 @@
 	{ "Compaq CRD-8241B"	,	"ALL"		},
 	{ "CRD-8400B"		,	"ALL"		},
 	{ "CRD-8480B",			"ALL"		},
-	{ "CRD-8480C",			"ALL"		},
 	{ "CRD-8482B",			"ALL"		},
  	{ "CRD-84"		,	"ALL"		},
 	{ "SanDisk SDP3B"	,	"ALL"		},
@@ -128,14 +128,11 @@
 	{ "CD-532E-A"		,	"ALL"		},
 	{ "E-IDE CD-ROM CR-840",	"ALL"		},
 	{ "CD-ROM Drive/F5A",	"ALL"		},
-	{ "RICOH CD-R/RW MP7083A",	"ALL"		},
 	{ "WPI CDD-820",		"ALL"		},
 	{ "SAMSUNG CD-ROM SC-148C",	"ALL"		},
-	{ "SAMSUNG CD-ROM SC-148F",	"ALL"		},
 	{ "SAMSUNG CD-ROM SC",	"ALL"		},
 	{ "SanDisk SDP3B-64"	,	"ALL"		},
 	{ "SAMSUNG CD-ROM SN-124",	"ALL"		},
-	{ "PLEXTOR CD-R PX-W8432T",	"ALL"		},
 	{ "ATAPI CD-ROM DRIVE 40X MAXIMUM",	"ALL"		},
 	{ "_NEC DV5800A",               "ALL"           },  
 	{ NULL			,	NULL		}
@@ -161,7 +158,6 @@
 	return 0;
 }
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
  *	ide_dma_intr	-	IDE DMA interrupt handler
  *	@drive: the drive the interrupt is for
@@ -186,11 +182,12 @@
 		printk(KERN_ERR "%s: dma_intr: bad DMA status (dma_stat=%x)\n", 
 		       drive->name, dma_stat);
 	}
-	return DRIVER(drive)->error(drive, "dma_intr", stat);
+	return ide_error(drive, "dma_intr", stat);
 }
 
 EXPORT_SYMBOL_GPL(ide_dma_intr);
 
+#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
  *	ide_build_sglist	-	map IDE scatter gather for DMA I/O
  *	@drive: the drive to build the DMA table for
@@ -206,73 +203,23 @@
 {
 	ide_hwif_t *hwif = HWIF(drive);
 	struct scatterlist *sg = hwif->sg_table;
-	int nents;
 
-	nents = blk_rq_map_sg(drive->queue, rq, hwif->sg_table);
-		
+	if ((rq->flags & REQ_DRIVE_TASKFILE) && rq->nr_sectors > 256)
+		BUG();
+
+	ide_map_sg(drive, rq);
+
 	if (rq_data_dir(rq) == READ)
 		hwif->sg_dma_direction = PCI_DMA_FROMDEVICE;
 	else
 		hwif->sg_dma_direction = PCI_DMA_TODEVICE;
 
-	return pci_map_sg(hwif->pci_dev, sg, nents, hwif->sg_dma_direction);
+	return pci_map_sg(hwif->pci_dev, sg, hwif->sg_nents, hwif->sg_dma_direction);
 }
 
 EXPORT_SYMBOL_GPL(ide_build_sglist);
 
 /**
- *	ide_raw_build_sglist	-	map IDE scatter gather for DMA
- *	@drive: the drive to build the DMA table for
- *	@rq: the request holding the sg list
- *
- *	Perform the PCI mapping magic necessary to access the source or
- *	target buffers of a taskfile request via PCI DMA. The lower layers 
- *	of the  kernel provide the necessary cache management so that we can
- *	operate in a portable fashion
- */
-
-int ide_raw_build_sglist(ide_drive_t *drive, struct request *rq)
-{
-	ide_hwif_t *hwif = HWIF(drive);
-	struct scatterlist *sg = hwif->sg_table;
-	int nents = 0;
-	ide_task_t *args = rq->special;
-	u8 *virt_addr = rq->buffer;
-	int sector_count = rq->nr_sectors;
-
-	if (args->command_type == IDE_DRIVE_TASK_RAW_WRITE)
-		hwif->sg_dma_direction = PCI_DMA_TODEVICE;
-	else
-		hwif->sg_dma_direction = PCI_DMA_FROMDEVICE;
-
-#if 1
-	if (sector_count > 256)
-		BUG();
-
-	if (sector_count > 128) {
-#else
-	while (sector_count > 128) {
-#endif
-		memset(&sg[nents], 0, sizeof(*sg));
-		sg[nents].page = virt_to_page(virt_addr);
-		sg[nents].offset = offset_in_page(virt_addr);
-		sg[nents].length = 128  * SECTOR_SIZE;
-		nents++;
-		virt_addr = virt_addr + (128 * SECTOR_SIZE);
-		sector_count -= 128;
-	}
-	memset(&sg[nents], 0, sizeof(*sg));
-	sg[nents].page = virt_to_page(virt_addr);
-	sg[nents].offset = offset_in_page(virt_addr);
-	sg[nents].length =  sector_count  * SECTOR_SIZE;
-	nents++;
-
-	return pci_map_sg(hwif->pci_dev, sg, nents, hwif->sg_dma_direction);
-}
-
-EXPORT_SYMBOL_GPL(ide_raw_build_sglist);
-
-/**
  *	ide_build_dmatable	-	build IDE DMA table
  *
  *	ide_build_dmatable() prepares a dma request. We map the command
@@ -280,7 +227,9 @@
  *	the PRD table that the IDE layer wants to be fed. The code
  *	knows about the 64K wrap bug in the CS5530.
  *
- *	Returns 0 if all went okay, returns 1 otherwise.
+ *	Returns the number of built PRD entries if all went okay,
+ *	returns 0 otherwise.
+ *
  *	May also be invoked from trm290.c
  */
  
@@ -293,10 +242,7 @@
 	int i;
 	struct scatterlist *sg;
 
-	if (HWGROUP(drive)->rq->flags & REQ_DRIVE_TASKFILE)
-		hwif->sg_nents = i = ide_raw_build_sglist(drive, rq);
-	else
-		hwif->sg_nents = i = ide_build_sglist(drive, rq);
+	hwif->sg_nents = i = ide_build_sglist(drive, rq);
 
 	if (!i)
 		return 0;
@@ -590,10 +536,8 @@
 EXPORT_SYMBOL(__ide_dma_check);
 
 /**
- *	ide_start_dma	-	begin a DMA phase
- *	@hwif: interface
+ *	ide_dma_setup	-	begin a DMA phase
  *	@drive: target device
- *	@reading: set if reading, clear if writing
  *
  *	Build an IDE DMA PRD (IDE speak for scatter gather table)
  *	and then set up the DMA transfer registers for a device
@@ -603,15 +547,24 @@
  *	Returns 0 on success. If a PIO fallback is required then 1
  *	is returned. 
  */
- 
-int ide_start_dma(ide_hwif_t *hwif, ide_drive_t *drive, int reading)
+
+int ide_dma_setup(ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	struct request *rq = HWGROUP(drive)->rq;
+	unsigned int reading;
 	u8 dma_stat;
 
+	if (rq_data_dir(rq))
+		reading = 0;
+	else
+		reading = 1 << 3;
+
 	/* fall back to pio! */
-	if (!ide_build_dmatable(drive, rq))
+	if (!ide_build_dmatable(drive, rq)) {
+		ide_map_sg(drive, rq);
 		return 1;
+	}
 
 	/* PRD table */
 	hwif->OUTL(hwif->dmatable_dma, hwif->dma_prdtable);
@@ -628,73 +581,15 @@
 	return 0;
 }
 
-EXPORT_SYMBOL(ide_start_dma);
+EXPORT_SYMBOL_GPL(ide_dma_setup);
 
-int __ide_dma_read (ide_drive_t *drive /*, struct request *rq */)
+static void ide_dma_exec_cmd(ide_drive_t *drive, u8 command)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
-	struct request *rq	= HWGROUP(drive)->rq;
-	unsigned int reading	= 1 << 3;
-	u8 lba48		= (drive->addressing == 1) ? 1 : 0;
-	task_ioreg_t command	= WIN_NOP;
-
-	/* try pio */
-	if (ide_start_dma(hwif, drive, reading))
-		return 1;
-
-	if (drive->media != ide_disk)
-		return 0;
-
-	command = (lba48) ? WIN_READDMA_EXT : WIN_READDMA;
-	
-	if (drive->vdma)
-		command = (lba48) ? WIN_READ_EXT: WIN_READ;
-		
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-
 	/* issue cmd to drive */
 	ide_execute_command(drive, command, &ide_dma_intr, 2*WAIT_CMD, dma_timer_expiry);
-	return hwif->ide_dma_begin(drive);
 }
 
-EXPORT_SYMBOL(__ide_dma_read);
-
-int __ide_dma_write (ide_drive_t *drive /*, struct request *rq */)
-{
-	ide_hwif_t *hwif	= HWIF(drive);
-	struct request *rq	= HWGROUP(drive)->rq;
-	unsigned int reading	= 0;
-	u8 lba48		= (drive->addressing == 1) ? 1 : 0;
-	task_ioreg_t command	= WIN_NOP;
-
-	/* try PIO instead of DMA */
-	if (ide_start_dma(hwif, drive, reading))
-		return 1;
-
-	if (drive->media != ide_disk)
-		return 0;
-
-	command = (lba48) ? WIN_WRITEDMA_EXT : WIN_WRITEDMA;
-	if (drive->vdma)
-		command = (lba48) ? WIN_WRITE_EXT: WIN_WRITE;
-		
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-
-	/* issue cmd to drive */
-	ide_execute_command(drive, command, &ide_dma_intr, 2*WAIT_CMD, dma_timer_expiry);
-
-	return hwif->ide_dma_begin(drive);
-}
-
-EXPORT_SYMBOL(__ide_dma_write);
-
-int __ide_dma_begin (ide_drive_t *drive)
+void ide_dma_start(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 dma_cmd		= hwif->INB(hwif->dma_command);
@@ -708,10 +603,9 @@
 	hwif->OUTB(dma_cmd|1, hwif->dma_command);
 	hwif->dma = 1;
 	wmb();
-	return 0;
 }
 
-EXPORT_SYMBOL(__ide_dma_begin);
+EXPORT_SYMBOL_GPL(ide_dma_start);
 
 /* returns 1 on error, 0 otherwise */
 int __ide_dma_end (ide_drive_t *drive)
@@ -739,7 +633,7 @@
 EXPORT_SYMBOL(__ide_dma_end);
 
 /* returns 1 if dma irq issued, 0 otherwise */
-int __ide_dma_test_irq (ide_drive_t *drive)
+static int __ide_dma_test_irq(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 dma_stat		= hwif->INB(hwif->dma_status);
@@ -758,8 +652,6 @@
 			drive->name, __FUNCTION__);
 	return 0;
 }
-
-EXPORT_SYMBOL(__ide_dma_test_irq);
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
 int __ide_dma_bad_drive (ide_drive_t *drive)
@@ -785,17 +677,46 @@
 
 EXPORT_SYMBOL(__ide_dma_good_drive);
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
-int __ide_dma_verbose (ide_drive_t *drive)
+int ide_use_dma(ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+	ide_hwif_t *hwif = drive->hwif;
+
+	/* consult the list of known "bad" drives */
+	if (__ide_dma_bad_drive(drive))
+		return 0;
+
+	/* capable of UltraDMA modes */
+	if (id->field_valid & 4) {
+		if (hwif->ultra_mask & id->dma_ultra)
+			return 1;
+	}
+
+	/* capable of regular DMA modes */
+	if (id->field_valid & 2) {
+		if (hwif->mwdma_mask & id->dma_mword)
+			return 1;
+		if (hwif->swdma_mask & id->dma_1word)
+			return 1;
+	}
+
+	/* consult the list of known "good" drives */
+	if (__ide_dma_good_drive(drive) && id->eide_dma_time < 150)
+		return 1;
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(ide_use_dma);
+
+void ide_dma_verbose(ide_drive_t *drive)
 {
 	struct hd_driveid *id	= drive->id;
 	ide_hwif_t *hwif	= HWIF(drive);
 
 	if (id->field_valid & 4) {
-		if ((id->dma_ultra >> 8) && (id->dma_mword >> 8)) {
-			printk(", BUG DMA OFF");
-			return hwif->ide_dma_off_quietly(drive);
-		}
+		if ((id->dma_ultra >> 8) && (id->dma_mword >> 8))
+			goto bug_dma_off;
 		if (id->dma_ultra & ((id->dma_ultra >> 8) & hwif->ultra_mask)) {
 			if (((id->dma_ultra >> 11) & 0x1F) &&
 			    eighty_ninty_three(drive)) {
@@ -825,19 +746,22 @@
 			printk(", (U)DMA");	/* Can be BIOS-enabled! */
 		}
 	} else if (id->field_valid & 2) {
-		if ((id->dma_mword >> 8) && (id->dma_1word >> 8)) {
-			printk(", BUG DMA OFF");
-			return hwif->ide_dma_off_quietly(drive);
-		}
+		if ((id->dma_mword >> 8) && (id->dma_1word >> 8))
+			goto bug_dma_off;
 		printk(", DMA");
 	} else if (id->field_valid & 1) {
 		printk(", BUG");
 	}
-	return 1;
+	return;
+bug_dma_off:
+	printk(", BUG DMA OFF");
+	hwif->ide_dma_off_quietly(drive);
+	return;
 }
 
-EXPORT_SYMBOL(__ide_dma_verbose);
+EXPORT_SYMBOL(ide_dma_verbose);
 
+#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 int __ide_dma_lostirq (ide_drive_t *drive)
 {
 	printk("%s: DMA interrupt recovery\n", drive->name);
@@ -860,7 +784,7 @@
 /*
  * Needed for allowing full modular support of ide-driver
  */
-int ide_release_dma_engine (ide_hwif_t *hwif)
+static int ide_release_dma_engine(ide_hwif_t *hwif)
 {
 	if (hwif->dmatable_cpu) {
 		pci_free_consistent(hwif->pci_dev,
@@ -869,14 +793,10 @@
 				    hwif->dmatable_dma);
 		hwif->dmatable_cpu = NULL;
 	}
-	if (hwif->sg_table) {
-		kfree(hwif->sg_table);
-		hwif->sg_table = NULL;
-	}
 	return 1;
 }
 
-int ide_release_iomio_dma (ide_hwif_t *hwif)
+static int ide_release_iomio_dma(ide_hwif_t *hwif)
 {
 	if ((hwif->dma_extra) && (hwif->channel == 0))
 		release_region((hwif->dma_base + 16), hwif->dma_extra);
@@ -900,27 +820,23 @@
 	return ide_release_iomio_dma(hwif);
 }
 
-int ide_allocate_dma_engine (ide_hwif_t *hwif)
+static int ide_allocate_dma_engine(ide_hwif_t *hwif)
 {
 	hwif->dmatable_cpu = pci_alloc_consistent(hwif->pci_dev,
 						  PRD_ENTRIES * PRD_BYTES,
 						  &hwif->dmatable_dma);
-	hwif->sg_table = kmalloc(sizeof(struct scatterlist) * PRD_ENTRIES,
-				GFP_KERNEL);
 
-	if ((hwif->dmatable_cpu) && (hwif->sg_table))
+	if (hwif->dmatable_cpu)
 		return 0;
 
-	printk(KERN_ERR "%s: -- Error, unable to allocate%s%s table(s).\n",
-		(hwif->dmatable_cpu == NULL) ? " CPU" : "",
-		(hwif->sg_table == NULL) ?  " SG DMA" : " DMA",
-		hwif->cds->name);
+	printk(KERN_ERR "%s: -- Error, unable to allocate%s DMA table(s).\n",
+			hwif->cds->name, !hwif->dmatable_cpu ? " CPU" : "");
 
 	ide_release_dma_engine(hwif);
 	return 1;
 }
 
-int ide_mapped_mmio_dma (ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+static int ide_mapped_mmio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
 {
 	printk(KERN_INFO "    %s: MMIO-DMA ", hwif->name);
 
@@ -935,7 +851,7 @@
 	return 0;
 }
 
-int ide_iomio_dma (ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
 {
 	printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx",
 		hwif->name, base, base + ports - 1);
@@ -964,10 +880,7 @@
 	return 0;
 }
 
-/*
- * 
- */
-int ide_dma_iobase (ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+static int ide_dma_iobase(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
 {
 	if (hwif->mmio == 2)
 		return ide_mapped_mmio_dma(hwif, base,ports);
@@ -1009,18 +922,16 @@
 		hwif->ide_dma_host_on = &__ide_dma_host_on;
 	if (!hwif->ide_dma_check)
 		hwif->ide_dma_check = &__ide_dma_check;
-	if (!hwif->ide_dma_read)
-		hwif->ide_dma_read = &__ide_dma_read;
-	if (!hwif->ide_dma_write)
-		hwif->ide_dma_write = &__ide_dma_write;
-	if (!hwif->ide_dma_begin)
-		hwif->ide_dma_begin = &__ide_dma_begin;
+	if (!hwif->dma_setup)
+		hwif->dma_setup = &ide_dma_setup;
+	if (!hwif->dma_exec_cmd)
+		hwif->dma_exec_cmd = &ide_dma_exec_cmd;
+	if (!hwif->dma_start)
+		hwif->dma_start = &ide_dma_start;
 	if (!hwif->ide_dma_end)
 		hwif->ide_dma_end = &__ide_dma_end;
 	if (!hwif->ide_dma_test_irq)
 		hwif->ide_dma_test_irq = &__ide_dma_test_irq;
-	if (!hwif->ide_dma_verbose)
-		hwif->ide_dma_verbose = &__ide_dma_verbose;
 	if (!hwif->ide_dma_timeout)
 		hwif->ide_dma_timeout = &__ide_dma_timeout;
 	if (!hwif->ide_dma_lostirq)
diff -Naur linuxppc-2.6.9/drivers/ide/ide-floppy.c linuxppc-2.6.9-dream/drivers/ide/ide-floppy.c
--- linuxppc-2.6.9/drivers/ide/ide-floppy.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-floppy.c	2005-06-20 10:46:10.000000000 +0200
@@ -97,13 +97,13 @@
 #include <linux/slab.h>
 #include <linux/cdrom.h>
 #include <linux/ide.h>
+#include <linux/bitops.h>
 
 #include <asm/byteorder.h>
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/unaligned.h>
-#include <asm/bitops.h>
 
 /*
  *	The following are used to debug the driver.
@@ -585,7 +585,7 @@
 			count = min(bvec->bv_len, bcount);
 
 			data = bvec_kmap_irq(bvec, &flags);
-			atapi_input_bytes(drive, data, count);
+			drive->hwif->atapi_input_bytes(drive, data, count);
 			bvec_kunmap_irq(data, &flags);
 
 			bcount -= count;
@@ -619,7 +619,7 @@
 			count = min(bvec->bv_len, bcount);
 
 			data = bvec_kmap_irq(bvec, &flags);
-			atapi_output_bytes(drive, data, count);
+			drive->hwif->atapi_output_bytes(drive, data, count);
 			bvec_kunmap_irq(data, &flags);
 
 			bcount -= count;
@@ -989,12 +989,27 @@
 	return ide_started;
 }
 
+/**
+ * idefloppy_should_report_error()
+ *
+ * Supresses error messages resulting from Medium not present
+ */
+static inline int idefloppy_should_report_error(idefloppy_floppy_t *floppy)
+{
+	if (floppy->sense_key == 0x02 &&
+	    floppy->asc       == 0x3a &&
+	    floppy->ascq      == 0x00)
+		return 0;
+	return 1;
+}
+
 /*
  *	Issue a packet command
  */
 static ide_startstop_t idefloppy_issue_pc (ide_drive_t *drive, idefloppy_pc_t *pc)
 {
 	idefloppy_floppy_t *floppy = drive->driver_data;
+	ide_hwif_t *hwif = drive->hwif;
 	atapi_feature_t feature;
 	atapi_bcount_t bcount;
 	ide_handler_t *pkt_xfer_routine;
@@ -1021,12 +1036,13 @@
 		 */
 		if (!test_bit(PC_ABORT, &pc->flags)) {
 			if (!test_bit(PC_SUPPRESS_ERROR, &pc->flags)) {
-				printk(KERN_ERR "ide-floppy: %s: I/O error, "
-						"pc = %2x, key = %2x, "
-						"asc = %2x, ascq = %2x\n",
-						drive->name, pc->c[0],
-						floppy->sense_key,
-						floppy->asc, floppy->ascq);
+				if (idefloppy_should_report_error(floppy))
+					printk(KERN_ERR "ide-floppy: %s: I/O error, "
+					       "pc = %2x, key = %2x, "
+					       "asc = %2x, ascq = %2x\n",
+					       drive->name, pc->c[0],
+					       floppy->sense_key,
+					       floppy->asc, floppy->ascq);
 			}
 			/* Giving up */
 			pc->error = IDEFLOPPY_ERROR_GENERAL;
@@ -1049,13 +1065,8 @@
 	}
 	feature.all = 0;
 
-	if (test_bit(PC_DMA_RECOMMENDED, &pc->flags) && drive->using_dma) {
-		if (test_bit(PC_WRITING, &pc->flags)) {
-			feature.b.dma = !HWIF(drive)->ide_dma_write(drive);
-		} else {
-			feature.b.dma = !HWIF(drive)->ide_dma_read(drive);
-		}
-	}
+	if (test_bit(PC_DMA_RECOMMENDED, &pc->flags) && drive->using_dma)
+		feature.b.dma = !hwif->dma_setup(drive);
 
 	if (IDE_CONTROL_REG)
 		HWIF(drive)->OUTB(drive->ctl, IDE_CONTROL_REG);
@@ -1067,7 +1078,7 @@
 
 	if (feature.b.dma) {	/* Begin DMA, if necessary */
 		set_bit(PC_DMA_IN_PROGRESS, &pc->flags);
-		(void) (HWIF(drive)->ide_dma_begin(drive));
+		hwif->dma_start(drive);
 	}
 
 	/* Can we transfer the packet when we get the interrupt or wait? */
@@ -1242,11 +1253,13 @@
 			rq->nr_sectors, rq->current_nr_sectors);
 
 	if (rq->errors >= ERROR_MAX) {
-		if (floppy->failed_pc != NULL)
-			printk(KERN_ERR "ide-floppy: %s: I/O error, pc = %2x,"
-					" key = %2x, asc = %2x, ascq = %2x\n",
-				drive->name, floppy->failed_pc->c[0],
-				floppy->sense_key, floppy->asc, floppy->ascq);
+		if (floppy->failed_pc != NULL) {
+			if (idefloppy_should_report_error(floppy))
+				printk(KERN_ERR "ide-floppy: %s: I/O error, pc = %2x,"
+				       " key = %2x, asc = %2x, ascq = %2x\n",
+				       drive->name, floppy->failed_pc->c[0],
+				       floppy->sense_key, floppy->asc, floppy->ascq);
+		}
 		else
 			printk(KERN_ERR "ide-floppy: %s: I/O error\n",
 				drive->name);
@@ -1627,7 +1640,7 @@
 }
 
 /*
- *	Return the current floppy capacity to ide.c.
+ *	Return the current floppy capacity.
  */
 static sector_t idefloppy_capacity (ide_drive_t *drive)
 {
@@ -2021,7 +2034,7 @@
 static int idefloppy_revalidate_disk(struct gendisk *disk)
 {
 	ide_drive_t *drive = disk->private_data;
-	set_capacity(disk, current_capacity(drive));
+	set_capacity(disk, idefloppy_capacity(drive));
 	return 0;
 }
 
diff -Naur linuxppc-2.6.9/drivers/ide/ide-io.c linuxppc-2.6.9-dream/drivers/ide/ide-io.c
--- linuxppc-2.6.9/drivers/ide/ide-io.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-io.c	2005-06-20 10:46:10.000000000 +0200
@@ -47,6 +47,7 @@
 #include <linux/seq_file.h>
 #include <linux/device.h>
 #include <linux/kmod.h>
+#include <linux/scatterlist.h>
 
 #include <asm/byteorder.h>
 #include <asm/irq.h>
@@ -237,9 +238,10 @@
 		high = ide_read_24(drive);
 	} else {
 		u8 cur = HWIF(drive)->INB(IDE_SELECT_REG);
-		if (cur & 0x40)
+		if (cur & 0x40) {
+			high = cur & 0xf;
 			low = (hcyl << 16) | (lcyl << 8) | sect;
-		else {
+		} else {
 			low = hcyl * drive->head * drive->sect;
 			low += lcyl * drive->sect;
 			low += sect - 1;
@@ -436,7 +438,7 @@
  *	by read a sector's worth of data from the drive.  Of course,
  *	this may not help if the drive is *waiting* for data from *us*.
  */
-void try_to_flush_leftover_data (ide_drive_t *drive)
+static void try_to_flush_leftover_data (ide_drive_t *drive)
 {
 	int i = (drive->mult_count ? drive->mult_count : 1) * SECTOR_WORDS;
 
@@ -451,11 +453,88 @@
 	}
 }
 
-EXPORT_SYMBOL(try_to_flush_leftover_data);
+static ide_startstop_t ide_ata_error(ide_drive_t *drive, struct request *rq, u8 stat, u8 err)
+{
+	ide_hwif_t *hwif = drive->hwif;
 
-/*
- * FIXME Add an ATAPI error
- */
+	if (stat & BUSY_STAT || ((stat & WRERR_STAT) && !drive->nowerr)) {
+		/* other bits are useless when BUSY */
+		rq->errors |= ERROR_RESET;
+	} else if (stat & ERR_STAT) {
+		/* err has different meaning on cdrom and tape */
+		if (err == ABRT_ERR) {
+			if (drive->select.b.lba &&
+			    /* some newer drives don't support WIN_SPECIFY */
+			    hwif->INB(IDE_COMMAND_REG) == WIN_SPECIFY)
+				return ide_stopped;
+		} else if ((err & BAD_CRC) == BAD_CRC) {
+			/* UDMA crc error, just retry the operation */
+			drive->crc_count++;
+		} else if (err & (BBD_ERR | ECC_ERR)) {
+			/* retries won't help these */
+			rq->errors = ERROR_MAX;
+		} else if (err & TRK0_ERR) {
+			/* help it find track zero */
+			rq->errors |= ERROR_RECAL;
+		}
+	}
+
+	if ((stat & DRQ_STAT) && rq_data_dir(rq) == READ)
+		try_to_flush_leftover_data(drive);
+
+	if (hwif->INB(IDE_STATUS_REG) & (BUSY_STAT|DRQ_STAT))
+		/* force an abort */
+		hwif->OUTB(WIN_IDLEIMMEDIATE, IDE_COMMAND_REG);
+
+	if (rq->errors >= ERROR_MAX || blk_noretry_request(rq))
+		drive->driver->end_request(drive, 0, 0);
+	else {
+		if ((rq->errors & ERROR_RESET) == ERROR_RESET) {
+			++rq->errors;
+			return ide_do_reset(drive);
+		}
+		if ((rq->errors & ERROR_RECAL) == ERROR_RECAL)
+			drive->special.b.recalibrate = 1;
+		++rq->errors;
+	}
+	return ide_stopped;
+}
+
+static ide_startstop_t ide_atapi_error(ide_drive_t *drive, struct request *rq, u8 stat, u8 err)
+{
+	ide_hwif_t *hwif = drive->hwif;
+
+	if (stat & BUSY_STAT || ((stat & WRERR_STAT) && !drive->nowerr)) {
+		/* other bits are useless when BUSY */
+		rq->errors |= ERROR_RESET;
+	} else {
+		/* add decoding error stuff */
+	}
+
+	if (hwif->INB(IDE_STATUS_REG) & (BUSY_STAT|DRQ_STAT))
+		/* force an abort */
+		hwif->OUTB(WIN_IDLEIMMEDIATE, IDE_COMMAND_REG);
+
+	if (rq->errors >= ERROR_MAX) {
+		drive->driver->end_request(drive, 0, 0);
+	} else {
+		if ((rq->errors & ERROR_RESET) == ERROR_RESET) {
+			++rq->errors;
+			return ide_do_reset(drive);
+		}
+		++rq->errors;
+	}
+
+	return ide_stopped;
+}
+
+ide_startstop_t
+__ide_error(ide_drive_t *drive, struct request *rq, u8 stat, u8 err)
+{
+	if (drive->media == ide_disk)
+		return ide_ata_error(drive, rq, stat, err);
+	return ide_atapi_error(drive, rq, stat, err);
+}
 
 /**
  *	ide_error	-	handle an error on the IDE
@@ -472,78 +551,35 @@
  
 ide_startstop_t ide_error (ide_drive_t *drive, const char *msg, u8 stat)
 {
-	ide_hwif_t *hwif;
 	struct request *rq;
 	u8 err;
 
 	err = ide_dump_status(drive, msg, stat);
-	if (drive == NULL || (rq = HWGROUP(drive)->rq) == NULL)
+
+	if ((rq = HWGROUP(drive)->rq) == NULL)
 		return ide_stopped;
 
-	hwif = HWIF(drive);
 	/* retry only "normal" I/O: */
-	if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK)) {
-		rq->errors = 1;
-		ide_end_drive_cmd(drive, stat, err);
-		return ide_stopped;
-	}
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
+	if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK | REQ_DRIVE_TASKFILE)) {
 		rq->errors = 1;
 		ide_end_drive_cmd(drive, stat, err);
 		return ide_stopped;
 	}
 
-	if (stat & BUSY_STAT || ((stat & WRERR_STAT) && !drive->nowerr)) {
-		 /* other bits are useless when BUSY */
+	return drive->driver->error(drive, rq, stat, err);
+}
+
+EXPORT_SYMBOL_GPL(ide_error);
+
+ide_startstop_t __ide_abort(ide_drive_t *drive, struct request *rq)
+{
+	if (drive->media != ide_disk)
 		rq->errors |= ERROR_RESET;
-	} else {
-		if (drive->media != ide_disk)
-			goto media_out;
 
-		if (stat & ERR_STAT) {
-			/* err has different meaning on cdrom and tape */
-			if (err == ABRT_ERR) {
-				if (drive->select.b.lba &&
-				    (hwif->INB(IDE_COMMAND_REG) == WIN_SPECIFY))
-					/* some newer drives don't
-					 * support WIN_SPECIFY
-					 */
-					return ide_stopped;
-			} else if ((err & BAD_CRC) == BAD_CRC) {
-				drive->crc_count++;
-				/* UDMA crc error -- just retry the operation */
-			} else if (err & (BBD_ERR | ECC_ERR)) {
-				/* retries won't help these */
-				rq->errors = ERROR_MAX;
-			} else if (err & TRK0_ERR) {
-				/* help it find track zero */
-				rq->errors |= ERROR_RECAL;
-			}
-		}
-media_out:
-		if ((stat & DRQ_STAT) && rq_data_dir(rq) != WRITE)
-			try_to_flush_leftover_data(drive);
-	}
-	if (hwif->INB(IDE_STATUS_REG) & (BUSY_STAT|DRQ_STAT)) {
-		/* force an abort */
-		hwif->OUTB(WIN_IDLEIMMEDIATE,IDE_COMMAND_REG);
-	}
-	if (rq->errors >= ERROR_MAX) {
-		DRIVER(drive)->end_request(drive, 0, 0);
-	} else {
-		if ((rq->errors & ERROR_RESET) == ERROR_RESET) {
-			++rq->errors;
-			return ide_do_reset(drive);
-		}
-		if ((rq->errors & ERROR_RECAL) == ERROR_RECAL)
-			drive->special.b.recalibrate = 1;
-		++rq->errors;
-	}
+	DRIVER(drive)->end_request(drive, 0, 0);
 	return ide_stopped;
 }
 
-EXPORT_SYMBOL(ide_error);
-
 /**
  *	ide_abort	-	abort pending IDE operatins
  *	@drive: drive the error occurred on
@@ -560,32 +596,21 @@
  
 ide_startstop_t ide_abort(ide_drive_t *drive, const char *msg)
 {
-	ide_hwif_t *hwif;
 	struct request *rq;
 
 	if (drive == NULL || (rq = HWGROUP(drive)->rq) == NULL)
 		return ide_stopped;
 
-	hwif = HWIF(drive);
 	/* retry only "normal" I/O: */
-	if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK)) {
-		rq->errors = 1;
-		ide_end_drive_cmd(drive, BUSY_STAT, 0);
-		return ide_stopped;
-	}
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
+	if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK | REQ_DRIVE_TASKFILE)) {
 		rq->errors = 1;
 		ide_end_drive_cmd(drive, BUSY_STAT, 0);
 		return ide_stopped;
 	}
 
-	rq->errors |= ERROR_RESET;
-	DRIVER(drive)->end_request(drive, 0, 0);
-	return ide_stopped;
+	return drive->driver->abort(drive, rq);
 }
 
-EXPORT_SYMBOL(ide_abort);
-
 /**
  *	ide_cmd		-	issue a simple drive command
  *	@drive: drive the command is for
@@ -597,7 +622,8 @@
  *	The drive must be selected beforehand.
  */
 
-void ide_cmd (ide_drive_t *drive, u8 cmd, u8 nsect, ide_handler_t *handler)
+static void ide_cmd (ide_drive_t *drive, u8 cmd, u8 nsect,
+		ide_handler_t *handler)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 	if (IDE_CONTROL_REG)
@@ -607,8 +633,6 @@
 	ide_execute_command(drive, cmd, handler, WAIT_CMD, NULL);
 }
 
-EXPORT_SYMBOL(ide_cmd);
-
 /**
  *	drive_cmd_intr		- 	drive command completion interrupt
  *	@drive: drive the completion interrupt occurred on
@@ -619,7 +643,7 @@
  *	the request
  */
  
-ide_startstop_t drive_cmd_intr (ide_drive_t *drive)
+static ide_startstop_t drive_cmd_intr (ide_drive_t *drive)
 {
 	struct request *rq = HWGROUP(drive)->rq;
 	ide_hwif_t *hwif = HWIF(drive);
@@ -638,14 +662,12 @@
 	}
 
 	if (!OK_STAT(stat, READY_STAT, BAD_STAT) && DRIVER(drive) != NULL)
-		return DRIVER(drive)->error(drive, "drive_cmd", stat);
+		return ide_error(drive, "drive_cmd", stat);
 		/* calls ide_end_drive_cmd */
 	ide_end_drive_cmd(drive, stat, hwif->INB(IDE_ERROR_REG));
 	return ide_stopped;
 }
 
-EXPORT_SYMBOL(drive_cmd_intr);
-
 /**
  *	do_special		-	issue some special commands
  *	@drive: drive the command is for
@@ -655,7 +677,7 @@
  *	back.
  */
 
-ide_startstop_t do_special (ide_drive_t *drive)
+static ide_startstop_t do_special (ide_drive_t *drive)
 {
 	special_t *s = &drive->special;
 
@@ -672,7 +694,33 @@
 		return DRIVER(drive)->special(drive);
 }
 
-EXPORT_SYMBOL(do_special);
+void ide_map_sg(ide_drive_t *drive, struct request *rq)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct scatterlist *sg = hwif->sg_table;
+
+	if (hwif->sg_mapped)	/* needed by ide-scsi */
+		return;
+
+	if ((rq->flags & REQ_DRIVE_TASKFILE) == 0) {
+		hwif->sg_nents = blk_rq_map_sg(drive->queue, rq, sg);
+	} else {
+		sg_init_one(sg, rq->buffer, rq->nr_sectors * SECTOR_SIZE);
+		hwif->sg_nents = 1;
+	}
+}
+
+EXPORT_SYMBOL_GPL(ide_map_sg);
+
+void ide_init_sg_cmd(ide_drive_t *drive, struct request *rq)
+{
+	ide_hwif_t *hwif = drive->hwif;
+
+	hwif->nsect = hwif->nleft = rq->nr_sectors;
+	hwif->cursg = hwif->cursg_ofs = 0;
+}
+
+EXPORT_SYMBOL_GPL(ide_init_sg_cmd);
 
 /**
  *	execute_drive_command	-	issue special drive command
@@ -686,7 +734,8 @@
  *	all commands to finish. Don't do this as that is due to change
  */
 
-ide_startstop_t execute_drive_cmd (ide_drive_t *drive, struct request *rq)
+static ide_startstop_t execute_drive_cmd (ide_drive_t *drive,
+		struct request *rq)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 	if (rq->flags & REQ_DRIVE_TASKFILE) {
@@ -697,6 +746,17 @@
 
 		hwif->data_phase = args->data_phase;
 
+		switch (hwif->data_phase) {
+		case TASKFILE_MULTI_OUT:
+		case TASKFILE_OUT:
+		case TASKFILE_MULTI_IN:
+		case TASKFILE_IN:
+			ide_init_sg_cmd(drive, rq);
+			ide_map_sg(drive, rq);
+		default:
+			break;
+		}
+
 		if (args->tf_out_flags.all != 0) 
 			return flagged_taskfile(drive, args);
 		return do_rw_taskfile(drive, args);
@@ -765,8 +825,6 @@
  	return ide_stopped;
 }
 
-EXPORT_SYMBOL(execute_drive_cmd);
-
 /**
  *	start_request	-	start of I/O and command issuing for IDE
  *
@@ -778,7 +836,7 @@
  *	FIXME: this function needs a rename
  */
  
-ide_startstop_t start_request (ide_drive_t *drive, struct request *rq)
+static ide_startstop_t start_request (ide_drive_t *drive, struct request *rq)
 {
 	ide_startstop_t startstop;
 	sector_t block;
@@ -795,13 +853,6 @@
 		goto kill_rq;
 	}
 
-	/*
-	 * bail early if we've sent a device to sleep, however how to wake
-	 * this needs to be a masked flag.  FIXME for proper operations.
-	 */
-	if (drive->suspend_reset)
-		goto kill_rq;
-
 	block    = rq->sector;
 	if (blk_fs_request(rq) &&
 	    (drive->media == ide_disk || drive->media == ide_floppy)) {
@@ -869,8 +920,6 @@
 	return ide_stopped;
 }
 
-EXPORT_SYMBOL(start_request);
-
 /**
  *	ide_stall_queue		-	pause an IDE device
  *	@drive: drive to stall
@@ -885,6 +934,7 @@
 	if (timeout > WAIT_WORSTCASE)
 		timeout = WAIT_WORSTCASE;
 	drive->sleep = timeout + jiffies;
+	drive->sleeping = 1;
 }
 
 EXPORT_SYMBOL(ide_stall_queue);
@@ -924,18 +974,18 @@
 	}
 
 	do {
-		if ((!drive->sleep || time_after_eq(jiffies, drive->sleep))
+		if ((!drive->sleeping || time_after_eq(jiffies, drive->sleep))
 		    && !elv_queue_empty(drive->queue)) {
 			if (!best
-			 || (drive->sleep && (!best->sleep || 0 < (signed long)(best->sleep - drive->sleep)))
-			 || (!best->sleep && 0 < (signed long)(WAKEUP(best) - WAKEUP(drive))))
+			 || (drive->sleeping && (!best->sleeping || time_before(drive->sleep, best->sleep)))
+			 || (!best->sleeping && time_before(WAKEUP(drive), WAKEUP(best))))
 			{
 				if (!blk_queue_plugged(drive->queue))
 					best = drive;
 			}
 		}
 	} while ((drive = drive->next) != hwgroup->drive);
-	if (best && best->nice1 && !best->sleep && best != hwgroup->drive && best->service_time > WAIT_MIN_SLEEP) {
+	if (best && best->nice1 && !best->sleeping && best != hwgroup->drive && best->service_time > WAIT_MIN_SLEEP) {
 		long t = (signed long)(WAKEUP(best) - jiffies);
 		if (t >= WAIT_MIN_SLEEP) {
 		/*
@@ -944,10 +994,9 @@
 		 */
 			drive = best->next;
 			do {
-				if (!drive->sleep
-				/* FIXME: use time_before */
-				 && 0 < (signed long)(WAKEUP(drive) - (jiffies - best->service_time))
-				 && 0 < (signed long)((jiffies + t) - WAKEUP(drive)))
+				if (!drive->sleeping
+				 && time_before(jiffies - best->service_time, WAKEUP(drive))
+				 && time_before(WAKEUP(drive), jiffies + t))
 				{
 					ide_stall_queue(best, min_t(long, t, 10 * WAIT_MIN_SLEEP));
 					goto repeat;
@@ -993,10 +1042,7 @@
  * the driver.  This makes the driver much more friendlier to shared IRQs
  * than previous designs, while remaining 100% (?) SMP safe and capable.
  */
-/* --BenH: made non-static as ide-pmac.c uses it to kick the hwgroup back
- *         into life on wakeup from machine sleep.
- */ 
-void ide_do_request (ide_hwgroup_t *hwgroup, int masked_irq)
+static void ide_do_request (ide_hwgroup_t *hwgroup, int masked_irq)
 {
 	ide_drive_t	*drive;
 	ide_hwif_t	*hwif;
@@ -1013,14 +1059,17 @@
 		hwgroup->busy = 1;
 		drive = choose_drive(hwgroup);
 		if (drive == NULL) {
-			unsigned long sleep = 0;
+			int sleeping = 0;
+			unsigned long sleep = 0; /* shut up, gcc */
 			hwgroup->rq = NULL;
 			drive = hwgroup->drive;
 			do {
-				if (drive->sleep && (!sleep || 0 < (signed long)(sleep - drive->sleep)))
+				if (drive->sleeping && (!sleeping || time_before(drive->sleep, sleep))) {
+					sleeping = 1;
 					sleep = drive->sleep;
+				}
 			} while ((drive = drive->next) != hwgroup->drive);
-			if (sleep) {
+			if (sleeping) {
 		/*
 		 * Take a short snooze, and then wake up this hwgroup again.
 		 * This gives other hwgroups on the same a chance to
@@ -1060,7 +1109,7 @@
 		}
 		hwgroup->hwif = hwif;
 		hwgroup->drive = drive;
-		drive->sleep = 0;
+		drive->sleeping = 0;
 		drive->service_start = jiffies;
 
 		if (blk_queue_plugged(drive->queue)) {
@@ -1114,22 +1163,20 @@
 		 * happens anyway when any interrupt comes in, IDE or otherwise
 		 *  -- the kernel masks the IRQ while it is being handled.
 		 */
-		if (hwif->irq != masked_irq)
+		if (masked_irq != IDE_NO_IRQ && hwif->irq != masked_irq)
 			disable_irq_nosync(hwif->irq);
 		spin_unlock(&ide_lock);
 		local_irq_enable();
 			/* allow other IRQs while we start this request */
 		startstop = start_request(drive, rq);
 		spin_lock_irq(&ide_lock);
-		if (hwif->irq != masked_irq)
+		if (masked_irq != IDE_NO_IRQ && hwif->irq != masked_irq)
 			enable_irq(hwif->irq);
 		if (startstop == ide_stopped)
 			hwgroup->busy = 0;
 	}
 }
 
-EXPORT_SYMBOL(ide_do_request);
-
 /*
  * Passes the stuff to ide_do_request
  */
@@ -1158,7 +1205,7 @@
 	if (error < 0) {
 		printk(KERN_WARNING "%s: DMA timeout error\n", drive->name);
 		(void)HWIF(drive)->ide_dma_end(drive);
-		ret = DRIVER(drive)->error(drive, "dma timeout error",
+		ret = ide_error(drive, "dma timeout error",
 						hwif->INB(IDE_STATUS_REG));
 	} else {
 		printk(KERN_WARNING "%s: DMA timeout retry\n", drive->name);
@@ -1182,12 +1229,15 @@
 	HWGROUP(drive)->rq = NULL;
 
 	rq->errors = 0;
+
+	if (!rq->bio)
+		goto out;
+
 	rq->sector = rq->bio->bi_sector;
 	rq->current_nr_sectors = bio_iovec(rq->bio)->bv_len >> 9;
 	rq->hard_cur_sectors = rq->current_nr_sectors;
-	if (rq->bio)
-		rq->buffer = NULL;
-
+	rq->buffer = bio_data(rq->bio);
+out:
 	return ret;
 }
 
@@ -1265,7 +1315,7 @@
 			/* local CPU only,
 			 * as if we were handling an interrupt */
 			local_irq_disable();
-			if (hwgroup->poll_timeout != 0) {
+			if (hwgroup->polling) {
 				startstop = handler(drive);
 			} else if (drive_is_ready(drive)) {
 				if (drive->waiting_for_dma)
@@ -1278,7 +1328,7 @@
 					startstop = ide_dma_timeout_retry(drive, wait);
 				} else
 					startstop =
-					DRIVER(drive)->error(drive, "irq timeout", hwif->INB(IDE_STATUS_REG));
+					ide_error(drive, "irq timeout", hwif->INB(IDE_STATUS_REG));
 			}
 			drive->service_time = jiffies - drive->service_start;
 			spin_lock_irq(&ide_lock);
@@ -1291,8 +1341,6 @@
 	spin_unlock_irqrestore(&ide_lock, flags);
 }
 
-EXPORT_SYMBOL(ide_timer_expiry);
-
 /**
  *	unexpected_intr		-	handle an unexpected IDE interrupt
  *	@irq: interrupt line
@@ -1395,8 +1443,7 @@
 		return IRQ_NONE;
 	}
 
-	if ((handler = hwgroup->handler) == NULL ||
-	    hwgroup->poll_timeout != 0) {
+	if ((handler = hwgroup->handler) == NULL || hwgroup->polling) {
 		/*
 		 * Not expecting an interrupt from this drive.
 		 * That means this could be:
@@ -1490,8 +1537,6 @@
 	return IRQ_HANDLED;
 }
 
-EXPORT_SYMBOL(ide_intr);
-
 /**
  *	ide_init_drive_cmd	-	initialize a drive command request
  *	@rq: request object
@@ -1550,18 +1595,6 @@
 	int where = ELEVATOR_INSERT_BACK, err;
 	int must_wait = (action == ide_wait || action == ide_head_wait);
 
-#ifdef CONFIG_BLK_DEV_PDC4030
-	/*
-	 *	FIXME: there should be a drive or hwif->special
-	 *	handler that points here by default, not hacks
-	 *	in the ide-io.c code
-	 *
-	 *	FIXME2: That code breaks power management if used with
-	 *	this chipset, that really doesn't belong here !
-	 */
-	if (HWIF(drive)->chipset == ide_pdc4030 && rq->buffer != NULL)
-		return -ENOSYS;  /* special drive cmds not supported */
-#endif
 	rq->errors = 0;
 	rq->rq_status = RQ_ACTIVE;
 
diff -Naur linuxppc-2.6.9/drivers/ide/ide-iops.c linuxppc-2.6.9-dream/drivers/ide/ide-iops.c
--- linuxppc-2.6.9/drivers/ide/ide-iops.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-iops.c	2005-06-20 10:46:10.000000000 +0200
@@ -23,12 +23,12 @@
 #include <linux/delay.h>
 #include <linux/hdreg.h>
 #include <linux/ide.h>
+#include <linux/bitops.h>
 
 #include <asm/byteorder.h>
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
-#include <asm/bitops.h>
 
 /*
  *	Conventional PIO operations for ATA devices
@@ -184,16 +184,6 @@
 
 EXPORT_SYMBOL(default_hwif_mmiops);
 
-void default_hwif_transport (ide_hwif_t *hwif)
-{
-	hwif->ata_input_data		= ata_input_data;
-	hwif->ata_output_data		= ata_output_data;
-	hwif->atapi_input_bytes		= atapi_input_bytes;
-	hwif->atapi_output_bytes	= atapi_output_bytes;
-}
-
-EXPORT_SYMBOL(default_hwif_transport);
-
 u32 ide_read_24 (ide_drive_t *drive)
 {
 	u8 hcyl = HWIF(drive)->INB(IDE_HCYL_REG);
@@ -202,8 +192,6 @@
 	return (hcyl<<16)|(lcyl<<8)|sect;
 }
 
-EXPORT_SYMBOL(ide_read_24);
-
 void SELECT_DRIVE (ide_drive_t *drive)
 {
 	if (HWIF(drive)->selectproc)
@@ -221,24 +209,18 @@
 		HWIF(drive)->OUTB(drive->ctl|2, IDE_CONTROL_REG);
 }
 
-EXPORT_SYMBOL(SELECT_INTERRUPT);
-
 void SELECT_MASK (ide_drive_t *drive, int mask)
 {
 	if (HWIF(drive)->maskproc)
 		HWIF(drive)->maskproc(drive, mask);
 }
 
-EXPORT_SYMBOL(SELECT_MASK);
-
 void QUIRK_LIST (ide_drive_t *drive)
 {
 	if (HWIF(drive)->quirkproc)
 		drive->quirk_list = HWIF(drive)->quirkproc(drive);
 }
 
-EXPORT_SYMBOL(QUIRK_LIST);
-
 /*
  * Some localbus EIDE interfaces require a special access sequence
  * when using 32-bit I/O instructions to transfer data.  We call this
@@ -246,19 +228,17 @@
  * of the sector count register location, with interrupts disabled
  * to ensure that the reads all happen together.
  */
-void ata_vlb_sync (ide_drive_t *drive, unsigned long port)
+static void ata_vlb_sync(ide_drive_t *drive, unsigned long port)
 {
 	(void) HWIF(drive)->INB(port);
 	(void) HWIF(drive)->INB(port);
 	(void) HWIF(drive)->INB(port);
 }
 
-EXPORT_SYMBOL(ata_vlb_sync);
-
 /*
  * This is used for most PIO data transfers *from* the IDE interface
  */
-void ata_input_data (ide_drive_t *drive, void *buffer, u32 wcount)
+static void ata_input_data(ide_drive_t *drive, void *buffer, u32 wcount)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 io_32bit		= drive->io_32bit;
@@ -277,12 +257,10 @@
 	}
 }
 
-EXPORT_SYMBOL(ata_input_data);
-
 /*
  * This is used for most PIO data transfers *to* the IDE interface
  */
-void ata_output_data (ide_drive_t *drive, void *buffer, u32 wcount)
+static void ata_output_data(ide_drive_t *drive, void *buffer, u32 wcount)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 io_32bit		= drive->io_32bit;
@@ -301,8 +279,6 @@
 	}
 }
 
-EXPORT_SYMBOL(ata_output_data);
-
 /*
  * The following routines are mainly used by the ATAPI drivers.
  *
@@ -311,7 +287,7 @@
  * extra byte allocated for the buffer.
  */
 
-void atapi_input_bytes (ide_drive_t *drive, void *buffer, u32 bytecount)
+static void atapi_input_bytes(ide_drive_t *drive, void *buffer, u32 bytecount)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 
@@ -328,9 +304,7 @@
 		hwif->INSW(IDE_DATA_REG, ((u8 *)buffer)+(bytecount & ~0x03), 1);
 }
 
-EXPORT_SYMBOL(atapi_input_bytes);
-
-void atapi_output_bytes (ide_drive_t *drive, void *buffer, u32 bytecount)
+static void atapi_output_bytes(ide_drive_t *drive, void *buffer, u32 bytecount)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 
@@ -347,7 +321,15 @@
 		hwif->OUTSW(IDE_DATA_REG, ((u8*)buffer)+(bytecount & ~0x03), 1);
 }
 
-EXPORT_SYMBOL(atapi_output_bytes);
+void default_hwif_transport(ide_hwif_t *hwif)
+{
+	hwif->ata_input_data		= ata_input_data;
+	hwif->ata_output_data		= ata_output_data;
+	hwif->atapi_input_bytes		= atapi_input_bytes;
+	hwif->atapi_output_bytes	= atapi_output_bytes;
+}
+
+EXPORT_SYMBOL(default_hwif_transport);
 
 /*
  * Beginning of Taskfile OPCODE Library and feature sets.
@@ -449,6 +431,7 @@
 #endif
 }
 
+/* FIXME: exported for use by the USB storage (isd200.c) code only */
 EXPORT_SYMBOL(ide_fix_driveid);
 
 void ide_fixstring (u8 *s, const int bytecount, const int byteswap)
@@ -588,7 +571,7 @@
 					break;
 
 				local_irq_restore(flags);
-				*startstop = DRIVER(drive)->error(drive, "status timeout", stat);
+				*startstop = ide_error(drive, "status timeout", stat);
 				return 1;
 			}
 		}
@@ -606,7 +589,7 @@
 		if (OK_STAT((stat = hwif->INB(IDE_STATUS_REG)), good, bad))
 			return 0;
 	}
-	*startstop = DRIVER(drive)->error(drive, "status error", stat);
+	*startstop = ide_error(drive, "status error", stat);
 	return 1;
 }
 
@@ -685,8 +668,6 @@
 	return 0;
 }
 
-EXPORT_SYMBOL(ide_ata66_check);
-
 /*
  * Backside of HDIO_DRIVE_CMD call of SETFEATURES_XFER.
  * 1 : Safe to update drive->id DMA registers.
@@ -705,9 +686,8 @@
 	return 0;
 }
 
-EXPORT_SYMBOL(set_transfer);
-
-u8 ide_auto_reduce_xfer (ide_drive_t *drive)
+#ifdef CONFIG_BLK_DEV_IDEDMA
+static u8 ide_auto_reduce_xfer (ide_drive_t *drive)
 {
 	if (!drive->crc_count)
 		return drive->current_speed;
@@ -731,8 +711,7 @@
 		default:		return XFER_PIO_4;
 	}
 }
-
-EXPORT_SYMBOL(ide_auto_reduce_xfer);
+#endif /* CONFIG_BLK_DEV_IDEDMA */
 
 /*
  * Update the 
@@ -807,8 +786,6 @@
 #endif
 }
 
-EXPORT_SYMBOL(ide_driveid_update);
-
 /*
  * Similar to ide_wait_stat(), except it never calls ide_error internally.
  * This is a kludge to handle the new ide_config_drive_speed() function,
@@ -948,7 +925,7 @@
  *
  * See also ide_execute_command
  */
-void __ide_set_handler (ide_drive_t *drive, ide_handler_t *handler,
+static void __ide_set_handler (ide_drive_t *drive, ide_handler_t *handler,
 		      unsigned int timeout, ide_expiry_t *expiry)
 {
 	ide_hwgroup_t *hwgroup = HWGROUP(drive);
@@ -964,8 +941,6 @@
 	add_timer(&hwgroup->timer);
 }
 
-EXPORT_SYMBOL(__ide_set_handler);
-
 void ide_set_handler (ide_drive_t *drive, ide_handler_t *handler,
 		      unsigned int timeout, ide_expiry_t *expiry)
 {
@@ -1048,14 +1023,14 @@
 			return ide_started;
 		}
 		/* end of polling */
-		hwgroup->poll_timeout = 0;
+		hwgroup->polling = 0;
 		printk("%s: ATAPI reset timed-out, status=0x%02x\n",
 				drive->name, stat);
 		/* do it the old fashioned way */
 		return do_reset1(drive, 1);
 	}
 	/* done polling */
-	hwgroup->poll_timeout = 0;
+	hwgroup->polling = 0;
 	return ide_stopped;
 }
 
@@ -1115,7 +1090,7 @@
 			printk("\n");
 		}
 	}
-	hwgroup->poll_timeout = 0;	/* done polling */
+	hwgroup->polling = 0;	/* done polling */
 	return ide_stopped;
 }
 
@@ -1132,7 +1107,7 @@
 #endif
 }
 
-void pre_reset (ide_drive_t *drive)
+static void pre_reset(ide_drive_t *drive)
 {
 	DRIVER(drive)->pre_reset(drive);
 
@@ -1190,6 +1165,7 @@
 		udelay (20);
 		hwif->OUTB(WIN_SRST, IDE_COMMAND_REG);
 		hwgroup->poll_timeout = jiffies + WAIT_WORSTCASE;
+		hwgroup->polling = 1;
 		__ide_set_handler(drive, &atapi_reset_pollfunc, HZ/20, NULL);
 		spin_unlock_irqrestore(&ide_lock, flags);
 		return ide_started;
@@ -1230,6 +1206,7 @@
 	/* more than enough time */
 	udelay(10);
 	hwgroup->poll_timeout = jiffies + WAIT_WORSTCASE;
+	hwgroup->polling = 1;
 	__ide_set_handler(drive, &reset_pollfunc, HZ/20, NULL);
 
 	/*
diff -Naur linuxppc-2.6.9/drivers/ide/ide-lib.c linuxppc-2.6.9-dream/drivers/ide/ide-lib.c
--- linuxppc-2.6.9/drivers/ide/ide-lib.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-lib.c	2005-06-20 10:46:10.000000000 +0200
@@ -15,12 +15,12 @@
 #include <linux/delay.h>
 #include <linux/hdreg.h>
 #include <linux/ide.h>
+#include <linux/bitops.h>
 
 #include <asm/byteorder.h>
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
-#include <asm/bitops.h>
 
 /*
  *	IDE library routines. These are plug in code that most 
@@ -421,8 +421,6 @@
 		blk_queue_bounce_limit(drive->queue, addr);
 }
 
-EXPORT_SYMBOL(ide_toggle_bounce);
-
 /**
  *	ide_set_xfer_rate	-	set transfer rate
  *	@drive: drive to set
@@ -447,6 +445,114 @@
 
 EXPORT_SYMBOL_GPL(ide_set_xfer_rate);
 
+static void ide_dump_opcode(ide_drive_t *drive)
+{
+	struct request *rq;
+	u8 opcode = 0;
+	int found = 0;
+
+	spin_lock(&ide_lock);
+	rq = NULL;
+	if (HWGROUP(drive))
+		rq = HWGROUP(drive)->rq;
+	spin_unlock(&ide_lock);
+	if (!rq)
+		return;
+	if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK)) {
+		char *args = rq->buffer;
+		if (args) {
+			opcode = args[0];
+			found = 1;
+		}
+	} else if (rq->flags & REQ_DRIVE_TASKFILE) {
+		ide_task_t *args = rq->special;
+		if (args) {
+			task_struct_t *tf = (task_struct_t *) args->tfRegister;
+			opcode = tf->command;
+			found = 1;
+		}
+	}
+
+	printk("ide: failed opcode was: ");
+	if (!found)
+		printk("unknown\n");
+	else
+		printk("0x%02x\n", opcode);
+}
+
+static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	unsigned long flags;
+	u8 err = 0;
+
+	local_irq_set(flags);
+	printk("%s: %s: status=0x%02x", drive->name, msg, stat);
+	printk(" { ");
+	if (stat & BUSY_STAT)
+		printk("Busy ");
+	else {
+		if (stat & READY_STAT)	printk("DriveReady ");
+		if (stat & WRERR_STAT)	printk("DeviceFault ");
+		if (stat & SEEK_STAT)	printk("SeekComplete ");
+		if (stat & DRQ_STAT)	printk("DataRequest ");
+		if (stat & ECC_STAT)	printk("CorrectedError ");
+		if (stat & INDEX_STAT)	printk("Index ");
+		if (stat & ERR_STAT)	printk("Error ");
+	}
+	printk("}");
+	printk("\n");
+	if ((stat & (BUSY_STAT|ERR_STAT)) == ERR_STAT) {
+		err = hwif->INB(IDE_ERROR_REG);
+		printk("%s: %s: error=0x%02x", drive->name, msg, err);
+		printk(" { ");
+		if (err & ABRT_ERR)	printk("DriveStatusError ");
+		if (err & ICRC_ERR)
+			printk("Bad%s ", (err & ABRT_ERR) ? "CRC" : "Sector");
+		if (err & ECC_ERR)	printk("UncorrectableError ");
+		if (err & ID_ERR)	printk("SectorIdNotFound ");
+		if (err & TRK0_ERR)	printk("TrackZeroNotFound ");
+		if (err & MARK_ERR)	printk("AddrMarkNotFound ");
+		printk("}");
+		if ((err & (BBD_ERR | ABRT_ERR)) == BBD_ERR ||
+		    (err & (ECC_ERR|ID_ERR|MARK_ERR))) {
+			if (drive->addressing == 1) {
+				__u64 sectors = 0;
+				u32 low = 0, high = 0;
+				low = ide_read_24(drive);
+				hwif->OUTB(drive->ctl|0x80, IDE_CONTROL_REG);
+				high = ide_read_24(drive);
+				sectors = ((__u64)high << 24) | low;
+				printk(", LBAsect=%llu, high=%d, low=%d",
+				       (unsigned long long) sectors,
+				       high, low);
+			} else {
+				u8 cur = hwif->INB(IDE_SELECT_REG);
+				if (cur & 0x40) {	/* using LBA? */
+					printk(", LBAsect=%ld", (unsigned long)
+					 ((cur&0xf)<<24)
+					 |(hwif->INB(IDE_HCYL_REG)<<16)
+					 |(hwif->INB(IDE_LCYL_REG)<<8)
+					 | hwif->INB(IDE_SECTOR_REG));
+				} else {
+					printk(", CHS=%d/%d/%d",
+					 (hwif->INB(IDE_HCYL_REG)<<8) +
+					  hwif->INB(IDE_LCYL_REG),
+					  cur & 0xf,
+					  hwif->INB(IDE_SECTOR_REG));
+				}
+			}
+			if (HWGROUP(drive) && HWGROUP(drive)->rq)
+				printk(", sector=%llu",
+					(unsigned long long)HWGROUP(drive)->rq->sector);
+		}
+	}
+	printk("\n");
+	ide_dump_opcode(drive);
+	local_irq_restore(flags);
+	return err;
+}
+
 /**
  *	ide_dump_atapi_status       -       print human readable atapi status
  *	@drive: drive that status applies to
@@ -455,7 +561,8 @@
  *
  *	Error reporting, in human readable form (luxurious, but a memory hog).
  */
-byte ide_dump_atapi_status (ide_drive_t *drive, const char *msg, byte stat)
+
+static u8 ide_dump_atapi_status(ide_drive_t *drive, const char *msg, u8 stat)
 {
 	unsigned long flags;
 
@@ -463,9 +570,9 @@
 	atapi_error_t error;
 
 	status.all = stat;
+	error.all = 0;
 	local_irq_set(flags);
-	printk("%s: %s: status=0x%02x", drive->name, msg, stat);
-	printk(" { ");
+	printk("%s: %s: status=0x%02x { ", drive->name, msg, stat);
 	if (status.b.bsy)
 		printk("Busy ");
 	else {
@@ -477,21 +584,39 @@
 		if (status.b.idx)	printk("Index ");
 		if (status.b.check)	printk("Error ");
 	}
-	printk("}");
-	printk("\n");
-	if ((status.all & (status.b.bsy|status.b.check)) == status.b.check) {
+	printk("}\n");
+	if (status.b.check && !status.b.bsy) {
 		error.all = HWIF(drive)->INB(IDE_ERROR_REG);
-		printk("%s: %s: error=0x%02x", drive->name, msg, error.all);
+		printk("%s: %s: error=0x%02x { ", drive->name, msg, error.all);
 		if (error.b.ili)	printk("IllegalLengthIndication ");
 		if (error.b.eom)	printk("EndOfMedia ");
-		if (error.b.abrt)	printk("Aborted Command ");
+		if (error.b.abrt)	printk("AbortedCommand ");
 		if (error.b.mcr)	printk("MediaChangeRequested ");
-		if (error.b.sense_key)	printk("LastFailedSense 0x%02x ",
+		if (error.b.sense_key)	printk("LastFailedSense=0x%02x ",
 						error.b.sense_key);
-		printk("\n");
+		printk("}\n");
 	}
+	ide_dump_opcode(drive);
 	local_irq_restore(flags);
 	return error.all;
 }
 
-EXPORT_SYMBOL(ide_dump_atapi_status);
+/**
+ *	ide_dump_status		-	translate ATA/ATAPI error
+ *	@drive: drive the error occured on
+ *	@msg: information string
+ *	@stat: status byte
+ *
+ *	Error reporting, in human readable form (luxurious, but a memory hog).
+ *	Combines the drive name, message and status byte to provide a
+ *	user understandable explanation of the device error.
+ */
+
+u8 ide_dump_status(ide_drive_t *drive, const char *msg, u8 stat)
+{
+	if (drive->media == ide_disk)
+		return ide_dump_ata_status(drive, msg, stat);
+	return ide_dump_atapi_status(drive, msg, stat);
+}
+
+EXPORT_SYMBOL(ide_dump_status);
diff -Naur linuxppc-2.6.9/drivers/ide/ide-pnp.c linuxppc-2.6.9-dream/drivers/ide/ide-pnp.c
--- linuxppc-2.6.9/drivers/ide/ide-pnp.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-pnp.c	2005-06-20 10:46:10.000000000 +0200
@@ -21,7 +21,7 @@
 #include <linux/ide.h>
 
 /* Add your devices here :)) */
-struct pnp_device_id idepnp_devices[] = {
+static struct pnp_device_id idepnp_devices[] = {
   	/* Generic ESDI/IDE/ATA compatible hard disk controller */
 	{.id = "PNP0600", .driver_data = 0},
 	{.id = ""}
diff -Naur linuxppc-2.6.9/drivers/ide/ide-probe.c linuxppc-2.6.9-dream/drivers/ide/ide-probe.c
--- linuxppc-2.6.9/drivers/ide/ide-probe.c	2004-10-18 23:54:32.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-probe.c	2005-06-20 10:46:10.000000000 +0200
@@ -180,12 +180,6 @@
 	if (cmd == WIN_PIDENTIFY) {
 		u8 type = (id->config >> 8) & 0x1f;
 		printk("ATAPI ");
-#ifdef CONFIG_BLK_DEV_PDC4030
-		if (hwif->channel == 1 && hwif->chipset == ide_pdc4030) {
-			printk(" -- not supported on 2nd Promise port\n");
-			goto err_misc;
-		}
-#endif /* CONFIG_BLK_DEV_PDC4030 */
 		switch (type) {
 			case ide_floppy:
 				if (!strstr(id->model, "CD-ROM")) {
@@ -297,13 +291,9 @@
 		/* disable dma & overlap */
 		hwif->OUTB(0, IDE_FEATURE_REG);
 
-	if (hwif->identify != NULL) {
-		if (hwif->identify(drive))
-			return 1;
-	} else {
-		/* ask drive for ID */
-		hwif->OUTB(cmd, IDE_COMMAND_REG);
-	}
+	/* ask drive for ID */
+	hwif->OUTB(cmd, IDE_COMMAND_REG);
+
 	timeout = ((cmd == WIN_IDENTIFY) ? WAIT_WORSTCASE : WAIT_PIDENTIFY) / 2;
 	timeout += jiffies;
 	do {
@@ -662,6 +652,43 @@
 	return rc;
 }
 
+/**
+ *	ide_undecoded_slave	-	look for bad CF adapters
+ *	@hwif: interface
+ *
+ *	Analyse the drives on the interface and attempt to decide if we
+ *	have the same drive viewed twice. This occurs with crap CF adapters
+ *	and PCMCIA sometimes.
+ */
+
+void ide_undecoded_slave(ide_hwif_t *hwif)
+{
+	ide_drive_t *drive0 = &hwif->drives[0];
+	ide_drive_t *drive1 = &hwif->drives[1];
+
+	if (drive0->present == 0 || drive1->present == 0)
+		return;
+
+	/* If the models don't match they are not the same product */
+	if (strcmp(drive0->id->model, drive1->id->model))
+		return;
+
+	/* Serial numbers do not match */
+	if (strncmp(drive0->id->serial_no, drive1->id->serial_no, 20))
+		return;
+
+	/* No serial number, thankfully very rare for CF */
+	if (drive0->id->serial_no[0] == 0)
+		return;
+
+	/* Appears to be an IDE flash adapter with decode bugs */
+	printk(KERN_WARNING "ide-probe: ignoring undecoded slave\n");
+
+	drive1->present = 0;
+}
+
+EXPORT_SYMBOL_GPL(ide_undecoded_slave);
+
 /*
  * This routine only knows how to look for drive units 0 and 1
  * on an interface, so any setting of MAX_DRIVES > 2 won't work here.
@@ -676,9 +703,6 @@
 		return;
 
 	if ((hwif->chipset != ide_4drives || !hwif->mate || !hwif->mate->present) &&
-#ifdef CONFIG_BLK_DEV_PDC4030
-	    (hwif->chipset != ide_pdc4030 || hwif->channel == 0) &&
-#endif /* CONFIG_BLK_DEV_PDC4030 */
 	    (ide_hwif_request_regions(hwif))) {
 		u16 msgout = 0;
 		for (unit = 0; unit < MAX_DRIVES; ++unit) {
@@ -725,7 +749,7 @@
 	 *  
 	 *  BenH.
 	 */
-	if (wait_hwif_ready(hwif))
+	if (wait_hwif_ready(hwif) == -EBUSY)
 		printk(KERN_DEBUG "%s: Wait for ready failed before probe !\n", hwif->name);
 
 	/*
@@ -736,18 +760,6 @@
 		ide_drive_t *drive = &hwif->drives[unit];
 		drive->dn = (hwif->channel ? 2 : 0) + unit;
 		(void) probe_for_drive(drive);
-		if (drive->present && hwif->present && unit == 1) {
-			if (strcmp(hwif->drives[0].id->model, drive->id->model) == 0 &&
-			    /* Don't do this for noprobe or non ATA */
-			    strcmp(drive->id->model, "UNKNOWN") &&
-			    /* And beware of confused Maxtor drives that go "M0000000000"
-			      "The SN# is garbage in the ID block..." [Eric] */
-			    strncmp(drive->id->serial_no, "M0000000000000000000", 20) &&
-			    strncmp(hwif->drives[0].id->serial_no, drive->id->serial_no, 20) == 0) {
-				printk(KERN_WARNING "ide-probe: ignoring undecoded slave\n");
-				drive->present = 0;
-			}
-		}
 		if (drive->present && !hwif->present) {
 			hwif->present = 1;
 			if (hwif->chipset != ide_4drives ||
@@ -821,10 +833,19 @@
 }
 
 static int hwif_init(ide_hwif_t *hwif);
-int probe_hwif_init (ide_hwif_t *hwif)
+
+int probe_hwif_init_with_fixup(ide_hwif_t *hwif, void (*fixup)(ide_hwif_t *hwif))
 {
 	probe_hwif(hwif);
-	hwif_init(hwif);
+
+	if (fixup)
+		fixup(hwif);
+
+	if (!hwif_init(hwif)) {
+		printk(KERN_INFO "%s: failed to initialize IDE interface\n",
+				 hwif->name);
+		return -1;
+	}
 
 	if (hwif->present) {
 		u16 unit = 0;
@@ -841,6 +862,11 @@
 	return 0;
 }
 
+int probe_hwif_init(ide_hwif_t *hwif)
+{
+	return probe_hwif_init_with_fixup(hwif, NULL);
+}
+
 EXPORT_SYMBOL(probe_hwif_init);
 
 #if MAX_HWIFS > 1
@@ -1127,7 +1153,7 @@
 
 extern ide_driver_t idedefault_driver;
 
-struct kobject *ata_probe(dev_t dev, int *part, void *data)
+static struct kobject *ata_probe(dev_t dev, int *part, void *data)
 {
 	ide_hwif_t *hwif = data;
 	int unit = *part >> PARTN_BITS;
@@ -1222,8 +1248,9 @@
 {
 	int old_irq, unit;
 
+	/* Return success if no device is connected */
 	if (!hwif->present)
-		return 0;
+		return 1;
 
 	if (!hwif->irq) {
 		if (!(hwif->irq = ide_default_irq(hwif->io_ports[IDE_DATA_OFFSET])))
@@ -1246,6 +1273,16 @@
 	if (register_blkdev(hwif->major, hwif->name))
 		return 0;
 
+	if (!hwif->sg_max_nents)
+		hwif->sg_max_nents = PRD_ENTRIES;
+
+	hwif->sg_table = kmalloc(sizeof(struct scatterlist)*hwif->sg_max_nents,
+				 GFP_KERNEL);
+	if (!hwif->sg_table) {
+		printk(KERN_ERR "%s: unable to allocate SG table.\n", hwif->name);
+		goto out;
+	}
+
 	if (alloc_disks(hwif) < 0)
 		goto out;
 	
@@ -1295,9 +1332,6 @@
 	for (index = 0; index < MAX_HWIFS; ++index)
 		probe[index] = !ide_hwifs[index].present;
 
-	/*
-	 * Probe for drives in the usual way.. CMOS/BIOS, then poke at ports
-	 */
 	for (index = 0; index < MAX_HWIFS; ++index)
 		if (probe[index])
 			probe_hwif(&ide_hwifs[index]);
diff -Naur linuxppc-2.6.9/drivers/ide/ide-proc.c linuxppc-2.6.9-dream/drivers/ide/ide-proc.c
--- linuxppc-2.6.9/drivers/ide/ide-proc.c	2004-10-18 23:54:31.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-proc.c	2005-06-20 10:46:10.000000000 +0200
@@ -8,37 +8,6 @@
 /*
  * This is the /proc/ide/ filesystem implementation.
  *
- * The major reason this exists is to provide sufficient access
- * to driver and config data, such that user-mode programs can
- * be developed to handle chipset tuning for most PCI interfaces.
- * This should provide better utilities, and less kernel bloat.
- *
- * The entire pci config space for a PCI interface chipset can be
- * retrieved by just reading it.  e.g.    "cat /proc/ide3/config"
- *
- * To modify registers *safely*, do something like:
- *   echo "P40:88" >/proc/ide/ide3/config
- * That expression writes 0x88 to pci config register 0x40
- * on the chip which controls ide3.  Multiple tuples can be issued,
- * and the writes will be completed as an atomic set:
- *   echo "P40:88 P41:35 P42:00 P43:00" >/proc/ide/ide3/config
- *
- * All numbers must be specified using pairs of ascii hex digits.
- * It is important to note that these writes will be performed
- * after waiting for the IDE controller (both interfaces)
- * to be completely idle, to ensure no corruption of I/O in progress.
- *
- * Non-PCI registers can also be written, using "R" in place of "P"
- * in the above examples.  The size of the port transfer is determined
- * by the number of pairs of hex digits given for the data.  If a two
- * digit value is given, the write will be a byte operation; if four
- * digits are used, the write will be performed as a 16-bit operation;
- * and if eight digits are specified, a 32-bit "dword" write will be
- * performed.  Odd numbers of digits are not permitted.
- *
- * If there is an error *anywhere* in the string of registers/data
- * then *none* of the writes will be performed.
- *
  * Drive/Driver settings can be retrieved by reading the drive's
  * "settings" files.  e.g.    "cat /proc/ide0/hda/settings"
  * To write a new value "val" into a specific setting "name", use:
@@ -51,10 +20,6 @@
  * returned data as 256 16-bit words.  The "hdparm" utility will
  * be updated someday soon to use this mechanism.
  *
- * Feel free to develop and distribute fancy GUI configuration
- * utilities for your favorite PCI chipsets.  I'll be working on
- * one for the Promise 20246 someday soon.  -ml
- *
  */
 
 #include <linux/config.h>
@@ -74,227 +39,6 @@
 
 #include <asm/io.h>
 
-static int proc_ide_write_config(struct file *file, const char __user *buffer,
-				 unsigned long count, void *data)
-{
-	ide_hwif_t	*hwif = (ide_hwif_t *)data;
-	ide_hwgroup_t *mygroup = (ide_hwgroup_t *)(hwif->hwgroup);
-	ide_hwgroup_t *mategroup = NULL;
-	unsigned long timeout;
-	unsigned long flags;
-	const char *start = NULL, *msg = NULL;
-	struct entry { u32 val; u16 reg; u8 size; u8 pci; } *prog, *q, *r;
-	int want_pci = 0;
-	char *buf, *s;
-	int err;
-
-	if (hwif->mate && hwif->mate->hwgroup)
-		mategroup = (ide_hwgroup_t *)(hwif->mate->hwgroup);
-
-	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
-		return -EACCES;
-
-	if (count >= PAGE_SIZE)
-		return -EINVAL;
-
-	s = buf = (char *)__get_free_page(GFP_USER);
-	if (!buf)
-		return -ENOMEM;
-
-	err = -ENOMEM;
-	q = prog = (struct entry *)__get_free_page(GFP_USER);
-	if (!prog)
-		goto out;
-
-	err = -EFAULT;
-	if (copy_from_user(buf, buffer, count))
-		goto out1;
-
-	buf[count] = '\0';
-
-	while (isspace(*s))
-		s++;
-
-	while (*s) {
-		char *p;
-		int digits;
-
-		start = s;
-
-		if ((char *)(q + 1) > (char *)prog + PAGE_SIZE) {
-			msg = "too many entries";
-			goto parse_error;
-		}
-
-		switch (*s++) {
-			case 'R':	q->pci = 0;
-					break;
-			case 'P':	q->pci = 1;
-					want_pci = 1;
-					break;
-			default:	msg = "expected 'R' or 'P'";
-					goto parse_error;
-		}
-
-		q->reg = simple_strtoul(s, &p, 16);
-		digits = p - s;
-		if (!digits || digits > 4 || (q->pci && q->reg > 0xff)) {
-			msg = "bad/missing register number";
-			goto parse_error;
-		}
-		if (*p++ != ':') {
-			msg = "missing ':'";
-			goto parse_error;
-		}
-		q->val = simple_strtoul(p, &s, 16);
-		digits = s - p;
-		if (digits != 2 && digits != 4 && digits != 8) {
-			msg = "bad data, 2/4/8 digits required";
-			goto parse_error;
-		}
-		q->size = digits / 2;
-
-		if (q->pci) {
-#ifdef CONFIG_BLK_DEV_IDEPCI
-			if (q->reg & (q->size - 1)) {
-				msg = "misaligned access";
-				goto parse_error;
-			}
-#else
-			msg = "not a PCI device";
-			goto parse_error;
-#endif	/* CONFIG_BLK_DEV_IDEPCI */
-		}
-
-		q++;
-
-		if (*s && !isspace(*s++)) {
-			msg = "expected whitespace after data";
-			goto parse_error;
-		}
-		while (isspace(*s))
-			s++;
-	}
-
-	/*
-	 * What follows below is fucking insane, even for IDE people.
-	 * For now I've dealt with the obvious problems on the parsing
-	 * side, but IMNSHO we should simply remove the write access
-	 * to /proc/ide/.../config, killing that FPOS completely.
-	 */
-
-	err = -EBUSY;
-	timeout = jiffies + (3 * HZ);
-	spin_lock_irqsave(&ide_lock, flags);
-	while (mygroup->busy ||
-	       (mategroup && mategroup->busy)) {
-		spin_unlock_irqrestore(&ide_lock, flags);
-		if (time_after(jiffies, timeout)) {
-			printk("/proc/ide/%s/config: channel(s) busy, cannot write\n", hwif->name);
-			goto out1;
-		}
-		spin_lock_irqsave(&ide_lock, flags);
-	}
-
-#ifdef CONFIG_BLK_DEV_IDEPCI
-	if (want_pci && (!hwif->pci_dev || hwif->pci_dev->vendor)) {
-		spin_unlock_irqrestore(&ide_lock, flags);
-		printk("proc_ide: PCI registers not accessible for %s\n",
-			hwif->name);
-		err = -EINVAL;
-		goto out1;
-	}
-#endif	/* CONFIG_BLK_DEV_IDEPCI */
-
-	for (r = prog; r < q; r++) {
-		unsigned int reg = r->reg, val = r->val;
-		if (r->pci) {
-#ifdef CONFIG_BLK_DEV_IDEPCI
-			int rc = 0;
-			struct pci_dev *dev = hwif->pci_dev;
-			switch (q->size) {
-				case 1:	msg = "byte";
-					rc = pci_write_config_byte(dev, reg, val);
-					break;
-				case 2:	msg = "word";
-					rc = pci_write_config_word(dev, reg, val);
-					break;
-				case 4:	msg = "dword";
-					rc = pci_write_config_dword(dev, reg, val);
-					break;
-			}
-			if (rc) {
-				spin_unlock_irqrestore(&ide_lock, flags);
-				printk("proc_ide_write_config: error writing %s at bus %02x dev %02x reg 0x%x value 0x%x\n",
-					msg, dev->bus->number, dev->devfn, reg, val);
-				printk("proc_ide_write_config: error %d\n", rc);
-				err = -EIO;
-				goto out1;
-			}
-#endif	/* CONFIG_BLK_DEV_IDEPCI */
-		} else {	/* not pci */
-			switch (r->size) {
-				case 1:	hwif->OUTB(val, reg);
-					break;
-				case 2:	hwif->OUTW(val, reg);
-					break;
-				case 4:	hwif->OUTL(val, reg);
-					break;
-			}
-		}
-	}
-	spin_unlock_irqrestore(&ide_lock, flags);
-	err = count;
-out1:
-	free_page((unsigned long)prog);
-out:
-	free_page((unsigned long)buf);
-	return err;
-
-parse_error:
-	printk("parse error\n");
-	printk("proc_ide: error: %s: '%s'\n", msg, start);
-	err = -EINVAL;
-	goto out1;
-}
-
-static int proc_ide_read_config
-	(char *page, char **start, off_t off, int count, int *eof, void *data)
-{
-	char		*out = page;
-	int		len;
-
-#ifdef CONFIG_BLK_DEV_IDEPCI
-	ide_hwif_t	*hwif = (ide_hwif_t *)data;
-	struct pci_dev	*dev = hwif->pci_dev;
-	if ((hwif->pci_dev && hwif->pci_dev->vendor) && dev && dev->bus) {
-		int reg = 0;
-
-		out += sprintf(out, "pci bus %02x device %02x vendor %04x "
-				"device %04x channel %d\n",
-			dev->bus->number, dev->devfn,
-			hwif->pci_dev->vendor, hwif->pci_dev->device,
-			hwif->channel);
-		do {
-			u8 val;
-			int rc = pci_read_config_byte(dev, reg, &val);
-			if (rc) {
-				printk("proc_ide_read_config: error %d reading"
-					" bus %02x dev %02x reg 0x%02x\n",
-					rc, dev->bus->number, dev->devfn, reg);
-				out += sprintf(out, "??%c",
-					(++reg & 0xf) ? ' ' : '\n');
-			} else
-				out += sprintf(out, "%02x%c",
-					val, (++reg & 0xf) ? ' ' : '\n');
-		} while (reg < 0x100);
-	} else
-#endif	/* CONFIG_BLK_DEV_IDEPCI */
-		out += sprintf(out, "(none)\n");
-	len = out - page;
-	PROC_IDE_READ_RETURN(page,start,off,count,eof,len);
-}
-
 static int proc_ide_read_imodel
 	(char *page, char **start, off_t off, int count, int *eof, void *data)
 {
@@ -314,7 +58,6 @@
 		case ide_qd65xx:	name = "qd65xx";	break;
 		case ide_umc8672:	name = "umc8672";	break;
 		case ide_ht6560b:	name = "ht6560b";	break;
-		case ide_pdc4030:	name = "pdc4030";	break;
 		case ide_rz1000:	name = "rz1000";	break;
 		case ide_trm290:	name = "trm290";	break;
 		case ide_cmd646:	name = "cmd646";	break;
@@ -381,6 +124,18 @@
 	PROC_IDE_READ_RETURN(page,start,off,count,eof,len);
 }
 
+static void proc_ide_settings_warn(void)
+{
+	static int warned = 0;
+
+	if (warned)
+		return;
+
+	printk(KERN_WARNING "Warning: /proc/ide/hd?/settings interface is "
+			    "obsolete, and will be removed soon!\n");
+	warned = 1;
+}
+
 static int proc_ide_read_settings
 	(char *page, char **start, off_t off, int count, int *eof, void *data)
 {
@@ -389,6 +144,8 @@
 	char		*out = page;
 	int		len, rc, mul_factor, div_factor;
 
+	proc_ide_settings_warn();
+
 	down(&ide_setting_sem);
 	out += sprintf(out, "name\t\t\tvalue\t\tmin\t\tmax\t\tmode\n");
 	out += sprintf(out, "----\t\t\t-----\t\t---\t\t---\t\t----\n");
@@ -428,6 +185,8 @@
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
+	proc_ide_settings_warn();
+
 	if (count >= PAGE_SIZE)
 		return -EINVAL;
 
@@ -675,7 +434,7 @@
 	}
 }
 
-void destroy_proc_ide_drives(ide_hwif_t *hwif)
+static void destroy_proc_ide_drives(ide_hwif_t *hwif)
 {
 	int	d;
 
@@ -688,7 +447,6 @@
 
 static ide_proc_entry_t hwif_entries[] = {
 	{ "channel",	S_IFREG|S_IRUGO,	proc_ide_read_channel,	NULL },
-	{ "config",	S_IFREG|S_IRUGO|S_IWUSR,proc_ide_read_config,	proc_ide_write_config },
 	{ "mate",	S_IFREG|S_IRUGO,	proc_ide_read_mate,	NULL },
 	{ "model",	S_IFREG|S_IRUGO,	proc_ide_read_imodel,	NULL },
 	{ NULL,	0, NULL, NULL }
@@ -724,29 +482,16 @@
 EXPORT_SYMBOL_GPL(ide_pci_create_host_proc);
 #endif
 
-void destroy_proc_ide_interfaces(void)
+void destroy_proc_ide_interface(ide_hwif_t *hwif)
 {
-	int	h;
-
-	for (h = 0; h < MAX_HWIFS; h++) {
-		ide_hwif_t *hwif = &ide_hwifs[h];
-		int exist = (hwif->proc != NULL);
-#if 0
-		if (!hwif->present)
-			continue;
-#endif
-		if (exist) {
-			destroy_proc_ide_drives(hwif);
-			ide_remove_proc_entries(hwif->proc, hwif_entries);
-			remove_proc_entry(hwif->name, proc_ide_root);
-			hwif->proc = NULL;
-		} else
-			continue;
+	if (hwif->proc) {
+		destroy_proc_ide_drives(hwif);
+		ide_remove_proc_entries(hwif->proc, hwif_entries);
+		remove_proc_entry(hwif->name, proc_ide_root);
+		hwif->proc = NULL;
 	}
 }
 
-EXPORT_SYMBOL(destroy_proc_ide_interfaces);
-
 extern struct seq_operations ide_drivers_op;
 static int ide_drivers_open(struct inode *inode, struct file *file)
 {
@@ -776,6 +521,5 @@
 void proc_ide_destroy(void)
 {
 	remove_proc_entry("ide/drivers", proc_ide_root);
-	destroy_proc_ide_interfaces();
 	remove_proc_entry("ide", NULL);
 }
diff -Naur linuxppc-2.6.9/drivers/ide/ide-tape.c linuxppc-2.6.9-dream/drivers/ide/ide-tape.c
--- linuxppc-2.6.9/drivers/ide/ide-tape.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-tape.c	2005-06-20 10:46:10.000000000 +0200
@@ -442,13 +442,13 @@
 #include <linux/ide.h>
 #include <linux/smp_lock.h>
 #include <linux/completion.h>
+#include <linux/bitops.h>
 
 #include <asm/byteorder.h>
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/unaligned.h>
-#include <asm/bitops.h>
 
 /*
  * partition
@@ -2067,7 +2067,7 @@
 #ifdef CONFIG_BLK_DEV_IDEDMA
 	/* Begin DMA, if necessary */
 	if (test_bit(PC_DMA_IN_PROGRESS, &pc->flags))
-		(void) (HWIF(drive)->ide_dma_begin(drive));
+		hwif->dma_start(drive);
 #endif
 	/* Send the actual packet */
 	HWIF(drive)->atapi_output_bytes(drive, pc->c, 12);
@@ -2135,12 +2135,8 @@
 				"reverting to PIO\n");
 		(void)__ide_dma_off(drive);
 	}
-	if (test_bit(PC_DMA_RECOMMENDED, &pc->flags) && drive->using_dma) {
-		if (test_bit(PC_WRITING, &pc->flags))
-			dma_ok = !HWIF(drive)->ide_dma_write(drive);
-		else
-			dma_ok = !HWIF(drive)->ide_dma_read(drive);
-	}
+	if (test_bit(PC_DMA_RECOMMENDED, &pc->flags) && drive->using_dma)
+		dma_ok = !hwif->dma_setup(drive);
 
 	if (IDE_CONTROL_REG)
 		hwif->OUTB(drive->ctl, IDE_CONTROL_REG);
@@ -2443,7 +2439,7 @@
 			tape->dsc_polling_start = jiffies;
 			tape->dsc_polling_frequency = tape->best_dsc_rw_frequency;
 			tape->dsc_timeout = jiffies + IDETAPE_DSC_RW_TIMEOUT;
-		} else if ((signed long) (jiffies - tape->dsc_timeout) > 0) {
+		} else if (time_after(jiffies, tape->dsc_timeout)) {
 			printk(KERN_ERR "ide-tape: %s: DSC timeout\n",
 				tape->name);
 			if (rq->cmd[0] & REQ_IDETAPE_PC2) {
diff -Naur linuxppc-2.6.9/drivers/ide/ide-taskfile.c linuxppc-2.6.9-dream/drivers/ide/ide-taskfile.c
--- linuxppc-2.6.9/drivers/ide/ide-taskfile.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ide-taskfile.c	2005-06-20 10:46:10.000000000 +0200
@@ -5,7 +5,7 @@
  *  Copyright (C) 2000-2002	Andre Hedrick <andre@linux-ide.org>
  *  Copyright (C) 2001-2002	Klaus Smolin
  *					IBM Storage Technology Division
- *  Copyright (C) 2003		Bartlomiej Zolnierkiewicz
+ *  Copyright (C) 2003-2004	Bartlomiej Zolnierkiewicz
  *
  *  The big the bad and the ugly.
  *
@@ -44,12 +44,12 @@
 #include <linux/delay.h>
 #include <linux/hdreg.h>
 #include <linux/ide.h>
+#include <linux/bitops.h>
 
 #include <asm/byteorder.h>
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
-#include <asm/bitops.h>
 
 #define DEBUG_TASKFILE	0	/* unset when fixed */
 
@@ -63,17 +63,14 @@
 	}
 }
 
-
-void taskfile_input_data (ide_drive_t *drive, void *buffer, u32 wcount)
+static void taskfile_input_data(ide_drive_t *drive, void *buffer, u32 wcount)
 {
 	HWIF(drive)->ata_input_data(drive, buffer, wcount);
 	if (drive->bswap)
 		ata_bswap_data(buffer, wcount);
 }
 
-EXPORT_SYMBOL(taskfile_input_data);
-
-void taskfile_output_data (ide_drive_t *drive, void *buffer, u32 wcount)
+static void taskfile_output_data(ide_drive_t *drive, void *buffer, u32 wcount)
 {
 	if (drive->bswap) {
 		ata_bswap_data(buffer, wcount);
@@ -84,8 +81,6 @@
 	}
 }
 
-EXPORT_SYMBOL(taskfile_output_data);
-
 int taskfile_lib_get_identify (ide_drive_t *drive, u8 *buf)
 {
 	ide_task_t args;
@@ -101,8 +96,6 @@
 	return ide_raw_taskfile(drive, &args, buf);
 }
 
-EXPORT_SYMBOL(taskfile_lib_get_identify);
-
 ide_startstop_t do_rw_taskfile (ide_drive_t *drive, ide_task_t *task)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
@@ -150,15 +143,15 @@
 		case WIN_WRITEDMA_ONCE:
 		case WIN_WRITEDMA:
 		case WIN_WRITEDMA_EXT:
-			if (!hwif->ide_dma_write(drive))
-				return ide_started;
-			break;
 		case WIN_READDMA_ONCE:
 		case WIN_READDMA:
 		case WIN_READDMA_EXT:
 		case WIN_IDENTIFY_DMA:
-			if (!hwif->ide_dma_read(drive))
+			if (!hwif->dma_setup(drive)) {
+				hwif->dma_exec_cmd(drive, taskfile->command);
+				hwif->dma_start(drive);
 				return ide_started;
+			}
 			break;
 		default:
 			if (task->handler == NULL)
@@ -206,7 +199,7 @@
 		return ide_stopped;
 
 	if (stat & (ERR_STAT|DRQ_STAT))
-		return DRIVER(drive)->error(drive, "set_geometry_intr", stat);
+		return ide_error(drive, "set_geometry_intr", stat);
 
 	if (HWGROUP(drive)->handler != NULL)
 		BUG();
@@ -225,7 +218,7 @@
 	u8 stat;
 
 	if (!OK_STAT(stat = hwif->INB(IDE_STATUS_REG), READY_STAT, BAD_STAT))
-		return DRIVER(drive)->error(drive, "recal_intr", stat);
+		return ide_error(drive, "recal_intr", stat);
 	return ide_stopped;
 }
 
@@ -242,7 +235,7 @@
 
 	local_irq_enable();
 	if (!OK_STAT(stat = hwif->INB(IDE_STATUS_REG),READY_STAT,BAD_STAT)) {
-		return DRIVER(drive)->error(drive, "task_no_data_intr", stat);
+		return ide_error(drive, "task_no_data_intr", stat);
 		/* calls ide_end_drive_cmd */
 	}
 	if (args)
@@ -253,73 +246,6 @@
 
 EXPORT_SYMBOL(task_no_data_intr);
 
-static void task_buffer_sectors(ide_drive_t *drive, struct request *rq,
-				unsigned nsect, unsigned rw)
-{
-	char *buf = rq->buffer + blk_rq_offset(rq);
-
-	rq->sector += nsect;
-	rq->current_nr_sectors -= nsect;
-	rq->nr_sectors -= nsect;
-	__task_sectors(drive, buf, nsect, rw);
-}
-
-static inline void task_buffer_multi_sectors(ide_drive_t *drive,
-					     struct request *rq, unsigned rw)
-{
-	unsigned int msect = drive->mult_count, nsect;
-
-	nsect = rq->current_nr_sectors;
-	if (nsect > msect)
-		nsect = msect;
-
-	task_buffer_sectors(drive, rq, nsect, rw);
-}
-
-#ifdef CONFIG_IDE_TASKFILE_IO
-static void task_sectors(ide_drive_t *drive, struct request *rq,
-			 unsigned nsect, unsigned rw)
-{
-	if (rq->cbio) {	/* fs request */
-		rq->errors = 0;
-		task_bio_sectors(drive, rq, nsect, rw);
-	} else		/* task request */
-		task_buffer_sectors(drive, rq, nsect, rw);
-}
-
-static inline void task_bio_multi_sectors(ide_drive_t *drive,
-					  struct request *rq, unsigned rw)
-{
-	unsigned int nsect, msect = drive->mult_count;
-
-	do {
-		nsect = rq->current_nr_sectors;
-		if (nsect > msect)
-			nsect = msect;
-
-		task_bio_sectors(drive, rq, nsect, rw);
-
-		if (!rq->nr_sectors)
-			msect = 0;
-		else
-			msect -= nsect;
-	} while (msect);
-}
-
-static void task_multi_sectors(ide_drive_t *drive,
-			       struct request *rq, unsigned rw)
-{
-	if (rq->cbio) {	/* fs request */
-		rq->errors = 0;
-		task_bio_multi_sectors(drive, rq, rw);
-	} else		/* task request */
-		task_buffer_multi_sectors(drive, rq, rw);
-}
-#else
-# define task_sectors(d, rq, nsect, rw)	task_buffer_sectors(d, rq, nsect, rw)
-# define task_multi_sectors(d, rq, rw)	task_buffer_multi_sectors(d, rq, rw)
-#endif /* CONFIG_IDE_TASKFILE_IO */
-
 static u8 wait_drive_not_busy(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
@@ -340,37 +266,92 @@
 	return stat;
 }
 
+static void ide_pio_sector(ide_drive_t *drive, unsigned int write)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct scatterlist *sg = hwif->sg_table;
+	struct page *page;
+#ifdef CONFIG_HIGHMEM
+	unsigned long flags;
+#endif
+	unsigned int offset;
+	u8 *buf;
+
+	page = sg[hwif->cursg].page;
+	offset = sg[hwif->cursg].offset + hwif->cursg_ofs * SECTOR_SIZE;
+
+	/* get the current page and offset */
+	page = nth_page(page, (offset >> PAGE_SHIFT));
+	offset %= PAGE_SIZE;
+
+#ifdef CONFIG_HIGHMEM
+	local_irq_save(flags);
+#endif
+	buf = kmap_atomic(page, KM_BIO_SRC_IRQ) + offset;
+
+	hwif->nleft--;
+	hwif->cursg_ofs++;
+
+	if ((hwif->cursg_ofs * SECTOR_SIZE) == sg[hwif->cursg].length) {
+		hwif->cursg++;
+		hwif->cursg_ofs = 0;
+	}
+
+	/* do the actual data transfer */
+	if (write)
+		taskfile_output_data(drive, buf, SECTOR_WORDS);
+	else
+		taskfile_input_data(drive, buf, SECTOR_WORDS);
+
+	kunmap_atomic(buf, KM_BIO_SRC_IRQ);
+#ifdef CONFIG_HIGHMEM
+	local_irq_restore(flags);
+#endif
+}
+
+static void ide_pio_multi(ide_drive_t *drive, unsigned int write)
+{
+	unsigned int nsect;
+
+	nsect = min_t(unsigned int, drive->hwif->nleft, drive->mult_count);
+	while (nsect--)
+		ide_pio_sector(drive, write);
+}
+
 static inline void ide_pio_datablock(ide_drive_t *drive, struct request *rq,
 				     unsigned int write)
 {
+	if (rq->bio)	/* fs request */
+		rq->errors = 0;
+
 	switch (drive->hwif->data_phase) {
 	case TASKFILE_MULTI_IN:
 	case TASKFILE_MULTI_OUT:
-		task_multi_sectors(drive, rq, write);
+		ide_pio_multi(drive, write);
 		break;
 	default:
-		task_sectors(drive, rq, 1, write);
+		ide_pio_sector(drive, write);
 		break;
 	}
 }
 
-#ifdef CONFIG_IDE_TASKFILE_IO
 static ide_startstop_t task_error(ide_drive_t *drive, struct request *rq,
 				  const char *s, u8 stat)
 {
 	if (rq->bio) {
-		int sectors = rq->hard_nr_sectors - rq->nr_sectors;
+		ide_hwif_t *hwif = drive->hwif;
+		int sectors = hwif->nsect - hwif->nleft;
 
-		switch (drive->hwif->data_phase) {
+		switch (hwif->data_phase) {
 		case TASKFILE_IN:
-			if (rq->nr_sectors)
+			if (hwif->nleft)
 				break;
 			/* fall through */
 		case TASKFILE_OUT:
 			sectors--;
 			break;
 		case TASKFILE_MULTI_IN:
-			if (rq->nr_sectors)
+			if (hwif->nleft)
 				break;
 			/* fall through */
 		case TASKFILE_MULTI_OUT:
@@ -382,11 +363,8 @@
 		if (sectors > 0)
 			drive->driver->end_request(drive, 1, sectors);
 	}
-	return drive->driver->error(drive, s, stat);
+	return ide_error(drive, s, stat);
 }
-#else
-# define task_error(d, rq, s, stat) drive->driver->error(d, s, stat)
-#endif
 
 static void task_end_request(ide_drive_t *drive, struct request *rq, u8 stat)
 {
@@ -407,9 +385,11 @@
  */
 ide_startstop_t task_in_intr (ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	struct request *rq = HWGROUP(drive)->rq;
-	u8 stat = HWIF(drive)->INB(IDE_STATUS_REG);
+	u8 stat = hwif->INB(IDE_STATUS_REG);
 
+	/* new way for dealing with premature shared PCI interrupts */
 	if (!OK_STAT(stat, DATA_READY, BAD_R_STAT)) {
 		if (stat & (ERR_STAT | DRQ_STAT))
 			return task_error(drive, rq, __FUNCTION__, stat);
@@ -421,7 +401,7 @@
 	ide_pio_datablock(drive, rq, 0);
 
 	/* If it was the last datablock check status and finish transfer. */
-	if (!rq->nr_sectors) {
+	if (!hwif->nleft) {
 		stat = wait_drive_not_busy(drive);
 		if (!OK_STAT(stat, 0, BAD_R_STAT))
 			return task_error(drive, rq, __FUNCTION__, stat);
@@ -439,20 +419,20 @@
 /*
  * Handler for command with PIO data-out phase (Write/Write Multiple).
  */
-ide_startstop_t task_out_intr (ide_drive_t *drive)
+static ide_startstop_t task_out_intr (ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	struct request *rq = HWGROUP(drive)->rq;
-	u8 stat;
+	u8 stat = hwif->INB(IDE_STATUS_REG);
 
-	stat = HWIF(drive)->INB(IDE_STATUS_REG);
 	if (!OK_STAT(stat, DRIVE_READY, drive->bad_wstat))
 		return task_error(drive, rq, __FUNCTION__, stat);
 
 	/* Deal with unexpected ATA data phase. */
-	if (((stat & DRQ_STAT) == 0) ^ !rq->nr_sectors)
+	if (((stat & DRQ_STAT) == 0) ^ !hwif->nleft)
 		return task_error(drive, rq, __FUNCTION__, stat);
 
-	if (!rq->nr_sectors) {
+	if (!hwif->nleft) {
 		task_end_request(drive, rq, stat);
 		return ide_stopped;
 	}
@@ -464,8 +444,6 @@
 	return ide_started;
 }
 
-EXPORT_SYMBOL(task_out_intr);
-
 ide_startstop_t pre_task_out_intr (ide_drive_t *drive, struct request *rq)
 {
 	ide_startstop_t startstop;
@@ -489,7 +467,7 @@
 }
 EXPORT_SYMBOL(pre_task_out_intr);
 
-int ide_diag_taskfile (ide_drive_t *drive, ide_task_t *args, unsigned long data_size, u8 *buf)
+static int ide_diag_taskfile(ide_drive_t *drive, ide_task_t *args, unsigned long data_size, u8 *buf)
 {
 	struct request rq;
 
@@ -517,14 +495,15 @@
 
 		rq.hard_nr_sectors = rq.nr_sectors;
 		rq.hard_cur_sectors = rq.current_nr_sectors = rq.nr_sectors;
+
+		if (args->command_type == IDE_DRIVE_TASK_RAW_WRITE)
+			rq.flags |= REQ_RW;
 	}
 
 	rq.special = args;
 	return ide_do_drive_cmd(drive, &rq, ide_wait);
 }
 
-EXPORT_SYMBOL(ide_diag_taskfile);
-
 int ide_raw_taskfile (ide_drive_t *drive, ide_task_t *args, u8 *buf)
 {
 	return ide_diag_taskfile(drive, args, 0, buf);
@@ -532,10 +511,6 @@
 
 EXPORT_SYMBOL(ide_raw_taskfile);
 
-#define MAX_DMA		(256*SECTOR_WORDS)
-
-ide_startstop_t flagged_taskfile(ide_drive_t *, ide_task_t *);
-
 int ide_taskfile_ioctl (ide_drive_t *drive, unsigned int cmd, unsigned long arg)
 {
 	ide_task_request_t	*req_task;
@@ -686,8 +661,6 @@
 	return err;
 }
 
-EXPORT_SYMBOL(ide_taskfile_ioctl);
-
 int ide_wait_cmd (ide_drive_t *drive, u8 cmd, u8 nsect, u8 feature, u8 sectors, u8 *buf)
 {
 	struct request rq;
@@ -705,8 +678,6 @@
 	return ide_do_drive_cmd(drive, &rq, ide_wait);
 }
 
-EXPORT_SYMBOL(ide_wait_cmd);
-
 /*
  * FIXME : this needs to map into at taskfile. <andre@linux-ide.org>
  */
@@ -764,9 +735,7 @@
 	return err;
 }
 
-EXPORT_SYMBOL(ide_cmd_ioctl);
-
-int ide_wait_cmd_task (ide_drive_t *drive, u8 *buf)
+static int ide_wait_cmd_task(ide_drive_t *drive, u8 *buf)
 {
 	struct request rq;
 
@@ -776,8 +745,6 @@
 	return ide_do_drive_cmd(drive, &rq, ide_wait);
 }
 
-EXPORT_SYMBOL(ide_wait_cmd_task);
-
 /*
  * FIXME : this needs to map into at taskfile. <andre@linux-ide.org>
  */
@@ -796,8 +763,6 @@
 	return err;
 }
 
-EXPORT_SYMBOL(ide_task_ioctl);
-
 /*
  * NOTICE: This is additions from IBM to provide a discrete interface,
  * for selective taskregister access operations.  Nice JOB Klaus!!!
@@ -886,8 +851,8 @@
 		hwif->OUTB(taskfile->high_cylinder, IDE_HCYL_REG);
 
         /*
-	 * (ks) In the flagged taskfile approch, we will used all specified
-	 * registers and the register value will not be changed. Except the
+	 * (ks) In the flagged taskfile approch, we will use all specified
+	 * registers and the register value will not be changed, except the
 	 * select bit (master/slave) in the drive_head register. We must make
 	 * sure that the desired drive is selected.
 	 */
@@ -896,12 +861,11 @@
 
    	        case TASKFILE_OUT_DMAQ:
 		case TASKFILE_OUT_DMA:
-			hwif->ide_dma_write(drive);
-			break;
-
 		case TASKFILE_IN_DMAQ:
 		case TASKFILE_IN_DMA:
-			hwif->ide_dma_read(drive);
+			hwif->dma_setup(drive);
+			hwif->dma_exec_cmd(drive, taskfile->command);
+			hwif->dma_start(drive);
 			break;
 
 	        default:
@@ -919,5 +883,3 @@
 
 	return ide_started;
 }
-
-EXPORT_SYMBOL(flagged_taskfile);
diff -Naur linuxppc-2.6.9/drivers/ide/Kconfig linuxppc-2.6.9-dream/drivers/ide/Kconfig
--- linuxppc-2.6.9/drivers/ide/Kconfig	2005-10-01 14:12:17.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/Kconfig	2005-06-20 10:46:10.000000000 +0200
@@ -273,15 +273,6 @@
 
 	  If you are unsure, say N here.
 
-config IDE_TASKFILE_IO
-	bool 'IDE Taskfile IO (EXPERIMENTAL)'
-	depends on EXPERIMENTAL
-	default n
-	---help---
-	  Use new taskfile IO code.
-
-	  It is safe to say Y to this question, in most cases.
-
 comment "IDE chipset support/bugfixes"
 
 config IDE_GENERIC
@@ -781,17 +772,6 @@
 	  This option enables the use of the sleep LED as a hard drive
 	  activity LED.
 
-config BLK_DEV_IDEDMA_PMAC_AUTO
-	bool "Use DMA by default"
-	depends on BLK_DEV_IDEDMA_PMAC
-	help
-	  This option allows the driver for the built-in IDE controller on
-	  Power Macintoshes and PowerBooks to use DMA automatically, without
-	  it having to be explicitly enabled.  This option is provided because
-	  of concerns about a couple of cases where using DMA on buggy PC
-	  hardware may have caused damage.  Saying Y should be safe on all
-	  Apple machines.
-
 config IDE_ARM
 	def_bool ARM && (ARCH_A5K || ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK)
 
@@ -832,7 +812,7 @@
 
 config BLK_DEV_IDE_BAST
 	tristate "Simtec BAST / Thorcom VR1000 IDE support"
-	depends on ARM && (ARCH_BAST || MACH_VR100)
+	depends on ARM && (ARCH_BAST || MACH_VR1000)
 	help
 	  Say Y here if you want to support the onboard IDE channels on the
 	  Simtec BAST or the Thorcom VR1000
@@ -950,8 +930,8 @@
 endchoice
 
 config BLK_DEV_IDE_STB04xxx
-	bool "STB04xxx (Redwood-5) IDE support"
-	depends on BLK_DEV_IDE && REDWOOD_5
+	tristate "STB04xxx (Redwood-5) IDE support"
+	depends on BLK_DEV_IDE && (REDWOOD_5 || DM7020 || DM7000)
 	help
 	  This option provides support for IDE on IBM STB04xxx Redwood-5
 	  systems.
@@ -1016,19 +996,6 @@
 	  See the <file:Documentation/ide.txt> and
 	  <file:drivers/ide/legacy/ht6560b.c> files for more info.
 
-config BLK_DEV_PDC4030
-	tristate "PROMISE DC4030 support (EXPERIMENTAL)"
-	depends on BLK_DEV_IDEDISK && EXPERIMENTAL
-	help
-	  This driver provides support for the secondary IDE interface and
-	  cache of the original Promise IDE chipsets, e.g. DC4030 and DC5030.
-	  It is nothing to do with the later range of Promise UDMA chipsets -
-	  see the PDC_202XX support for these. CD-ROM and TAPE devices are not
-	  supported (and probably never will be since I don't think the cards
-	  support them). This driver is enabled at runtime using the "ide0=dc4030"
-	  or "ide1=dc4030" kernel boot parameter. See the
-	  <file:drivers/ide/legacy/pdc4030.c> file for more info.
-
 config BLK_DEV_QD65XX
 	tristate "QDI QD65xx support"
 	help
@@ -1049,11 +1016,11 @@
 endif
 
 config BLK_DEV_IDEDMA
-	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS
+	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_STB04xxx
 
 config IDEDMA_IVB
 	bool "IGNORE word93 Validation BITS"
-	depends on BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS
+	depends on BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_STB04xxx
 	---help---
 	  There are unclear terms in ATA-4 and ATA-5 standards how certain
 	  hardware (an 80c ribbon) should be detected. Different interpretations
@@ -1068,7 +1035,7 @@
 	  It is normally safe to answer Y; however, the default is N.
 
 config IDEDMA_AUTO
-	def_bool IDEDMA_PCI_AUTO || BLK_DEV_IDEDMA_PMAC_AUTO || IDEDMA_ICS_AUTO
+	def_bool IDEDMA_PCI_AUTO || IDEDMA_ICS_AUTO || BLK_DEV_IDE_STB04xxx
 
 endif
 
diff -Naur linuxppc-2.6.9/drivers/ide/legacy/ali14xx.c linuxppc-2.6.9-dream/drivers/ide/legacy/ali14xx.c
--- linuxppc-2.6.9/drivers/ide/legacy/ali14xx.c	2004-10-18 23:53:42.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/legacy/ali14xx.c	2005-06-20 10:46:11.000000000 +0200
@@ -226,6 +226,8 @@
 	probe_hwif_init(hwif);
 	probe_hwif_init(mate);
 
+	create_proc_ide_interfaces();
+
 	return 0;
 }
 
diff -Naur linuxppc-2.6.9/drivers/ide/legacy/dtc2278.c linuxppc-2.6.9-dream/drivers/ide/legacy/dtc2278.c
--- linuxppc-2.6.9/drivers/ide/legacy/dtc2278.c	2004-10-18 23:53:45.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/legacy/dtc2278.c	2005-06-20 10:46:11.000000000 +0200
@@ -141,6 +141,8 @@
 	probe_hwif_init(hwif);
 	probe_hwif_init(mate);
 
+	create_proc_ide_interfaces();
+
 	return 0;
 }
 
diff -Naur linuxppc-2.6.9/drivers/ide/legacy/hd.c linuxppc-2.6.9-dream/drivers/ide/legacy/hd.c
--- linuxppc-2.6.9/drivers/ide/legacy/hd.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/legacy/hd.c	2005-06-20 10:46:11.000000000 +0200
@@ -94,7 +94,7 @@
 #define BBD_ERR			0x80	/* pre-EIDE meaning:  block marked bad */
 #define ICRC_ERR		0x80	/* new meaning:  CRC error during transfer */
 
-static spinlock_t hd_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(hd_lock);
 static struct request_queue *hd_queue;
 
 #define MAJOR_NR HD_MAJOR
@@ -174,7 +174,7 @@
 }
 #endif
 
-void __init hd_setup(char *str, int *ints)
+static void __init hd_setup(char *str, int *ints)
 {
 	int hdind = 0;
 
@@ -239,7 +239,7 @@
 #endif
 }
 
-void check_status(void)
+static void check_status(void)
 {
 	int i = inb_p(HD_STATUS);
 
@@ -386,7 +386,7 @@
  * drive enters "idle", "standby", or "sleep" mode, so if the status looks
  * "good", we just ignore the interrupt completely.
  */
-void unexpected_hd_interrupt(void)
+static void unexpected_hd_interrupt(void)
 {
 	unsigned int stat = inb_p(HD_STATUS);
 
@@ -551,7 +551,7 @@
 	enable_irq(HD_IRQ);
 }
 
-int do_special_op(struct hd_i_struct *disk, struct request *req)
+static int do_special_op(struct hd_i_struct *disk, struct request *req)
 {
 	if (disk->recalibrate) {
 		disk->recalibrate = 0;
diff -Naur linuxppc-2.6.9/drivers/ide/legacy/ht6560b.c linuxppc-2.6.9-dream/drivers/ide/legacy/ht6560b.c
--- linuxppc-2.6.9/drivers/ide/legacy/ht6560b.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/legacy/ht6560b.c	2005-06-20 10:46:11.000000000 +0200
@@ -352,6 +352,8 @@
 	probe_hwif_init(hwif);
 	probe_hwif_init(mate);
 
+	create_proc_ide_interfaces();
+
 	return 0;
 
 release_region:
diff -Naur linuxppc-2.6.9/drivers/ide/legacy/ide-cs.c linuxppc-2.6.9-dream/drivers/ide/legacy/ide-cs.c
--- linuxppc-2.6.9/drivers/ide/legacy/ide-cs.c	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/legacy/ide-cs.c	2005-06-20 10:46:11.000000000 +0200
@@ -62,12 +62,7 @@
 MODULE_DESCRIPTION("PCMCIA ATA/IDE card driver");
 MODULE_LICENSE("Dual MPL/GPL");
 
-#define INT_MODULE_PARM(n, v) static int n = v; MODULE_PARM(n, "i")
-
-/* Bit map of interrupts to choose from */
-INT_MODULE_PARM(irq_mask, 0xdeb8);
-static int irq_list[4] = { -1 };
-MODULE_PARM(irq_list, "1-4i");
+#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0)
 
 #ifdef PCMCIA_DEBUG
 INT_MODULE_PARM(pc_debug, PCMCIA_DEBUG);
@@ -116,7 +111,7 @@
     ide_info_t *info;
     dev_link_t *link;
     client_reg_t client_reg;
-    int i, ret;
+    int ret;
     
     DEBUG(0, "ide_attach()\n");
 
@@ -130,12 +125,7 @@
     link->io.Attributes2 = IO_DATA_PATH_WIDTH_8;
     link->io.IOAddrLines = 3;
     link->irq.Attributes = IRQ_TYPE_EXCLUSIVE;
-    link->irq.IRQInfo1 = IRQ_INFO2_VALID|IRQ_LEVEL_ID;
-    if (irq_list[0] == -1)
-	link->irq.IRQInfo2 = irq_mask;
-    else
-	for (i = 0; i < 4; i++)
-	    link->irq.IRQInfo2 |= 1 << irq_list[i];
+    link->irq.IRQInfo1 = IRQ_LEVEL_ID;
     link->conf.Attributes = CONF_ENABLE_IRQ;
     link->conf.Vcc = 50;
     link->conf.IntType = INT_MEMORY_AND_IO;
@@ -144,7 +134,6 @@
     link->next = dev_list;
     dev_list = link;
     client_reg.dev_info = &dev_info;
-    client_reg.Attributes = INFO_IO_CLIENT | INFO_CARD_SHARE;
     client_reg.EventMask =
 	CS_EVENT_CARD_INSERTION | CS_EVENT_CARD_REMOVAL |
 	CS_EVENT_RESET_PHYSICAL | CS_EVENT_CARD_RESET |
@@ -206,7 +195,7 @@
     ide_init_hwif_ports(&hw, io, ctl, NULL);
     hw.irq = irq;
     hw.chipset = ide_pci;
-    return ide_register_hw(&hw, NULL);
+    return ide_register_hw_with_fixup(&hw, NULL, ide_undecoded_slave);
 }
 
 /*======================================================================
@@ -220,7 +209,7 @@
 #define CS_CHECK(fn, ret) \
 do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
 
-void ide_config(dev_link_t *link)
+static void ide_config(dev_link_t *link)
 {
     client_handle_t handle = link->handle;
     ide_info_t *info = link->priv;
@@ -485,8 +474,7 @@
 static void __exit exit_ide_cs(void)
 {
 	pcmcia_unregister_driver(&ide_cs_driver);
-	while (dev_list != NULL)
-		ide_detach(dev_list);
+	BUG_ON(dev_list != NULL);
 }
 
 module_init(init_ide_cs);
diff -Naur linuxppc-2.6.9/drivers/ide/legacy/Makefile linuxppc-2.6.9-dream/drivers/ide/legacy/Makefile
--- linuxppc-2.6.9/drivers/ide/legacy/Makefile	2004-10-18 23:53:22.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/legacy/Makefile	2005-06-20 10:46:11.000000000 +0200
@@ -2,7 +2,6 @@
 obj-$(CONFIG_BLK_DEV_ALI14XX)		+= ali14xx.o
 obj-$(CONFIG_BLK_DEV_DTC2278)		+= dtc2278.o
 obj-$(CONFIG_BLK_DEV_HT6560B)		+= ht6560b.o
-obj-$(CONFIG_BLK_DEV_PDC4030)		+= pdc4030.o
 obj-$(CONFIG_BLK_DEV_QD65XX)		+= qd65xx.o
 obj-$(CONFIG_BLK_DEV_UMC8672)		+= umc8672.o
 
diff -Naur linuxppc-2.6.9/drivers/ide/legacy/pdc4030.c linuxppc-2.6.9-dream/drivers/ide/legacy/pdc4030.c
--- linuxppc-2.6.9/drivers/ide/legacy/pdc4030.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/legacy/pdc4030.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,679 +0,0 @@
-/*  -*- linux-c -*-
- *  linux/drivers/ide/legacy/pdc4030.c		Version 0.90  May 27, 1999
- *
- *  Copyright (C) 1995-2002  Linus Torvalds & authors (see below)
- */
-
-/*
- *  Principal Author/Maintainer:  Peter Denison <promise@pnd-pc.demon.co.uk>
- *
- *  This file provides support for the second port and cache of Promise
- *  IDE interfaces, e.g. DC4030VL, DC4030VL-1 and DC4030VL-2.
- *
- *  Thanks are due to Mark Lord for advice and patiently answering stupid
- *  questions, and all those mugs^H^H^H^Hbrave souls who've tested this,
- *  especially Andre Hedrick.
- *
- *  Version 0.01	Initial version, #include'd in ide.c rather than
- *                      compiled separately.
- *                      Reads use Promise commands, writes as before. Drives
- *                      on second channel are read-only.
- *  Version 0.02        Writes working on second channel, reads on both
- *                      channels. Writes fail under high load. Suspect
- *			transfers of >127 sectors don't work.
- *  Version 0.03        Brought into line with ide.c version 5.27.
- *                      Other minor changes.
- *  Version 0.04        Updated for ide.c version 5.30
- *                      Changed initialization strategy
- *  Version 0.05	Kernel integration.  -ml
- *  Version 0.06	Ooops. Add hwgroup to direct call of ide_intr() -ml
- *  Version 0.07	Added support for DC4030 variants
- *			Secondary interface autodetection
- *  Version 0.08	Renamed to pdc4030.c
- *  Version 0.09	Obsolete - never released - did manual write request
- *			splitting before max_sectors[major][minor] available.
- *  Version 0.10	Updated for 2.1 series of kernels
- *  Version 0.11	Updated for 2.3 series of kernels
- *			Autodetection code added.
- *
- *  Version 0.90	Transition to BETA code. No lost/unexpected interrupts
- */
-
-/*
- * Once you've compiled it in, you'll have to also enable the interface
- * setup routine from the kernel command line, as in 
- *
- *	'linux ide0=dc4030' or 'linux ide1=dc4030'
- *
- * It should now work as a second controller also ('ide1=dc4030') but only
- * if you DON'T have BIOS V4.44, which has a bug. If you have this version
- * and EPROM programming facilities, you need to fix 4 bytes:
- * 	2496:	81	81
- *	2497:	3E	3E
- *	2498:	22	98	*
- *	2499:	06	05	*
- *	249A:	F0	F0
- *	249B:	01	01
- *	...
- *	24A7:	81	81
- *	24A8:	3E	3E
- *	24A9:	22	98	*
- *	24AA:	06	05	*
- *	24AB:	70	70
- *	24AC:	01	01
- *
- * As of January 1999, Promise Technology Inc. have finally supplied me with
- * some technical information which has shed a glimmer of light on some of the
- * problems I was having, especially with writes. 
- *
- * There are still potential problems with the robustness and efficiency of
- * this driver because I still don't understand what the card is doing with
- * interrupts, however, it has been stable for a while with no reports of ill
- * effects.
- */
-
-#define DEBUG_READ
-#define DEBUG_WRITE
-#define __PROMISE_4030
-
-#include <linux/module.h>
-#include <linux/config.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/timer.h>
-#include <linux/mm.h>
-#include <linux/ioport.h>
-#include <linux/blkdev.h>
-#include <linux/hdreg.h>
-#include <linux/ide.h>
-#include <linux/init.h>
-
-#include <asm/io.h>
-#include <asm/irq.h>
-
-#include "pdc4030.h"
-
-static ide_startstop_t promise_rw_disk (ide_drive_t *drive, struct request *rq, sector_t block);
-
-/*
- * promise_selectproc() is invoked by ide.c
- * in preparation for access to the specified drive.
- */
-static void promise_selectproc (ide_drive_t *drive)
-{
-	unsigned int number;
-
-	number = (HWIF(drive)->channel << 1) + drive->select.b.unit;
-	HWIF(drive)->OUTB(number, IDE_FEATURE_REG);
-}
-
-/*
- * pdc4030_cmd handles the set of vendor specific commands that are initiated
- * by command F0. They all have the same success/failure notification -
- * 'P' (=0x50) on success, 'p' (=0x70) on failure.
- */
-int pdc4030_cmd(ide_drive_t *drive, u8 cmd)
-{
-	unsigned long timeout;
-	u8 status_val;
-
-	promise_selectproc(drive);	/* redundant? */
-	HWIF(drive)->OUTB(0xF3, IDE_SECTOR_REG);
-	HWIF(drive)->OUTB(cmd, IDE_SELECT_REG);
-	HWIF(drive)->OUTB(PROMISE_EXTENDED_COMMAND, IDE_COMMAND_REG);
-	timeout = HZ * 10;
-	timeout += jiffies;
-	do {
-		if(time_after(jiffies, timeout)) {
-			return 2; /* device timed out */
-		}
-		/* Delays at least 10ms to give interface a chance */
-		mdelay(10);
-		status_val = HWIF(drive)->INB(IDE_SECTOR_REG);
-	} while (status_val != 0x50 && status_val != 0x70);
-
-	if(status_val == 0x50)
-		return 0; /* device returned success */
-	else
-		return 1; /* device returned failure */
-}
-
-/*
- * pdc4030_identify sends a vendor-specific IDENTIFY command to the drive
- */
-int pdc4030_identify(ide_drive_t *drive)
-{
-	return pdc4030_cmd(drive, PROMISE_IDENTIFY);
-}
-
-/*
- * setup_pdc4030()
- * Completes the setup of a Promise DC4030 controller card, once found.
- */
-int __init setup_pdc4030(ide_hwif_t *hwif)
-{
-        ide_drive_t *drive;
-	ide_hwif_t *hwif2;
-	struct dc_ident ident;
-	int i;
-	ide_startstop_t startstop;
-	
-	if (!hwif) return 0;
-
-	drive = &hwif->drives[0];
-	hwif2 = &ide_hwifs[hwif->index+1];
-	if (hwif->chipset == ide_pdc4030) /* we've already been found ! */
-		return 1;
-
-	if (hwif->INB(IDE_NSECTOR_REG) == 0xFF ||
-	    hwif->INB(IDE_SECTOR_REG) == 0xFF) {
-		return 0;
-	}
-	if (IDE_CONTROL_REG)
-		hwif->OUTB(0x08, IDE_CONTROL_REG);
-	if (pdc4030_cmd(drive,PROMISE_GET_CONFIG)) {
-		return 0;
-	}
-	if (ide_wait_stat(&startstop, drive,DATA_READY,BAD_W_STAT,WAIT_DRQ)) {
-		printk(KERN_INFO
-			"%s: Failed Promise read config!\n",hwif->name);
-		return 0;
-	}
-	hwif->ata_input_data(drive, &ident, SECTOR_WORDS);
-	if (ident.id[1] != 'P' || ident.id[0] != 'T') {
-		return 0;
-	}
-	printk(KERN_INFO "%s: Promise caching controller, ",hwif->name);
-	switch(ident.type) {
-		case 0x43:	printk("DC4030VL-2, "); break;
-		case 0x41:	printk("DC4030VL-1, "); break;
-		case 0x40:	printk("DC4030VL, "); break;
-		default:
-			printk("unknown - type 0x%02x - please report!\n"
-			       ,ident.type);
-			printk("Please e-mail the following data to "
-			       "promise@pnd-pc.demon.co.uk along with\n"
-			       "a description of your card and drives:\n");
-			for (i=0; i < 0x90; i++) {
-				printk("%02x ", ((unsigned char *)&ident)[i]);
-				if ((i & 0x0f) == 0x0f) printk("\n");
-			}
-			return 0;
-	}
-	printk("%dKB cache, ",(int)ident.cache_mem);
-	switch(ident.irq) {
-            case 0x00: hwif->irq = 14; break;
-            case 0x01: hwif->irq = 12; break;
-            default:   hwif->irq = 15; break;
-	}
-	printk("on IRQ %d\n",hwif->irq);
-
-	/*
-	 * Once found and identified, we set up the next hwif in the array
-	 * (hwif2 = ide_hwifs[hwif->index+1]) with the same io ports, irq
-	 * and other settings as the main hwif. This gives us two "mated"
-	 * hwifs pointing to the Promise card.
-	 *
-	 * We also have to shift the default values for the remaining
-	 * interfaces "up by one" to make room for the second interface on the
-	 * same set of values.
-	 */
-
-	hwif->chipset	= hwif2->chipset = ide_pdc4030;
-	hwif->mate	= hwif2;
-	hwif2->mate	= hwif;
-	hwif2->channel	= 1;
-	hwif->rqsize	= hwif2->rqsize = 127;
-	hwif->no_lba48 = hwif2->no_lba48 = 1;
-	hwif->selectproc = hwif2->selectproc = &promise_selectproc;
-	hwif->serialized = hwif2->serialized = 1;
-	/* DC4030 hosted drives need their own identify... */
-	hwif->identify = hwif2->identify = &pdc4030_identify;
-
-	/* Override the normal ide disk read/write. */
-	hwif->rw_disk = promise_rw_disk;
-	hwif2->rw_disk = promise_rw_disk;
-
-	/* Shift the remaining interfaces up by one */
-	for (i=MAX_HWIFS-1 ; i > hwif->index+1 ; i--) {
-		ide_hwif_t *h = &ide_hwifs[i];
-
-#ifdef DEBUG
-		printk(KERN_DEBUG "pdc4030: Shifting i/f %d values to i/f %d\n",i-1,i);
-#endif /* DEBUG */
-		ide_init_hwif_ports(&h->hw, (h-1)->io_ports[IDE_DATA_OFFSET], 0, NULL);
-		memcpy(h->io_ports, h->hw.io_ports, sizeof(h->io_ports));
-		h->noprobe = (h-1)->noprobe;
-	}
-	ide_init_hwif_ports(&hwif2->hw, hwif->io_ports[IDE_DATA_OFFSET], 0, NULL);
-	memcpy(hwif2->io_ports, hwif->hw.io_ports, sizeof(hwif2->io_ports));
-	hwif2->irq = hwif->irq;
-	hwif2->hw.irq = hwif->hw.irq = hwif->irq;
-	for (i=0; i<2 ; i++) {
-		hwif->drives[i].io_32bit = 3;
-		hwif2->drives[i].io_32bit = 3;
-		hwif->drives[i].keep_settings = 1;
-		hwif2->drives[i].keep_settings = 1;
-		if (!ident.current_tm[i].cyl)
-			hwif->drives[i].noprobe = 1;
-		if (!ident.current_tm[i+2].cyl)
-			hwif2->drives[i].noprobe = 1;
-	}
-
-	probe_hwif_init(&ide_hwifs[hwif->index]);
-	probe_hwif_init(&ide_hwifs[hwif2->index]);
-
-	return 1;
-}
-
-/*
- * detect_pdc4030()
- * Tests for the presence of a DC4030 Promise card on this interface
- * Returns: 1 if found, 0 if not found
- */
-int __init detect_pdc4030(ide_hwif_t *hwif)
-{
-	ide_drive_t *drive = &hwif->drives[0];
-
-	if (IDE_DATA_REG == 0) { /* Skip test for non-existent interface */
-		return 0;
-	}
-	hwif->OUTB(0xF3, IDE_SECTOR_REG);
-	hwif->OUTB(0x14, IDE_SELECT_REG);
-	hwif->OUTB(PROMISE_EXTENDED_COMMAND, IDE_COMMAND_REG);
-
-	msleep(50);
-
-	if (hwif->INB(IDE_ERROR_REG) == 'P' &&
-	    hwif->INB(IDE_NSECTOR_REG) == 'T' &&
-	    hwif->INB(IDE_SECTOR_REG) == 'I') {
-		return 1;
-	} else {
-		return 0;
-	}
-}
-
-int __init pdc4030_init(void)
-{
-	unsigned int	index;
-	ide_hwif_t	*hwif;
-
-	for (index = 0; index < MAX_HWIFS; index++) {
-		hwif = &ide_hwifs[index];
-		if (hwif->chipset == ide_unknown && detect_pdc4030(hwif)) {
-			if (!setup_pdc4030(hwif))
-				return -ENODEV;
-			return 0;
-		}
-	}
-	return -ENODEV;
-}
-
-#ifdef MODULE
-module_init(pdc4030_init);
-#endif
-
-MODULE_AUTHOR("Peter Denison");
-MODULE_DESCRIPTION("Support of Promise 4030 VLB series IDE chipsets");
-MODULE_LICENSE("GPL");
-
-/*
- * promise_read_intr() is the handler for disk read/multread interrupts
- */
-static ide_startstop_t promise_read_intr (ide_drive_t *drive)
-{
-	unsigned int sectors_left, sectors_avail, nsect;
-	struct request *rq = HWGROUP(drive)->rq;
-	ata_status_t status;
-
-	status.all = HWIF(drive)->INB(IDE_STATUS_REG);
-	if (!OK_STAT(status.all, DATA_READY, BAD_R_STAT))
-		return DRIVER(drive)->error(drive, __FUNCTION__, status.all);
-
-read_again:
-	do {
-		sectors_left = HWIF(drive)->INB(IDE_NSECTOR_REG);
-		HWIF(drive)->INB(IDE_SECTOR_REG);
-	} while (HWIF(drive)->INB(IDE_NSECTOR_REG) != sectors_left);
-	sectors_avail = rq->nr_sectors - sectors_left;
-	if (!sectors_avail)
-		goto read_again;
-
-read_next:
-	nsect = rq->current_nr_sectors;
-	if (nsect > sectors_avail)
-		nsect = sectors_avail;
-	sectors_avail -= nsect;
-
-#ifdef DEBUG_READ
-	printk(KERN_DEBUG "%s: %s: sectors(%lu-%lu), rem=%lu\n",
-			  drive->name, __FUNCTION__,
-			  (unsigned long)rq->sector,
-			  (unsigned long)rq->sector + nsect - 1,
-			  (unsigned long)rq->nr_sectors - nsect);
-#endif /* DEBUG_READ */
-
-	HWIF(drive)->ata_input_data(drive, rq->buffer, nsect * SECTOR_WORDS);
-	rq->buffer += nsect<<9;
-	rq->sector += nsect;
-	rq->errors = 0;
-	rq->nr_sectors -= nsect;
-	if (!rq->current_nr_sectors)
-		DRIVER(drive)->end_request(drive, 1, 0);
-
-/*
- * Now the data has been read in, do the following:
- * 
- * if there are still sectors left in the request, 
- *   if we know there are still sectors available from the interface,
- *     go back and read the next bit of the request.
- *   else if DRQ is asserted, there are more sectors available, so
- *     go back and find out how many, then read them in.
- *   else if BUSY is asserted, we are going to get an interrupt, so
- *     set the handler for the interrupt and just return
- */
-	if (rq->nr_sectors > 0) {
-		if (sectors_avail)
-			goto read_next;
-		status.all = HWIF(drive)->INB(IDE_STATUS_REG);
-		if (status.b.drq)
-			goto read_again;
-		if (status.b.bsy) {
-			if (HWGROUP(drive)->handler != NULL)
-				BUG();
-			ide_set_handler(drive,
-					&promise_read_intr,
-					WAIT_CMD,
-					NULL);
-#ifdef DEBUG_READ
-			printk(KERN_DEBUG "%s: promise_read: waiting for"
-			       "interrupt\n", drive->name);
-#endif /* DEBUG_READ */
-			return ide_started;
-		}
-		printk(KERN_ERR "%s: Eeek! promise_read_intr: sectors left "
-		       "!DRQ !BUSY\n", drive->name);
-		return DRIVER(drive)->error(drive,
-				"promise read intr", status.all);
-	}
-	return ide_stopped;
-}
-
-/*
- * promise_complete_pollfunc()
- * This is the polling function for waiting (nicely!) until drive stops
- * being busy. It is invoked at the end of a write, after the previous poll
- * has finished.
- *
- * Once not busy, the end request is called.
- */
-static ide_startstop_t promise_complete_pollfunc(ide_drive_t *drive)
-{
-	ide_hwgroup_t *hwgroup = HWGROUP(drive);
-	struct request *rq = &hwgroup->wrq;
-	struct bio *bio = rq->bio;
-
-	if ((HWIF(drive)->INB(IDE_STATUS_REG)) & BUSY_STAT) {
-		if (time_before(jiffies, hwgroup->poll_timeout)) {
-			if (hwgroup->handler != NULL)
-				BUG();
-			ide_set_handler(drive,
-					&promise_complete_pollfunc,
-					HZ/100,
-					NULL);
-			return ide_started; /* continue polling... */
-		}
-		hwgroup->poll_timeout = 0;
-		printk(KERN_ERR "%s: completion timeout - still busy!\n",
-		       drive->name);
-		return DRIVER(drive)->error(drive, "busy timeout",
-				HWIF(drive)->INB(IDE_STATUS_REG));
-	}
-
-	hwgroup->poll_timeout = 0;
-#ifdef DEBUG_WRITE
-	printk(KERN_DEBUG "%s: Write complete - end_request\n", drive->name);
-#endif /* DEBUG_WRITE */
-
-	bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-	rq = hwgroup->rq;
-	DRIVER(drive)->end_request(drive, 1, rq->hard_nr_sectors);
-
-	return ide_stopped;
-}
-
-/*
- * promise_multwrite() transfers a block of up to mcount sectors of data
- * to a drive as part of a disk multiple-sector write operation.
- */
-static void promise_multwrite (ide_drive_t *drive, unsigned int mcount)
-{
-	ide_hwgroup_t *hwgroup	= HWGROUP(drive);
-	struct request *rq	= &hwgroup->wrq;
-
-	do {
-		char *buffer;
-		int nsect = rq->current_nr_sectors;
-
-		if (nsect > mcount)
-			nsect = mcount;
-		mcount -= nsect;
-		buffer = rq->buffer;
-
-		rq->sector += nsect;
-		rq->buffer += nsect << 9;
-		rq->nr_sectors -= nsect;
-		rq->current_nr_sectors -= nsect;
-
-		/* Do we move to the next bh after this? */
-		if (!rq->current_nr_sectors) {
-			struct bio *bio = rq->bio;
-
-			/*
-			 * only move to next bio, when we have processed
-			 * all bvecs in this one.
-			 */
-			if (++bio->bi_idx >= bio->bi_vcnt) {
-				bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-				bio = bio->bi_next;
-			}
-
-			/* end early early we ran out of requests */
-			if (!bio) {
-				mcount = 0;
-			} else {
-				rq->bio = bio;
-				rq->nr_cbio_segments = bio_segments(bio);
-				rq->current_nr_sectors = bio_cur_sectors(bio);
-				rq->hard_cur_sectors = rq->current_nr_sectors;
-			}
-		}
-
-		/*
-		 * Ok, we're all setup for the interrupt
-		 * re-entering us on the last transfer.
-		 */
-		taskfile_output_data(drive, buffer, nsect<<7);
-	} while (mcount);
-}
-
-/*
- * promise_write_pollfunc() is the handler for disk write completion polling.
- */
-static ide_startstop_t promise_write_pollfunc (ide_drive_t *drive)
-{
-	ide_hwgroup_t *hwgroup = HWGROUP(drive);
-	struct request *rq = &hwgroup->wrq;
-	struct bio *bio = rq->bio;
-
-	if (HWIF(drive)->INB(IDE_NSECTOR_REG) != 0) {
-		if (time_before(jiffies, hwgroup->poll_timeout)) {
-			if (hwgroup->handler != NULL)
-				BUG();
-			ide_set_handler(drive,
-					&promise_write_pollfunc,
-					HZ/100,
-					NULL);
-			return ide_started; /* continue polling... */
-		}
-		hwgroup->poll_timeout = 0;
-		printk(KERN_ERR "%s: write timed-out!\n",drive->name);
-		bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-		return DRIVER(drive)->error(drive, "write timeout",
-				HWIF(drive)->INB(IDE_STATUS_REG));
-	}
-
-	/*
-	 * Now write out last 4 sectors and poll for not BUSY
-	 */
-	promise_multwrite(drive, 4);
-	hwgroup->poll_timeout = jiffies + WAIT_WORSTCASE;
-	if (hwgroup->handler != NULL)
-		BUG();
-	ide_set_handler(drive, &promise_complete_pollfunc, HZ/100, NULL);
-#ifdef DEBUG_WRITE
-	printk(KERN_DEBUG "%s: Done last 4 sectors - status = %02x\n",
-		drive->name, HWIF(drive)->INB(IDE_STATUS_REG));
-#endif /* DEBUG_WRITE */
-	return ide_started;
-}
-
-/*
- * promise_write() transfers a block of one or more sectors of data to a
- * drive as part of a disk write operation. All but 4 sectors are transferred
- * in the first attempt, then the interface is polled (nicely!) for completion
- * before the final 4 sectors are transferred. There is no interrupt generated
- * on writes (at least on the DC4030VL-2), we just have to poll for NOT BUSY.
- */
-static ide_startstop_t promise_write (ide_drive_t *drive)
-{
-	ide_hwgroup_t *hwgroup = HWGROUP(drive);
-	struct request *rq = &hwgroup->wrq;
-
-#ifdef DEBUG_WRITE
-	printk(KERN_DEBUG "%s: %s: sectors(%lu-%lu)\n",
-			  drive->name, __FUNCTION__,
-			  (unsigned long)rq->sector,
-			  (unsigned long)rq->sector + rq->nr_sectors - 1);
-#endif /* DEBUG_WRITE */
-
-	/*
-	 * If there are more than 4 sectors to transfer, do n-4 then go into
-	 * the polling strategy as defined above.
-	 */
-	if (rq->nr_sectors > 4) {
-		promise_multwrite(drive, rq->nr_sectors - 4);
-		hwgroup->poll_timeout = jiffies + WAIT_WORSTCASE;
-		if (hwgroup->handler != NULL)	/* paranoia check */
-			BUG();
-		ide_set_handler (drive, &promise_write_pollfunc, HZ/100, NULL);
-		return ide_started;
-	} else {
-	/*
-	 * There are 4 or fewer sectors to transfer, do them all in one go
-	 * and wait for NOT BUSY.
-	 */
-		promise_multwrite(drive, rq->nr_sectors);
-		hwgroup->poll_timeout = jiffies + WAIT_WORSTCASE;
-		if (hwgroup->handler != NULL)
-			BUG();
-		ide_set_handler(drive,
-				&promise_complete_pollfunc,
-				HZ/100,
-				NULL);
-
-#ifdef DEBUG_WRITE
-		printk(KERN_DEBUG "%s: promise_write: <= 4 sectors, "
-			"status = %02x\n", drive->name,
-			HWIF(drive)->INB(IDE_STATUS_REG));
-#endif /* DEBUG_WRITE */
-		return ide_started;
-	}
-}
-
-/*
- * do_pdc4030_io() is called from promise_rw_disk, having had the block number
- * already set up. It issues a READ or WRITE command to the Promise
- * controller, assuming LBA has been used to set up the block number.
- */
-ide_startstop_t do_pdc4030_io (ide_drive_t *drive, struct request *rq)
-{
-	ide_startstop_t startstop;
-	unsigned long timeout;
-	u8 stat = 0;
-
-	if (rq_data_dir(rq) == READ) {
-		HWIF(drive)->OUTB(PROMISE_READ, IDE_COMMAND_REG);
-/*
- * The card's behaviour is odd at this point. If the data is
- * available, DRQ will be true, and no interrupt will be
- * generated by the card. If this is the case, we need to call the 
- * "interrupt" handler (promise_read_intr) directly. Otherwise, if
- * an interrupt is going to occur, bit0 of the SELECT register will
- * be high, so we can set the handler the just return and be interrupted.
- * If neither of these is the case, we wait for up to 50ms (badly I'm
- * afraid!) until one of them is.
- */
-		timeout = jiffies + HZ/20; /* 50ms wait */
-		do {
-			stat = HWIF(drive)->INB(IDE_STATUS_REG);
-			if (stat & DRQ_STAT) {
-				udelay(1);
-				return promise_read_intr(drive);
-			}
-			if (HWIF(drive)->INB(IDE_SELECT_REG) & 0x01) {
-#ifdef DEBUG_READ
-				printk(KERN_DEBUG "%s: read: waiting for "
-						"interrupt\n", drive->name);
-#endif /* DEBUG_READ */
-				ide_set_handler(drive,
-						&promise_read_intr,
-						WAIT_CMD,
-						NULL);
-				return ide_started;
-			}
-			udelay(1);
-		} while (time_before(jiffies, timeout));
-
-		printk(KERN_ERR "%s: reading: No DRQ and not "
-				"waiting - Odd!\n", drive->name);
-		return ide_stopped;
-	} else {
-		HWIF(drive)->OUTB(PROMISE_WRITE, IDE_COMMAND_REG);
-		if (ide_wait_stat(&startstop, drive, DATA_READY,
-				drive->bad_wstat, WAIT_DRQ)) {
-			printk(KERN_ERR "%s: no DRQ after issuing "
-				"PROMISE_WRITE\n", drive->name);
-			return startstop;
-	    	}
-		if (!drive->unmask)
-			local_irq_disable();
-		HWGROUP(drive)->wrq = *rq; /* scratchpad */
-		return promise_write(drive);
-	}
-}
-
-static ide_startstop_t promise_rw_disk (ide_drive_t *drive, struct request *rq, sector_t block)
-{
-	/* The four drives on the two logical (one physical) interfaces
-	   are distinguished by writing the drive number (0-3) to the
-	   Feature register.
-	   FIXME: Is promise_selectproc now redundant??
-	*/
-	ide_hwif_t *hwif = HWIF(drive);
-	int drive_number = (hwif->channel << 1) + drive->select.b.unit;
-
-	BUG_ON(rq->nr_sectors > 127);
-
-	if (IDE_CONTROL_REG)
-		hwif->OUTB(drive->ctl, IDE_CONTROL_REG);
-	hwif->OUTB(drive_number, IDE_FEATURE_REG);
-	hwif->OUTB(rq->nr_sectors, IDE_NSECTOR_REG);
-	hwif->OUTB(block,IDE_SECTOR_REG);
-	hwif->OUTB(block>>=8,IDE_LCYL_REG);
-	hwif->OUTB(block>>=8,IDE_HCYL_REG);
-	hwif->OUTB(((block>>8)&0x0f)|drive->select.all,IDE_SELECT_REG);
-
-	return do_pdc4030_io(drive, rq);
-}
diff -Naur linuxppc-2.6.9/drivers/ide/legacy/qd65xx.c linuxppc-2.6.9-dream/drivers/ide/legacy/qd65xx.c
--- linuxppc-2.6.9/drivers/ide/legacy/qd65xx.c	2004-10-18 23:53:41.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/legacy/qd65xx.c	2005-06-20 10:46:11.000000000 +0200
@@ -101,7 +101,7 @@
 	spin_unlock_irqrestore(&ide_lock, flags);
 }
 
-u8 __init qd_read_reg (unsigned long reg)
+static u8 __init qd_read_reg (unsigned long reg)
 {
 	unsigned long flags;
 	u8 read;
@@ -429,6 +429,9 @@
 
 		qd_setup(hwif, base, config, QD6500_DEF_DATA, QD6500_DEF_DATA,
 			 &qd6500_tune_drive);
+
+		create_proc_ide_interfaces();
+
 		return 1;
 	}
 
@@ -459,6 +462,8 @@
 				 &qd6580_tune_drive);
 			qd_write_reg(QD_DEF_CONTR,QD_CONTROL_PORT);
 
+			create_proc_ide_interfaces();
+
 			return 1;
 		} else {
 			ide_hwif_t *mate;
@@ -477,6 +482,8 @@
 				 &qd6580_tune_drive);
 			qd_write_reg(QD_DEF_CONTR,QD_CONTROL_PORT);
 
+			create_proc_ide_interfaces();
+
 			return 0; /* no other qd65xx possible */
 		}
 	}
diff -Naur linuxppc-2.6.9/drivers/ide/legacy/qd65xx.h linuxppc-2.6.9-dream/drivers/ide/legacy/qd65xx.h
--- linuxppc-2.6.9/drivers/ide/legacy/qd65xx.h	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/legacy/qd65xx.h	2005-06-20 10:46:11.000000000 +0200
@@ -46,7 +46,7 @@
 
 /* Drive specific timing taken from DOS driver v3.7 */
 
-struct qd65xx_timing_s {
+static struct qd65xx_timing_s {
 	s8	offset;   /* ofset from the beginning of Model Number" */
 	char	model[4];    /* 4 chars from Model number, no conversion */
 	s16	active;   /* active time */
diff -Naur linuxppc-2.6.9/drivers/ide/legacy/umc8672.c linuxppc-2.6.9-dream/drivers/ide/legacy/umc8672.c
--- linuxppc-2.6.9/drivers/ide/legacy/umc8672.c	2004-10-18 23:53:41.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/legacy/umc8672.c	2005-06-20 10:46:11.000000000 +0200
@@ -161,6 +161,8 @@
 	probe_hwif_init(hwif);
 	probe_hwif_init(mate);
 
+	create_proc_ide_interfaces();
+
 	return 0;
 }
 
diff -Naur linuxppc-2.6.9/drivers/ide/Makefile linuxppc-2.6.9-dream/drivers/ide/Makefile
--- linuxppc-2.6.9/drivers/ide/Makefile	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/Makefile	2005-06-20 10:46:10.000000000 +0200
@@ -38,6 +38,11 @@
 # built-in only drivers from ppc/
 ide-core-$(CONFIG_BLK_DEV_MPC8xx_IDE)	+= ppc/mpc8xx.o
 ide-core-$(CONFIG_BLK_DEV_IDE_PMAC)	+= ppc/pmac.o
+ifeq ($(CONFIG_BLK_DEV_IDE_STB04xxx),y)
+ide-core-$(CONFIG_BLK_DEV_IDE_STB04xxx)	+= ppc/ibm_ocp_ide.o
+else
+obj-$(CONFIG_BLK_DEV_IDE_STB04xxx)	+= ppc/ibm_ocp_ide.o
+endif
 
 # built-in only drivers from h8300/
 ide-core-$(CONFIG_H8300)		+= h8300/ide-h8300.o
@@ -52,3 +57,4 @@
 
 obj-$(CONFIG_BLK_DEV_IDE)		+= legacy/ arm/
 obj-$(CONFIG_BLK_DEV_HD)		+= legacy/
+obj-$(CONFIG_ETRAX_IDE)		+= cris/
diff -Naur linuxppc-2.6.9/drivers/ide/pci/adma100.c linuxppc-2.6.9-dream/drivers/ide/pci/adma100.c
--- linuxppc-2.6.9/drivers/ide/pci/adma100.c	2004-10-18 23:53:50.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/adma100.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/*
- *  linux/drivers/ide/pci/adma100.c -- basic support for Pacific Digital ADMA-100 boards
- *
- *     Created 09 Apr 2002 by Mark Lord
- *
- *  This file is subject to the terms and conditions of the GNU General Public
- *  License.  See the file COPYING in the main directory of this archive for
- *  more details.
- */
-
-#include <linux/mm.h>
-#include <linux/blkdev.h>
-#include <linux/hdreg.h>
-#include <linux/ide.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <asm/io.h>
-
-void __init ide_init_adma100 (ide_hwif_t *hwif)
-{
-	unsigned long  phy_admctl = pci_resource_start(hwif->pci_dev, 4) + 0x80 + (hwif->channel * 0x20);
-	void *v_admctl;
-
-	hwif->autodma = 0;		// not compatible with normal IDE DMA transfers
-	hwif->dma_base = 0;		// disable DMA completely
-	hwif->io_ports[IDE_CONTROL_OFFSET] += 4;	// chip needs offset of 6 instead of 2
-	v_admctl = ioremap_nocache(phy_admctl, 1024);	// map config regs, so we can turn on drive IRQs
-	*((unsigned short *)v_admctl) &= 3;		// enable aIEN; preserve PIO mode
-	iounmap(v_admctl);				// all done; unmap config regs
-}
diff -Naur linuxppc-2.6.9/drivers/ide/pci/adma100.h linuxppc-2.6.9-dream/drivers/ide/pci/adma100.h
--- linuxppc-2.6.9/drivers/ide/pci/adma100.h	2004-10-18 23:55:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/adma100.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-#ifndef ADMA_100_H
-#define ADMA_100_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-extern void init_setup_pdcadma(struct pci_dev *, ide_pci_device_t *);
-extern unsigned int init_chipset_pdcadma(struct pci_dev *, const char *);
-extern void init_hwif_pdcadma(ide_hwif_t *);
-extern void init_dma_pdcadma(ide_hwif_t *, unsigned long);
-
-static ide_pci_device_t pdcadma_chipsets[] __devinitdata = {
-	{
-		.vendor		= PCI_VENDOR_ID_PDC,
-		.device		= PCI_DEVICE_ID_PDC_1841,
-		.name		= "ADMA100",
-		.init_setup	= init_setup_pdcadma,
-		.init_chipset	= init_chipset_pdcadma,
-		.init_hwif	= init_hwif_pdcadma,
-		.init_dma	= init_dma_pdcadma,
-		.channels	= 2,
-		.autodma	= NODMA,
-		.bootable	= OFF_BOARD,
-	}
-}
-
-#endif /* ADMA_100_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/aec62xx.c linuxppc-2.6.9-dream/drivers/ide/pci/aec62xx.c
--- linuxppc-2.6.9/drivers/ide/pci/aec62xx.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/aec62xx.c	2005-06-20 10:46:11.000000000 +0200
@@ -16,54 +16,56 @@
 
 #include <asm/io.h>
 
-#include "aec62xx.h"
+struct chipset_bus_clock_list_entry {
+	u8 xfer_speed;
+	u8 chipset_settings;
+	u8 ultra_settings;
+};
+
+static struct chipset_bus_clock_list_entry aec6xxx_33_base [] = {
+	{	XFER_UDMA_6,	0x31,	0x07	},
+	{	XFER_UDMA_5,	0x31,	0x06	},
+	{	XFER_UDMA_4,	0x31,	0x05	},
+	{	XFER_UDMA_3,	0x31,	0x04	},
+	{	XFER_UDMA_2,	0x31,	0x03	},
+	{	XFER_UDMA_1,	0x31,	0x02	},
+	{	XFER_UDMA_0,	0x31,	0x01	},
+
+	{	XFER_MW_DMA_2,	0x31,	0x00	},
+	{	XFER_MW_DMA_1,	0x31,	0x00	},
+	{	XFER_MW_DMA_0,	0x0a,	0x00	},
+	{	XFER_PIO_4,	0x31,	0x00	},
+	{	XFER_PIO_3,	0x33,	0x00	},
+	{	XFER_PIO_2,	0x08,	0x00	},
+	{	XFER_PIO_1,	0x0a,	0x00	},
+	{	XFER_PIO_0,	0x00,	0x00	},
+	{	0,		0x00,	0x00	}
+};
 
-#if defined(DISPLAY_AEC62XX_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 aec62xx_proc = 0;
-
-#define AEC_MAX_DEVS		5
-
-static struct pci_dev *aec_devs[AEC_MAX_DEVS];
-static int n_aec_devs;
-
-static int aec62xx_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	char *chipset_nums[] = {"error", "error", "error", "error",
-				"error", "error", "850UF",   "860",
-				 "860R",   "865",  "865R", "error"  };
-	int len;
-	int i;
-
-	for (i = 0; i < n_aec_devs; i++) {
-		struct pci_dev *dev	= aec_devs[i];
-		unsigned long iobase = pci_resource_start(dev, 4);
-		u8 c0 = 0, c1 = 0, art	= 0;
-
-		c0 = inb(iobase + 0x02);
-		c1 = inb(iobase + 0x0a);
-
-		p += sprintf(p, "\nController: %d\n", i);
-		p += sprintf(p, "Chipset: AEC%s\n", chipset_nums[dev->device]);
-
-		p += sprintf(p, "--------------- Primary Channel "
-				"---------------- Secondary Channel "
-				"-------------\n");
-		(void) pci_read_config_byte(dev, 0x4a, &art);
-		p += sprintf(p, "                %sabled ",
-			(art&0x02)?" en":"dis");
-		p += sprintf(p, "                        %sabled\n",
-			(art&0x04)?" en":"dis");
-		p += sprintf(p, "--------------- drive0 --------- drive1 "
-				"-------- drive0 ---------- drive1 ------\n");
-		p += sprintf(p, "DMA enabled:    %s              %s ",
-			(c0&0x20)?"yes":"no ",(c0&0x40)?"yes":"no ");
-		p += sprintf(p, "            %s               %s\n",
-			(c1&0x20)?"yes":"no ",(c1&0x40)?"yes":"no ");
+static struct chipset_bus_clock_list_entry aec6xxx_34_base [] = {
+	{	XFER_UDMA_6,	0x41,	0x06	},
+	{	XFER_UDMA_5,	0x41,	0x05	},
+	{	XFER_UDMA_4,	0x41,	0x04	},
+	{	XFER_UDMA_3,	0x41,	0x03	},
+	{	XFER_UDMA_2,	0x41,	0x02	},
+	{	XFER_UDMA_1,	0x41,	0x01	},
+	{	XFER_UDMA_0,	0x41,	0x01	},
+
+	{	XFER_MW_DMA_2,	0x41,	0x00	},
+	{	XFER_MW_DMA_1,	0x42,	0x00	},
+	{	XFER_MW_DMA_0,	0x7a,	0x00	},
+	{	XFER_PIO_4,	0x41,	0x00	},
+	{	XFER_PIO_3,	0x43,	0x00	},
+	{	XFER_PIO_2,	0x78,	0x00	},
+	{	XFER_PIO_1,	0x7a,	0x00	},
+	{	XFER_PIO_0,	0x70,	0x00	},
+	{	0,		0x00,	0x00	}
+};
 
+#define BUSCLOCK(D)	\
+	((struct chipset_bus_clock_list_entry *) pci_get_drvdata((D)))
+
+#if 0
 		if (dev->device == PCI_DEVICE_ID_ARTOP_ATP850UF) {
 			(void) pci_read_config_byte(dev, 0x54, &art);
 			p += sprintf(p, "DMA Mode:       %s(%s)",
@@ -79,59 +81,7 @@
 				(c1&0x40)?((art&0xc0)?"UDMA":" DMA"):" PIO",
 				(art&0x80)?"2":(art&0x40)?"1":"0");
 		} else {
-			/*
-			 * case PCI_DEVICE_ID_ARTOP_ATP860:
-			 * case PCI_DEVICE_ID_ARTOP_ATP860R:
-			 * case PCI_DEVICE_ID_ARTOP_ATP865:
-			 * case PCI_DEVICE_ID_ARTOP_ATP865R:
-			 */
-			(void) pci_read_config_byte(dev, 0x44, &art);
-			p += sprintf(p, "DMA Mode:       %s(%s)",
-				(c0&0x20)?((art&0x07)?"UDMA":" DMA"):" PIO",
-				((art&0x07)==0x07)?"6":
-				((art&0x06)==0x06)?"5":
-				((art&0x05)==0x05)?"4":
-				((art&0x04)==0x04)?"3":
-				((art&0x03)==0x03)?"2":
-				((art&0x02)==0x02)?"1":
-				((art&0x01)==0x01)?"0":"?");
-			p += sprintf(p, "          %s(%s)",
-				(c0&0x40)?((art&0x70)?"UDMA":" DMA"):" PIO",
-				((art&0x70)==0x70)?"6":
-				((art&0x60)==0x60)?"5":
-				((art&0x50)==0x50)?"4":
-				((art&0x40)==0x40)?"3":
-				((art&0x30)==0x30)?"2":
-				((art&0x20)==0x20)?"1":
-				((art&0x10)==0x10)?"0":"?");
-			(void) pci_read_config_byte(dev, 0x45, &art);
-			p += sprintf(p, "         %s(%s)",
-				(c1&0x20)?((art&0x07)?"UDMA":" DMA"):" PIO",
-				((art&0x07)==0x07)?"6":
-				((art&0x06)==0x06)?"5":
-				((art&0x05)==0x05)?"4":
-				((art&0x04)==0x04)?"3":
-				((art&0x03)==0x03)?"2":
-				((art&0x02)==0x02)?"1":
-				((art&0x01)==0x01)?"0":"?");
-			p += sprintf(p, "           %s(%s)\n",
-				(c1&0x40)?((art&0x70)?"UDMA":" DMA"):" PIO",
-				((art&0x70)==0x70)?"6":
-				((art&0x60)==0x60)?"5":
-				((art&0x50)==0x50)?"4":
-				((art&0x40)==0x40)?"3":
-				((art&0x30)==0x30)?"2":
-				((art&0x20)==0x20)?"1":
-				((art&0x10)==0x10)?"0":"?");
-		}
-	}
-	/* p - buffer must be less than 4k! */
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif	/* defined(DISPLAY_AEC62xx_TIMINGS) && defined(CONFIG_PROC_FS) */
+#endif
 
 /*
  * TO DO: active tuning and correction of cards without a bios.
@@ -198,8 +148,7 @@
 	/* 0x40|(2*drive->dn): Active, 0x41|(2*drive->dn): Recovery */
 	pci_read_config_word(dev, 0x40|(2*drive->dn), &d_conf);
 	tmp0 = pci_bus_clock_list(speed, BUSCLOCK(dev));
-	SPLIT_BYTE(tmp0,tmp1,tmp2);
-	MAKE_WORD(d_conf,tmp1,tmp2);
+	d_conf = ((tmp0 & 0xf0) << 4) | (tmp0 & 0xf);
 	pci_write_config_word(dev, 0x40|(2*drive->dn), d_conf);
 
 	tmp1 = 0x00;
@@ -286,36 +235,16 @@
 	struct hd_driveid *id	= drive->id;
 
 	if ((id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		aec62xx_tune_drive(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -375,15 +304,6 @@
 		printk(KERN_INFO "%s: ROM enabled at 0x%08lx\n", name, dev->resource[PCI_ROM_RESOURCE].start);
 	}
 
-#if defined(DISPLAY_AEC62XX_TIMINGS) && defined(CONFIG_PROC_FS)
-	aec_devs[n_aec_devs++] = dev;
-
-	if (!aec62xx_proc) {
-		aec62xx_proc = 1;
-		ide_pci_create_host_proc("aec62xx", aec62xx_get_info);
-	}
-#endif /* DISPLAY_AEC62XX_TIMINGS && CONFIG_PROC_FS */
-
 	if (bus_speed <= 33)
 		pci_set_drvdata(dev, (void *) aec6xxx_33_base);
 	else
@@ -447,12 +367,12 @@
 	ide_setup_dma(hwif, dmabase, 8);
 }
 
-static void __devinit init_setup_aec62xx(struct pci_dev *dev, ide_pci_device_t *d)
+static int __devinit init_setup_aec62xx(struct pci_dev *dev, ide_pci_device_t *d)
 {
-	ide_setup_pci_device(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
-static void __devinit init_setup_aec6x80(struct pci_dev *dev, ide_pci_device_t *d)
+static int __devinit init_setup_aec6x80(struct pci_dev *dev, ide_pci_device_t *d)
 {
 	unsigned long bar4reg = pci_resource_start(dev, 4);
 
@@ -466,9 +386,61 @@
 			strcpy(d->name, "AEC6280R");
 	}
 
-	ide_setup_pci_device(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
+static ide_pci_device_t aec62xx_chipsets[] __devinitdata = {
+	{	/* 0 */
+		.name		= "AEC6210",
+		.init_setup	= init_setup_aec62xx,
+		.init_chipset	= init_chipset_aec62xx,
+		.init_hwif	= init_hwif_aec62xx,
+		.init_dma	= init_dma_aec62xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x4a,0x02,0x02}, {0x4a,0x04,0x04}},
+		.bootable	= OFF_BOARD,
+	},{	/* 1 */
+		.name		= "AEC6260",
+		.init_setup	= init_setup_aec62xx,
+		.init_chipset	= init_chipset_aec62xx,
+		.init_hwif	= init_hwif_aec62xx,
+		.init_dma	= init_dma_aec62xx,
+		.channels	= 2,
+		.autodma	= NOAUTODMA,
+		.bootable	= OFF_BOARD,
+	},{	/* 2 */
+		.name		= "AEC6260R",
+		.init_setup	= init_setup_aec62xx,
+		.init_chipset	= init_chipset_aec62xx,
+		.init_hwif	= init_hwif_aec62xx,
+		.init_dma	= init_dma_aec62xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x4a,0x02,0x02}, {0x4a,0x04,0x04}},
+		.bootable	= NEVER_BOARD,
+	},{	/* 3 */
+		.name		= "AEC6X80",
+		.init_setup	= init_setup_aec6x80,
+		.init_chipset	= init_chipset_aec62xx,
+		.init_hwif	= init_hwif_aec62xx,
+		.init_dma	= init_dma_aec62xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+	},{	/* 4 */
+		.name		= "AEC6X80R",
+		.init_setup	= init_setup_aec6x80,
+		.init_chipset	= init_chipset_aec62xx,
+		.init_hwif	= init_hwif_aec62xx,
+		.init_dma	= init_dma_aec62xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x4a,0x02,0x02}, {0x4a,0x04,0x04}},
+		.bootable	= OFF_BOARD,
+	}
+};
+
 /**
  *	aec62xx_init_one	-	called when a AEC is found
  *	@dev: the aec62xx device
@@ -482,8 +454,7 @@
 {
 	ide_pci_device_t *d = &aec62xx_chipsets[id->driver_data];
 
-	d->init_setup(dev, d);
-	return 0;
+	return d->init_setup(dev, d);
 }
 
 static struct pci_device_id aec62xx_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/aec62xx.h linuxppc-2.6.9-dream/drivers/ide/pci/aec62xx.h
--- linuxppc-2.6.9/drivers/ide/pci/aec62xx.h	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/aec62xx.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,124 +0,0 @@
-#ifndef AEC62XX_H
-#define AEC62XX_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-#define DISPLAY_AEC62XX_TIMINGS
-
-struct chipset_bus_clock_list_entry {
-	byte		xfer_speed;
-	byte		chipset_settings;
-	byte		ultra_settings;
-};
-
-struct chipset_bus_clock_list_entry aec6xxx_33_base [] = {
-	{	XFER_UDMA_6,	0x31,	0x07	},
-	{	XFER_UDMA_5,	0x31,	0x06	},
-	{	XFER_UDMA_4,	0x31,	0x05	},
-	{	XFER_UDMA_3,	0x31,	0x04	},
-	{	XFER_UDMA_2,	0x31,	0x03	},
-	{	XFER_UDMA_1,	0x31,	0x02	},
-	{	XFER_UDMA_0,	0x31,	0x01	},
-
-	{	XFER_MW_DMA_2,	0x31,	0x00	},
-	{	XFER_MW_DMA_1,	0x31,	0x00	},
-	{	XFER_MW_DMA_0,	0x0a,	0x00	},
-	{	XFER_PIO_4,	0x31,	0x00	},
-	{	XFER_PIO_3,	0x33,	0x00	},
-	{	XFER_PIO_2,	0x08,	0x00	},
-	{	XFER_PIO_1,	0x0a,	0x00	},
-	{	XFER_PIO_0,	0x00,	0x00	},
-	{	0,		0x00,	0x00	}
-};
-
-struct chipset_bus_clock_list_entry aec6xxx_34_base [] = {
-	{	XFER_UDMA_6,	0x41,	0x06	},
-	{	XFER_UDMA_5,	0x41,	0x05	},
-	{	XFER_UDMA_4,	0x41,	0x04	},
-	{	XFER_UDMA_3,	0x41,	0x03	},
-	{	XFER_UDMA_2,	0x41,	0x02	},
-	{	XFER_UDMA_1,	0x41,	0x01	},
-	{	XFER_UDMA_0,	0x41,	0x01	},
-
-	{	XFER_MW_DMA_2,	0x41,	0x00	},
-	{	XFER_MW_DMA_1,	0x42,	0x00	},
-	{	XFER_MW_DMA_0,	0x7a,	0x00	},
-	{	XFER_PIO_4,	0x41,	0x00	},
-	{	XFER_PIO_3,	0x43,	0x00	},
-	{	XFER_PIO_2,	0x78,	0x00	},
-	{	XFER_PIO_1,	0x7a,	0x00	},
-	{	XFER_PIO_0,	0x70,	0x00	},
-	{	0,		0x00,	0x00	}
-};
-
-#ifndef SPLIT_BYTE
-#define SPLIT_BYTE(B,H,L)	((H)=(B>>4), (L)=(B-((B>>4)<<4)))
-#endif
-#ifndef MAKE_WORD
-#define MAKE_WORD(W,HB,LB)	((W)=((HB<<8)+LB))
-#endif
-
-#define BUSCLOCK(D)	\
-	((struct chipset_bus_clock_list_entry *) pci_get_drvdata((D)))
-
-static void init_setup_aec6x80(struct pci_dev *, ide_pci_device_t *);
-static void init_setup_aec62xx(struct pci_dev *, ide_pci_device_t *);
-static unsigned int init_chipset_aec62xx(struct pci_dev *, const char *);
-static void init_hwif_aec62xx(ide_hwif_t *);
-static void init_dma_aec62xx(ide_hwif_t *, unsigned long);
-
-static ide_pci_device_t aec62xx_chipsets[] __devinitdata = {
-	{	/* 0 */
-		.name		= "AEC6210",
-		.init_setup	= init_setup_aec62xx,
-		.init_chipset	= init_chipset_aec62xx,
-		.init_hwif	= init_hwif_aec62xx,
-		.init_dma	= init_dma_aec62xx,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.enablebits	= {{0x4a,0x02,0x02}, {0x4a,0x04,0x04}},
-		.bootable	= OFF_BOARD,
-	},{	/* 1 */
-		.name		= "AEC6260",
-		.init_setup	= init_setup_aec62xx,
-		.init_chipset	= init_chipset_aec62xx,
-		.init_hwif	= init_hwif_aec62xx,
-		.init_dma	= init_dma_aec62xx,
-		.channels	= 2,
-		.autodma	= NOAUTODMA,
-		.bootable	= OFF_BOARD,
-	},{	/* 2 */
-		.name		= "AEC6260R",
-		.init_setup	= init_setup_aec62xx,
-		.init_chipset	= init_chipset_aec62xx,
-		.init_hwif	= init_hwif_aec62xx,
-		.init_dma	= init_dma_aec62xx,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.enablebits	= {{0x4a,0x02,0x02}, {0x4a,0x04,0x04}},
-		.bootable	= NEVER_BOARD,
-	},{	/* 3 */
-		.name		= "AEC6X80",
-		.init_setup	= init_setup_aec6x80,
-		.init_chipset	= init_chipset_aec62xx,
-		.init_hwif	= init_hwif_aec62xx,
-		.init_dma	= init_dma_aec62xx,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-	},{	/* 4 */
-		.name		= "AEC6X80R",
-		.init_setup	= init_setup_aec6x80,
-		.init_chipset	= init_chipset_aec62xx,
-		.init_hwif	= init_hwif_aec62xx,
-		.init_dma	= init_dma_aec62xx,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.enablebits	= {{0x4a,0x02,0x02}, {0x4a,0x04,0x04}},
-		.bootable	= OFF_BOARD,
-	}
-};
-
-#endif /* AEC62XX_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/alim15x3.c linuxppc-2.6.9-dream/drivers/ide/pci/alim15x3.c
--- linuxppc-2.6.9/drivers/ide/pci/alim15x3.c	2004-10-18 23:53:50.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/alim15x3.c	2005-06-20 10:46:11.000000000 +0200
@@ -8,6 +8,7 @@
  *  Copyright (C) 1998-2000 Andre Hedrick (andre@linux-ide.org)
  *  May be copied or modified under the terms of the GNU General Public License
  *  Copyright (C) 2002 Alan Cox <alan@redhat.com>
+ *  ALi (now ULi M5228) support by Clear Zhang <Clear.Zhang@ali.com.tw>
  *
  *  (U)DMA capable version of ali 1533/1543(C), 1535(D)
  *
@@ -558,18 +559,19 @@
 }
 
 /**
- *	ali15x3_dma_write	-	do a DMA IDE write
- *	@drive:	drive to issue write for
+ *	ali15x3_dma_setup	-	begin a DMA phase
+ *	@drive:	target device
  *
- *	Returns 1 if the DMA write cannot be performed, zero on 
- *	success.
+ *	Returns 1 if the DMA cannot be performed, zero on success.
  */
- 
-static int ali15x3_dma_write (ide_drive_t *drive)
+
+static int ali15x3_dma_setup(ide_drive_t *drive)
 {
-	if ((m5229_revision < 0xC2) && (drive->media != ide_disk))
-		return 1;	/* try PIO instead of DMA */
-	return __ide_dma_write(drive);
+	if (m5229_revision < 0xC2 && drive->media != ide_disk) {
+		if (rq_data_dir(drive->hwif->hwgroup->rq))
+			return 1;	/* try PIO instead of DMA */
+	}
+	return ide_dma_setup(drive);
 }
 
 /**
@@ -773,7 +775,7 @@
                  * M1543C or newer for DMAing
                  */
                 hwif->ide_dma_check = &ali15x3_config_drive_for_dma;
-                hwif->ide_dma_write = &ali15x3_dma_write;
+		hwif->dma_setup = &ali15x3_dma_setup;
 		if (!noautodma)
 			hwif->autodma = 1;
 		if (!(hwif->udma_four))
@@ -798,8 +800,9 @@
 	s8 irq_routing_table[] = { -1,  9, 3, 10, 4,  5, 7,  6,
 				      1, 11, 0, 12, 0, 14, 0, 15 };
 	int irq = -1;
-	
-	hwif->irq = hwif->channel ? 15 : 14;
+
+	if (hwif->pci_dev->device == PCI_DEVICE_ID_AL_M5229)
+		hwif->irq = hwif->channel ? 15 : 14;
 
 	if (isa_dev) {
 		/*
@@ -881,13 +884,13 @@
 #if defined(CONFIG_SPARC64)
 	d->init_hwif = init_hwif_common_ali15x3;
 #endif /* CONFIG_SPARC64 */
-	ide_setup_pci_device(dev, d);
-	return 0;
+	return ide_setup_pci_device(dev, d);
 }
 
 
 static struct pci_device_id alim15x3_pci_tbl[] = {
 	{ PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M5229, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M5228, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, alim15x3_pci_tbl);
diff -Naur linuxppc-2.6.9/drivers/ide/pci/amd74xx.c linuxppc-2.6.9-dream/drivers/ide/pci/amd74xx.c
--- linuxppc-2.6.9/drivers/ide/pci/amd74xx.c	2004-10-18 23:55:35.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/amd74xx.c	2005-06-20 10:46:11.000000000 +0200
@@ -416,8 +416,8 @@
 {
 	int i;
 
-	if (!hwif->irq)
-		hwif->irq = hwif->channel ? 15 : 14;
+	if (hwif->irq == 0) /* 0 is bogus but will do for now */
+		hwif->irq = pci_get_legacy_ide_irq(hwif->pci_dev, hwif->channel);
 
 	hwif->autodma = 0;
 
@@ -493,9 +493,12 @@
 {
 	amd_chipset = amd74xx_chipsets + id->driver_data;
 	amd_config = amd_ide_chips + id->driver_data;
-	if (dev->device != amd_config->id) BUG();
-	ide_setup_pci_device(dev, amd_chipset);
-	return 0;
+	if (dev->device != amd_config->id) {
+		printk(KERN_ERR "%s: assertion 0x%02x == 0x%02x failed !\n",
+		       pci_name(dev), dev->device, amd_config->id);
+		return -ENODEV;
+	}
+	return ide_setup_pci_device(dev, amd_chipset);
 }
 
 static struct pci_device_id amd74xx_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/atiixp.c linuxppc-2.6.9-dream/drivers/ide/pci/atiixp.c
--- linuxppc-2.6.9/drivers/ide/pci/atiixp.c	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/atiixp.c	2005-06-20 10:46:11.000000000 +0200
@@ -47,102 +47,6 @@
 
 static int save_mdma_mode[4];
 
-#define DISPLAY_ATIIXP_TIMINGS
-
-#if defined(DISPLAY_ATIIXP_TIMINGS) && defined(CONFIG_PROC_FS)
-
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 atiixp_proc;
-static struct pci_dev *bmide_dev;
-
-/**
- *	atiixp_get_info		-	fill in /proc for ATIIXP IDE
- *	@buffer: buffer to fill
- *	@addr: address of user start in buffer
- *	@offset: offset into 'file'
- *	@count: buffer count
- *
- *	Output summary data on the tuning.
- */
-
-static int atiixp_get_info(char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	struct pci_dev *dev = bmide_dev;
-	unsigned long bibma = pci_resource_start(dev, 4);
-	u32 mdma_timing = 0;
-	u16 udma_mode = 0, pio_mode = 0;
-	u8 c0, c1, udma_control = 0;
-
-	p += sprintf(p, "\n                          ATI ");
-	p += sprintf(p, "ATIIXP Ultra100 IDE Chipset.\n");
-
-	pci_read_config_byte(dev, ATIIXP_IDE_UDMA_CONTROL, &udma_control);
-	pci_read_config_word(dev, ATIIXP_IDE_UDMA_MODE, &udma_mode);
-	pci_read_config_word(dev, ATIIXP_IDE_PIO_MODE, &pio_mode);
-	pci_read_config_dword(dev, ATIIXP_IDE_MDMA_TIMING, &mdma_timing);
-
-	/*
-	 * at that point bibma+0x2 et bibma+0xa are byte registers
-	 * to investigate:
-	 */
-	c0 = inb(bibma + 0x02);
-	c1 = inb(bibma + 0x0a);
-
-	p += sprintf(p, "--------------- Primary Channel "
-			"---------------- Secondary Channel "
-			"-------------\n");
-	p += sprintf(p, "                %sabled "
-			"                        %sabled\n",
-			(c0 & 0x80) ? "dis" : " en",
-			(c1 & 0x80) ? "dis" : " en");
-	p += sprintf(p, "--------------- drive0 --------- drive1 "
-			"-------- drive0 ---------- drive1 ------\n");
-	p += sprintf(p, "DMA enabled:    %s              %s "
-			"            %s               %s\n",
-			(c0 & 0x20) ? "yes" : "no ",
-			(c0 & 0x40) ? "yes" : "no ",
-			(c1 & 0x20) ? "yes" : "no ",
-			(c1 & 0x40) ? "yes" : "no " );
-	p += sprintf(p, "UDMA enabled:   %s              %s "
-			"            %s               %s\n",
-			(udma_control & 0x01) ? "yes" : "no ",
-			(udma_control & 0x02) ? "yes" : "no ",
-			(udma_control & 0x04) ? "yes" : "no ",
-			(udma_control & 0x08) ? "yes" : "no " );
-	p += sprintf(p, "UDMA mode:      %c                %c "
-			"              %c                 %c\n",
-			(udma_control & 0x01) ?
-			((udma_mode & 0x07) + 48) : 'X',
-			(udma_control & 0x02) ?
-			(((udma_mode >> 4) & 0x07) + 48) : 'X',
-			(udma_control & 0x04) ?
-			(((udma_mode >> 8) & 0x07) + 48) : 'X',
-			(udma_control & 0x08) ?
-			(((udma_mode >> 12) & 0x07) + 48) : 'X');
-	p += sprintf(p, "MDMA mode:      %c                %c "
-			"              %c                 %c\n",
-			(save_mdma_mode[0] && (c0 & 0x20)) ?
-			((save_mdma_mode[0] & 0xf) + 48) : 'X',
-			(save_mdma_mode[1] && (c0 & 0x40)) ?
-			((save_mdma_mode[1] & 0xf) + 48) : 'X',
-			(save_mdma_mode[2] && (c1 & 0x20)) ?
-			((save_mdma_mode[2] & 0xf) + 48) : 'X',
-			(save_mdma_mode[3] && (c1 & 0x40)) ?
-			((save_mdma_mode[3] & 0xf) + 48) : 'X');
-	p += sprintf(p, "PIO mode:       %c                %c "
-			"              %c                 %c\n",
-			(c0 & 0x20) ? 'X' : ((pio_mode & 0x07) + 48),
-			(c0 & 0x40) ? 'X' : (((pio_mode >> 4) & 0x07) + 48),
-			(c1 & 0x20) ? 'X' : (((pio_mode >> 8) & 0x07) + 48),
-			(c1 & 0x40) ? 'X' : (((pio_mode >> 12) & 0x07) + 48));
-
-	return p - buffer;	/* => must be less than 4k! */
-}
-#endif  /* defined(DISPLAY_ATIIXP_TIMINGS) && defined(CONFIG_PROC_FS) */
-
 /**
  *	atiixp_ratemask		-	compute rate mask for ATIIXP IDE
  *	@drive: IDE drive to compute for
@@ -357,36 +261,16 @@
 	drive->init_speed = 0;
 
 	if ((id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				if ((id->field_valid & 2) &&
-				    (!atiixp_config_drive_for_dma(drive)))
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!atiixp_config_drive_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!atiixp_config_drive_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (atiixp_config_drive_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		tspeed = ide_get_best_pio_mode(drive, 255, 5, NULL);
 		speed = atiixp_dma_2_pio(XFER_PIO_0 + tspeed) + XFER_PIO_0;
 		hwif->speedproc(drive, speed);
@@ -397,27 +281,6 @@
 }
 
 /**
- *	init_chipset_atiixp	-	set up the ATIIXP chipset
- *	@dev: PCI device to set up
- *	@name: Name of the device
- *
- *	Initialize the PCI device as required. For the ATIIXP this turns
- *	out to be nice and simple
- */
-
-static unsigned int __devinit init_chipset_atiixp(struct pci_dev *dev, const char *name)
-{
-#if defined(DISPLAY_ATIIXP_TIMINGS) && defined(CONFIG_PROC_FS)
-	if (!atiixp_proc) {
-		atiixp_proc = 1;
-		bmide_dev = dev;
-		ide_pci_create_host_proc("atiixp", atiixp_get_info);
-	}
-#endif /* DISPLAY_ATIIXP_TIMINGS && CONFIG_PROC_FS */
-	return 0;
-}
-
-/**
  *	init_hwif_atiixp		-	fill in the hwif for the ATIIXP
  *	@hwif: IDE interface
  *
@@ -459,7 +322,6 @@
 static ide_pci_device_t atiixp_pci_info[] __devinitdata = {
 	{	/* 0 */
 		.name		= "ATIIXP",
-		.init_chipset	= init_chipset_atiixp,
 		.init_hwif	= init_hwif_atiixp,
 		.channels	= 2,
 		.autodma	= AUTODMA,
@@ -479,12 +341,13 @@
 
 static int __devinit atiixp_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &atiixp_pci_info[id->driver_data]);
-	return 0;
+	return ide_setup_pci_device(dev, &atiixp_pci_info[id->driver_data]);
 }
 
 static struct pci_device_id atiixp_pci_tbl[] = {
-	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP200_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP300_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP400_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, atiixp_pci_tbl);
diff -Naur linuxppc-2.6.9/drivers/ide/pci/cmd64x.c linuxppc-2.6.9-dream/drivers/ide/pci/cmd64x.c
--- linuxppc-2.6.9/drivers/ide/pci/cmd64x.c	2004-10-18 23:55:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/cmd64x.c	2005-06-20 10:46:11.000000000 +0200
@@ -25,7 +25,56 @@
 
 #include <asm/io.h>
 
-#include "cmd64x.h"
+#define DISPLAY_CMD64X_TIMINGS
+
+#define CMD_DEBUG 0
+
+#if CMD_DEBUG
+#define cmdprintk(x...)	printk(x)
+#else
+#define cmdprintk(x...)
+#endif
+
+/*
+ * CMD64x specific registers definition.
+ */
+#define CFR		0x50
+#define   CFR_INTR_CH0		0x02
+#define CNTRL		0x51
+#define	  CNTRL_DIS_RA0		0x40
+#define   CNTRL_DIS_RA1		0x80
+#define	  CNTRL_ENA_2ND		0x08
+
+#define	CMDTIM		0x52
+#define	ARTTIM0		0x53
+#define	DRWTIM0		0x54
+#define ARTTIM1 	0x55
+#define DRWTIM1		0x56
+#define ARTTIM23	0x57
+#define   ARTTIM23_DIS_RA2	0x04
+#define   ARTTIM23_DIS_RA3	0x08
+#define   ARTTIM23_INTR_CH1	0x10
+#define ARTTIM2		0x57
+#define ARTTIM3		0x57
+#define DRWTIM23	0x58
+#define DRWTIM2		0x58
+#define BRST		0x59
+#define DRWTIM3		0x5b
+
+#define BMIDECR0	0x70
+#define MRDMODE		0x71
+#define   MRDMODE_INTR_CH0	0x04
+#define   MRDMODE_INTR_CH1	0x08
+#define   MRDMODE_BLK_CH0	0x10
+#define   MRDMODE_BLK_CH1	0x20
+#define BMIDESR0	0x72
+#define UDIDETCR0	0x73
+#define DTPR0		0x74
+#define BMIDECR1	0x78
+#define BMIDECSR	0x79
+#define BMIDESR1	0x7A
+#define UDIDETCR1	0x7B
+#define DTPR1		0x7C
 
 #if defined(DISPLAY_CMD64X_TIMINGS) && defined(CONFIG_PROC_FS)
 #include <linux/stat.h>
@@ -441,36 +490,16 @@
 	struct hd_driveid *id	= drive->id;
 
 	if ((id != NULL) && ((id->capability & 1) != 0) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if ((id->field_valid & 4) && cmd64x_ratemask(drive)) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		config_chipset_for_pio(drive, 1);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -727,10 +756,42 @@
 	hwif->drives[1].autodma = hwif->autodma;
 }
 
+static ide_pci_device_t cmd64x_chipsets[] __devinitdata = {
+	{	/* 0 */
+		.name		= "CMD643",
+		.init_chipset	= init_chipset_cmd64x,
+		.init_hwif	= init_hwif_cmd64x,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 1 */
+		.name		= "CMD646",
+		.init_chipset	= init_chipset_cmd64x,
+		.init_hwif	= init_hwif_cmd64x,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x00,0x00,0x00}, {0x51,0x80,0x80}},
+		.bootable	= ON_BOARD,
+	},{	/* 2 */
+		.name		= "CMD648",
+		.init_chipset	= init_chipset_cmd64x,
+		.init_hwif	= init_hwif_cmd64x,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 3 */
+		.name		= "CMD649",
+		.init_chipset	= init_chipset_cmd64x,
+		.init_hwif	= init_hwif_cmd64x,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= ON_BOARD,
+	}
+};
+
 static int __devinit cmd64x_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &cmd64x_chipsets[id->driver_data]);
-	return 0;
+	return ide_setup_pci_device(dev, &cmd64x_chipsets[id->driver_data]);
 }
 
 static struct pci_device_id cmd64x_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/cmd64x.h linuxppc-2.6.9-dream/drivers/ide/pci/cmd64x.h
--- linuxppc-2.6.9/drivers/ide/pci/cmd64x.h	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/cmd64x.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,95 +0,0 @@
-#ifndef CMD64X_H
-#define CMD64X_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-#define DISPLAY_CMD64X_TIMINGS
-
-#define CMD_DEBUG 0
-
-#if CMD_DEBUG
-#define cmdprintk(x...)	printk(x)
-#else
-#define cmdprintk(x...)
-#endif
-
-/*
- * CMD64x specific registers definition.
- */
-#define CFR		0x50
-#define   CFR_INTR_CH0		0x02
-#define CNTRL		0x51
-#define	  CNTRL_DIS_RA0		0x40
-#define   CNTRL_DIS_RA1		0x80
-#define	  CNTRL_ENA_2ND		0x08
-
-#define	CMDTIM		0x52
-#define	ARTTIM0		0x53
-#define	DRWTIM0		0x54
-#define ARTTIM1 	0x55
-#define DRWTIM1		0x56
-#define ARTTIM23	0x57
-#define   ARTTIM23_DIS_RA2	0x04
-#define   ARTTIM23_DIS_RA3	0x08
-#define   ARTTIM23_INTR_CH1	0x10
-#define ARTTIM2		0x57
-#define ARTTIM3		0x57
-#define DRWTIM23	0x58
-#define DRWTIM2		0x58
-#define BRST		0x59
-#define DRWTIM3		0x5b
-
-#define BMIDECR0	0x70
-#define MRDMODE		0x71
-#define   MRDMODE_INTR_CH0	0x04
-#define   MRDMODE_INTR_CH1	0x08
-#define   MRDMODE_BLK_CH0	0x10
-#define   MRDMODE_BLK_CH1	0x20
-#define BMIDESR0	0x72
-#define UDIDETCR0	0x73
-#define DTPR0		0x74
-#define BMIDECR1	0x78
-#define BMIDECSR	0x79
-#define BMIDESR1	0x7A
-#define UDIDETCR1	0x7B
-#define DTPR1		0x7C
-
-static unsigned int init_chipset_cmd64x(struct pci_dev *, const char *);
-static void init_hwif_cmd64x(ide_hwif_t *);
-
-static ide_pci_device_t cmd64x_chipsets[] __devinitdata = {
-	{	/* 0 */
-		.name		= "CMD643",
-		.init_chipset	= init_chipset_cmd64x,
-		.init_hwif	= init_hwif_cmd64x,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= ON_BOARD,
-	},{	/* 1 */
-		.name		= "CMD646",
-		.init_chipset	= init_chipset_cmd64x,
-		.init_hwif	= init_hwif_cmd64x,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.enablebits	= {{0x00,0x00,0x00}, {0x51,0x80,0x80}},
-		.bootable	= ON_BOARD,
-	},{	/* 2 */
-		.name		= "CMD648",
-		.init_chipset	= init_chipset_cmd64x,
-		.init_hwif	= init_hwif_cmd64x,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= ON_BOARD,
-	},{
-		.name		= "CMD649",
-		.init_chipset	= init_chipset_cmd64x,
-		.init_hwif	= init_hwif_cmd64x,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= ON_BOARD,
-	}
-};
-
-#endif /* CMD64X_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/cs5520.c linuxppc-2.6.9-dream/drivers/ide/pci/cs5520.c
--- linuxppc-2.6.9/drivers/ide/pci/cs5520.c	2004-10-18 23:53:12.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/cs5520.c	2005-06-20 10:46:11.000000000 +0200
@@ -51,57 +51,6 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-#define DISPLAY_CS5520_TIMINGS
-
-#if defined(DISPLAY_CS5520_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 cs5520_proc = 0;
-static struct pci_dev *bmide_dev;
-
-static int cs5520_get_info(char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	unsigned long bmiba = pci_resource_start(bmide_dev, 2);
-	int len;
-	u8 c0 = 0, c1 = 0;
-	u16 reg16;
-	u32 reg32;
-
-	/*
-	 * at that point bibma+0x2 et bibma+0xa are byte registers
-	 * to investigate:
-	 */
-	c0 = inb(bmiba + 0x02);
-	c1 = inb(bmiba + 0x0a);
-	
-	p += sprintf(p, "\nCyrix CS55x0 IDE\n");
-	p += sprintf(p, "--------------- Primary Channel "
-			"---------------- Secondary Channel "
-			"-------------\n");
-	p += sprintf(p, "                %sabled "
-			"                        %sabled\n",
-			(c0&0x80) ? "dis" : " en",
-			(c1&0x80) ? "dis" : " en");
-			
-	p += sprintf(p, "\n\nTimings: \n");
-	
-	pci_read_config_word(bmide_dev, 0x62, &reg16);
-	p += sprintf(p, "8bit CAT/CRT   : %04x\n", reg16);
-	pci_read_config_dword(bmide_dev, 0x64, &reg32);
-	p += sprintf(p, "16bit Primary  : %08x\n", reg32);
-	pci_read_config_dword(bmide_dev, 0x68, &reg32);
-	p += sprintf(p, "16bit Secondary: %08x\n", reg32);
-	
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-
-#endif
-
 struct pio_clocks
 {
 	int address;
@@ -109,7 +58,7 @@
 	int recovery;
 };
 
-struct pio_clocks cs5520_pio_clocks[]={
+static struct pio_clocks cs5520_pio_clocks[]={
 	{3, 6, 11},
 	{2, 5, 6},
 	{1, 4, 3},
@@ -144,12 +93,14 @@
 	printk("PIO clocking = %d\n", pio);
 	
 	/* FIXME: if DMA = 1 do we need to set the DMA bit here ? */
-	
-	/* 8bit command timing for channel */
+
+	/* 8bit CAT/CRT - 8bit command timing for channel */
 	pci_write_config_byte(pdev, 0x62 + controller, 
 		(cs5520_pio_clocks[pio].recovery << 4) |
 		(cs5520_pio_clocks[pio].assert));
-		
+
+	/* 0x64 - 16bit Primary, 0x68 - 16bit Secondary */
+
 	/* FIXME: should these use address ? */
 	/* Data read timing */
 	pci_write_config_byte(pdev, 0x64 + 4*controller + (drive->dn&1),
@@ -188,19 +139,6 @@
 	/* Then tell the core to use DMA operations */
 	return hwif->ide_dma_on(drive);
 }
-	
-	
-static unsigned int __devinit init_chipset_cs5520(struct pci_dev *dev, const char *name)
-{
-#if defined(DISPLAY_CS5520_TIMINGS) && defined(CONFIG_PROC_FS)
-	if (!cs5520_proc) {
-		cs5520_proc = 1;
-		bmide_dev = dev;
-		ide_pci_create_host_proc("cs5520", cs5520_get_info);
-	}
-#endif /* DISPLAY_CS5520_TIMINGS && CONFIG_PROC_FS */
-	return 0;
-}
 
 /*
  *	We provide a callback for our nonstandard DMA location
@@ -255,7 +193,6 @@
 #define DECLARE_CS_DEV(name_str)				\
 	{							\
 		.name		= name_str,			\
-		.init_chipset	= init_chipset_cs5520,		\
 		.init_setup_dma = cs5520_init_setup_dma,	\
 		.init_hwif	= init_hwif_cs5520,		\
 		.channels	= 2,				\
@@ -294,7 +231,6 @@
 		printk(KERN_WARNING "cs5520: No suitable DMA available.\n");
 		return -ENODEV;
 	}
-	init_chipset_cs5520(dev, d->name);
 
 	index.all = 0xf0f0;
 
@@ -303,10 +239,8 @@
 	 *	do all the device setup for us
 	 */
 
-	ide_pci_setup_ports(dev, d, 1, 14, &index);
+	ide_pci_setup_ports(dev, d, 14, &index);
 
-	printk("Index.b %d %d\n", index.b.low, index.b.high);
-	mdelay(2000);
 	if((index.b.low & 0xf0) != 0xf0)
 		probe_hwif_init(&ide_hwifs[index.b.low]);
 	if((index.b.high & 0xf0) != 0xf0)
diff -Naur linuxppc-2.6.9/drivers/ide/pci/cs5530.c linuxppc-2.6.9-dream/drivers/ide/pci/cs5530.c
--- linuxppc-2.6.9/drivers/ide/pci/cs5530.c	2004-10-18 23:53:50.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/cs5530.c	2005-06-20 10:46:11.000000000 +0200
@@ -31,56 +31,6 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-#define DISPLAY_CS5530_TIMINGS
-
-#if defined(DISPLAY_CS5530_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 cs5530_proc = 0;
-
-static struct pci_dev *bmide_dev;
-
-static int cs5530_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	unsigned long bibma = pci_resource_start(bmide_dev, 4);
-	u8  c0 = 0, c1 = 0;
-
-	/*
-	 * at that point bibma+0x2 et bibma+0xa are byte registers
-	 * to investigate:
-	 */
-
-	c0 = inb_p((u16)bibma + 0x02);
-	c1 = inb_p((u16)bibma + 0x0a);
-
-	p += sprintf(p, "\n                                "
-			"Cyrix 5530 Chipset.\n");
-	p += sprintf(p, "--------------- Primary Channel "
-			"---------------- Secondary Channel "
-			"-------------\n");
-	p += sprintf(p, "                %sabled "
-			"                        %sabled\n",
-			(c0&0x80) ? "dis" : " en",
-			(c1&0x80) ? "dis" : " en");
-	p += sprintf(p, "--------------- drive0 --------- drive1 "
-			"-------- drive0 ---------- drive1 ------\n");
-	p += sprintf(p, "DMA enabled:    %s              %s "
-			"            %s               %s\n",
-			(c0&0x20) ? "yes" : "no ",
-			(c0&0x40) ? "yes" : "no ",
-			(c1&0x20) ? "yes" : "no ",
-			(c1&0x40) ? "yes" : "no " );
-
-	p += sprintf(p, "UDMA\n");
-	p += sprintf(p, "DMA\n");
-	p += sprintf(p, "PIO\n");
-
-	return p-buffer;
-}
-#endif /* DISPLAY_CS5530_TIMINGS && CONFIG_PROC_FS */
-
 /**
  *	cs5530_xfer_set_mode	-	set a new transfer mode at the drive
  *	@drive: drive to tune
@@ -272,14 +222,6 @@
 	struct pci_dev *master_0 = NULL, *cs5530_0 = NULL;
 	unsigned long flags;
 
-#if defined(DISPLAY_CS5530_TIMINGS) && defined(CONFIG_PROC_FS)
-	if (!cs5530_proc) {
-		cs5530_proc = 1;
-		bmide_dev = dev;
-		ide_pci_create_host_proc("cs5530", cs5530_get_info);
-	}
-#endif /* DISPLAY_CS5530_TIMINGS && CONFIG_PROC_FS */
-
 	dev = NULL;
 	while ((dev = pci_find_device(PCI_VENDOR_ID_CYRIX, PCI_ANY_ID, dev)) != NULL) {
 		switch (dev->device) {
@@ -411,13 +353,11 @@
 	.channels	= 2,
 	.autodma	= AUTODMA,
 	.bootable	= ON_BOARD,
-	.flags		= IDEPCI_FLAG_FORCE_MASTER,
 };
 
 static int __devinit cs5530_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &cs5530_chipset);
-	return 0;
+	return ide_setup_pci_device(dev, &cs5530_chipset);
 }
 
 static struct pci_device_id cs5530_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/cy82c693.c linuxppc-2.6.9-dream/drivers/ide/pci/cy82c693.c
--- linuxppc-2.6.9/drivers/ide/pci/cy82c693.c	2004-10-18 23:53:23.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/cy82c693.c	2005-06-20 10:46:11.000000000 +0200
@@ -54,7 +54,64 @@
 
 #include <asm/io.h>
 
-#include "cy82c693.h"
+/* the current version */
+#define CY82_VERSION	"CY82C693U driver v0.34 99-13-12 Andreas S. Krebs (akrebs@altavista.net)"
+
+/*
+ *	The following are used to debug the driver.
+ */
+#define CY82C693_DEBUG_LOGS	0
+#define CY82C693_DEBUG_INFO	0
+
+/* define CY82C693_SETDMA_CLOCK to set DMA Controller Clock Speed to ATCLK */
+#undef CY82C693_SETDMA_CLOCK
+
+/*
+ *	NOTE: the value for busmaster timeout is tricky and I got it by
+ *	trial and error!  By using a to low value will cause DMA timeouts
+ *	and drop IDE performance, and by using a to high value will cause
+ *	audio playback to scatter.
+ *	If you know a better value or how to calc it, please let me know.
+ */
+
+/* twice the value written in cy82c693ub datasheet */
+#define BUSMASTER_TIMEOUT	0x50
+/*
+ * the value above was tested on my machine and it seems to work okay
+ */
+
+/* here are the offset definitions for the registers */
+#define CY82_IDE_CMDREG		0x04
+#define CY82_IDE_ADDRSETUP	0x48
+#define CY82_IDE_MASTER_IOR	0x4C
+#define CY82_IDE_MASTER_IOW	0x4D
+#define CY82_IDE_SLAVE_IOR	0x4E
+#define CY82_IDE_SLAVE_IOW	0x4F
+#define CY82_IDE_MASTER_8BIT	0x50
+#define CY82_IDE_SLAVE_8BIT	0x51
+
+#define CY82_INDEX_PORT		0x22
+#define CY82_DATA_PORT		0x23
+
+#define CY82_INDEX_CTRLREG1	0x01
+#define CY82_INDEX_CHANNEL0	0x30
+#define CY82_INDEX_CHANNEL1	0x31
+#define CY82_INDEX_TIMEOUT	0x32
+
+/* the max PIO mode - from datasheet */
+#define CY82C693_MAX_PIO	4
+
+/* the min and max PCI bus speed in MHz - from datasheet */
+#define CY82C963_MIN_BUS_SPEED	25
+#define CY82C963_MAX_BUS_SPEED	33
+
+/* the struct for the PIO mode timings */
+typedef struct pio_clocks_s {
+	u8	address_time;	/* Address setup (clocks) */
+	u8	time_16r;	/* clocks for 16bit IOR (0xF0=Active/data, 0x0F=Recovery) */
+	u8	time_16w;	/* clocks for 16bit IOW (0xF0=Active/data, 0x0F=Recovery) */
+	u8	time_8;		/* clocks for 8bit (0xF0=Active/data, 0x0F=Recovery) */
+} pio_clocks_t;
 
 /*
  * calc clocks using bus_speed
@@ -183,7 +240,7 @@
 /* 
  * used to set DMA mode for CY82C693 (single and multi modes)
  */
-int cy82c693_ide_dma_on (ide_drive_t *drive)
+static int cy82c693_ide_dma_on (ide_drive_t *drive)
 {
 	struct hd_driveid *id = drive->id;
 
@@ -422,19 +479,32 @@
 	}
 }
 
+static ide_pci_device_t cy82c693_chipsets[] __devinitdata = {
+	{	/* 0 */
+		.name		= "CY82C693",
+		.init_chipset	= init_chipset_cy82c693,
+		.init_iops	= init_iops_cy82c693,
+		.init_hwif	= init_hwif_cy82c693,
+		.channels	= 1,
+		.autodma	= AUTODMA,
+		.bootable	= ON_BOARD,
+	}
+};
+
 static int __devinit cy82c693_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	ide_pci_device_t *d = &cy82c693_chipsets[id->driver_data];
 	struct pci_dev *dev2;
+	int ret = -ENODEV;
 
 	/* CY82C693 is more than only a IDE controller.
 	   Function 1 is primary IDE channel, function 2 - secondary. */
         if ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE &&
 	    PCI_FUNC(dev->devfn) == 1) {
 		dev2 = pci_find_slot(dev->bus->number, dev->devfn + 1);
-		ide_setup_pci_devices(dev, dev2, d);
+		ret = ide_setup_pci_devices(dev, dev2, d);
 	}
-	return 0;
+	return ret;
 }
 
 static struct pci_device_id cy82c693_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/cy82c693.h linuxppc-2.6.9-dream/drivers/ide/pci/cy82c693.h
--- linuxppc-2.6.9/drivers/ide/pci/cy82c693.h	2004-10-18 23:53:45.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/cy82c693.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,83 +0,0 @@
-#ifndef CY82C693_H
-#define CY82C693_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-/* the current version */
-#define CY82_VERSION	"CY82C693U driver v0.34 99-13-12 Andreas S. Krebs (akrebs@altavista.net)"
-
-/*
- *	The following are used to debug the driver.
- */
-#define	CY82C693_DEBUG_LOGS	0
-#define	CY82C693_DEBUG_INFO	0
-
-/* define CY82C693_SETDMA_CLOCK to set DMA Controller Clock Speed to ATCLK */
-#undef CY82C693_SETDMA_CLOCK
-
-/*
- *	NOTE: the value for busmaster timeout is tricky and I got it by
- *	 trial and error!  By using a to low value will cause DMA timeouts
- *	 and drop IDE performance, and by using a to high value will cause
- *	 audio playback to scatter.
- *	 If you know a better value or how to calc it, please let me know.
- */
-
-/* twice the value written in cy82c693ub datasheet */
-#define BUSMASTER_TIMEOUT	0x50
-/*
- * the value above was tested on my machine and it seems to work okay
- */
-
-/* here are the offset definitions for the registers */
-#define CY82_IDE_CMDREG		0x04
-#define CY82_IDE_ADDRSETUP	0x48
-#define CY82_IDE_MASTER_IOR	0x4C	
-#define CY82_IDE_MASTER_IOW	0x4D	
-#define CY82_IDE_SLAVE_IOR	0x4E	
-#define CY82_IDE_SLAVE_IOW	0x4F
-#define CY82_IDE_MASTER_8BIT	0x50	
-#define CY82_IDE_SLAVE_8BIT	0x51	
-
-#define CY82_INDEX_PORT		0x22
-#define CY82_DATA_PORT		0x23
-
-#define CY82_INDEX_CTRLREG1	0x01
-#define CY82_INDEX_CHANNEL0	0x30
-#define CY82_INDEX_CHANNEL1	0x31
-#define CY82_INDEX_TIMEOUT	0x32
-
-/* the max PIO mode - from datasheet */
-#define CY82C693_MAX_PIO	4
-
-/* the min and max PCI bus speed in MHz - from datasheet */
-#define CY82C963_MIN_BUS_SPEED	25
-#define CY82C963_MAX_BUS_SPEED	33
-
-/* the struct for the PIO mode timings */
-typedef struct pio_clocks_s {
-        u8	address_time;	/* Address setup (clocks) */
-	u8	time_16r;	/* clocks for 16bit IOR (0xF0=Active/data, 0x0F=Recovery) */
-	u8	time_16w;	/* clocks for 16bit IOW (0xF0=Active/data, 0x0F=Recovery) */
-	u8	time_8;		/* clocks for 8bit (0xF0=Active/data, 0x0F=Recovery) */
-} pio_clocks_t;
-
-static unsigned int init_chipset_cy82c693(struct pci_dev *, const char *);
-static void init_hwif_cy82c693(ide_hwif_t *);
-static void init_iops_cy82c693(ide_hwif_t *);
-
-static ide_pci_device_t cy82c693_chipsets[] __devinitdata = {
-	{	/* 0 */
-		.name		= "CY82C693",
-		.init_chipset	= init_chipset_cy82c693,
-		.init_iops	= init_iops_cy82c693,
-		.init_hwif	= init_hwif_cy82c693,
-		.channels	= 1,
-		.autodma	= AUTODMA,
-		.bootable	= ON_BOARD,
-	}
-};
-
-#endif /* CY82C693_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/generic.c linuxppc-2.6.9-dream/drivers/ide/pci/generic.c
--- linuxppc-2.6.9/drivers/ide/pci/generic.c	2004-10-18 23:54:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/generic.c	2005-06-20 10:46:11.000000000 +0200
@@ -39,14 +39,7 @@
 
 #include <asm/io.h>
 
-#include "generic.h"
-
-static unsigned int __init init_chipset_generic (struct pci_dev *dev, const char *name)
-{
-	return 0;
-}
-
-static void __init init_hwif_generic (ide_hwif_t *hwif)
+static void __devinit init_hwif_generic (ide_hwif_t *hwif)
 {
 	switch(hwif->pci_dev->device) {
 		case PCI_DEVICE_ID_UMC_UM8673F:
@@ -83,6 +76,89 @@
 	return 0;
 #endif	
 
+static ide_pci_device_t generic_chipsets[] __devinitdata = {
+	{	/* 0 */
+		.name		= "NS87410",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x43,0x08,0x08}, {0x47,0x08,0x08}},
+		.bootable	= ON_BOARD,
+        },{	/* 1 */
+		.name		= "SAMURAI",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 2 */
+		.name		= "HT6565",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 3 */
+		.name		= "UM8673F",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= NODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 4 */
+		.name		= "UM8886A",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= NODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 5 */
+		.name		= "UM8886BF",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= NODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 6 */
+		.name		= "HINT_IDE",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 7 */
+		.name		= "VIA_IDE",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= NOAUTODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 8 */
+		.name		= "OPTI621V",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= NOAUTODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 9 */
+		.name		= "VIA8237SATA",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+	},{	/* 10 */
+		.name 		= "Piccolo0102",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= NOAUTODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 11 */
+		.name 		= "Piccolo0103",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= NOAUTODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 12 */
+		.name 		= "Piccolo0105",
+		.init_hwif	= init_hwif_generic,
+		.channels	= 2,
+		.autodma	= NOAUTODMA,
+		.bootable	= ON_BOARD,
+	}
+};
+
 /**
  *	generic_init_one	-	called when a PIIX is found
  *	@dev: the generic device
@@ -96,25 +172,26 @@
 {
 	ide_pci_device_t *d = &generic_chipsets[id->driver_data];
 	u16 command;
+	int ret = -ENODEV;
 
 	if (dev->vendor == PCI_VENDOR_ID_UMC &&
 	    dev->device == PCI_DEVICE_ID_UMC_UM8886A &&
 	    (!(PCI_FUNC(dev->devfn) & 1)))
-		return 1; /* UM8886A/BF pair */
+		goto out; /* UM8886A/BF pair */
 
 	if (dev->vendor == PCI_VENDOR_ID_OPTI &&
 	    dev->device == PCI_DEVICE_ID_OPTI_82C558 &&
 	    (!(PCI_FUNC(dev->devfn) & 1)))
-		return 1;
+		goto out;
 
 	pci_read_config_word(dev, PCI_COMMAND, &command);
-	if(!(command & PCI_COMMAND_IO))
-	{
+	if (!(command & PCI_COMMAND_IO)) {
 		printk(KERN_INFO "Skipping disabled %s IDE controller.\n", d->name);
-		return 1; 
+		goto out;
 	}
-	ide_setup_pci_device(dev, d);
-	return 0;
+	ret = ide_setup_pci_device(dev, d);
+out:
+	return ret;
 }
 
 static struct pci_device_id generic_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/generic.h linuxppc-2.6.9-dream/drivers/ide/pci/generic.h
--- linuxppc-2.6.9/drivers/ide/pci/generic.h	2004-10-18 23:53:22.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/generic.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,120 +0,0 @@
-#ifndef IDE_GENERIC_H
-#define IDE_GENERIC_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-static unsigned int init_chipset_generic(struct pci_dev *, const char *);
-static void init_hwif_generic(ide_hwif_t *);
-
-static ide_pci_device_t generic_chipsets[] __devinitdata = {
-	{	/* 0 */
-		.name		= "NS87410",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.enablebits	= {{0x43,0x08,0x08}, {0x47,0x08,0x08}},
-		.bootable	= ON_BOARD,
-        },{	/* 1 */
-		.name		= "SAMURAI",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= ON_BOARD,
-	},{	/* 2 */
-		.name		= "HT6565",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= ON_BOARD,
-	},{	/* 3 */
-		.name		= "UM8673F",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= NODMA,
-		.bootable	= ON_BOARD,
-	},{	/* 4 */
-		.name		= "UM8886A",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= NODMA,
-		.bootable	= ON_BOARD,
-	},{	/* 5 */
-		.name		= "UM8886BF",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= NODMA,
-		.bootable	= ON_BOARD,
-	},{	/* 6 */
-		.name		= "HINT_IDE",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= ON_BOARD,
-	},{	/* 7 */
-		.name		= "VIA_IDE",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= NOAUTODMA,
-		.bootable	= ON_BOARD,
-	},{	/* 8 */
-		.name		= "OPTI621V",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= NOAUTODMA,
-		.bootable	= ON_BOARD,
-	},{	/* 9 */
-		.name		= "VIA8237SATA",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-	},{ /* 10 */
-		.name 		= "Piccolo0102",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= NOAUTODMA,
-		.bootable	= ON_BOARD,
-	},{ /* 11 */
-		.name 		= "Piccolo0103",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= NOAUTODMA,
-		.bootable	= ON_BOARD,
-	},{ /* 12 */
-		.name 		= "Piccolo0105",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= NOAUTODMA,
-		.bootable	= ON_BOARD,
-	}
-};
-
-#if 0
-static ide_pci_device_t unknown_chipset[] __devinitdata = {
-	{	/* 0 */
-		.name		= "PCI_IDE",
-		.init_chipset	= init_chipset_generic,
-		.init_hwif	= init_hwif_generic,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= ON_BOARD,
-	}
-};
-#endif
-
-#endif /* IDE_GENERIC_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/hpt34x.c linuxppc-2.6.9-dream/drivers/ide/pci/hpt34x.c
--- linuxppc-2.6.9/drivers/ide/pci/hpt34x.c	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/hpt34x.c	2005-06-20 10:46:11.000000000 +0200
@@ -42,7 +42,7 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-#include "hpt34x.h"
+#define HPT343_DEBUG_DRIVE_INFO		0
 
 static u8 hpt34x_ratemask (ide_drive_t *drive)
 {
@@ -69,7 +69,8 @@
 	u32 reg1= 0, tmp1 = 0, reg2 = 0, tmp2 = 0;
 	u8			hi_speed, lo_speed;
 
-	SPLIT_BYTE(speed, hi_speed, lo_speed);
+	hi_speed = speed >> 4;
+	lo_speed = speed & 0x0f;
 
 	if (hi_speed & 7) {
 		hi_speed = (hi_speed & 4) ? 0x01 : 0x10;
@@ -130,40 +131,20 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
-		}
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
 #ifndef CONFIG_HPT34X_AUTODMA
-		return hwif->ide_dma_off_quietly(drive);
+				return hwif->ide_dma_off_quietly(drive);
 #else
-		return hwif->ide_dma_on(drive);
+				return hwif->ide_dma_on(drive);
 #endif
+		}
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		hpt34x_tune_drive(drive, 255);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -249,9 +230,19 @@
 	hwif->drives[1].autodma = hwif->autodma;
 }
 
+static ide_pci_device_t hpt34x_chipset __devinitdata = {
+	.name		= "HPT34X",
+	.init_chipset	= init_chipset_hpt34x,
+	.init_hwif	= init_hwif_hpt34x,
+	.channels	= 2,
+	.autodma	= NOAUTODMA,
+	.bootable	= NEVER_BOARD,
+	.extra		= 16
+};
+
 static int __devinit hpt34x_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_pci_device_t *d = &hpt34x_chipsets[id->driver_data];
+	ide_pci_device_t *d = &hpt34x_chipset;
 	static char *chipset_names[] = {"HPT343", "HPT345"};
 	u16 pcicmd = 0;
 
@@ -260,8 +251,7 @@
 	d->name = chipset_names[(pcicmd & PCI_COMMAND_MEMORY) ? 1 : 0];
 	d->bootable = (pcicmd & PCI_COMMAND_MEMORY) ? OFF_BOARD : NEVER_BOARD;
 
-	ide_setup_pci_device(dev, d);
-	return 0;
+	return ide_setup_pci_device(dev, d);
 }
 
 static struct pci_device_id hpt34x_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/hpt34x.h linuxppc-2.6.9-dream/drivers/ide/pci/hpt34x.h
--- linuxppc-2.6.9/drivers/ide/pci/hpt34x.h	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/hpt34x.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
-#ifndef HPT34X_H
-#define HPT34X_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-#define HPT343_DEBUG_DRIVE_INFO		0
-
-#ifndef SPLIT_BYTE
-#define SPLIT_BYTE(B,H,L)	((H)=(B>>4), (L)=(B-((B>>4)<<4)))
-#endif
-
-static unsigned int init_chipset_hpt34x(struct pci_dev *, const char *);
-static void init_hwif_hpt34x(ide_hwif_t *);
-
-static ide_pci_device_t hpt34x_chipsets[] __devinitdata = {
-	{	/* 0 */
-		.name		= "HPT34X",
-		.init_chipset	= init_chipset_hpt34x,
-		.init_hwif	= init_hwif_hpt34x,
-		.channels	= 2,
-		.autodma	= NOAUTODMA,
-		.bootable	= NEVER_BOARD,
-		.extra		= 16
-	}
-};
-
-#endif /* HPT34X_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/hpt366.c linuxppc-2.6.9-dream/drivers/ide/pci/hpt366.c
--- linuxppc-2.6.9/drivers/ide/pci/hpt366.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/hpt366.c	2005-06-20 10:46:11.000000000 +0200
@@ -70,51 +70,383 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-#include "hpt366.h"
+/* various tuning parameters */
+#define HPT_RESET_STATE_ENGINE
+#undef HPT_DELAY_INTERRUPT
+#undef HPT_SERIALIZE_IO
+
+static const char *quirk_drives[] = {
+	"QUANTUM FIREBALLlct08 08",
+	"QUANTUM FIREBALLP KA6.4",
+	"QUANTUM FIREBALLP LM20.4",
+	"QUANTUM FIREBALLP LM20.5",
+	NULL
+};
+
+static const char *bad_ata100_5[] = {
+	"IBM-DTLA-307075",
+	"IBM-DTLA-307060",
+	"IBM-DTLA-307045",
+	"IBM-DTLA-307030",
+	"IBM-DTLA-307020",
+	"IBM-DTLA-307015",
+	"IBM-DTLA-305040",
+	"IBM-DTLA-305030",
+	"IBM-DTLA-305020",
+	"IC35L010AVER07-0",
+	"IC35L020AVER07-0",
+	"IC35L030AVER07-0",
+	"IC35L040AVER07-0",
+	"IC35L060AVER07-0",
+	"WDC AC310200R",
+	NULL
+};
+
+static const char *bad_ata66_4[] = {
+	"IBM-DTLA-307075",
+	"IBM-DTLA-307060",
+	"IBM-DTLA-307045",
+	"IBM-DTLA-307030",
+	"IBM-DTLA-307020",
+	"IBM-DTLA-307015",
+	"IBM-DTLA-305040",
+	"IBM-DTLA-305030",
+	"IBM-DTLA-305020",
+	"IC35L010AVER07-0",
+	"IC35L020AVER07-0",
+	"IC35L030AVER07-0",
+	"IC35L040AVER07-0",
+	"IC35L060AVER07-0",
+	"WDC AC310200R",
+	NULL
+};
+
+static const char *bad_ata66_3[] = {
+	"WDC AC310200R",
+	NULL
+};
+
+static const char *bad_ata33[] = {
+	"Maxtor 92720U8", "Maxtor 92040U6", "Maxtor 91360U4", "Maxtor 91020U3", "Maxtor 90845U3", "Maxtor 90650U2",
+	"Maxtor 91360D8", "Maxtor 91190D7", "Maxtor 91020D6", "Maxtor 90845D5", "Maxtor 90680D4", "Maxtor 90510D3", "Maxtor 90340D2",
+	"Maxtor 91152D8", "Maxtor 91008D7", "Maxtor 90845D6", "Maxtor 90840D6", "Maxtor 90720D5", "Maxtor 90648D5", "Maxtor 90576D4",
+	"Maxtor 90510D4",
+	"Maxtor 90432D3", "Maxtor 90288D2", "Maxtor 90256D2",
+	"Maxtor 91000D8", "Maxtor 90910D8", "Maxtor 90875D7", "Maxtor 90840D7", "Maxtor 90750D6", "Maxtor 90625D5", "Maxtor 90500D4",
+	"Maxtor 91728D8", "Maxtor 91512D7", "Maxtor 91303D6", "Maxtor 91080D5", "Maxtor 90845D4", "Maxtor 90680D4", "Maxtor 90648D3", "Maxtor 90432D2",
+	NULL
+};
+
+struct chipset_bus_clock_list_entry {
+	u8		xfer_speed;
+	unsigned int	chipset_settings;
+};
+
+/* key for bus clock timings
+ * bit
+ * 0:3    data_high_time. inactive time of DIOW_/DIOR_ for PIO and MW
+ *        DMA. cycles = value + 1
+ * 4:8    data_low_time. active time of DIOW_/DIOR_ for PIO and MW
+ *        DMA. cycles = value + 1
+ * 9:12   cmd_high_time. inactive time of DIOW_/DIOR_ during task file
+ *        register access.
+ * 13:17  cmd_low_time. active time of DIOW_/DIOR_ during task file
+ *        register access.
+ * 18:21  udma_cycle_time. clock freq and clock cycles for UDMA xfer.
+ *        during task file register access.
+ * 22:24  pre_high_time. time to initialize 1st cycle for PIO and MW DMA
+ *        xfer.
+ * 25:27  cmd_pre_high_time. time to initialize 1st PIO cycle for task
+ *        register access.
+ * 28     UDMA enable
+ * 29     DMA enable
+ * 30     PIO_MST enable. if set, the chip is in bus master mode during
+ *        PIO.
+ * 31     FIFO enable.
+ */
+static struct chipset_bus_clock_list_entry forty_base_hpt366[] = {
+	{	XFER_UDMA_4,	0x900fd943	},
+	{	XFER_UDMA_3,	0x900ad943	},
+	{	XFER_UDMA_2,	0x900bd943	},
+	{	XFER_UDMA_1,	0x9008d943	},
+	{	XFER_UDMA_0,	0x9008d943	},
+
+	{	XFER_MW_DMA_2,	0xa008d943	},
+	{	XFER_MW_DMA_1,	0xa010d955	},
+	{	XFER_MW_DMA_0,	0xa010d9fc	},
+
+	{	XFER_PIO_4,	0xc008d963	},
+	{	XFER_PIO_3,	0xc010d974	},
+	{	XFER_PIO_2,	0xc010d997	},
+	{	XFER_PIO_1,	0xc010d9c7	},
+	{	XFER_PIO_0,	0xc018d9d9	},
+	{	0,		0x0120d9d9	}
+};
+
+static struct chipset_bus_clock_list_entry thirty_three_base_hpt366[] = {
+	{	XFER_UDMA_4,	0x90c9a731	},
+	{	XFER_UDMA_3,	0x90cfa731	},
+	{	XFER_UDMA_2,	0x90caa731	},
+	{	XFER_UDMA_1,	0x90cba731	},
+	{	XFER_UDMA_0,	0x90c8a731	},
+
+	{	XFER_MW_DMA_2,	0xa0c8a731	},
+	{	XFER_MW_DMA_1,	0xa0c8a732	},	/* 0xa0c8a733 */
+	{	XFER_MW_DMA_0,	0xa0c8a797	},
+
+	{	XFER_PIO_4,	0xc0c8a731	},
+	{	XFER_PIO_3,	0xc0c8a742	},
+	{	XFER_PIO_2,	0xc0d0a753	},
+	{	XFER_PIO_1,	0xc0d0a7a3	},	/* 0xc0d0a793 */
+	{	XFER_PIO_0,	0xc0d0a7aa	},	/* 0xc0d0a7a7 */
+	{	0,		0x0120a7a7	}
+};
+
+static struct chipset_bus_clock_list_entry twenty_five_base_hpt366[] = {
+	{	XFER_UDMA_4,	0x90c98521	},
+	{	XFER_UDMA_3,	0x90cf8521	},
+	{	XFER_UDMA_2,	0x90cf8521	},
+	{	XFER_UDMA_1,	0x90cb8521	},
+	{	XFER_UDMA_0,	0x90cb8521	},
+
+	{	XFER_MW_DMA_2,	0xa0ca8521	},
+	{	XFER_MW_DMA_1,	0xa0ca8532	},
+	{	XFER_MW_DMA_0,	0xa0ca8575	},
+
+	{	XFER_PIO_4,	0xc0ca8521	},
+	{	XFER_PIO_3,	0xc0ca8532	},
+	{	XFER_PIO_2,	0xc0ca8542	},
+	{	XFER_PIO_1,	0xc0d08572	},
+	{	XFER_PIO_0,	0xc0d08585	},
+	{	0,		0x01208585	}
+};
+
+/* from highpoint documentation. these are old values */
+static struct chipset_bus_clock_list_entry thirty_three_base_hpt370[] = {
+/*	{	XFER_UDMA_5,	0x1A85F442,	0x16454e31	}, */
+	{	XFER_UDMA_5,	0x16454e31	},
+	{	XFER_UDMA_4,	0x16454e31	},
+	{	XFER_UDMA_3,	0x166d4e31	},
+	{	XFER_UDMA_2,	0x16494e31	},
+	{	XFER_UDMA_1,	0x164d4e31	},
+	{	XFER_UDMA_0,	0x16514e31	},
+
+	{	XFER_MW_DMA_2,	0x26514e21	},
+	{	XFER_MW_DMA_1,	0x26514e33	},
+	{	XFER_MW_DMA_0,	0x26514e97	},
+
+	{	XFER_PIO_4,	0x06514e21	},
+	{	XFER_PIO_3,	0x06514e22	},
+	{	XFER_PIO_2,	0x06514e33	},
+	{	XFER_PIO_1,	0x06914e43	},
+	{	XFER_PIO_0,	0x06914e57	},
+	{	0,		0x06514e57	}
+};
+
+static struct chipset_bus_clock_list_entry sixty_six_base_hpt370[] = {
+	{	XFER_UDMA_5,	0x14846231	},
+	{	XFER_UDMA_4,	0x14886231	},
+	{	XFER_UDMA_3,	0x148c6231	},
+	{	XFER_UDMA_2,	0x148c6231	},
+	{	XFER_UDMA_1,	0x14906231	},
+	{	XFER_UDMA_0,	0x14986231	},
+
+	{	XFER_MW_DMA_2,	0x26514e21	},
+	{	XFER_MW_DMA_1,	0x26514e33	},
+	{	XFER_MW_DMA_0,	0x26514e97	},
+
+	{	XFER_PIO_4,	0x06514e21	},
+	{	XFER_PIO_3,	0x06514e22	},
+	{	XFER_PIO_2,	0x06514e33	},
+	{	XFER_PIO_1,	0x06914e43	},
+	{	XFER_PIO_0,	0x06914e57	},
+	{	0,		0x06514e57	}
+};
+
+/* these are the current (4 sep 2001) timings from highpoint */
+static struct chipset_bus_clock_list_entry thirty_three_base_hpt370a[] = {
+	{	XFER_UDMA_5,	0x12446231	},
+	{	XFER_UDMA_4,	0x12446231	},
+	{	XFER_UDMA_3,	0x126c6231	},
+	{	XFER_UDMA_2,	0x12486231	},
+	{	XFER_UDMA_1,	0x124c6233	},
+	{	XFER_UDMA_0,	0x12506297	},
+
+	{	XFER_MW_DMA_2,	0x22406c31	},
+	{	XFER_MW_DMA_1,	0x22406c33	},
+	{	XFER_MW_DMA_0,	0x22406c97	},
+
+	{	XFER_PIO_4,	0x06414e31	},
+	{	XFER_PIO_3,	0x06414e42	},
+	{	XFER_PIO_2,	0x06414e53	},
+	{	XFER_PIO_1,	0x06814e93	},
+	{	XFER_PIO_0,	0x06814ea7	},
+	{	0,		0x06814ea7	}
+};
+
+/* 2x 33MHz timings */
+static struct chipset_bus_clock_list_entry sixty_six_base_hpt370a[] = {
+	{	XFER_UDMA_5,	0x1488e673	},
+	{	XFER_UDMA_4,	0x1488e673	},
+	{	XFER_UDMA_3,	0x1498e673	},
+	{	XFER_UDMA_2,	0x1490e673	},
+	{	XFER_UDMA_1,	0x1498e677	},
+	{	XFER_UDMA_0,	0x14a0e73f	},
+
+	{	XFER_MW_DMA_2,	0x2480fa73	},
+	{	XFER_MW_DMA_1,	0x2480fa77	}, 
+	{	XFER_MW_DMA_0,	0x2480fb3f	},
+
+	{	XFER_PIO_4,	0x0c82be73	},
+	{	XFER_PIO_3,	0x0c82be95	},
+	{	XFER_PIO_2,	0x0c82beb7	},
+	{	XFER_PIO_1,	0x0d02bf37	},
+	{	XFER_PIO_0,	0x0d02bf5f	},
+	{	0,		0x0d02bf5f	}
+};
+
+static struct chipset_bus_clock_list_entry fifty_base_hpt370a[] = {
+	{	XFER_UDMA_5,	0x12848242	},
+	{	XFER_UDMA_4,	0x12ac8242	},
+	{	XFER_UDMA_3,	0x128c8242	},
+	{	XFER_UDMA_2,	0x120c8242	},
+	{	XFER_UDMA_1,	0x12148254	},
+	{	XFER_UDMA_0,	0x121882ea	},
+
+	{	XFER_MW_DMA_2,	0x22808242	},
+	{	XFER_MW_DMA_1,	0x22808254	},
+	{	XFER_MW_DMA_0,	0x228082ea	},
+
+	{	XFER_PIO_4,	0x0a81f442	},
+	{	XFER_PIO_3,	0x0a81f443	},
+	{	XFER_PIO_2,	0x0a81f454	},
+	{	XFER_PIO_1,	0x0ac1f465	},
+	{	XFER_PIO_0,	0x0ac1f48a	},
+	{	0,		0x0ac1f48a	}
+};
+
+static struct chipset_bus_clock_list_entry thirty_three_base_hpt372[] = {
+	{	XFER_UDMA_6,	0x1c81dc62	},
+	{	XFER_UDMA_5,	0x1c6ddc62	},
+	{	XFER_UDMA_4,	0x1c8ddc62	},
+	{	XFER_UDMA_3,	0x1c8edc62	},	/* checkme */
+	{	XFER_UDMA_2,	0x1c91dc62	},
+	{	XFER_UDMA_1,	0x1c9adc62	},	/* checkme */
+	{	XFER_UDMA_0,	0x1c82dc62	},	/* checkme */
+
+	{	XFER_MW_DMA_2,	0x2c829262	},
+	{	XFER_MW_DMA_1,	0x2c829266	},	/* checkme */
+	{	XFER_MW_DMA_0,	0x2c82922e	},	/* checkme */
+
+	{	XFER_PIO_4,	0x0c829c62	},
+	{	XFER_PIO_3,	0x0c829c84	},
+	{	XFER_PIO_2,	0x0c829ca6	},
+	{	XFER_PIO_1,	0x0d029d26	},
+	{	XFER_PIO_0,	0x0d029d5e	},
+	{	0,		0x0d029d5e	}
+};
+
+static struct chipset_bus_clock_list_entry fifty_base_hpt372[] = {
+	{	XFER_UDMA_5,	0x12848242	},
+	{	XFER_UDMA_4,	0x12ac8242	},
+	{	XFER_UDMA_3,	0x128c8242	},
+	{	XFER_UDMA_2,	0x120c8242	},
+	{	XFER_UDMA_1,	0x12148254	},
+	{	XFER_UDMA_0,	0x121882ea	},
+
+	{	XFER_MW_DMA_2,	0x22808242	},
+	{	XFER_MW_DMA_1,	0x22808254	},
+	{	XFER_MW_DMA_0,	0x228082ea	},
+
+	{	XFER_PIO_4,	0x0a81f442	},
+	{	XFER_PIO_3,	0x0a81f443	},
+	{	XFER_PIO_2,	0x0a81f454	},
+	{	XFER_PIO_1,	0x0ac1f465	},
+	{	XFER_PIO_0,	0x0ac1f48a	},
+	{	0,		0x0a81f443	}
+};
+
+static struct chipset_bus_clock_list_entry sixty_six_base_hpt372[] = {
+	{	XFER_UDMA_6,	0x1c869c62	},
+	{	XFER_UDMA_5,	0x1cae9c62	},
+	{	XFER_UDMA_4,	0x1c8a9c62	},
+	{	XFER_UDMA_3,	0x1c8e9c62	},
+	{	XFER_UDMA_2,	0x1c929c62	},
+	{	XFER_UDMA_1,	0x1c9a9c62	},
+	{	XFER_UDMA_0,	0x1c829c62	},
+
+	{	XFER_MW_DMA_2,	0x2c829c62	},
+	{	XFER_MW_DMA_1,	0x2c829c66	},
+	{	XFER_MW_DMA_0,	0x2c829d2e	},
+
+	{	XFER_PIO_4,	0x0c829c62	},
+	{	XFER_PIO_3,	0x0c829c84	},
+	{	XFER_PIO_2,	0x0c829ca6	},
+	{	XFER_PIO_1,	0x0d029d26	},
+	{	XFER_PIO_0,	0x0d029d5e	},
+	{	0,		0x0d029d26	}
+};
+
+static struct chipset_bus_clock_list_entry thirty_three_base_hpt374[] = {
+	{	XFER_UDMA_6,	0x12808242	},
+	{	XFER_UDMA_5,	0x12848242	},
+	{	XFER_UDMA_4,	0x12ac8242	},
+	{	XFER_UDMA_3,	0x128c8242	},
+	{	XFER_UDMA_2,	0x120c8242	},
+	{	XFER_UDMA_1,	0x12148254	},
+	{	XFER_UDMA_0,	0x121882ea	},
+
+	{	XFER_MW_DMA_2,	0x22808242	},
+	{	XFER_MW_DMA_1,	0x22808254	},
+	{	XFER_MW_DMA_0,	0x228082ea	},
+
+	{	XFER_PIO_4,	0x0a81f442	},
+	{	XFER_PIO_3,	0x0a81f443	},
+	{	XFER_PIO_2,	0x0a81f454	},
+	{	XFER_PIO_1,	0x0ac1f465	},
+	{	XFER_PIO_0,	0x0ac1f48a	},
+	{	0,		0x06814e93	}
+};
+
+/* FIXME: 50MHz timings for HPT374 */
 
-#if defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-#endif  /* defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS) */
-
-static unsigned int hpt_revision(struct pci_dev *dev);
-static unsigned int hpt_minimum_revision(struct pci_dev *dev, int revision);
-
-#if defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS)
-
-static u8 hpt366_proc = 0;
-static struct pci_dev *hpt_devs[HPT366_MAX_DEVS];
-static int n_hpt_devs;
-
-static int hpt366_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p	= buffer;
-	char *chipset_nums[] = {"366", "366",  "368",
-				"370", "370A", "372",
-				"302", "371",  "374" };
-	int i, len;
-
-	p += sprintf(p, "\n                             "
-		"HighPoint HPT366/368/370/372/374\n");
-	for (i = 0; i < n_hpt_devs; i++) {
-		struct pci_dev *dev = hpt_devs[i];
-		unsigned long iobase = dev->resource[4].start;
-		u32 class_rev = hpt_revision(dev);
-		u8 c0, c1;
-
-		p += sprintf(p, "\nController: %d\n", i);
-		p += sprintf(p, "Chipset: HPT%s\n", chipset_nums[class_rev]);
-		p += sprintf(p, "--------------- Primary Channel "
-				"--------------- Secondary Channel "
-				"--------------\n");
-
-		/* get the bus master status registers */
-		c0 = inb(iobase + 0x2);
-		c1 = inb(iobase + 0xa);
-		p += sprintf(p, "Enabled:        %s"
-				"                             %s\n",
-			(c0 & 0x80) ? "no" : "yes",
-			(c1 & 0x80) ? "no" : "yes");
+#if 0
+static struct chipset_bus_clock_list_entry sixty_six_base_hpt374[] = {
+	{	XFER_UDMA_6,	0x12406231	},	/* checkme */
+	{	XFER_UDMA_5,	0x12446231	},	/* 0x14846231 */
+	{	XFER_UDMA_4,	0x16814ea7	},	/* 0x14886231 */
+	{	XFER_UDMA_3,	0x16814ea7	},	/* 0x148c6231 */
+	{	XFER_UDMA_2,	0x16814ea7	},	/* 0x148c6231 */
+	{	XFER_UDMA_1,	0x16814ea7	},	/* 0x14906231 */
+	{	XFER_UDMA_0,	0x16814ea7	},	/* 0x14986231 */
+	{	XFER_MW_DMA_2,	0x16814ea7	},	/* 0x26514e21 */
+	{	XFER_MW_DMA_1,	0x16814ea7	},	/* 0x26514e97 */
+	{	XFER_MW_DMA_0,	0x16814ea7	},	/* 0x26514e97 */
+	{	XFER_PIO_4,	0x06814ea7	},	/* 0x06514e21 */
+	{	XFER_PIO_3,	0x06814ea7	},	/* 0x06514e22 */
+	{	XFER_PIO_2,	0x06814ea7	},	/* 0x06514e33 */
+	{	XFER_PIO_1,	0x06814ea7	},	/* 0x06914e43 */
+	{	XFER_PIO_0,	0x06814ea7	},	/* 0x06914e57 */
+	{	0,		0x06814ea7	}
+};
+#endif
+
+#define HPT366_DEBUG_DRIVE_INFO		0
+#define HPT374_ALLOW_ATA133_6		0
+#define HPT371_ALLOW_ATA133_6		0
+#define HPT302_ALLOW_ATA133_6		0
+#define HPT372_ALLOW_ATA133_6		1
+#define HPT370_ALLOW_ATA100_5		1
+#define HPT366_ALLOW_ATA66_4		1
+#define HPT366_ALLOW_ATA66_3		1
+#define HPT366_MAX_DEVS			8
+
+#define F_LOW_PCI_33	0x23
+#define F_LOW_PCI_40	0x29
+#define F_LOW_PCI_50	0x2d
+#define F_LOW_PCI_66	0x42
+
+/* FIXME: compare with driver's code before removing */
 #if 0
 		if (hpt_minimum_revision(dev, 3)) {
 			u8 cbl;
@@ -128,16 +460,6 @@
 				(cbl & 0x01) ? 33 : 66);
 			p += sprintf(p, "\n");
 		}
-#endif
-		p += sprintf(p, "--------------- drive0 --------- drive1 "
-				"------- drive0 ---------- drive1 -------\n");
-		p += sprintf(p, "DMA capable:    %s              %s" 
-				"            %s               %s\n",
-			(c0 & 0x20) ? "yes" : "no ", 
-			(c0 & 0x40) ? "yes" : "no ",
-			(c1 & 0x20) ? "yes" : "no ", 
-			(c1 & 0x40) ? "yes" : "no ");
-
 		{
 			u8 c2, c3;
 			/* older revs don't have these registers mapped 
@@ -159,15 +481,7 @@
 					(c3 & 0x80) ? "PIO " : "off ");
 		}
 	}
-	p += sprintf(p, "\n");
-
-	/* p - buffer must be less than 4k! */
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif  /* defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS) */
+#endif
 
 static u32 hpt_revision (struct pci_dev *dev)
 {
@@ -521,35 +835,16 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if (id->dma_mword & hwif->mwdma_mask) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		hpt3xx_tune_drive(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -577,7 +872,7 @@
 	/* how about we flush and reset, mmmkay? */
 	pci_write_config_byte(dev, 0x51, 0x1F);
 	/* fall through to a reset */
-	case ide_dma_begin:
+	case dma_start:
 	case ide_dma_end:
 	/* reset the chips state over and over.. */
 	pci_write_config_byte(dev, 0x51, 0x13);
@@ -592,12 +887,12 @@
 	udelay(10);
 }
 
-static int hpt370_ide_dma_begin (ide_drive_t *drive)
+static void hpt370_ide_dma_start(ide_drive_t *drive)
 {
 #ifdef HPT_RESET_STATE_ENGINE
 	hpt370_clear_engine(drive);
 #endif
-	return __ide_dma_begin(drive);
+	ide_dma_start(drive);
 }
 
 static int hpt370_ide_dma_end (ide_drive_t *drive)
@@ -723,32 +1018,25 @@
 }
 
 /**
- *	hpt372n_rw_disk		-	wrapper for I/O
+ *	hpt372n_rw_disk		-	prepare for I/O
  *	@drive: drive for command
  *	@rq: block request structure
- *	@block: block number
- *
- *	This is called when a disk I/O is issued to the 372N instead
- *	of the default functionality. We need it because of the clock
- *	switching
  *
+ *	This is called when a disk I/O is issued to the 372N.
+ *	We need it because of the clock switching.
  */
- 
-static ide_startstop_t hpt372n_rw_disk(ide_drive_t *drive, struct request *rq, sector_t block)
+
+static void hpt372n_rw_disk(ide_drive_t *drive, struct request *rq)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	int wantclock;
-	
-	if(rq_data_dir(rq) == READ)
-		wantclock = 0x21;
-	else
-		wantclock = 0x23;
-		
-	if(HWIF(drive)->config_data != wantclock)
-	{
+
+	wantclock = rq_data_dir(rq) ? 0x23 : 0x21;
+
+	if (hwif->config_data != wantclock) {
 		hpt372n_set_clock(drive, wantclock);
-		HWIF(drive)->config_data = wantclock;
+		hwif->config_data = wantclock;
 	}
-	return __ide_do_rw_disk(drive, rq, block);
 }
 
 /*
@@ -1105,15 +1393,6 @@
 	}
 	if (ret)
 		return ret;
-	
-#if defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS)
-	hpt_devs[n_hpt_devs++] = dev;
-
-	if (!hpt366_proc) {
-		hpt366_proc = 1;
-		ide_pci_create_host_proc("hpt366", hpt366_get_info);
-	}
-#endif /* DISPLAY_HPT366_TIMINGS && CONFIG_PROC_FS */
 
 	return dev->irq;
 }
@@ -1230,7 +1509,7 @@
 		hwif->ide_dma_test_irq = &hpt374_ide_dma_test_irq;
 		hwif->ide_dma_end = &hpt374_ide_dma_end;
 	} else if (hpt_minimum_revision(dev,3)) {
-		hwif->ide_dma_begin = &hpt370_ide_dma_begin;
+		hwif->dma_start = &hpt370_ide_dma_start;
 		hwif->ide_dma_end = &hpt370_ide_dma_end;
 		hwif->ide_dma_timeout = &hpt370_ide_dma_timeout;
 		hwif->ide_dma_lostirq = &hpt370_ide_dma_lostirq;
@@ -1280,12 +1559,12 @@
 	ide_setup_dma(hwif, dmabase, 8);
 }
 
-static void __devinit init_setup_hpt374(struct pci_dev *dev, ide_pci_device_t *d)
+static int __devinit init_setup_hpt374(struct pci_dev *dev, ide_pci_device_t *d)
 {
 	struct pci_dev *findev = NULL;
 
 	if (PCI_FUNC(dev->devfn) & 1)
-		return;
+		return -ENODEV;
 
 	while ((findev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, findev)) != NULL) {
 		if ((findev->vendor == dev->vendor) &&
@@ -1298,19 +1577,18 @@
 				printk(KERN_WARNING "%s: pci-config space interrupt "
 					"fixed.\n", d->name);
 			}
-			ide_setup_pci_devices(dev, findev, d);
-			return;
+			return ide_setup_pci_devices(dev, findev, d);
 		}
 	}
-	ide_setup_pci_device(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
-static void __devinit init_setup_hpt37x(struct pci_dev *dev, ide_pci_device_t *d)
+static int __devinit init_setup_hpt37x(struct pci_dev *dev, ide_pci_device_t *d)
 {
-	ide_setup_pci_device(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
-static void __devinit init_setup_hpt366(struct pci_dev *dev, ide_pci_device_t *d)
+static int __devinit init_setup_hpt366(struct pci_dev *dev, ide_pci_device_t *d)
 {
 	struct pci_dev *findev = NULL;
 	u8 pin1 = 0, pin2 = 0;
@@ -1320,7 +1598,7 @@
 				 "HPT372N" };
 
 	if (PCI_FUNC(dev->devfn) & 1)
-		return;
+		return -ENODEV;
 
 	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class_rev);
 	class_rev &= 0xff;
@@ -1335,9 +1613,10 @@
 		case 6:
 		case 5:
 		case 4:
-		case 3: ide_setup_pci_device(dev, d);
-			return;
-		default:	break;
+		case 3:
+			goto init_single;
+		default:
+			break;
 	}
 
 	d->channels = 1;
@@ -1355,13 +1634,71 @@
 					"pin1=%d pin2=%d\n", d->name,
 					pin1, pin2);
 			}
-			ide_setup_pci_devices(dev, findev, d);
-			return;
+			return ide_setup_pci_devices(dev, findev, d);
 		}
 	}
-	ide_setup_pci_device(dev, d);
+init_single:
+	return ide_setup_pci_device(dev, d);
 }
 
+static ide_pci_device_t hpt366_chipsets[] __devinitdata = {
+	{	/* 0 */
+		.name		= "HPT366",
+		.init_setup	= init_setup_hpt366,
+		.init_chipset	= init_chipset_hpt366,
+		.init_hwif	= init_hwif_hpt366,
+		.init_dma	= init_dma_hpt366,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+		.extra		= 240
+	},{	/* 1 */
+		.name		= "HPT372A",
+		.init_setup	= init_setup_hpt37x,
+		.init_chipset	= init_chipset_hpt366,
+		.init_hwif	= init_hwif_hpt366,
+		.init_dma	= init_dma_hpt366,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+	},{	/* 2 */
+		.name		= "HPT302",
+		.init_setup	= init_setup_hpt37x,
+		.init_chipset	= init_chipset_hpt366,
+		.init_hwif	= init_hwif_hpt366,
+		.init_dma	= init_dma_hpt366,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+	},{	/* 3 */
+		.name		= "HPT371",
+		.init_setup	= init_setup_hpt37x,
+		.init_chipset	= init_chipset_hpt366,
+		.init_hwif	= init_hwif_hpt366,
+		.init_dma	= init_dma_hpt366,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+	},{	/* 4 */
+		.name		= "HPT374",
+		.init_setup	= init_setup_hpt374,
+		.init_chipset	= init_chipset_hpt366,
+		.init_hwif	= init_hwif_hpt366,
+		.init_dma	= init_dma_hpt366,
+		.channels	= 2,	/* 4 */
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+	},{	/* 5 */
+		.name		= "HPT372N",
+		.init_setup	= init_setup_hpt37x,
+		.init_chipset	= init_chipset_hpt366,
+		.init_hwif	= init_hwif_hpt366,
+		.init_dma	= init_dma_hpt366,
+		.channels	= 2,	/* 4 */
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+	}
+};
 
 /**
  *	hpt366_init_one	-	called when an HPT366 is found
@@ -1376,8 +1713,7 @@
 {
 	ide_pci_device_t *d = &hpt366_chipsets[id->driver_data];
 
-	d->init_setup(dev, d);
-	return 0;
+	return d->init_setup(dev, d);
 }
 
 static struct pci_device_id hpt366_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/hpt366.h linuxppc-2.6.9-dream/drivers/ide/pci/hpt366.h
--- linuxppc-2.6.9/drivers/ide/pci/hpt366.h	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/hpt366.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,485 +0,0 @@
-#ifndef HPT366_H
-#define HPT366_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-#define DISPLAY_HPT366_TIMINGS
-
-/* various tuning parameters */
-#define HPT_RESET_STATE_ENGINE
-#undef HPT_DELAY_INTERRUPT
-#undef HPT_SERIALIZE_IO
-
-const char *quirk_drives[] = {
-	"QUANTUM FIREBALLlct08 08",
-	"QUANTUM FIREBALLP KA6.4",
-	"QUANTUM FIREBALLP LM20.4",
-	"QUANTUM FIREBALLP LM20.5",
-        NULL
-};
-
-const char *bad_ata100_5[] = {
-	"IBM-DTLA-307075",
-	"IBM-DTLA-307060",
-	"IBM-DTLA-307045",
-	"IBM-DTLA-307030",
-	"IBM-DTLA-307020",
-	"IBM-DTLA-307015",
-	"IBM-DTLA-305040",
-	"IBM-DTLA-305030",
-	"IBM-DTLA-305020",
-	"IC35L010AVER07-0",
-	"IC35L020AVER07-0",
-	"IC35L030AVER07-0",
-	"IC35L040AVER07-0",
-	"IC35L060AVER07-0",
-	"WDC AC310200R",
-	NULL
-};
-
-const char *bad_ata66_4[] = {
-	"IBM-DTLA-307075",
-	"IBM-DTLA-307060",
-	"IBM-DTLA-307045",
-	"IBM-DTLA-307030",
-	"IBM-DTLA-307020",
-	"IBM-DTLA-307015",
-	"IBM-DTLA-305040",
-	"IBM-DTLA-305030",
-	"IBM-DTLA-305020",
-	"IC35L010AVER07-0",
-	"IC35L020AVER07-0",
-	"IC35L030AVER07-0",
-	"IC35L040AVER07-0",
-	"IC35L060AVER07-0",
-	"WDC AC310200R",
-	NULL
-};
-
-const char *bad_ata66_3[] = {
-	"WDC AC310200R",
-	NULL
-};
-
-const char *bad_ata33[] = {
-	"Maxtor 92720U8", "Maxtor 92040U6", "Maxtor 91360U4", "Maxtor 91020U3", "Maxtor 90845U3", "Maxtor 90650U2",
-	"Maxtor 91360D8", "Maxtor 91190D7", "Maxtor 91020D6", "Maxtor 90845D5", "Maxtor 90680D4", "Maxtor 90510D3", "Maxtor 90340D2",
-	"Maxtor 91152D8", "Maxtor 91008D7", "Maxtor 90845D6", "Maxtor 90840D6", "Maxtor 90720D5", "Maxtor 90648D5", "Maxtor 90576D4",
-	"Maxtor 90510D4",
-	"Maxtor 90432D3", "Maxtor 90288D2", "Maxtor 90256D2",
-	"Maxtor 91000D8", "Maxtor 90910D8", "Maxtor 90875D7", "Maxtor 90840D7", "Maxtor 90750D6", "Maxtor 90625D5", "Maxtor 90500D4",
-	"Maxtor 91728D8", "Maxtor 91512D7", "Maxtor 91303D6", "Maxtor 91080D5", "Maxtor 90845D4", "Maxtor 90680D4", "Maxtor 90648D3", "Maxtor 90432D2",
-	NULL
-};
-
-struct chipset_bus_clock_list_entry {
-	byte		xfer_speed;
-	unsigned int	chipset_settings;
-};
-
-/* key for bus clock timings
- * bit
- * 0:3    data_high_time. inactive time of DIOW_/DIOR_ for PIO and MW
- *        DMA. cycles = value + 1
- * 4:8    data_low_time. active time of DIOW_/DIOR_ for PIO and MW
- *        DMA. cycles = value + 1
- * 9:12   cmd_high_time. inactive time of DIOW_/DIOR_ during task file
- *        register access.
- * 13:17  cmd_low_time. active time of DIOW_/DIOR_ during task file
- *        register access.
- * 18:21  udma_cycle_time. clock freq and clock cycles for UDMA xfer.
- *        during task file register access.
- * 22:24  pre_high_time. time to initialize 1st cycle for PIO and MW DMA
- *        xfer.
- * 25:27  cmd_pre_high_time. time to initialize 1st PIO cycle for task
- *        register access.
- * 28     UDMA enable
- * 29     DMA enable
- * 30     PIO_MST enable. if set, the chip is in bus master mode during
- *        PIO.
- * 31     FIFO enable.
- */
-struct chipset_bus_clock_list_entry forty_base_hpt366[] = {
-	{	XFER_UDMA_4,	0x900fd943	},
-	{	XFER_UDMA_3,	0x900ad943	},
-	{	XFER_UDMA_2,	0x900bd943	},
-	{	XFER_UDMA_1,	0x9008d943	},
-	{	XFER_UDMA_0,	0x9008d943	},
-
-	{	XFER_MW_DMA_2,	0xa008d943	},
-	{	XFER_MW_DMA_1,	0xa010d955	},
-	{	XFER_MW_DMA_0,	0xa010d9fc	},
-
-	{	XFER_PIO_4,	0xc008d963	},
-	{	XFER_PIO_3,	0xc010d974	},
-	{	XFER_PIO_2,	0xc010d997	},
-	{	XFER_PIO_1,	0xc010d9c7	},
-	{	XFER_PIO_0,	0xc018d9d9	},
-	{	0,		0x0120d9d9	}
-};
-
-struct chipset_bus_clock_list_entry thirty_three_base_hpt366[] = {
-	{	XFER_UDMA_4,	0x90c9a731	},
-	{	XFER_UDMA_3,	0x90cfa731	},
-	{	XFER_UDMA_2,	0x90caa731	},
-	{	XFER_UDMA_1,	0x90cba731	},
-	{	XFER_UDMA_0,	0x90c8a731	},
-
-	{	XFER_MW_DMA_2,	0xa0c8a731	},
-	{	XFER_MW_DMA_1,	0xa0c8a732	},	/* 0xa0c8a733 */
-	{	XFER_MW_DMA_0,	0xa0c8a797	},
-
-	{	XFER_PIO_4,	0xc0c8a731	},
-	{	XFER_PIO_3,	0xc0c8a742	},
-	{	XFER_PIO_2,	0xc0d0a753	},
-	{	XFER_PIO_1,	0xc0d0a7a3	},	/* 0xc0d0a793 */
-	{	XFER_PIO_0,	0xc0d0a7aa	},	/* 0xc0d0a7a7 */
-	{	0,		0x0120a7a7	}
-};
-
-struct chipset_bus_clock_list_entry twenty_five_base_hpt366[] = {
-
-	{	XFER_UDMA_4,	0x90c98521	},
-	{	XFER_UDMA_3,	0x90cf8521	},
-	{	XFER_UDMA_2,	0x90cf8521	},
-	{	XFER_UDMA_1,	0x90cb8521	},
-	{	XFER_UDMA_0,	0x90cb8521	},
-
-	{	XFER_MW_DMA_2,	0xa0ca8521	},
-	{	XFER_MW_DMA_1,	0xa0ca8532	},
-	{	XFER_MW_DMA_0,	0xa0ca8575	},
-
-	{	XFER_PIO_4,	0xc0ca8521	},
-	{	XFER_PIO_3,	0xc0ca8532	},
-	{	XFER_PIO_2,	0xc0ca8542	},
-	{	XFER_PIO_1,	0xc0d08572	},
-	{	XFER_PIO_0,	0xc0d08585	},
-	{	0,		0x01208585	}
-};
-
-/* from highpoint documentation. these are old values */
-struct chipset_bus_clock_list_entry thirty_three_base_hpt370[] = {
-/*	{	XFER_UDMA_5,	0x1A85F442,	0x16454e31	}, */
-	{	XFER_UDMA_5,	0x16454e31	},
-	{	XFER_UDMA_4,	0x16454e31	},
-	{	XFER_UDMA_3,	0x166d4e31	},
-	{	XFER_UDMA_2,	0x16494e31	},
-	{	XFER_UDMA_1,	0x164d4e31	},
-	{	XFER_UDMA_0,	0x16514e31	},
-
-	{	XFER_MW_DMA_2,	0x26514e21	},
-	{	XFER_MW_DMA_1,	0x26514e33	},
-	{	XFER_MW_DMA_0,	0x26514e97	},
-
-	{	XFER_PIO_4,	0x06514e21	},
-	{	XFER_PIO_3,	0x06514e22	},
-	{	XFER_PIO_2,	0x06514e33	},
-	{	XFER_PIO_1,	0x06914e43	},
-	{	XFER_PIO_0,	0x06914e57	},
-	{	0,		0x06514e57	}
-};
-
-struct chipset_bus_clock_list_entry sixty_six_base_hpt370[] = {
-	{       XFER_UDMA_5,    0x14846231      },
-	{       XFER_UDMA_4,    0x14886231      },
-	{       XFER_UDMA_3,    0x148c6231      },
-	{       XFER_UDMA_2,    0x148c6231      },
-	{       XFER_UDMA_1,    0x14906231      },
-	{       XFER_UDMA_0,    0x14986231      },
-	
-	{       XFER_MW_DMA_2,  0x26514e21      },
-	{       XFER_MW_DMA_1,  0x26514e33      },
-	{       XFER_MW_DMA_0,  0x26514e97      },
-	
-	{       XFER_PIO_4,     0x06514e21      },
-	{       XFER_PIO_3,     0x06514e22      },
-	{       XFER_PIO_2,     0x06514e33      },
-	{       XFER_PIO_1,     0x06914e43      },
-	{       XFER_PIO_0,     0x06914e57      },
-	{       0,              0x06514e57      }
-};
-
-/* these are the current (4 sep 2001) timings from highpoint */
-struct chipset_bus_clock_list_entry thirty_three_base_hpt370a[] = {
-        {       XFER_UDMA_5,    0x12446231      },
-        {       XFER_UDMA_4,    0x12446231      },
-        {       XFER_UDMA_3,    0x126c6231      },
-        {       XFER_UDMA_2,    0x12486231      },
-        {       XFER_UDMA_1,    0x124c6233      },
-        {       XFER_UDMA_0,    0x12506297      },
-
-        {       XFER_MW_DMA_2,  0x22406c31      },
-        {       XFER_MW_DMA_1,  0x22406c33      },
-        {       XFER_MW_DMA_0,  0x22406c97      },
-
-        {       XFER_PIO_4,     0x06414e31      },
-        {       XFER_PIO_3,     0x06414e42      },
-        {       XFER_PIO_2,     0x06414e53      },
-        {       XFER_PIO_1,     0x06814e93      },
-        {       XFER_PIO_0,     0x06814ea7      },
-        {       0,              0x06814ea7      }
-};
-
-/* 2x 33MHz timings */
-struct chipset_bus_clock_list_entry sixty_six_base_hpt370a[] = {
-	{       XFER_UDMA_5,    0x1488e673       },
-	{       XFER_UDMA_4,    0x1488e673       },
-	{       XFER_UDMA_3,    0x1498e673       },
-	{       XFER_UDMA_2,    0x1490e673       },
-	{       XFER_UDMA_1,    0x1498e677       },
-	{       XFER_UDMA_0,    0x14a0e73f       },
-
-	{       XFER_MW_DMA_2,  0x2480fa73       },
-	{       XFER_MW_DMA_1,  0x2480fa77       }, 
-	{       XFER_MW_DMA_0,  0x2480fb3f       },
-
-	{       XFER_PIO_4,     0x0c82be73       },
-	{       XFER_PIO_3,     0x0c82be95       },
-	{       XFER_PIO_2,     0x0c82beb7       },
-	{       XFER_PIO_1,     0x0d02bf37       },
-	{       XFER_PIO_0,     0x0d02bf5f       },
-	{       0,              0x0d02bf5f       }
-};
-
-struct chipset_bus_clock_list_entry fifty_base_hpt370a[] = {
-	{       XFER_UDMA_5,    0x12848242      },
-	{       XFER_UDMA_4,    0x12ac8242      },
-	{       XFER_UDMA_3,    0x128c8242      },
-	{       XFER_UDMA_2,    0x120c8242      },
-	{       XFER_UDMA_1,    0x12148254      },
-	{       XFER_UDMA_0,    0x121882ea      },
-
-	{       XFER_MW_DMA_2,  0x22808242      },
-	{       XFER_MW_DMA_1,  0x22808254      },
-	{       XFER_MW_DMA_0,  0x228082ea      },
-
-	{       XFER_PIO_4,     0x0a81f442      },
-	{       XFER_PIO_3,     0x0a81f443      },
-	{       XFER_PIO_2,     0x0a81f454      },
-	{       XFER_PIO_1,     0x0ac1f465      },
-	{       XFER_PIO_0,     0x0ac1f48a      },
-	{       0,              0x0ac1f48a      }
-};
-
-struct chipset_bus_clock_list_entry thirty_three_base_hpt372[] = {
-	{	XFER_UDMA_6,	0x1c81dc62	},
-	{	XFER_UDMA_5,	0x1c6ddc62	},
-	{	XFER_UDMA_4,	0x1c8ddc62	},
-	{	XFER_UDMA_3,	0x1c8edc62	},	/* checkme */
-	{	XFER_UDMA_2,	0x1c91dc62	},
-	{	XFER_UDMA_1,	0x1c9adc62	},	/* checkme */
-	{	XFER_UDMA_0,	0x1c82dc62	},	/* checkme */
-
-	{	XFER_MW_DMA_2,	0x2c829262	},
-	{	XFER_MW_DMA_1,	0x2c829266	},	/* checkme */
-	{	XFER_MW_DMA_0,	0x2c82922e	},	/* checkme */
-
-	{	XFER_PIO_4,	0x0c829c62	},
-	{	XFER_PIO_3,	0x0c829c84	},
-	{	XFER_PIO_2,	0x0c829ca6	},
-	{	XFER_PIO_1,	0x0d029d26	},
-	{	XFER_PIO_0,	0x0d029d5e	},
-	{	0,		0x0d029d5e	}
-};
-
-struct chipset_bus_clock_list_entry fifty_base_hpt372[] = {
-	{	XFER_UDMA_5,	0x12848242	},
-	{	XFER_UDMA_4,	0x12ac8242	},
-	{	XFER_UDMA_3,	0x128c8242	},
-	{	XFER_UDMA_2,	0x120c8242	},
-	{	XFER_UDMA_1,	0x12148254	},
-	{	XFER_UDMA_0,	0x121882ea	},
-
-	{	XFER_MW_DMA_2,	0x22808242	},
-	{	XFER_MW_DMA_1,	0x22808254	},
-	{	XFER_MW_DMA_0,	0x228082ea	},
-
-	{	XFER_PIO_4,	0x0a81f442	},
-	{	XFER_PIO_3,	0x0a81f443	},
-	{	XFER_PIO_2,	0x0a81f454	},
-	{	XFER_PIO_1,	0x0ac1f465	},
-	{	XFER_PIO_0,	0x0ac1f48a	},
-	{	0,		0x0a81f443	}
-};
-
-struct chipset_bus_clock_list_entry sixty_six_base_hpt372[] = {
-	{	XFER_UDMA_6,	0x1c869c62	},
-	{	XFER_UDMA_5,	0x1cae9c62	},
-	{	XFER_UDMA_4,	0x1c8a9c62	},
-	{	XFER_UDMA_3,	0x1c8e9c62	},
-	{	XFER_UDMA_2,	0x1c929c62	},
-	{	XFER_UDMA_1,	0x1c9a9c62	},
-	{	XFER_UDMA_0,	0x1c829c62	},
-
-	{	XFER_MW_DMA_2,	0x2c829c62	},
-	{	XFER_MW_DMA_1,	0x2c829c66	},
-	{	XFER_MW_DMA_0,	0x2c829d2e	},
-
-	{	XFER_PIO_4,	0x0c829c62	},
-	{	XFER_PIO_3,	0x0c829c84	},
-	{	XFER_PIO_2,	0x0c829ca6	},
-	{	XFER_PIO_1,	0x0d029d26	},
-	{	XFER_PIO_0,	0x0d029d5e	},
-	{	0,		0x0d029d26	}
-};
-
-struct chipset_bus_clock_list_entry thirty_three_base_hpt374[] = {
-	{	XFER_UDMA_6,	0x12808242	},
-	{	XFER_UDMA_5,	0x12848242	},
-	{	XFER_UDMA_4,	0x12ac8242	},
-	{	XFER_UDMA_3,	0x128c8242	},
-	{	XFER_UDMA_2,	0x120c8242	},
-	{	XFER_UDMA_1,	0x12148254	},
-	{	XFER_UDMA_0,	0x121882ea	},
-
-	{	XFER_MW_DMA_2,	0x22808242	},
-	{	XFER_MW_DMA_1,	0x22808254	},
-	{	XFER_MW_DMA_0,	0x228082ea	},
-
-	{	XFER_PIO_4,	0x0a81f442	},
-	{	XFER_PIO_3,	0x0a81f443	},
-	{	XFER_PIO_2,	0x0a81f454	},
-	{	XFER_PIO_1,	0x0ac1f465	},
-	{	XFER_PIO_0,	0x0ac1f48a	},
-	{	0,		0x06814e93	}
-};
-
-#if 0
-struct chipset_bus_clock_list_entry fifty_base_hpt374[] = {
-	{	XFER_UDMA_6,	},
-	{	XFER_UDMA_5,	},
-	{	XFER_UDMA_4,	},
-	{	XFER_UDMA_3,	},
-	{	XFER_UDMA_2,	},
-	{	XFER_UDMA_1,	},
-	{	XFER_UDMA_0,	},
-	{	XFER_MW_DMA_2,	},
-	{	XFER_MW_DMA_1,	},
-	{	XFER_MW_DMA_0,	},
-	{	XFER_PIO_4,	},
-	{	XFER_PIO_3,	},
-	{	XFER_PIO_2,	},
-	{	XFER_PIO_1,	},
-	{	XFER_PIO_0,	},
-	{	0,	}
-};
-#endif
-#if 0
-struct chipset_bus_clock_list_entry sixty_six_base_hpt374[] = {
-	{	XFER_UDMA_6,	0x12406231	},	/* checkme */
-	{	XFER_UDMA_5,	0x12446231	},
-				0x14846231
-	{	XFER_UDMA_4,		0x16814ea7	},
-				0x14886231
-	{	XFER_UDMA_3,		0x16814ea7	},
-				0x148c6231
-	{	XFER_UDMA_2,		0x16814ea7	},
-				0x148c6231
-	{	XFER_UDMA_1,		0x16814ea7	},
-				0x14906231
-	{	XFER_UDMA_0,		0x16814ea7	},
-				0x14986231
-	{	XFER_MW_DMA_2,		0x16814ea7	},
-				0x26514e21
-	{	XFER_MW_DMA_1,		0x16814ea7	},
-				0x26514e97
-	{	XFER_MW_DMA_0,		0x16814ea7	},
-				0x26514e97
-	{	XFER_PIO_4,		0x06814ea7	},
-				0x06514e21
-	{	XFER_PIO_3,		0x06814ea7	},
-				0x06514e22
-	{	XFER_PIO_2,		0x06814ea7	},
-				0x06514e33
-	{	XFER_PIO_1,		0x06814ea7	},
-				0x06914e43
-	{	XFER_PIO_0,		0x06814ea7	},
-				0x06914e57
-	{	0,		0x06814ea7	}
-};
-#endif
-
-#define HPT366_DEBUG_DRIVE_INFO		0
-#define HPT374_ALLOW_ATA133_6		0
-#define HPT371_ALLOW_ATA133_6		0
-#define HPT302_ALLOW_ATA133_6		0
-#define HPT372_ALLOW_ATA133_6		1
-#define HPT370_ALLOW_ATA100_5		1
-#define HPT366_ALLOW_ATA66_4		1
-#define HPT366_ALLOW_ATA66_3		1
-#define HPT366_MAX_DEVS			8
-
-#define F_LOW_PCI_33      0x23
-#define F_LOW_PCI_40      0x29
-#define F_LOW_PCI_50      0x2d
-#define F_LOW_PCI_66      0x42
-
-static void init_setup_hpt366(struct pci_dev *, ide_pci_device_t *);
-static void init_setup_hpt37x(struct pci_dev *, ide_pci_device_t *);
-static void init_setup_hpt374(struct pci_dev *, ide_pci_device_t *);
-static unsigned int init_chipset_hpt366(struct pci_dev *, const char *);
-static void init_hwif_hpt366(ide_hwif_t *);
-static void init_dma_hpt366(ide_hwif_t *, unsigned long);
-
-static ide_pci_device_t hpt366_chipsets[] __devinitdata = {
-	{	/* 0 */
-		.name		= "HPT366",
-		.init_setup	= init_setup_hpt366,
-		.init_chipset	= init_chipset_hpt366,
-		.init_hwif	= init_hwif_hpt366,
-		.init_dma	= init_dma_hpt366,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-		.extra		= 240
-	},{	/* 1 */
-		.name		= "HPT372A",
-		.init_setup	= init_setup_hpt37x,
-		.init_chipset	= init_chipset_hpt366,
-		.init_hwif	= init_hwif_hpt366,
-		.init_dma	= init_dma_hpt366,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-	},{	/* 2 */
-		.name		= "HPT302",
-		.init_setup	= init_setup_hpt37x,
-		.init_chipset	= init_chipset_hpt366,
-		.init_hwif	= init_hwif_hpt366,
-		.init_dma	= init_dma_hpt366,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-	},{	/* 3 */
-		.name		= "HPT371",
-		.init_setup	= init_setup_hpt37x,
-		.init_chipset	= init_chipset_hpt366,
-		.init_hwif	= init_hwif_hpt366,
-		.init_dma	= init_dma_hpt366,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-	},{	/* 4 */
-		.name		= "HPT374",
-		.init_setup	= init_setup_hpt374,
-		.init_chipset	= init_chipset_hpt366,
-		.init_hwif	= init_hwif_hpt366,
-		.init_dma	= init_dma_hpt366,
-		.channels	= 2,	/* 4 */
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-	},{	/* 5 */
-		.name		= "HPT372N",
-		.init_setup	= init_setup_hpt37x,
-		.init_chipset	= init_chipset_hpt366,
-		.init_hwif	= init_hwif_hpt366,
-		.init_dma	= init_dma_hpt366,
-		.channels	= 2,	/* 4 */
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-	}
-};
-
-#endif /* HPT366_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/it8172.c linuxppc-2.6.9-dream/drivers/ide/pci/it8172.c
--- linuxppc-2.6.9/drivers/ide/pci/it8172.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/it8172.c	2005-06-20 10:46:11.000000000 +0200
@@ -42,8 +42,6 @@
 #include <asm/io.h>
 #include <asm/it8172/it8172_int.h>
 
-#include "it8172.h"
-
 /*
  * Prototypes
  */
@@ -56,7 +54,7 @@
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	struct pci_dev *dev	= hwif->pci_dev;
-	int is_slave		= (hwif->drives[1] == drive);
+	int is_slave		= (&hwif->drives[1] == drive);
 	unsigned long flags;
 	u16 drive_enables;
 	u32 drive_timing;
@@ -94,7 +92,7 @@
 	}
 
 	pci_write_config_word(dev, 0x40, drive_enables);
-	spin_unlock_irqrestore(&ide_lock, flags)
+	spin_unlock_irqrestore(&ide_lock, flags);
 }
 
 static u8 it8172_dma_2_pio (u8 xfer_rate)
@@ -201,36 +199,16 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = it8172_config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!it8172_config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!it8172_config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (it8172_config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		it8172_tune_drive(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -286,13 +264,24 @@
 	hwif->drives[1].autodma = hwif->autodma;
 }
 
+static ide_pci_device_t it8172_chipsets[] __devinitdata = {
+	{	/* 0 */
+		.name		= "IT8172G",
+		.init_chipset	= init_chipset_it8172,
+		.init_hwif	= init_hwif_it8172,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x00,0x00,0x00}, {0x40,0x00,0x01}},
+		.bootable	= ON_BOARD,
+	}
+};
+
 static int __devinit it8172_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
         if ((!(PCI_FUNC(dev->devfn) & 1) ||
             (!((dev->class >> 8) == PCI_CLASS_STORAGE_IDE))))
-                return 1; /* IT8172 is more than only a IDE controller */
-	ide_setup_pci_device(dev, &it8172_chipsets[id->driver_data]);
-	return 0;
+		return -ENODEV; /* IT8172 is more than an IDE controller */
+	return ide_setup_pci_device(dev, &it8172_chipsets[id->driver_data]);
 }
 
 static struct pci_device_id it8172_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/it8172.h linuxppc-2.6.9-dream/drivers/ide/pci/it8172.h
--- linuxppc-2.6.9/drivers/ide/pci/it8172.h	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/it8172.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,34 +0,0 @@
-#ifndef ITE8172G_H
-#define ITE8172G_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-static u8 it8172_ratemask(ide_drive_t *drive);
-static u8 it8172_ratefilter(ide_drive_t *drive, u8 speed);
-static void it8172_tune_drive(ide_drive_t *drive, u8 pio);
-static u8 it8172_dma_2_pio(u8 xfer_rate);
-static int it8172_tune_chipset(ide_drive_t *drive, u8 xferspeed);
-#ifdef CONFIG_BLK_DEV_IDEDMA
-static int it8172_config_chipset_for_dma(ide_drive_t *drive);
-#endif
-
-static void init_setup_it8172(struct pci_dev *, ide_pci_device_t *);
-static unsigned int init_chipset_it8172(struct pci_dev *, const char *);
-static void init_hwif_it8172(ide_hwif_t *);
-
-static ide_pci_device_t it8172_chipsets[] __devinitdata = {
-	{	/* 0 */
-		.name		= "IT8172G",
-		.init_setup	= init_setup_it8172,
-		.init_chipset	= init_chipset_it8172,
-		.init_hwif	= init_hwif_it8172,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.enablebits	= {{0x00,0x00,0x00}, {0x40,0x00,0x01}},
-		.bootable	= ON_BOARD,
-	}
-};
-
-#endif /* ITE8172G_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/Makefile linuxppc-2.6.9-dream/drivers/ide/pci/Makefile
--- linuxppc-2.6.9/drivers/ide/pci/Makefile	2004-10-18 23:53:42.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/Makefile	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,4 @@
 
-obj-$(CONFIG_BLK_DEV_ADMA100)		+= adma100.o
 obj-$(CONFIG_BLK_DEV_AEC62XX)		+= aec62xx.o
 obj-$(CONFIG_BLK_DEV_ALI15X3)		+= alim15x3.o
 obj-$(CONFIG_BLK_DEV_AMD74XX)		+= amd74xx.o
diff -Naur linuxppc-2.6.9/drivers/ide/pci/ns87415.c linuxppc-2.6.9-dream/drivers/ide/pci/ns87415.c
--- linuxppc-2.6.9/drivers/ide/pci/ns87415.c	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/ns87415.c	2005-06-20 10:46:11.000000000 +0200
@@ -4,6 +4,7 @@
  * Copyright (C) 1997-1998	Mark Lord <mlord@pobox.com>
  * Copyright (C) 1998		Eddie C. Dost <ecd@skynet.be>
  * Copyright (C) 1999-2000	Andre Hedrick <andre@linux-ide.org>
+ * Copyright (C) 2004		Grant Grundler <grundler at parisc-linux.org>
  *
  * Inspired by an earlier effort from David S. Miller <davem@redhat.com>
  */
@@ -25,6 +26,81 @@
 
 #include <asm/io.h>
 
+#ifdef CONFIG_SUPERIO
+/* SUPERIO 87560 is a PoS chip that NatSem denies exists.
+ * Unfortunately, it's built-in on all Astro-based PA-RISC workstations
+ * which use the integrated NS87514 cell for CD-ROM support.
+ * i.e we have to support for CD-ROM installs.
+ * See drivers/parisc/superio.c for more gory details.
+ */
+#include <asm/superio.h>
+
+static unsigned long superio_ide_status[2];
+static unsigned long superio_ide_select[2];
+static unsigned long superio_ide_dma_status[2];
+
+#define SUPERIO_IDE_MAX_RETRIES 25
+
+/* Because of a defect in Super I/O, all reads of the PCI DMA status 
+ * registers, IDE status register and the IDE select register need to be 
+ * retried
+ */
+static u8 superio_ide_inb (unsigned long port)
+{
+	if (port == superio_ide_status[0] ||
+	    port == superio_ide_status[1] ||
+	    port == superio_ide_select[0] ||
+	    port == superio_ide_select[1] ||
+	    port == superio_ide_dma_status[0] ||
+	    port == superio_ide_dma_status[1]) {
+		u8 tmp;
+		int retries = SUPERIO_IDE_MAX_RETRIES;
+
+		/* printk(" [ reading port 0x%x with retry ] ", port); */
+
+		do {
+			tmp = inb(port);
+			if (tmp == 0)
+				udelay(50);
+		} while (tmp == 0 && retries-- > 0);
+
+		return tmp;
+	}
+
+	return inb(port);
+}
+
+static void __devinit superio_ide_init_iops (struct hwif_s *hwif)
+{
+	u32 base, dmabase;
+	u8 tmp;
+	struct pci_dev *pdev = hwif->pci_dev;
+	u8 port = hwif->channel;
+
+	base = pci_resource_start(pdev, port * 2) & ~3;
+	dmabase = pci_resource_start(pdev, 4) & ~3;
+
+	superio_ide_status[port] = base + IDE_STATUS_OFFSET;
+	superio_ide_select[port] = base + IDE_SELECT_OFFSET;
+	superio_ide_dma_status[port] = dmabase + (!port ? 2 : 0xa);
+
+	/* Clear error/interrupt, enable dma */
+	tmp = superio_ide_inb(superio_ide_dma_status[port]);
+	outb(tmp | 0x66, superio_ide_dma_status[port]);
+
+	/* We need to override inb to workaround a SuperIO errata */
+	hwif->INB = superio_ide_inb;
+}
+
+static void __devinit init_iops_ns87415(ide_hwif_t *hwif)
+{
+	if (PCI_SLOT(hwif->pci_dev->devfn) == 0xE) {
+		/* Built-in - assume it's under superio. */
+		superio_ide_init_iops(hwif);
+	}
+}
+#endif
+
 static unsigned int ns87415_count = 0, ns87415_control[MAX_HWIFS] = { 0 };
 
 /*
@@ -101,22 +177,11 @@
 	return (dma_stat & 7) != 4;
 }
 
-static int ns87415_ide_dma_read (ide_drive_t *drive)
+static int ns87415_ide_dma_setup(ide_drive_t *drive)
 {
 	/* select DMA xfer */
 	ns87415_prepare_drive(drive, 1);
-	if (!(__ide_dma_read(drive)))
-		return 0;
-	/* DMA failed: select PIO xfer */
-	ns87415_prepare_drive(drive, 0);
-	return 1;
-}
-
-static int ns87415_ide_dma_write (ide_drive_t *drive)
-{
-	/* select DMA xfer */
-	ns87415_prepare_drive(drive, 1);
-	if (!(__ide_dma_write(drive)))
+	if (!ide_dma_setup(drive))
 		return 0;
 	/* DMA failed: select PIO xfer */
 	ns87415_prepare_drive(drive, 0);
@@ -143,10 +208,6 @@
 	hwif->autodma = 0;
 	hwif->selectproc = &ns87415_selectproc;
 
-	/* Set a good latency timer and cache line size value. */
-	(void) pci_write_config_byte(dev, PCI_LATENCY_TIMER, 64);
-	/* FIXME: use pci_set_master() to ensure good latency timer value */
-
 	/*
 	 * We cannot probe for IRQ: both ports share common IRQ on INTA.
 	 * Also, leave IRQ masked during drive probing, to prevent infinite
@@ -204,8 +265,7 @@
 		return;
 
 	hwif->OUTB(0x60, hwif->dma_status);
-	hwif->ide_dma_read = &ns87415_ide_dma_read;
-	hwif->ide_dma_write = &ns87415_ide_dma_write;
+	hwif->dma_setup = &ns87415_ide_dma_setup;
 	hwif->ide_dma_check = &ns87415_ide_dma_check;
 	hwif->ide_dma_end = &ns87415_ide_dma_end;
 
@@ -217,6 +277,9 @@
 
 static ide_pci_device_t ns87415_chipset __devinitdata = {
 	.name		= "NS87415",
+#ifdef CONFIG_SUPERIO
+	.init_iops	= init_iops_ns87415,
+#endif
 	.init_hwif	= init_hwif_ns87415,
 	.channels	= 2,
 	.autodma	= AUTODMA,
@@ -225,8 +288,7 @@
 
 static int __devinit ns87415_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &ns87415_chipset);
-	return 0;
+	return ide_setup_pci_device(dev, &ns87415_chipset);
 }
 
 static struct pci_device_id ns87415_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/opti621.c linuxppc-2.6.9-dream/drivers/ide/pci/opti621.c
--- linuxppc-2.6.9/drivers/ide/pci/opti621.c	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/opti621.c	2005-06-20 10:46:11.000000000 +0200
@@ -104,8 +104,6 @@
 
 #include <asm/io.h>
 
-#include "opti621.h"
-
 #define OPTI621_MAX_PIO 3
 /* In fact, I do not have any PIO 4 drive
  * (address: 25 ns, data: 70 ns, recovery: 35 ns),
@@ -348,15 +346,27 @@
 	hwif->drives[1].autodma = hwif->autodma;
 }
 
-static void __init init_setup_opti621 (struct pci_dev *dev, ide_pci_device_t *d)
-{
-	ide_setup_pci_device(dev, d);
-}
+static ide_pci_device_t opti621_chipsets[] __devinitdata = {
+	{	/* 0 */
+		.name		= "OPTI621",
+		.init_hwif	= init_hwif_opti621,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x45,0x80,0x00}, {0x40,0x08,0x00}},
+		.bootable	= ON_BOARD,
+	},{	/* 1 */
+		.name		= "OPTI621X",
+		.init_hwif	= init_hwif_opti621,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.enablebits	= {{0x45,0x80,0x00}, {0x40,0x08,0x00}},
+		.bootable	= ON_BOARD,
+	}
+};
 
 static int __devinit opti621_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &opti621_chipsets[id->driver_data]);
-	return 0;
+	return ide_setup_pci_device(dev, &opti621_chipsets[id->driver_data]);
 }
 
 static struct pci_device_id opti621_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/opti621.h linuxppc-2.6.9-dream/drivers/ide/pci/opti621.h
--- linuxppc-2.6.9/drivers/ide/pci/opti621.h	2004-10-18 23:55:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/opti621.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-#ifndef OPTI621_H
-#define OPTI621_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-static void init_setup_opti621(struct pci_dev *, ide_pci_device_t *);
-static void init_hwif_opti621(ide_hwif_t *);
-
-static ide_pci_device_t opti621_chipsets[] __devinitdata = {
-	{	/* 0 */
-		.name		= "OPTI621",
-		.init_setup	= init_setup_opti621,
-		.init_hwif	= init_hwif_opti621,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.enablebits	= {{0x45,0x80,0x00}, {0x40,0x08,0x00}},
-		.bootable	= ON_BOARD,
-	},{	/* 1 */
-		.name		= "OPTI621X",
-		.init_setup	= init_setup_opti621,
-		.init_hwif	= init_hwif_opti621,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.enablebits	= {{0x45,0x80,0x00}, {0x40,0x08,0x00}},
-		.bootable	= ON_BOARD,
-	}
-};
-
-#endif /* OPTI621_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/pdc202xx_new.c linuxppc-2.6.9-dream/drivers/ide/pci/pdc202xx_new.c
--- linuxppc-2.6.9/drivers/ide/pci/pdc202xx_new.c	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/pdc202xx_new.c	2005-06-20 10:46:11.000000000 +0200
@@ -37,64 +37,45 @@
 #include <asm/pci-bridge.h>
 #endif
 
-#include "pdc202xx_new.h"
-
 #define PDC202_DEBUG_CABLE	0
 
-#if defined(DISPLAY_PDC202XX_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 pdcnew_proc = 0;
-#define PDC202_MAX_DEVS		5
-static struct pci_dev *pdc202_devs[PDC202_MAX_DEVS];
-static int n_pdc202_devs;
-
-static char * pdcnew_info(char *buf, struct pci_dev *dev)
-{
-	char *p = buf;
-
-	p += sprintf(p, "\n                                ");
-	switch(dev->device) {
-		case PCI_DEVICE_ID_PROMISE_20277:
-			p += sprintf(p, "SBFastTrak 133 Lite"); break;
-		case PCI_DEVICE_ID_PROMISE_20276:
-			p += sprintf(p, "MBFastTrak 133 Lite"); break;
-		case PCI_DEVICE_ID_PROMISE_20275:
-			p += sprintf(p, "MBUltra133"); break;
-		case PCI_DEVICE_ID_PROMISE_20271:
-			p += sprintf(p, "FastTrak TX2000"); break;
-		case PCI_DEVICE_ID_PROMISE_20270:
-			p += sprintf(p, "FastTrak LP/TX2/TX4"); break;
-		case PCI_DEVICE_ID_PROMISE_20269:
-			p += sprintf(p, "Ultra133 TX2"); break;
-		case PCI_DEVICE_ID_PROMISE_20268:
-			p += sprintf(p, "Ultra100 TX2"); break;
-		default:
-			p += sprintf(p, "Ultra series"); break;
-			break;
-	}
-	p += sprintf(p, " Chipset.\n");
-	return (char *)p;
-}
-
-static int pdcnew_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	int i, len;
-
-	for (i = 0; i < n_pdc202_devs; i++) {
-		struct pci_dev *dev	= pdc202_devs[i];
-		p = pdcnew_info(buffer, dev);
-	}
-	/* p - buffer must be less than 4k! */
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif  /* defined(DISPLAY_PDC202XX_TIMINGS) && defined(CONFIG_PROC_FS) */
+const static char *pdc_quirk_drives[] = {
+	"QUANTUM FIREBALLlct08 08",
+	"QUANTUM FIREBALLP KA6.4",
+	"QUANTUM FIREBALLP KA9.1",
+	"QUANTUM FIREBALLP LM20.4",
+	"QUANTUM FIREBALLP KX13.6",
+	"QUANTUM FIREBALLP KX20.5",
+	"QUANTUM FIREBALLP KX27.3",
+	"QUANTUM FIREBALLP LM20.5",
+	NULL
+};
 
+#define set_2regs(a, b)					\
+	do {						\
+		hwif->OUTB((a + adj), indexreg);	\
+		hwif->OUTB(b, datareg);			\
+	} while(0)
+
+#define set_ultra(a, b, c)				\
+	do {						\
+		set_2regs(0x10,(a));			\
+		set_2regs(0x11,(b));			\
+		set_2regs(0x12,(c));			\
+	} while(0)
+
+#define set_ata2(a, b)					\
+	do {						\
+		set_2regs(0x0e,(a));			\
+		set_2regs(0x0f,(b));			\
+	} while(0)
+
+#define set_pio(a, b, c)				\
+	do { 						\
+		set_2regs(0x0c,(a));			\
+		set_2regs(0x0d,(b));			\
+		set_2regs(0x13,(c));			\
+	} while(0)
 
 static u8 pdcnew_ratemask (ide_drive_t *drive)
 {
@@ -244,37 +225,16 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			    (id->eide_dma_time < 150)) {
-				goto no_dma_set;
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		hwif->tuneproc(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -310,68 +270,12 @@
 		HWIF(drive)->channel ? "Secondary" : "Primary");
 }
 
-static void pdcnew_reset_host (ide_hwif_t *hwif)
-{
-//	unsigned long high_16	= hwif->dma_base - (8*(hwif->channel));
-	unsigned long high_16	= hwif->dma_master;
-	u8 udma_speed_flag	= hwif->INB(high_16|0x001f);
-
-	hwif->OUTB((udma_speed_flag | 0x10), (high_16|0x001f));
-	mdelay(100);
-	hwif->OUTB((udma_speed_flag & ~0x10), (high_16|0x001f));
-	mdelay(2000);	/* 2 seconds ?! */
-
-	printk(KERN_WARNING "PDC202XX: %s channel reset.\n",
-		hwif->channel ? "Secondary" : "Primary");
-}
-
-void pdcnew_reset (ide_drive_t *drive)
-{
-	ide_hwif_t *hwif	= HWIF(drive);
-	ide_hwif_t *mate	= hwif->mate;
-	
-	pdcnew_reset_host(hwif);
-	pdcnew_reset_host(mate);
-#if 0
-	/*
-	 * FIXME: Have to kick all the drives again :-/
-	 * What a pain in the ACE!
-	 */
-	if (hwif->present) {
-		u16 hunit = 0;
-		for (hunit = 0; hunit < MAX_DRIVES; ++hunit) {
-			ide_drive_t *hdrive = &hwif->drives[hunit];
-			if (hdrive->present) {
-				if (hwif->ide_dma_check)
-					hwif->ide_dma_check(hdrive);
-				else
-					hwif->tuneproc(hdrive, 5);
-			}
-		}
-	}
-	if (mate->present) {
-		u16 munit = 0;
-		for (munit = 0; munit < MAX_DRIVES; ++munit) {
-			ide_drive_t *mdrive = &mate->drives[munit];
-			if (mdrive->present) {
-				if (mate->ide_dma_check) 
-					mate->ide_dma_check(mdrive);
-				else
-					mate->tuneproc(mdrive, 5);
-			}
-		}
-	}
-#else
-	hwif->tuneproc(drive, 5);
-#endif
-}
-
 #ifdef CONFIG_PPC_PMAC
 static void __devinit apple_kiwi_init(struct pci_dev *pdev)
 {
 	struct device_node *np = pci_device_to_OF_node(pdev);
 	unsigned int class_rev = 0;
-	unsigned long mmio;
+	void __iomem *mmio;
 	u8 conf;
 
 	if (np == NULL || !device_is_compatible(np, "kiwi-root"))
@@ -385,7 +289,7 @@
 		pci_read_config_byte(pdev, 0x40, &conf);
 		pci_write_config_byte(pdev, 0x40, conf | 0x01);
 	}
-	mmio = (unsigned long)ioremap(pci_resource_start(pdev, 5),
+	mmio = ioremap(pci_resource_start(pdev, 5),
 				      pci_resource_len(pdev, 5));
 
 	/* Setup some PLL stuffs */
@@ -400,7 +304,7 @@
 		break;
 	}
 
-	iounmap((void *)mmio);
+	iounmap(mmio);
 }
 #endif /* CONFIG_PPC_PMAC */
 
@@ -417,15 +321,6 @@
 	apple_kiwi_init(dev);
 #endif
 
-#if defined(DISPLAY_PDC202XX_TIMINGS) && defined(CONFIG_PROC_FS)
-	pdc202_devs[n_pdc202_devs++] = dev;
-
-	if (!pdcnew_proc) {
-		pdcnew_proc = 1;
-		ide_pci_create_host_proc("pdcnew", pdcnew_get_info);
-	}
-#endif /* DISPLAY_PDC202XX_TIMINGS && CONFIG_PROC_FS */
-
 	return dev->irq;
 }
 
@@ -457,21 +352,21 @@
 #endif /* PDC202_DEBUG_CABLE */
 }
 
-static void __devinit init_setup_pdcnew(struct pci_dev *dev, ide_pci_device_t *d)
+static int __devinit init_setup_pdcnew(struct pci_dev *dev, ide_pci_device_t *d)
 {
-	ide_setup_pci_device(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
-static void __devinit init_setup_pdc20270(struct pci_dev *dev, ide_pci_device_t *d)
+static int __devinit init_setup_pdc20270(struct pci_dev *dev,
+					 ide_pci_device_t *d)
 {
 	struct pci_dev *findev = NULL;
 
 	if ((dev->bus->self &&
 	     dev->bus->self->vendor == PCI_VENDOR_ID_DEC) &&
 	    (dev->bus->self->device == PCI_DEVICE_ID_DEC_21150)) {
-		if (PCI_SLOT(dev->devfn) & 2) {
-			return;
-		}
+		if (PCI_SLOT(dev->devfn) & 2)
+			return -ENODEV;
 		d->extra = 0;
 		while ((findev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, findev)) != NULL) {
 			if ((findev->vendor == dev->vendor) &&
@@ -480,15 +375,15 @@
 				if (findev->irq != dev->irq) {
 					findev->irq = dev->irq;
 				}
-				ide_setup_pci_devices(dev, findev, d);
-				return;
+				return ide_setup_pci_devices(dev, findev, d);
 			}
 		}
 	}
-	ide_setup_pci_device(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
-static void __devinit init_setup_pdc20276(struct pci_dev *dev, ide_pci_device_t *d)
+static int __devinit init_setup_pdc20276(struct pci_dev *dev,
+					 ide_pci_device_t *d)
 {
 	if ((dev->bus->self) &&
 	    (dev->bus->self->vendor == PCI_VENDOR_ID_INTEL) &&
@@ -496,11 +391,77 @@
 	     (dev->bus->self->device == PCI_DEVICE_ID_INTEL_I960RM))) {
 		printk(KERN_INFO "ide: Skipping Promise PDC20276 "
 			"attached to I2O RAID controller.\n");
-		return;
+		return -ENODEV;
 	}
-	ide_setup_pci_device(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
+static ide_pci_device_t pdcnew_chipsets[] __devinitdata = {
+	{	/* 0 */
+		.name		= "PDC20268",
+		.init_setup	= init_setup_pdcnew,
+		.init_chipset	= init_chipset_pdcnew,
+		.init_hwif	= init_hwif_pdc202new,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+	},{	/* 1 */
+		.name		= "PDC20269",
+		.init_setup	= init_setup_pdcnew,
+		.init_chipset	= init_chipset_pdcnew,
+		.init_hwif	= init_hwif_pdc202new,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+	},{	/* 2 */
+		.name		= "PDC20270",
+		.init_setup	= init_setup_pdc20270,
+		.init_chipset	= init_chipset_pdcnew,
+		.init_hwif	= init_hwif_pdc202new,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+#ifndef CONFIG_PDC202XX_FORCE
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
+#endif
+		.bootable	= OFF_BOARD,
+	},{	/* 3 */
+		.name		= "PDC20271",
+		.init_setup	= init_setup_pdcnew,
+		.init_chipset	= init_chipset_pdcnew,
+		.init_hwif	= init_hwif_pdc202new,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+	},{	/* 4 */
+		.name		= "PDC20275",
+		.init_setup	= init_setup_pdcnew,
+		.init_chipset	= init_chipset_pdcnew,
+		.init_hwif	= init_hwif_pdc202new,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+	},{	/* 5 */
+		.name		= "PDC20276",
+		.init_setup	= init_setup_pdc20276,
+		.init_chipset	= init_chipset_pdcnew,
+		.init_hwif	= init_hwif_pdc202new,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+#ifndef CONFIG_PDC202XX_FORCE
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
+#endif
+		.bootable	= OFF_BOARD,
+	},{	/* 6 */
+		.name		= "PDC20277",
+		.init_setup	= init_setup_pdcnew,
+		.init_chipset	= init_chipset_pdcnew,
+		.init_hwif	= init_hwif_pdc202new,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= OFF_BOARD,
+	}
+};
+
 /**
  *	pdc202new_init_one	-	called when a pdc202xx is found
  *	@dev: the pdc202new device
@@ -514,8 +475,7 @@
 {
 	ide_pci_device_t *d = &pdcnew_chipsets[id->driver_data];
 
-	d->init_setup(dev, d);
-	return 0;
+	return d->init_setup(dev, d);
 }
 
 static struct pci_device_id pdc202new_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/pdc202xx_new.h linuxppc-2.6.9-dream/drivers/ide/pci/pdc202xx_new.h
--- linuxppc-2.6.9/drivers/ide/pci/pdc202xx_new.h	2004-10-18 23:53:11.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/pdc202xx_new.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,120 +0,0 @@
-#ifndef PDC202XX_H
-#define PDC202XX_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-const static char *pdc_quirk_drives[] = {
-	"QUANTUM FIREBALLlct08 08",
-	"QUANTUM FIREBALLP KA6.4",
-	"QUANTUM FIREBALLP KA9.1",
-	"QUANTUM FIREBALLP LM20.4",
-	"QUANTUM FIREBALLP KX13.6",
-	"QUANTUM FIREBALLP KX20.5",
-	"QUANTUM FIREBALLP KX27.3",
-	"QUANTUM FIREBALLP LM20.5",
-	NULL
-};
-
-#define set_2regs(a, b)					\
-	do {						\
-		hwif->OUTB((a + adj), indexreg);	\
-		hwif->OUTB(b, datareg);			\
-	} while(0)
-
-#define set_ultra(a, b, c)				\
-	do {						\
-		set_2regs(0x10,(a));			\
-		set_2regs(0x11,(b));			\
-		set_2regs(0x12,(c));			\
-	} while(0)
-
-#define set_ata2(a, b)					\
-	do {						\
-		set_2regs(0x0e,(a));			\
-		set_2regs(0x0f,(b));			\
-	} while(0)
-
-#define set_pio(a, b, c)				\
-	do { 						\
-		set_2regs(0x0c,(a));			\
-		set_2regs(0x0d,(b));			\
-		set_2regs(0x13,(c));			\
-	} while(0)
-
-#define DISPLAY_PDC202XX_TIMINGS
-
-static void init_setup_pdcnew(struct pci_dev *, ide_pci_device_t *);
-static void init_setup_pdc20270(struct pci_dev *, ide_pci_device_t *);
-static void init_setup_pdc20276(struct pci_dev *dev, ide_pci_device_t *d);
-static unsigned int init_chipset_pdcnew(struct pci_dev *, const char *);
-static void init_hwif_pdc202new(ide_hwif_t *);
-
-static ide_pci_device_t pdcnew_chipsets[] __devinitdata = {
-	{	/* 0 */
-		.name		= "PDC20268",
-		.init_setup	= init_setup_pdcnew,
-		.init_chipset	= init_chipset_pdcnew,
-		.init_hwif	= init_hwif_pdc202new,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-	},{	/* 1 */
-		.name		= "PDC20269",
-		.init_setup	= init_setup_pdcnew,
-		.init_chipset	= init_chipset_pdcnew,
-		.init_hwif	= init_hwif_pdc202new,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-	},{	/* 2 */
-		.name		= "PDC20270",
-		.init_setup	= init_setup_pdc20270,
-		.init_chipset	= init_chipset_pdcnew,
-		.init_hwif	= init_hwif_pdc202new,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
-		.bootable	= OFF_BOARD,
-	},{	/* 3 */
-		.name		= "PDC20271",
-		.init_setup	= init_setup_pdcnew,
-		.init_chipset	= init_chipset_pdcnew,
-		.init_hwif	= init_hwif_pdc202new,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-	},{	/* 4 */
-		.name		= "PDC20275",
-		.init_setup	= init_setup_pdcnew,
-		.init_chipset	= init_chipset_pdcnew,
-		.init_hwif	= init_hwif_pdc202new,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-	},{	/* 5 */
-		.name		= "PDC20276",
-		.init_setup	= init_setup_pdc20276,
-		.init_chipset	= init_chipset_pdcnew,
-		.init_hwif	= init_hwif_pdc202new,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
-		.bootable	= OFF_BOARD,
-	},{	/* 6 */
-		.name		= "PDC20277",
-		.init_setup	= init_setup_pdcnew,
-		.init_chipset	= init_chipset_pdcnew,
-		.init_hwif	= init_hwif_pdc202new,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= OFF_BOARD,
-	}
-};
-
-#endif /* PDC202XX_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/pdc202xx_old.c linuxppc-2.6.9-dream/drivers/ide/pci/pdc202xx_old.c
--- linuxppc-2.6.9/drivers/ide/pci/pdc202xx_old.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/pdc202xx_old.c	2005-06-20 10:46:11.000000000 +0200
@@ -46,72 +46,69 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-#include "pdc202xx_old.h"
+#define PDC202_DEBUG_CABLE		0
+#define PDC202XX_DEBUG_DRIVE_INFO	0
 
-#define PDC202_DEBUG_CABLE	0
-
-#if defined(DISPLAY_PDC202XX_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
+static const char *pdc_quirk_drives[] = {
+	"QUANTUM FIREBALLlct08 08",
+	"QUANTUM FIREBALLP KA6.4",
+	"QUANTUM FIREBALLP KA9.1",
+	"QUANTUM FIREBALLP LM20.4",
+	"QUANTUM FIREBALLP KX13.6",
+	"QUANTUM FIREBALLP KX20.5",
+	"QUANTUM FIREBALLP KX27.3",
+	"QUANTUM FIREBALLP LM20.5",
+	NULL
+};
 
-static u8 pdc202xx_proc = 0;
-#define PDC202_MAX_DEVS		5
-static struct pci_dev *pdc202_devs[PDC202_MAX_DEVS];
-static int n_pdc202_devs;
+/* A Register */
+#define	SYNC_ERRDY_EN	0xC0
 
-static char * pdc202xx_info (char *buf, struct pci_dev *dev)
-{
-	char *p = buf;
+#define	SYNC_IN		0x80	/* control bit, different for master vs. slave drives */
+#define	ERRDY_EN	0x40	/* control bit, different for master vs. slave drives */
+#define	IORDY_EN	0x20	/* PIO: IOREADY */
+#define	PREFETCH_EN	0x10	/* PIO: PREFETCH */
+
+#define	PA3		0x08	/* PIO"A" timing */
+#define	PA2		0x04	/* PIO"A" timing */
+#define	PA1		0x02	/* PIO"A" timing */
+#define	PA0		0x01	/* PIO"A" timing */
+
+/* B Register */
+
+#define	MB2		0x80	/* DMA"B" timing */
+#define	MB1		0x40	/* DMA"B" timing */
+#define	MB0		0x20	/* DMA"B" timing */
+
+#define	PB4		0x10	/* PIO_FORCE 1:0 */
+
+#define	PB3		0x08	/* PIO"B" timing */	/* PIO flow Control mode */
+#define	PB2		0x04	/* PIO"B" timing */	/* PIO 4 */
+#define	PB1		0x02	/* PIO"B" timing */	/* PIO 3 half */
+#define	PB0		0x01	/* PIO"B" timing */	/* PIO 3 other half */
+
+/* C Register */
+#define	IORDYp_NO_SPEED	0x4F
+#define	SPEED_DIS	0x0F
+
+#define	DMARQp		0x80
+#define	IORDYp		0x40
+#define	DMAR_EN		0x20
+#define	DMAW_EN		0x10
+
+#define	MC3		0x08	/* DMA"C" timing */
+#define	MC2		0x04	/* DMA"C" timing */
+#define	MC1		0x02	/* DMA"C" timing */
+#define	MC0		0x01	/* DMA"C" timing */
 
+#if 0
 	unsigned long bibma  = pci_resource_start(dev, 4);
-	u32 reg60h = 0, reg64h = 0, reg68h = 0, reg6ch = 0;
-	u16 reg50h = 0, pmask = (1<<10), smask = (1<<11);
 	u8 hi = 0, lo = 0;
 
-        /*
-         * at that point bibma+0x2 et bibma+0xa are byte registers
-         * to investigate:
-         */
-	u8 c0	= inb_p((u16)bibma + 0x02);
-	u8 c1	= inb_p((u16)bibma + 0x0a);
-
-	u8 sc11	= inb_p((u16)bibma + 0x11);
-	u8 sc1a	= inb_p((u16)bibma + 0x1a);
-	u8 sc1b	= inb_p((u16)bibma + 0x1b);
 	u8 sc1c	= inb_p((u16)bibma + 0x1c); 
-	u8 sc1d	= inb_p((u16)bibma + 0x1d);
 	u8 sc1e	= inb_p((u16)bibma + 0x1e);
 	u8 sc1f	= inb_p((u16)bibma + 0x1f);
 
-	pci_read_config_word(dev, 0x50, &reg50h);
-	pci_read_config_dword(dev, 0x60, &reg60h);
-	pci_read_config_dword(dev, 0x64, &reg64h);
-	pci_read_config_dword(dev, 0x68, &reg68h);
-	pci_read_config_dword(dev, 0x6c, &reg6ch);
-
-	p += sprintf(p, "\n                                ");
-	switch(dev->device) {
-		case PCI_DEVICE_ID_PROMISE_20267:
-			p += sprintf(p, "Ultra100"); break;
-		case PCI_DEVICE_ID_PROMISE_20265:
-			p += sprintf(p, "Ultra100 on M/B"); break;
-		case PCI_DEVICE_ID_PROMISE_20263:
-			p += sprintf(p, "FastTrak 66"); break;
-		case PCI_DEVICE_ID_PROMISE_20262:
-			p += sprintf(p, "Ultra66"); break;
-		case PCI_DEVICE_ID_PROMISE_20246:
-			p += sprintf(p, "Ultra33");
-			reg50h |= 0x0c00;
-			break;
-		default:
-			p += sprintf(p, "Ultra Series"); break;
-	}
-	p += sprintf(p, " Chipset.\n");
-
-	p += sprintf(p, "------------------------------- General Status "
-			"---------------------------------\n");
-	p += sprintf(p, "Burst Mode                           : %sabled\n",
-		(sc1f & 0x01) ? "en" : "dis");
 	p += sprintf(p, "Host Mode                            : %s\n",
 		(sc1f & 0x08) ? "Tri-Stated" : "Normal");
 	p += sprintf(p, "Bus Clocking                         : %s\n",
@@ -123,73 +120,11 @@
 		((sc1c & 0x02) == 0x02) ? "8" :
 		((sc1c & 0x01) == 0x01) ? "6" :
 		((sc1c & 0x00) == 0x00) ? "4" : "??");
-	SPLIT_BYTE(sc1e, hi, lo);
+	hi = sc1e >> 4;
+	lo = sc1e & 0xf;
 	p += sprintf(p, "Status Polling Period                : %d\n", hi);
 	p += sprintf(p, "Interrupt Check Status Polling Delay : %d\n", lo);
-	p += sprintf(p, "--------------- Primary Channel "
-			"---------------- Secondary Channel "
-			"-------------\n");
-	p += sprintf(p, "                %s                         %s\n",
-		(c0&0x80)?"disabled":"enabled ",
-		(c1&0x80)?"disabled":"enabled ");
-	p += sprintf(p, "66 Clocking     %s                         %s\n",
-		(sc11&0x02)?"enabled ":"disabled",
-		(sc11&0x08)?"enabled ":"disabled");
-	p += sprintf(p, "           Mode %s                      Mode %s\n",
-		(sc1a & 0x01) ? "MASTER" : "PCI   ",
-		(sc1b & 0x01) ? "MASTER" : "PCI   ");
-	p += sprintf(p, "                %s                     %s\n",
-		(sc1d & 0x08) ? "Error       " :
-		((sc1d & 0x05) == 0x05) ? "Not My INTR " :
-		(sc1d & 0x04) ? "Interrupting" :
-		(sc1d & 0x02) ? "FIFO Full   " :
-		(sc1d & 0x01) ? "FIFO Empty  " : "????????????",
-		(sc1d & 0x80) ? "Error       " :
-		((sc1d & 0x50) == 0x50) ? "Not My INTR " :
-		(sc1d & 0x40) ? "Interrupting" :
-		(sc1d & 0x20) ? "FIFO Full   " :
-		(sc1d & 0x10) ? "FIFO Empty  " : "????????????");
-	p += sprintf(p, "--------------- drive0 --------- drive1 "
-			"-------- drive0 ---------- drive1 ------\n");
-	p += sprintf(p, "DMA enabled:    %s              %s "
-			"            %s               %s\n",
-		(c0&0x20)?"yes":"no ", (c0&0x40)?"yes":"no ",
-		(c1&0x20)?"yes":"no ", (c1&0x40)?"yes":"no ");
-	p += sprintf(p, "DMA Mode:       %s           %s "
-			"         %s            %s\n",
-		pdc202xx_ultra_verbose(reg60h, (reg50h & pmask)),
-		pdc202xx_ultra_verbose(reg64h, (reg50h & pmask)),
-		pdc202xx_ultra_verbose(reg68h, (reg50h & smask)),
-		pdc202xx_ultra_verbose(reg6ch, (reg50h & smask)));
-	p += sprintf(p, "PIO Mode:       %s            %s "
-			"          %s            %s\n",
-		pdc202xx_pio_verbose(reg60h),
-		pdc202xx_pio_verbose(reg64h),
-		pdc202xx_pio_verbose(reg68h),
-		pdc202xx_pio_verbose(reg6ch));
-#if 0
-	p += sprintf(p, "--------------- Can ATAPI DMA ---------------\n");
 #endif
-	return (char *)p;
-}
-
-static int pdc202xx_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	int i, len;
-
-	for (i = 0; i < n_pdc202_devs; i++) {
-		struct pci_dev *dev	= pdc202_devs[i];
-		p = pdc202xx_info(buffer, dev);
-	}
-	/* p - buffer must be less than 4k! */
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif  /* defined(DISPLAY_PDC202XX_TIMINGS) && defined(CONFIG_PROC_FS) */
-
 
 static u8 pdc202xx_ratemask (ide_drive_t *drive)
 {
@@ -347,7 +282,7 @@
 {
 	u16 CIS = 0, mask = (hwif->channel) ? (1<<11) : (1<<10);
 	pci_read_config_word(hwif->pci_dev, 0x50, &CIS);
-	return ((u8)(CIS & mask));
+	return (CIS & mask) ? 1 : 0;
 }
 
 /*
@@ -451,37 +386,16 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			    (id->eide_dma_time < 150)) {
-				goto no_dma_set;
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		hwif->tuneproc(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -494,7 +408,7 @@
 	return ((int) check_in_drive_lists(drive, pdc_quirk_drives));
 }
 
-static int pdc202xx_old_ide_dma_begin(ide_drive_t *drive)
+static void pdc202xx_old_ide_dma_start(ide_drive_t *drive)
 {
 	if (drive->current_speed > XFER_UDMA_2)
 		pdc_old_enable_66MHz_clock(drive->hwif);
@@ -515,7 +429,7 @@
 					word_count | 0x06000000;
 		hwif->OUTL(word_count, atapi_reg);
 	}
-	return __ide_dma_begin(drive);
+	ide_dma_start(drive);
 }
 
 static int pdc202xx_old_ide_dma_end(ide_drive_t *drive)
@@ -546,11 +460,13 @@
 	u8 sc1d			= hwif->INB((high_16 + 0x001d));
 
 	if (hwif->channel) {
+		/* bit7: Error, bit6: Interrupting, bit5: FIFO Full, bit4: FIFO Empty */
 		if ((sc1d & 0x50) == 0x50)
 			goto somebody_else;
 		else if ((sc1d & 0x40) == 0x40)
 			return (dma_stat & 4) == 4;
 	} else {
+		/* bit3: Error, bit2: Interrupting, bit1: FIFO Full, bit0: FIFO Empty */
 		if ((sc1d & 0x05) == 0x05)
 			goto somebody_else;
 		else if ((sc1d & 0x04) == 0x04)
@@ -593,7 +509,7 @@
 		hwif->channel ? "Secondary" : "Primary");
 }
 
-void pdc202xx_reset (ide_drive_t *drive)
+static void pdc202xx_reset (ide_drive_t *drive)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	ide_hwif_t *mate	= hwif->mate;
@@ -668,15 +584,6 @@
 			name, dev->resource[PCI_ROM_RESOURCE].start);
 	}
 
-#if defined(DISPLAY_PDC202XX_TIMINGS) && defined(CONFIG_PROC_FS)
-	pdc202_devs[n_pdc202_devs++] = dev;
-
-	if (!pdc202xx_proc) {
-		pdc202xx_proc = 1;
-		ide_pci_create_host_proc("pdc202xx", pdc202xx_get_info);
-	}
-#endif /* DISPLAY_PDC202XX_TIMINGS && CONFIG_PROC_FS */
-
 	/*
 	 * software reset -  this is required because the bios
 	 * will set UDMA timing on if the hdd supports it. The
@@ -709,7 +616,8 @@
 	struct pci_dev *dev = hwif->pci_dev;
 
 	/* PDC20265 has problems with large LBA48 requests */
-	if (dev->device == PCI_DEVICE_ID_PROMISE_20265)
+	if ((dev->device == PCI_DEVICE_ID_PROMISE_20267) ||
+	    (dev->device == PCI_DEVICE_ID_PROMISE_20265))
 		hwif->rqsize = 256;
 
 	hwif->autodma = 0;
@@ -736,7 +644,7 @@
 	if (hwif->pci_dev->device != PCI_DEVICE_ID_PROMISE_20246) {
 		if (!(hwif->udma_four))
 			hwif->udma_four = (pdc202xx_old_cable_detect(hwif)) ? 0 : 1;
-		hwif->ide_dma_begin = &pdc202xx_old_ide_dma_begin;
+		hwif->dma_start = &pdc202xx_old_ide_dma_start;
 		hwif->ide_dma_end = &pdc202xx_old_ide_dma_end;
 	} 
 	hwif->ide_dma_test_irq = &pdc202xx_old_ide_dma_test_irq;
@@ -802,7 +710,8 @@
 	ide_setup_dma(hwif, dmabase, 8);
 }
 
-static void __devinit init_setup_pdc202ata4(struct pci_dev *dev, ide_pci_device_t *d)
+static int __devinit init_setup_pdc202ata4(struct pci_dev *dev,
+					   ide_pci_device_t *d)
 {
 	if ((dev->class >> 8) != PCI_CLASS_STORAGE_IDE) {
 		u8 irq = 0, irq2 = 0;
@@ -829,10 +738,11 @@
         }
 #endif
 
-	ide_setup_pci_device(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
-static void __devinit init_setup_pdc20265(struct pci_dev *dev, ide_pci_device_t *d)
+static int __devinit init_setup_pdc20265(struct pci_dev *dev,
+					 ide_pci_device_t *d)
 {
 	if ((dev->bus->self) &&
 	    (dev->bus->self->vendor == PCI_VENDOR_ID_INTEL) &&
@@ -840,7 +750,7 @@
 	     (dev->bus->self->device == PCI_DEVICE_ID_INTEL_I960RM))) {
 		printk(KERN_INFO "ide: Skipping Promise PDC20265 "
 			"attached to I2O RAID controller.\n");
-		return;
+		return -ENODEV;
 	}
 
 #if 0
@@ -858,14 +768,86 @@
         }
 #endif
 
-	ide_setup_pci_device(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
-static void __devinit init_setup_pdc202xx(struct pci_dev *dev, ide_pci_device_t *d)
+static int __devinit init_setup_pdc202xx(struct pci_dev *dev,
+					 ide_pci_device_t *d)
 {
-	ide_setup_pci_device(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
+static ide_pci_device_t pdc202xx_chipsets[] __devinitdata = {
+	{	/* 0 */
+		.name		= "PDC20246",
+		.init_setup	= init_setup_pdc202ata4,
+		.init_chipset	= init_chipset_pdc202xx,
+		.init_hwif	= init_hwif_pdc202xx,
+		.init_dma	= init_dma_pdc202xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+#ifndef CONFIG_PDC202XX_FORCE
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
+#endif
+		.bootable	= OFF_BOARD,
+		.extra		= 16,
+	},{	/* 1 */
+		.name		= "PDC20262",
+		.init_setup	= init_setup_pdc202ata4,
+		.init_chipset	= init_chipset_pdc202xx,
+		.init_hwif	= init_hwif_pdc202xx,
+		.init_dma	= init_dma_pdc202xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+#ifndef CONFIG_PDC202XX_FORCE
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
+#endif
+		.bootable	= OFF_BOARD,
+		.extra		= 48,
+		.flags		= IDEPCI_FLAG_FORCE_PDC,
+	},{	/* 2 */
+		.name		= "PDC20263",
+		.init_setup	= init_setup_pdc202ata4,
+		.init_chipset	= init_chipset_pdc202xx,
+		.init_hwif	= init_hwif_pdc202xx,
+		.init_dma	= init_dma_pdc202xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+#ifndef CONFIG_PDC202XX_FORCE
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
+#endif
+		.bootable	= OFF_BOARD,
+		.extra		= 48,
+	},{	/* 3 */
+		.name		= "PDC20265",
+		.init_setup	= init_setup_pdc20265,
+		.init_chipset	= init_chipset_pdc202xx,
+		.init_hwif	= init_hwif_pdc202xx,
+		.init_dma	= init_dma_pdc202xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+#ifndef CONFIG_PDC202XX_FORCE
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
+#endif
+		.bootable	= OFF_BOARD,
+		.extra		= 48,
+		.flags		= IDEPCI_FLAG_FORCE_PDC,
+	},{	/* 4 */
+		.name		= "PDC20267",
+		.init_setup	= init_setup_pdc202xx,
+		.init_chipset	= init_chipset_pdc202xx,
+		.init_hwif	= init_hwif_pdc202xx,
+		.init_dma	= init_dma_pdc202xx,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+#ifndef CONFIG_PDC202XX_FORCE
+		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
+#endif
+		.bootable	= OFF_BOARD,
+		.extra		= 48,
+	}
+};
+
 /**
  *	pdc202xx_init_one	-	called when a PDC202xx is found
  *	@dev: the pdc202xx device
@@ -879,8 +861,7 @@
 {
 	ide_pci_device_t *d = &pdc202xx_chipsets[id->driver_data];
 
-	d->init_setup(dev, d);
-	return 0;
+	return d->init_setup(dev, d);
 }
 
 static struct pci_device_id pdc202xx_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/pdc202xx_old.h linuxppc-2.6.9-dream/drivers/ide/pci/pdc202xx_old.h
--- linuxppc-2.6.9/drivers/ide/pci/pdc202xx_old.h	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/pdc202xx_old.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,181 +0,0 @@
-#ifndef PDC202XX_H
-#define PDC202XX_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-#ifndef SPLIT_BYTE
-#define SPLIT_BYTE(B,H,L)	((H)=(B>>4), (L)=(B-((B>>4)<<4)))
-#endif
-
-#define PDC202XX_DEBUG_DRIVE_INFO		0
-
-static const char *pdc_quirk_drives[] = {
-	"QUANTUM FIREBALLlct08 08",
-	"QUANTUM FIREBALLP KA6.4",
-	"QUANTUM FIREBALLP KA9.1",
-	"QUANTUM FIREBALLP LM20.4",
-	"QUANTUM FIREBALLP KX13.6",
-	"QUANTUM FIREBALLP KX20.5",
-	"QUANTUM FIREBALLP KX27.3",
-	"QUANTUM FIREBALLP LM20.5",
-	NULL
-};
-
-static inline u8 *pdc202xx_pio_verbose (u32 drive_pci)
-{
-	if ((drive_pci & 0x000ff000) == 0x000ff000) return("NOTSET");
-	if ((drive_pci & 0x00000401) == 0x00000401) return("PIO 4");
-	if ((drive_pci & 0x00000602) == 0x00000602) return("PIO 3");
-	if ((drive_pci & 0x00000803) == 0x00000803) return("PIO 2");
-	if ((drive_pci & 0x00000C05) == 0x00000C05) return("PIO 1");
-	if ((drive_pci & 0x00001309) == 0x00001309) return("PIO 0");
-	return("PIO ?");
-}
-
-static inline u8 *pdc202xx_dma_verbose (u32 drive_pci)
-{
-	if ((drive_pci & 0x00036000) == 0x00036000) return("MWDMA 2");
-	if ((drive_pci & 0x00046000) == 0x00046000) return("MWDMA 1");
-	if ((drive_pci & 0x00056000) == 0x00056000) return("MWDMA 0");
-	if ((drive_pci & 0x00056000) == 0x00056000) return("SWDMA 2");
-	if ((drive_pci & 0x00068000) == 0x00068000) return("SWDMA 1");
-	if ((drive_pci & 0x000BC000) == 0x000BC000) return("SWDMA 0");
-	return("PIO---");
-}
-
-static inline u8 *pdc202xx_ultra_verbose (u32 drive_pci, u16 slow_cable)
-{
-	if ((drive_pci & 0x000ff000) == 0x000ff000)
-		return("NOTSET");
-	if ((drive_pci & 0x00012000) == 0x00012000)
-		return((slow_cable) ? "UDMA 2" : "UDMA 4");
-	if ((drive_pci & 0x00024000) == 0x00024000)
-		return((slow_cable) ? "UDMA 1" : "UDMA 3");
-	if ((drive_pci & 0x00036000) == 0x00036000)
-		return("UDMA 0");
-	return(pdc202xx_dma_verbose(drive_pci));
-}
-
-/* A Register */
-#define	SYNC_ERRDY_EN	0xC0
-
-#define	SYNC_IN		0x80	/* control bit, different for master vs. slave drives */
-#define	ERRDY_EN	0x40	/* control bit, different for master vs. slave drives */
-#define	IORDY_EN	0x20	/* PIO: IOREADY */
-#define	PREFETCH_EN	0x10	/* PIO: PREFETCH */
-
-#define	PA3		0x08	/* PIO"A" timing */
-#define	PA2		0x04	/* PIO"A" timing */
-#define	PA1		0x02	/* PIO"A" timing */
-#define	PA0		0x01	/* PIO"A" timing */
-
-/* B Register */
-
-#define	MB2		0x80	/* DMA"B" timing */
-#define	MB1		0x40	/* DMA"B" timing */
-#define	MB0		0x20	/* DMA"B" timing */
-
-#define	PB4		0x10	/* PIO_FORCE 1:0 */
-
-#define	PB3		0x08	/* PIO"B" timing */	/* PIO flow Control mode */
-#define	PB2		0x04	/* PIO"B" timing */	/* PIO 4 */
-#define	PB1		0x02	/* PIO"B" timing */	/* PIO 3 half */
-#define	PB0		0x01	/* PIO"B" timing */	/* PIO 3 other half */
-
-/* C Register */
-#define	IORDYp_NO_SPEED	0x4F
-#define	SPEED_DIS	0x0F
-
-#define	DMARQp		0x80
-#define	IORDYp		0x40
-#define	DMAR_EN		0x20
-#define	DMAW_EN		0x10
-
-#define	MC3		0x08	/* DMA"C" timing */
-#define	MC2		0x04	/* DMA"C" timing */
-#define	MC1		0x02	/* DMA"C" timing */
-#define	MC0		0x01	/* DMA"C" timing */
-
-#define DISPLAY_PDC202XX_TIMINGS
-
-static void init_setup_pdc202ata4(struct pci_dev *dev, ide_pci_device_t *d);
-static void init_setup_pdc20265(struct pci_dev *, ide_pci_device_t *);
-static void init_setup_pdc202xx(struct pci_dev *, ide_pci_device_t *);
-static unsigned int init_chipset_pdc202xx(struct pci_dev *, const char *);
-static void init_hwif_pdc202xx(ide_hwif_t *);
-static void init_dma_pdc202xx(ide_hwif_t *, unsigned long);
-
-static ide_pci_device_t pdc202xx_chipsets[] __devinitdata = {
-	{	/* 0 */
-		.name		= "PDC20246",
-		.init_setup	= init_setup_pdc202ata4,
-		.init_chipset	= init_chipset_pdc202xx,
-		.init_hwif	= init_hwif_pdc202xx,
-		.init_dma	= init_dma_pdc202xx,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
-		.bootable	= OFF_BOARD,
-		.extra		= 16,
-	},{	/* 1 */
-		.name		= "PDC20262",
-		.init_setup	= init_setup_pdc202ata4,
-		.init_chipset	= init_chipset_pdc202xx,
-		.init_hwif	= init_hwif_pdc202xx,
-		.init_dma	= init_dma_pdc202xx,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
-		.bootable	= OFF_BOARD,
-		.extra		= 48,
-		.flags		= IDEPCI_FLAG_FORCE_PDC,
-	},{	/* 2 */
-		.name		= "PDC20263",
-		.init_setup	= init_setup_pdc202ata4,
-		.init_chipset	= init_chipset_pdc202xx,
-		.init_hwif	= init_hwif_pdc202xx,
-		.init_dma	= init_dma_pdc202xx,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
-		.bootable	= OFF_BOARD,
-		.extra		= 48,
-	},{	/* 3 */
-		.name		= "PDC20265",
-		.init_setup	= init_setup_pdc20265,
-		.init_chipset	= init_chipset_pdc202xx,
-		.init_hwif	= init_hwif_pdc202xx,
-		.init_dma	= init_dma_pdc202xx,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
-		.bootable	= OFF_BOARD,
-		.extra		= 48,
-		.flags		= IDEPCI_FLAG_FORCE_PDC,
-	},{	/* 4 */
-		.name		= "PDC20267",
-		.init_setup	= init_setup_pdc202xx,
-		.init_chipset	= init_chipset_pdc202xx,
-		.init_hwif	= init_hwif_pdc202xx,
-		.init_dma	= init_dma_pdc202xx,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
-		.bootable	= OFF_BOARD,
-		.extra		= 48,
-	}
-};
-
-#endif /* PDC202XX_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/piix.c linuxppc-2.6.9-dream/drivers/ide/pci/piix.c
--- linuxppc-2.6.9/drivers/ide/pci/piix.c	2004-10-18 23:53:11.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/piix.c	2005-06-20 10:46:11.000000000 +0200
@@ -103,168 +103,7 @@
 
 #include <asm/io.h>
 
-#include "piix.h"
-
 static int no_piix_dma;
-#if defined(DISPLAY_PIIX_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 piix_proc = 0;
-#define PIIX_MAX_DEVS		5
-static struct pci_dev *piix_devs[PIIX_MAX_DEVS];
-static int n_piix_devs;
-
-/**
- *	piix_get_info		-	fill in /proc for PIIX ide
- *	@buffer: buffer to fill
- *	@addr: address of user start in buffer
- *	@offset: offset into 'file'
- *	@count: buffer count
- *
- *	Walks the PIIX devices and outputs summary data on the tuning and
- *	anything else that will help with debugging
- */
- 
-static int piix_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	int i;
-
-	for (i = 0; i < n_piix_devs; i++) {
-		struct pci_dev *dev	= piix_devs[i];
-		unsigned long bibma = pci_resource_start(dev, 4);
-	        u16 reg40 = 0, psitre = 0, reg42 = 0, ssitre = 0;
-		u8  c0 = 0, c1 = 0, reg54 = 0, reg55 = 0;
-		u8  reg44 = 0, reg48 = 0, reg4a = 0, reg4b = 0;
-
-		p += sprintf(p, "\nController: %d\n", i);
-		p += sprintf(p, "\n                                Intel ");
-		switch(dev->device) {
-			case PCI_DEVICE_ID_INTEL_82801EB_1:
-				p += sprintf(p, "PIIX4 SATA 150 ");
-				break;
-			case PCI_DEVICE_ID_INTEL_82801BA_8:
-			case PCI_DEVICE_ID_INTEL_82801BA_9:
-			case PCI_DEVICE_ID_INTEL_82801CA_10:
-			case PCI_DEVICE_ID_INTEL_82801CA_11:
-			case PCI_DEVICE_ID_INTEL_82801DB_10:
-			case PCI_DEVICE_ID_INTEL_82801DB_11:
-			case PCI_DEVICE_ID_INTEL_82801EB_11:
-			case PCI_DEVICE_ID_INTEL_82801E_11:
-			case PCI_DEVICE_ID_INTEL_ESB_2:
-			case PCI_DEVICE_ID_INTEL_ICH6_19:
-				p += sprintf(p, "PIIX4 Ultra 100 ");
-				break;
-			case PCI_DEVICE_ID_INTEL_82372FB_1:
-			case PCI_DEVICE_ID_INTEL_82801AA_1:
-				p += sprintf(p, "PIIX4 Ultra 66 ");
-				break;
-			case PCI_DEVICE_ID_INTEL_82451NX:
-			case PCI_DEVICE_ID_INTEL_82801AB_1:
-			case PCI_DEVICE_ID_INTEL_82443MX_1:
-			case PCI_DEVICE_ID_INTEL_82371AB:
-				p += sprintf(p, "PIIX4 Ultra 33 ");
-				break;
-			case PCI_DEVICE_ID_INTEL_82371SB_1:
-				p += sprintf(p, "PIIX3 ");
-				break;
-			case PCI_DEVICE_ID_INTEL_82371MX:
-				p += sprintf(p, "MPIIX ");
-				break;
-			case PCI_DEVICE_ID_INTEL_82371FB_1:
-			case PCI_DEVICE_ID_INTEL_82371FB_0:
-			default:
-				p += sprintf(p, "PIIX ");
-				break;
-		}
-		p += sprintf(p, "Chipset.\n");
-
-		if (dev->device == PCI_DEVICE_ID_INTEL_82371MX)
-			continue;
-
-		pci_read_config_word(dev, 0x40, &reg40);
-		pci_read_config_word(dev, 0x42, &reg42);
-		pci_read_config_byte(dev, 0x44, &reg44);
-		pci_read_config_byte(dev, 0x48, &reg48);
-		pci_read_config_byte(dev, 0x4a, &reg4a);
-		pci_read_config_byte(dev, 0x4b, &reg4b);
-		pci_read_config_byte(dev, 0x54, &reg54);
-		pci_read_config_byte(dev, 0x55, &reg55);
-
-		psitre = (reg40 & 0x4000) ? 1 : 0;
-		ssitre = (reg42 & 0x4000) ? 1 : 0;
-
-		/*
-		 * at that point bibma+0x2 et bibma+0xa are byte registers
-		 * to investigate:
-		 */
-		c0 = inb(bibma + 0x02);
-		c1 = inb(bibma + 0x0a);
-
-		p += sprintf(p, "--------------- Primary Channel "
-				"---------------- Secondary Channel "
-				"-------------\n");
-		p += sprintf(p, "                %sabled "
-				"                        %sabled\n",
-				(c0&0x80) ? "dis" : " en",
-				(c1&0x80) ? "dis" : " en");
-		p += sprintf(p, "--------------- drive0 --------- drive1 "
-				"-------- drive0 ---------- drive1 ------\n");
-		p += sprintf(p, "DMA enabled:    %s              %s "
-				"            %s               %s\n",
-				(c0&0x20) ? "yes" : "no ",
-				(c0&0x40) ? "yes" : "no ",
-				(c1&0x20) ? "yes" : "no ",
-				(c1&0x40) ? "yes" : "no " );
-		p += sprintf(p, "UDMA enabled:   %s              %s "
-				"            %s               %s\n",
-				(reg48&0x01) ? "yes" : "no ",
-				(reg48&0x02) ? "yes" : "no ",
-				(reg48&0x04) ? "yes" : "no ",
-				(reg48&0x08) ? "yes" : "no " );
-		p += sprintf(p, "UDMA enabled:   %s                %s "
-				"              %s                 %s\n",
-				((reg54&0x11) &&
-				 (reg55&0x10) && (reg4a&0x01)) ? "5" :
-				((reg54&0x11) && (reg4a&0x02)) ? "4" :
-				((reg54&0x11) && (reg4a&0x01)) ? "3" :
-				(reg4a&0x02) ? "2" :
-				(reg4a&0x01) ? "1" :
-				(reg4a&0x00) ? "0" : "X",
-				((reg54&0x22) &&
-				 (reg55&0x20) && (reg4a&0x10)) ? "5" :
-				((reg54&0x22) && (reg4a&0x20)) ? "4" :
-				((reg54&0x22) && (reg4a&0x10)) ? "3" :
-				(reg4a&0x20) ? "2" :
-				(reg4a&0x10) ? "1" :
-				(reg4a&0x00) ? "0" : "X",
-				((reg54&0x44) &&
-				 (reg55&0x40) && (reg4b&0x03)) ? "5" :
-				((reg54&0x44) && (reg4b&0x02)) ? "4" :
-				((reg54&0x44) && (reg4b&0x01)) ? "3" :
-				(reg4b&0x02) ? "2" :
-				(reg4b&0x01) ? "1" :
-				(reg4b&0x00) ? "0" : "X",
-				((reg54&0x88) &&
-				 (reg55&0x80) && (reg4b&0x30)) ? "5" :
-				((reg54&0x88) && (reg4b&0x20)) ? "4" :
-				((reg54&0x88) && (reg4b&0x10)) ? "3" :
-				(reg4b&0x20) ? "2" :
-				(reg4b&0x10) ? "1" :
-				(reg4b&0x00) ? "0" : "X");
-
-		p += sprintf(p, "UDMA\n");
-		p += sprintf(p, "DMA\n");
-		p += sprintf(p, "PIO\n");
-
-		/*
-		 * FIXME.... Add configuration junk data....blah blah......
-		 */
-	}
-	return p-buffer;	 /* => must be less than 4k! */
-}
-#endif  /* defined(DISPLAY_PIIX_TIMINGS) && defined(CONFIG_PROC_FS) */
 
 /**
  *	piix_ratemask		-	compute rate mask for PIIX IDE
@@ -288,11 +127,13 @@
 		case PCI_DEVICE_ID_INTEL_82801CA_10:
 		case PCI_DEVICE_ID_INTEL_82801CA_11:
 		case PCI_DEVICE_ID_INTEL_82801E_11:
+		case PCI_DEVICE_ID_INTEL_82801DB_1:
 		case PCI_DEVICE_ID_INTEL_82801DB_10:
 		case PCI_DEVICE_ID_INTEL_82801DB_11:
 		case PCI_DEVICE_ID_INTEL_82801EB_11:
 		case PCI_DEVICE_ID_INTEL_ESB_2:
 		case PCI_DEVICE_ID_INTEL_ICH6_19:
+		case PCI_DEVICE_ID_INTEL_ICH7_21:
 			mode = 3;
 			break;
 		/* UDMA 66 capable */
@@ -562,25 +403,11 @@
 
 	if ((id->capability & 1) && drive->autodma) {
 
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-
-		/**
-		 * Try to turn DMA on if:
-		 *  - UDMA or EIDE modes are supported or
-		 *  - drive is a known "good" drive
-		 *
-		 * Checks for best mode supported are down later by
-		 * piix_config_drive_for_dma() -> ide_dma_speed()
-		 */
-		if ((id->field_valid & (4 | 2)) ||
-		    (__ide_dma_good_drive(drive) && id->eide_dma_time < 150)) {
+		if (ide_use_dma(drive)) {
 			if (piix_config_drive_for_dma(drive))
 				return hwif->ide_dma_on(drive);
 		}
 
-		/* For some reason DMA wasn't turned on, so try PIO. */
 		goto fast_ata_pio;
 
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
@@ -612,12 +439,14 @@
 		case PCI_DEVICE_ID_INTEL_82801BA_9:
 		case PCI_DEVICE_ID_INTEL_82801CA_10:
 		case PCI_DEVICE_ID_INTEL_82801CA_11:
+		case PCI_DEVICE_ID_INTEL_82801DB_1:
 		case PCI_DEVICE_ID_INTEL_82801DB_10:
 		case PCI_DEVICE_ID_INTEL_82801DB_11:
 		case PCI_DEVICE_ID_INTEL_82801EB_11:
 		case PCI_DEVICE_ID_INTEL_82801E_11:
 		case PCI_DEVICE_ID_INTEL_ESB_2:
 		case PCI_DEVICE_ID_INTEL_ICH6_19:
+		case PCI_DEVICE_ID_INTEL_ICH7_21:
 		{
 			unsigned int extra = 0;
 			pci_read_config_dword(dev, 0x54, &extra);
@@ -627,14 +456,6 @@
 			break;
 	}
 
-#if defined(DISPLAY_PIIX_TIMINGS) && defined(CONFIG_PROC_FS)
-	piix_devs[n_piix_devs++] = dev;
-
-	if (!piix_proc) {
-		piix_proc = 1;
-		ide_pci_create_host_proc("piix", piix_get_info);
-	}
-#endif /* DISPLAY_PIIX_TIMINGS && CONFIG_PROC_FS */
 	return 0;
 }
 
@@ -707,19 +528,51 @@
 	hwif->drives[0].autodma = hwif->autodma;
 }
 
-/**
- *	init_setup_piix		-	callback for IDE initialize
- *	@dev: PIIX PCI device
- *	@d: IDE pci info
- *
- *	Enable the xp fixup for the PIIX controller and then perform
- *	a standard ide PCI setup
- */
-
-static void __devinit init_setup_piix(struct pci_dev *dev, ide_pci_device_t *d)
-{
-	ide_setup_pci_device(dev, d);
-}
+#define DECLARE_PIIX_DEV(name_str) \
+	{						\
+		.name		= name_str,		\
+		.init_chipset	= init_chipset_piix,	\
+		.init_hwif	= init_hwif_piix,	\
+		.channels	= 2,			\
+		.autodma	= AUTODMA,		\
+		.enablebits	= {{0x41,0x80,0x80}, {0x43,0x80,0x80}}, \
+		.bootable	= ON_BOARD,		\
+	}
+
+static ide_pci_device_t piix_pci_info[] __devinitdata = {
+	/*  0 */ DECLARE_PIIX_DEV("PIIXa"),
+	/*  1 */ DECLARE_PIIX_DEV("PIIXb"),
+
+	{	/* 2 */
+		.name		= "MPIIX",
+		.init_hwif	= init_hwif_piix,
+		.channels	= 2,
+		.autodma	= NODMA,
+		.enablebits	= {{0x6D,0x80,0x80}, {0x6F,0x80,0x80}},
+		.bootable	= ON_BOARD,
+	},
+
+	/*  3 */ DECLARE_PIIX_DEV("PIIX3"),
+	/*  4 */ DECLARE_PIIX_DEV("PIIX4"),
+	/*  5 */ DECLARE_PIIX_DEV("ICH0"),
+	/*  6 */ DECLARE_PIIX_DEV("PIIX4"),
+	/*  7 */ DECLARE_PIIX_DEV("ICH"),
+	/*  8 */ DECLARE_PIIX_DEV("PIIX4"),
+	/*  9 */ DECLARE_PIIX_DEV("PIIX4"),
+	/* 10 */ DECLARE_PIIX_DEV("ICH2"),
+	/* 11 */ DECLARE_PIIX_DEV("ICH2M"),
+	/* 12 */ DECLARE_PIIX_DEV("ICH3M"),
+	/* 13 */ DECLARE_PIIX_DEV("ICH3"),
+	/* 14 */ DECLARE_PIIX_DEV("ICH4"),
+	/* 15 */ DECLARE_PIIX_DEV("ICH5"),
+	/* 16 */ DECLARE_PIIX_DEV("C-ICH"),
+	/* 17 */ DECLARE_PIIX_DEV("ICH4"),
+	/* 18 */ DECLARE_PIIX_DEV("ICH5-SATA"),
+	/* 19 */ DECLARE_PIIX_DEV("ICH5"),
+	/* 20 */ DECLARE_PIIX_DEV("ICH6"),
+	/* 21 */ DECLARE_PIIX_DEV("ICH7"),
+	/* 22 */ DECLARE_PIIX_DEV("ICH4"),
+};
 
 /**
  *	piix_init_one	-	called when a PIIX is found
@@ -734,8 +587,7 @@
 {
 	ide_pci_device_t *d = &piix_pci_info[id->driver_data];
 
-	d->init_setup(dev, d);
-	return 0;
+	return ide_setup_pci_device(dev, d);
 }
 
 /**
@@ -793,6 +645,8 @@
 #endif
 	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ESB_2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 19},
 	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH6_19, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 20},
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH7_21, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 21},
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801DB_1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 22},
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, piix_pci_tbl);
diff -Naur linuxppc-2.6.9/drivers/ide/pci/piix.h linuxppc-2.6.9-dream/drivers/ide/pci/piix.h
--- linuxppc-2.6.9/drivers/ide/pci/piix.h	2004-10-18 23:53:43.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/piix.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-#ifndef PIIX_H
-#define PIIX_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-#define PIIX_DEBUG_DRIVE_INFO		0
-
-#define DISPLAY_PIIX_TIMINGS
-
-static void init_setup_piix(struct pci_dev *, ide_pci_device_t *);
-static unsigned int __devinit init_chipset_piix(struct pci_dev *, const char *);
-static void init_hwif_piix(ide_hwif_t *);
-
-#define DECLARE_PIIX_DEV(name_str) \
-	{						\
-		.name		= name_str,		\
-		.init_setup	= init_setup_piix,	\
-		.init_chipset	= init_chipset_piix,	\
-		.init_hwif	= init_hwif_piix,	\
-		.channels	= 2,			\
-		.autodma	= AUTODMA,		\
-		.enablebits	= {{0x41,0x80,0x80}, {0x43,0x80,0x80}}, \
-		.bootable	= ON_BOARD,		\
-	}
-
-/*
- *	Table of the various PIIX capability blocks
- *
- */
- 
-static ide_pci_device_t piix_pci_info[] __devinitdata = {
-	/*  0 */ DECLARE_PIIX_DEV("PIIXa"),
-	/*  1 */ DECLARE_PIIX_DEV("PIIXb"),
-
-	{	/* 2 */
-		.name		= "MPIIX",
-		.init_setup	= init_setup_piix,
-		.init_hwif	= init_hwif_piix,
-		.channels	= 2,
-		.autodma	= NODMA,
-		.enablebits	= {{0x6D,0x80,0x80}, {0x6F,0x80,0x80}},
-		.bootable	= ON_BOARD,
-	},
-
-	/*  3 */ DECLARE_PIIX_DEV("PIIX3"),
-	/*  4 */ DECLARE_PIIX_DEV("PIIX4"),
-	/*  5 */ DECLARE_PIIX_DEV("ICH0"),
-	/*  6 */ DECLARE_PIIX_DEV("PIIX4"),
-	/*  7 */ DECLARE_PIIX_DEV("ICH"),
-	/*  8 */ DECLARE_PIIX_DEV("PIIX4"),
-	/*  9 */ DECLARE_PIIX_DEV("PIIX4"),
-	/* 10 */ DECLARE_PIIX_DEV("ICH2"),
-	/* 11 */ DECLARE_PIIX_DEV("ICH2M"),
-	/* 12 */ DECLARE_PIIX_DEV("ICH3M"),
-	/* 13 */ DECLARE_PIIX_DEV("ICH3"),
-	/* 14 */ DECLARE_PIIX_DEV("ICH4"),
-	/* 15 */ DECLARE_PIIX_DEV("ICH5"),
-	/* 16 */ DECLARE_PIIX_DEV("C-ICH"),
-	/* 17 */ DECLARE_PIIX_DEV("ICH4"),
-	/* 18 */ DECLARE_PIIX_DEV("ICH5-SATA"),
-	/* 19 */ DECLARE_PIIX_DEV("ICH5"),
-	/* 20 */ DECLARE_PIIX_DEV("ICH6")
-};
-
-#endif /* PIIX_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/rz1000.c linuxppc-2.6.9-dream/drivers/ide/pci/rz1000.c
--- linuxppc-2.6.9/drivers/ide/pci/rz1000.c	2004-10-18 23:53:50.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/rz1000.c	2005-06-20 10:46:11.000000000 +0200
@@ -33,7 +33,7 @@
 
 #include <asm/io.h>
 
-static void __init init_hwif_rz1000 (ide_hwif_t *hwif)
+static void __devinit init_hwif_rz1000 (ide_hwif_t *hwif)
 {
 	u16 reg;
 	struct pci_dev *dev = hwif->pci_dev;
@@ -62,8 +62,7 @@
 
 static int __devinit rz1000_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &rz1000_chipset);
-	return 0;
+	return ide_setup_pci_device(dev, &rz1000_chipset);
 }
 
 static struct pci_device_id rz1000_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/sc1200.c linuxppc-2.6.9-dream/drivers/ide/pci/sc1200.c
--- linuxppc-2.6.9/drivers/ide/pci/sc1200.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/sc1200.c	2005-06-20 10:46:11.000000000 +0200
@@ -67,61 +67,12 @@
 	return pci_clock;
 }
 
-#define DISPLAY_SC1200_TIMINGS
-
-#if defined(DISPLAY_SC1200_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static int sc1200_get_info(char *, char **, off_t, int);
-extern int (*sc1200_display_info)(char *, char **, off_t, int); /* ide-proc.c */
-extern char *ide_media_verbose(ide_drive_t *);
-static u8 sc1200_proc = 0;
-
-static struct pci_dev *bmide_dev;
-
-static int sc1200_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	unsigned long bibma = pci_resource_start(bmide_dev, 4);
-	int len;
-	u8  c0 = 0, c1 = 0;
-
-	/*
-	 * at that point bibma+0x2 et bibma+0xa are byte registers
-	 * to investigate:
-	 */
-
-	c0 = inb_p(bibma + 0x02);
-	c1 = inb_p(bibma + 0x0a);
-
-	p += sprintf(p, "\n                               National SCx200 Chipset.\n");
-	p += sprintf(p, "--------------- Primary Channel ---------------- Secondary Channel -------------\n");
-	p += sprintf(p, "                %sabled                         %sabled\n",
-			(c0&0x80) ? "dis" : " en",
-			(c1&0x80) ? "dis" : " en");
-	p += sprintf(p, "--------------- drive0 --------- drive1 -------- drive0 ---------- drive1 ------\n");
-	p += sprintf(p, "DMA enabled:    %s              %s             %s               %s\n",
-			(c0&0x20) ? "yes" : "no ", (c0&0x40) ? "yes" : "no ",
-			(c1&0x20) ? "yes" : "no ", (c1&0x40) ? "yes" : "no " );
-
-	p += sprintf(p, "UDMA\n");
-	p += sprintf(p, "DMA\n");
-	p += sprintf(p, "PIO\n");
-
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif /* DISPLAY_SC1200_TIMINGS && CONFIG_PROC_FS */
-
 extern char *ide_xfer_verbose (byte xfer_rate);
 
 /*
  * Set a new transfer mode at the drive
  */
-int sc1200_set_xfer_mode (ide_drive_t *drive, byte mode)
+static int sc1200_set_xfer_mode (ide_drive_t *drive, byte mode)
 {
 	printk("%s: sc1200_set_xfer_mode(%s)\n", drive->name, ide_xfer_verbose(mode));
 	return ide_config_drive_speed(drive, mode);
@@ -312,7 +263,7 @@
  *
  *  returns 1 on error, 0 otherwise
  */
-int sc1200_ide_dma_end (ide_drive_t *drive)
+static int sc1200_ide_dma_end (ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 	unsigned long dma_base = hwif->dma_base;
@@ -505,21 +456,6 @@
 }
 
 /*
- * Initialize the sc1200 bridge for reliable IDE DMA operation.
- */
-static unsigned int __init init_chipset_sc1200 (struct pci_dev *dev, const char *name)
-{
-#if defined(DISPLAY_SC1200_TIMINGS) && defined(CONFIG_PROC_FS)
-	if (!bmide_dev) {
-		sc1200_proc = 1;
-		bmide_dev = dev;
-		ide_pci_create_host_proc("sc1200", sc1200_get_info);
-	}
-#endif /* DISPLAY_SC1200_TIMINGS && CONFIG_PROC_FS */
-	return 0;
-}
-
-/*
  * This gets invoked by the IDE driver once for each channel,
  * and performs channel-specific pre-initialization before drive probing.
  */
@@ -545,7 +481,6 @@
 
 static ide_pci_device_t sc1200_chipset __devinitdata = {
 	.name		= "SC1200",
-	.init_chipset	= init_chipset_sc1200,
 	.init_hwif	= init_hwif_sc1200,
 	.channels	= 2,
 	.autodma	= AUTODMA,
@@ -554,8 +489,7 @@
 
 static int __devinit sc1200_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &sc1200_chipset);
-	return 0;
+	return ide_setup_pci_device(dev, &sc1200_chipset);
 }
 
 static struct pci_device_id sc1200_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/serverworks.c linuxppc-2.6.9-dream/drivers/ide/pci/serverworks.c
--- linuxppc-2.6.9/drivers/ide/pci/serverworks.c	2004-10-18 23:53:10.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/serverworks.c	2005-06-20 10:46:11.000000000 +0200
@@ -39,169 +39,22 @@
 
 #include <asm/io.h>
 
-#include "serverworks.h"
+#define SVWKS_CSB5_REVISION_NEW	0x92 /* min PCI_REVISION_ID for UDMA5 (A2.0) */
+#define SVWKS_CSB6_REVISION	0xa0 /* min PCI_REVISION_ID for UDMA4 (A1.0) */
+
+/* Seagate Barracuda ATA IV Family drives in UDMA mode 5
+ * can overrun their FIFOs when used with the CSB5 */
+static const char *svwks_bad_ata100[] = {
+	"ST320011A",
+	"ST340016A",
+	"ST360021A",
+	"ST380021A",
+	NULL
+};
 
 static u8 svwks_revision = 0;
 static struct pci_dev *isa_dev;
 
-#if defined(DISPLAY_SVWKS_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 svwks_proc = 0;
-#define SVWKS_MAX_DEVS		2
-static struct pci_dev *svwks_devs[SVWKS_MAX_DEVS];
-static int n_svwks_devs;
-
-static int svwks_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	int i, len;
-
-	p += sprintf(p, "\n                             "
-			"ServerWorks OSB4/CSB5/CSB6\n");
-
-	for (i = 0; i < n_svwks_devs; i++) {
-		struct pci_dev *dev = svwks_devs[i];
-		unsigned long bibma = pci_resource_start(dev, 4);
-		u32 reg40, reg44;
-		u16 reg48, reg56;
-		u8  reg54, c0=0, c1=0;
-
-		pci_read_config_dword(dev, 0x40, &reg40);
-		pci_read_config_dword(dev, 0x44, &reg44);
-		pci_read_config_word(dev, 0x48, &reg48);
-		pci_read_config_byte(dev, 0x54, &reg54);
-		pci_read_config_word(dev, 0x56, &reg56);
-
-		/*
-		 * at that point bibma+0x2 et bibma+0xa are byte registers
-		 * to investigate:
-		 */
-		c0 = inb_p(bibma + 0x02);
-		c1 = inb_p(bibma + 0x0a);
-
-		p += sprintf(p, "\n                            ServerWorks ");
-		switch(dev->device) {
-			case PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2:
-			case PCI_DEVICE_ID_SERVERWORKS_CSB6IDE:
-				p += sprintf(p, "CSB6 ");
-				break;
-			case PCI_DEVICE_ID_SERVERWORKS_CSB5IDE:
-				p += sprintf(p, "CSB5 ");
-				break;
-			case PCI_DEVICE_ID_SERVERWORKS_OSB4IDE:
-				p += sprintf(p, "OSB4 ");
-				break;
-			default:
-				p += sprintf(p, "%04x ", dev->device);
-				break;
-		}
-		p += sprintf(p, "Chipset (rev %02x)\n", svwks_revision);
-
-		p += sprintf(p, "------------------------------- "
-				"General Status "
-				"---------------------------------\n");
-		p += sprintf(p, "--------------- Primary Channel "
-				"---------------- Secondary Channel "
-				"-------------\n");
-		p += sprintf(p, "                %sabled"
-				"                         %sabled\n",
-				(c0&0x80) ? "dis" : " en",
-				(c1&0x80) ? "dis" : " en");
-		p += sprintf(p, "--------------- drive0 --------- drive1 "
-				"-------- drive0 ---------- drive1 ------\n");
-		p += sprintf(p, "DMA enabled:    %s              %s"
-				"             %s               %s\n",
-			(c0&0x20) ? "yes" : "no ",
-			(c0&0x40) ? "yes" : "no ",
-			(c1&0x20) ? "yes" : "no ",
-			(c1&0x40) ? "yes" : "no " );
-		p += sprintf(p, "UDMA enabled:   %s              %s"
-				"             %s               %s\n",
-			(reg54 & 0x01) ? "yes" : "no ",
-			(reg54 & 0x02) ? "yes" : "no ",
-			(reg54 & 0x04) ? "yes" : "no ",
-			(reg54 & 0x08) ? "yes" : "no " );
-		p += sprintf(p, "UDMA enabled:   %s                %s"
-				"               %s                 %s\n",
-			((reg56&0x0005)==0x0005)?"5":
-				((reg56&0x0004)==0x0004)?"4":
-				((reg56&0x0003)==0x0003)?"3":
-				((reg56&0x0002)==0x0002)?"2":
-				((reg56&0x0001)==0x0001)?"1":
-				((reg56&0x000F))?"?":"0",
-			((reg56&0x0050)==0x0050)?"5":
-				((reg56&0x0040)==0x0040)?"4":
-				((reg56&0x0030)==0x0030)?"3":
-				((reg56&0x0020)==0x0020)?"2":
-				((reg56&0x0010)==0x0010)?"1":
-				((reg56&0x00F0))?"?":"0",
-			((reg56&0x0500)==0x0500)?"5":
-				((reg56&0x0400)==0x0400)?"4":
-				((reg56&0x0300)==0x0300)?"3":
-				((reg56&0x0200)==0x0200)?"2":
-				((reg56&0x0100)==0x0100)?"1":
-				((reg56&0x0F00))?"?":"0",
-			((reg56&0x5000)==0x5000)?"5":
-				((reg56&0x4000)==0x4000)?"4":
-				((reg56&0x3000)==0x3000)?"3":
-				((reg56&0x2000)==0x2000)?"2":
-				((reg56&0x1000)==0x1000)?"1":
-				((reg56&0xF000))?"?":"0");
-		p += sprintf(p, "DMA enabled:    %s                %s"
-				"               %s                 %s\n",
-			((reg44&0x00002000)==0x00002000)?"2":
-				((reg44&0x00002100)==0x00002100)?"1":
-				((reg44&0x00007700)==0x00007700)?"0":
-				((reg44&0x0000FF00)==0x0000FF00)?"X":"?",
-			((reg44&0x00000020)==0x00000020)?"2":
-				((reg44&0x00000021)==0x00000021)?"1":
-				((reg44&0x00000077)==0x00000077)?"0":
-				((reg44&0x000000FF)==0x000000FF)?"X":"?",
-			((reg44&0x20000000)==0x20000000)?"2":
-				((reg44&0x21000000)==0x21000000)?"1":
-				((reg44&0x77000000)==0x77000000)?"0":
-				((reg44&0xFF000000)==0xFF000000)?"X":"?",
-			((reg44&0x00200000)==0x00200000)?"2":
-				((reg44&0x00210000)==0x00210000)?"1":
-				((reg44&0x00770000)==0x00770000)?"0":
-				((reg44&0x00FF0000)==0x00FF0000)?"X":"?");
-
-		p += sprintf(p, "PIO  enabled:   %s                %s"
-				"               %s                 %s\n",
-			((reg40&0x00002000)==0x00002000)?"4":
-				((reg40&0x00002200)==0x00002200)?"3":
-				((reg40&0x00003400)==0x00003400)?"2":
-				((reg40&0x00004700)==0x00004700)?"1":
-				((reg40&0x00005D00)==0x00005D00)?"0":"?",
-			((reg40&0x00000020)==0x00000020)?"4":
-				((reg40&0x00000022)==0x00000022)?"3":
-				((reg40&0x00000034)==0x00000034)?"2":
-				((reg40&0x00000047)==0x00000047)?"1":
-				((reg40&0x0000005D)==0x0000005D)?"0":"?",
-			((reg40&0x20000000)==0x20000000)?"4":
-				((reg40&0x22000000)==0x22000000)?"3":
-				((reg40&0x34000000)==0x34000000)?"2":
-				((reg40&0x47000000)==0x47000000)?"1":
-				((reg40&0x5D000000)==0x5D000000)?"0":"?",
-			((reg40&0x00200000)==0x00200000)?"4":
-				((reg40&0x00220000)==0x00220000)?"3":
-				((reg40&0x00340000)==0x00340000)?"2":
-				((reg40&0x00470000)==0x00470000)?"1":
-				((reg40&0x005D0000)==0x005D0000)?"0":"?");
-
-	}
-	p += sprintf(p, "\n");
-
-	/* p - buffer must be less than 4k! */
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif  /* defined(DISPLAY_SVWKS_TIMINGS) && defined(CONFIG_PROC_FS) */
-
 static int check_in_drive_lists (ide_drive_t *drive, const char **list)
 {
 	while (*list)
@@ -463,38 +316,16 @@
 	drive->init_speed = 0;
 
 	if ((id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			} else
-				/* UDMA disabled by mask, try other DMA modes */
-				goto try_dma_modes;
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto no_dma_set;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		config_chipset_for_pio(drive);
 		//	hwif->tuneproc(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
@@ -539,11 +370,9 @@
 	else if ((dev->device == PCI_DEVICE_ID_SERVERWORKS_CSB5IDE) ||
 		 (dev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE) ||
 		 (dev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2)) {
-//		u32 pioreg = 0, dmareg = 0;
 
 		/* Third Channel Test */
 		if (!(PCI_FUNC(dev->devfn) & 1)) {
-#if 1
 			struct pci_dev * findev = NULL;
 			u32 reg4c = 0;
 			findev = pci_find_device(PCI_VENDOR_ID_SERVERWORKS,
@@ -555,19 +384,11 @@
 				reg4c |=  0x00000020;
 				pci_write_config_dword(findev, 0x4C, reg4c);
 			}
-#endif
 			outb_p(0x06, 0x0c00);
 			dev->irq = inb_p(0x0c01);
 #if 0
-			/* WE need to figure out how to get the correct one */
-			printk("%s: interrupt %d\n", name, dev->irq);
-			if (dev->irq != 0x0B)
-				dev->irq = 0x0B;
-#endif
-#if 0
 			printk("%s: device class (0x%04x)\n",
 				name, dev->class);
-#else
 			if ((dev->class >> 8) != PCI_CLASS_STORAGE_IDE) {
 				dev->class &= ~0x000F0F00;
 		//		dev->class |= ~0x00000400;
@@ -593,7 +414,8 @@
 			 * interrupt pin to be set, and it is a compatibility
 			 * mode issue.
 			 */
-			dev->irq = 0;
+			if ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE)
+				dev->irq = 0;
 		}
 //		pci_read_config_dword(dev, 0x40, &pioreg)
 //		pci_write_config_dword(dev, 0x40, 0x99999999);
@@ -617,16 +439,6 @@
 		pci_write_config_byte(dev, 0x5A, btr);
 	}
 
-
-#if defined(DISPLAY_SVWKS_TIMINGS) && defined(CONFIG_PROC_FS)
-	svwks_devs[n_svwks_devs++] = dev;
-
-	if (!svwks_proc) {
-		svwks_proc = 1;
-		ide_pci_create_host_proc("svwks", svwks_get_info);
-	}
-#endif /* DISPLAY_SVWKS_TIMINGS && CONFIG_PROC_FS */
-
 	return (dev->irq) ? dev->irq : 0;
 }
 
@@ -756,20 +568,17 @@
 	ide_setup_dma(hwif, dmabase, 8);
 }
 
-static void __init init_setup_svwks (struct pci_dev *dev, ide_pci_device_t *d)
+static int __init init_setup_svwks (struct pci_dev *dev, ide_pci_device_t *d)
 {
-	ide_setup_pci_device(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
-static void __init init_setup_csb6 (struct pci_dev *dev, ide_pci_device_t *d)
+static int __init init_setup_csb6 (struct pci_dev *dev, ide_pci_device_t *d)
 {
 	if (!(PCI_FUNC(dev->devfn) & 1)) {
 		d->bootable = NEVER_BOARD;
 		if (dev->resource[0].start == 0x01f1)
 			d->bootable = ON_BOARD;
-	} else {
-		if ((dev->class >> 8) != PCI_CLASS_STORAGE_IDE)
-			return;
 	}
 #if 0
 	if ((IDE_PCI_DEVID_EQ(d->devid, DEVID_CSB6) &&
@@ -781,9 +590,47 @@
 			dev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2) &&
 		       (!(PCI_FUNC(dev->devfn) & 1))) ? 1 : 2;
 
-	ide_setup_pci_device(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
+static ide_pci_device_t serverworks_chipsets[] __devinitdata = {
+	{	/* 0 */
+		.name		= "SvrWks OSB4",
+		.init_setup	= init_setup_svwks,
+		.init_chipset	= init_chipset_svwks,
+		.init_hwif	= init_hwif_svwks,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 1 */
+		.name		= "SvrWks CSB5",
+		.init_setup	= init_setup_svwks,
+		.init_chipset	= init_chipset_svwks,
+		.init_hwif	= init_hwif_svwks,
+		.init_dma	= init_dma_svwks,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 2 */
+		.name		= "SvrWks CSB6",
+		.init_setup	= init_setup_csb6,
+		.init_chipset	= init_chipset_svwks,
+		.init_hwif	= init_hwif_svwks,
+		.init_dma	= init_dma_svwks,
+		.channels	= 2,
+		.autodma	= AUTODMA,
+		.bootable	= ON_BOARD,
+	},{	/* 3 */
+		.name		= "SvrWks CSB6",
+		.init_setup	= init_setup_csb6,
+		.init_chipset	= init_chipset_svwks,
+		.init_hwif	= init_hwif_svwks,
+		.init_dma	= init_dma_svwks,
+		.channels	= 1,	/* 2 */
+		.autodma	= AUTODMA,
+		.bootable	= ON_BOARD,
+	}
+};
 
 /**
  *	svwks_init_one	-	called when a OSB/CSB is found
@@ -798,8 +645,7 @@
 {
 	ide_pci_device_t *d = &serverworks_chipsets[id->driver_data];
 
-	d->init_setup(dev, d);
-	return 0;
+	return d->init_setup(dev, d);
 }
 
 static struct pci_device_id svwks_pci_tbl[] = {
@@ -815,10 +661,6 @@
 	.name		= "Serverworks_IDE",
 	.id_table	= svwks_pci_tbl,
 	.probe		= svwks_init_one,
-#if 0	/* FIXME: implement */
-	.suspend	= ,
-	.resume		= ,
-#endif
 };
 
 static int svwks_ide_init(void)
diff -Naur linuxppc-2.6.9/drivers/ide/pci/serverworks.h linuxppc-2.6.9-dream/drivers/ide/pci/serverworks.h
--- linuxppc-2.6.9/drivers/ide/pci/serverworks.h	2004-10-18 23:53:50.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/serverworks.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,71 +0,0 @@
-
-#ifndef SERVERWORKS_H
-#define SERVERWORKS_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-#undef SVWKS_DEBUG_DRIVE_INFO
-
-#define SVWKS_CSB5_REVISION_NEW	0x92 /* min PCI_REVISION_ID for UDMA5 (A2.0) */
-#define SVWKS_CSB6_REVISION	0xa0 /* min PCI_REVISION_ID for UDMA4 (A1.0) */
-
-/* Seagate Barracuda ATA IV Family drives in UDMA mode 5
- * can overrun their FIFOs when used with the CSB5 */
-const char *svwks_bad_ata100[] = {
-	"ST320011A",
-	"ST340016A",
-	"ST360021A",
-	"ST380021A",
-	NULL
-};
-
-#define DISPLAY_SVWKS_TIMINGS	1
-
-static void init_setup_svwks(struct pci_dev *, ide_pci_device_t *);
-static void init_setup_csb6(struct pci_dev *, ide_pci_device_t *);
-static unsigned int init_chipset_svwks(struct pci_dev *, const char *);
-static void init_hwif_svwks(ide_hwif_t *);
-static void init_dma_svwks(ide_hwif_t *, unsigned long);
-
-static ide_pci_device_t serverworks_chipsets[] __devinitdata = {
-	{	/* 0 */
-		.name		= "SvrWks OSB4",
-		.init_setup	= init_setup_svwks,
-		.init_chipset	= init_chipset_svwks,
-		.init_hwif	= init_hwif_svwks,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= ON_BOARD,
-	},{	/* 1 */
-		.name		= "SvrWks CSB5",
-		.init_setup	= init_setup_svwks,
-		.init_chipset	= init_chipset_svwks,
-		.init_hwif	= init_hwif_svwks,
-		.init_dma	= init_dma_svwks,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= ON_BOARD,
-	},{	/* 2 */
-		.name		= "SvrWks CSB6",
-		.init_setup	= init_setup_csb6,
-		.init_chipset	= init_chipset_svwks,
-		.init_hwif	= init_hwif_svwks,
-		.init_dma	= init_dma_svwks,
-		.channels	= 2,
-		.autodma	= AUTODMA,
-		.bootable	= ON_BOARD,
-	},{	/* 3 */
-		.name		= "SvrWks CSB6",
-		.init_setup	= init_setup_csb6,
-		.init_chipset	= init_chipset_svwks,
-		.init_hwif	= init_hwif_svwks,
-		.init_dma	= init_dma_svwks,
-		.channels	= 1,	/* 2 */
-		.autodma	= AUTODMA,
-		.bootable	= ON_BOARD,
-	}
-};
-
-#endif /* SERVERWORKS_H */
diff -Naur linuxppc-2.6.9/drivers/ide/pci/sgiioc4.c linuxppc-2.6.9-dream/drivers/ide/pci/sgiioc4.c
--- linuxppc-2.6.9/drivers/ide/pci/sgiioc4.c	2004-10-18 23:54:19.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/sgiioc4.c	2005-06-20 10:46:11.000000000 +0200
@@ -192,16 +192,13 @@
 	return intr_reg & 3;
 }
 
-static int
-sgiioc4_ide_dma_begin(ide_drive_t * drive)
+static void sgiioc4_ide_dma_start(ide_drive_t * drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 	unsigned int reg = hwif->INL(hwif->dma_base + IOC4_DMA_CTRL * 4);
 	unsigned int temp_reg = reg | IOC4_S_DMA_START;
 
 	hwif->OUTL(temp_reg, hwif->dma_base + IOC4_DMA_CTRL * 4);
-
-	return 0;
 }
 
 static u32
@@ -335,17 +332,6 @@
 }
 
 static int
-sgiioc4_ide_dma_verbose(ide_drive_t * drive)
-{
-	if (drive->using_dma == 1)
-		printk(", UDMA(16)");
-	else
-		printk(", PIO");
-
-	return 1;
-}
-
-static int
 sgiioc4_ide_dma_lostirq(ide_drive_t * drive)
 {
 	HWIF(drive)->resetproc(drive);
@@ -382,7 +368,7 @@
 }
 
 /* Creates a dma map for the scatter-gather list entries */
-static void __init
+static void __devinit
 ide_dma_sgiioc4(ide_hwif_t * hwif, unsigned long dma_base)
 {
 	int num_ports = sizeof (ioc4_dma_regs_t);
@@ -407,11 +393,7 @@
 	if (!hwif->dmatable_cpu)
 		goto dma_alloc_failure;
 
-	hwif->sg_table =
-	    kmalloc(sizeof (struct scatterlist) * IOC4_PRD_ENTRIES, GFP_KERNEL);
-
-	if (!hwif->sg_table)
-		goto dma_sgalloc_failure;
+	hwif->sg_max_nents = IOC4_PRD_ENTRIES;
 
 	hwif->dma_base2 = (unsigned long)
 		pci_alloc_consistent(hwif->pci_dev,
@@ -424,9 +406,6 @@
 	return;
 
 dma_base2alloc_failure:
-	kfree(hwif->sg_table);
-
-dma_sgalloc_failure:
 	pci_free_consistent(hwif->pci_dev,
 			    IOC4_PRD_ENTRIES * IOC4_PRD_BYTES,
 			    hwif->dmatable_cpu, hwif->dmatable_dma);
@@ -511,10 +490,7 @@
 	unsigned int count = 0, i = 1;
 	struct scatterlist *sg;
 
-	if (HWGROUP(drive)->rq->flags & REQ_DRIVE_TASKFILE)
-		hwif->sg_nents = i = ide_raw_build_sglist(drive, rq);
-	else
-		hwif->sg_nents = i = ide_build_sglist(drive, rq);
+	hwif->sg_nents = i = ide_build_sglist(drive, rq);
 
 	if (!i)
 		return 0;	/* sglist of length Zero */
@@ -574,40 +550,36 @@
 	return 0;		/* revert to PIO for this request */
 }
 
-static int
-sgiioc4_ide_dma_read(ide_drive_t * drive)
+static int sgiioc4_ide_dma_setup(ide_drive_t *drive)
 {
 	struct request *rq = HWGROUP(drive)->rq;
 	unsigned int count = 0;
+	int ddir;
 
-	if (!(count = sgiioc4_build_dma_table(drive, rq, PCI_DMA_FROMDEVICE))) {
-		/* try PIO instead of DMA */
-		return 1;
-	}
-	/* Writes FROM the IOC4 TO Main Memory */
-	sgiioc4_configure_for_dma(IOC4_DMA_WRITE, drive);
-
-	return 0;
-}
-
-static int
-sgiioc4_ide_dma_write(ide_drive_t * drive)
-{
-	struct request *rq = HWGROUP(drive)->rq;
-	unsigned int count = 0;
+	if (rq_data_dir(rq))
+		ddir = PCI_DMA_TODEVICE;
+	else
+		ddir = PCI_DMA_FROMDEVICE;
 
-	if (!(count = sgiioc4_build_dma_table(drive, rq, PCI_DMA_TODEVICE))) {
+	if (!(count = sgiioc4_build_dma_table(drive, rq, ddir))) {
 		/* try PIO instead of DMA */
+		ide_map_sg(drive, rq);
 		return 1;
 	}
 
-	sgiioc4_configure_for_dma(IOC4_DMA_READ, drive);
-	/* Writes TO the IOC4 FROM Main Memory */
+	if (rq_data_dir(rq))
+		/* Writes TO the IOC4 FROM Main Memory */
+		ddir = IOC4_DMA_READ;
+	else
+		/* Writes FROM the IOC4 TO Main Memory */
+		ddir = IOC4_DMA_WRITE;
+
+	sgiioc4_configure_for_dma(ddir, drive);
 
 	return 0;
 }
 
-static void __init
+static void __devinit
 ide_init_sgiioc4(ide_hwif_t * hwif)
 {
 	hwif->mmio = 2;
@@ -616,7 +588,6 @@
 	hwif->ultra_mask = 0x0;	/* Disable Ultra DMA */
 	hwif->mwdma_mask = 0x2;	/* Multimode-2 DMA  */
 	hwif->swdma_mask = 0x2;
-	hwif->identify = NULL;
 	hwif->tuneproc = NULL;	/* Sets timing for PIO mode */
 	hwif->speedproc = NULL;	/* Sets timing for DMA &/or PIO modes */
 	hwif->selectproc = NULL;/* Use the default routine to select drive */
@@ -629,9 +600,8 @@
 	hwif->quirkproc = NULL;
 	hwif->busproc = NULL;
 
-	hwif->ide_dma_read = &sgiioc4_ide_dma_read;
-	hwif->ide_dma_write = &sgiioc4_ide_dma_write;
-	hwif->ide_dma_begin = &sgiioc4_ide_dma_begin;
+	hwif->dma_setup = &sgiioc4_ide_dma_setup;
+	hwif->dma_start = &sgiioc4_ide_dma_start;
 	hwif->ide_dma_end = &sgiioc4_ide_dma_end;
 	hwif->ide_dma_check = &sgiioc4_ide_dma_check;
 	hwif->ide_dma_on = &sgiioc4_ide_dma_on;
@@ -639,13 +609,12 @@
 	hwif->ide_dma_test_irq = &sgiioc4_ide_dma_test_irq;
 	hwif->ide_dma_host_on = &sgiioc4_ide_dma_host_on;
 	hwif->ide_dma_host_off = &sgiioc4_ide_dma_host_off;
-	hwif->ide_dma_verbose = &sgiioc4_ide_dma_verbose;
 	hwif->ide_dma_lostirq = &sgiioc4_ide_dma_lostirq;
 	hwif->ide_dma_timeout = &__ide_dma_timeout;
 	hwif->INB = &sgiioc4_INB;
 }
 
-static int __init
+static int __devinit
 sgiioc4_ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t * d)
 {
 	unsigned long base, ctl, dma_base, irqport;
@@ -700,7 +669,8 @@
 		printk(KERN_INFO "%s: %s Bus-Master DMA disabled\n",
 		       hwif->name, d->name);
 
-	probe_hwif_init(hwif);
+	if (probe_hwif_init(hwif))
+		return -EIO;
 
 	/* Create /proc/ide entries */
 	create_proc_ide_interfaces(); 
@@ -708,28 +678,18 @@
 	return 0;
 }
 
-/* This ensures that we can build this for generic kernels without
- * having all the SN2 code sync'd and merged.
- */
-typedef enum pciio_endian_e {
-	PCIDMA_ENDIAN_BIG,
-	PCIDMA_ENDIAN_LITTLE
-} pciio_endian_t;
-pciio_endian_t snia_pciio_endian_set(struct pci_dev
-				     *pci_dev, pciio_endian_t device_end,
-				     pciio_endian_t desired_end);
-
-static unsigned int __init
+static unsigned int __devinit
 pci_init_sgiioc4(struct pci_dev *dev, ide_pci_device_t * d)
 {
 	unsigned int class_rev;
-	pciio_endian_t endian_status;
+	int ret;
 
-	if (pci_enable_device(dev)) {
+	ret = pci_enable_device(dev);
+	if (ret < 0) {
 		printk(KERN_ERR
 		       "Failed to enable device %s at slot %s\n",
 		       d->name, dev->slot_name);
-		return -ENODEV;
+		goto out;
 	}
 	pci_set_master(dev);
 
@@ -741,20 +701,12 @@
 		printk(KERN_ERR "Skipping %s IDE controller in slot %s: "
 			"firmware is obsolete - please upgrade to revision"
 			"46 or higher\n", d->name, dev->slot_name);
-		return -ENODEV;
+		ret = -EAGAIN;
+		goto out;
 	}
-
-	/* Enable Byte Swapping in the PIC... */
-	endian_status = snia_pciio_endian_set(dev, PCIDMA_ENDIAN_LITTLE,
-					      PCIDMA_ENDIAN_BIG);
-	if (endian_status != PCIDMA_ENDIAN_BIG) {
-		printk(KERN_ERR
-		       "Failed to set endianness for device %s at slot %s\n",
-		       d->name, dev->slot_name);
-		return -ENODEV;
-	}
-
-	return sgiioc4_ide_setup_pci_device(dev, d);
+	ret = sgiioc4_ide_setup_pci_device(dev, d);
+out:
+	return ret;
 }
 
 static ide_pci_device_t sgiioc4_chipsets[] __devinitdata = {
@@ -784,13 +736,13 @@
 };
 MODULE_DEVICE_TABLE(pci, sgiioc4_pci_tbl);
 
-static struct pci_driver driver = {
+static struct pci_driver __devinitdata driver = {
 	.name = "SGI-IOC4_IDE",
 	.id_table = sgiioc4_pci_tbl,
 	.probe = sgiioc4_init_one,
 };
 
-static int
+static int __devinit
 sgiioc4_ide_init(void)
 {
 	return ide_pci_register_driver(&driver);
diff -Naur linuxppc-2.6.9/drivers/ide/pci/siimage.c linuxppc-2.6.9-dream/drivers/ide/pci/siimage.c
--- linuxppc-2.6.9/drivers/ide/pci/siimage.c	2004-10-18 23:53:50.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/siimage.c	2005-06-20 10:46:11.000000000 +0200
@@ -420,37 +420,16 @@
 	struct hd_driveid *id	= drive->id;
 
 	if ((id->capability & 1) != 0 && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-
-		if ((id->field_valid & 4) && siimage_ratemask(drive)) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		config_chipset_for_pio(drive, 1);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -554,12 +533,6 @@
 	return 0;
 }
 
-static int siimage_mmio_ide_dma_verbose (ide_drive_t *drive)
-{
-	int temp = __ide_dma_verbose(drive);
-	return temp;
-}
-
 /**
  *	siimage_busproc		-	bus isolation ioctl
  *	@drive: drive to isolate/restore
@@ -617,7 +590,7 @@
 		if ((hwif->INL(SATA_STATUS_REG) & 0x03) != 0x03) {
 			printk(KERN_WARNING "%s: reset phy dead, status=0x%08x\n",
 				hwif->name, hwif->INL(SATA_STATUS_REG));
-			HWGROUP(drive)->poll_timeout = 0;
+			HWGROUP(drive)->polling = 0;
 			return ide_started;
 		}
 		return 0;
@@ -898,12 +871,11 @@
 	 *	the MMIO layout isnt the same as the the standard port
 	 *	based I/O
 	 */
-	 
+
 	memset(&hw, 0, sizeof(hw_regs_t));
-	hw.priv				= addr;
 
-	base				= (unsigned long)addr;
-	if(ch)
+	base = (unsigned long)addr;
+	if (ch)
 		base += 0xC0;
 	else
 		base += 0x80;
@@ -928,16 +900,16 @@
 
 	hw.io_ports[IDE_IRQ_OFFSET]	= 0;
 
-        if (pdev_is_sata(dev)) {
-        	base = (unsigned long) addr;
-        	if(ch)
-        		base += 0x80;
-		hw.sata_scr[SATA_STATUS_OFFSET]	= base + 0x104;
-		hw.sata_scr[SATA_ERROR_OFFSET]	= base + 0x108;
-		hw.sata_scr[SATA_CONTROL_OFFSET]= base + 0x100;
-		hw.sata_misc[SATA_MISC_OFFSET]	= base + 0x140;
-		hw.sata_misc[SATA_PHY_OFFSET]	= base + 0x144;
-		hw.sata_misc[SATA_IEN_OFFSET]	= base + 0x148;
+	if (pdev_is_sata(dev)) {
+		base = (unsigned long)addr;
+		if (ch)
+			base += 0x80;
+		hwif->sata_scr[SATA_STATUS_OFFSET]	= base + 0x104;
+		hwif->sata_scr[SATA_ERROR_OFFSET]	= base + 0x108;
+		hwif->sata_scr[SATA_CONTROL_OFFSET]	= base + 0x100;
+		hwif->sata_misc[SATA_MISC_OFFSET]	= base + 0x140;
+		hwif->sata_misc[SATA_PHY_OFFSET]	= base + 0x144;
+		hwif->sata_misc[SATA_IEN_OFFSET]	= base + 0x148;
 	}
 
 	hw.irq				= hwif->pci_dev->irq;
@@ -945,11 +917,6 @@
 	memcpy(&hwif->hw, &hw, sizeof(hw));
 	memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->hw.io_ports));
 
-	if (is_sata(hwif)) {
-		memcpy(hwif->sata_scr, hwif->hw.sata_scr, sizeof(hwif->hw.sata_scr));
-		memcpy(hwif->sata_misc, hwif->hw.sata_misc, sizeof(hwif->hw.sata_misc));
-	}
-
 	hwif->irq			= hw.irq;
 
        	base = (unsigned long) addr;
@@ -988,6 +955,22 @@
 }
 
 /**
+ *	siimage_fixup		-	post probe fixups
+ *	@hwif: interface to fix up
+ *
+ *	Called after drive probe we use this to decide whether the
+ *	Seagate fixup must be applied. This used to be in init_iops but
+ *	that can occur before we know what drives are present.
+ */
+
+static void __devinit siimage_fixup(ide_hwif_t *hwif)
+{
+	/* Try and raise the rqsize */
+	if (!is_sata(hwif) || !is_dev_seagate_sata(&hwif->drives[0]))
+		hwif->rqsize = 128;
+}
+
+/**
  *	init_iops_siimage	-	set up iops
  *	@hwif: interface to set up
  *
@@ -1007,9 +990,8 @@
 	
 	hwif->hwif_data = NULL;
 
-	hwif->rqsize = 128;
-	if (is_sata(hwif) && is_dev_seagate_sata(&hwif->drives[0]))
-		hwif->rqsize = 15;
+	/* Pessimal until we finish probing */
+	hwif->rqsize = 15;
 
 	if (pci_get_drvdata(dev) == NULL)
 		return;
@@ -1077,7 +1059,6 @@
 
 	if (hwif->mmio) {
 		hwif->ide_dma_test_irq = &siimage_mmio_ide_dma_test_irq;
-		hwif->ide_dma_verbose = &siimage_mmio_ide_dma_verbose;
 	} else {
 		hwif->ide_dma_test_irq = & siimage_io_ide_dma_test_irq;
 	}
@@ -1098,6 +1079,7 @@
 		.init_chipset	= init_chipset_siimage,	\
 		.init_iops	= init_iops_siimage,	\
 		.init_hwif	= init_hwif_siimage,	\
+		.fixup		= siimage_fixup,	\
 		.channels	= 2,			\
 		.autodma	= AUTODMA,		\
 		.bootable	= ON_BOARD,		\
@@ -1120,8 +1102,7 @@
  
 static int __devinit siimage_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &siimage_chipsets[id->driver_data]);
-	return 0;
+	return ide_setup_pci_device(dev, &siimage_chipsets[id->driver_data]);
 }
 
 static struct pci_device_id siimage_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/sis5513.c linuxppc-2.6.9-dream/drivers/ide/pci/sis5513.c
--- linuxppc-2.6.9/drivers/ide/pci/sis5513.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/sis5513.c	2005-06-20 10:46:11.000000000 +0200
@@ -671,36 +671,16 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		sis5513_tune_drive(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -966,8 +946,7 @@
 
 static int __devinit sis5513_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &sis5513_chipset);
-	return 0;
+	return ide_setup_pci_device(dev, &sis5513_chipset);
 }
 
 static struct pci_device_id sis5513_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/sl82c105.c linuxppc-2.6.9-dream/drivers/ide/pci/sl82c105.c
--- linuxppc-2.6.9/drivers/ide/pci/sl82c105.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/sl82c105.c	2005-06-20 10:46:11.000000000 +0200
@@ -236,15 +236,13 @@
  * The generic IDE core will have disabled the BMEN bit before this
  * function is called.
  */
-static int sl82c105_ide_dma_begin(ide_drive_t *drive)
+static void sl82c105_ide_dma_start(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 	struct pci_dev *dev = hwif->pci_dev;
 
-//	DBG(("sl82c105_ide_dma_begin(drive:%s)\n", drive->name));
-
 	sl82c105_reset_host(dev);
-	return __ide_dma_begin(drive);
+	ide_dma_start(drive);
 }
 
 static int sl82c105_ide_dma_timeout(ide_drive_t *drive)
@@ -469,7 +467,7 @@
 	hwif->ide_dma_on = &sl82c105_ide_dma_on;
 	hwif->ide_dma_off_quietly = &sl82c105_ide_dma_off_quietly;
 	hwif->ide_dma_lostirq = &sl82c105_ide_dma_lost_irq;
-	hwif->ide_dma_begin = &sl82c105_ide_dma_begin;
+	hwif->dma_start = &sl82c105_ide_dma_start;
 	hwif->ide_dma_timeout = &sl82c105_ide_dma_timeout;
 
 	if (!noautodma)
@@ -492,8 +490,7 @@
 
 static int __devinit sl82c105_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &sl82c105_chipset);
-	return 0;
+	return ide_setup_pci_device(dev, &sl82c105_chipset);
 }
 
 static struct pci_device_id sl82c105_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/slc90e66.c linuxppc-2.6.9-dream/drivers/ide/pci/slc90e66.c
--- linuxppc-2.6.9/drivers/ide/pci/slc90e66.c	2004-10-18 23:54:54.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/slc90e66.c	2005-06-20 10:46:11.000000000 +0200
@@ -21,103 +21,6 @@
 
 #include <asm/io.h>
 
-#define DISPLAY_SLC90E66_TIMINGS
-
-#if defined(DISPLAY_SLC90E66_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 slc90e66_proc = 0;
-static struct pci_dev *bmide_dev;
-
-static int slc90e66_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	int len;
-	unsigned long bibma = pci_resource_start(bmide_dev, 4);
-	u16 reg40 = 0, psitre = 0, reg42 = 0, ssitre = 0;
-	u8  c0 = 0, c1 = 0;
-	u8  reg44 = 0, reg47 = 0, reg48 = 0, reg4a = 0, reg4b = 0;
-
-	pci_read_config_word(bmide_dev, 0x40, &reg40);
-	pci_read_config_word(bmide_dev, 0x42, &reg42);
-	pci_read_config_byte(bmide_dev, 0x44, &reg44);
-	pci_read_config_byte(bmide_dev, 0x47, &reg47);
-	pci_read_config_byte(bmide_dev, 0x48, &reg48);
-	pci_read_config_byte(bmide_dev, 0x4a, &reg4a);
-	pci_read_config_byte(bmide_dev, 0x4b, &reg4b);
-
-	psitre = (reg40 & 0x4000) ? 1 : 0;
-	ssitre = (reg42 & 0x4000) ? 1 : 0;
-
-        /*
-         * at that point bibma+0x2 et bibma+0xa are byte registers
-         * to investigate:
-         */
-	c0 = inb_p(bibma + 0x02);
-	c1 = inb_p(bibma + 0x0a);
-
-	p += sprintf(p, "                                SLC90E66 Chipset.\n");
-	p += sprintf(p, "--------------- Primary Channel "
-			"---------------- Secondary Channel "
-			"-------------\n");
-	p += sprintf(p, "                %sabled "
-			"                        %sabled\n",
-			(c0&0x80) ? "dis" : " en",
-			(c1&0x80) ? "dis" : " en");
-	p += sprintf(p, "--------------- drive0 --------- drive1 "
-			"-------- drive0 ---------- drive1 ------\n");
-	p += sprintf(p, "DMA enabled:    %s              %s "
-			"            %s               %s\n",
-			(c0&0x20) ? "yes" : "no ",
-			(c0&0x40) ? "yes" : "no ",
-			(c1&0x20) ? "yes" : "no ",
-			(c1&0x40) ? "yes" : "no " );
-	p += sprintf(p, "UDMA enabled:   %s              %s "
-			"            %s               %s\n",
-			(reg48&0x01) ? "yes" : "no ",
-			(reg48&0x02) ? "yes" : "no ",
-			(reg48&0x04) ? "yes" : "no ",
-			(reg48&0x08) ? "yes" : "no " );
-	p += sprintf(p, "UDMA enabled:   %s                %s "
-			"              %s                 %s\n",
-			((reg4a&0x04)==0x04) ? "4" :
-			((reg4a&0x03)==0x03) ? "3" :
-			(reg4a&0x02) ? "2" :
-			(reg4a&0x01) ? "1" :
-			(reg4a&0x00) ? "0" : "X",
-			((reg4a&0x40)==0x40) ? "4" :
-			((reg4a&0x30)==0x30) ? "3" :
-			(reg4a&0x20) ? "2" :
-			(reg4a&0x10) ? "1" :
-			(reg4a&0x00) ? "0" : "X",
-			((reg4b&0x04)==0x04) ? "4" :
-			((reg4b&0x03)==0x03) ? "3" :
-			(reg4b&0x02) ? "2" :
-			(reg4b&0x01) ? "1" :
-			(reg4b&0x00) ? "0" : "X",
-			((reg4b&0x40)==0x40) ? "4" :
-			((reg4b&0x30)==0x30) ? "3" :
-			(reg4b&0x20) ? "2" :
-			(reg4b&0x10) ? "1" :
-			(reg4b&0x00) ? "0" : "X");
-
-	p += sprintf(p, "UDMA\n");
-	p += sprintf(p, "DMA\n");
-	p += sprintf(p, "PIO\n");
-
-/*
- *	FIXME.... Add configuration junk data....blah blah......
- */
-
-	/* p - buffer must be less than 4k! */
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif  /* defined(DISPLAY_SLC90E66_TIMINGS) && defined(CONFIG_PROC_FS) */
-
 static u8 slc90e66_ratemask (ide_drive_t *drive)
 {
 	u8 mode	= 2;
@@ -236,6 +139,7 @@
 	if (speed >= XFER_UDMA_0) {
 		if (!(reg48 & u_flag))
 			pci_write_config_word(dev, 0x48, reg48|u_flag);
+		/* FIXME: (reg4a & a_speed) ? */
 		if ((reg4a & u_speed) != u_speed) {
 			pci_write_config_word(dev, 0x4a, reg4a & ~a_speed);
 			pci_read_config_word(dev, 0x4a, &reg4a);
@@ -274,37 +178,16 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = slc90e66_config_drive_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!slc90e66_config_drive_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!slc90e66_config_drive_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (slc90e66_config_drive_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		hwif->tuneproc(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -313,18 +196,6 @@
 }
 #endif /* CONFIG_BLK_DEV_IDEDMA */
 
-static unsigned int __init init_chipset_slc90e66 (struct pci_dev *dev, const char *name)
-{
-#if defined(DISPLAY_SLC90E66_TIMINGS) && defined(CONFIG_PROC_FS)
-	if (!slc90e66_proc) {
-		slc90e66_proc = 1;
-		bmide_dev = dev;
-		ide_pci_create_host_proc("slc90e66", slc90e66_get_info);
-	}
-#endif /* DISPLAY_SLC90E66_TIMINGS && CONFIG_PROC_FS */
-	return 0;
-}
-
 static void __init init_hwif_slc90e66 (ide_hwif_t *hwif)
 {
 	u8 reg47 = 0;
@@ -366,7 +237,6 @@
 
 static ide_pci_device_t slc90e66_chipset __devinitdata = {
 	.name		= "SLC90E66",
-	.init_chipset	= init_chipset_slc90e66,
 	.init_hwif	= init_hwif_slc90e66,
 	.channels	= 2,
 	.autodma	= AUTODMA,
@@ -376,8 +246,7 @@
 
 static int __devinit slc90e66_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &slc90e66_chipset);
-	return 0;
+	return ide_setup_pci_device(dev, &slc90e66_chipset);
 }
 
 static struct pci_device_id slc90e66_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/triflex.c linuxppc-2.6.9-dream/drivers/ide/pci/triflex.c
--- linuxppc-2.6.9/drivers/ide/pci/triflex.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/triflex.c	2005-06-20 10:46:11.000000000 +0200
@@ -118,25 +118,16 @@
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	struct hd_driveid *id	= drive->id;
-	
-	if (id && (id->capability & 1) && drive->autodma) {
-		if (__ide_dma_bad_drive(drive))
-			goto tune_pio;
-		if (id->field_valid & 2) {
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-				(id->dma_1word & hwif->swdma_mask)) {
-				if (!triflex_config_drive_for_dma(drive))
-					goto tune_pio;
-			}
-		} else 
-			goto tune_pio;
-	} else {
-tune_pio:
-		hwif->tuneproc(drive, 255);
-		return hwif->ide_dma_off_quietly(drive);
+
+	if ((id->capability & 1) && drive->autodma) {
+		if (ide_use_dma(drive)) {
+			if (triflex_config_drive_for_dma(drive))
+				return hwif->ide_dma_on(drive);
+		}
 	}
 
-	return hwif->ide_dma_on(drive);
+	hwif->tuneproc(drive, 255);
+	return hwif->ide_dma_off_quietly(drive);
 }
 
 static void __init init_hwif_triflex(ide_hwif_t *hwif)
@@ -167,9 +158,7 @@
 static int __devinit triflex_init_one(struct pci_dev *dev, 
 		const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &triflex_device);
-
-	return 0;
+	return ide_setup_pci_device(dev, &triflex_device);
 }
 
 static struct pci_device_id triflex_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/trm290.c linuxppc-2.6.9-dream/drivers/ide/pci/trm290.c
--- linuxppc-2.6.9/drivers/ide/pci/trm290.c	2004-10-18 23:53:43.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/trm290.c	2005-06-20 10:46:11.000000000 +0200
@@ -179,64 +179,32 @@
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA
-static int trm290_ide_dma_write (ide_drive_t *drive /*, struct request *rq */)
+static void trm290_ide_dma_exec_cmd(ide_drive_t *drive, u8 command)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
-	struct request *rq	= HWGROUP(drive)->rq;
-//	ide_task_t *args	= rq->special;
-	task_ioreg_t command	= WIN_NOP;
-	unsigned int count, reading = 2, writing = 0;
 
-	reading = 0;
-	writing = 1;
-#ifdef TRM290_NO_DMA_WRITES
-	/* always use PIO for writes */
-	trm290_prepare_drive(drive, 0);	/* select PIO xfer */
-	return 1;
-#endif
-	if (!(count = ide_build_dmatable(drive, rq))) {
-		/* try PIO instead of DMA */
-		trm290_prepare_drive(drive, 0); /* select PIO xfer */
-		return 1;
-	}
-	/* select DMA xfer */
-	trm290_prepare_drive(drive, 1);
-	hwif->OUTL(hwif->dmatable_dma|reading|writing, hwif->dma_command);
-	drive->waiting_for_dma = 1;
-	/* start DMA */
-	hwif->OUTW((count * 2) - 1, hwif->dma_status);
-	if (drive->media != ide_disk)
-		return 0;
 	if (HWGROUP(drive)->handler != NULL)	/* paranoia check */
 		BUG();
 	ide_set_handler(drive, &ide_dma_intr, WAIT_CMD, NULL);
-	/*
-	 * FIX ME to use only ACB ide_task_t args Struct
-	 */
-#if 0
-	{
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-#else
-	command = /* (lba48) ? WIN_READDMA_EXT : */ WIN_READDMA;
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-#endif
 	/* issue cmd to drive */
 	hwif->OUTB(command, IDE_COMMAND_REG);
-	return hwif->ide_dma_begin(drive);
 }
 
-static int trm290_ide_dma_read (ide_drive_t *drive  /*, struct request *rq */)
+static int trm290_ide_dma_setup(ide_drive_t *drive)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
-	struct request *rq	= HWGROUP(drive)->rq;
-//	ide_task_t *args	= rq->special;
-	task_ioreg_t command	= WIN_NOP;
-	unsigned int count, reading = 2, writing = 0;
+	ide_hwif_t *hwif = drive->hwif;
+	struct request *rq = hwif->hwgroup->rq;
+	unsigned int count, rw;
+
+	if (rq_data_dir(rq)) {
+#ifdef TRM290_NO_DMA_WRITES
+		/* always use PIO for writes */
+		trm290_prepare_drive(drive, 0);	/* select PIO xfer */
+		return 1;
+#endif
+		rw = 1;
+	} else
+		rw = 2;
 
 	if (!(count = ide_build_dmatable(drive, rq))) {
 		/* try PIO instead of DMA */
@@ -245,38 +213,15 @@
 	}
 	/* select DMA xfer */
 	trm290_prepare_drive(drive, 1);
-	hwif->OUTL(hwif->dmatable_dma|reading|writing, hwif->dma_command);
+	hwif->OUTL(hwif->dmatable_dma|rw, hwif->dma_command);
 	drive->waiting_for_dma = 1;
 	/* start DMA */
 	hwif->OUTW((count * 2) - 1, hwif->dma_status);
-	if (drive->media != ide_disk)
-		return 0;
-	if (HWGROUP(drive)->handler != NULL)	/* paranoia check */
-		BUG();
-	ide_set_handler(drive, &ide_dma_intr, WAIT_CMD, NULL);
-	/*
-	 * FIX ME to use only ACB ide_task_t args Struct
-	 */
-#if 0
-	{
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-#else
-	command = /* (lba48) ? WIN_WRITEDMA_EXT : */ WIN_WRITEDMA;
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-#endif
-	/* issue cmd to drive */
-	hwif->OUTB(command, IDE_COMMAND_REG);
-	return hwif->ide_dma_begin(drive);
+	return 0;
 }
 
-static int trm290_ide_dma_begin (ide_drive_t *drive)
+static void trm290_ide_dma_start(ide_drive_t *drive)
 {
-	return 0;
 }
 
 static int trm290_ide_dma_end (ide_drive_t *drive)
@@ -304,7 +249,7 @@
 /*
  * Invoked from ide-dma.c at boot time.
  */
-void __devinit init_hwif_trm290(ide_hwif_t *hwif)
+static void __devinit init_hwif_trm290(ide_hwif_t *hwif)
 {
 	unsigned int cfgbase = 0;
 	unsigned long flags;
@@ -347,9 +292,9 @@
 	ide_setup_dma(hwif, (hwif->config_data + 4) ^ (hwif->channel ? 0x0080 : 0x0000), 3);
 
 #ifdef CONFIG_BLK_DEV_IDEDMA
-	hwif->ide_dma_write = &trm290_ide_dma_write;
-	hwif->ide_dma_read = &trm290_ide_dma_read;
-	hwif->ide_dma_begin = &trm290_ide_dma_begin;
+	hwif->dma_setup = &trm290_ide_dma_setup;
+	hwif->dma_exec_cmd = &trm290_ide_dma_exec_cmd;
+	hwif->dma_start = &trm290_ide_dma_start;
 	hwif->ide_dma_end = &trm290_ide_dma_end;
 	hwif->ide_dma_test_irq = &trm290_ide_dma_test_irq;
 #endif /* CONFIG_BLK_DEV_IDEDMA */
@@ -397,8 +342,7 @@
 
 static int __devinit trm290_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &trm290_chipset);
-	return 0;
+	return ide_setup_pci_device(dev, &trm290_chipset);
 }
 
 static struct pci_device_id trm290_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/pci/via82cxxx.c linuxppc-2.6.9-dream/drivers/ide/pci/via82cxxx.c
--- linuxppc-2.6.9/drivers/ide/pci/via82cxxx.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/pci/via82cxxx.c	2005-06-20 10:46:11.000000000 +0200
@@ -36,6 +36,10 @@
 #include <linux/ide.h>
 #include <asm/io.h>
 
+#ifdef CONFIG_PPC_MULTIPLATFORM
+#include <asm/processor.h>
+#endif
+
 #include "ide-timing.h"
 
 #define DISPLAY_VIA_TIMINGS
@@ -584,6 +588,13 @@
 	hwif->tuneproc = &via82cxxx_tune_drive;
 	hwif->speedproc = &via_set_drive;
 
+
+#if defined(CONFIG_PPC_MULTIPLATFORM) && defined(CONFIG_PPC32)
+	if(_machine == _MACH_chrp && _chrp_type == _CHRP_Pegasos) {
+		hwif->irq = hwif->channel ? 15 : 14;
+	}
+#endif
+
 	for (i = 0; i < 2; i++) {
 		hwif->drives[i].io_32bit = 1;
 		hwif->drives[i].unmask = (via_config->flags & VIA_NO_UNMASK) ? 0 : 1;
@@ -620,8 +631,7 @@
 
 static int __devinit via_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_setup_pci_device(dev, &via82cxxx_chipset);
-	return 0;
+	return ide_setup_pci_device(dev, &via82cxxx_chipset);
 }
 
 static struct pci_device_id via_pci_tbl[] = {
diff -Naur linuxppc-2.6.9/drivers/ide/ppc/ibm_ocp_ide.c linuxppc-2.6.9-dream/drivers/ide/ppc/ibm_ocp_ide.c
--- linuxppc-2.6.9/drivers/ide/ppc/ibm_ocp_ide.c	2005-10-01 14:12:17.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ppc/ibm_ocp_ide.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,14 +1,26 @@
-/*
- *    Copyright 2002 MontaVista Software Inc.
- *      Completed implementation.
- *      Author: Armin Kuster <akuster@mvista.com>
- *      MontaVista Software, Inc.  <source@mvista.com>
+	/*
+ * IDE driver for IBM On-chip IDE contollers
+ *    Copyright 2001 - 2002 MontaVista Software Inc.
+ *    Dan Malek.
+ *
+ *    Version 1.2 (01/30/12) Armin
+ *    Converted to ocp
+ *    merger up to new ide-timing.h
  *
- *    Module name: ibm_ocp_ide.c
+ *    Version 2.0 (05/02/15) - armin
+ *    converted to new core_ocp and only supports one interface for now.
  *
- *    Description:
+ *    Version 2.1 (05/25/02) - armin
+ *      name change from *_driver to *_dev
+ *    Version 2.2 06/13/02 - Armin
+ *      changed irq_resource array to just irq
  *
- *    Based on ocp_stbxxxx.c
+ *    Version 2.3 (Feb 2005) - andre
+ *      - big rewrite to fix some serious bugs
+ *      - bring up to date with ide in 2.6.11-rc3
+ *      - DMA works correctly now, even with non-hard-disks
+ *        I snagged bits and pieces from a variety of drivers, primarily
+ *        ide-pmac.c and ide-dma.c .....thanks to previous authors!
  */
 
 #include <linux/types.h>
@@ -17,54 +29,63 @@
 #include <linux/hdreg.h>
 #include <linux/delay.h>
 #include <linux/ide.h>
-#include "../ide-timing.h"
+#include <ide-timing.h>
 #include <asm/ocp.h>
 #include <asm/io.h>
 #include <asm/scatterlist.h>
-#include <asm/ppc4xx_dma.h>
-
-#include "ide_modes.h"
-
-#define IDE_VER			"2.0"
-ppc_dma_ch_t dma_ch;
+#include <asm/dma-mapping.h>
 
-/* use DMA channel 2 for IDE DMA operations */
-#define IDE_DMACH	2	/* 2nd DMA channel */
-#define IDE_DMA_INT	6	/* IDE dma channel 2 interrupt */
+#define OCPVR	"2.3"
 
-#define WMODE	0		/* default to DMA line mode */
-#define PIOMODE	0
+#ifdef CONFIG_DM7020
+#define NR_HWIF 2
+static void dreambox_set_ide_bus(int bus)
+{
+#define MUXO 0x36
+#define MUXOD 0x37
+#define MUXTC 0x38
+	unsigned long temp = mfdcr(MUXO);
+	if (!bus)
+		temp |=  0x80000000 >> 25;
+	else
+		temp &=~(0x80000000 >> 25);
+	mtdcr(MUXO, temp);
+}
+#else
+#define NR_HWIF 1
+#endif
 
 #define MK_TIMING(AS, DIOP, DIOY, DH) \
-	((FIT((AS),    0, 15) << 27) | \
-	 (FIT((DIOP),  0, 63) << 20) | \
-	 (FIT((DIOY),  0, 63) << 13) | \
-	 (FIT((DH),    0,  7) << 9))
+	((FIT((AS),    0, 0x0f) << 27) | \
+	 (FIT((DIOP),  0, 0x3f) << 20) | \
+	 (FIT((DIOY),  0, 0x3f) << 13) | \
+	 (FIT((DH),    0, 0x07) <<  9))
 
 #define UTIMING_SETHLD	(EZ(20 /*tACK*/, SYS_CLOCK_NS) - 1 /*fixed cycles*/)
 #define UTIMING_ENV	(EZ(20 /*tENV*/, SYS_CLOCK_NS) - 1 /*fixed cycles*/)
 #define UTIMING_SS	(EZ(50 /*tSS */, SYS_CLOCK_NS) - 3 /*fixed cycles*/)
+
 #define MK_UTIMING(CYC, RP) \
-	((FIT(UTIMING_SETHLD, 0, 15) << 27) | \
-	 (FIT(UTIMING_ENV,    0, 15) << 22) | \
-	 (FIT((CYC),          0, 15) << 17) | \
-	 (FIT((RP),           0, 63) << 10) | \
-	 (FIT(UTIMING_SS,     0, 15) << 5)  | \
+	((FIT(UTIMING_SETHLD, 0, 0x0f) << 27) | \
+	 (FIT(UTIMING_ENV,    0, 0x0f) << 22) | \
+	 (FIT((CYC),          0, 0x0f) << 17) | \
+	 (FIT((RP),           0, 0x3f) << 10) | \
+	 (FIT(UTIMING_SS,     0, 0x0f) <<  5) | \
 	 1 /* Turn on Ultra DMA */)
 
 /* Define the period of the STB clock used to generate the
  * IDE bus timing.  The clock is actually 63 MHz, but it
- * get rounded in a favorable direction.
+ * gets rounded in a favorable direction.
  */
 #define IDE_SYS_FREQ	63	/* MHz */
-#define SYS_CLOCK_NS	(1000 / IDE_SYS_FREQ)
+#define SYS_CLOCK_NS	(1000 / IDE_SYS_FREQ)   /* 1takt == SYS_CLOCK_NS nanosekunden */
 
 struct whold_timing {
 	short mode;
 	short whold;
 };
 
-static struct whold_timing whold_timing[] = {
+static const struct whold_timing whold_timing[] = {
 
 	{XFER_UDMA_5, 0},
 	{XFER_UDMA_4, 0},
@@ -101,10 +122,10 @@
  * but rather "fast" and "slow" timing.  We have to determeine
  * which is the "fast" device based upon their capability.
  */
-static int pio_mode[2];
+static int pio_mode[2] = { -1, -1 };
+
 
-/* Structure of the memory mapped IDE control.
-*/
+/* structure of the memory mapped IDE control */
 typedef struct ide_regs {
 	unsigned int si_stat;	/* IDE status */
 	unsigned int si_intenable;	/* IDE interrupt enable */
@@ -114,8 +135,8 @@
 	unsigned int si_c0fpt;	/* Chan 0 Fast PIO transfer timing */
 	unsigned int si_c0timo;	/* Chan 0 timeout */
 	unsigned int pad1[2];
-	unsigned int si_c0d0u;	/* Chan 0 UDMA transfer timing */
-#define si_c0d0m si_c0d0u	/* Chan 0 Multiword DMA timing */
+	unsigned int si_c0d0u;	/* Chan 0 dev 0 UDMA timing */
+#define si_c0d0m si_c0d0u	/* Chan 0 dev 0 Multiword DMA timing */
 	unsigned int pad2;
 	unsigned int si_c0d1u;	/* Chan 0 dev 1 UDMA timing */
 #define si_c0d1m si_c0d1u	/* Chan 0 dev 1 Multiword DMA timing */
@@ -141,6 +162,50 @@
 	unsigned char si_c0scm;	/* Chan 0 status/command */
 } ide_t;
 
+#if NR_HWIF == 2
+static int shadow_valid;
+static ide_t shadow_regs;
+static int current_bus = -1;
+static void dreambox_ide_selectproc(ide_drive_t *drive)
+{
+	volatile ide_t __iomem * const idp = HWIF (drive)->hwif_data;
+	int newbus = drive->hwif->index;
+	if (current_bus != newbus)
+	{
+//		printk("select %d\n", newbus);
+		if (current_bus != -1)
+		{
+			if (!shadow_valid)
+			{
+				printk("initializing!\n");
+#define SWAP(x) shadow_regs.si_##x = idp->si_##x;
+				SWAP(c0rt);
+				SWAP(c0fpt);
+				SWAP(c0timo);
+				SWAP(c0d0u);
+				SWAP(c0d1u);
+				SWAP(c0c);
+#undef SWAP
+				shadow_valid = 1;
+			} else
+			{
+				u32 tmp;
+#define SWAP(x) tmp = idp->si_##x; idp->si_##x = shadow_regs.si_##x; shadow_regs.si_##x = tmp;
+				SWAP(c0rt);
+				SWAP(c0fpt);
+				SWAP(c0timo);
+				SWAP(c0d0u);
+				SWAP(c0d1u);
+				SWAP(c0c);
+#undef SWAP
+			}
+		}
+		dreambox_set_ide_bus(newbus);
+		current_bus = newbus;
+	}
+}
+#endif
+
 /* The structure of the PRD entry.  The address must be word aligned,
  * and the count must be an even number of bytes.
  */
@@ -148,84 +213,74 @@
 	unsigned int prd_physptr;
 	unsigned int prd_count;	/* Count only in lower 16 bits */
 } prd_entry_t;
-#define PRD_EOT		(uint)0x80000000	/* Set in prd_count */
+#define PRD_EOT		0x80000000lu	/* Set in prd_count */
 
 /* The number of PRDs required in a single transfer from the upper IDE
- * functions.  I believe the maximum number is 128, but most seem to
- * code to 256.  It's probably best to keep this under one page......
+ * functions. The maximum number is 128 (ide.h), but most seem to code to
+ * 256 (because of having two IDE channels). must be less than one page.
  */
-#define NUM_PRD	256
+#define NUM_PRD 256
 
-static volatile ide_t *idp;
-/* Virtual and physical address of the PRD page.
-*/
-static prd_entry_t *prd_table;
-static dma_addr_t prd_phys;
-
-/* Function Prototypes */
-static void ocp_ide_tune_drive(ide_drive_t *, byte);
-static int ocp_ide_dma_off(ide_drive_t * drive);
 
-/* The STB04 has a fixed number of cycles that get added in
- * regardless.  Adjust an ide_timing struct to accommodate that.
- */
-static void
-ocp_ide_adjust_timing(struct ide_timing *t)
-{
-	t->setup -= 2;
-	t->act8b -= 1;
-	t->rec8b -= 1;
-	t->active -= 1;
-	t->recover -= 1;
-}
 
-/* this iis barrowed from ide_timing_find_mode so we can find the proper 
- * whold parameter 
+/* this is borrowed from ide_timing_find_mode so we can find the proper
+ * whold parameter
  */
-
 static short
 whold_timing_find_mode(short speed)
 {
-	struct whold_timing *t;
+	const struct whold_timing *t;
+
+	for (t = whold_timing; likely (t->mode >= 0); t++)
+		if (t->mode == speed)
+			return t->whold;
+
+	return 0;
+}
 
-	for (t = whold_timing; t->mode != speed; t++)
-		if (t->mode < 0)
-			return 0;
-	return t->whold;
+/* The STB04 has a fixed number of cycles that get added in
+ * regardless.  Adjust an ide_timing struct to accommodate that.
+ */
+static void
+stb04xxx_ide_adjust_timing(struct ide_timing * const t)
+{
+	t->setup   -= 2;
+	t->act8b   -= 1;
+	t->rec8b   -= 1;
+	t->active  -= 1;
+	t->recover -= 1;
 }
 
 static int
-ocp_ide_set_drive(ide_drive_t * drive, unsigned char speed)
+stb04xxx_ide_tune_chipset (ide_drive_t * const drive,
+			   u8           speed)
 {
-	ide_drive_t *peer;
-	struct ide_timing d, p, merge, *fast;
-	int fast_device;
-	unsigned int ctl;
-	volatile unsigned int *dtiming;
+	volatile ide_t __iomem * const ide_regs  = HWIF (drive)->hwif_data;
+	ide_drive_t       *peer        = HWIF (drive)->drives + (~drive->dn & 1);
+	struct ide_timing  t, p, merge, *fast;
+	int                fast_device;
+	unsigned int       ctl;
 
 	if (speed != XFER_PIO_SLOW && speed != drive->current_speed)
 		if (ide_config_drive_speed(drive, speed))
-			printk(KERN_WARNING
-			       "ide%d: Drive %d didn't accept speed setting. Oh, well.\n",
-			       drive->dn >> 1, drive->dn & 1);
-
-	ide_timing_compute(drive, speed, &d, SYS_CLOCK_NS, SYS_CLOCK_NS);
-	ocp_ide_adjust_timing(&d);
+			printk (KERN_WARNING
+				"ide%d: Drive %d didn't accept speed setting. "
+				"Oh, well.\n",
+				HWIF(drive)->index, drive->dn & 1);
 
-	/* This should be set somewhere else, but it isn't.....
-	 */
-	drive->dn = ((drive->select.all & 0x10) != 0);
-	peer = HWIF(drive)->drives + (~drive->dn & 1);
+	ide_timing_compute(drive, speed, &t, SYS_CLOCK_NS, SYS_CLOCK_NS);
+	stb04xxx_ide_adjust_timing(&t);
 
+	/* peer is the other, i.e. not current, drive */
 	if (peer->present) {
 		ide_timing_compute(peer, peer->current_speed, &p,
 				   SYS_CLOCK_NS, SYS_CLOCK_NS);
-		ocp_ide_adjust_timing(&p);
-		ide_timing_merge(&p, &d, &merge,
+		stb04xxx_ide_adjust_timing(&p);
+		ide_timing_merge(&p, &t, &merge,
 				 IDE_TIMING_8BIT | IDE_TIMING_SETUP);
-	} else {
-		merge = d;
 	}
+	else
+		merge = t;
 
 	if (!drive->init_speed)
 		drive->init_speed = speed;
@@ -235,58 +290,59 @@
 	 * interface timing.  It would sure be nice if they would
 	 * have just had the timing registers for each device......
 	 */
-	if (drive->dn & 1)
-		pio_mode[1] = (int) speed;
-	else
-		pio_mode[0] = (int) speed;
-
-	if (pio_mode[0] > pio_mode[1])
-		fast_device = 0;
-	else
-		fast_device = 1;
+	/* change pio_mode of current drive */
+	pio_mode[(drive->dn & 1)] = (int) speed;
 
 	/* Now determine which of the drives
 	 * the first call we only know one device, and on subsequent
 	 * calls the user may manually change drive parameters.
 	 * Make timing[0] the fast device and timing[1] the slow.
 	 */
+
+	/* compare pio_mode of both drives, one of them is
+	   faster than the other */
+	if (pio_mode[0] >= pio_mode[1])
+		fast_device = 0;
+	else
+		fast_device = 1;
+
 	if (fast_device == (drive->dn & 1))
-		fast = &d;
+		/* if fast drive == current drive */
+		fast = &t;
 	else
+		/* if fast drive == peer (other) drive */
 		fast = &p;
 
 	/* Now we know which device is the fast one and which is
 	 * the slow one.  The merged timing goes into the "regular"
 	 * timing registers and represents the slower of both times.
 	 */
-
-	idp->si_c0rt = MK_TIMING(merge.setup, merge.act8b,
-				 merge.rec8b,
-				 whold_timing_find_mode(merge.mode));
-
-	idp->si_c0fpt = MK_TIMING(fast->setup, fast->act8b,
-				  fast->rec8b,
-				  whold_timing_find_mode(fast->mode));
-
-	/* Tell the interface which drive is the fast one.
-	 */
-	ctl = idp->si_c0c;	/* Chan 0 Control */
-	ctl &= ~0x10000000;
+	ide_regs->si_c0rt = MK_TIMING(merge.setup, merge.act8b,
+				      merge.rec8b,
+				      whold_timing_find_mode(merge.mode));
+
+	ide_regs->si_c0fpt = MK_TIMING(fast->setup, fast->act8b,
+				       fast->rec8b,
+				       whold_timing_find_mode(fast->mode));
+
+	/* tell the interface which drive is the fast one. 	 */
+	ctl = ide_regs->si_c0c; /* Chan 0 Control */
+	ctl &= ~0x10000000ul;
 	ctl |= fast_device << 28;
-	idp->si_c0c = ctl;
+	ide_regs->si_c0c = ctl;
 
-	/* Set up DMA timing.
-	 */
+	/* Set up DMA timing. */
 	if ((speed & XFER_MODE) != XFER_PIO) {
 		/* NOTE: si_c0d0m and si_c0d0u are two different names
 		 * for the same register.  Whether it is used for
 		 * Multi-word DMA timings or Ultra DMA timings is
 		 * determined by the LSB written into it.  This is also
 		 * true for si_c0d1m and si_c0d1u.  */
+		volatile unsigned int __iomem *dtiming;
 		if (drive->dn & 1)
-			dtiming = &(idp->si_c0d1m);
+			dtiming = &(ide_regs->si_c0d1u);
 		else
-			dtiming = &(idp->si_c0d0m);
+			dtiming = &(ide_regs->si_c0d0u);
 
 		if ((speed & XFER_MODE) == XFER_UDMA) {
 			static const int tRP[] = {
@@ -295,18 +351,18 @@
 				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
 				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
 				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
-				EZ(85, SYS_CLOCK_NS) - 2	/*fixed cycles */
+				EZ( 85, SYS_CLOCK_NS) - 2 /*fixed cycles */
 			};
 			static const int NUMtRP =
 			    (sizeof (tRP) / sizeof (tRP[0]));
 			*dtiming =
-			    MK_UTIMING(d.udma,
+			    MK_UTIMING(t.udma,
 				       tRP[FIT(speed & 0xf, 0, NUMtRP - 1)]);
 		} else {
-			/* Multi-word DMA.  Note that d.recover/2 is an
+			/* Multi-word DMA.  Note that t.recover/2 is an
 			 * approximation of MAX(tH, MAX(tJ, tN)) */
-			*dtiming = MK_TIMING(d.setup, d.active,
-					     d.recover, d.recover / 2);
+			*dtiming = MK_TIMING(t.setup, t.active,
+					     t.recover, t.recover / 2);
 		}
 		drive->using_dma = 1;
 	}
@@ -314,590 +370,538 @@
 	return 0;
 }
 
+
+/**
+ *	stb04xxx_ide_tune_drive - tune a drive attached to a stb04
+ *	@drive: drive to tune
+ *	@pio: desired PIO mode (255 for "best possible")
+ *
+ *	Set the interface PIO mode.
+ */
 static void
-ocp_ide_tune_drive(ide_drive_t * drive, byte pio)
+stb04xxx_ide_tune_drive (ide_drive_t * const drive,
+			 u8           pio)
 {
-	pio = ide_get_best_pio_mode(drive, pio, 5, NULL);
+	pio = ide_get_best_pio_mode (drive, pio, 4, NULL);
+	stb04xxx_ide_tune_chipset(drive, XFER_PIO_0 + pio);
 }
 
-/*
- * Fill in the next PRD entry.
- */
+static int
+stb04xxx_ide_dma_host_off (ide_drive_t * const drive)
+{
+	return 0;
+}
+static int stb04xxx_ide_dma_host_on (ide_drive_t * const drive) __attribute__((alias("stb04xxx_ide_dma_host_off")));
 
-static int ocp_ide_build_prd_entry(prd_entry_t **table, unsigned int paddr, 
-				   unsigned int size, int *count)
+static int
+stb04xxx_ide_dma_off_quietly (ide_drive_t * const drive)
 {
+	drive->using_dma = 0;
+	return stb04xxx_ide_dma_host_off (drive);
+}
 
-	/*
-	 * Note that one PRD entry can transfer
-	 * at most 65535 bytes.
+/**
+ *	stb04xxx_ide_dma_check - set up for DMA if possible
+ *	@drive: IDE drive to set up
+ *
+ *	Set up the drive for the highest supported speed considering the
+ *	driver, controller and cable
+ */
+static int
+stb04xxx_ide_dma_check (ide_drive_t * const drive)
+{
+	/* Allow UDMA_66 only if an 80 conductor cable is connected. */
+	u16 w80 = HWIF (drive)->udma_four;
+
+	/* Section 1.6.2.6 "IDE Controller, ATA/ATAPI-5" in the STB04xxx
+	 * Datasheet says the following modes are supported:
+	 *   PIO modes 0 to 4
+	 *   Multiword DMA modes 0 to 2
+	 *   UltraDMA modes 0 to 4
+	 */
+	int modes = XFER_PIO | XFER_EPIO | XFER_MWDMA | XFER_UDMA
+		    | (w80 ? XFER_UDMA_66 : 0);
+	int mode;
+
+	/* XFER_EPIO includes both PIO modes 4 and 5.  Mode 5 is not
+	 * valid for the STB04, so mask it out of consideration just
+	 * in case some drive sets it...
 	 */
+	drive->id->eide_pio_modes &= ~4;
+
+	mode = ide_find_best_mode (drive, modes);
+
+	drive->using_dma = 0;
+	stb04xxx_ide_tune_chipset (drive, mode);
+	if (HWIF (drive)->autodma
+	    && (((mode & XFER_MODE) == XFER_PIO)
+		|| ((mode & XFER_MODE) == XFER_EPIO)))
+		drive->using_dma = 0;
 
+	return 0;
+}
+
+static int
+stb04xxx_ide_dma_on (ide_drive_t * const drive)
+{
+	drive->using_dma = 1;
+	return stb04xxx_ide_dma_host_on (drive);
+}
+
+
+/* fill in the next PRD entry
+   note that one PRD entry can transfer at most 65536 bytes */
+static int
+build_prd_entry (prd_entry_t **table,
+		 u32           paddr,
+		 u32           size,
+		 int          *count)
+{
 	while (size) {
-		unsigned int tc = (size < 0xfe00) ? size : 0xfe00;
+		u16 tc = size & 0xffff;
+
+		if (unlikely (*count >= NUM_PRD)) {
+//			printk (KERN_WARNING "%s: DMA table too small\n",
+//					     __FUNCTION__);
+			return 0;	/* revert to PIO for this request */
+		}
 
-		if (++(*count) >= NUM_PRD) {
-		  printk(KERN_WARNING "DMA table too small\n");
+		/* data must be 16 byte aligned */
+		if (unlikely (paddr & 0xf)) {
+//			printk (KERN_WARNING
+//				"%s: DMA buffer not 16 byte aligned.\n",
+//				__FUNCTION__);
 			return 0;	/* revert to PIO for this request */
 		}
-		(*table)->prd_physptr = (paddr & 0xfffffffe);
 
-		if ((*table)->prd_physptr & 0xF) {
-			printk(KERN_WARNING "DMA buffer not 16 byte aligned.\n");
+		/* transfer count must be a multiple of 16 */
+		if (unlikely (tc & 0x0f)) {
+//			printk (KERN_WARNING
+//				"%s: invalid DMA transfer count.\n",
+//				__FUNCTION__);
 			return 0;	/* revert to PIO for this request */
 		}
 		
-		(*table)->prd_count = (tc & 0xfffe);
-		paddr += tc;
-		size -= tc;
+		(*table)->prd_physptr = paddr;
+		(*table)->prd_count   = tc;
+
+		paddr += (tc ? : 65536);
+		size  -= (tc ? : 65536);
+
 		++(*table);
+		++(*count);
 	}
 
 	return 1;
 }
 
+static int
+stb04xxx_ide_build_sglist (ide_drive_t        * const drive,
+			   ide_hwif_t         * const hwif,
+			   struct request     * const rq,
+			   struct scatterlist *sg)
+{
+	if ((rq->flags & REQ_DRIVE_TASKFILE) && rq->nr_sectors > 256)
+		BUG();
+
+	ide_map_sg(drive, rq);
+
+	hwif->sg_dma_direction = (rq_data_dir (rq) == READ) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
+	
+	return dma_map_sg(/* hwif->pci_dev */ NULL, sg, hwif->sg_nents,
+			  hwif->sg_dma_direction);
+}
 
 static int
-ocp_ide_build_dmatable(ide_drive_t * drive, int wr)
+stb04xxx_ide_build_dmatable (ide_drive_t    * const drive,
+			     ide_hwif_t     * const hwif,
+			     struct request * const rq)
 {
-	prd_entry_t *table;
-	int count = 0;
-	struct request *rq = HWGROUP(drive)->rq;
-	unsigned long size, vaddr, paddr;
-	unsigned long prd_size, prd_paddr = 0;
-	struct bio_vec *bvec, *bvprv;
-	struct bio *bio;
+	prd_entry_t  *table = (prd_entry_t *) hwif->dmatable_cpu;
+	unsigned int  count = 0;
 	int i;
+	struct scatterlist *sg = hwif->sg_table;
 
-	table = prd_table;
-
-	bvprv = NULL;
-	rq_for_each_bio(bio, rq) {
-		bio_for_each_segment(bvec, bio, i) {
-			paddr = bvec_to_phys(bvec);
-			vaddr = (unsigned long) __va(paddr);
-			size = bvec->bv_len;
-			if (wr)
-				consistent_sync((void *)vaddr, 
-						size, PCI_DMA_TODEVICE);
-			else
-				consistent_sync((void *)vaddr,
-						size, PCI_DMA_FROMDEVICE);
-
-			if (!BIOVEC_PHYS_MERGEABLE(bvprv, bvec)) {
-				if (ocp_ide_build_prd_entry(&table, 
-							    prd_paddr,
-							    prd_size,
-							    &count) == 0)
-					return 0; /* use PIO */
-				prd_paddr = 0;
-			}
+	hwif->sg_nents = i = stb04xxx_ide_build_sglist (drive, hwif, rq, sg);
 
-			if (prd_paddr == 0) {
-				prd_paddr = paddr;
-				prd_size = size;
-			} else {
-			  prd_size += size;
-			}
+	if (unlikely (!i))
+		goto use_pio_instead;
+	
+	++i;
+	while (--i) {
+		if (unlikely (!build_prd_entry (&table,
+						sg_dma_address (sg),
+						sg_dma_len (sg),
+						&count)))
+			goto use_pio_instead;
 
-			bvprv = bvec;
-		} /* segments in bio */
-	} /* bios in rq */
-
-	if (prd_paddr) {
-		if (ocp_ide_build_prd_entry(&table, 
-					    prd_paddr,
-					    prd_size,
-					    &count) == 0)
-			return 0; /* use PIO */
+		++sg;
 	}
 
-	/* Add the EOT to the last table entry.
-	 */
-	if (count) {
-		table--;
+	if (likely (count)) {
+		--table;
 		table->prd_count |= PRD_EOT;
-	} else {
-		printk(KERN_DEBUG "%s: empty DMA table?\n", drive->name);
+		return count;
 	}
 
-	return 1;
-}
+	printk (KERN_ERR "%s: empty DMA table?\n", drive->name);
 
-/*
- * ocp_ide_dma_intr() is the handler for disk read/write DMA interrupts
- * This is taken directly from ide-dma.c, which we can't use because
- * it requires PCI support.
- */
-ide_startstop_t
-ocp_ide_dma_intr(ide_drive_t * drive)
-{
-	int i;
-	byte stat, dma_stat;
-
-	dma_stat = HWIF(drive)->ide_dma_end(drive);
-	stat = HWIF(drive)->INB(IDE_STATUS_REG);	/* get drive status */
-	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | DRQ_STAT)) {
-		if (!dma_stat) {
-			struct request *rq = HWGROUP(drive)->rq;
-			rq = HWGROUP(drive)->rq;
-			for (i = rq->nr_sectors; i > 0;) {
-				i -= rq->current_nr_sectors;
-				ide_end_request(drive, 1, 
-						rq->current_nr_sectors );
-			}
-			return ide_stopped;
-		}
-		printk("%s: dma_intr: bad DMA status (dma_stat=%x)\n",
-		       drive->name, dma_stat);
-	}
-	return ide_error(drive, "dma_intr", stat);
+use_pio_instead:
+	dma_unmap_sg (NULL,
+		      hwif->sg_table, hwif->sg_nents, hwif->sg_dma_direction);
+	
+	return 0; /* revert to PIO for this request */
 }
+	
 
-/* ....and another one....
-*/
-int
-report_drive_dmaing(ide_drive_t * drive)
+static void
+stb04xxx_ide_destroy_dmatable (ide_drive_t * const drive)
 {
-	struct hd_driveid *id = drive->id;
-
-	if ((id->field_valid & 4) && (eighty_ninty_three(drive)) &&
-	    (id->dma_ultra & (id->dma_ultra >> 11) & 7)) {
-		if ((id->dma_ultra >> 13) & 1) {
-			printk(", UDMA(100)");	/* UDMA BIOS-enabled! */
-		} else if ((id->dma_ultra >> 12) & 1) {
-			printk(", UDMA(66)");	/* UDMA BIOS-enabled! */
-		} else {
-			printk(", UDMA(44)");	/* UDMA BIOS-enabled! */
-		}
-	} else if ((id->field_valid & 4) &&
-		   (id->dma_ultra & (id->dma_ultra >> 8) & 7)) {
-		if ((id->dma_ultra >> 10) & 1) {
-			printk(", UDMA(33)");	/* UDMA BIOS-enabled! */
-		} else if ((id->dma_ultra >> 9) & 1) {
-			printk(", UDMA(25)");	/* UDMA BIOS-enabled! */
-		} else {
-			printk(", UDMA(16)");	/* UDMA BIOS-enabled! */
-		}
-	} else if (id->field_valid & 4) {
-		printk(", (U)DMA");	/* Can be BIOS-enabled! */
-	} else {
-		printk(", DMA");
+	ide_hwif_t *hwif = drive->hwif;
+	int nents = hwif->sg_nents;
+	
+	if (nents) {
+		dma_unmap_sg (NULL, hwif->sg_table, nents,
+			      hwif->sg_dma_direction);
+		hwif->sg_nents = 0;
 	}
-	return 1;
 }
 
+
 static int
-ocp_ide_check_dma(ide_drive_t * drive)
+stb04xxx_dma_setup (ide_drive_t * const drive)
 {
-	struct hd_driveid *id = drive->id;
-	int enable = 1;
-	int speed;
-
-	drive->using_dma = 0;
-
-	if (drive->media == ide_floppy)
-		enable = 0;
-
-	/* Check timing here, we may be able to include XFER_UDMA_66
-	 * and XFER_UDMA_100.  This basically tells the 'best_mode'
-	 * function to also consider UDMA3 to UDMA5 device timing.
-	 */
-	if (enable) {
-		/* Section 1.6.2.6 "IDE Controller, ATA/ATAPI-5" in the STB04xxx
-		 * Datasheet says the following modes are supported:
-		 *   PIO modes 0 to 4
-		 *   Multiword DMA modes 0 to 2
-		 *   UltraDMA modes 0 to 4
-		 */
-		int map = XFER_PIO | XFER_EPIO | XFER_MWDMA | XFER_UDMA;
-		/* XFER_EPIO includes both PIO modes 4 and 5.  Mode 5 is not
-		 * valid for the STB04, so mask it out of consideration just
-		 * in case some drive sets it...
-		 */
-		id->eide_pio_modes &= ~4;
-
-		/* Allow UDMA_66 only if an 80 conductor cable is connected. */
-		if (eighty_ninty_three(drive))
-			map |= XFER_UDMA_66;
-
-		speed = ide_find_best_mode(drive, map);
-		ocp_ide_set_drive(drive, speed);
-
-		if (HWIF(drive)->autodma &&
-		    (((speed & XFER_MODE) == XFER_PIO) ||
-		     ((speed & XFER_MODE) == XFER_EPIO))) {
-			drive->using_dma = 0;
-		}
+	ide_hwif_t             * const hwif = HWIF (drive);
+	volatile ide_t __iomem * const ide_regs = (ide_t *) hwif->hwif_data;
+	struct request         * const rq = HWGROUP (drive)->rq;
+
+	/* PRD table */
+	if (unlikely (!stb04xxx_ide_build_dmatable (drive, hwif, rq))) {
+		/* try PIO instead of DMA */
+		ide_map_sg (drive, rq);
+		return 1;
 	}
 
-	return 0;
-}
+	ide_regs->si_c0tb = hwif->dmatable_dma; /* address of sg list */
+	ide_regs->si_c0s0 = 0xdc800000ul;       /* clear all status */
+	ide_regs->si_c0ie = 0x90000000ul;       /* enable all intr */
+	/* specify r/w */
+	ide_regs->si_c0dcm = (rq_data_dir (rq) == READ) ? 0x00000000ul : 0x08000000ul;
 
-static int ocp_ide_dma_off_quietly(ide_drive_t * drive)
-{
-	drive->using_dma = 0;
+	drive->waiting_for_dma = 1;
 	return 0;
 }
 
-static int ocp_ide_dma_off(ide_drive_t * drive)
+static void
+stb04xxx_dma_exec_cmd (ide_drive_t * const drive,
+		       u8           command)
 {
-	printk(KERN_INFO "%s: DMA disabled\n", drive->name);
-	return ocp_ide_dma_off_quietly(drive);
+	ide_execute_command (drive, command, &ide_dma_intr, 2*WAIT_CMD, NULL);
 }
 
-static int ocp_ide_dma_on(ide_drive_t * drive)
+static void
+stb04xxx_dma_start (ide_drive_t * const drive)
 {
-	return ocp_ide_check_dma(drive);
-}
+	volatile ide_t __iomem * const ide_regs  = (ide_t *) HWIF (drive)->hwif_data;
 
-static int ocp_ide_dma_check(ide_drive_t * drive)
-{
-	return ocp_ide_dma_on(drive);
+	/* start DMA */
+	mb ();
+	ide_regs->si_c0dcm |= 0x01000000ul; /* kick it */
 }
 
-static int __ocp_ide_dma_begin(ide_drive_t * drive, int writing)
+static int
+stb04xxx_ide_dma_end (ide_drive_t * const drive)
 {
-	idp->si_c0tb = (unsigned int) prd_phys;
-	idp->si_c0s0 = 0xdc800000;	/* Clear all status */
-	idp->si_c0ie = 0x90000000;	/* Enable all intr */
-	idp->si_c0dcm = 0;
-	idp->si_c0dcm =
-		(writing ? 0x09000000 : 0x01000000);
-	return 0;
-}
+	volatile ide_t __iomem * const ide_regs = (ide_t *) HWIF (drive)->hwif_data;
+	unsigned int    dstat;
 
-static int ocp_ide_dma_begin(ide_drive_t * drive)
-{
-	idp->si_c0tb = (unsigned int) prd_phys;
-	idp->si_c0s0 = 0xdc800000;	/* Clear all status */
-	idp->si_c0ie = 0x90000000;	/* Enable all intr */
-	idp->si_c0dcm = 0;
-	idp->si_c0dcm =	0x01000000;
-	return 0;
+	drive->waiting_for_dma = 0;
+	/* stop DMA */
+	ide_regs->si_c0dcm &= ~0x01000000ul;
+	/* get DMA status */
+	dstat = ide_regs->si_c0s1;
+	/* clear all status bits */
+	ide_regs->si_c0s0 = 0xdc800000ul;
+	wmb ();
+	stb04xxx_ide_destroy_dmatable (drive);
+	/* verify good dma status */
+	return (dstat & 0x10000000ul) ? 0 : 1; /* return true if DMA still active */
 }
 
-static int ocp_ide_dma_io(ide_drive_t * drive, int writing)
+static int
+stb04xxx_ide_dma_test_irq (ide_drive_t * const drive)
 {
-	if (!ocp_ide_build_dmatable(drive, writing))
-		return 1;
+	/* return 1 if dma irq issued, 0 otherwise */
+	volatile ide_t __iomem * const ide = (ide_t *) HWIF (drive)->hwif_data;
 
-	drive->waiting_for_dma = 1;
-	if (drive->media != ide_disk)
+#if NR_HWIF == 2
+	if (HWIF(drive)->index != current_bus)
 		return 0;
-	ide_set_handler(drive, &ocp_ide_dma_intr, WAIT_CMD, NULL);
-	HWIF(drive)->OUTB(writing ? WIN_WRITEDMA : WIN_READDMA,
-		 IDE_COMMAND_REG);
-	return __ocp_ide_dma_begin(drive, writing);
-}
+#endif
 
-static int ocp_ide_dma_read(ide_drive_t * drive)
-{
-	return ocp_ide_dma_io(drive, 0);
-}
+	if (ide->si_c0s0 & 0x10000000ul)
+		return 1;
+	if (!drive->waiting_for_dma) {
+		printk(KERN_WARNING "%s: (%s) called while not waiting\n",
+				    drive->name, __FUNCTION__);
+	}
 
-static int ocp_ide_dma_write(ide_drive_t * drive)
-{
-	return ocp_ide_dma_io(drive, 1);
+	return 0;
 }
 
-static int ocp_ide_dma_end(ide_drive_t * drive)
+static int
+stb04xxx_ide_dma_lostirq (ide_drive_t * const drive)
 {
-	unsigned int dstat;
-
-	drive->waiting_for_dma = 0;
-	dstat = idp->si_c0s1;
-	idp->si_c0s0 = 0xdc800000;	/* Clear all status */
-	/* verify good dma status */
-	return (dstat & 0x80000000);
+	printk ("%s: DMA interrupt recovery neccessary\n", drive->name);
+	return 1;
 }
 
-static int ocp_ide_dma_test_irq(ide_drive_t * drive)
+static int
+stb04xxx_ide_dma_timeout (ide_drive_t * const drive)
 {
-	return idp->si_c0s0 & 0x10000000 ? 1 : 0;
+	printk (KERN_ERR "%s: timeout waiting for DMA\n", drive->name);
+	if (stb04xxx_ide_dma_test_irq (drive))
+		return 0;
+	return stb04xxx_ide_dma_end (drive);
 }
 
-static int ocp_ide_dma_verbose(ide_drive_t * drive)
+static void
+stb04xxx_ide_setup_dma (ide_hwif_t * const hwif)
 {
-	return report_drive_dmaing(drive);
-}
+#ifdef CONFIG_DM7020
+	if ( !hwif->index )
+		hwif->udma_four = 1; //(ide_regs->si_c0s1 & 0x20000000ul) != 0;
+#endif
+	if ( hwif->index )
+		hwif->autodma = 0;
+	else
+	{
+		hwif->autodma = 1;
+		hwif->atapi_dma  = 1;
+		hwif->ultra_mask = hwif->udma_four ? 0x1f : 0x07;
+		hwif->mwdma_mask = 0x07;
+	}
 
-static unsigned int
-ocp_ide_spinup(int index)
-{
-	int i, ret;
-	ide_ioreg_t *io_ports;
+	hwif->drives[0].autotune = hwif->drives[1].autotune = IDE_TUNE_AUTO;
+	hwif->drives[0].autodma  = hwif->drives[1].autodma  = hwif->autodma;
 
-	ret = 1;
-	printk("OCP ide: waiting for drive spinup");
-	printk("ioports for drive %d @ %p\n",index,ide_hwifs[index].io_ports);
-	io_ports = ide_hwifs[index].io_ports;
-	printk(".");
-	
-	/* wait until drive is not busy (it may be spinning up) */
-	for (i = 0; i < 30; i++) {
-		unsigned char stat;
-		stat = inb_p(io_ports[7]);
-		/* wait for !busy & ready */
-		if ((stat & 0x80) == 0) {
-			break;
-		}
-		udelay(1000 * 1000);	/* 1 second */
-	}
+	/* set everything to something != NULL */
+	hwif->ide_dma_host_off = &stb04xxx_ide_dma_host_off;
+	hwif->ide_dma_host_on  = &stb04xxx_ide_dma_host_on;
 
-	printk(".");
+	hwif->ide_dma_check = &stb04xxx_ide_dma_check;
+	hwif->ide_dma_off_quietly = &stb04xxx_ide_dma_off_quietly;
+	hwif->ide_dma_on          = &stb04xxx_ide_dma_on;
 
-	/* select slave */
-	outb_p(0xa0 | 0x10, io_ports[6]);
+	hwif->dma_setup    = &stb04xxx_dma_setup;
+	hwif->dma_exec_cmd = &stb04xxx_dma_exec_cmd;
+	hwif->dma_start    = &stb04xxx_dma_start;
+	hwif->ide_dma_end  = &stb04xxx_ide_dma_end;
 
-	for (i = 0; i < 30; i++) {
-		unsigned char stat;
-		stat = inb_p(io_ports[7]);
-		/* wait for !busy & ready */
-		if ((stat & 0x80) == 0) {
-			break;
-		}
-		udelay(1000 * 1000);	/* 1 second */
-	}
-	if( i < 30){
-		outb_p(0xa0, io_ports[6]);
-		printk("Drive spun up \n");
-	} else {
-		printk("Drive spin up Failed !\n");
-		ret = 0;
-	}
-	return (ret);
-}
+	hwif->ide_dma_test_irq = &stb04xxx_ide_dma_test_irq;
 
-int
-ocp_ide_default_irq(ide_ioreg_t base)
-{
-	return IDE0_IRQ;
+	hwif->ide_dma_lostirq = &stb04xxx_ide_dma_lostirq;
+	hwif->ide_dma_timeout = &stb04xxx_ide_dma_timeout;
 }
 
-/*
- * setup_ocp_ide()
- * Completes the setup of a on-chip ide controller card, once found.
- */
-int __init setup_ocp_ide (struct ocp_device *pdev)
+static int __init
+stb04xxx_ide_probe (struct ocp_device * const ocp)
 {
-	ide_hwif_t	*hwif;
-	unsigned int uicdcr;
+	int                     err;
+	unsigned int            uicdcr;
+	volatile ide_t __iomem *ide_regs;
+	unsigned long           flags;
+	unsigned char          * ip;
+	int                     i, index;
 	
-	hwif = &ide_hwifs[pdev->num];
-	hwif->index = pdev->num;
-#ifdef WMODE
-   /*Word Mode psc(11-12)=00,pwc(13-18)=000110, phc(19-21)=010, 22=1, 30=1  ----  0xCB02*/
-
-    dma_ch.mode	=TM_S_MM;	  /* xfer from peripheral to mem */
-    dma_ch.pwidth = PW_16;
-    dma_ch.pwc = 6;                     /* set the max wait cycles  */
-#else
-/*Line Mode psc(11-12)=00,pwc(13-18)=000001, phc(19-21)=010, 22=1, 30=1  ----  0x2B02*/
-
-    dma_ch.mode	=DMA_MODE_MM_DEVATSRC;	  /* xfer from peripheral to mem */
-    dma_ch.pwidth = PW_64;		/* Line mode on stbs */
-    dma_ch.pwc = 1;                     /* set the max wait cycles  */
-#endif
+	printk ("IBM STB04xxx OCP IDE driver version %s\n", OCPVR);
 
-    dma_ch.td	= DMA_TD;
-    dma_ch.buffer_enable = 0;
-    dma_ch.tce_enable = 0;
-    dma_ch.etd_output = 0;
-    dma_ch.pce = 0;
-    dma_ch.pl = EXTERNAL_PERIPHERAL;    /* no op */
-    dma_ch.dai = 1;
-    dma_ch.sai = 0;
-    dma_ch.psc = 0;                      /* set the max setup cycles */
-    dma_ch.phc = 2;                      /* set the max hold cycles  */
-    dma_ch.cp = PRIORITY_LOW;
-    dma_ch.int_enable = 0;
-    dma_ch.ch_enable = 0;		/* No chaining */
-    dma_ch.tcd_disable = 1;		/* No chaining */
-
-    if (hw_init_dma_channel(IDE_DMACH, &dma_ch) != DMA_STATUS_GOOD)
-        return -EBUSY;
-
-    /* init CIC select2 reg to connect external DMA port 3 to internal
-     * DMA channel 2
-     */
-    map_dma_port(IDE_DMACH,EXT_DMA_3,DMA_CHAN_2); 
-
-    /* Enable the interface.
-     */
-    idp->si_control = 0x80000000;
-    idp->si_c0s0 = 0xdc800000;	/* Clear all status */
-    idp->si_intenable = 0x80000000;
-
-    /* Per the STB04 data sheet:
-     *  1)  tTO = ((8*RDYT) + 1) * SYS_CLK
-     * and:
-     *  2)  tTO >= 1250 + (2 * SYS_CLK) - t2
-     * Solving the first equation for RDYT:
-     *             (tTO/SYS_CLK) - 1
-     *  3)  RDYT = -----------------
-     *                     8
-     * Substituting equation 2) for tTO in equation 3:
-     *             ((1250 + (2 * SYS_CLK) - t2)/SYS_CLK) - 1
-     *  3)  RDYT = -----------------------------------------
-     *                                8
-     * It's just the timeout so having it too long isn't too
-     * significant, so we'll just assume t2 is zero.  All this math
-     * is handled by the compiler and RDYT ends up being 11 assuming
-     * that SYS_CLOCK_NS is 15.
-     */
-    idp->si_c0timo = (EZ(EZ(1250 + 2 * SYS_CLOCK_NS, SYS_CLOCK_NS) - 1, 8)) << 23;	/* Chan 0 timeout */
-
-    /* Stuff some slow default PIO timing.
-     */
-    idp->si_c0rt = MK_TIMING(6, 19, 15, 2);
-    idp->si_c0fpt = MK_TIMING(6, 19, 15, 2);
-    
-    /* We should probably have UIC functions to set external
-     * interrupt level/edge.
-     */
-    uicdcr = mfdcr(DCRN_UIC_PR(UIC0));
-    uicdcr &= ~(0x80000000 >> IDE0_IRQ);
-    mtdcr(DCRN_UIC_PR(UIC0), uicdcr);
-    mtdcr(DCRN_UIC_TR(UIC0), 0x80000000 >> IDE0_IRQ);
-
-    /* Grab a page for the PRD Table.
-     */
-    prd_table = (prd_entry_t *) consistent_alloc(GFP_KERNEL,
-						 NUM_PRD *
-						 sizeof
-						 (prd_entry_t),
-						 &prd_phys);
-
-
-    if(!ocp_ide_spinup(hwif->index))
-	    return 0;
-    
-    return 1;
-}
+	if (!request_region (ocp->def->paddr, sizeof (ide_t), "ide"))
+		return -ENOMEM;
 
+	ocp_force_power_on (ocp);
 
-static int __devinit ocp_ide_probe(struct ocp_device *pdev)
-{
-	int i;
-	unsigned int index;
-	hw_regs_t * hw;
-	unsigned char *ip;
-
-	printk("IBM STB04xxx IDE driver version %s\n", IDE_VER);
+	ide_regs = ioremap (ocp->def->paddr, sizeof (ide_t));
+	if (unlikely (!ide_regs)) {
+		err = -ENOMEM;
+		goto error1;
+	}
+
+	/* Enable the interface. */
+	ide_regs->si_control = 0x80000000ul;
+	ide_regs->si_c0s0 = 0xdc800000ul;       /* Clear all status */
+	ide_regs->si_intenable = 0x80000000ul;
+	/* Per the STB04 data sheet:
+	 *  1)  tTO = ((8*RDYT) + 1) * SYS_CLK
+	 * and:
+	 *  2)  tTO >= 1250 + (2 * SYS_CLK) - t2
+	 * Solving the first equation for RDYT:
+	 *             (tTO/SYS_CLK) - 1
+	 *  3)  RDYT = -----------------
+	 *                     8
+	 * Substituting equation 2) for tTO in equation 3:
+	 *             ((1250 + (2 * SYS_CLK) - t2)/SYS_CLK) - 1
+	 *  3)  RDYT = -----------------------------------------
+	 *                                8
+	 * It's just the timeout so having it too long isn't too
+	 * significant, so we'll just assume t2 is zero.  All this math
+	 * is handled by the compiler and RDYT ends up being 11 assuming
+	 * that SYS_CLOCK_NS is 15.
+	 */
+	ide_regs->si_c0timo = (EZ(EZ(1250 + 2 * SYS_CLOCK_NS, SYS_CLOCK_NS) - 1, 8)) << 23;	/* Chan 0 timeout */
 
-	hw = kmalloc(sizeof(*hw), GFP_KERNEL);
-	if (!hw)
-		return 0;
-	memset(hw, 0, sizeof(*hw));
+	/* stuff some slow default PIO timing */
+	ide_regs->si_c0rt = MK_TIMING(6, 19, 15, 2);
+	ide_regs->si_c0fpt = MK_TIMING(6, 19, 15, 2);
+
+	/* enable 32bit access on both devices */
+	ide_regs->si_c0c |= 0x00008040ul;
+
+	/* we should probably have UIC functions to set external
+	   interrupt level/edge */
+	local_irq_save (flags);
+	uicdcr = mfdcr (DCRN_UIC_PR (UIC0));
+	uicdcr &= ~(0x80000000ul >> IDE0_IRQ);
+	mtdcr (DCRN_UIC_PR(UIC0), uicdcr);
+	mtdcr (DCRN_UIC_TR(UIC0),
+	       mfdcr (DCRN_UIC_TR (UIC0)) | (0x80000000ul >> IDE0_IRQ));
+	local_irq_restore (flags);
+
+	/* initialize */
+	ocp_set_drvdata (ocp, &ide_hwifs[0]);
+
+	for (index=0; index < NR_HWIF; ++index)
+	{
+		ide_hwifs[index].gendev.parent = &ocp->dev;
+		/* setup MMIO ops */
+		default_hwif_mmiops (&ide_hwifs[index]);
+
+		/* tell common code _not_q to mess with resources */
+		ide_hwifs[index].mmio = 2;
+		ide_set_hwifdata (&ide_hwifs[index], (void *) ide_regs);
+
+		ip = (unsigned char *) (&(ide_regs->si_c0d));    /* Chan 0 data */
+		for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++)
+			ide_hwifs[index].hw.io_ports[i] = (int) (ip++);
+		ide_hwifs[index].hw.io_ports[IDE_CONTROL_OFFSET] = (int) (&(ide_regs->si_c0adc));
+		memcpy (ide_hwifs[index].io_ports, ide_hwifs[index].hw.io_ports, sizeof (ide_hwifs[index].hw.io_ports));
+		ide_hwifs[index].chipset = ide_generic;
+		ide_hwifs[index].irq     = ocp->def->irq;
+		ide_hwifs[index].noprobe = 0;
+		ide_hwifs[index].hold    = 1;
+		ide_hwifs[index].index   = index;
+		/* Figure out if an 80 conductor cable is connected */
+
+		ide_hwifs[index].tuneproc  = &stb04xxx_ide_tune_drive;
+		ide_hwifs[index].speedproc = &stb04xxx_ide_tune_chipset;
+		ide_hwifs[index].drives[0].io_32bit = ide_hwifs[index].drives[1].io_32bit = 1;
+		ide_hwifs[index].drives[0].unmask   = ide_hwifs[index].drives[1].unmask   = 1;
+		pio_mode[0] = pio_mode[1] = -1;
 
-	if (!request_region(pdev->paddr, IDE0_SIZE, "IDE")) {
-		printk(KERN_WARNING "ocp_ide: failed request_region\n");
-		return -1;
+		stb04xxx_ide_setup_dma (&ide_hwifs[index]);
+	
+		ide_hwifs[index].sg_max_nents = NUM_PRD;
+#if NR_HWIF == 2
+		ide_hwifs[index].mate = &ide_hwifs[index^1];
+		ide_hwifs[index].serialized = 1;
+		ide_hwifs[index].selectproc = &dreambox_ide_selectproc;
+#endif
 	}
 
-	if ((idp = (ide_t *) ioremap(pdev->paddr,
-				     IDE0_SIZE)) == NULL) {
-		printk(KERN_WARNING "ocp_ide: failed ioremap\n");
-		return -1;
+	/* grab a page for the PRD table. this is save with respect to not
+	   crossing a 64k border because returned memory is page aligned
+	   and NUM_PRD*sizeof(prd_entry_t) end up being 2048 bytes, i.e.
+	   less than one page. */
+	ide_hwifs[0].dmatable_cpu = dma_alloc_coherent (NULL,
+		 NUM_PRD * sizeof (prd_entry_t),
+		 &ide_hwifs[0].dmatable_dma,
+		 GFP_KERNEL | GFP_DMA);
+	if (unlikely (!ide_hwifs[0].dmatable_cpu)) {
+		err = -ENOMEM;
+		goto error2;
 	}
 
-	pdev->dev.driver_data = (void *) idp;
+	for (index=0; index < NR_HWIF; ++index)
+		probe_hwif_init (&ide_hwifs[index]);
 
-	pdev->ocpdev  = (void *) hw;
-	index = pdev->num;
-	ip = (unsigned char *) (&(idp->si_c0d));	/* Chan 0 data */
+	return 0;
 
-	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
-		hw->io_ports[i] = (unsigned long) (ip++);
-	}
+error2:
+	ide_set_hwifdata (&ide_hwifs[index], NULL);
+	ide_hwifs[index].noprobe = 1;
+	ide_hwifs[index].chipset = ide_unknown;
+	ocp_set_drvdata (ocp, NULL);
+	iounmap (ide_regs);
+error1:
+	ocp_force_power_off (ocp);
+	release_region (ocp->def->paddr, sizeof (ide_t));
+	return err;
+}
 
-	hw->io_ports[IDE_CONTROL_OFFSET] = (unsigned long) (&(idp->si_c0adc));
-	hw->irq = pdev->irq;
+static void
+stb04xxx_ide_remove (struct ocp_device * const ocp)
+{
+	ide_hwif_t             * const hwif = ocp_get_drvdata (ocp);
+	volatile ide_t __iomem * const ide_regs = ide_get_hwifdata (hwif);
 
-	/* use DMA channel 2 for IDE DMA operations */
-	hw->dma = IDE_DMACH;
+	/* ide_unregister () can't ever handle these correctly for us */
+	dma_free_coherent (NULL, NUM_PRD * sizeof (prd_entry_t),
+		hwif->dmatable_cpu, hwif->dmatable_dma);
 
-	ide_hwifs[index].tuneproc = &ocp_ide_tune_drive;
-	ide_hwifs[index].drives[0].autotune = 1;
-	ide_hwifs[index].autodma = 1;
-	ide_hwifs[index].ide_dma_off = &ocp_ide_dma_off;
-	ide_hwifs[index].ide_dma_off_quietly = &ocp_ide_dma_off_quietly;
-	ide_hwifs[index].ide_dma_host_off = &ocp_ide_dma_off_quietly;
-	ide_hwifs[index].ide_dma_on = &ocp_ide_dma_on;
-	ide_hwifs[index].ide_dma_host_on = &ocp_ide_dma_on;
-	ide_hwifs[index].ide_dma_check = &ocp_ide_dma_check;
-	ide_hwifs[index].ide_dma_read = &ocp_ide_dma_read;
-	ide_hwifs[index].ide_dma_write = &ocp_ide_dma_write;
-	ide_hwifs[index].ide_dma_begin = &ocp_ide_dma_begin;
-	ide_hwifs[index].ide_dma_end = &ocp_ide_dma_end;
-	ide_hwifs[index].ide_dma_test_irq = &ocp_ide_dma_test_irq;
-	ide_hwifs[index].ide_dma_verbose = &ocp_ide_dma_verbose;
-	ide_hwifs[index].speedproc = &ocp_ide_set_drive;
-	ide_hwifs[index].noprobe = 0;
+	hwif->dmatable_cpu = NULL;
+	hwif->dmatable_dma = 0;
+	ide_unregister (hwif->index);
 
-	memcpy(ide_hwifs[index].io_ports, hw->io_ports, sizeof (hw->io_ports));
-	ide_hwifs[index].irq = pdev->irq;
+	iounmap (ide_regs);
+	release_region (ocp->def->paddr, sizeof (ide_t));
 
-	ocp_force_power_on(pdev);
-	return 1;
+	ocp_force_power_off (ocp);
 }
 
-static void __devexit ocp_ide_remove_one (struct ocp_device *pdev)
-{
-	ocp_force_power_off(pdev);
-}
 
-static struct ocp_device_id ocp_ide_id_tbl[] __devinitdata = {
-	{OCP_VENDOR_IBM,OCP_FUNC_IDE},
-	{0,}
+static struct ocp_device_id stb04xxx_ide_ids[] __devinitdata =
+{
+        { .vendor = OCP_VENDOR_IBM, .function = OCP_FUNC_IDE},
+        { .vendor = OCP_VENDOR_INVALID }
 };
 
-MODULE_DEVICE_TABLE(ocp,ocp_ide_id_tbl );
+MODULE_DEVICE_TABLE (ocp, stb04xxx_ide_ids);
 
-static struct ocp_driver ocp_ide_driver = {
-	.name		= "ocp_ide",
-	.id_table	= ocp_ide_id_tbl,
-	.probe		= ocp_ide_probe,
-	.remove		= __devexit_p(ocp_ide_remove_one),
+static struct ocp_driver stb04xxx_ide_driver = {
+	.name     = "ide",
+	.id_table = stb04xxx_ide_ids,
+	.probe    = stb04xxx_ide_probe,
+	.remove   = __devexit_p (stb04xxx_ide_remove),
 #if defined(CONFIG_PM)
-	.suspend	= ocp_generic_suspend,
-	.resume		= ocp_generic_resume,
-#endif /* CONFIG_PM */
+	.suspend  = NULL,
+	.resume   = NULL,
+#endif
 };
 
 
-void __init std_ide_cntl_scan(void)
-{
-	struct ocp_device *dev;
-	int i, max;
-	printk("OCP ide ver:%s\n", IDE_VER);
-
-	ocp_module_init(&ocp_ide_driver);
-	max = ocp_get_num(OCP_FUNC_IDE);
-	for(i = 0; i < max; i++){
-		dev = ocp_get_dev(OCP_FUNC_IDE,i);
-		if(!dev)	
-		  setup_ocp_ide(dev);
-	}
-}
-#if 0
-#if defined (CONFIG_MODULE)
-static int __init
-ocp_ide_init(void)
+int __init
+stb04xxx_ide_init (void)
 {
-	printk("OCP ide ver:%s\n", IDE_VER);
-	return ocp_module_init(&ocp_ide_driver);
+	return ocp_register_driver (&stb04xxx_ide_driver);
 }
 
-void __exit
-ocp_ide_fini(void)
+static void __exit
+stb04xxx_ide_exit (void)
 {
-	ocp_unregister_driver(&ocp_ide_driver);
+	ocp_unregister_driver (&stb04xxx_ide_driver);
 }
 
-module_init(ocp_ide_init);
-module_exit(ocp_ide_fini);
-#endif
+#if 0
+/* needs to be called after ide has been initialized */
+late_initcall (stb04xxx_ide_init);
 #endif
+// sorry..but late_initcall isn't working properly 
+// some entries in /proc/ide/hdX/ are missing ( e.g. capacity )
+// so we call stb04xxx_ide_init from within ide.c probe_for_hwifs
+
+
+module_exit (stb04xxx_ide_exit);
 
+MODULE_LICENSE ("GPL");
+MODULE_AUTHOR ("Andr Draszik <andid@gmx.net>");
+MODULE_DESCRIPTION ("driver for IBM OCP IDE on STB04xxx");
diff -Naur linuxppc-2.6.9/drivers/ide/ppc/pmac.c linuxppc-2.6.9-dream/drivers/ide/ppc/pmac.c
--- linuxppc-2.6.9/drivers/ide/ppc/pmac.c	2004-10-18 23:53:13.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/ppc/pmac.c	2005-06-20 10:46:11.000000000 +0200
@@ -34,6 +34,7 @@
 #include <linux/pci.h>
 #include <linux/adb.h>
 #include <linux/pmu.h>
+#include <linux/scatterlist.h>
 
 #include <asm/prom.h>
 #include <asm/io.h>
@@ -51,9 +52,7 @@
 
 #include "ide-timing.h"
 
-extern void ide_do_request(ide_hwgroup_t *hwgroup, int masked_irq);
-
-#define IDE_PMAC_DEBUG
+#undef IDE_PMAC_DEBUG
 
 #define DMA_WAIT_TIMEOUT	50
 
@@ -77,10 +76,6 @@
 	 */
 	volatile struct dbdma_regs __iomem *	dma_regs;
 	struct dbdma_cmd*		dma_table_cpu;
-	dma_addr_t			dma_table_dma;
-	struct scatterlist*		sg_table;
-	int				sg_nents;
-	int				sg_dma_direction;
 #endif
 	
 } pmac_ide_hwif_t;
@@ -361,7 +356,6 @@
 static void pmac_ide_tuneproc(ide_drive_t *drive, u8 pio);
 static void pmac_ide_selectproc(ide_drive_t *drive);
 static void pmac_ide_kauai_selectproc(ide_drive_t *drive);
-static int pmac_ide_dma_begin (ide_drive_t *drive);
 
 #endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
 
@@ -1245,6 +1239,8 @@
 		hwif->noprobe = 0;
 #endif /* CONFIG_PMAC_PBOOK */
 
+	hwif->sg_max_nents = MAX_DCMDS;
+
 #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
 	/* has a DBDMA controller channel */
 	if (pmif->dma_regs)
@@ -1364,10 +1360,10 @@
 	ide_hwif_t	*hwif = (ide_hwif_t *)dev_get_drvdata(&mdev->ofdev.dev);
 	int		rc = 0;
 
-	if (state != mdev->ofdev.dev.power_state && state >= 2) {
+	if (state != mdev->ofdev.dev.power.power_state && state >= 2) {
 		rc = pmac_ide_do_suspend(hwif);
 		if (rc == 0)
-			mdev->ofdev.dev.power_state = state;
+			mdev->ofdev.dev.power.power_state = state;
 	}
 
 	return rc;
@@ -1379,10 +1375,10 @@
 	ide_hwif_t	*hwif = (ide_hwif_t *)dev_get_drvdata(&mdev->ofdev.dev);
 	int		rc = 0;
 	
-	if (mdev->ofdev.dev.power_state != 0) {
+	if (mdev->ofdev.dev.power.power_state != 0) {
 		rc = pmac_ide_do_resume(hwif);
 		if (rc == 0)
-			mdev->ofdev.dev.power_state = 0;
+			mdev->ofdev.dev.power.power_state = 0;
 	}
 
 	return rc;
@@ -1472,10 +1468,10 @@
 	ide_hwif_t	*hwif = (ide_hwif_t *)pci_get_drvdata(pdev);
 	int		rc = 0;
 	
-	if (state != pdev->dev.power_state && state >= 2) {
+	if (state != pdev->dev.power.power_state && state >= 2) {
 		rc = pmac_ide_do_suspend(hwif);
 		if (rc == 0)
-			pdev->dev.power_state = state;
+			pdev->dev.power.power_state = state;
 	}
 
 	return rc;
@@ -1487,10 +1483,10 @@
 	ide_hwif_t	*hwif = (ide_hwif_t *)pci_get_drvdata(pdev);
 	int		rc = 0;
 	
-	if (pdev->dev.power_state != 0) {
+	if (pdev->dev.power.power_state != 0) {
 		rc = pmac_ide_do_resume(hwif);
 		if (rc == 0)
-			pdev->dev.power_state = 0;
+			pdev->dev.power.power_state = 0;
 	}
 
 	return rc;
@@ -1562,66 +1558,6 @@
 #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
 
 /*
- * This is very close to the generic ide-dma version of the function except
- * that we don't use the fields in the hwif but our own copies for sg_table
- * and friends. We build & map the sglist for a given request
- */
-static int __pmac
-pmac_ide_build_sglist(ide_drive_t *drive, struct request *rq)
-{
-	ide_hwif_t *hwif = HWIF(drive);
-	pmac_ide_hwif_t *pmif = (pmac_ide_hwif_t *)hwif->hwif_data;
-	struct scatterlist *sg = pmif->sg_table;
-	int nents;
-
-	nents = blk_rq_map_sg(drive->queue, rq, sg);
-		
-	if (rq_data_dir(rq) == READ)
-		pmif->sg_dma_direction = PCI_DMA_FROMDEVICE;
-	else
-		pmif->sg_dma_direction = PCI_DMA_TODEVICE;
-
-	return pci_map_sg(hwif->pci_dev, sg, nents, pmif->sg_dma_direction);
-}
-
-/*
- * Same as above but for a "raw" taskfile request
- */
-static int __pmac
-pmac_ide_raw_build_sglist(ide_drive_t *drive, struct request *rq)
-{
-	ide_hwif_t *hwif = HWIF(drive);
-	pmac_ide_hwif_t *pmif = (pmac_ide_hwif_t *)hwif->hwif_data;
-	struct scatterlist *sg = pmif->sg_table;
-	int nents = 0;
-	ide_task_t *args = rq->special;
-	unsigned char *virt_addr = rq->buffer;
-	int sector_count = rq->nr_sectors;
-
-	if (args->command_type == IDE_DRIVE_TASK_RAW_WRITE)
-		pmif->sg_dma_direction = PCI_DMA_TODEVICE;
-	else
-		pmif->sg_dma_direction = PCI_DMA_FROMDEVICE;
-	
-	if (sector_count > 128) {
-		memset(&sg[nents], 0, sizeof(*sg));
-		sg[nents].page = virt_to_page(virt_addr);
-		sg[nents].offset = offset_in_page(virt_addr);
-		sg[nents].length = 128  * SECTOR_SIZE;
-		nents++;
-		virt_addr = virt_addr + (128 * SECTOR_SIZE);
-		sector_count -= 128;
-	}
-	memset(&sg[nents], 0, sizeof(*sg));
-	sg[nents].page = virt_to_page(virt_addr);
-	sg[nents].offset = offset_in_page(virt_addr);
-	sg[nents].length =  sector_count  * SECTOR_SIZE;
-	nents++;
-   
-	return pci_map_sg(hwif->pci_dev, sg, nents, pmif->sg_dma_direction);
-}
-
-/*
  * pmac_ide_build_dmatable builds the DBDMA command list
  * for a transfer and sets the DBDMA channel to point to it.
  */
@@ -1644,16 +1580,13 @@
 	while (readl(&dma->status) & RUN)
 		udelay(1);
 
-	/* Build sglist */
-	if (HWGROUP(drive)->rq->flags & REQ_DRIVE_TASKFILE)
-		pmif->sg_nents = i = pmac_ide_raw_build_sglist(drive, rq);
-	else
-		pmif->sg_nents = i = pmac_ide_build_sglist(drive, rq);
+	hwif->sg_nents = i = ide_build_sglist(drive, rq);
+
 	if (!i)
 		return 0;
 
 	/* Build DBDMA commands list */
-	sg = pmif->sg_table;
+	sg = hwif->sg_table;
 	while (i && sg_dma_len(sg)) {
 		u32 cur_addr;
 		u32 cur_len;
@@ -1698,16 +1631,16 @@
 		memset(table, 0, sizeof(struct dbdma_cmd));
 		st_le16(&table->command, DBDMA_STOP);
 		mb();
-		writel(pmif->dma_table_dma, &dma->cmdptr);
+		writel(hwif->dmatable_dma, &dma->cmdptr);
 		return 1;
 	}
 
 	printk(KERN_DEBUG "%s: empty DMA table?\n", drive->name);
  use_pio_instead:
 	pci_unmap_sg(hwif->pci_dev,
-		     pmif->sg_table,
-		     pmif->sg_nents,
-		     pmif->sg_dma_direction);
+		     hwif->sg_table,
+		     hwif->sg_nents,
+		     hwif->sg_dma_direction);
 	return 0; /* revert to PIO for this request */
 }
 
@@ -1715,14 +1648,14 @@
 static void __pmac
 pmac_ide_destroy_dmatable (ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	struct pci_dev *dev = HWIF(drive)->pci_dev;
-	pmac_ide_hwif_t* pmif = (pmac_ide_hwif_t *)HWIF(drive)->hwif_data;
-	struct scatterlist *sg = pmif->sg_table;
-	int nents = pmif->sg_nents;
+	struct scatterlist *sg = hwif->sg_table;
+	int nents = hwif->sg_nents;
 
 	if (nents) {
-		pci_unmap_sg(dev, sg, nents, pmif->sg_dma_direction);
-		pmif->sg_nents = 0;
+		pci_unmap_sg(dev, sg, nents, hwif->sg_dma_direction);
+		hwif->sg_nents = 0;
 	}
 }
 
@@ -1885,7 +1818,7 @@
  * a read on KeyLargo ATA/66 and mark us as waiting for DMA completion
  */
 static int __pmac
-pmac_ide_dma_start(ide_drive_t *drive, int reading)
+pmac_ide_dma_setup(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 	pmac_ide_hwif_t* pmif = (pmac_ide_hwif_t *)hwif->hwif_data;
@@ -1897,12 +1830,14 @@
 		return 1;
 	ata4 = (pmif->kind == controller_kl_ata4);	
 
-	if (!pmac_ide_build_dmatable(drive, rq))
+	if (!pmac_ide_build_dmatable(drive, rq)) {
+		ide_map_sg(drive, rq);
 		return 1;
+	}
 
 	/* Apple adds 60ns to wrDataSetup on reads */
 	if (ata4 && (pmif->timings[unit] & TR_66_UDMA_EN)) {
-		writel(pmif->timings[unit] + (reading ? 0x00800000UL : 0),
+		writel(pmif->timings[unit] + (!rq_data_dir(rq) ? 0x00800000UL : 0),
 			PMAC_IDE_REG(IDE_TIMING_CONFIG));
 		(void)readl(PMAC_IDE_REG(IDE_TIMING_CONFIG));
 	}
@@ -1912,87 +1847,28 @@
 	return 0;
 }
 
-/*
- * Start a DMA READ command
- */
-static int __pmac
-pmac_ide_dma_read(ide_drive_t *drive)
-{
-	struct request *rq = HWGROUP(drive)->rq;
-	u8 lba48 = (drive->addressing == 1) ? 1 : 0;
-	task_ioreg_t command = WIN_NOP;
-
-	if (pmac_ide_dma_start(drive, 1))
-		return 1;
-
-	if (drive->media != ide_disk)
-		return 0;
-
-	command = (lba48) ? WIN_READDMA_EXT : WIN_READDMA;
-	
-	if (drive->vdma)
-		command = (lba48) ? WIN_READ_EXT: WIN_READ;
-		
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-
-	/* issue cmd to drive */
-	ide_execute_command(drive, command, &ide_dma_intr, 2*WAIT_CMD, NULL);
-
-	return pmac_ide_dma_begin(drive);
-}
-
-/*
- * Start a DMA WRITE command
- */
-static int __pmac
-pmac_ide_dma_write (ide_drive_t *drive)
+static void __pmac
+pmac_ide_dma_exec_cmd(ide_drive_t *drive, u8 command)
 {
-	struct request *rq = HWGROUP(drive)->rq;
-	u8 lba48 = (drive->addressing == 1) ? 1 : 0;
-	task_ioreg_t command = WIN_NOP;
-
-	if (pmac_ide_dma_start(drive, 0))
-		return 1;
-
-	if (drive->media != ide_disk)
-		return 0;
-
-	command = (lba48) ? WIN_WRITEDMA_EXT : WIN_WRITEDMA;
-	if (drive->vdma)
-		command = (lba48) ? WIN_WRITE_EXT: WIN_WRITE;
-		
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-
 	/* issue cmd to drive */
 	ide_execute_command(drive, command, &ide_dma_intr, 2*WAIT_CMD, NULL);
-
-	return pmac_ide_dma_begin(drive);
 }
 
 /*
  * Kick the DMA controller into life after the DMA command has been issued
  * to the drive.
  */
-static int __pmac
-pmac_ide_dma_begin (ide_drive_t *drive)
+static void __pmac
+pmac_ide_dma_start(ide_drive_t *drive)
 {
 	pmac_ide_hwif_t* pmif = (pmac_ide_hwif_t *)HWIF(drive)->hwif_data;
 	volatile struct dbdma_regs __iomem *dma;
 
-	if (pmif == NULL)
-		return 1;
 	dma = pmif->dma_regs;
 
 	writel((RUN << 16) | RUN, &dma->control);
 	/* Make sure it gets to the controller right now */
 	(void)readl(&dma->control);
-	return 0;
 }
 
 /*
@@ -2130,42 +2006,26 @@
 	pmif->dma_table_cpu = (struct dbdma_cmd*)pci_alloc_consistent(
 		hwif->pci_dev,
 		(MAX_DCMDS + 2) * sizeof(struct dbdma_cmd),
-		&pmif->dma_table_dma);
+		&hwif->dmatable_dma);
 	if (pmif->dma_table_cpu == NULL) {
 		printk(KERN_ERR "%s: unable to allocate DMA command list\n",
 		       hwif->name);
 		return;
 	}
 
-	pmif->sg_table = kmalloc(sizeof(struct scatterlist) * MAX_DCMDS,
-				 GFP_KERNEL);
-	if (pmif->sg_table == NULL) {
-		pci_free_consistent(	hwif->pci_dev,
-					(MAX_DCMDS + 2) * sizeof(struct dbdma_cmd),
-				    	pmif->dma_table_cpu, pmif->dma_table_dma);
-		return;
-	}
 	hwif->ide_dma_off_quietly = &__ide_dma_off_quietly;
 	hwif->ide_dma_on = &__ide_dma_on;
 	hwif->ide_dma_check = &pmac_ide_dma_check;
-	hwif->ide_dma_read = &pmac_ide_dma_read;
-	hwif->ide_dma_write = &pmac_ide_dma_write;
-	hwif->ide_dma_begin = &pmac_ide_dma_begin;
+	hwif->dma_setup = &pmac_ide_dma_setup;
+	hwif->dma_exec_cmd = &pmac_ide_dma_exec_cmd;
+	hwif->dma_start = &pmac_ide_dma_start;
 	hwif->ide_dma_end = &pmac_ide_dma_end;
 	hwif->ide_dma_test_irq = &pmac_ide_dma_test_irq;
 	hwif->ide_dma_host_off = &pmac_ide_dma_host_off;
 	hwif->ide_dma_host_on = &pmac_ide_dma_host_on;
-	hwif->ide_dma_verbose = &__ide_dma_verbose;
 	hwif->ide_dma_timeout = &__ide_dma_timeout;
 	hwif->ide_dma_lostirq = &pmac_ide_dma_lostirq;
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO
-	if (!noautodma)
-		hwif->autodma = 1;
-#endif
-	hwif->drives[0].autodma = hwif->autodma;
-	hwif->drives[1].autodma = hwif->autodma;
-
 	hwif->atapi_dma = 1;
 	switch(pmif->kind) {
 		case controller_un_ata6:
diff -Naur linuxppc-2.6.9/drivers/ide/setup-pci.c linuxppc-2.6.9-dream/drivers/ide/setup-pci.c
--- linuxppc-2.6.9/drivers/ide/setup-pci.c	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/ide/setup-pci.c	2005-06-20 10:46:11.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/mm.h>
 #include <linux/interrupt.h>
 #include <linux/ide.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -185,19 +186,16 @@
 second_chance_to_dma:
 #endif /* CONFIG_BLK_DEV_IDEDMA_FORCED */
 
-	if ((hwif->mmio) && (hwif->dma_base))
+	if (hwif->mmio)
 		return hwif->dma_base;
 
 	if (hwif->mate && hwif->mate->dma_base) {
 		dma_base = hwif->mate->dma_base - (hwif->channel ? 0 : 8);
 	} else {
-		dma_base = (hwif->mmio) ?
-			((unsigned long) hwif->hwif_data) :
-			(pci_resource_start(dev, 4));
+		dma_base = pci_resource_start(dev, 4);
 		if (!dma_base) {
-			printk(KERN_ERR "%s: dma_base is invalid (0x%04lx)\n",
-				hwif->cds->name, dma_base);
-			dma_base = 0;
+			printk(KERN_ERR "%s: dma_base is invalid\n",
+					hwif->cds->name);
 		}
 	}
 
@@ -251,7 +249,6 @@
 				simplex_stat = hwif->INB(dma_base + 2);
 				if (simplex_stat & 0x80) {
 					/* simplex device? */
-#if 0					
 /*
  *	At this point we haven't probed the drives so we can't make the
  *	appropriate decision. Really we should defer this problem
@@ -259,18 +256,7 @@
  *	to be the DMA end. This has to be become dynamic to handle hot
  *	plug.
  */
-					/* Don't enable DMA on a simplex channel with no drives */
-					if (!hwif->drives[0].present && !hwif->drives[1].present)
-					{
-						printk(KERN_INFO "%s: simplex device with no drives: DMA disabled\n",
-								hwif->cds->name);
-						dma_base = 0;
-					}
-					/* If our other channel has DMA then we cannot */
-					else 
-#endif					
-					if(hwif->mate && hwif->mate->dma_base) 
-					{
+					if (hwif->mate && hwif->mate->dma_base) {
 						printk(KERN_INFO "%s: simplex device: "
 							"DMA disabled\n",
 							hwif->cds->name);
@@ -305,14 +291,16 @@
  
 static int ide_pci_enable(struct pci_dev *dev, ide_pci_device_t *d)
 {
-	
+	int ret;
+
 	if (pci_enable_device(dev)) {
-		if (pci_enable_device_bars(dev, 1 << 4)) {
+		ret = pci_enable_device_bars(dev, 1 << 4);
+		if (ret < 0) {
 			printk(KERN_WARNING "%s: (ide_setup_pci_device:) "
 				"Could not enable device.\n", d->name);
-			return -EBUSY;
-		} else
-			printk(KERN_WARNING "%s: BIOS configuration fixed.\n", d->name);
+			goto out;
+		}
+		printk(KERN_WARNING "%s: BIOS configuration fixed.\n", d->name);
 	}
 
 	/*
@@ -320,18 +308,21 @@
 	 * dma mask field to the ide_pci_device_t if we need it (or let
 	 * lower level driver set the dma mask)
 	 */
-	if (pci_set_dma_mask(dev, 0xffffffff)) {
+	ret = pci_set_dma_mask(dev, DMA_32BIT_MASK);
+	if (ret < 0) {
 		printk(KERN_ERR "%s: can't set dma mask\n", d->name);
-		return -EBUSY;
+		goto out;
 	}
-	 
+
 	/* FIXME: Temporary - until we put in the hotplug interface logic
-	   Check that the bits we want are not in use by someone else */
-	if (pci_request_region(dev, 4, "ide_tmp"))
-		return -EBUSY;
+	   Check that the bits we want are not in use by someone else. */
+	ret = pci_request_region(dev, 4, "ide_tmp");
+	if (ret < 0)
+		goto out;
+
 	pci_release_region(dev, 4);
-	
-	return 0;	
+out:
+	return ret;
 }
 
 /**
@@ -440,7 +431,12 @@
 	if (hwif->io_ports[IDE_DATA_OFFSET] != base ||
 	    hwif->io_ports[IDE_CONTROL_OFFSET] != (ctl | 2)) {
 		memset(&hwif->hw, 0, sizeof(hwif->hw));
+#ifndef IDE_ARCH_OBSOLETE_INIT
+		ide_std_init_ports(&hwif->hw, base, (ctl | 2));
+		hwif->hw.io_ports[IDE_IRQ_OFFSET] = 0;
+#else
 		ide_init_hwif_ports(&hwif->hw, base, (ctl | 2), NULL);
+#endif
 		memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->io_ports));
 		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
 	}
@@ -488,13 +484,8 @@
  			 * Set up BM-DMA capability
 			 * (PnP BIOS should have done this)
  			 */
-			if ((d->flags & IDEPCI_FLAG_FORCE_MASTER) == 0) {
-				/*
-				 * default DMA off if we had to
-				 * configure it here
-				 */
-				hwif->autodma = 0;
-			}
+			/* default DMA off if we had to configure it here */
+			hwif->autodma = 0;
 			pci_set_master(dev);
 			if (pci_read_config_word(dev, PCI_COMMAND, &pcicmd) || !(pcicmd & PCI_COMMAND_MASTER)) {
 				printk(KERN_ERR "%s: %s error updating PCICMD\n",
@@ -514,6 +505,11 @@
 		}
 	}
 }
+
+#ifndef CONFIG_IDEDMA_PCI_AUTO
+#warning CONFIG_IDEDMA_PCI_AUTO=n support is obsolete, and will be removed soon.
+#endif
+
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI*/
 
 /**
@@ -530,28 +526,26 @@
  
 static int ide_setup_pci_controller(struct pci_dev *dev, ide_pci_device_t *d, int noisy, int *config)
 {
-	int ret = 0;
+	int ret;
 	u32 class_rev;
 	u16 pcicmd;
 
-	if (!noautodma)
-		ret = 1;
-
 	if (noisy)
 		ide_setup_pci_noise(dev, d);
 
-	if (ide_pci_enable(dev, d))
-		return -EBUSY;
-		
-	if (pci_read_config_word(dev, PCI_COMMAND, &pcicmd)) {
+	ret = ide_pci_enable(dev, d);
+	if (ret < 0)
+		goto out;
+
+	ret = pci_read_config_word(dev, PCI_COMMAND, &pcicmd);
+	if (ret < 0) {
 		printk(KERN_ERR "%s: error accessing PCI regs\n", d->name);
-		return -EIO;
+		goto out;
 	}
 	if (!(pcicmd & PCI_COMMAND_IO)) {	/* is device disabled? */
-		if (ide_pci_configure(dev, d))
-			return -ENODEV;
-		/* default DMA off if we had to configure it here */
-		ret = 0;
+		ret = ide_pci_configure(dev, d);
+		if (ret < 0)
+			goto out;
 		*config = 1;
 		printk(KERN_INFO "%s: device enabled (Linux)\n", d->name);
 	}
@@ -560,6 +554,7 @@
 	class_rev &= 0xff;
 	if (noisy)
 		printk(KERN_INFO "%s: chipset revision %d\n", d->name, class_rev);
+out:
 	return ret;
 }
 
@@ -567,7 +562,6 @@
  *	ide_pci_setup_ports	-	configure ports/devices on PCI IDE
  *	@dev: PCI device
  *	@d: IDE pci device info
- *	@autodma: Should we enable DMA
  *	@pciirq: IRQ line
  *	@index: ata index to update
  *
@@ -580,7 +574,7 @@
  *	where the chipset setup is not the default PCI IDE one.
  */
  
-void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int autodma, int pciirq, ata_index_t *index)
+void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, ata_index_t *index)
 {
 	int port;
 	int at_least_one_hwif_enabled = 0;
@@ -634,11 +628,7 @@
 
 		if (d->autodma == NODMA)
 			goto bypass_legacy_dma;
-		if (d->autodma == NOAUTODMA)
-			autodma = 0;
-		if (autodma)
-			hwif->autodma = 1;
-			
+
 		if(d->init_setup_dma)
 			d->init_setup_dma(dev, d, hwif);
 		else
@@ -669,15 +659,16 @@
  * we "know" about, this information is in the ide_pci_device_t struct;
  * for all other chipsets, we just assume both interfaces are enabled.
  */
-static ata_index_t do_ide_setup_pci_device (struct pci_dev *dev, ide_pci_device_t *d, u8 noisy)
+static int do_ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d,
+				   ata_index_t *index, u8 noisy)
 {
-	int autodma = 0;
-	int pciirq = 0;
+	static ata_index_t ata_index = { .b = { .low = 0xff, .high = 0xff } };
 	int tried_config = 0;
-	ata_index_t index = { .b = { .low = 0xff, .high = 0xff } };
+	int pciirq, ret;
 
-	if((autodma = ide_setup_pci_controller(dev, d, noisy, &tried_config)) < 0)
-		return index;
+	ret = ide_setup_pci_controller(dev, d, noisy, &tried_config);
+	if (ret < 0)
+		goto out;
 
 	/*
 	 * Can we trust the reported IRQ?
@@ -695,7 +686,10 @@
 		 * space, place chipset into init-mode, and/or preserve
 		 * an interrupt if the card is not native ide support.
 		 */
-		pciirq = (d->init_chipset) ? d->init_chipset(dev, d->name) : 0;
+		ret = d->init_chipset ? d->init_chipset(dev, d->name) : 0;
+		if (ret < 0)
+			goto out;
+		pciirq = ret;
 	} else if (tried_config) {
 		if (noisy)
 			printk(KERN_INFO "%s: will probe irqs later\n", d->name);
@@ -706,10 +700,10 @@
 				d->name, pciirq);
 		pciirq = 0;
 	} else {
-		if (d->init_chipset)
-		{
-			if(d->init_chipset(dev, d->name) < 0)
-				return index;
+		if (d->init_chipset) {
+			ret = d->init_chipset(dev, d->name);
+			if (ret < 0)
+				goto out;
 		}
 		if (noisy)
 #ifdef __sparc__
@@ -720,44 +714,66 @@
 				d->name, pciirq);
 #endif
 	}
-	
-	if(pciirq < 0)		/* Error not an IRQ */
-		return index;
 
-	ide_pci_setup_ports(dev, d, autodma, pciirq, &index);
+	/* FIXME: silent failure can happen */
 
-	return index;
+	*index = ata_index;
+	ide_pci_setup_ports(dev, d, pciirq, index);
+out:
+	return ret;
 }
 
-void ide_setup_pci_device (struct pci_dev *dev, ide_pci_device_t *d)
+int ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d)
 {
-	ata_index_t index_list = do_ide_setup_pci_device(dev, d, 1);
+	ata_index_t index_list;
+	int ret;
+
+	ret = do_ide_setup_pci_device(dev, d, &index_list, 1);
+	if (ret < 0)
+		goto out;
 
 	if ((index_list.b.low & 0xf0) != 0xf0)
-		probe_hwif_init(&ide_hwifs[index_list.b.low]);
+		probe_hwif_init_with_fixup(&ide_hwifs[index_list.b.low], d->fixup);
 	if ((index_list.b.high & 0xf0) != 0xf0)
-		probe_hwif_init(&ide_hwifs[index_list.b.high]);
+		probe_hwif_init_with_fixup(&ide_hwifs[index_list.b.high], d->fixup);
 
 	create_proc_ide_interfaces();
+out:
+	return ret;
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_pci_device);
 
-void ide_setup_pci_devices (struct pci_dev *dev, struct pci_dev *dev2, ide_pci_device_t *d)
+int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
+			  ide_pci_device_t *d)
 {
-	ata_index_t index_list  = do_ide_setup_pci_device(dev, d, 1);
-	ata_index_t index_list2 = do_ide_setup_pci_device(dev2, d, 0);
+	struct pci_dev *pdev[] = { dev1, dev2 };
+	ata_index_t index_list[2];
+	int ret, i;
 
-	if ((index_list.b.low & 0xf0) != 0xf0)
-		probe_hwif_init(&ide_hwifs[index_list.b.low]);
-	if ((index_list.b.high & 0xf0) != 0xf0)
-		probe_hwif_init(&ide_hwifs[index_list.b.high]);
-	if ((index_list2.b.low & 0xf0) != 0xf0)
-		probe_hwif_init(&ide_hwifs[index_list2.b.low]);
-	if ((index_list2.b.high & 0xf0) != 0xf0)
-		probe_hwif_init(&ide_hwifs[index_list2.b.high]);
+	for (i = 0; i < 2; i++) {
+		ret = do_ide_setup_pci_device(pdev[i], d, index_list + i, !i);
+		/*
+		 * FIXME: Mom, mom, they stole me the helper function to undo
+		 * do_ide_setup_pci_device() on the first device!
+		 */
+		if (ret < 0)
+			goto out;
+	}
+
+	for (i = 0; i < 2; i++) {
+		u8 idx[2] = { index_list[i].b.low, index_list[i].b.high };
+		int j;
+
+		for (j = 0; j < 2; j++) {
+			if ((idx[j] & 0xf0) != 0xf0)
+				probe_hwif_init(ide_hwifs + idx[j]);
+		}
+	}
 
 	create_proc_ide_interfaces();
+out:
+	return ret;
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_pci_devices);
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/amd_flash.c linuxppc-2.6.9-dream/drivers/mtd/chips/amd_flash.c
--- linuxppc-2.6.9/drivers/mtd/chips/amd_flash.c	2004-10-18 23:53:45.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/amd_flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * Author: Jonas Holmberg <jonas.holmberg@axis.com>
  *
- * $Id: amd_flash.c,v 1.25 2004/08/09 13:19:43 dwmw2 Exp $
+ * $Id: amd_flash.c,v 1.26 2004/11/20 12:49:04 dwmw2 Exp $
  *
  * Copyright (c) 2001 Axis Communications AB
  *
@@ -1122,7 +1122,7 @@
 	timeo = jiffies + (HZ * 20);
 
 	spin_unlock_bh(chip->mutex);
-	schedule_timeout(HZ);
+	msleep(1000);
 	spin_lock_bh(chip->mutex);
 	
 	while (flash_is_busy(map, adr, private->interleave)) {
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/cfi_cmdset_0001.c linuxppc-2.6.9-dream/drivers/mtd/chips/cfi_cmdset_0001.c
--- linuxppc-2.6.9/drivers/mtd/chips/cfi_cmdset_0001.c	2004-10-18 23:53:45.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/cfi_cmdset_0001.c	2005-06-20 10:46:11.000000000 +0200
@@ -4,7 +4,7 @@
  *
  * (C) 2000 Red Hat. GPL'd
  *
- * $Id: cfi_cmdset_0001.c,v 1.154 2004/08/09 13:19:43 dwmw2 Exp $
+ * $Id: cfi_cmdset_0001.c,v 1.164 2004/11/16 18:29:00 dwmw2 Exp $
  *
  * 
  * 10/10/2000	Nicolas Pitre <nico@cam.org>
@@ -29,16 +29,24 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/mtd/xip.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/compatmac.h>
 #include <linux/mtd/cfi.h>
 
 /* #define CMDSET0001_DISABLE_ERASE_SUSPEND_ON_WRITE */
+/* #define CMDSET0001_DISABLE_WRITE_SUSPEND */
 
 // debugging, turns off buffer write mode if set to 1
 #define FORCE_WORD_WRITE 0
 
+#define MANUFACTURER_INTEL	0x0089
+#define I82802AB	0x00ad
+#define I82802AC	0x00ac
+#define MANUFACTURER_ST         0x0020
+#define M50LPW080       0x002F
+
 static int cfi_intelext_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 //static int cfi_intelext_read_user_prot_reg (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 //static int cfi_intelext_read_fact_prot_reg (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
@@ -55,14 +63,19 @@
 
 struct mtd_info *cfi_cmdset_0001(struct map_info *, int);
 
-static struct mtd_info *cfi_intelext_setup (struct map_info *);
-static int cfi_intelext_partition_fixup(struct map_info *, struct cfi_private **);
+static struct mtd_info *cfi_intelext_setup (struct mtd_info *);
+static int cfi_intelext_partition_fixup(struct mtd_info *, struct cfi_private **);
 
 static int cfi_intelext_point (struct mtd_info *mtd, loff_t from, size_t len,
 		     size_t *retlen, u_char **mtdbuf);
 static void cfi_intelext_unpoint (struct mtd_info *mtd, u_char *addr, loff_t from,
 			size_t len);
 
+static int get_chip(struct map_info *map, struct flchip *chip, unsigned long adr, int mode);
+static void put_chip(struct map_info *map, struct flchip *chip, unsigned long adr);
+#include "fwh_lock.h"
+
+
 
 /*
  *  *********** SETUP AND PROBE BITS  ***********
@@ -123,8 +136,9 @@
 
 #ifdef CMDSET0001_DISABLE_ERASE_SUSPEND_ON_WRITE
 /* Some Intel Strata Flash prior to FPO revision C has bugs in this area */ 
-static void fixup_intel_strataflash(struct map_info *map, void* param)
+static void fixup_intel_strataflash(struct mtd_info *mtd, void* param)
 {
+	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	struct cfi_pri_amdstd *extp = cfi->cmdset_priv;
 
@@ -134,16 +148,32 @@
 }
 #endif
 
-static void fixup_st_m28w320ct(struct map_info *map, void* param)
+#ifdef CMDSET0001_DISABLE_WRITE_SUSPEND
+static void fixup_no_write_suspend(struct mtd_info *mtd, void* param)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	struct cfi_pri_intelext *cfip = cfi->cmdset_priv;
+
+	if (cfip && (cfip->FeatureSupport&4)) {
+		cfip->FeatureSupport &= ~4;
+		printk(KERN_WARNING "cfi_cmdset_0001: write suspend disabled\n");
+	}
+}
+#endif
+
+static void fixup_st_m28w320ct(struct mtd_info *mtd, void* param)
 {
+	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	
 	cfi->cfiq->BufWriteTimeoutTyp = 0;	/* Not supported */
 	cfi->cfiq->BufWriteTimeoutMax = 0;	/* Not supported */
 }
 
-static void fixup_st_m28w320cb(struct map_info *map, void* param)
+static void fixup_st_m28w320cb(struct mtd_info *mtd, void* param)
 {
+	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	
 	/* Note this is done after the region info is endian swapped */
@@ -151,25 +181,115 @@
 		(cfi->cfiq->EraseRegionInfo[1] & 0xffff0000) | 0x3e;
 };
 
-static struct cfi_fixup fixup_table[] = {
+static void fixup_use_point(struct mtd_info *mtd, void *param)
+{
+	struct map_info *map = mtd->priv;
+	if (!mtd->point && map_is_linear(map)) {
+		mtd->point   = cfi_intelext_point;
+		mtd->unpoint = cfi_intelext_unpoint;
+	}
+}
+
+static void fixup_use_write_buffers(struct mtd_info *mtd, void *param)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	if (cfi->cfiq->BufWriteTimeoutTyp) {
+		printk(KERN_INFO "Using buffer write method\n" );
+		mtd->write = cfi_intelext_write_buffers;
+	}
+}
+
+static struct cfi_fixup cfi_fixup_table[] = {
 #ifdef CMDSET0001_DISABLE_ERASE_SUSPEND_ON_WRITE
-	{
-		CFI_MFR_ANY, CFI_ID_ANY,
-		fixup_intel_strataflash, NULL
-	}, 
+	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_intel_strataflash, NULL }, 
 #endif
-	{
-		0x0020,	/* STMicroelectronics */
-		0x00ba,	/* M28W320CT */
-		fixup_st_m28w320ct, NULL
-	}, {
-		0x0020,	/* STMicroelectronics */
-		0x00bb,	/* M28W320CB */
-		fixup_st_m28w320cb, NULL
-	}, {
-		0, 0, NULL, NULL
-	}
+#ifdef CMDSET0001_DISABLE_WRITE_SUSPEND
+	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_no_write_suspend, NULL },
+#endif
+#if !FORCE_WORD_WRITE
+	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_write_buffers, NULL },
+#endif
+	{ CFI_MFR_ST, 0x00ba, /* M28W320CT */ fixup_st_m28w320ct, NULL },
+	{ CFI_MFR_ST, 0x00bb, /* M28W320CB */ fixup_st_m28w320cb, NULL },
+	{ 0, 0, NULL, NULL }
+};
+
+static struct cfi_fixup jedec_fixup_table[] = {
+	{ MANUFACTURER_INTEL, I82802AB,   fixup_use_fwh_lock, NULL, },
+	{ MANUFACTURER_INTEL, I82802AC,   fixup_use_fwh_lock, NULL, },
+	{ MANUFACTURER_ST,    M50LPW080,  fixup_use_fwh_lock, NULL, },
+	{ 0, 0, NULL, NULL }
 };
+static struct cfi_fixup fixup_table[] = {
+	/* The CFI vendor ids and the JEDEC vendor IDs appear
+	 * to be common.  It is like the devices id's are as
+	 * well.  This table is to pick all cases where
+	 * we know that is the case.
+	 */
+	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_point, NULL },
+	{ 0, 0, NULL, NULL }
+};
+
+static inline struct cfi_pri_intelext *
+read_pri_intelext(struct map_info *map, __u16 adr)
+{
+	struct cfi_pri_intelext *extp;
+	unsigned int extp_size = sizeof(*extp);
+
+ again:
+	extp = (struct cfi_pri_intelext *)cfi_read_pri(map, adr, extp_size, "Intel/Sharp");
+	if (!extp)
+		return NULL;
+
+	/* Do some byteswapping if necessary */
+	extp->FeatureSupport = le32_to_cpu(extp->FeatureSupport);
+	extp->BlkStatusRegMask = le16_to_cpu(extp->BlkStatusRegMask);
+	extp->ProtRegAddr = le16_to_cpu(extp->ProtRegAddr);
+
+	if (extp->MajorVersion == '1' && extp->MinorVersion == '3') {
+		unsigned int extra_size = 0;
+		int nb_parts, i;
+
+		/* Protection Register info */
+		extra_size += (extp->NumProtectionFields - 1) * (4 + 6);
+
+		/* Burst Read info */
+		extra_size += 6;
+
+		/* Number of hardware-partitions */
+		extra_size += 1;
+		if (extp_size < sizeof(*extp) + extra_size)
+			goto need_more;
+		nb_parts = extp->extra[extra_size - 1];
+
+		for (i = 0; i < nb_parts; i++) {
+			struct cfi_intelext_regioninfo *rinfo;
+			rinfo = (struct cfi_intelext_regioninfo *)&extp->extra[extra_size];
+			extra_size += sizeof(*rinfo);
+			if (extp_size < sizeof(*extp) + extra_size)
+				goto need_more;
+			rinfo->NumIdentPartitions=le16_to_cpu(rinfo->NumIdentPartitions);
+			extra_size += (rinfo->NumBlockTypes - 1)
+				      * sizeof(struct cfi_intelext_blockinfo);
+		}
+
+		if (extp_size < sizeof(*extp) + extra_size) {
+			need_more:
+			extp_size = sizeof(*extp) + extra_size;
+			kfree(extp);
+			if (extp_size > 4096) {
+				printk(KERN_ERR
+					"%s: cfi_pri_intelext is too fat\n",
+					__FUNCTION__);
+				return NULL;
+			}
+			goto again;
+		}
+	}
+		
+	return extp;
+}
 
 /* This routine is made available to other mtd code via
  * inter_module_register.  It must only be accessed through
@@ -181,8 +301,30 @@
 struct mtd_info *cfi_cmdset_0001(struct map_info *map, int primary)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
+	struct mtd_info *mtd;
 	int i;
 
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if (!mtd) {
+		printk(KERN_ERR "Failed to allocate memory for MTD device\n");
+		return NULL;
+	}
+	memset(mtd, 0, sizeof(*mtd));
+	mtd->priv = map;
+	mtd->type = MTD_NORFLASH;
+
+	/* Fill in the default mtd operations */
+	mtd->erase   = cfi_intelext_erase_varsize;
+	mtd->read    = cfi_intelext_read;
+	mtd->write   = cfi_intelext_write_words;
+	mtd->sync    = cfi_intelext_sync;
+	mtd->lock    = cfi_intelext_lock;
+	mtd->unlock  = cfi_intelext_unlock;
+	mtd->suspend = cfi_intelext_suspend;
+	mtd->resume  = cfi_intelext_resume;
+	mtd->flags   = MTD_CAP_NORFLASH;
+	mtd->name    = map->name;
+	
 	if (cfi->cfi_mode == CFI_MODE_CFI) {
 		/* 
 		 * It's a real CFI chip, not one for which the probe
@@ -192,20 +334,17 @@
 		__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;
 		struct cfi_pri_intelext *extp;
 
-		extp = (struct cfi_pri_intelext*)cfi_read_pri(map, adr, sizeof(*extp), "Intel/Sharp");
-		if (!extp)
+		extp = read_pri_intelext(map, adr);
+		if (!extp) {
+			kfree(mtd);
 			return NULL;
-		
-		/* Do some byteswapping if necessary */
-		extp->FeatureSupport = le32_to_cpu(extp->FeatureSupport);
-		extp->BlkStatusRegMask = le16_to_cpu(extp->BlkStatusRegMask);
-		extp->ProtRegAddr = le16_to_cpu(extp->ProtRegAddr);
+		}
 
 		/* Install our own private info structure */
 		cfi->cmdset_priv = extp;	
 
-		cfi_fixup(map, fixup_table);
-			
+		cfi_fixup(mtd, cfi_fixup_table);
+
 #ifdef DEBUG_CFI_FEATURES
 		/* Tell the user about it in lots of lovely detail */
 		cfi_tell_features(extp);
@@ -215,6 +354,12 @@
 			printk(KERN_NOTICE "cfi_cmdset_0001: Erase suspend on write enabled\n");
 		}
 	}
+	else if (cfi->cfi_mode == CFI_MODE_JEDEC) {
+		/* Apply jedec specific fixups */
+		cfi_fixup(mtd, jedec_fixup_table);
+	}
+	/* Apply generic fixups */
+	cfi_fixup(mtd, fixup_table);
 
 	for (i=0; i< cfi->numchips; i++) {
 		cfi->chips[i].word_write_time = 1<<cfi->cfiq->WordWriteTimeoutTyp;
@@ -225,28 +370,19 @@
 
 	map->fldrv = &cfi_intelext_chipdrv;
 	
-	return cfi_intelext_setup(map);
+	return cfi_intelext_setup(mtd);
 }
 
-static struct mtd_info *cfi_intelext_setup(struct map_info *map)
+static struct mtd_info *cfi_intelext_setup(struct mtd_info *mtd)
 {
+	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
-	struct mtd_info *mtd;
 	unsigned long offset = 0;
 	int i,j;
 	unsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;
 
-	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
 	//printk(KERN_DEBUG "number of CFI chips: %d\n", cfi->numchips);
 
-	if (!mtd) {
-		printk(KERN_ERR "Failed to allocate memory for MTD device\n");
-		goto setup_err;
-	}
-
-	memset(mtd, 0, sizeof(*mtd));
-	mtd->priv = map;
-	mtd->type = MTD_NORFLASH;
 	mtd->size = devsize * cfi->numchips;
 
 	mtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;
@@ -286,38 +422,14 @@
 		       mtd->eraseregions[i].numblocks);
 	}
 
-	/* Also select the correct geometry setup too */ 
-	mtd->erase = cfi_intelext_erase_varsize;
-	mtd->read = cfi_intelext_read;
-
-	if (map_is_linear(map)) {
-		mtd->point = cfi_intelext_point;
-		mtd->unpoint = cfi_intelext_unpoint;
-	}
-
-	if ( cfi->cfiq->BufWriteTimeoutTyp && !FORCE_WORD_WRITE) {
-		printk(KERN_INFO "Using buffer write method\n" );
-		mtd->write = cfi_intelext_write_buffers;
-	} else {
-		printk(KERN_INFO "Using word write method\n" );
-		mtd->write = cfi_intelext_write_words;
-	}
 #if 0
 	mtd->read_user_prot_reg = cfi_intelext_read_user_prot_reg;
 	mtd->read_fact_prot_reg = cfi_intelext_read_fact_prot_reg;
 #endif
-	mtd->sync = cfi_intelext_sync;
-	mtd->lock = cfi_intelext_lock;
-	mtd->unlock = cfi_intelext_unlock;
-	mtd->suspend = cfi_intelext_suspend;
-	mtd->resume = cfi_intelext_resume;
-	mtd->flags = MTD_CAP_NORFLASH;
-	map->fldrv = &cfi_intelext_chipdrv;
-	mtd->name = map->name;
 
 	/* This function has the potential to distort the reality
 	   a bit and therefore should be called last. */
-	if (cfi_intelext_partition_fixup(map, &cfi) != 0)
+	if (cfi_intelext_partition_fixup(mtd, &cfi) != 0)
 		goto setup_err;
 
 	__module_get(THIS_MODULE);
@@ -333,20 +445,16 @@
 	return NULL;
 }
 
-static int cfi_intelext_partition_fixup(struct map_info *map,
+static int cfi_intelext_partition_fixup(struct mtd_info *mtd,
 					struct cfi_private **pcfi)
 {
+	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = *pcfi;
 	struct cfi_pri_intelext *extp = cfi->cmdset_priv;
 
 	/*
 	 * Probing of multi-partition flash ships.
 	 *
-	 * This is extremely crude at the moment and should probably be
-	 * extracted entirely from the Intel extended query data instead.
-	 * Right now a L18 flash is assumed if multiple operations is
-	 * detected.
-	 *
 	 * To support multiple partitions when available, we simply arrange
 	 * for each of them to have their own flchip structure even if they
 	 * are on the same physical chip.  This means completely recreating
@@ -355,20 +463,49 @@
 	 * arrangement at this point. This can be rearranged in the future
 	 * if someone feels motivated enough.  --nico
 	 */
-	if (extp && extp->FeatureSupport & (1 << 9)) {
+	if (extp && extp->MajorVersion == '1' && extp->MinorVersion == '3'
+	    && extp->FeatureSupport & (1 << 9)) {
 		struct cfi_private *newcfi;
 		struct flchip *chip;
 		struct flchip_shared *shared;
-		int numparts, partshift, numvirtchips, i, j;
+		int offs, numregions, numparts, partshift, numvirtchips, i, j;
+
+		/* Protection Register info */
+		offs = (extp->NumProtectionFields - 1) * (4 + 6);
+
+		/* Burst Read info */
+		offs += 6;
+
+		/* Number of partition regions */
+		numregions = extp->extra[offs];
+		offs += 1;
+
+		/* Number of hardware partitions */
+		numparts = 0;
+		for (i = 0; i < numregions; i++) {
+			struct cfi_intelext_regioninfo *rinfo;
+			rinfo = (struct cfi_intelext_regioninfo *)&extp->extra[offs];
+			numparts += rinfo->NumIdentPartitions;
+			offs += sizeof(*rinfo)
+				+ (rinfo->NumBlockTypes - 1) *
+				  sizeof(struct cfi_intelext_blockinfo);
+		}
 
 		/*
-		 * The L18 flash memory array is divided
-		 * into multiple 8-Mbit partitions.
+		 * All functions below currently rely on all chips having
+		 * the same geometry so we'll just assume that all hardware
+		 * partitions are of the same size too.
 		 */
-		numparts = 1 << (cfi->cfiq->DevSize - 20);
-		partshift = 20 + __ffs(cfi->interleave);
-		numvirtchips = cfi->numchips * numparts;
+		partshift = cfi->chipshift - __ffs(numparts);
+
+		if ((1 << partshift) < mtd->erasesize) {
+			printk( KERN_ERR
+				"%s: bad number of hw partitions (%d)\n",
+				__FUNCTION__, numparts);
+			return -EINVAL;
+		}
 
+		numvirtchips = cfi->numchips * numparts;
 		newcfi = kmalloc(sizeof(struct cfi_private) + numvirtchips * sizeof(struct flchip), GFP_KERNEL);
 		if (!newcfi)
 			return -ENOMEM;
@@ -398,10 +535,10 @@
 			}
 		}
 
-		printk(KERN_DEBUG "%s: %d sets of %d interleaved chips "
-				  "--> %d partitions of %#x bytes\n",
+		printk(KERN_DEBUG "%s: %d set(s) of %d interleaved chips "
+				  "--> %d partitions of %d KiB\n",
 				  map->name, cfi->numchips, cfi->interleave,
-				  newcfi->numchips, 1<<newcfi->chipshift);
+				  newcfi->numchips, 1<<(newcfi->chipshift-10));
 
 		map->fldrv_priv = newcfi;
 		*pcfi = newcfi;
@@ -515,7 +652,8 @@
 		return 0;
 
 	case FL_ERASING:
-		if (!(cfip->FeatureSupport & 2) ||
+		if (!cfip ||
+		    !(cfip->FeatureSupport & 2) ||
 		    !(mode == FL_READY || mode == FL_POINT ||
 		     (mode == FL_WRITING && (cfip->SuspendCmdSupport & 1))))
 			goto sleep;
@@ -559,6 +697,14 @@
 		chip->state = FL_STATUS;
 		return 0;
 
+	case FL_XIP_WHILE_ERASING:
+		if (mode != FL_READY && mode != FL_POINT &&
+		    (mode != FL_WRITING || !cfip || !(cfip->SuspendCmdSupport&1)))
+			goto sleep;
+		chip->oldstate = chip->state;
+		chip->state = FL_READY;
+		return 0;
+
 	case FL_POINT:
 		/* Only if there's no operation suspended... */
 		if (mode == FL_READY && chip->oldstate == FL_READY)
@@ -583,7 +729,7 @@
 	if (chip->priv) {
 		struct flchip_shared *shared = chip->priv;
 		spin_lock(&shared->lock);
-		if (shared->writing == chip) {
+		if (shared->writing == chip && chip->oldstate == FL_READY) {
 			/* We own the ability to write, but we're done */
 			shared->writing = shared->erasing;
 			if (shared->writing && shared->writing != chip) {
@@ -595,17 +741,24 @@
 				put_chip(map, loaner, loaner->start);
 				spin_lock(chip->mutex);
 				spin_unlock(loaner->mutex);
-			} else {
-				if (chip->oldstate != FL_ERASING) {
-					shared->erasing = NULL;
-					if (chip->oldstate != FL_WRITING)
-						shared->writing = NULL;
-				}
-				spin_unlock(&shared->lock);
+				wake_up(&chip->wq);
+				return;
 			}
-		} else {
+			shared->erasing = NULL;
+			shared->writing = NULL;
+		} else if (shared->erasing == chip && shared->writing != chip) {
+			/*
+			 * We own the ability to erase without the ability
+			 * to write, which means the erase was suspended
+			 * and some other partition is currently writing.
+			 * Don't let the switch below mess things up since
+			 * we don't have ownership to resume anything.
+			 */
 			spin_unlock(&shared->lock);
+			wake_up(&chip->wq);
+			return;
 		}
+		spin_unlock(&shared->lock);
 	}
 
 	switch(chip->oldstate) {
@@ -626,6 +779,11 @@
 		chip->state = FL_ERASING;
 		break;
 
+	case FL_XIP_WHILE_ERASING:
+		chip->state = chip->oldstate;
+		chip->oldstate = FL_READY;
+		break;
+
 	case FL_READY:
 	case FL_STATUS:
 	case FL_JEDEC_QUERY:
@@ -638,6 +796,201 @@
 	wake_up(&chip->wq);
 }
 
+#ifdef CONFIG_MTD_XIP
+
+/*
+ * No interrupt what so ever can be serviced while the flash isn't in array
+ * mode.  This is ensured by the xip_disable() and xip_enable() functions
+ * enclosing any code path where the flash is known not to be in array mode.
+ * And within a XIP disabled code path, only functions marked with __xipram
+ * may be called and nothing else (it's a good thing to inspect generated
+ * assembly to make sure inline functions were actually inlined and that gcc
+ * didn't emit calls to its own support functions). Also configuring MTD CFI
+ * support to a single buswidth and a single interleave is also recommended.
+ * Note that not only IRQs are disabled but the preemption count is also
+ * increased to prevent other locking primitives (namely spin_unlock) from
+ * decrementing the preempt count to zero and scheduling the CPU away while
+ * not in array mode.
+ */
+
+static void xip_disable(struct map_info *map, struct flchip *chip,
+			unsigned long adr)
+{
+	/* TODO: chips with no XIP use should ignore and return */
+	(void) map_read(map, adr); /* ensure mmu mapping is up to date */
+	preempt_disable();
+	local_irq_disable();
+}
+
+static void __xipram xip_enable(struct map_info *map, struct flchip *chip,
+				unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	if (chip->state != FL_POINT && chip->state != FL_READY) {
+		map_write(map, CMD(0xff), adr);
+		chip->state = FL_READY;
+	}
+	(void) map_read(map, adr);
+	asm volatile (".rep 8; nop; .endr"); /* fill instruction prefetch */
+	local_irq_enable();
+	preempt_enable();
+}
+
+/*
+ * When a delay is required for the flash operation to complete, the
+ * xip_udelay() function is polling for both the given timeout and pending
+ * (but still masked) hardware interrupts.  Whenever there is an interrupt
+ * pending then the flash erase or write operation is suspended, array mode
+ * restored and interrupts unmasked.  Task scheduling might also happen at that
+ * point.  The CPU eventually returns from the interrupt or the call to
+ * schedule() and the suspended flash operation is resumed for the remaining
+ * of the delay period.
+ *
+ * Warning: this function _will_ fool interrupt latency tracing tools.
+ */
+
+static void __xipram xip_udelay(struct map_info *map, struct flchip *chip,
+				unsigned long adr, int usec)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	struct cfi_pri_intelext *cfip = cfi->cmdset_priv;
+	map_word status, OK = CMD(0x80);
+	unsigned long suspended, start = xip_currtime();
+	flstate_t oldstate, newstate;
+
+	do {
+		cpu_relax();
+		if (xip_irqpending() && cfip &&
+		    ((chip->state == FL_ERASING && (cfip->FeatureSupport&2)) ||
+		     (chip->state == FL_WRITING && (cfip->FeatureSupport&4))) &&
+		    (cfi_interleave_is_1(cfi) || chip->oldstate == FL_READY)) {
+			/*
+			 * Let's suspend the erase or write operation when
+			 * supported.  Note that we currently don't try to
+			 * suspend interleaved chips if there is already
+			 * another operation suspended (imagine what happens
+			 * when one chip was already done with the current
+			 * operation while another chip suspended it, then
+			 * we resume the whole thing at once).  Yes, it
+			 * can happen!
+			 */
+			map_write(map, CMD(0xb0), adr);
+			map_write(map, CMD(0x70), adr);
+			usec -= xip_elapsed_since(start);
+			suspended = xip_currtime();
+			do {
+				if (xip_elapsed_since(suspended) > 100000) {
+					/*
+					 * The chip doesn't want to suspend
+					 * after waiting for 100 msecs.
+					 * This is a critical error but there
+					 * is not much we can do here.
+					 */
+					return;
+				}
+				status = map_read(map, adr);
+			} while (!map_word_andequal(map, status, OK, OK));
+
+			/* Suspend succeeded */
+			oldstate = chip->state;
+			if (oldstate == FL_ERASING) {
+				if (!map_word_bitsset(map, status, CMD(0x40)))
+					break;
+				newstate = FL_XIP_WHILE_ERASING;
+				chip->erase_suspended = 1;
+			} else {
+				if (!map_word_bitsset(map, status, CMD(0x04)))
+					break;
+				newstate = FL_XIP_WHILE_WRITING;
+				chip->write_suspended = 1;
+			}
+			chip->state = newstate;
+			map_write(map, CMD(0xff), adr);
+			(void) map_read(map, adr);
+			asm volatile (".rep 8; nop; .endr");
+			local_irq_enable();
+			preempt_enable();
+			asm volatile (".rep 8; nop; .endr");
+			cond_resched();
+
+			/*
+			 * We're back.  However someone else might have
+			 * decided to go write to the chip if we are in
+			 * a suspended erase state.  If so let's wait
+			 * until it's done.
+			 */
+			preempt_disable();
+			while (chip->state != newstate) {
+				DECLARE_WAITQUEUE(wait, current);
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				add_wait_queue(&chip->wq, &wait);
+				preempt_enable();
+				schedule();
+				remove_wait_queue(&chip->wq, &wait);
+				preempt_disable();
+			}
+			/* Disallow XIP again */
+			local_irq_disable();
+
+			/* Resume the write or erase operation */
+			map_write(map, CMD(0xd0), adr);
+			map_write(map, CMD(0x70), adr);
+			chip->state = oldstate;
+			start = xip_currtime();
+		} else if (usec >= 1000000/HZ) {
+			/*
+			 * Try to save on CPU power when waiting delay
+			 * is at least a system timer tick period.
+			 * No need to be extremely accurate here.
+			 */
+			xip_cpu_idle();
+		}
+		status = map_read(map, adr);
+	} while (!map_word_andequal(map, status, OK, OK)
+		 && xip_elapsed_since(start) < usec);
+}
+
+#define UDELAY(map, chip, adr, usec)  xip_udelay(map, chip, adr, usec)
+
+/*
+ * The INVALIDATE_CACHED_RANGE() macro is normally used in parallel while
+ * the flash is actively programming or erasing since we have to poll for
+ * the operation to complete anyway.  We can't do that in a generic way with
+ * a XIP setup so do it before the actual flash operation in this case.
+ */
+#undef INVALIDATE_CACHED_RANGE
+#define INVALIDATE_CACHED_RANGE(x...)
+#define XIP_INVAL_CACHED_RANGE(map, from, size) \
+	do { if(map->inval_cache) map->inval_cache(map, from, size); } while(0)
+
+/*
+ * Extra notes:
+ *
+ * Activating this XIP support changes the way the code works a bit.  For
+ * example the code to suspend the current process when concurrent access
+ * happens is never executed because xip_udelay() will always return with the
+ * same chip state as it was entered with.  This is why there is no care for
+ * the presence of add_wait_queue() or schedule() calls from within a couple
+ * xip_disable()'d  areas of code, like in do_erase_oneblock for example.
+ * The queueing and scheduling are always happening within xip_udelay().
+ *
+ * Similarly, get_chip() and put_chip() just happen to always be executed
+ * with chip->state set to FL_READY (or FL_XIP_WHILE_*) where flash state
+ * is in array mode, therefore never executing many cases therein and not
+ * causing any problem with XIP.
+ */
+
+#else
+
+#define xip_disable(map, chip, adr)
+#define xip_enable(map, chip, adr)
+
+#define UDELAY(map, chip, adr, usec)  cfi_udelay(usec)
+
+#define XIP_INVAL_CACHED_RANGE(x...)
+
+#endif
+
 static int do_point_onechip (struct map_info *map, struct flchip *chip, loff_t adr, size_t len)
 {
 	unsigned long cmd_addr;
@@ -822,8 +1175,13 @@
 	}
 	return ret;
 }
+
 #if 0
-static int cfi_intelext_read_prot_reg (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf, int base_offst, int reg_sz)
+static int __xipram cfi_intelext_read_prot_reg (struct mtd_info *mtd,
+						loff_t from, size_t len,
+						size_t *retlen,
+						u_char *buf,
+						int base_offst, int reg_sz)
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -852,6 +1210,8 @@
 			return (len-count)?:ret;
 		}
 
+		xip_disable(map, chip, chip->start);
+
 		if (chip->state != FL_JEDEC_QUERY) {
 			map_write(map, CMD(0x90), chip->start);
 			chip->state = FL_JEDEC_QUERY;
@@ -864,6 +1224,7 @@
 			count--;
 		}
 
+		xip_enable(map, chip, chip->start);
 		put_chip(map, chip, chip->start);
 		spin_unlock(chip->mutex);
 
@@ -884,7 +1245,7 @@
 	int base_offst,reg_sz;
 	
 	/* Check that we actually have some protection registers */
-	if(!(extp->FeatureSupport&64)){
+	if(!extp || !(extp->FeatureSupport&64)){
 		printk(KERN_WARNING "%s: This flash device has no protection data to read!\n",map->name);
 		return 0;
 	}
@@ -903,7 +1264,7 @@
 	int base_offst,reg_sz;
 	
 	/* Check that we actually have some protection registers */
-	if(!(extp->FeatureSupport&64)){
+	if(!extp || !(extp->FeatureSupport&64)){
 		printk(KERN_WARNING "%s: This flash device has no protection data to read!\n",map->name);
 		return 0;
 	}
@@ -915,7 +1276,8 @@
 }
 #endif
 
-static int do_write_oneword(struct map_info *map, struct flchip *chip, unsigned long adr, map_word datum)
+static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
+				     unsigned long adr, map_word datum)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	map_word status, status_OK;
@@ -934,14 +1296,16 @@
 		return ret;
 	}
 
+	XIP_INVAL_CACHED_RANGE(map, adr, map_bankwidth(map));
 	ENABLE_VPP(map);
+	xip_disable(map, chip, adr);
 	map_write(map, CMD(0x40), adr);
 	map_write(map, datum, adr);
 	chip->state = FL_WRITING;
 
 	spin_unlock(chip->mutex);
 	INVALIDATE_CACHED_RANGE(map, adr, map_bankwidth(map));
-	cfi_udelay(chip->word_write_time);
+	UDELAY(map, chip, adr, chip->word_write_time);
 	spin_lock(chip->mutex);
 
 	timeo = jiffies + (HZ/2);
@@ -968,6 +1332,7 @@
 		/* OK Still waiting */
 		if (time_after(jiffies, timeo)) {
 			chip->state = FL_STATUS;
+			xip_enable(map, chip, adr);
 			printk(KERN_ERR "waiting for chip to be ready timed out in word write\n");
 			ret = -EIO;
 			goto out;
@@ -976,7 +1341,7 @@
 		/* Latency issues. Drop the lock, wait a while and retry */
 		spin_unlock(chip->mutex);
 		z++;
-		cfi_udelay(1);
+		UDELAY(map, chip, adr, 1);
 		spin_lock(chip->mutex);
 	}
 	if (!z) {
@@ -989,6 +1354,7 @@
 
 	/* Done and happy. */
 	chip->state = FL_STATUS;
+
 	/* check for lock bit */
 	if (map_word_bitsset(map, status, CMD(0x02))) {
 		/* clear status */
@@ -997,8 +1363,9 @@
 		map_write(map, CMD(0x70), adr);
 		ret = -EROFS;
 	}
- out:
-	put_chip(map, chip, adr);
+
+	xip_enable(map, chip, adr);
+ out:	put_chip(map, chip, adr);
 	spin_unlock(chip->mutex);
 
 	return ret;
@@ -1088,8 +1455,8 @@
 }
 
 
-static inline int do_write_buffer(struct map_info *map, struct flchip *chip, 
-				  unsigned long adr, const u_char *buf, int len)
+static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip, 
+				    unsigned long adr, const u_char *buf, int len)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	map_word status, status_OK;
@@ -1110,6 +1477,10 @@
 		return ret;
 	}
 
+	XIP_INVAL_CACHED_RANGE(map, adr, len);
+	ENABLE_VPP(map);
+	xip_disable(map, chip, cmd_adr);
+
 	/* 4.8 of the 28FxxxJ3A datasheet says "Any time SR.4 and/or SR.5 is set
 	   [...], the device will not accept any more Write to Buffer commands". 
 	   So we must check here and reset those bits if they're set. Otherwise
@@ -1118,12 +1489,13 @@
 		map_write(map, CMD(0x70), cmd_adr);
 	status = map_read(map, cmd_adr);
 	if (map_word_bitsset(map, status, CMD(0x30))) {
+		xip_enable(map, chip, cmd_adr);
 		printk(KERN_WARNING "SR.4 or SR.5 bits set in buffer write (status %lx). Clearing.\n", status.x[0]);
+		xip_disable(map, chip, cmd_adr);
 		map_write(map, CMD(0x50), cmd_adr);
 		map_write(map, CMD(0x70), cmd_adr);
 	}
 
-	ENABLE_VPP(map);
 	chip->state = FL_WRITING_TO_BUFFER;
 
 	z = 0;
@@ -1135,18 +1507,21 @@
 			break;
 
 		spin_unlock(chip->mutex);
-		cfi_udelay(1);
+		UDELAY(map, chip, cmd_adr, 1);
 		spin_lock(chip->mutex);
 
 		if (++z > 20) {
 			/* Argh. Not ready for write to buffer */
+			map_word Xstatus;
 			map_write(map, CMD(0x70), cmd_adr);
 			chip->state = FL_STATUS;
-			printk(KERN_ERR "Chip not ready for buffer write. Xstatus = %lx, status = %lx\n",
-			       status.x[0], map_read(map, cmd_adr).x[0]);
+			Xstatus = map_read(map, cmd_adr);
 			/* Odd. Clear status bits */
 			map_write(map, CMD(0x50), cmd_adr);
 			map_write(map, CMD(0x70), cmd_adr);
+			xip_enable(map, chip, cmd_adr);
+			printk(KERN_ERR "Chip not ready for buffer write. status = %lx, Xstatus = %lx\n",
+			       status.x[0], Xstatus.x[0]);
 			ret = -EIO;
 			goto out;
 		}
@@ -1181,7 +1556,7 @@
 
 	spin_unlock(chip->mutex);
 	INVALIDATE_CACHED_RANGE(map, adr, len);
-	cfi_udelay(chip->buffer_write_time);
+	UDELAY(map, chip, cmd_adr, chip->buffer_write_time);
 	spin_lock(chip->mutex);
 
 	timeo = jiffies + (HZ/2);
@@ -1207,6 +1582,7 @@
 		/* OK Still waiting */
 		if (time_after(jiffies, timeo)) {
 			chip->state = FL_STATUS;
+			xip_enable(map, chip, cmd_adr);
 			printk(KERN_ERR "waiting for chip to be ready timed out in bufwrite\n");
 			ret = -EIO;
 			goto out;
@@ -1214,7 +1590,7 @@
 		
 		/* Latency issues. Drop the lock, wait a while and retry */
 		spin_unlock(chip->mutex);
-		cfi_udelay(1);
+		UDELAY(map, chip, cmd_adr, 1);
 		z++;
 		spin_lock(chip->mutex);
 	}
@@ -1238,8 +1614,8 @@
 		ret = -EROFS;
 	}
 
- out:
-	put_chip(map, chip, cmd_adr);
+	xip_enable(map, chip, cmd_adr);
+ out:	put_chip(map, chip, cmd_adr);
 	spin_unlock(chip->mutex);
 	return ret;
 }
@@ -1308,104 +1684,8 @@
 	return 0;
 }
 
-typedef int (*varsize_frob_t)(struct map_info *map, struct flchip *chip,
-			      unsigned long adr, int len, void *thunk);
-
-static int cfi_intelext_varsize_frob(struct mtd_info *mtd, varsize_frob_t frob,
-				     loff_t ofs, size_t len, void *thunk)
-{
-	struct map_info *map = mtd->priv;
-	struct cfi_private *cfi = map->fldrv_priv;
-	unsigned long adr;
-	int chipnum, ret = 0;
-	int i, first;
-	struct mtd_erase_region_info *regions = mtd->eraseregions;
-
-	if (ofs > mtd->size)
-		return -EINVAL;
-
-	if ((len + ofs) > mtd->size)
-		return -EINVAL;
-
-	/* Check that both start and end of the requested erase are
-	 * aligned with the erasesize at the appropriate addresses.
-	 */
-
-	i = 0;
-
-	/* Skip all erase regions which are ended before the start of 
-	   the requested erase. Actually, to save on the calculations,
-	   we skip to the first erase region which starts after the
-	   start of the requested erase, and then go back one.
-	*/
-	
-	while (i < mtd->numeraseregions && ofs >= regions[i].offset)
-	       i++;
-	i--;
-
-	/* OK, now i is pointing at the erase region in which this 
-	   erase request starts. Check the start of the requested
-	   erase range is aligned with the erase size which is in
-	   effect here.
-	*/
-
-	if (ofs & (regions[i].erasesize-1))
-		return -EINVAL;
-
-	/* Remember the erase region we start on */
-	first = i;
-
-	/* Next, check that the end of the requested erase is aligned
-	 * with the erase region at that address.
-	 */
-
-	while (i<mtd->numeraseregions && (ofs + len) >= regions[i].offset)
-		i++;
-
-	/* As before, drop back one to point at the region in which
-	   the address actually falls
-	*/
-	i--;
-	
-	if ((ofs + len) & (regions[i].erasesize-1))
-		return -EINVAL;
-
-	chipnum = ofs >> cfi->chipshift;
-	adr = ofs - (chipnum << cfi->chipshift);
-
-	i=first;
-
-	while(len) {
-		unsigned long chipmask;
-		int size = regions[i].erasesize;
-
-		ret = (*frob)(map, &cfi->chips[chipnum], adr, size, thunk);
-		
-		if (ret)
-			return ret;
-
-		adr += size;
-		len -= size;
-
-		chipmask = (1 << cfi->chipshift) - 1;
-		if ((adr & chipmask) == ((regions[i].offset + size * regions[i].numblocks) & chipmask))
-			i++;
-
-		if (adr >> cfi->chipshift) {
-			adr = 0;
-			chipnum++;
-			
-			if (chipnum >= cfi->numchips)
-			break;
-		}
-	}
-
-	return 0;
-}
-
-
-static int do_erase_oneblock(struct map_info *map, struct flchip *chip,
-			     unsigned long adr, int len, void *thunk)
+static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
+				      unsigned long adr, int len, void *thunk)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	map_word status, status_OK;
@@ -1427,7 +1707,10 @@
 		return ret;
 	}
 
+	XIP_INVAL_CACHED_RANGE(map, adr, len);
 	ENABLE_VPP(map);
+	xip_disable(map, chip, adr);
+
 	/* Clear the status register first */
 	map_write(map, CMD(0x50), adr);
 
@@ -1439,7 +1722,7 @@
 
 	spin_unlock(chip->mutex);
 	INVALIDATE_CACHED_RANGE(map, adr, len);
-	msleep(chip->erase_time / 2);
+	UDELAY(map, chip, adr, chip->erase_time*1000/2);
 	spin_lock(chip->mutex);
 
 	/* FIXME. Use a timer to check this, and return immediately. */
@@ -1470,27 +1753,25 @@
 		
 		/* OK Still waiting */
 		if (time_after(jiffies, timeo)) {
+			map_word Xstatus;
 			map_write(map, CMD(0x70), adr);
 			chip->state = FL_STATUS;
-			printk(KERN_ERR "waiting for erase at %08lx to complete timed out. Xstatus = %lx, status = %lx.\n",
-			       adr, status.x[0], map_read(map, adr).x[0]);
+			Xstatus = map_read(map, adr);
 			/* Clear status bits */
 			map_write(map, CMD(0x50), adr);
 			map_write(map, CMD(0x70), adr);
-			DISABLE_VPP(map);
-			spin_unlock(chip->mutex);
-			return -EIO;
+			xip_enable(map, chip, adr);
+			printk(KERN_ERR "waiting for erase at %08lx to complete timed out. status = %lx, Xstatus = %lx.\n",
+			       adr, status.x[0], Xstatus.x[0]);
+			ret = -EIO;
+			goto out;
 		}
 		
 		/* Latency issues. Drop the lock, wait a while and retry */
 		spin_unlock(chip->mutex);
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		UDELAY(map, chip, adr, 1000000/HZ);
 		spin_lock(chip->mutex);
 	}
-	
-	DISABLE_VPP(map);
-	ret = 0;
 
 	/* We've broken this before. It doesn't hurt to be safe */
 	map_write(map, CMD(0x70), adr);
@@ -1499,7 +1780,14 @@
 
 	/* check for lock bit */
 	if (map_word_bitsset(map, status, CMD(0x3a))) {
-		unsigned char chipstatus = status.x[0];
+		unsigned char chipstatus;
+
+		/* Reset the error bits */
+		map_write(map, CMD(0x50), adr);
+		map_write(map, CMD(0x70), adr);
+		xip_enable(map, chip, adr);
+
+		chipstatus = status.x[0];
 		if (!map_word_equal(map, status, CMD(chipstatus))) {
 			int i, w;
 			for (w=0; w<map_words(map); w++) {
@@ -1510,10 +1798,7 @@
 			printk(KERN_WARNING "Status is not identical for all chips: 0x%lx. Merging to give 0x%02x\n",
 			       status.x[0], chipstatus);
 		}
-		/* Reset the error bits */
-		map_write(map, CMD(0x50), adr);
-		map_write(map, CMD(0x70), adr);
-		
+
 		if ((chipstatus & 0x30) == 0x30) {
 			printk(KERN_NOTICE "Chip reports improper command sequence: status 0x%x\n", chipstatus);
 			ret = -EIO;
@@ -1528,16 +1813,19 @@
 			if (retries--) {
 				printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x. Retrying...\n", adr, chipstatus);
 				timeo = jiffies + HZ;
-				chip->state = FL_STATUS;
+				put_chip(map, chip, adr);
 				spin_unlock(chip->mutex);
 				goto retry;
 			}
 			printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x\n", adr, chipstatus);
 			ret = -EIO;
 		}
+	} else {
+		xip_enable(map, chip, adr);
+		ret = 0;
 	}
 
-	wake_up(&chip->wq);
+ out:	put_chip(map, chip, adr);
 	spin_unlock(chip->mutex);
 	return ret;
 }
@@ -1550,7 +1838,7 @@
 	ofs = instr->addr;
 	len = instr->len;
 
-	ret = cfi_intelext_varsize_frob(mtd, do_erase_oneblock, ofs, len, NULL);
+	ret = cfi_varsize_frob(mtd, do_erase_oneblock, ofs, len, NULL);
 	if (ret)
 		return ret;
 
@@ -1601,16 +1889,21 @@
 }
 
 #ifdef DEBUG_LOCK_BITS
-static int do_printlockstatus_oneblock(struct map_info *map, struct flchip *chip,
-				       unsigned long adr, int len, void *thunk)
+static int __xipram do_printlockstatus_oneblock(struct map_info *map,
+						struct flchip *chip,
+						unsigned long adr,
+						int len, void *thunk)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
-	int ofs_factor = cfi->interleave * cfi->device_type;
+	int status, ofs_factor = cfi->interleave * cfi->device_type;
 
+	xip_disable(map, chip, adr+(2*ofs_factor));
 	cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);
-	printk(KERN_DEBUG "block status register for 0x%08lx is %x\n",
-	       adr, cfi_read_query(map, adr+(2*ofs_factor)));
 	chip->state = FL_JEDEC_QUERY;
+	status = cfi_read_query(map, adr+(2*ofs_factor));
+	xip_enable(map, chip, 0);
+	printk(KERN_DEBUG "block status register for 0x%08lx is %x\n",
+	       adr, status);
 	return 0;
 }
 #endif
@@ -1618,8 +1911,8 @@
 #define DO_XXLOCK_ONEBLOCK_LOCK		((void *) 1)
 #define DO_XXLOCK_ONEBLOCK_UNLOCK	((void *) 2)
 
-static int do_xxlock_oneblock(struct map_info *map, struct flchip *chip,
-			      unsigned long adr, int len, void *thunk)
+static int __xipram do_xxlock_oneblock(struct map_info *map, struct flchip *chip,
+				       unsigned long adr, int len, void *thunk)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	map_word status, status_OK;
@@ -1639,8 +1932,9 @@
 	}
 
 	ENABLE_VPP(map);
+	xip_disable(map, chip, adr);
+	
 	map_write(map, CMD(0x60), adr);
-
 	if (thunk == DO_XXLOCK_ONEBLOCK_LOCK) {
 		map_write(map, CMD(0x01), adr);
 		chip->state = FL_LOCKING;
@@ -1651,7 +1945,7 @@
 		BUG();
 
 	spin_unlock(chip->mutex);
-	schedule_timeout(HZ);
+	UDELAY(map, chip, adr, 1000000/HZ);
 	spin_lock(chip->mutex);
 
 	/* FIXME. Use a timer to check this, and return immediately. */
@@ -1666,23 +1960,27 @@
 		
 		/* OK Still waiting */
 		if (time_after(jiffies, timeo)) {
+			map_word Xstatus;
 			map_write(map, CMD(0x70), adr);
 			chip->state = FL_STATUS;
-			printk(KERN_ERR "waiting for unlock to complete timed out. Xstatus = %lx, status = %lx.\n",
-			       status.x[0], map_read(map, adr).x[0]);
-			DISABLE_VPP(map);
+			Xstatus = map_read(map, adr);
+			xip_enable(map, chip, adr);
+			printk(KERN_ERR "waiting for unlock to complete timed out. status = %lx, Xstatus = %lx.\n",
+			       status.x[0], Xstatus.x[0]);
+			put_chip(map, chip, adr);
 			spin_unlock(chip->mutex);
 			return -EIO;
 		}
 		
 		/* Latency issues. Drop the lock, wait a while and retry */
 		spin_unlock(chip->mutex);
-		cfi_udelay(1);
+		UDELAY(map, chip, adr, 1);
 		spin_lock(chip->mutex);
 	}
 	
 	/* Done and happy. */
 	chip->state = FL_STATUS;
+	xip_enable(map, chip, adr);
 	put_chip(map, chip, adr);
 	spin_unlock(chip->mutex);
 	return 0;
@@ -1695,18 +1993,18 @@
 #ifdef DEBUG_LOCK_BITS
 	printk(KERN_DEBUG "%s: lock status before, ofs=0x%08llx, len=0x%08X\n",
 	       __FUNCTION__, ofs, len);
-	cfi_intelext_varsize_frob(mtd, do_printlockstatus_oneblock,
-				  ofs, len, 0);
+	cfi_varsize_frob(mtd, do_printlockstatus_oneblock,
+		ofs, len, 0);
 #endif
 
-	ret = cfi_intelext_varsize_frob(mtd, do_xxlock_oneblock, 
-					ofs, len, DO_XXLOCK_ONEBLOCK_LOCK);
+	ret = cfi_varsize_frob(mtd, do_xxlock_oneblock, 
+		ofs, len, DO_XXLOCK_ONEBLOCK_LOCK);
 	
 #ifdef DEBUG_LOCK_BITS
 	printk(KERN_DEBUG "%s: lock status after, ret=%d\n",
 	       __FUNCTION__, ret);
-	cfi_intelext_varsize_frob(mtd, do_printlockstatus_oneblock,
-				  ofs, len, 0);
+	cfi_varsize_frob(mtd, do_printlockstatus_oneblock,
+		ofs, len, 0);
 #endif
 
 	return ret;
@@ -1719,18 +2017,18 @@
 #ifdef DEBUG_LOCK_BITS
 	printk(KERN_DEBUG "%s: lock status before, ofs=0x%08llx, len=0x%08X\n",
 	       __FUNCTION__, ofs, len);
-	cfi_intelext_varsize_frob(mtd, do_printlockstatus_oneblock,
-				  ofs, len, 0);
+	cfi_varsize_frob(mtd, do_printlockstatus_oneblock,
+		ofs, len, 0);
 #endif
 
-	ret = cfi_intelext_varsize_frob(mtd, do_xxlock_oneblock,
+	ret = cfi_varsize_frob(mtd, do_xxlock_oneblock,
 					ofs, len, DO_XXLOCK_ONEBLOCK_UNLOCK);
 	
 #ifdef DEBUG_LOCK_BITS
 	printk(KERN_DEBUG "%s: lock status after, ret=%d\n",
 	       __FUNCTION__, ret);
-	cfi_intelext_varsize_frob(mtd, do_printlockstatus_oneblock, 
-				  ofs, len, 0);
+	cfi_varsize_frob(mtd, do_printlockstatus_oneblock, 
+		ofs, len, 0);
 #endif
 	
 	return ret;
@@ -1761,9 +2059,18 @@
 				 * as the whole point is that nobody can do anything
 				 * with the chip now anyway.
 				 */
+			} else {
+				/* There seems to be an operation pending. We must wait for it. */
+				printk(KERN_NOTICE "Flash device refused suspend due to pending operation (oldstate %d)\n", chip->oldstate);
+				ret = -EAGAIN;
 			}
 			break;
 		default:
+			/* Should we actually wait? Once upon a time these routines weren't
+			   allowed to. Or should we return -EAGAIN, because the upper layers
+			   ought to have already shut down anything which was using the device
+			   anyway? The latter for now. */
+			printk(KERN_NOTICE "Flash device refused suspend due to active operation (state %d)\n", chip->oldstate);
 			ret = -EAGAIN;
 		case FL_PM_SUSPENDED:
 			break;
@@ -1784,6 +2091,7 @@
 				   because we're returning failure, and it didn't
 				   get power cycled */
 				chip->state = chip->oldstate;
+				chip->oldstate = FL_READY;
 				wake_up(&chip->wq);
 			}
 			spin_unlock(chip->mutex);
@@ -1809,7 +2117,7 @@
 		/* Go to known state. Chip may have been power cycled */
 		if (chip->state == FL_PM_SUSPENDED) {
 			map_write(map, CMD(0xFF), cfi->chips[i].start);
-			chip->state = FL_READY;
+			chip->oldstate = chip->state = FL_READY;
 			wake_up(&chip->wq);
 		}
 
@@ -1831,7 +2139,7 @@
 static char im_name_1[]="cfi_cmdset_0001";
 static char im_name_3[]="cfi_cmdset_0003";
 
-int __init cfi_intelext_init(void)
+static int __init cfi_intelext_init(void)
 {
 	inter_module_register(im_name_1, THIS_MODULE, &cfi_cmdset_0001);
 	inter_module_register(im_name_3, THIS_MODULE, &cfi_cmdset_0001);
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/cfi_cmdset_0002.c linuxppc-2.6.9-dream/drivers/mtd/chips/cfi_cmdset_0002.c
--- linuxppc-2.6.9/drivers/mtd/chips/cfi_cmdset_0002.c	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/cfi_cmdset_0002.c	2005-06-20 10:46:11.000000000 +0200
@@ -13,7 +13,7 @@
  *
  * This code is GPL
  *
- * $Id: cfi_cmdset_0002.c,v 1.106 2004/08/09 14:02:32 dwmw2 Exp $
+ * $Id: cfi_cmdset_0002.c,v 1.114 2004/12/11 15:43:53 dedekind Exp $
  *
  */
 
@@ -40,13 +40,15 @@
 
 #define MAX_WORD_RETRIES 3
 
+#define MANUFACTURER_AMD	0x0001
+#define MANUFACTURER_SST	0x00BF
+#define SST49LF004B	        0x0060
+
 static int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int cfi_amdstd_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
 static int cfi_amdstd_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
 static int cfi_amdstd_erase_chip(struct mtd_info *, struct erase_info *);
 static int cfi_amdstd_erase_varsize(struct mtd_info *, struct erase_info *);
-static int cfi_amdstd_lock_varsize(struct mtd_info *, loff_t, size_t);
-static int cfi_amdstd_unlock_varsize(struct mtd_info *, loff_t, size_t);
 static void cfi_amdstd_sync (struct mtd_info *);
 static int cfi_amdstd_suspend (struct mtd_info *);
 static void cfi_amdstd_resume (struct mtd_info *);
@@ -55,8 +57,11 @@
 static void cfi_amdstd_destroy(struct mtd_info *);
 
 struct mtd_info *cfi_cmdset_0002(struct map_info *, int);
-static struct mtd_info *cfi_amdstd_setup (struct map_info *);
+static struct mtd_info *cfi_amdstd_setup (struct mtd_info *);
 
+static int get_chip(struct map_info *map, struct flchip *chip, unsigned long adr, int mode);
+static void put_chip(struct map_info *map, struct flchip *chip, unsigned long adr);
+#include "fwh_lock.h"
 
 static struct mtd_chip_driver cfi_amdstd_chipdrv = {
 	.probe		= NULL, /* Not usable directly */
@@ -66,7 +71,6 @@
 };
 
 
-/* #define DEBUG_LOCK_BITS */
 /* #define DEBUG_CFI_FEATURES */
 
 
@@ -122,8 +126,9 @@
 
 #ifdef AMD_BOOTLOC_BUG
 /* Wheee. Bring me the head of someone at AMD. */
-static void fixup_amd_bootblock(struct map_info *map, void* param)
+static void fixup_amd_bootblock(struct mtd_info *mtd, void* param)
 {
+	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	struct cfi_pri_amdstd *extp = cfi->cmdset_priv;
 	__u8 major = extp->MajorVersion;
@@ -141,25 +146,92 @@
 }
 #endif
 
-static struct cfi_fixup fixup_table[] = {
+static void fixup_use_write_buffers(struct mtd_info *mtd, void *param)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	if (cfi->cfiq->BufWriteTimeoutTyp) {
+		DEBUG(MTD_DEBUG_LEVEL1, "Using buffer write method\n" );
+		mtd->write = cfi_amdstd_write_buffers;
+	}
+}
+
+static void fixup_use_secsi(struct mtd_info *mtd, void *param)
+{
+	/* Setup for chips with a secsi area */
+	mtd->read_user_prot_reg = cfi_amdstd_secsi_read;
+	mtd->read_fact_prot_reg = cfi_amdstd_secsi_read;
+}
+
+static void fixup_use_erase_chip(struct mtd_info *mtd, void *param)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	if ((cfi->cfiq->NumEraseRegions == 1) &&
+		((cfi->cfiq->EraseRegionInfo[0] & 0xffff) == 0)) {
+		mtd->erase = cfi_amdstd_erase_chip;
+	}
+	
+}
+
+static struct cfi_fixup cfi_fixup_table[] = {
 #ifdef AMD_BOOTLOC_BUG
-	{
-		0x0001,		/* AMD */
-		CFI_ID_ANY,
-		fixup_amd_bootblock, NULL
-	},
+	{ CFI_MFR_AMD, CFI_ID_ANY, fixup_amd_bootblock, NULL },
+#endif
+	{ CFI_MFR_AMD, 0x0050, fixup_use_secsi, NULL, },
+	{ CFI_MFR_AMD, 0x0053, fixup_use_secsi, NULL, },
+	{ CFI_MFR_AMD, 0x0055, fixup_use_secsi, NULL, },
+	{ CFI_MFR_AMD, 0x0056, fixup_use_secsi, NULL, },
+	{ CFI_MFR_AMD, 0x005C, fixup_use_secsi, NULL, },
+	{ CFI_MFR_AMD, 0x005F, fixup_use_secsi, NULL, },
+#if !FORCE_WORD_WRITE
+	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_write_buffers, NULL, },
 #endif
 	{ 0, 0, NULL, NULL }
 };
+static struct cfi_fixup jedec_fixup_table[] = {
+	{ MANUFACTURER_SST, SST49LF004B, fixup_use_fwh_lock, NULL, },
+	{ 0, 0, NULL, NULL }
+};
+
+static struct cfi_fixup fixup_table[] = {
+	/* The CFI vendor ids and the JEDEC vendor IDs appear
+	 * to be common.  It is like the devices id's are as
+	 * well.  This table is to pick all cases where
+	 * we know that is the case.
+	 */
+	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_erase_chip, NULL },
+	{ 0, 0, NULL, NULL }
+};
 
 
 struct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
-	unsigned char bootloc;
+	struct mtd_info *mtd;
 	int i;
 
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if (!mtd) {
+		printk(KERN_WARNING "Failed to allocate memory for MTD device\n");
+		return NULL;
+	}
+	memset(mtd, 0, sizeof(*mtd));
+	mtd->priv = map;
+	mtd->type = MTD_NORFLASH;
+
+	/* Fill in the default mtd operations */
+	mtd->erase   = cfi_amdstd_erase_varsize;
+	mtd->write   = cfi_amdstd_write_words;
+	mtd->read    = cfi_amdstd_read;
+	mtd->sync    = cfi_amdstd_sync;
+	mtd->suspend = cfi_amdstd_suspend;
+	mtd->resume  = cfi_amdstd_resume;
+	mtd->flags   = MTD_CAP_NORFLASH;
+	mtd->name    = map->name;
+
 	if (cfi->cfi_mode==CFI_MODE_CFI){
+		unsigned char bootloc;
 		/* 
 		 * It's a real CFI chip, not one for which the probe
 		 * routine faked a CFI structure. So we read the feature
@@ -169,13 +241,16 @@
 		struct cfi_pri_amdstd *extp;
 
 		extp = (struct cfi_pri_amdstd*)cfi_read_pri(map, adr, sizeof(*extp), "Amd/Fujitsu");
-		if (!extp)
+		if (!extp) {
+			kfree(mtd);
 			return NULL;
+		}
 
 		/* Install our own private info structure */
 		cfi->cmdset_priv = extp;	
 
-		cfi_fixup(map, fixup_table);
+		/* Apply cfi device specific fixups */
+		cfi_fixup(mtd, cfi_fixup_table);
 
 #ifdef DEBUG_CFI_FEATURES
 		/* Tell the user about it in lots of lovely detail */
@@ -201,43 +276,28 @@
 				cfi->cfiq->EraseRegionInfo[j] = swap;
 			}
 		}
-		/*
-		 * These might already be setup (more correctly) by
-		 * jedec_probe.c - still need it for cfi_probe.c path.
-		 */
-		if ( ! (cfi->addr_unlock1 && cfi->addr_unlock2) ) {
-			switch (cfi->device_type) {
-			case CFI_DEVICETYPE_X8:
-				cfi->addr_unlock1 = 0x555; 
-				cfi->addr_unlock2 = 0x2aa; 
-				break;
-			case CFI_DEVICETYPE_X16:
-				cfi->addr_unlock1 = 0xaaa;
-				if (map_bankwidth(map) == cfi_interleave(cfi)) {
-					/* X16 chip(s) in X8 mode */
-					cfi->addr_unlock2 = 0x555;
-				} else {
-					cfi->addr_unlock2 = 0x554;
-				}
-				break;
-			case CFI_DEVICETYPE_X32:
-				cfi->addr_unlock1 = 0x1554;
-				if (map_bankwidth(map) == cfi_interleave(cfi)*2) {
-					/* X32 chip(s) in X16 mode */
-					cfi->addr_unlock1 = 0xaaa;
-				} else {
-					cfi->addr_unlock2 = 0xaa8; 
-				}
-				break;
-			default:
-				printk(KERN_WARNING
-				       "MTD %s(): Unsupported device type %d\n",
-				       __func__, cfi->device_type);
-				return NULL;
-			}
+		/* Set the default CFI lock/unlock addresses */
+		cfi->addr_unlock1 = 0x555;
+		cfi->addr_unlock2 = 0x2aa;
+		/* Modify the unlock address if we are in compatibility mode */
+		if (	/* x16 in x8 mode */
+			((cfi->device_type == CFI_DEVICETYPE_X8) && 
+				(cfi->cfiq->InterfaceDesc == 2)) ||
+			/* x32 in x16 mode */
+			((cfi->device_type == CFI_DEVICETYPE_X16) &&
+				(cfi->cfiq->InterfaceDesc == 4))) 
+		{
+			cfi->addr_unlock1 = 0xaaa;
+			cfi->addr_unlock2 = 0x555;
 		}
 
 	} /* CFI mode */
+	else if (cfi->cfi_mode == CFI_MODE_JEDEC) {
+		/* Apply jedec specific fixups */
+		cfi_fixup(mtd, jedec_fixup_table);
+	}
+	/* Apply generic fixups */
+	cfi_fixup(mtd, fixup_table);
 
 	for (i=0; i< cfi->numchips; i++) {
 		cfi->chips[i].word_write_time = 1<<cfi->cfiq->WordWriteTimeoutTyp;
@@ -246,32 +306,22 @@
 	}		
 	
 	map->fldrv = &cfi_amdstd_chipdrv;
-
-	return cfi_amdstd_setup(map);
+	
+	return cfi_amdstd_setup(mtd);
 }
 
 
-static struct mtd_info *cfi_amdstd_setup(struct map_info *map)
+static struct mtd_info *cfi_amdstd_setup(struct mtd_info *mtd)
 {
+	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
-	struct mtd_info *mtd;
 	unsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;
 	unsigned long offset = 0;
 	int i,j;
 
-	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
 	printk(KERN_NOTICE "number of %s chips: %d\n", 
 	       (cfi->cfi_mode == CFI_MODE_CFI)?"CFI":"JEDEC",cfi->numchips);
-
-	if (!mtd) {
-		printk(KERN_WARNING "Failed to allocate memory for MTD device\n");
-		goto setup_err;
-	}
-
-	memset(mtd, 0, sizeof(*mtd));
-	mtd->priv = map;
-	mtd->type = MTD_NORFLASH;
-	/* Also select the correct geometry setup too */ 
+	/* Select the correct geometry setup */ 
 	mtd->size = devsize * cfi->numchips;
 
 	mtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;
@@ -312,54 +362,10 @@
 	}
 #endif
 
-	if (mtd->numeraseregions == 1
-	    && ((cfi->cfiq->EraseRegionInfo[0] & 0xffff) + 1) == 1) {
-		mtd->erase = cfi_amdstd_erase_chip;
-	} else {
-		mtd->erase = cfi_amdstd_erase_varsize;
-		mtd->lock = cfi_amdstd_lock_varsize;
-		mtd->unlock = cfi_amdstd_unlock_varsize;
-	}
-
-	if ( cfi->cfiq->BufWriteTimeoutTyp && !FORCE_WORD_WRITE) {
-		DEBUG(MTD_DEBUG_LEVEL1, "Using buffer write method\n" );
-		mtd->write = cfi_amdstd_write_buffers;
-	} else {
-		DEBUG(MTD_DEBUG_LEVEL1, "Using word write method\n" );
-		mtd->write = cfi_amdstd_write_words;
-	}
-
-	mtd->read = cfi_amdstd_read;
-
 	/* FIXME: erase-suspend-program is broken.  See
 	   http://lists.infradead.org/pipermail/linux-mtd/2003-December/009001.html */
 	printk(KERN_NOTICE "cfi_cmdset_0002: Disabling erase-suspend-program due to code brokenness.\n");
 
-	/* does this chip have a secsi area? */
-	if(cfi->mfr==1){
-		
-		switch(cfi->id){
-		case 0x50:
-		case 0x53:
-		case 0x55:
-		case 0x56:
-		case 0x5C:
-		case 0x5F:
-			/* Yes */
-			mtd->read_user_prot_reg = cfi_amdstd_secsi_read;
-			mtd->read_fact_prot_reg = cfi_amdstd_secsi_read;
-		default:		       
-			;
-		}
-	}
-	
-		
-	mtd->sync = cfi_amdstd_sync;
-	mtd->suspend = cfi_amdstd_suspend;
-	mtd->resume = cfi_amdstd_resume;
-	mtd->flags = MTD_CAP_NORFLASH;
-	map->fldrv = &cfi_amdstd_chipdrv;
-	mtd->name = map->name;
 	__module_get(THIS_MODULE);
 	return mtd;
 
@@ -434,6 +440,7 @@
 			goto sleep;
 
 		if (!(mode == FL_READY || mode == FL_POINT
+		      || !cfip
 		      || (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))
 		      || (mode == FL_WRITING && (cfip->EraseSuspend & 0x1))))
 			goto sleep;
@@ -624,14 +631,12 @@
 
 	chip->state = FL_READY;
 
-	/* should these be CFI_DEVICETYPE_X8 instead of cfi->device_type? */
 	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0x88, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
 	
 	map_copy_from(map, buf, adr, len);
 
-	/* should these be CFI_DEVICETYPE_X8 instead of cfi->device_type? */
 	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0x90, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
@@ -702,7 +707,7 @@
 	 */
 	unsigned long uWriteTimeout = ( HZ / 1000 ) + 1;
 	int ret = 0;
-	map_word oldd, curd;
+	map_word oldd;
 	int retry_cnt = 0;
 
 	adr += chip->start;
@@ -732,17 +737,9 @@
 
 	ENABLE_VPP(map);
  retry:
-	/*
-	 * The CFI_DEVICETYPE_X8 argument is needed even when
-	 * cfi->device_type != CFI_DEVICETYPE_X8.  The addresses for
-	 * command sequences don't scale even when the device is
-	 * wider.  This is the case for many of the cfi_send_gen_cmd()
-	 * below.  I'm not sure, however, why some use
-	 * cfi->device_type.
-	 */
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
 	map_write(map, datum, adr);
 	chip->state = FL_WRITING;
 
@@ -767,23 +764,11 @@
 			continue;
 		}
 
-		/* Test to see if toggling has stopped. */
-		oldd = map_read(map, adr);
-		curd = map_read(map, adr);
-		if (map_word_equal(map, curd, oldd)) {
-			/* Do we have the correct value? */
-			if (map_word_equal(map, curd, datum)) {
-				goto op_done;
-			}
-			/* Nope something has gone wrong. */
-			break;
-		}
+		if (chip_ready(map, adr))
+			goto op_done;
 
-		if (time_after(jiffies, timeo)) {
-			printk(KERN_WARNING "MTD %s(): software timeout\n",
-				__func__ );
-			break;
-		}
+		if (time_after(jiffies, timeo))
+                        break;
 
 		/* Latency issues. Drop the lock, wait a while and retry */
 		cfi_spin_unlock(chip->mutex);
@@ -791,6 +776,8 @@
 		cfi_spin_lock(chip->mutex);
 	}
 
+	printk(KERN_WARNING "MTD %s(): software timeout\n", __func__);
+
 	/* reset on all failures. */
 	map_write( map, CMD(0xF0), chip->start );
 	/* FIXME - should have reset delay before continuing */
@@ -958,7 +945,7 @@
 	struct cfi_private *cfi = map->fldrv_priv;
 	unsigned long timeo = jiffies + HZ;
 	/* see comments in do_write_oneword() regarding uWriteTimeo. */
-	static unsigned long uWriteTimeout = ( HZ / 1000 ) + 1;
+	unsigned long uWriteTimeout = ( HZ / 1000 ) + 1;
 	int ret = -EIO;
 	unsigned long cmd_adr;
 	int z, words;
@@ -980,9 +967,9 @@
 	       __func__, adr, datum.x[0] );
 
 	ENABLE_VPP(map);
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	//cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
+	//cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
 
 	/* Write Buffer Load */
 	map_write(map, CMD(0x25), cmd_adr);
@@ -1081,8 +1068,8 @@
 		size_t local_len = (-ofs)&(map_bankwidth(map)-1);
 		if (local_len > len)
 			local_len = len;
-		ret = cfi_amdstd_write_words(mtd, to, local_len,
-					       retlen, buf);
+		ret = cfi_amdstd_write_words(mtd, ofs + (chipnum<<cfi->chipshift),
+					     local_len, retlen, buf);
 		if (ret)
 			return ret;
 		ofs += local_len;
@@ -1128,7 +1115,8 @@
 	if (len) {
 		size_t retlen_dregs = 0;
 
-		ret = cfi_amdstd_write_words(mtd, to, len, &retlen_dregs, buf);
+		ret = cfi_amdstd_write_words(mtd, ofs + (chipnum<<cfi->chipshift),
+					     len, &retlen_dregs, buf);
 
 		*retlen += retlen_dregs;
 		return ret;
@@ -1163,20 +1151,19 @@
 	       __func__, chip->start );
 
 	ENABLE_VPP(map);
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	cfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	cfi_send_gen_cmd(0x10, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x10, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
 
 	chip->state = FL_ERASING;
 	chip->erase_suspended = 0;
 	chip->in_progress_block_addr = adr;
 
 	cfi_spin_unlock(chip->mutex);
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout((chip->erase_time*HZ)/(2*1000));
+	msleep(chip->erase_time/2);
 	cfi_spin_lock(chip->mutex);
 
 	timeo = jiffies + (HZ*20);
@@ -1229,100 +1216,7 @@
 }
 
 
-typedef int (*frob_t)(struct map_info *map, struct flchip *chip,
-		      unsigned long adr, void *thunk);
-
-
-static int cfi_amdstd_varsize_frob(struct mtd_info *mtd, frob_t frob,
-				   loff_t ofs, size_t len, void *thunk)
-{
-	struct map_info *map = mtd->priv;
-	struct cfi_private *cfi = map->fldrv_priv;
-	unsigned long adr;
-	int chipnum, ret = 0;
-	int i, first;
-	struct mtd_erase_region_info *regions = mtd->eraseregions;
-
-	if (ofs > mtd->size)
-		return -EINVAL;
-
-	if ((len + ofs) > mtd->size)
-		return -EINVAL;
-
-	/* Check that both start and end of the requested erase are
-	 * aligned with the erasesize at the appropriate addresses.
-	 */
-
-	i = 0;
-
-	/* Skip all erase regions which are ended before the start of 
-	   the requested erase. Actually, to save on the calculations,
-	   we skip to the first erase region which starts after the
-	   start of the requested erase, and then go back one.
-	*/
-	
-	while (i < mtd->numeraseregions && ofs >= regions[i].offset)
-	       i++;
-	i--;
-
-	/* OK, now i is pointing at the erase region in which this 
-	   erase request starts. Check the start of the requested
-	   erase range is aligned with the erase size which is in
-	   effect here.
-	*/
-
-	if (ofs & (regions[i].erasesize-1))
-		return -EINVAL;
-
-	/* Remember the erase region we start on */
-	first = i;
-
-	/* Next, check that the end of the requested erase is aligned
-	 * with the erase region at that address.
-	 */
-
-	while (i<mtd->numeraseregions && (ofs + len) >= regions[i].offset)
-		i++;
-
-	/* As before, drop back one to point at the region in which
-	   the address actually falls
-	*/
-	i--;
-	
-	if ((ofs + len) & (regions[i].erasesize-1))
-		return -EINVAL;
-
-	chipnum = ofs >> cfi->chipshift;
-	adr = ofs - (chipnum << cfi->chipshift);
-
-	i=first;
-
-	while (len) {
-		ret = (*frob)(map, &cfi->chips[chipnum], adr, thunk);
-		
-		if (ret)
-			return ret;
-
-		adr += regions[i].erasesize;
-		len -= regions[i].erasesize;
-
-		if (adr % (1<< cfi->chipshift) == ((regions[i].offset + (regions[i].erasesize * regions[i].numblocks)) %( 1<< cfi->chipshift)))
-			i++;
-
-		if (adr >> cfi->chipshift) {
-			adr = 0;
-			chipnum++;
-			
-			if (chipnum >= cfi->numchips)
-			break;
-		}
-	}
-
-	return 0;
-}
-
-
-static inline int do_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr, void *thunk)
+static inline int do_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr, int len, void *thunk)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	unsigned long timeo = jiffies + HZ;
@@ -1342,11 +1236,11 @@
 	       __func__, adr );
 
 	ENABLE_VPP(map);
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	cfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
 	map_write(map, CMD(0x30), adr);
 
 	chip->state = FL_ERASING;
@@ -1354,8 +1248,7 @@
 	chip->in_progress_block_addr = adr;
 	
 	cfi_spin_unlock(chip->mutex);
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout((chip->erase_time*HZ)/(2*1000));
+	msleep(chip->erase_time/2);
 	cfi_spin_lock(chip->mutex);
 
 	timeo = jiffies + (HZ*20);
@@ -1415,7 +1308,7 @@
 	ofs = instr->addr;
 	len = instr->len;
 
-	ret = cfi_amdstd_varsize_frob(mtd, do_erase_oneblock, ofs, len, NULL);
+	ret = cfi_varsize_frob(mtd, do_erase_oneblock, ofs, len, NULL);
 	if (ret)
 		return ret;
 
@@ -1588,137 +1481,6 @@
 	}
 }
 
-
-#ifdef DEBUG_LOCK_BITS
-
-static int do_printlockstatus_oneblock(struct map_info *map,
-				       struct flchip *chip,
-				       unsigned long adr,
-				       void *thunk)
-{
-	struct cfi_private *cfi = map->fldrv_priv;
-	int ofs_factor = cfi->interleave * cfi->device_type;
-
-	cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);
-	printk(KERN_DEBUG "block status register for 0x%08lx is %x\n",
-	       adr, cfi_read_query(map, adr+(2*ofs_factor)));
-	cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);
-	
-	return 0;
-}
-
-
-#define debug_dump_locks(mtd, frob, ofs, len, thunk) \
-	cfi_amdstd_varsize_frob((mtd), (frob), (ofs), (len), (thunk))
-
-#else
-
-#define debug_dump_locks(...)
-
-#endif /* DEBUG_LOCK_BITS */
-
-
-struct xxlock_thunk {
-	uint8_t val;
-	flstate_t state;
-};
-
-
-#define DO_XXLOCK_ONEBLOCK_LOCK   ((struct xxlock_thunk){0x01, FL_LOCKING})
-#define DO_XXLOCK_ONEBLOCK_UNLOCK ((struct xxlock_thunk){0x00, FL_UNLOCKING})
-
-
-/*
- * FIXME - this is *very* specific to a particular chip.  It likely won't
- * work for all chips that require unlock.  It also hasn't been tested
- * with interleaved chips.
- */
-static int do_xxlock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr, void *thunk)
-{
-	struct cfi_private *cfi = map->fldrv_priv;
-	struct xxlock_thunk *xxlt = (struct xxlock_thunk *)thunk;
-	int ret;
-
-	/*
-	 * This is easy because these are writes to registers and not writes
-	 * to flash memory - that means that we don't have to check status
-	 * and timeout.
-	 */
-
-	adr += chip->start;
-	/*
-	 * lock block registers:
-	 * - on 64k boundariesand
-	 * - bit 1 set high
-	 * - block lock registers are 4MiB lower - overflow subtract (danger)
-	 */
-	adr = ((adr & ~0xffff) | 0x2) + ~0x3fffff;
-
-	cfi_spin_lock(chip->mutex);
-	ret = get_chip(map, chip, adr, FL_LOCKING);
-	if (ret) {
-		cfi_spin_unlock(chip->mutex);
-		return ret;
-	}
-
-	chip->state = xxlt->state;
-	map_write(map, CMD(xxlt->val), adr);
-	
-	/* Done and happy. */
-	chip->state = FL_READY;
-	put_chip(map, chip, adr);
-	cfi_spin_unlock(chip->mutex);
-	return 0;
-}
-
-
-static int cfi_amdstd_lock_varsize(struct mtd_info *mtd,
-				   loff_t ofs,
-				   size_t len)
-{
-	int ret;
-
-	DEBUG(MTD_DEBUG_LEVEL3,
-	      "%s: lock status before, ofs=0x%08llx, len=0x%08zX\n",
-	      __func__, ofs, len);
-	debug_dump_locks(mtd, do_printlockstatus_oneblock, ofs, len, 0);
-
-	ret = cfi_amdstd_varsize_frob(mtd, do_xxlock_oneblock, ofs, len,
-				      (void *)&DO_XXLOCK_ONEBLOCK_LOCK);
-	
-	DEBUG(MTD_DEBUG_LEVEL3,
-	      "%s: lock status after, ret=%d\n",
-	      __func__, ret);
-
-	debug_dump_locks(mtd, do_printlockstatus_oneblock, ofs, len, 0);
-
-	return ret;
-}
-
-
-static int cfi_amdstd_unlock_varsize(struct mtd_info *mtd,
-				     loff_t ofs,
-				     size_t len)
-{
-	int ret;
-
-	DEBUG(MTD_DEBUG_LEVEL3,
-	      "%s: lock status before, ofs=0x%08llx, len=0x%08zX\n",
-	      __func__, ofs, len);
-	debug_dump_locks(mtd, do_printlockstatus_oneblock, ofs, len, 0);
-
-	ret = cfi_amdstd_varsize_frob(mtd, do_xxlock_oneblock, ofs, len,
-				      (void *)&DO_XXLOCK_ONEBLOCK_UNLOCK);
-	
-	DEBUG(MTD_DEBUG_LEVEL3,
-	      "%s: lock status after, ret=%d\n",
-	      __func__, ret);
-	debug_dump_locks(mtd, do_printlockstatus_oneblock, ofs, len, 0);
-	
-	return ret;
-}
-
-
 static void cfi_amdstd_destroy(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
@@ -1732,7 +1494,7 @@
 static char im_name[]="cfi_cmdset_0002";
 
 
-int __init cfi_amdstd_init(void)
+static int __init cfi_amdstd_init(void)
 {
 	inter_module_register(im_name, THIS_MODULE, &cfi_cmdset_0002);
 	return 0;
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/cfi_cmdset_0020.c linuxppc-2.6.9-dream/drivers/mtd/chips/cfi_cmdset_0020.c
--- linuxppc-2.6.9/drivers/mtd/chips/cfi_cmdset_0020.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/cfi_cmdset_0020.c	2005-06-20 10:46:11.000000000 +0200
@@ -4,7 +4,7 @@
  *
  * (C) 2000 Red Hat. GPL'd
  *
- * $Id: cfi_cmdset_0020.c,v 1.15 2004/08/09 13:19:43 dwmw2 Exp $
+ * $Id: cfi_cmdset_0020.c,v 1.17 2004/11/20 12:49:04 dwmw2 Exp $
  * 
  * 10/10/2000	Nicolas Pitre <nico@cam.org>
  * 	- completely revamped method functions so they are aware and
@@ -788,7 +788,7 @@
 	chip->state = FL_ERASING;
 	
 	spin_unlock_bh(chip->mutex);
-	schedule_timeout(HZ);
+	msleep(1000);
 	spin_lock_bh(chip->mutex);
 
 	/* FIXME. Use a timer to check this, and return immediately. */
@@ -1087,7 +1087,7 @@
 	chip->state = FL_LOCKING;
 	
 	spin_unlock_bh(chip->mutex);
-	schedule_timeout(HZ);
+	msleep(1000);
 	spin_lock_bh(chip->mutex);
 
 	/* FIXME. Use a timer to check this, and return immediately. */
@@ -1236,7 +1236,7 @@
 	chip->state = FL_UNLOCKING;
 	
 	spin_unlock_bh(chip->mutex);
-	schedule_timeout(HZ);
+	msleep(1000);
 	spin_lock_bh(chip->mutex);
 
 	/* FIXME. Use a timer to check this, and return immediately. */
@@ -1401,7 +1401,7 @@
 
 static char im_name[]="cfi_cmdset_0020";
 
-int __init cfi_staa_init(void)
+static int __init cfi_staa_init(void)
 {
 	inter_module_register(im_name, THIS_MODULE, &cfi_cmdset_0020);
 	return 0;
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/cfi_probe.c linuxppc-2.6.9-dream/drivers/mtd/chips/cfi_probe.c
--- linuxppc-2.6.9/drivers/mtd/chips/cfi_probe.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/cfi_probe.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 /* 
    Common Flash Interface probe code.
    (C) 2000 Red Hat. GPL'd.
-   $Id: cfi_probe.c,v 1.77 2004/07/14 08:38:44 dwmw2 Exp $
+   $Id: cfi_probe.c,v 1.83 2004/11/16 18:19:02 nico Exp $
 */
 
 #include <linux/config.h>
@@ -15,6 +15,7 @@
 #include <linux/slab.h>
 #include <linux/interrupt.h>
 
+#include <linux/mtd/xip.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/cfi.h>
 #include <linux/mtd/gen_probe.h>
@@ -31,40 +32,75 @@
 
 struct mtd_info *cfi_probe(struct map_info *map);
 
+#ifdef CONFIG_MTD_XIP
+
+/* only needed for short periods, so this is rather simple */
+#define xip_disable()	local_irq_disable()
+
+#define xip_allowed(base, map) \
+do { \
+	(void) map_read(map, base); \
+	asm volatile (".rep 8; nop; .endr"); \
+	local_irq_enable(); \
+} while (0)
+
+#define xip_enable(base, map, cfi) \
+do { \
+	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL); \
+	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL); \
+	xip_allowed(base, map); \
+} while (0)
+
+#define xip_disable_qry(base, map, cfi) \
+do { \
+	xip_disable(); \
+	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL); \
+	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL); \
+	cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL); \
+} while (0)
+
+#else
+
+#define xip_disable()			do { } while (0)
+#define xip_allowed(base, map)		do { } while (0)
+#define xip_enable(base, map, cfi)	do { } while (0)
+#define xip_disable_qry(base, map, cfi) do { } while (0)
+
+#endif
+
 /* check for QRY.
    in: interleave,type,mode
    ret: table index, <0 for error
  */
-static int qry_present(struct map_info *map, __u32 base,
+static int __xipram qry_present(struct map_info *map, __u32 base,
 				struct cfi_private *cfi)
 {
 	int osf = cfi->interleave * cfi->device_type;	// scale factor
-	map_word val;
-	map_word qry;
+	map_word val[3];
+	map_word qry[3];
 
-	qry =  cfi_build_cmd('Q', map, cfi);
-	val = map_read(map, base + osf*0x10);
+	qry[0] = cfi_build_cmd('Q', map, cfi);
+	qry[1] = cfi_build_cmd('R', map, cfi);
+	qry[2] = cfi_build_cmd('Y', map, cfi);
+
+	val[0] = map_read(map, base + osf*0x10);
+	val[1] = map_read(map, base + osf*0x11);
+	val[2] = map_read(map, base + osf*0x12);
 
-	if (!map_word_equal(map, qry, val))
+	if (!map_word_equal(map, qry[0], val[0]))
 		return 0;
 
-	qry =  cfi_build_cmd('R', map, cfi);
-	val = map_read(map, base + osf*0x11);
-
-	if (!map_word_equal(map, qry, val))
+	if (!map_word_equal(map, qry[1], val[1]))
 		return 0;
 
-	qry =  cfi_build_cmd('Y', map, cfi);
-	val = map_read(map, base + osf*0x12);
-
-	if (!map_word_equal(map, qry, val))
+	if (!map_word_equal(map, qry[2], val[2]))
 		return 0;
 
-	return 1; 	// nothing found
+	return 1; 	// "QRY" found
 }
 
-static int cfi_probe_chip(struct map_info *map, __u32 base,
-			  unsigned long *chip_map, struct cfi_private *cfi)
+static int __xipram cfi_probe_chip(struct map_info *map, __u32 base,
+				   unsigned long *chip_map, struct cfi_private *cfi)
 {
 	int i;
 	
@@ -80,12 +116,16 @@
 			(unsigned long)base + 0x55, map->size -1);
 		return 0;
 	}
+
+	xip_disable();
 	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
 
-	if (!qry_present(map,base,cfi))
+	if (!qry_present(map,base,cfi)) {
+		xip_enable(base, map, cfi);
 		return 0;
+	}
 
 	if (!cfi->numchips) {
 		/* This is the first time we're called. Set up the CFI 
@@ -111,6 +151,7 @@
 
 			/* If the QRY marker goes away, it's an alias */
 			if (!qry_present(map, start, cfi)) {
+				xip_allowed(base, map);
 				printk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",
 				       map->name, base, start);
 				return 0;
@@ -123,6 +164,7 @@
 			cfi_send_gen_cmd(0xFF, 0, start, map, cfi, cfi->device_type, NULL);
 			
 			if (qry_present(map, base, cfi)) {
+				xip_allowed(base, map);
 				printk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",
 				       map->name, base, start);
 				return 0;
@@ -138,6 +180,7 @@
 	/* Put it back into Read Mode */
 	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);
+	xip_allowed(base, map);
 
 	printk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit bank\n",
 	       map->name, cfi->interleave, cfi->device_type*8, base,
@@ -146,14 +189,15 @@
 	return 1;
 }
 
-static int cfi_chip_setup(struct map_info *map, 
-		   struct cfi_private *cfi)
+static int __xipram cfi_chip_setup(struct map_info *map, 
+				   struct cfi_private *cfi)
 {
 	int ofs_factor = cfi->interleave*cfi->device_type;
 	__u32 base = 0;
 	int num_erase_regions = cfi_read_query(map, base + (0x10 + 28)*ofs_factor);
 	int i;
 
+	xip_enable(base, map, cfi);
 #ifdef DEBUG_CFI
 	printk("Number of erase regions: %d\n", num_erase_regions);
 #endif
@@ -171,13 +215,33 @@
 	cfi->cfi_mode = CFI_MODE_CFI;
 	
 	/* Read the CFI info structure */
-	for (i=0; i<(sizeof(struct cfi_ident) + num_erase_regions * 4); i++) {
+	xip_disable_qry(base, map, cfi);
+	for (i=0; i<(sizeof(struct cfi_ident) + num_erase_regions * 4); i++)
 		((unsigned char *)cfi->cfiq)[i] = cfi_read_query(map,base + (0x10 + i)*ofs_factor);
-	}
-	
+
+	/* Note we put the device back into Read Mode BEFORE going into Auto
+	 * Select Mode, as some devices support nesting of modes, others
+	 * don't. This way should always work.
+	 * On cmdset 0001 the writes of 0xaa and 0x55 are not needed, and
+	 * so should be treated as nops or illegal (and so put the device
+	 * back into Read Mode, which is a nop in this case).
+	 */
+	cfi_send_gen_cmd(0xf0,     0, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xaa, 0x555, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, 0x2aa, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x90, 0x555, base, map, cfi, cfi->device_type, NULL);
+	cfi->mfr = cfi_read_query(map, base);
+	cfi->id = cfi_read_query(map, base + ofs_factor);    
+
+	/* Put it back into Read Mode */
+	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
+	/* ... even if it's an Intel chip */
+	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);
+	xip_allowed(base, map);
+
 	/* Do any necessary byteswapping */
 	cfi->cfiq->P_ID = le16_to_cpu(cfi->cfiq->P_ID);
-	
+
 	cfi->cfiq->P_ADR = le16_to_cpu(cfi->cfiq->P_ADR);
 	cfi->cfiq->A_ID = le16_to_cpu(cfi->cfiq->A_ID);
 	cfi->cfiq->A_ADR = le16_to_cpu(cfi->cfiq->A_ADR);
@@ -199,25 +263,6 @@
 #endif
 	}
 
-	/* Note we put the device back into Read Mode BEFORE going into Auto
-	 * Select Mode, as some devices support nesting of modes, others
-	 * don't. This way should always work.
-	 * On cmdset 0001 the writes of 0xaa and 0x55 are not needed, and
-	 * so should be treated as nops or illegal (and so put the device
-	 * back into Read Mode, which is a nop in this case).
-	 */
-	cfi_send_gen_cmd(0xf0,     0, base, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0xaa, 0x555, base, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x55, 0x2aa, base, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x90, 0x555, base, map, cfi, cfi->device_type, NULL);
-	cfi->mfr = cfi_read_query(map, base);
-	cfi->id = cfi_read_query(map, base + ofs_factor);    
-
-	/* Put it back into Read Mode */
-	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
-	/* ... even if it's an Intel chip */
-	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);
-
 	printk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit bank\n",
 	       map->name, cfi->interleave, cfi->device_type*8, base,
 	       map->bankwidth*8);
@@ -243,12 +288,27 @@
 		
 	case P_ID_AMD_EXT:
 		return "AMD/Fujitsu Extended";
+
+	case P_ID_WINBOND:
+		return "Winbond Standard";
 		
+	case P_ID_ST_ADV:
+		return "ST Advanced";
+
 	case P_ID_MITSUBISHI_STD:
 		return "Mitsubishi Standard";
 		
 	case P_ID_MITSUBISHI_EXT:
 		return "Mitsubishi Extended";
+
+	case P_ID_SST_PAGE:
+		return "SST Page Write";
+
+	case P_ID_INTEL_PERFORMANCE:
+		return "Intel Performance Code";
+		
+	case P_ID_INTEL_DATA:
+		return "Intel Data";
 		
 	case P_ID_RESERVED:
 		return "Not Allowed / Reserved for Future Use";
@@ -327,6 +387,10 @@
 		printk("  - x32-only asynchronous interface\n");
 		break;
 		
+	case 4:
+		printk("  - supports x16 and x32 via Word# with asynchronous interface\n");
+		break;
+		
 	case 65535:
 		printk("  - Not Allowed / Reserved\n");
 		break;
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/cfi_util.c linuxppc-2.6.9-dream/drivers/mtd/chips/cfi_util.c
--- linuxppc-2.6.9/drivers/mtd/chips/cfi_util.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/cfi_util.c	2005-06-20 10:46:11.000000000 +0200
@@ -7,7 +7,7 @@
  *
  * This code is covered by the GPL.
  *
- * $Id: cfi_util.c,v 1.4 2004/07/14 08:38:44 dwmw2 Exp $
+ * $Id: cfi_util.c,v 1.8 2004/12/14 19:55:56 nico Exp $
  *
  */
 
@@ -22,12 +22,14 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/mtd/xip.h>
+#include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/cfi.h>
 #include <linux/mtd/compatmac.h>
 
 struct cfi_extquery *
-cfi_read_pri(struct map_info *map, __u16 adr, __u16 size, const char* name)
+__xipram cfi_read_pri(struct map_info *map, __u16 adr, __u16 size, const char* name)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	__u32 base = 0; // cfi->chips[0].start;
@@ -39,21 +41,35 @@
 	if (!adr)
 		goto out;
 
-	/* Switch it into Query Mode */
-	cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
-
 	extp = kmalloc(size, GFP_KERNEL);
 	if (!extp) {
 		printk(KERN_ERR "Failed to allocate memory\n");
 		goto out;
 	}
-		
+
+#ifdef CONFIG_MTD_XIP
+	local_irq_disable();
+#endif
+
+	/* Switch it into Query Mode */
+	cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
+
 	/* Read in the Extended Query Table */
 	for (i=0; i<size; i++) {
 		((unsigned char *)extp)[i] = 
 			cfi_read_query(map, base+((adr+i)*ofs_factor));
 	}
 
+	/* Make sure it returns to read mode */
+	cfi_send_gen_cmd(0xf0, 0, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xff, 0, base, map, cfi, cfi->device_type, NULL);
+
+#ifdef CONFIG_MTD_XIP
+	(void) map_read(map, base);
+	asm volatile (".rep 8; nop; .endr");
+	local_irq_enable();
+#endif
+
 	if (extp->MajorVersion != '1' || 
 	    (extp->MinorVersion < '0' || extp->MinorVersion > '3')) {
 		printk(KERN_WARNING "  Unknown %s Extended Query "
@@ -61,32 +77,120 @@
 		       extp->MinorVersion);
 		kfree(extp);
 		extp = NULL;
-		goto out;
 	}
 
-out:
-	/* Make sure it's in read mode */
-	cfi_send_gen_cmd(0xf0, 0, base, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0xff, 0, base, map, cfi, cfi->device_type, NULL);
-
-	return extp;
+ out:	return extp;
 }
 
 EXPORT_SYMBOL(cfi_read_pri);
 
-void cfi_fixup(struct map_info *map, struct cfi_fixup* fixups)
+void cfi_fixup(struct mtd_info *mtd, struct cfi_fixup *fixups)
 {
+	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	struct cfi_fixup *f;
 
 	for (f=fixups; f->fixup; f++) {
 		if (((f->mfr == CFI_MFR_ANY) || (f->mfr == cfi->mfr)) &&
 		    ((f->id  == CFI_ID_ANY)  || (f->id  == cfi->id))) {
-			f->fixup(map, f->param);
+			f->fixup(mtd, f->param);
 		}
 	}
 }
 
 EXPORT_SYMBOL(cfi_fixup);
 
+int cfi_varsize_frob(struct mtd_info *mtd, varsize_frob_t frob,
+				     loff_t ofs, size_t len, void *thunk)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long adr;
+	int chipnum, ret = 0;
+	int i, first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	if (ofs > mtd->size)
+		return -EINVAL;
+
+	if ((len + ofs) > mtd->size)
+		return -EINVAL;
+
+	/* Check that both start and end of the requested erase are
+	 * aligned with the erasesize at the appropriate addresses.
+	 */
+
+	i = 0;
+
+	/* Skip all erase regions which are ended before the start of 
+	   the requested erase. Actually, to save on the calculations,
+	   we skip to the first erase region which starts after the
+	   start of the requested erase, and then go back one.
+	*/
+	
+	while (i < mtd->numeraseregions && ofs >= regions[i].offset)
+	       i++;
+	i--;
+
+	/* OK, now i is pointing at the erase region in which this 
+	   erase request starts. Check the start of the requested
+	   erase range is aligned with the erase size which is in
+	   effect here.
+	*/
+
+	if (ofs & (regions[i].erasesize-1))
+		return -EINVAL;
+
+	/* Remember the erase region we start on */
+	first = i;
+
+	/* Next, check that the end of the requested erase is aligned
+	 * with the erase region at that address.
+	 */
+
+	while (i<mtd->numeraseregions && (ofs + len) >= regions[i].offset)
+		i++;
+
+	/* As before, drop back one to point at the region in which
+	   the address actually falls
+	*/
+	i--;
+	
+	if ((ofs + len) & (regions[i].erasesize-1))
+		return -EINVAL;
+
+	chipnum = ofs >> cfi->chipshift;
+	adr = ofs - (chipnum << cfi->chipshift);
+
+	i=first;
+
+	while(len) {
+		int size = regions[i].erasesize;
+
+		ret = (*frob)(map, &cfi->chips[chipnum], adr, size, thunk);
+		
+		if (ret)
+			return ret;
+
+		adr += size;
+		ofs += size;
+		len -= size;
+
+		if (ofs == regions[i].offset + size * regions[i].numblocks)
+			i++;
+
+		if (adr >> cfi->chipshift) {
+			adr = 0;
+			chipnum++;
+			
+			if (chipnum >= cfi->numchips)
+			break;
+		}
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(cfi_varsize_frob);
+
 MODULE_LICENSE("GPL");
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/chipreg.c linuxppc-2.6.9-dream/drivers/mtd/chips/chipreg.c
--- linuxppc-2.6.9/drivers/mtd/chips/chipreg.c	2004-10-18 23:53:50.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/chipreg.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: chipreg.c,v 1.16 2003/05/29 09:36:15 dwmw2 Exp $
+ * $Id: chipreg.c,v 1.17 2004/11/16 18:29:00 dwmw2 Exp $
  *
  * Registration for chip drivers
  *
@@ -15,7 +15,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/compatmac.h>
 
-spinlock_t chip_drvs_lock = SPIN_LOCK_UNLOCKED;
+static spinlock_t chip_drvs_lock = SPIN_LOCK_UNLOCKED;
 static LIST_HEAD(chip_drvs_list);
 
 void register_mtd_chip_driver(struct mtd_chip_driver *drv)
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/fwh_lock.h linuxppc-2.6.9-dream/drivers/mtd/chips/fwh_lock.h
--- linuxppc-2.6.9/drivers/mtd/chips/fwh_lock.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/fwh_lock.h	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,107 @@
+#ifndef FWH_LOCK_H
+#define FWH_LOCK_H
+
+
+enum fwh_lock_state {
+        FWH_UNLOCKED   = 0,
+	FWH_DENY_WRITE = 1,
+	FWH_IMMUTABLE  = 2,
+	FWH_DENY_READ  = 4,
+};
+
+struct fwh_xxlock_thunk {
+	enum fwh_lock_state val;
+	flstate_t state;
+};
+
+
+#define FWH_XXLOCK_ONEBLOCK_LOCK   ((struct fwh_xxlock_thunk){ FWH_DENY_WRITE, FL_LOCKING})
+#define FWH_XXLOCK_ONEBLOCK_UNLOCK ((struct fwh_xxlock_thunk){ FWH_UNLOCKED,   FL_UNLOCKING})
+
+/*
+ * This locking/unlock is specific to firmware hub parts.  Only one
+ * is known that supports the Intel command set.    Firmware
+ * hub parts cannot be interleaved as they are on the LPC bus
+ * so this code has not been tested with interleaved chips,
+ * and will likely fail in that context.
+ */
+static int fwh_xxlock_oneblock(struct map_info *map, struct flchip *chip, 
+	unsigned long adr, int len, void *thunk)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	struct fwh_xxlock_thunk *xxlt = (struct fwh_xxlock_thunk *)thunk;
+	int ret;
+
+	/* Refuse the operation if the we cannot look behind the chip */
+	if (chip->start < 0x400000) {
+		DEBUG( MTD_DEBUG_LEVEL3,
+			"MTD %s(): chip->start: %lx wanted >= 0x400000\n",
+			__func__, chip->start );
+		return -EIO;
+	}
+	/*
+	 * lock block registers:
+	 * - on 64k boundariesand
+	 * - bit 1 set high
+	 * - block lock registers are 4MiB lower - overflow subtract (danger)
+	 * 
+	 * The address manipulation is first done on the logical address
+	 * which is 0 at the start of the chip, and then the offset of
+	 * the individual chip is addted to it.  Any other order a weird
+	 * map offset could cause problems.
+	 */
+	adr = (adr & ~0xffffUL) | 0x2;
+	adr += chip->start - 0x400000;
+
+	/*
+	 * This is easy because these are writes to registers and not writes
+	 * to flash memory - that means that we don't have to check status
+	 * and timeout.
+	 */
+	cfi_spin_lock(chip->mutex);
+	ret = get_chip(map, chip, adr, FL_LOCKING);
+	if (ret) {
+		cfi_spin_unlock(chip->mutex);
+		return ret;
+	}
+
+	chip->state = xxlt->state;
+	map_write(map, CMD(xxlt->val), adr);
+
+	/* Done and happy. */
+	chip->state = FL_READY;
+	put_chip(map, chip, adr);
+	cfi_spin_unlock(chip->mutex);
+	return 0;
+}
+
+
+static int fwh_lock_varsize(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	int ret;
+
+	ret = cfi_varsize_frob(mtd, fwh_xxlock_oneblock, ofs, len,
+		(void *)&FWH_XXLOCK_ONEBLOCK_LOCK);
+
+	return ret;
+}
+
+
+static int fwh_unlock_varsize(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	int ret;
+
+	ret = cfi_varsize_frob(mtd, fwh_xxlock_oneblock, ofs, len,
+		(void *)&FWH_XXLOCK_ONEBLOCK_UNLOCK);
+	
+	return ret;
+}
+
+static void fixup_use_fwh_lock(struct mtd_info *mtd, void *param)
+{
+	printk(KERN_NOTICE "using fwh lock/unlock method\n");
+	/* Setup for the chips with the fwh lock method */
+	mtd->lock   = fwh_lock_varsize;
+	mtd->unlock = fwh_unlock_varsize;
+}
+#endif /* FWH_LOCK_H */
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/gen_probe.c linuxppc-2.6.9-dream/drivers/mtd/chips/gen_probe.c
--- linuxppc-2.6.9/drivers/mtd/chips/gen_probe.c	2004-10-18 23:55:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/gen_probe.c	2005-06-20 10:46:11.000000000 +0200
@@ -2,7 +2,7 @@
  * Routines common to all CFI-type probes.
  * (C) 2001-2003 Red Hat, Inc.
  * GPL'd
- * $Id: gen_probe.c,v 1.19 2004/07/13 22:33:32 dwmw2 Exp $
+ * $Id: gen_probe.c,v 1.21 2004/08/14 15:14:05 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
@@ -64,7 +64,7 @@
 	   interleave and device type, etc. */
 	if (!genprobe_new_chip(map, cp, &cfi)) {
 		/* The probe didn't like it */
-		printk(KERN_WARNING "%s: Found no %s device at location zero\n",
+		printk(KERN_DEBUG "%s: Found no %s device at location zero\n",
 		       cp->name, map->name);
 		return NULL;
 	}		
@@ -169,8 +169,12 @@
 
 		cfi->interleave = nr_chips;
 
-		for (type = 0; type < 3; type++) {
-			cfi->device_type = 1<<type;
+		/* Minimum device size. Don't look for one 8-bit device
+		   in a 16-bit bus, etc. */
+		type = map_bankwidth(map) / nr_chips;
+
+		for (; type <= CFI_DEVICETYPE_X32; type<<=1) {
+			cfi->device_type = type;
 
 			if (cp->probe_chip(map, 0, NULL, cfi))
 				return 1;
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/jedec.c linuxppc-2.6.9-dream/drivers/mtd/chips/jedec.c
--- linuxppc-2.6.9/drivers/mtd/chips/jedec.c	2004-10-18 23:54:32.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/jedec.c	2005-06-20 10:46:11.000000000 +0200
@@ -11,7 +11,7 @@
  * not going to guess how to send commands to them, plus I expect they will
  * all speak CFI..
  *
- * $Id: jedec.c,v 1.21 2004/08/09 13:19:43 dwmw2 Exp $
+ * $Id: jedec.c,v 1.22 2005/01/05 18:05:11 dwmw2 Exp $
  */
 
 #include <linux/init.h>
@@ -529,7 +529,7 @@
 static int jedec_read(struct mtd_info *mtd, loff_t from, size_t len, 
 		      size_t *retlen, u_char *buf)
 {
-   struct map_info *map = (struct map_info *)mtd->priv;
+   struct map_info *map = mtd->priv;
    
    map_copy_from(map, buf, from, len);
    *retlen = len;
@@ -541,8 +541,8 @@
 static int jedec_read_banked(struct mtd_info *mtd, loff_t from, size_t len, 
 			     size_t *retlen, u_char *buf)
 {
-   struct map_info *map = (struct map_info *)mtd->priv;
-   struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
+   struct map_info *map = mtd->priv;
+   struct jedec_private *priv = map->fldrv_priv;
 
    *retlen = 0;
    while (len > 0)
@@ -593,8 +593,8 @@
    unsigned long NoTime = 0;
    unsigned long start = instr->addr, len = instr->len;
    unsigned int I;
-   struct map_info *map = (struct map_info *)mtd->priv;
-   struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
+   struct map_info *map = mtd->priv;
+   struct jedec_private *priv = map->fldrv_priv;
 
    // Verify the arguments..
    if (start + len > mtd->size ||
@@ -800,8 +800,8 @@
    #define flread(x) map_read8(map,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
    #define flwrite(v,x) map_write8(map,v,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
    
-   struct map_info *map = (struct map_info *)mtd->priv;
-   struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
+   struct map_info *map = mtd->priv;
+   struct jedec_private *priv = map->fldrv_priv;
    unsigned long base;
    unsigned long off;
    size_t save_len = len;
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/jedec_probe.c linuxppc-2.6.9-dream/drivers/mtd/chips/jedec_probe.c
--- linuxppc-2.6.9/drivers/mtd/chips/jedec_probe.c	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/jedec_probe.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 /* 
    Common Flash Interface probe code.
    (C) 2000 Red Hat. GPL'd.
-   $Id: jedec_probe.c,v 1.51 2004/07/14 14:44:30 thayne Exp $
+   $Id: jedec_probe.c,v 1.61 2004/11/19 20:52:16 thayne Exp $
    See JEDEC (http://www.jedec.org/) standard JESD21C (section 3.5)
    for the standard this probe goes back to.
 
@@ -32,6 +32,7 @@
 #define MANUFACTURER_HYUNDAI	0x00AD
 #define MANUFACTURER_INTEL	0x0089
 #define MANUFACTURER_MACRONIX	0x00C2
+#define MANUFACTURER_NEC	0x0010
 #define MANUFACTURER_PMC	0x009D
 #define MANUFACTURER_SST	0x00BF
 #define MANUFACTURER_ST		0x0020
@@ -107,6 +108,7 @@
 #define I82802AC	0x00ac
 
 /* Macronix */
+#define MX29LV040C	0x004F
 #define MX29LV160T	0x22C4
 #define MX29LV160B	0x2249
 #define MX29F016	0x00AD
@@ -114,6 +116,9 @@
 #define MX29F004T	0x0045
 #define MX29F004B	0x0046
 
+/* NEC */
+#define UPD29F064115	0x221C
+
 /* PMC */
 #define PM49FL002	0x006D
 #define PM49FL004	0x006E
@@ -128,6 +133,7 @@
 #define M50FW040	0x002C
 #define M50FW080	0x002D
 #define M50FW016	0x002E
+#define M50LPW080       0x002F
 
 /* SST */
 #define SST29EE020	0x0010
@@ -181,8 +187,8 @@
 
 
 struct unlock_addr {
-	int addr1;
-	int addr2;
+	u32 addr1;
+	u32 addr2;
 };
 
 
@@ -225,6 +231,11 @@
 	[MTD_UADDR_DONT_CARE] = {
 		.addr1 = 0x0000,      /* Doesn't matter which address */
 		.addr2 = 0x0000       /* is used - must be last entry */
+	},
+
+	[MTD_UADDR_UNNECESSARY] = {
+		.addr1 = 0x0000,
+		.addr2 = 0x0000
 	}
 };
 
@@ -512,15 +523,20 @@
 			ERASEINFO(0x10000,8),
 		}
 	}, {
-		.mfr_id = MANUFACTURER_AMD,
-		.dev_id = AM29F002T,
-		.name = "AMD AM29F002T",
-		.DevSize = SIZE_256KiB,
-		.NumEraseRegions = 4,
-		.regions = {ERASEINFO(0x10000,3),
-			  ERASEINFO(0x08000,1),
-			  ERASEINFO(0x02000,2),
-			  ERASEINFO(0x04000,1)
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29F002T,
+		.name		= "AMD AM29F002T",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_256KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,3),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1),
 		}
 	}, {
 		.mfr_id		= MANUFACTURER_ATMEL,
@@ -768,15 +784,20 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
-		.mfr_id = MANUFACTURER_HYUNDAI,
-		.dev_id = HY29F002T,
-		.name = "Hyundai HY29F002T",
-		.DevSize = SIZE_256KiB,
-		.NumEraseRegions = 4,
-		.regions = {ERASEINFO(0x10000,3),
-			  ERASEINFO(0x08000,1),
-			  ERASEINFO(0x02000,2),
-			  ERASEINFO(0x04000,1)
+		.mfr_id		= MANUFACTURER_HYUNDAI,
+		.dev_id		= HY29F002T,
+		.name		= "Hyundai HY29F002T",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_256KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,3),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1),
 		}
 	}, {
 		.mfr_id		= MANUFACTURER_INTEL,
@@ -1084,6 +1105,19 @@
 		}
 	}, {
 		.mfr_id		= MANUFACTURER_MACRONIX,
+		.dev_id		= MX29LV040C,
+		.name		= "Macronix MX29LV040C",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA,  /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_MACRONIX,
 		.dev_id		= MX29LV160T,
 		.name		= "MXIC MX29LV160T",
 		.uaddr		= {
@@ -1100,6 +1134,22 @@
 			ERASEINFO(0x04000,1)
 		}
 	}, {
+		.mfr_id		= MANUFACTURER_NEC,
+		.dev_id		= UPD29F064115,
+		.name		= "NEC uPD29F064115",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_8MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 3,
+		.regions	= {
+			ERASEINFO(0x2000,8),
+			ERASEINFO(0x10000,126),
+			ERASEINFO(0x2000,8),
+		}
+	}, {
 		.mfr_id		= MANUFACTURER_MACRONIX,
 		.dev_id		= MX29LV160B,
 		.name		= "MXIC MX29LV160B",
@@ -1162,15 +1212,20 @@
 			ERASEINFO(0x10000,7),
 		}
 	}, {
-		.mfr_id = MANUFACTURER_MACRONIX,
-		.dev_id = MX29F002T,
-		.name = "Macronix MX29F002T",
-		.DevSize = SIZE_256KiB,
-		.NumEraseRegions = 4,
-		.regions = {ERASEINFO(0x10000,3),
-			  ERASEINFO(0x08000,1),
-			  ERASEINFO(0x02000,2),
-			  ERASEINFO(0x04000,1)
+		.mfr_id		= MANUFACTURER_MACRONIX,
+		.dev_id		= MX29F002T,
+		.name		= "Macronix MX29F002T",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_256KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,3),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1),
 		}
 	}, {
 		.mfr_id		= MANUFACTURER_PMC,
@@ -1379,6 +1434,22 @@
 			ERASEINFO(0x01000,256),
 		}
 	}, {
+               .mfr_id         = MANUFACTURER_SST,     /* should be CFI */
+               .dev_id         = SST39LF160,
+               .name           = "SST 39LF160",
+               .uaddr          = {
+                       [0] = MTD_UADDR_0x5555_0x2AAA,  /* x8 */
+                       [1] = MTD_UADDR_0x5555_0x2AAA   /* x16 */
+               },
+               .DevSize        = SIZE_2MiB,
+               .CmdSet         = P_ID_AMD_STD,
+               .NumEraseRegions= 2,
+               .regions        = {
+                       ERASEINFO(0x1000,256),
+                       ERASEINFO(0x1000,256)
+               }
+
+       }, {
 		.mfr_id		= MANUFACTURER_ST,	/* FIXME - CFI device? */
 		.dev_id		= M29W800DT,
 		.name		= "ST M29W800DT",
@@ -1499,6 +1570,19 @@
 			ERASEINFO(0x10000,32),
 		}
 	}, {
+		.mfr_id		= MANUFACTURER_ST,
+		.dev_id		= M50LPW080,
+		.name		= "ST M50LPW080",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_INTEL_EXT,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,16),
+		}
+	}, {
 		.mfr_id		= MANUFACTURER_TOSHIBA,
 		.dev_id		= TC58FVT160,
 		.name		= "Toshiba TC58FVT160",
@@ -1617,27 +1701,27 @@
 static int jedec_probe_chip(struct map_info *map, __u32 base,
 			    unsigned long *chip_map, struct cfi_private *cfi);
 
-struct mtd_info *jedec_probe(struct map_info *map);
+static struct mtd_info *jedec_probe(struct map_info *map);
 
 static inline u32 jedec_read_mfr(struct map_info *map, __u32 base, 
 	struct cfi_private *cfi)
 {
 	map_word result;
 	unsigned long mask;
+	u32 ofs = cfi_build_cmd_addr(0, cfi_interleave(cfi), cfi->device_type);
 	mask = (1 << (cfi->device_type * 8)) -1;
-	result = map_read(map, base);
+	result = map_read(map, base + ofs);
 	return result.x[0] & mask;
 }
 
 static inline u32 jedec_read_id(struct map_info *map, __u32 base, 
 	struct cfi_private *cfi)
 {
-	int osf;
 	map_word result;
 	unsigned long mask;
-	osf = cfi->interleave *cfi->device_type;
+	u32 ofs = cfi_build_cmd_addr(1, cfi_interleave(cfi), cfi->device_type);
 	mask = (1 << (cfi->device_type * 8)) -1;
-	result = map_read(map, base + osf);
+	result = map_read(map, base + ofs);
 	return result.x[0] & mask;
 }
 
@@ -1653,9 +1737,11 @@
 	 * as they will ignore the writes and dont care what address
 	 * the F0 is written to */
 	if(cfi->addr_unlock1) {
-		/*printk("reset unlock called %x %x \n",cfi->addr_unlock1,cfi->addr_unlock2);*/
-		cfi_send_gen_cmd(0xaa, cfi->addr_unlock1, base, map, cfi, CFI_DEVICETYPE_X8, NULL);
-		cfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi, CFI_DEVICETYPE_X8, NULL);
+		DEBUG( MTD_DEBUG_LEVEL3,
+		       "reset unlock called %x %x \n",
+		       cfi->addr_unlock1,cfi->addr_unlock2);
+		cfi_send_gen_cmd(0xaa, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);
+		cfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi, cfi->device_type, NULL);
 	}
 
 	cfi_send_gen_cmd(0xF0, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);
@@ -1700,7 +1786,6 @@
 static int cfi_jedec_setup(struct cfi_private *p_cfi, int index)
 {
 	int i,num_erase_regions;
-	unsigned long mask;
 	__u8 uaddr;
 
 	printk("Found: %s\n",jedec_table[index].name);
@@ -1735,10 +1820,8 @@
 		return 0;
 	}
 
-	/* Mask out address bits which are smaller than the device type */
-	mask = ~(p_cfi->device_type-1);
-	p_cfi->addr_unlock1 = unlock_addrs[uaddr].addr1 & mask;
-	p_cfi->addr_unlock2 = unlock_addrs[uaddr].addr2 & mask;
+	p_cfi->addr_unlock1 = unlock_addrs[uaddr].addr1;
+	p_cfi->addr_unlock2 = unlock_addrs[uaddr].addr2;
 
 	return 1; 	/* ok */
 }
@@ -1759,7 +1842,6 @@
 	int rc = 0;           /* failure until all tests pass */
 	u32 mfr, id;
 	__u8 uaddr;
-	unsigned long mask;
 
 	/*
 	 * The IDs must match.  For X16 and X32 devices operating in
@@ -1797,7 +1879,7 @@
 	DEBUG( MTD_DEBUG_LEVEL3,
 	       "MTD %s(): Check fit 0x%.8x + 0x%.8x = 0x%.8x\n",
 	       __func__, base, 1 << finfo->DevSize, base + (1 << finfo->DevSize) );
-	if ( base + cfi->interleave * ( 1 << finfo->DevSize ) > map->size ) {
+	if ( base + cfi_interleave(cfi) * ( 1 << finfo->DevSize ) > map->size ) {
 		DEBUG( MTD_DEBUG_LEVEL3,
 		       "MTD %s(): 0x%.4x 0x%.4x %dKiB doesn't fit\n",
 		       __func__, finfo->mfr_id, finfo->dev_id,
@@ -1810,18 +1892,16 @@
 		goto match_done;
 	}
 
-	mask = ~(cfi->device_type-1);
-
 	DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): check unlock addrs 0x%.4x 0x%.4x\n",
 	       __func__, cfi->addr_unlock1, cfi->addr_unlock2 );
 	if ( MTD_UADDR_UNNECESSARY != uaddr && MTD_UADDR_DONT_CARE != uaddr
-	     && ( (unlock_addrs[uaddr].addr1 & mask) != cfi->addr_unlock1 ||
-		  (unlock_addrs[uaddr].addr2 & mask) != cfi->addr_unlock2 ) ) {
+	     && ( unlock_addrs[uaddr].addr1 != cfi->addr_unlock1 ||
+		  unlock_addrs[uaddr].addr2 != cfi->addr_unlock2 ) ) {
 		DEBUG( MTD_DEBUG_LEVEL3,
-		       "MTD %s(): 0x%.4lx 0x%.4lx did not match\n",
-		       __func__,
-		       unlock_addrs[uaddr].addr1 & mask,
-		       unlock_addrs[uaddr].addr2 & mask);
+			"MTD %s(): 0x%.4x 0x%.4x did not match\n",
+			__func__,
+			unlock_addrs[uaddr].addr1,
+			unlock_addrs[uaddr].addr2);
 		goto match_done;
 	}
 
@@ -1857,10 +1937,10 @@
 	 */
 	DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): return to ID mode\n", __func__ );
 	if(cfi->addr_unlock1) {
-		cfi_send_gen_cmd(0xaa, cfi->addr_unlock1, base, map, cfi, CFI_DEVICETYPE_X8, NULL);
-		cfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi, CFI_DEVICETYPE_X8, NULL);
+		cfi_send_gen_cmd(0xaa, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);
+		cfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi, cfi->device_type, NULL);
 	}
-	cfi_send_gen_cmd(0x90, cfi->addr_unlock1, base, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0x90, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);
 	/* FIXME - should have a delay before continuing */
 
  match_done:	
@@ -1873,19 +1953,17 @@
 {
 	int i;
 	enum uaddr uaddr_idx = MTD_UADDR_NOT_SUPPORTED;
+	u32 probe_offset1, probe_offset2;
 
  retry:
 	if (!cfi->numchips) {
-		unsigned long mask = ~(cfi->device_type-1);
-
 		uaddr_idx++;
 
 		if (MTD_UADDR_UNNECESSARY == uaddr_idx)
 			return 0;
 
-		/* Mask out address bits which are smaller than the device type */
-		cfi->addr_unlock1 = unlock_addrs[uaddr_idx].addr1 & mask;
-		cfi->addr_unlock2 = unlock_addrs[uaddr_idx].addr2 & mask;
+		cfi->addr_unlock1 = unlock_addrs[uaddr_idx].addr1;
+		cfi->addr_unlock2 = unlock_addrs[uaddr_idx].addr2;
 	}
 
 	/* Make certain we aren't probing past the end of map */
@@ -1896,30 +1974,30 @@
 		return 0;
 		
 	}
-	if ((base + cfi->addr_unlock1) >= map->size) {
-		printk(KERN_NOTICE
-			"Probe at addr_unlock1(0x%08x + 0x%08x) past the end of the map(0x%08lx)\n",
-			base, cfi->addr_unlock1, map->size -1);
-
-		return 0;
+	/* Ensure the unlock addresses we try stay inside the map */
+	probe_offset1 = cfi_build_cmd_addr(
+		cfi->addr_unlock1, 
+		cfi_interleave(cfi), 
+		cfi->device_type);
+	probe_offset2 = cfi_build_cmd_addr(
+		cfi->addr_unlock1, 
+		cfi_interleave(cfi), 
+		cfi->device_type);
+	if (	((base + probe_offset1 + map_bankwidth(map)) >= map->size) ||
+		((base + probe_offset2 + map_bankwidth(map)) >= map->size))
+	{
+		goto retry;
 	}
-	if ((base + cfi->addr_unlock2) >= map->size) {
-		printk(KERN_NOTICE
-			"Probe at addr_unlock2(0x%08x + 0x%08x) past the end of the map(0x%08lx)\n",
-			base, cfi->addr_unlock2, map->size -1);
-		return 0;
 		
-	}
-
 	/* Reset */
 	jedec_reset(base, map, cfi);
 
 	/* Autoselect Mode */
 	if(cfi->addr_unlock1) {
-		cfi_send_gen_cmd(0xaa, cfi->addr_unlock1, base, map, cfi, CFI_DEVICETYPE_X8, NULL);
-		cfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi, CFI_DEVICETYPE_X8, NULL);
+		cfi_send_gen_cmd(0xaa, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);
+		cfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi, cfi->device_type, NULL);
 	}
-	cfi_send_gen_cmd(0x90, cfi->addr_unlock1, base, map, cfi, CFI_DEVICETYPE_X8, NULL);
+	cfi_send_gen_cmd(0x90, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);
 	/* FIXME - should have a delay before continuing */
 
 	if (!cfi->numchips) {
@@ -1930,7 +2008,7 @@
 		cfi->id = jedec_read_id(map, base, cfi);
 		DEBUG(MTD_DEBUG_LEVEL3,
 		      "Search for id:(%02x %02x) interleave(%d) type(%d)\n", 
-			cfi->mfr, cfi->id, cfi->interleave, cfi->device_type);
+			cfi->mfr, cfi->id, cfi_interleave(cfi), cfi->device_type);
 		for (i=0; i<sizeof(jedec_table)/sizeof(jedec_table[0]); i++) {
 			if ( jedec_match( base, map, cfi, &jedec_table[i] ) ) {
 				DEBUG( MTD_DEBUG_LEVEL3,
@@ -2004,7 +2082,7 @@
 	jedec_reset(base, map, cfi);
 
 	printk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit bank\n",
-	       map->name, cfi->interleave, cfi->device_type*8, base, 
+	       map->name, cfi_interleave(cfi), cfi->device_type*8, base, 
 	       map->bankwidth*8);
 	
 	return 1;
@@ -2015,7 +2093,7 @@
 	.probe_chip = jedec_probe_chip
 };
 
-struct mtd_info *jedec_probe(struct map_info *map)
+static struct mtd_info *jedec_probe(struct map_info *map)
 {
 	/*
 	 * Just use the generic probe stuff to call our CFI-specific
@@ -2030,7 +2108,7 @@
 	.module	= THIS_MODULE
 };
 
-int __init jedec_probe_init(void)
+static int __init jedec_probe_init(void)
 {
 	register_mtd_chip_driver(&jedec_chipdrv);
 	return 0;
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/Kconfig linuxppc-2.6.9-dream/drivers/mtd/chips/Kconfig
--- linuxppc-2.6.9/drivers/mtd/chips/Kconfig	2004-10-18 23:53:45.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/Kconfig	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 # drivers/mtd/chips/Kconfig
-# $Id: Kconfig,v 1.9 2004/07/16 15:32:14 dwmw2 Exp $
+# $Id: Kconfig,v 1.13 2004/12/01 15:49:10 nico Exp $
 
 menu "RAM/ROM/Flash chip drivers"
 	depends on MTD!=n
@@ -7,6 +7,7 @@
 config MTD_CFI
 	tristate "Detect flash chips by Common Flash Interface (CFI) probe"
 	depends on MTD
+	select MTD_GEN_PROBE
 	help
 	  The Common Flash Interface specification was developed by Intel,
 	  AMD and other flash manufactures that provides a universal method
@@ -18,6 +19,7 @@
 config MTD_JEDECPROBE
 	tristate "Detect non-CFI AMD/JEDEC-compatible flash chips"
 	depends on MTD
+	select MTD_GEN_PROBE
 	help
 	  This option enables JEDEC-style probing of flash chips which are not
 	  compatible with the Common Flash Interface, but will use the common
@@ -29,8 +31,6 @@
 
 config MTD_GEN_PROBE
 	tristate
-	default m if MTD_CFI!=y && !MTD_INTELPROBE && MTD_JEDECPROBE!=y && (MTD_CFI=m || MTD_JEDECPROBE=m)
-	default y if MTD_CFI=y || MTD_INTELPROBE || MTD_JEDECPROBE=y
 
 config MTD_CFI_ADV_OPTIONS
 	bool "Flash chip driver advanced configuration options"
@@ -158,6 +158,7 @@
 config MTD_CFI_INTELEXT
 	tristate "Support for Intel/Sharp flash chips"
 	depends on MTD_GEN_PROBE
+	select MTD_CFI_UTIL
 	help
 	  The Common Flash Interface defines a number of different command
 	  sets which a CFI-compliant chip may claim to implement. This code
@@ -167,6 +168,7 @@
 config MTD_CFI_AMDSTD
 	tristate "Support for AMD/Fujitsu flash chips"
 	depends on MTD_GEN_PROBE
+	select MTD_CFI_UTIL
 	help
 	  The Common Flash Interface defines a number of different command
 	  sets which a CFI-compliant chip may claim to implement. This code
@@ -197,6 +199,7 @@
 config MTD_CFI_STAA
 	tristate "Support for ST (Advanced Architecture) flash chips"
 	depends on MTD_GEN_PROBE
+	select MTD_CFI_UTIL
 	help
 	  The Common Flash Interface defines a number of different command
 	  sets which a CFI-compliant chip may claim to implement. This code
@@ -204,8 +207,6 @@
 
 config MTD_CFI_UTIL
 	tristate
-	default y if MTD_CFI_INTELEXT=y || MTD_CFI_AMDSTD=y || MTD_CFI_STAA=y
-	default m if MTD_CFI_INTELEXT=m || MTD_CFI_AMDSTD=m || MTD_CFI_STAA=m
 
 config MTD_RAM
 	tristate "Support for RAM chips in bus mapping"
@@ -272,5 +273,14 @@
 	  <http://www.jedec.org/> distributes the identification codes for the
 	  chips.
 
+config MTD_XIP
+	bool "XIP aware MTD support"
+	depends on !SMP && MTD_CFI_INTELEXT && EXPERIMENTAL
+	default y if XIP_KERNEL
+	help
+	  This allows MTD support to work with flash memory which is also
+	  used for XIP purposes.  If you're not sure what this is all about
+	  then say N.
+
 endmenu
 
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/map_absent.c linuxppc-2.6.9-dream/drivers/mtd/chips/map_absent.c
--- linuxppc-2.6.9/drivers/mtd/chips/map_absent.c	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/map_absent.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Common code to handle absent "placeholder" devices
  * Copyright 2001 Resilience Corporation <ebrower@resilience.com>
- * $Id: map_absent.c,v 1.4 2003/05/28 12:51:49 dwmw2 Exp $
+ * $Id: map_absent.c,v 1.5 2004/11/16 18:29:00 dwmw2 Exp $
  *
  * This map driver is used to allocate "placeholder" MTD
  * devices on systems that have socketed/removable media. 
@@ -98,7 +98,7 @@
 	/* nop */
 }
 
-int __init map_absent_init(void)
+static int __init map_absent_init(void)
 {
 	register_mtd_chip_driver(&map_absent_chipdrv);
 	return 0;
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/map_ram.c linuxppc-2.6.9-dream/drivers/mtd/chips/map_ram.c
--- linuxppc-2.6.9/drivers/mtd/chips/map_ram.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/map_ram.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Common code to handle map devices which are simple RAM
  * (C) 2000 Red Hat. GPL'd.
- * $Id: map_ram.c,v 1.20 2004/08/09 13:19:43 dwmw2 Exp $
+ * $Id: map_ram.c,v 1.22 2005/01/05 18:05:12 dwmw2 Exp $
  */
 
 #include <linux/module.h>
@@ -83,7 +83,7 @@
 
 static int mapram_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
 {
-	struct map_info *map = (struct map_info *)mtd->priv;
+	struct map_info *map = mtd->priv;
 
 	map_copy_from(map, buf, from, len);
 	*retlen = len;
@@ -92,7 +92,7 @@
 
 static int mapram_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
 {
-	struct map_info *map = (struct map_info *)mtd->priv;
+	struct map_info *map = mtd->priv;
 
 	map_copy_to(map, to, buf, len);
 	*retlen = len;
@@ -103,7 +103,7 @@
 {
 	/* Yeah, it's inefficient. Who cares? It's faster than a _real_
 	   flash erase. */
-	struct map_info *map = (struct map_info *)mtd->priv;
+	struct map_info *map = mtd->priv;
 	map_word allff;
 	unsigned long i;
 
@@ -124,7 +124,7 @@
 	/* Nothing to see here */
 }
 
-int __init map_ram_init(void)
+static int __init map_ram_init(void)
 {
 	register_mtd_chip_driver(&mapram_chipdrv);
 	return 0;
diff -Naur linuxppc-2.6.9/drivers/mtd/chips/map_rom.c linuxppc-2.6.9-dream/drivers/mtd/chips/map_rom.c
--- linuxppc-2.6.9/drivers/mtd/chips/map_rom.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/chips/map_rom.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Common code to handle map devices which are simple ROM
  * (C) 2000 Red Hat. GPL'd.
- * $Id: map_rom.c,v 1.21 2004/07/12 14:06:01 dwmw2 Exp $
+ * $Id: map_rom.c,v 1.23 2005/01/05 18:05:12 dwmw2 Exp $
  */
 
 #include <linux/module.h>
@@ -19,7 +19,7 @@
 static int maprom_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int maprom_write (struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
 static void maprom_nop (struct mtd_info *);
-struct mtd_info *map_rom_probe(struct map_info *map);
+static struct mtd_info *map_rom_probe(struct map_info *map);
 
 static struct mtd_chip_driver maprom_chipdrv = {
 	.probe	= map_rom_probe,
@@ -27,7 +27,7 @@
 	.module	= THIS_MODULE
 };
 
-struct mtd_info *map_rom_probe(struct map_info *map)
+static struct mtd_info *map_rom_probe(struct map_info *map)
 {
 	struct mtd_info *mtd;
 
@@ -57,7 +57,7 @@
 
 static int maprom_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
 {
-	struct map_info *map = (struct map_info *)mtd->priv;
+	struct map_info *map = mtd->priv;
 
 	map_copy_from(map, buf, from, len);
 	*retlen = len;
@@ -75,7 +75,7 @@
 	return -EIO;
 }
 
-int __init map_rom_init(void)
+static int __init map_rom_init(void)
 {
 	register_mtd_chip_driver(&maprom_chipdrv);
 	return 0;
diff -Naur linuxppc-2.6.9/drivers/mtd/cmdlinepart.c linuxppc-2.6.9-dream/drivers/mtd/cmdlinepart.c
--- linuxppc-2.6.9/drivers/mtd/cmdlinepart.c	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/cmdlinepart.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: cmdlinepart.c,v 1.14 2004/07/12 12:34:23 dwmw2 Exp $
+ * $Id: cmdlinepart.c,v 1.17 2004/11/26 11:18:47 lavinen Exp $
  *
  * Read flash partition table from command line
  *
@@ -338,8 +338,10 @@
  * This is the handler for our kernel parameter, called from 
  * main.c::checksetup(). Note that we can not yet kmalloc() anything,
  * so we only save the commandline for later processing.
+ *
+ * This function needs to be visible for bootloaders.
  */
-static int __init mtdpart_setup(char *s)
+int mtdpart_setup(char *s)
 {
 	cmdline = s;
 	return 1;
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/blkmtd.c linuxppc-2.6.9-dream/drivers/mtd/devices/blkmtd.c
--- linuxppc-2.6.9/drivers/mtd/devices/blkmtd.c	2004-10-18 23:53:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/blkmtd.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: blkmtd.c,v 1.23 2004/08/09 14:03:19 dwmw2 Exp $
+ * $Id: blkmtd.c,v 1.24 2004/11/16 18:29:01 dwmw2 Exp $
  *
  * blkmtd.c - use a block device as a fake MTD
  *
@@ -39,7 +39,7 @@
 
 /* Default erase size in K, always make it a multiple of PAGE_SIZE */
 #define CONFIG_MTD_BLKDEV_ERASESIZE (128 << 10)	/* 128KiB */
-#define VERSION "$Revision: 1.23 $"
+#define VERSION "$Revision: 1.24 $"
 
 /* Info for the block device */
 struct blkmtd_dev {
@@ -59,22 +59,22 @@
 #define MAX_DEVICES 4
 
 /* Module parameters passed by insmod/modprobe */
-char *device[MAX_DEVICES];    /* the block device to use */
-int erasesz[MAX_DEVICES];     /* optional default erase size */
-int ro[MAX_DEVICES];          /* optional read only flag */
-int sync;
+static char *device[MAX_DEVICES];    /* the block device to use */
+static int erasesz[MAX_DEVICES];     /* optional default erase size */
+static int ro[MAX_DEVICES];          /* optional read only flag */
+static int sync;
 
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Simon Evans <spse@secret.org.uk>");
 MODULE_DESCRIPTION("Emulate an MTD using a block device");
-MODULE_PARM(device, "1-4s");
+module_param_array(device, charp, NULL, 0);
 MODULE_PARM_DESC(device, "block device to use");
-MODULE_PARM(erasesz, "1-4i");
+module_param_array(erasesz, int, NULL, 0);
 MODULE_PARM_DESC(erasesz, "optional erase size to use in KiB. eg 4=4KiB.");
-MODULE_PARM(ro, "1-4i");
+module_param_array(ro, bool, NULL, 0);
 MODULE_PARM_DESC(ro, "1=Read only, writes and erases cause errors");
-MODULE_PARM(sync, "i");
+module_param(sync, bool, 0);
 MODULE_PARM_DESC(sync, "1=Synchronous writes");
 
 
@@ -661,7 +661,6 @@
 
 	memset(dev, 0, sizeof(struct blkmtd_dev));
 	dev->blkdev = bdev;
-	atomic_set(&(dev->blkdev->bd_inode->i_mapping->truncate_count), 0);
 	if(!readonly) {
 		init_MUTEX(&dev->wrbuf_mutex);
 	}
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/block2mtd.c linuxppc-2.6.9-dream/drivers/mtd/devices/block2mtd.c
--- linuxppc-2.6.9/drivers/mtd/devices/block2mtd.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/block2mtd.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,495 @@
+/*
+ * $Id: block2mtd.c,v 1.23 2005/01/05 17:05:46 dwmw2 Exp $
+ *
+ * block2mtd.c - create an mtd from a block device
+ *
+ * Copyright (C) 2001,2002	Simon Evans <spse@secret.org.uk>
+ * Copyright (C) 2004		Gareth Bult <Gareth@Encryptec.net>
+ * Copyright (C) 2004,2005	Jrn Engel <joern@wh.fh-wedel.de>
+ *
+ * Licence: GPL
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/blkdev.h>
+#include <linux/bio.h>
+#include <linux/pagemap.h>
+#include <linux/list.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/buffer_head.h>
+
+#define VERSION "$Revision: 1.23 $"
+
+
+#define ERROR(fmt, args...) printk(KERN_ERR "block2mtd: " fmt "\n" , ## args)
+#define INFO(fmt, args...) printk(KERN_INFO "block2mtd: " fmt "\n" , ## args)
+
+
+/* Info for the block device */
+struct block2mtd_dev {
+	struct list_head list;
+	struct block_device *blkdev;
+	struct mtd_info mtd;
+	struct semaphore write_mutex;
+};
+
+
+/* Static info about the MTD, used in cleanup_module */
+static LIST_HEAD(blkmtd_device_list);
+
+
+#define PAGE_READAHEAD 64
+void cache_readahead(struct address_space *mapping, int index)
+{
+	filler_t *filler = (filler_t*)mapping->a_ops->readpage;
+	int i, pagei;
+	unsigned ret = 0;
+	unsigned long end_index;
+	struct page *page;
+	LIST_HEAD(page_pool);
+	struct inode *inode = mapping->host;
+	loff_t isize = i_size_read(inode);
+
+	if (!isize) {
+		INFO("iSize=0 in cache_readahead\n");
+		return;
+	}
+
+	end_index = ((isize - 1) >> PAGE_CACHE_SHIFT);
+
+	spin_lock_irq(&mapping->tree_lock);
+	for (i = 0; i < PAGE_READAHEAD; i++) {
+		pagei = index + i;
+		if (pagei > end_index) {
+			INFO("Overrun end of disk in cache readahead\n");
+			break;
+		}
+		page = radix_tree_lookup(&mapping->page_tree, pagei);
+		if (page && (!i))
+			break;
+		if (page)
+			continue;
+		spin_unlock_irq(&mapping->tree_lock);
+		page = page_cache_alloc_cold(mapping);
+		spin_lock_irq(&mapping->tree_lock);
+		if (!page)
+			break;
+		page->index = pagei;
+		list_add(&page->lru, &page_pool);
+		ret++;
+	}
+	spin_unlock_irq(&mapping->tree_lock);
+	if (ret)
+		read_cache_pages(mapping, &page_pool, filler, NULL);
+}
+
+
+static struct page* page_readahead(struct address_space *mapping, int index)
+{
+	filler_t *filler = (filler_t*)mapping->a_ops->readpage;
+	//do_page_cache_readahead(mapping, index, XXX, 64);
+	cache_readahead(mapping, index);
+	return read_cache_page(mapping, index, filler, NULL);
+}
+
+
+/* erase a specified part of the device */
+static int _block2mtd_erase(struct block2mtd_dev *dev, loff_t to, size_t len)
+{
+	struct address_space *mapping = dev->blkdev->bd_inode->i_mapping;
+	struct page *page;
+	int index = to >> PAGE_SHIFT;	// page index
+	int pages = len >> PAGE_SHIFT;
+	u_long *p;
+	u_long *max;
+
+	while (pages) {
+		page = page_readahead(mapping, index);
+		if (!page)
+			return -ENOMEM;
+		if (IS_ERR(page))
+			return PTR_ERR(page);
+
+		max = (u_long*)page_address(page) + PAGE_SIZE;
+		for (p=(u_long*)page_address(page); p<max; p++) 
+			if (*p != -1UL) {
+				lock_page(page);
+				memset(page_address(page), 0xff, PAGE_SIZE);
+				set_page_dirty(page);
+				unlock_page(page);
+				break;
+			}
+
+		page_cache_release(page);
+		pages--;
+		index++;
+	}
+	return 0;
+}
+static int block2mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct block2mtd_dev *dev = mtd->priv;
+	size_t from = instr->addr;
+	size_t len = instr->len;
+	int err;
+
+	instr->state = MTD_ERASING;
+	down(&dev->write_mutex);
+	err = _block2mtd_erase(dev, from, len);
+	up(&dev->write_mutex);
+	if (err) {
+		ERROR("erase failed err = %d", err);
+		instr->state = MTD_ERASE_FAILED;
+	} else
+		instr->state = MTD_ERASE_DONE;
+
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+	return err;
+}
+
+
+static int block2mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	struct block2mtd_dev *dev = mtd->priv;
+	struct page *page;
+	int index = from >> PAGE_SHIFT;
+	int offset = from & (PAGE_SHIFT-1);
+	int cpylen;
+
+	if (from > mtd->size)
+		return -EINVAL;
+	if (from + len > mtd->size)
+		len = mtd->size - from;
+
+	if (retlen)
+		*retlen = 0;
+
+	while (len) {
+		if ((offset + len) > PAGE_SIZE)
+			cpylen = PAGE_SIZE - offset;	// multiple pages
+		else
+			cpylen = len;	// this page
+		len = len - cpylen;
+
+		//      Get page
+		page = page_readahead(dev->blkdev->bd_inode->i_mapping, index);
+		if (!page)
+			return -ENOMEM;
+		if (IS_ERR(page))
+			return PTR_ERR(page);
+
+		memcpy(buf, page_address(page) + offset, cpylen);
+		page_cache_release(page);
+
+		if (retlen)
+			*retlen += cpylen;
+		buf += cpylen;
+		offset = 0;
+		index++;
+	}
+	return 0;
+}
+
+
+/* write data to the underlying device */
+static int _block2mtd_write(struct block2mtd_dev *dev, const u_char *buf,
+		loff_t to, size_t len, size_t *retlen)
+{
+	struct page *page;
+	struct address_space *mapping = dev->blkdev->bd_inode->i_mapping;
+	int index = to >> PAGE_SHIFT;	// page index
+	int offset = to & ~PAGE_MASK;	// page offset
+	int cpylen;
+
+	if (retlen)
+		*retlen = 0;
+	while (len) {
+		if ((offset+len) > PAGE_SIZE) 
+			cpylen = PAGE_SIZE - offset;	// multiple pages
+		else
+			cpylen = len;			// this page
+		len = len - cpylen;
+
+		//	Get page
+		page = page_readahead(mapping, index);
+		if (!page)
+			return -ENOMEM;
+		if (IS_ERR(page))
+			return PTR_ERR(page);
+
+		if (memcmp(page_address(page)+offset, buf, cpylen)) {
+			lock_page(page);
+			memcpy(page_address(page) + offset, buf, cpylen);
+			set_page_dirty(page);
+			unlock_page(page);
+		}
+		page_cache_release(page);
+
+		if (retlen)
+			*retlen += cpylen;
+
+		buf += cpylen;
+		offset = 0;
+		index++;
+	}
+	return 0;
+}
+static int block2mtd_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	struct block2mtd_dev *dev = mtd->priv;
+	int err;
+
+	if (!len)
+		return 0;
+	if (to >= mtd->size)
+		return -ENOSPC;
+	if (to + len > mtd->size)
+		len = mtd->size - to;
+
+	down(&dev->write_mutex);
+	err = _block2mtd_write(dev, buf, to, len, retlen);
+	up(&dev->write_mutex);
+	if (err > 0)
+		err = 0;
+	return err;
+}
+
+
+/* sync the device - wait until the write queue is empty */
+static void block2mtd_sync(struct mtd_info *mtd)
+{
+	struct block2mtd_dev *dev = mtd->priv;
+	sync_blockdev(dev->blkdev);
+	return;
+}
+
+
+static void block2mtd_free_device(struct block2mtd_dev *dev)
+{
+	if (!dev)
+		return;
+
+	kfree(dev->mtd.name);
+
+	if (dev->blkdev) {
+		invalidate_inode_pages(dev->blkdev->bd_inode->i_mapping);
+		close_bdev_excl(dev->blkdev);
+	}
+
+	kfree(dev);
+}
+
+
+/* FIXME: ensure that mtd->size % erase_size == 0 */
+static struct block2mtd_dev *add_device(char *devname, int erase_size)
+{
+	struct block_device *bdev;
+	struct block2mtd_dev *dev;
+
+	if (!devname)
+		return NULL;
+
+	dev = kmalloc(sizeof(struct block2mtd_dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+	memset(dev, 0, sizeof(*dev));
+
+	/* Get a handle on the device */
+	bdev = open_bdev_excl(devname, O_RDWR, NULL);
+	if (IS_ERR(bdev)) {
+		ERROR("error: cannot open device %s", devname);
+		goto devinit_err;
+	}
+	dev->blkdev = bdev;
+
+	if (MAJOR(bdev->bd_dev) == MTD_BLOCK_MAJOR) {
+		ERROR("attempting to use an MTD device as a block device");
+		goto devinit_err;
+	}
+
+	init_MUTEX(&dev->write_mutex);
+
+	/* Setup the MTD structure */
+	/* make the name contain the block device in */
+	dev->mtd.name = kmalloc(sizeof("block2mtd: ") + strlen(devname),
+			GFP_KERNEL);
+	if (!dev->mtd.name)
+		goto devinit_err;
+
+	sprintf(dev->mtd.name, "block2mtd: %s", devname);
+
+	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;
+	dev->mtd.erasesize = erase_size;
+	dev->mtd.type = MTD_RAM;
+	dev->mtd.flags = MTD_CAP_RAM;
+	dev->mtd.erase = block2mtd_erase;
+	dev->mtd.write = block2mtd_write;
+	dev->mtd.writev = default_mtd_writev;
+	dev->mtd.sync = block2mtd_sync;
+	dev->mtd.read = block2mtd_read;
+	dev->mtd.readv = default_mtd_readv;
+	dev->mtd.priv = dev;
+	dev->mtd.owner = THIS_MODULE;
+
+	if (add_mtd_device(&dev->mtd)) {
+		/* Device didnt get added, so free the entry */
+		goto devinit_err;
+	}
+	list_add(&dev->list, &blkmtd_device_list);
+	INFO("mtd%d: [%s] erase_size = %dKiB [%d]", dev->mtd.index,
+			dev->mtd.name + strlen("blkmtd: "),
+			dev->mtd.erasesize >> 10, dev->mtd.erasesize);
+	return dev;
+
+devinit_err:
+	block2mtd_free_device(dev);
+	return NULL;
+}
+
+
+static int ustrtoul(const char *cp, char **endp, unsigned int base)
+{
+	unsigned long result = simple_strtoul(cp, endp, base);
+	switch (**endp) {
+	case 'G' :
+		result *= 1024;
+	case 'M':
+		result *= 1024;
+	case 'k':
+		result *= 1024;
+	/* By dwmw2 editorial decree, "ki", "Mi" or "Gi" are to be used. */
+		if ((*endp)[1] == 'i')
+			(*endp) += 2;
+	}
+	return result;
+}
+
+
+static int parse_num32(u32 *num32, const char *token)
+{
+	char *endp;
+	unsigned long n;
+
+	n = ustrtoul(token, &endp, 0);
+	if (*endp)
+		return -EINVAL;
+
+	*num32 = n;
+	return 0;
+}
+
+
+static int parse_name(char **pname, const char *token, size_t limit)
+{
+	size_t len;
+	char *name;
+
+	len = strlen(token) + 1;
+	if (len > limit)
+		return -ENOSPC;
+
+	name = kmalloc(len, GFP_KERNEL);
+	if (!name)
+		return -ENOMEM;
+
+	strcpy(name, token);
+
+	*pname = name;
+	return 0;
+}
+
+
+static inline void kill_final_newline(char *str)
+{
+	char *newline = strrchr(str, '\n');
+	if (newline && !newline[1])
+		*newline = 0;
+}
+
+
+#define parse_err(fmt, args...) do {		\
+	ERROR("block2mtd: " fmt "\n", ## args);	\
+	return 0;				\
+} while (0)
+
+static int block2mtd_setup(const char *val, struct kernel_param *kp)
+{
+	char buf[80+12], *str=buf; /* 80 for device, 12 for erase size */
+	char *token[2];
+	char *name;
+	u32 erase_size = PAGE_SIZE;
+	int i, ret;
+
+	if (strnlen(val, sizeof(buf)) >= sizeof(buf))
+		parse_err("parameter too long");
+
+	strcpy(str, val);
+	kill_final_newline(str);
+
+	for (i=0; i<2; i++)
+		token[i] = strsep(&str, ",");
+
+	if (str)
+		parse_err("too many arguments");
+
+	if (!token[0])
+		parse_err("no argument");
+
+	ret = parse_name(&name, token[0], 80);
+	if (ret == -ENOMEM)
+		parse_err("out of memory");
+	if (ret == -ENOSPC)
+		parse_err("name too long");
+	if (ret)
+		return 0;
+
+	if (token[1]) {
+		ret = parse_num32(&erase_size, token[1]);
+		if (ret)
+			parse_err("illegal erase size");
+	}
+
+	add_device(name, erase_size);
+
+	return 0;
+}
+
+
+module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
+MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>]\"");
+
+static int __init block2mtd_init(void)
+{
+	INFO("version " VERSION);
+	return 0;
+}
+
+
+static void __devexit block2mtd_exit(void)
+{
+	struct list_head *pos, *next;
+
+	/* Remove the MTD devices */
+	list_for_each_safe(pos, next, &blkmtd_device_list) {
+		struct block2mtd_dev *dev = list_entry(pos, typeof(*dev), list);
+		block2mtd_sync(&dev->mtd);
+		del_mtd_device(&dev->mtd);
+		INFO("mtd%d: [%s] removed", dev->mtd.index,
+				dev->mtd.name + strlen("blkmtd: "));
+		list_del(&dev->list);
+		block2mtd_free_device(dev);
+	}
+}
+
+
+module_init(block2mtd_init);
+module_exit(block2mtd_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Simon Evans <spse@secret.org.uk> and others");
+MODULE_DESCRIPTION("Emulate an MTD using a block device");
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/doc1000.c linuxppc-2.6.9-dream/drivers/mtd/devices/doc1000.c
--- linuxppc-2.6.9/drivers/mtd/devices/doc1000.c	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/doc1000.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,594 +0,0 @@
-/*======================================================================
-
-  $Id: doc1000.c,v 1.15 2001/10/02 15:05:13 dwmw2 Exp $
-
-======================================================================*/
-
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <asm/uaccess.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/ptrace.h>
-#include <linux/slab.h>
-#include <linux/string.h>
-#include <linux/timer.h>
-#include <linux/major.h>
-#include <linux/fs.h>
-#include <linux/ioctl.h>
-#include <asm/io.h>
-#include <asm/system.h>
-#include <stdarg.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/iflash.h>
-
-/* Parameters that can be set with 'insmod' */
-
-static u_long base              = 0xe0000;
-static int erase_timeout	= 10*HZ;	/* in ticks */
-static int retry_limit		= 4;		/* write retries */
-static u_long max_tries       	= 4096;		/* status polling */
-
-MODULE_PARM(base,"l");
-MODULE_PARM(erase_timeout, "i");
-MODULE_PARM(retry_limit, "i");
-MODULE_PARM(max_tries, "i");
-
-#define WINDOW_SIZE 0x2000
-#define WINDOW_MASK (WINDOW_SIZE - 1)
-#define PAGEREG_LO (WINDOW_SIZE)
-#define PAGEREG_HI (WINDOW_SIZE + 2)
-
-static struct mtd_info *mymtd;
-static struct timer_list flashcard_timer;
-
-#define MAX_CELLS		32
-#define MAX_FLASH_DEVICES       8
-
-/* A flash region is composed of one or more "cells", where we allow
-   simultaneous erases if they are in different cells */
-
-
-
-struct mypriv {
-	u_char *baseaddr;
-	u_short curpage;
-	u_char locked;
-	u_short numdevices;
-	u_char interleave;
-	struct erase_info *cur_erases;
-	wait_queue_head_t wq;
-	u_char devstat[MAX_FLASH_DEVICES];
-	u_long devshift;
-};
-
-
-static void flashcard_periodic(u_long data);
-static int flashcard_erase (struct mtd_info *mtd, struct erase_info *instr);
-static int flashcard_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
-static int flashcard_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
-static void flashcard_sync (struct mtd_info *mtd);
-
-static inline void resume_erase(volatile u_char *addr);
-static inline int suspend_erase(volatile u_char *addr);
-static inline int byte_write (volatile u_char *addr, u_char byte);
-static inline int word_write (volatile u_char *addr, __u16 word);
-static inline int check_write(volatile u_char *addr);
-static inline void block_erase (volatile u_char *addr);
-static inline int check_erase(volatile u_char *addr);
-
-#ifdef CONFIG_SMP
-#warning This is definitely not SMP safe. Lock the paging mechanism.
-#endif
-
-static u_char *pagein(struct mtd_info *mtd, u_long addr)
-{
-  struct mypriv *priv=mtd->priv;
-  u_short page = addr >> 13;
-
-  priv->baseaddr[PAGEREG_LO] = page & 0xff;
-  priv->baseaddr[PAGEREG_HI] = page >> 8;
-  priv->curpage = page;
-  
-  return &priv->baseaddr[addr & WINDOW_MASK];
-}
-
-
-void flashcard_sync (struct mtd_info *mtd)
-{
-	struct mypriv *priv=mtd->priv;
-
-	flashcard_periodic((u_long) mtd);
-	printk("sync...");
-	if (priv->cur_erases)
-		interruptible_sleep_on(&priv->wq);
-	printk("Done.\n");
-}
-
-int flashcard_erase (struct mtd_info *mtd, struct erase_info *instr)
-{
-	u_char *pageaddr;
-	struct mypriv *priv=mtd->priv;
-	struct erase_info **tmp=&priv->cur_erases;
-	
-	if (instr->len != mtd->erasesize)
-		return -EINVAL;
-	if (instr->addr + instr->len > mtd->size)
-		return -EINVAL;
-
-	pageaddr=pagein(mtd,instr->addr);
-	instr->mtd = mtd;
-	instr->dev = instr->addr >> priv->devshift;
-	instr->cell = (instr->addr - (instr->dev << priv->devshift)) / mtd->erasesize;
-	instr->next = NULL;
-	instr->state = MTD_ERASE_PENDING;
-	
-	while (*tmp)
-	{
-		tmp = &((*tmp) -> next);
-	}
-	
-	*tmp = instr;
-	flashcard_periodic((u_long)mtd);
-	return 0;
-}
-
-
-int flashcard_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
-{
- 	u_char *pageaddr=pagein(mtd,from);
-	struct mypriv *priv=mtd->priv;
-	u_char device = from >> priv->devshift;
-	u_char cell = (int) (from - (device << priv->devshift)) / mtd->erasesize;
-	int ret = 0, timeron = 0;
-
-	if ((from & WINDOW_MASK) + len <= WINDOW_SIZE)
-		*retlen = len;
-	else
-		*retlen = WINDOW_SIZE - (from & WINDOW_MASK);
-
-	if (priv->devstat[device])
-	{
-		
-		/* There is an erase in progress or pending for this device. Stop it */
-		timeron = del_timer(&flashcard_timer);
-		
-		if (priv->cur_erases && priv->cur_erases->cell == cell) 
-			
-		{
-			/* The erase is on the current cell. Just return all 0xff */ 
-			add_timer(&flashcard_timer);
-			
-			
-			printk("Cell %d currently erasing. Setting to all 0xff\n",cell);
-			memset(buf, 0xff, *retlen);
-			return 0;
-		}
-		if (priv->devstat[device] == MTD_ERASING)
-		{
-			ret = suspend_erase(pageaddr);
-			priv->devstat[device] = MTD_ERASE_SUSPEND;
-		       
-			if (ret) 
-			{
-				printk("flashcard: failed to suspend erase\n");
-				add_timer (&flashcard_timer);
-				return ret;
-			}
-		}
-
-	}
-
-	writew(IF_READ_ARRAY, (u_long)pageaddr & ~1);
-	
-	ret = 0;
-	memcpy (buf, pageaddr, *retlen);
-	
-	writew(IF_READ_CSR, (u_long)pageaddr & ~1);
-	
-	
-	if (priv->devstat[device] & MTD_ERASE_SUSPEND)
-	{
-		resume_erase(pageaddr);
-		priv->devstat[device]=MTD_ERASING;
-	}
-
-
-	if (timeron) add_timer (&flashcard_timer);
-		
-	return ret;
-}
-
-
-int flashcard_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
-{
-	struct mypriv *priv = (struct mypriv *)mtd->priv;
- 	u_char *endaddr, *startaddr;
-	register u_char *pageaddr;
-	u_char device = to >> priv->devshift;
-/*	jiffies_t oldj=jiffies;*/
-	int ret;
-
-	while (priv->devstat[device])
-	{
-		flashcard_sync(mtd);
-	}
-
-	if ((to & WINDOW_MASK) + len <= WINDOW_SIZE)
-		*retlen = len;
-	else
-		*retlen = WINDOW_SIZE - (to & WINDOW_MASK);
-	
-	pageaddr = pagein(mtd, to);
-	startaddr = (u_char *)((u_long) pageaddr & ~1);
-	endaddr = pageaddr+(*retlen);
-
-
-
-	/* Set up to read */
-	writew(IF_READ_CSR, startaddr);
-	
-	/* Make sure it's aligned by reading the first byte if necessary */
-	if (to & 1)
-	{
-		/* Unaligned access */
-
-		u_char cbuf;
-
-		cbuf = *buf;
-
-		if (!((u_long)pageaddr & 0xf))
-			schedule();
-			
-		ret = byte_write(pageaddr, cbuf);
-		if (ret) return ret;
-
-		pageaddr++; buf++;
-	}
-
-
-	for ( ; pageaddr + 1 < endaddr; buf += 2, pageaddr += 2)
-		{
-			/* if ((u_long)pageaddr & 0xf) schedule();*/
-			
-			ret = word_write(pageaddr, *(__u16 *)buf);
-			if (ret) 
-				return ret;
-		}
-	
-	if (pageaddr != endaddr)
-	{
-		/* One more byte to write at the end. */
-		u_char cbuf;
-
-		cbuf = *buf;
-
-		ret = byte_write(pageaddr, cbuf);
-
-		if (ret) return ret;
-	}
-
-	return check_write(startaddr);
-/*	printk("Time taken in flashcard_write: %lx jiffies\n",jiffies - oldj);*/
-}
-
-
-
-
-/*====================================================================*/
-
-static inline int byte_write (volatile u_char *addr, u_char byte)
-{
-	register u_char status;
-	register u_short i = 0;
-
-	do {
-		status = readb(addr);
-		if (status & CSR_WR_READY)
-		{
-			writeb(IF_WRITE & 0xff, addr);
-			writeb(byte, addr);
-			return 0;
-		}
-		i++;
-	} while(i < max_tries);
-
-		
-	printk(KERN_NOTICE "flashcard: byte_write timed out, status 0x%x\n",status);
-	return -EIO;
-}
-
-static inline int word_write (volatile u_char *addr, __u16 word)
-{
-	register u_short status;
-	register u_short i = 0;
-	
-	do {
-		status = readw(addr);
-		if ((status & CSR_WR_READY) == CSR_WR_READY)
-		{
-			writew(IF_WRITE, addr);
-			writew(word, addr);
-			return 0;
-		}
-		i++;
-	} while(i < max_tries);
-		
-	printk(KERN_NOTICE "flashcard: word_write timed out at %p, status 0x%x\n", addr, status);
-	return -EIO;
-}
-
-static inline void block_erase (volatile u_char *addr)
-{
-	writew(IF_BLOCK_ERASE, addr);
-	writew(IF_CONFIRM, addr);
-}
-
-
-static inline int check_erase(volatile u_char *addr)
-{
-	__u16 status;
-	
-/*	writew(IF_READ_CSR, addr);*/
-	status = readw(addr);
-	
-
-	if ((status & CSR_WR_READY) != CSR_WR_READY)
-		return -EBUSY;
-	
-	if (status & (CSR_ERA_ERR | CSR_VPP_LOW | CSR_WR_ERR)) 
-	{
-		printk(KERN_NOTICE "flashcard: erase failed, status 0x%x\n",
-		       status);
-		return -EIO;
-	}
-	
-	return 0;
-}
-
-static inline int suspend_erase(volatile u_char *addr)
-{
-	__u16 status;
-	u_long i = 0;
-	
-	writew(IF_ERASE_SUSPEND, addr);
-	writew(IF_READ_CSR, addr);
-	
-	do {
-		status = readw(addr);
-		if ((status & CSR_WR_READY) == CSR_WR_READY)
-			return 0;
-		i++;
-	} while(i < max_tries);
-
-	printk(KERN_NOTICE "flashcard: suspend_erase timed out, status 0x%x\n", status);
-	return -EIO;
-
-}
-
-static inline void resume_erase(volatile u_char *addr)
-{
-	__u16 status;
-	
-	writew(IF_READ_CSR, addr);
-	status = readw(addr);
-	
-	/* Only give resume signal if the erase is really suspended */
-	if (status & CSR_ERA_SUSPEND)
-		writew(IF_CONFIRM, addr);
-}
-
-static inline void reset_block(volatile u_char *addr)
-{
-	u_short i;
-	__u16 status;
-
-	writew(IF_CLEAR_CSR, addr);
-
-	for (i = 0; i < 100; i++) {
-		writew(IF_READ_CSR, addr);
-		status = readw(addr);
-		if (status != 0xffff) break;
-		udelay(1000);
-	}
-
-	writew(IF_READ_CSR, addr);
-}
-
-static inline int check_write(volatile u_char *addr)
-{
-	u_short status, i = 0;
-	
-	writew(IF_READ_CSR, addr);
-	
-	do {
-		status = readw(addr);
-		if (status & (CSR_WR_ERR | CSR_VPP_LOW))
-		{
-			printk(KERN_NOTICE "flashcard: write failure at %p, status 0x%x\n", addr, status);
-			reset_block(addr);
-			return -EIO;
-		}
-		if ((status & CSR_WR_READY) == CSR_WR_READY)
-			return 0;
-		i++;
-	} while (i < max_tries);
-
-	printk(KERN_NOTICE "flashcard: write timed out at %p, status 0x%x\n", addr, status);
-	return -EIO;
-}
-
-
-/*====================================================================*/
-
-
-
-static void flashcard_periodic(unsigned long data)
-{
-	register struct mtd_info *mtd = (struct mtd_info *)data;
-	register struct mypriv *priv = mtd->priv;
-	struct erase_info *erase = priv->cur_erases;
-	u_char *pageaddr;
-
-	del_timer (&flashcard_timer);
-
-	if (!erase)
-		return;
-
-	pageaddr = pagein(mtd, erase->addr);
-	
-	if (erase->state == MTD_ERASE_PENDING)
-	{
-		block_erase(pageaddr);
-		priv->devstat[erase->dev] = erase->state = MTD_ERASING;
-		erase->time = jiffies;
-		erase->retries = 0;
-	}
-	else if (erase->state == MTD_ERASING)
-	{
-		/* It's trying to erase. Check whether it's finished */
-
-		int ret = check_erase(pageaddr);
-
-		if (!ret)
-		{
-			/* It's finished OK */
-			priv->devstat[erase->dev] = 0;
-			priv->cur_erases = erase->next;
-			erase->state = MTD_ERASE_DONE;
-			if (erase->callback)
-				(*(erase->callback))(erase);
-			else
-				kfree(erase);
-		}
-		else if (ret == -EIO)
-		{
-			if (++erase->retries > retry_limit)
-			{
-				printk("Failed too many times. Giving up\n");
-				priv->cur_erases = erase->next;
-				priv->devstat[erase->dev] = 0;
-				erase->state = MTD_ERASE_FAILED;
-				if (erase->callback)
-					(*(erase->callback))(erase);
-				else
-					kfree(erase);
-			}
-			else
-				priv->devstat[erase->dev] = erase->state = MTD_ERASE_PENDING;
-		}
-		else if (erase->time + erase_timeout < jiffies)
-		{
-			printk("Flash erase timed out. The world is broken.\n");
-
-			/* Just ignore and hope it goes away. For a while, read ops will give the CSR
-			   and writes won't work. */
-
-			priv->cur_erases = erase->next;
-			priv->devstat[erase->dev] = 0;
-			erase->state = MTD_ERASE_FAILED;
-			if (erase->callback)
-					(*(erase->callback))(erase);
-				else
-					kfree(erase);
-		}
-	}
-
-	if (priv->cur_erases)
-	{
-		flashcard_timer.expires = jiffies + HZ;
-		add_timer (&flashcard_timer);
-	}
-	else 
-		wake_up_interruptible(&priv->wq);
-
-}
-
-int __init init_doc1000(void)
-{
-	struct mypriv *priv;
-
-	if (!base)
-	{
-		printk(KERN_NOTICE "flashcard: No start address for memory device.\n");
-		return -EINVAL;
-	}
-
-	mymtd  = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
-
-	if (!mymtd)
-	{
-		printk(KERN_NOTICE "physmem: Cannot allocate memory for new MTD device.\n");
-		return -ENOMEM;
-	}
-
-	memset(mymtd,0,sizeof(struct mtd_info));
-
-	mymtd->priv = (void *) kmalloc (sizeof(struct mypriv), GFP_KERNEL);
-	if (!mymtd->priv)
-	  {
-	    kfree(mymtd);
-	    printk(KERN_NOTICE "physmem: Cannot allocate memory for new MTD device's private data.\n");
-	    return -ENOMEM;
-	  }
-	
-
-
-
-	priv=mymtd->priv;
-	init_waitqueue_head(&priv->wq);
-
-	memset (priv,0,sizeof(struct mypriv));
-
-	priv->baseaddr = phys_to_virt(base);
-	priv->numdevices = 4;
-	
-	mymtd->name = "M-Systems DiskOnChip 1000";
-
-	mymtd->size = 0x100000;
-	mymtd->flags = MTD_CLEAR_BITS | MTD_ERASEABLE;
-        mymtd->erase = flashcard_erase;
-	mymtd->point = NULL;
-	mymtd->unpoint = NULL;
-	mymtd->read = flashcard_read;
-	mymtd->write = flashcard_write;
-
-	mymtd->sync = flashcard_sync;
-	mymtd->erasesize = 0x10000;
-	//	mymtd->interleave = 2;
-	priv->devshift =  24;
-	mymtd->type = MTD_NORFLASH;
-	
-	if (add_mtd_device(mymtd))
-	{
-		printk(KERN_NOTICE "MTD device registration failed!\n");
-		kfree(mymtd->priv);
-		kfree(mymtd);
-		return -EAGAIN;
-	}
-	
-	init_timer(&flashcard_timer);
-	flashcard_timer.function = flashcard_periodic;
-	flashcard_timer.data = (u_long)mymtd;
-	return 0;
-}
-
-static void __init cleanup_doc1000(void)
-{
-	kfree (mymtd->priv);
-	del_mtd_device(mymtd);
-	kfree(mymtd);
-}
-
-module_init(init_doc1000);
-module_exit(cleanup_doc1000);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
-MODULE_DESCRIPTION("MTD driver for DiskOnChip 1000");
-
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/doc2000.c linuxppc-2.6.9-dream/drivers/mtd/devices/doc2000.c
--- linuxppc-2.6.9/drivers/mtd/devices/doc2000.c	2004-10-18 23:53:05.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/doc2000.c	2005-06-20 10:46:11.000000000 +0200
@@ -4,7 +4,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2000.c,v 1.62 2004/08/09 14:04:02 dwmw2 Exp $
+ * $Id: doc2000.c,v 1.66 2005/01/05 18:05:12 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
@@ -89,7 +89,7 @@
 /* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */
 static int _DoC_WaitReady(struct DiskOnChip *doc)
 {
-	unsigned long docptr = doc->virtadr;
+	void __iomem *docptr = doc->virtadr;
 	unsigned long timeo = jiffies + (HZ * 10);
 
 	DEBUG(MTD_DEBUG_LEVEL3,
@@ -114,7 +114,8 @@
 
 static inline int DoC_WaitReady(struct DiskOnChip *doc)
 {
-	unsigned long docptr = doc->virtadr;
+	void __iomem *docptr = doc->virtadr;
+
 	/* This is inline, to optimise the common case, where it's ready instantly */
 	int ret = 0;
 
@@ -140,7 +141,7 @@
 static inline int DoC_Command(struct DiskOnChip *doc, unsigned char command,
 			      unsigned char xtraflags)
 {
-	unsigned long docptr = doc->virtadr;
+	void __iomem *docptr = doc->virtadr;
 
 	if (DoC_is_2000(doc))
 		xtraflags |= CDSN_CTRL_FLASH_IO;
@@ -172,10 +173,8 @@
 static int DoC_Address(struct DiskOnChip *doc, int numbytes, unsigned long ofs,
 		       unsigned char xtraflags1, unsigned char xtraflags2)
 {
-	unsigned long docptr;
 	int i;
-
-	docptr = doc->virtadr;
+	void __iomem *docptr = doc->virtadr;
 
 	if (DoC_is_2000(doc))
 		xtraflags1 |= CDSN_CTRL_FLASH_IO;
@@ -240,11 +239,9 @@
 {
 	volatile int dummy;
 	int modulus = 0xffff;
-	unsigned long docptr;
+	void __iomem *docptr = doc->virtadr;
 	int i;
 
-	docptr = doc->virtadr;
-
 	if (len <= 0)
 		return;
 
@@ -271,11 +268,9 @@
 /* Write a buffer to DoC, taking care of Millennium odditys */
 static void DoC_WriteBuf(struct DiskOnChip *doc, const u_char * buf, int len)
 {
-	unsigned long docptr;
+	void __iomem *docptr = doc->virtadr;
 	int i;
 
-	docptr = doc->virtadr;
-
 	if (len <= 0)
 		return;
 
@@ -292,7 +287,7 @@
 
 static inline int DoC_SelectChip(struct DiskOnChip *doc, int chip)
 {
-	unsigned long docptr = doc->virtadr;
+	void __iomem *docptr = doc->virtadr;
 
 	/* Software requirement 11.4.4 before writing DeviceSelect */
 	/* Deassert the CE line to eliminate glitches on the FCE# outputs */
@@ -316,7 +311,7 @@
 
 static inline int DoC_SelectFloor(struct DiskOnChip *doc, int floor)
 {
-	unsigned long docptr = doc->virtadr;
+	void __iomem *docptr = doc->virtadr;
 
 	/* Select the floor (bank) of chips required */
 	WriteDOC(floor, docptr, FloorSelect);
@@ -532,26 +527,26 @@
  */
 static void DoC2k_init(struct mtd_info *mtd)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	struct DiskOnChip *old = NULL;
 	int maxchips;
 
 	/* We must avoid being called twice for the same device. */
 
 	if (doc2klist)
-		old = (struct DiskOnChip *) doc2klist->priv;
+		old = doc2klist->priv;
 
 	while (old) {
 		if (DoC2k_is_alias(old, this)) {
 			printk(KERN_NOTICE
 			       "Ignoring DiskOnChip 2000 at 0x%lX - already configured\n",
 			       this->physadr);
-			iounmap((void *) this->virtadr);
+			iounmap(this->virtadr);
 			kfree(mtd);
 			return;
 		}
 		if (old->nextdoc)
-			old = (struct DiskOnChip *) old->nextdoc->priv;
+			old = old->nextdoc->priv;
 		else
 			old = NULL;
 	}
@@ -578,7 +573,7 @@
 	default:
 		printk("Unknown ChipID 0x%02x\n", this->ChipID);
 		kfree(mtd);
-		iounmap((void *) this->virtadr);
+		iounmap(this->virtadr);
 		return;
 	}
 
@@ -617,7 +612,7 @@
 
 	if (!this->totlen) {
 		kfree(mtd);
-		iounmap((void *) this->virtadr);
+		iounmap(this->virtadr);
 	} else {
 		this->nextdoc = doc2klist;
 		doc2klist = mtd;
@@ -638,16 +633,14 @@
 static int doc_read_ecc(struct mtd_info *mtd, loff_t from, size_t len,
 			size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
-	unsigned long docptr;
+	struct DiskOnChip *this = mtd->priv;
+	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip;
 	unsigned char syndrome[6];
 	volatile char dummy;
 	int i, len256 = 0, ret=0;
 	size_t left = len;
 
-	docptr = this->virtadr;
-
 	/* Don't allow read past end of device */
 	if (from >= this->totlen)
 		return -EINVAL;
@@ -797,17 +790,15 @@
 			 size_t * retlen, const u_char * buf,
 			 u_char * eccbuf, struct nand_oobinfo *oobsel)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	int di; /* Yes, DI is a hangover from when I was disassembling the binary driver */
-	unsigned long docptr;
+	void __iomem *docptr = this->virtadr;
 	volatile char dummy;
 	int len256 = 0;
 	struct Nand *mychip;
 	size_t left = len;
 	int status;
 
-	docptr = this->virtadr;
-
 	/* Don't allow write past end of device */
 	if (to >= this->totlen)
 		return -EINVAL;
@@ -1042,15 +1033,12 @@
 static int doc_read_oob(struct mtd_info *mtd, loff_t ofs, size_t len,
 			size_t * retlen, u_char * buf)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	int len256 = 0, ret;
-	unsigned long docptr;
 	struct Nand *mychip;
 
 	down(&this->lock);
 
-	docptr = this->virtadr;
-
 	mychip = &this->chips[ofs >> this->chipshift];
 
 	if (this->curfloor != mychip->floor) {
@@ -1103,9 +1091,9 @@
 static int doc_write_oob_nolock(struct mtd_info *mtd, loff_t ofs, size_t len,
 				size_t * retlen, const u_char * buf)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	int len256 = 0;
-	unsigned long docptr = this->virtadr;
+	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 	volatile int dummy;
 	int status;
@@ -1206,7 +1194,7 @@
 static int doc_write_oob(struct mtd_info *mtd, loff_t ofs, size_t len,
  			 size_t * retlen, const u_char * buf)
 {
- 	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+ 	struct DiskOnChip *this = mtd->priv;
  	int ret;
 
  	down(&this->lock);
@@ -1218,11 +1206,11 @@
 
 static int doc_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	__u32 ofs = instr->addr;
 	__u32 len = instr->len;
 	volatile int dummy;
-	unsigned long docptr;
+	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip;
 	int status;
 
@@ -1235,8 +1223,6 @@
 
 	instr->state = MTD_ERASING;
 		
-	docptr = this->virtadr;
-
 	/* FIXME: Do this in the background. Use timers or schedule_task() */
 	while(len) {
 		mychip = &this->chips[ofs >> this->chipshift];
@@ -1290,7 +1276,7 @@
  *
  ****************************************************************************/
 
-int __init init_doc2000(void)
+static int __init init_doc2000(void)
 {
        inter_module_register(im_name, THIS_MODULE, &DoC2k_init);
        return 0;
@@ -1302,12 +1288,12 @@
 	struct DiskOnChip *this;
 
 	while ((mtd = doc2klist)) {
-		this = (struct DiskOnChip *) mtd->priv;
+		this = mtd->priv;
 		doc2klist = this->nextdoc;
 
 		del_mtd_device(mtd);
 
-		iounmap((void *) this->virtadr);
+		iounmap(this->virtadr);
 		kfree(this->chips);
 		kfree(mtd);
 	}
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/doc2001.c linuxppc-2.6.9-dream/drivers/mtd/devices/doc2001.c
--- linuxppc-2.6.9/drivers/mtd/devices/doc2001.c	2004-10-18 23:53:45.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/doc2001.c	2005-06-20 10:46:11.000000000 +0200
@@ -4,7 +4,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2001.c,v 1.44 2004/08/09 14:04:24 dwmw2 Exp $
+ * $Id: doc2001.c,v 1.48 2005/01/05 18:05:12 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
@@ -52,7 +52,7 @@
 static struct mtd_info *docmillist = NULL;
 
 /* Perform the required delay cycles by reading from the NOP register */
-static void DoC_Delay(unsigned long docptr, unsigned short cycles)
+static void DoC_Delay(void __iomem * docptr, unsigned short cycles)
 {
 	volatile char dummy;
 	int i;
@@ -62,7 +62,7 @@
 }
 
 /* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */
-static int _DoC_WaitReady(unsigned long docptr)
+static int _DoC_WaitReady(void __iomem * docptr)
 {
 	unsigned short c = 0xffff;
 
@@ -79,7 +79,7 @@
 	return (c == 0);
 }
 
-static inline int DoC_WaitReady(unsigned long docptr)
+static inline int DoC_WaitReady(void __iomem * docptr)
 {
 	/* This is inline, to optimise the common case, where it's ready instantly */
 	int ret = 0;
@@ -103,7 +103,7 @@
    with the internal pipeline. Each of 4 delay cycles (read from the NOP register) is
    required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */
 
-static inline void DoC_Command(unsigned long docptr, unsigned char command,
+static inline void DoC_Command(void __iomem * docptr, unsigned char command,
 			       unsigned char xtraflags)
 {
 	/* Assert the CLE (Command Latch Enable) line to the flash chip */
@@ -123,7 +123,7 @@
    with the internal pipeline. Each of 4 delay cycles (read from the NOP register) is
    required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */
 
-static inline void DoC_Address(unsigned long docptr, int numbytes, unsigned long ofs,
+static inline void DoC_Address(void __iomem * docptr, int numbytes, unsigned long ofs,
 			       unsigned char xtraflags1, unsigned char xtraflags2)
 {
 	/* Assert the ALE (Address Latch Enable) line to the flash chip */
@@ -161,7 +161,7 @@
 }
 
 /* DoC_SelectChip: Select a given flash chip within the current floor */
-static int DoC_SelectChip(unsigned long docptr, int chip)
+static int DoC_SelectChip(void __iomem * docptr, int chip)
 {
 	/* Select the individual flash chip requested */
 	WriteDOC(chip, docptr, CDSNDeviceSelect);
@@ -172,7 +172,7 @@
 }
 
 /* DoC_SelectFloor: Select a given floor (bank of flash chips) */
-static int DoC_SelectFloor(unsigned long docptr, int floor)
+static int DoC_SelectFloor(void __iomem * docptr, int floor)
 {
 	/* Select the floor (bank) of chips required */
 	WriteDOC(floor, docptr, FloorSelect);
@@ -335,23 +335,23 @@
  */
 static void DoCMil_init(struct mtd_info *mtd)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	struct DiskOnChip *old = NULL;
 
 	/* We must avoid being called twice for the same device. */
 	if (docmillist)
-		old = (struct DiskOnChip *)docmillist->priv;
+		old = docmillist->priv;
 
 	while (old) {
 		if (DoCMil_is_alias(this, old)) {
 			printk(KERN_NOTICE "Ignoring DiskOnChip Millennium at "
 			       "0x%lX - already configured\n", this->physadr);
-			iounmap((void *)this->virtadr);
+			iounmap(this->virtadr);
 			kfree(mtd);
 			return;
 		}
 		if (old->nextdoc)
-			old = (struct DiskOnChip *)old->nextdoc->priv;
+			old = old->nextdoc->priv;
 		else
 			old = NULL;
 	}
@@ -392,7 +392,7 @@
 
 	if (!this->totlen) {
 		kfree(mtd);
-		iounmap((void *)this->virtadr);
+		iounmap(this->virtadr);
 	} else {
 		this->nextdoc = docmillist;
 		docmillist = mtd;
@@ -416,8 +416,8 @@
 	int i, ret;
 	volatile char dummy;
 	unsigned char syndrome[6];
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
-	unsigned long docptr = this->virtadr;
+	struct DiskOnChip *this = mtd->priv;
+	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[from >> (this->chipshift)];
 
 	/* Don't allow read past end of device */
@@ -542,8 +542,8 @@
 {
 	int i,ret = 0;
 	volatile char dummy;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
-	unsigned long docptr = this->virtadr;
+	struct DiskOnChip *this = mtd->priv;
+	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[to >> (this->chipshift)];
 
 	/* Don't allow write past end of device */
@@ -677,8 +677,8 @@
 	int i;
 #endif
 	volatile char dummy;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
-	unsigned long docptr = this->virtadr;
+	struct DiskOnChip *this = mtd->priv;
+	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 
 	/* Find the chip which is to be used and select it */
@@ -729,8 +729,8 @@
 #endif
 	volatile char dummy;
 	int ret = 0;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
-	unsigned long docptr = this->virtadr;
+	struct DiskOnChip *this = mtd->priv;
+	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 
 	/* Find the chip which is to be used and select it */
@@ -796,10 +796,10 @@
 int doc_erase (struct mtd_info *mtd, struct erase_info *instr)
 {
 	volatile char dummy;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	__u32 ofs = instr->addr;
 	__u32 len = instr->len;
-	unsigned long docptr = this->virtadr;
+	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 
 	if (len != mtd->erasesize) 
@@ -856,7 +856,7 @@
  *
  ****************************************************************************/
 
-int __init init_doc2001(void)
+static int __init init_doc2001(void)
 {
 	inter_module_register(im_name, THIS_MODULE, &DoCMil_init);
 	return 0;
@@ -868,12 +868,12 @@
 	struct DiskOnChip *this;
 
 	while ((mtd=docmillist)) {
-		this = (struct DiskOnChip *)mtd->priv;
+		this = mtd->priv;
 		docmillist = this->nextdoc;
 			
 		del_mtd_device(mtd);
 			
-		iounmap((void *)this->virtadr);
+		iounmap(this->virtadr);
 		kfree(this->chips);
 		kfree(mtd);
 	}
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/doc2001plus.c linuxppc-2.6.9-dream/drivers/mtd/devices/doc2001plus.c
--- linuxppc-2.6.9/drivers/mtd/devices/doc2001plus.c	2004-10-18 23:53:05.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/doc2001plus.c	2005-06-20 10:46:11.000000000 +0200
@@ -6,7 +6,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2001plus.c,v 1.9 2004/08/09 13:19:44 dwmw2 Exp $
+ * $Id: doc2001plus.c,v 1.13 2005/01/05 18:05:12 dwmw2 Exp $
  *
  * Released under GPL
  */
@@ -57,7 +57,7 @@
 
 
 /* Perform the required delay cycles by writing to the NOP register */
-static void DoC_Delay(unsigned long docptr, int cycles)
+static void DoC_Delay(void __iomem * docptr, int cycles)
 {
 	int i;
 
@@ -68,7 +68,7 @@
 #define	CDSN_CTRL_FR_B_MASK	(CDSN_CTRL_FR_B0 | CDSN_CTRL_FR_B1)
 
 /* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */
-static int _DoC_WaitReady(unsigned long docptr)
+static int _DoC_WaitReady(void __iomem * docptr)
 {
 	unsigned int c = 0xffff;
 
@@ -85,7 +85,7 @@
 	return (c == 0);
 }
 
-static inline int DoC_WaitReady(unsigned long docptr)
+static inline int DoC_WaitReady(void __iomem * docptr)
 {
 	/* This is inline, to optimise the common case, where it's ready instantly */
 	int ret = 0;
@@ -106,7 +106,7 @@
  * can detect. M-systems suggest always check this on any block level
  * operation and setting to normal mode if in reset mode.
  */
-static inline void DoC_CheckASIC(unsigned long docptr)
+static inline void DoC_CheckASIC(void __iomem * docptr)
 {
 	/* Make sure the DoC is in normal mode */
 	if ((ReadDOC(docptr, Mplus_DOCControl) & DOC_MODE_NORMAL) == 0) {
@@ -118,7 +118,7 @@
 /* DoC_Command: Send a flash command to the flash chip through the Flash
  * command register. Need 2 Write Pipeline Terminates to complete send.
  */
-static inline void DoC_Command(unsigned long docptr, unsigned char command,
+static inline void DoC_Command(void __iomem * docptr, unsigned char command,
 			       unsigned char xtraflags)
 {
 	WriteDOC(command, docptr, Mplus_FlashCmd);
@@ -133,7 +133,7 @@
 			       unsigned long ofs, unsigned char xtraflags1,
 			       unsigned char xtraflags2)
 {
-	unsigned long docptr = doc->virtadr;
+	void __iomem * docptr = doc->virtadr;
 
 	/* Allow for possible Mill Plus internal flash interleaving */
 	ofs >>= doc->interleave;
@@ -163,14 +163,14 @@
 }
 
 /* DoC_SelectChip: Select a given flash chip within the current floor */
-static int DoC_SelectChip(unsigned long docptr, int chip)
+static int DoC_SelectChip(void __iomem * docptr, int chip)
 {
 	/* No choice for flash chip on Millennium Plus */
 	return 0;
 }
 
 /* DoC_SelectFloor: Select a given floor (bank of flash chips) */
-static int DoC_SelectFloor(unsigned long docptr, int floor)
+static int DoC_SelectFloor(void __iomem * docptr, int floor)
 {
 	WriteDOC((floor & 0x3), docptr, Mplus_DeviceSelect);
 	return 0;
@@ -190,7 +190,7 @@
    may not want it */
 static unsigned int DoC_GetDataOffset(struct mtd_info *mtd, loff_t *from)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 
 	if (this->interleave) {
 		unsigned int ofs = *from & 0x3ff;
@@ -253,7 +253,7 @@
 	return cmd;
 }
 
-static inline void MemReadDOC(unsigned long docptr, unsigned char *buf, int len)
+static inline void MemReadDOC(void __iomem * docptr, unsigned char *buf, int len)
 {
 #ifndef USE_MEMCPY
 	int i;
@@ -264,7 +264,7 @@
 #endif
 }
 
-static inline void MemWriteDOC(unsigned long docptr, unsigned char *buf, int len)
+static inline void MemWriteDOC(void __iomem * docptr, unsigned char *buf, int len)
 {
 #ifndef USE_MEMCPY
 	int i;
@@ -280,7 +280,7 @@
 {
 	int mfr, id, i, j;
 	volatile char dummy;
-	unsigned long docptr = doc->virtadr;
+	void __iomem * docptr = doc->virtadr;
 
 	/* Page in the required floor/chip */
 	DoC_SelectFloor(docptr, floor);
@@ -371,7 +371,7 @@
 		printk(KERN_NOTICE "Setting DiskOnChip Millennium Plus interleave to %s\n",
 		       this->interleave?"on (16-bit)":"off (8-bit)");
 		conf ^= 4;
-		WriteDOC(this->virtadr, conf, Mplus_Configuration);
+		WriteDOC(conf, this->virtadr, Mplus_Configuration);
 	}
 
 	/* For each floor, find the number of valid chips it contains */
@@ -458,24 +458,24 @@
  */
 static void DoCMilPlus_init(struct mtd_info *mtd)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	struct DiskOnChip *old = NULL;
 
 	/* We must avoid being called twice for the same device. */
 	if (docmilpluslist)
-		old = (struct DiskOnChip *)docmilpluslist->priv;
+		old = docmilpluslist->priv;
 
 	while (old) {
 		if (DoCMilPlus_is_alias(this, old)) {
 			printk(KERN_NOTICE "Ignoring DiskOnChip Millennium "
 				"Plus at 0x%lX - already configured\n",
 				this->physadr);
-			iounmap((void *)this->virtadr);
+			iounmap(this->virtadr);
 			kfree(mtd);
 			return;
 		}
 		if (old->nextdoc)
-			old = (struct DiskOnChip *)old->nextdoc->priv;
+			old = old->nextdoc->priv;
 		else
 			old = NULL;
 	}
@@ -514,7 +514,7 @@
 
 	if (!this->totlen) {
 		kfree(mtd);
-		iounmap((void *)this->virtadr);
+		iounmap(this->virtadr);
 	} else {
 		this->nextdoc = docmilpluslist;
 		docmilpluslist = mtd;
@@ -530,8 +530,8 @@
 {
 	int i;
 	loff_t fofs;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
-	unsigned long docptr = this->virtadr;
+	struct DiskOnChip *this = mtd->priv;
+	void __iomem * docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[from >> (this->chipshift)];
 	unsigned char *bp, buf[1056];
 	char c[32];
@@ -615,8 +615,8 @@
 	volatile char dummy;
 	loff_t fofs;
 	unsigned char syndrome[6];
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
-	unsigned long docptr = this->virtadr;
+	struct DiskOnChip *this = mtd->priv;
+	void __iomem * docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[from >> (this->chipshift)];
 
 	/* Don't allow read past end of device */
@@ -754,8 +754,8 @@
 	int i, before, ret = 0;
 	loff_t fto;
 	volatile char dummy;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
-	unsigned long docptr = this->virtadr;
+	struct DiskOnChip *this = mtd->priv;
+	void __iomem * docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[to >> (this->chipshift)];
 
 	/* Don't allow write past end of device */
@@ -880,8 +880,8 @@
 			size_t *retlen, u_char *buf)
 {
 	loff_t fofs, base;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
-	unsigned long docptr = this->virtadr;
+	struct DiskOnChip *this = mtd->priv;
+	void __iomem * docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 	size_t i, size, got, want;
 
@@ -958,8 +958,8 @@
 {
 	volatile char dummy;
 	loff_t fofs, base;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
-	unsigned long docptr = this->virtadr;
+	struct DiskOnChip *this = mtd->priv;
+	void __iomem * docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 	size_t i, size, got, want;
 	int ret = 0;
@@ -1058,10 +1058,10 @@
 int doc_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
 	volatile char dummy;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	__u32 ofs = instr->addr;
 	__u32 len = instr->len;
-	unsigned long docptr = this->virtadr;
+	void __iomem * docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 
 	DoC_CheckASIC(docptr);
@@ -1122,7 +1122,7 @@
  *
  ****************************************************************************/
 
-int __init init_doc2001plus(void)
+static int __init init_doc2001plus(void)
 {
 	inter_module_register(im_name, THIS_MODULE, &DoCMilPlus_init);
 	return 0;
@@ -1134,12 +1134,12 @@
 	struct DiskOnChip *this;
 
 	while ((mtd=docmilpluslist)) {
-		this = (struct DiskOnChip *)mtd->priv;
+		this = mtd->priv;
 		docmilpluslist = this->nextdoc;
 			
 		del_mtd_device(mtd);
 			
-		iounmap((void *)this->virtadr);
+		iounmap(this->virtadr);
 		kfree(this->chips);
 		kfree(mtd);
 	}
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/docprobe.c linuxppc-2.6.9-dream/drivers/mtd/devices/docprobe.c
--- linuxppc-2.6.9/drivers/mtd/devices/docprobe.c	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/docprobe.c	2005-06-20 10:46:11.000000000 +0200
@@ -4,7 +4,7 @@
 /* (C) 1999 Machine Vision Holdings, Inc.			*/
 /* (C) 1999-2003 David Woodhouse <dwmw2@infradead.org>		*/
 
-/* $Id: docprobe.c,v 1.41 2003/12/03 10:19:57 dwmw2 Exp $	*/
+/* $Id: docprobe.c,v 1.44 2005/01/05 12:40:36 dwmw2 Exp $	*/
 
 
 
@@ -62,7 +62,7 @@
 
 
 static unsigned long doc_config_location = CONFIG_MTD_DOCPROBE_ADDRESS;
-MODULE_PARM(doc_config_location, "l");
+module_param(doc_config_location, ulong, 0);
 MODULE_PARM_DESC(doc_config_location, "Physical memory address at which to probe for DiskOnChip");
 
 static unsigned long __initdata doc_locations[] = {
@@ -94,9 +94,9 @@
 
 /* doccheck: Probe a given memory window to see if there's a DiskOnChip present */
 
-static inline int __init doccheck(unsigned long potential, unsigned long physadr)
+static inline int __init doccheck(void __iomem *potential, unsigned long physadr)
 {
-	unsigned long window=potential;
+	void __iomem *window=potential;
 	unsigned char tmp, tmpb, tmpc, ChipID;
 #ifndef DOC_PASSIVE_PROBE
 	unsigned char tmp2;
@@ -233,7 +233,7 @@
 
 static void __init DoC_Probe(unsigned long physadr)
 {
-	unsigned long docptr;
+	void __iomem *docptr;
 	struct DiskOnChip *this;
 	struct mtd_info *mtd;
 	int ChipID;
@@ -243,7 +243,7 @@
 	char *im_modname = NULL;
 	void (*initroutine)(struct mtd_info *) = NULL;
 
-	docptr = (unsigned long)ioremap(physadr, DOC_IOREMAP_LEN);
+	docptr = ioremap(physadr, DOC_IOREMAP_LEN);
 	
 	if (!docptr)
 		return;
@@ -252,7 +252,7 @@
 		if (ChipID == DOC_ChipID_Doc2kTSOP) {
 			/* Remove this at your own peril. The hardware driver works but nothing prevents you from erasing bad blocks */
 			printk(KERN_NOTICE "Refusing to drive DiskOnChip 2000 TSOP until Bad Block Table is correctly supported by INFTL\n");
-			iounmap((void *)docptr);
+			iounmap(docptr);
 			return;
 		}
 		docfound = 1;
@@ -260,7 +260,7 @@
 
 		if (!mtd) {
 			printk(KERN_WARNING "Cannot allocate memory for data structures. Dropping.\n");
-			iounmap((void *)docptr);
+			iounmap(docptr);
 			return;
 		}
 		
@@ -318,7 +318,7 @@
 		printk(KERN_NOTICE "Cannot find driver for DiskOnChip %s at 0x%lX\n", name, physadr);
 		kfree(mtd);
 	}
-	iounmap((void *)docptr);
+	iounmap(docptr);
 }
 
 
@@ -328,7 +328,7 @@
  *
  ****************************************************************************/
 
-int __init init_doc(void)
+static int __init init_doc(void)
 {
 	int i;
 	
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/Kconfig linuxppc-2.6.9-dream/drivers/mtd/devices/Kconfig
--- linuxppc-2.6.9/drivers/mtd/devices/Kconfig	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/Kconfig	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 # drivers/mtd/maps/Kconfig
-# $Id: Kconfig,v 1.12 2004/08/10 13:12:18 dwmw2 Exp $
+# $Id: Kconfig,v 1.15 2004/12/22 17:51:15 joern Exp $
 
 menu "Self-contained MTD device drivers"
 	depends on MTD!=n
@@ -125,11 +125,22 @@
 	  Testing MTD users (eg JFFS2) on large media and media that might
 	  be removed during a write (using the floppy drive).
 
+config MTD_BLOCK2MTD
+	tristate "MTD using block device (rewrite)"
+	depends on MTD && EXPERIMENTAL
+	help
+	  This driver is basically the same at MTD_BLKMTD above, but
+	  experienced some interface changes plus serious speedups.  In
+	  the long term, it should replace MTD_BLKMTD.  Right now, you
+	  shouldn't entrust important data to it yet.
+
 comment "Disk-On-Chip Device Drivers"
 
 config MTD_DOC2000
 	tristate "M-Systems Disk-On-Chip 2000 and Millennium (DEPRECATED)"
 	depends on MTD
+	select MTD_DOCPROBE
+	select MTD_NAND_IDS
 	---help---
 	  This provides an MTD device driver for the M-Systems DiskOnChip
 	  2000 and Millennium devices.  Originally designed for the DiskOnChip
@@ -151,6 +162,8 @@
 config MTD_DOC2001
 	tristate "M-Systems Disk-On-Chip Millennium-only alternative driver (DEPRECATED)"
 	depends on MTD
+	select MTD_DOCPROBE
+	select MTD_NAND_IDS
 	---help---
 	  This provides an alternative MTD device driver for the M-Systems 
 	  DiskOnChip Millennium devices.  Use this if you have problems with
@@ -171,6 +184,8 @@
 config MTD_DOC2001PLUS
 	tristate "M-Systems Disk-On-Chip Millennium Plus"
 	depends on MTD
+	select MTD_DOCPROBE
+	select MTD_NAND_IDS
 	---help---
 	  This provides an MTD device driver for the M-Systems DiskOnChip
 	  Millennium Plus devices.
@@ -186,17 +201,10 @@
 
 config MTD_DOCPROBE
 	tristate
-	default m if MTD_DOC2001!=y && MTD_DOC2000!=y && MTD_DOC2001PLUS!=y && (MTD_DOC2001=m || MTD_DOC2000=m || MTD_DOC2001PLUS=m)
-	default y if MTD_DOC2001=y || MTD_DOC2000=y || MTD_DOC2001PLUS=y
-	help
-	  This isn't a real config option; it's derived.
+	select MTD_DOCECC
 
 config MTD_DOCECC
 	tristate
-	default m if MTD_DOCPROBE!=y && MTD_NAND_DISKONCHIP!=y && (MTD_DOCPROBE=m || MTD_NAND_DISKONCHIP=m)
-	default y if MTD_DOCPROBE=y || MTD_NAND_DISKONCHIP=y
-	help
-	  This isn't a real config option; it's derived.
 
 config MTD_DOCPROBE_ADVANCED
 	bool "Advanced detection options for DiskOnChip"
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/Makefile linuxppc-2.6.9-dream/drivers/mtd/devices/Makefile
--- linuxppc-2.6.9/drivers/mtd/devices/Makefile	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/Makefile	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # linux/drivers/devices/Makefile
 #
-# $Id: Makefile.common,v 1.6 2004/07/12 16:07:30 dwmw2 Exp $
+# $Id: Makefile.common,v 1.7 2004/12/22 17:51:15 joern Exp $
 
 #                       *** BIG UGLY NOTE ***
 #
@@ -22,3 +22,4 @@
 obj-$(CONFIG_MTD_MTDRAM)	+= mtdram.o
 obj-$(CONFIG_MTD_LART)		+= lart.o
 obj-$(CONFIG_MTD_BLKMTD)	+= blkmtd.o
+obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd.o
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/ms02-nv.c linuxppc-2.6.9-dream/drivers/mtd/devices/ms02-nv.c
--- linuxppc-2.6.9/drivers/mtd/devices/ms02-nv.c	2004-10-18 23:53:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/ms02-nv.c	2005-06-20 10:46:11.000000000 +0200
@@ -6,7 +6,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  *
- *	$Id: ms02-nv.c,v 1.7 2004/07/29 14:16:45 macro Exp $
+ *	$Id: ms02-nv.c,v 1.8 2005/01/05 18:05:12 dwmw2 Exp $
  */
 
 #include <linux/init.h>
@@ -59,7 +59,7 @@
 static int ms02nv_read(struct mtd_info *mtd, loff_t from,
 			size_t len, size_t *retlen, u_char *buf)
 {
-	struct ms02nv_private *mp = (struct ms02nv_private *)mtd->priv;
+	struct ms02nv_private *mp = mtd->priv;
 
 	if (from + len > mtd->size)
 		return -EINVAL;
@@ -73,7 +73,7 @@
 static int ms02nv_write(struct mtd_info *mtd, loff_t to,
 			size_t len, size_t *retlen, const u_char *buf)
 {
-	struct ms02nv_private *mp = (struct ms02nv_private *)mtd->priv;
+	struct ms02nv_private *mp = mtd->priv;
 
 	if (to + len > mtd->size)
 		return -EINVAL;
@@ -265,7 +265,7 @@
 static void __exit ms02nv_remove_one(void)
 {
 	struct mtd_info *mtd = root_ms02nv_mtd;
-	struct ms02nv_private *mp = (struct ms02nv_private *)mtd->priv;
+	struct ms02nv_private *mp = mtd->priv;
 
 	root_ms02nv_mtd = mp->next;
 
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/mtdram.c linuxppc-2.6.9-dream/drivers/mtd/devices/mtdram.c
--- linuxppc-2.6.9/drivers/mtd/devices/mtdram.c	2004-10-18 23:53:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/mtdram.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * mtdram - a test mtd device
- * $Id: mtdram.c,v 1.33 2004/08/09 13:19:44 dwmw2 Exp $
+ * $Id: mtdram.c,v 1.35 2005/01/05 18:05:12 dwmw2 Exp $
  * Author: Alexander Larsson <alex@cendio.se>
  *
  * Copyright (c) 1999 Alexander Larsson <alex@cendio.se>
@@ -29,9 +29,9 @@
 #ifdef MODULE
 static unsigned long total_size = CONFIG_MTDRAM_TOTAL_SIZE;
 static unsigned long erase_size = CONFIG_MTDRAM_ERASE_SIZE;
-MODULE_PARM(total_size,"l");
+module_param(total_size,ulong,0);
 MODULE_PARM_DESC(total_size, "Total device size in KiB");
-MODULE_PARM(erase_size,"l");
+module_param(erase_size,ulong,0);
 MODULE_PARM_DESC(erase_size, "Device erase block size in KiB");
 #define MTDRAM_TOTAL_SIZE (total_size * 1024)
 #define MTDRAM_ERASE_SIZE (erase_size * 1024)
@@ -153,12 +153,12 @@
 
 #if CONFIG_MTDRAM_TOTAL_SIZE > 0
 #if CONFIG_MTDRAM_ABS_POS > 0
-int __init init_mtdram(void)
+static int __init init_mtdram(void)
 {
   void *addr;
   int err;
   /* Allocate some memory */
-   mtd_info = (struct mtd_info *)kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
+   mtd_info = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
    if (!mtd_info)
      return -ENOMEM;
    
@@ -186,12 +186,12 @@
 
 #else /* CONFIG_MTDRAM_ABS_POS > 0 */
 
-int __init init_mtdram(void)
+static int __init init_mtdram(void)
 {
   void *addr;
   int err;
   /* Allocate some memory */
-   mtd_info = (struct mtd_info *)kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
+   mtd_info = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
    if (!mtd_info)
      return -ENOMEM;
 
@@ -220,7 +220,7 @@
 
 #else /* CONFIG_MTDRAM_TOTAL_SIZE > 0 */
 
-int __init init_mtdram(void)
+static int __init init_mtdram(void)
 {
   return 0;
 }
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/phram.c linuxppc-2.6.9-dream/drivers/mtd/devices/phram.c
--- linuxppc-2.6.9/drivers/mtd/devices/phram.c	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/phram.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,13 +1,8 @@
 /**
+ * $Id: phram.c,v 1.11 2005/01/05 18:05:13 dwmw2 Exp $
  *
- * $Id: phram.c,v 1.2 2004/08/09 13:19:44 dwmw2 Exp $
- *
- * Copyright (c) Jochen Schaeuble <psionic@psionic.de>
- * 07/2003	rewritten by Joern Engel <joern@wh.fh-wedel.de>
- *
- * DISCLAIMER:  This driver makes use of Rusty's excellent module code,
- * so it will not work for 2.4 without changes and it wont work for 2.4
- * as a module without major changes.  Oh well!
+ * Copyright (c) ????		Jochen Schuble <psionic@psionic.de>
+ * Copyright (c) 2003-2004	Jrn Engel <joern@wh.fh-wedel.de>
  *
  * Usage:
  *
@@ -15,9 +10,12 @@
  *   phram=<name>,<start>,<len>
  * <name> may be up to 63 characters.
  * <start> and <len> can be octal, decimal or hexadecimal.  If followed
- * by "k", "M" or "G", the numbers will be interpreted as kilo, mega or
+ * by "ki", "Mi" or "Gi", the numbers will be interpreted as kilo, mega or
  * gigabytes.
  *
+ * Example:
+ *	phram=swap,64Mi,128Mi phram=test,900Mi,1Mi
+ *
  */
 
 #include <asm/io.h>
@@ -31,17 +29,17 @@
 #define ERROR(fmt, args...) printk(KERN_ERR "phram: " fmt , ## args)
 
 struct phram_mtd_list {
+	struct mtd_info mtd;
 	struct list_head list;
-	struct mtd_info *mtdinfo;
 };
 
 static LIST_HEAD(phram_list);
 
 
 
-int phram_erase(struct mtd_info *mtd, struct erase_info *instr)
+static int phram_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
-	u_char *start = (u_char *)mtd->priv;
+	u_char *start = mtd->priv;
 
 	if (instr->addr + instr->len > mtd->size)
 		return -EINVAL;
@@ -60,10 +58,10 @@
 	return 0;
 }
 
-int phram_point(struct mtd_info *mtd, loff_t from, size_t len,
+static int phram_point(struct mtd_info *mtd, loff_t from, size_t len,
 		size_t *retlen, u_char **mtdbuf)
 {
-	u_char *start = (u_char *)mtd->priv;
+	u_char *start = mtd->priv;
 
 	if (from + len > mtd->size)
 		return -EINVAL;
@@ -73,14 +71,14 @@
 	return 0;
 }
 
-void phram_unpoint(struct mtd_info *mtd, u_char *addr, loff_t from, size_t len)
+static void phram_unpoint(struct mtd_info *mtd, u_char *addr, loff_t from, size_t len)
 {
 }
 
-int phram_read(struct mtd_info *mtd, loff_t from, size_t len,
+static int phram_read(struct mtd_info *mtd, loff_t from, size_t len,
 		size_t *retlen, u_char *buf)
 {
-	u_char *start = (u_char *)mtd->priv;
+	u_char *start = mtd->priv;
 
 	if (from + len > mtd->size)
 		return -EINVAL;
@@ -91,10 +89,10 @@
 	return 0;
 }
 
-int phram_write(struct mtd_info *mtd, loff_t to, size_t len,
+static int phram_write(struct mtd_info *mtd, loff_t to, size_t len,
 		size_t *retlen, const u_char *buf)
 {
-	u_char *start = (u_char *)mtd->priv;
+	u_char *start = mtd->priv;
 
 	if (to + len > mtd->size)
 		return -EINVAL;
@@ -112,9 +110,8 @@
 	struct phram_mtd_list *this;
 
 	list_for_each_entry(this, &phram_list, list) {
-		del_mtd_device(this->mtdinfo);
-		iounmap(this->mtdinfo->priv);
-		kfree(this->mtdinfo);
+		del_mtd_device(&this->mtd);
+		iounmap(this->mtd.priv);
 		kfree(this);
 	}
 }
@@ -128,45 +125,39 @@
 	if (!new)
 		goto out0;
 
-	new->mtdinfo = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
-	if (!new->mtdinfo)
-		goto out1;
-	
-	memset(new->mtdinfo, 0, sizeof(struct mtd_info));
+	memset(new, 0, sizeof(*new));
 
 	ret = -EIO;
-	new->mtdinfo->priv = ioremap(start, len);
-	if (!new->mtdinfo->priv) {
+	new->mtd.priv = ioremap(start, len);
+	if (!new->mtd.priv) {
 		ERROR("ioremap failed\n");
-		goto out2;
+		goto out1;
 	}
 
 
-	new->mtdinfo->name = name;
-	new->mtdinfo->size = len;
-	new->mtdinfo->flags = MTD_CAP_RAM | MTD_ERASEABLE | MTD_VOLATILE;
-        new->mtdinfo->erase = phram_erase;
-	new->mtdinfo->point = phram_point;
-	new->mtdinfo->unpoint = phram_unpoint;
-	new->mtdinfo->read = phram_read;
-	new->mtdinfo->write = phram_write;
-	new->mtdinfo->owner = THIS_MODULE;
-	new->mtdinfo->type = MTD_RAM;
-	new->mtdinfo->erasesize = 0x0;
+	new->mtd.name = name;
+	new->mtd.size = len;
+	new->mtd.flags = MTD_CAP_RAM | MTD_ERASEABLE | MTD_VOLATILE;
+        new->mtd.erase = phram_erase;
+	new->mtd.point = phram_point;
+	new->mtd.unpoint = phram_unpoint;
+	new->mtd.read = phram_read;
+	new->mtd.write = phram_write;
+	new->mtd.owner = THIS_MODULE;
+	new->mtd.type = MTD_RAM;
+	new->mtd.erasesize = 0;
 
 	ret = -EAGAIN;
-	if (add_mtd_device(new->mtdinfo)) {
+	if (add_mtd_device(&new->mtd)) {
 		ERROR("Failed to register new device\n");
-		goto out3;
+		goto out2;
 	}
 
 	list_add_tail(&new->list, &phram_list);
 	return 0;	
 
-out3:
-	iounmap(new->mtdinfo->priv);
 out2:
-	kfree(new->mtdinfo);
+	iounmap(new->mtd.priv);
 out1:
 	kfree(new);
 out0:
@@ -184,7 +175,9 @@
 		result *= 1024;
 	case 'k':
 		result *= 1024;
-		endp++;
+	/* By dwmw2 editorial decree, "ki", "Mi" or "Gi" are to be used. */
+		if ((*endp)[1] == 'i')
+			(*endp) += 2;
 	}
 	return result;
 }
@@ -235,7 +228,7 @@
 	uint32_t len;
 	int i, ret;
 
-	if (strnlen(val, sizeof(str)) >= sizeof(str))
+	if (strnlen(val, sizeof(buf)) >= sizeof(buf))
 		parse_err("parameter too long\n");
 
 	strcpy(str, val);
@@ -271,78 +264,11 @@
 }
 
 module_param_call(phram, phram_setup, NULL, NULL, 000);
-MODULE_PARM_DESC(phram, "Memory region to map. \"map=<name>,<start><length>\"");
-
-/*
- * Just for compatibility with slram, this is horrible and should go someday.
- */
-static int __init slram_setup(const char *val, struct kernel_param *kp)
-{
-	char buf[256], *str = buf;
-
-	if (!val || !val[0])
-		parse_err("no arguments to \"slram=\"\n");
-
-	if (strnlen(val, sizeof(str)) >= sizeof(str))
-		parse_err("parameter too long\n");
-
-	strcpy(str, val);
-
-	while (str) {
-		char *token[3];
-		char *name;
-		uint32_t start;
-		uint32_t len;
-		int i, ret;
-
-		for (i=0; i<3; i++) {
-			token[i] = strsep(&str, ",");
-			if (token[i])
-				continue;
-			parse_err("wrong number of arguments to \"slram=\"\n");
-		}
-
-		/* name */
-		ret = parse_name(&name, token[0]);
-		if (ret == -ENOMEM)
-			parse_err("of memory\n");
-		if (ret == -ENOSPC)
-			parse_err("too long\n");
-		if (ret)
-			return 1;
-
-		/* start */
-		ret = parse_num32(&start, token[1]);
-		if (ret)
-			parse_err("illegal start address\n");
-
-		/* len */
-		if (token[2][0] == '+')
-			ret = parse_num32(&len, token[2] + 1);
-		else
-			ret = parse_num32(&len, token[2]);
-
-		if (ret)
-			parse_err("illegal device length\n");
-
-		if (token[2][0] != '+') {
-			if (len < start)
-				parse_err("end < start\n");
-			len -= start;
-		}
-
-		register_device(name, start, len);
-	}
-	return 1;
-}
-
-module_param_call(slram, slram_setup, NULL, NULL, 000);
-MODULE_PARM_DESC(slram, "List of memory regions to map. \"map=<name>,<start><length/end>\"");
+MODULE_PARM_DESC(phram,"Memory region to map. \"map=<name>,<start>,<length>\"");
 
 
-int __init init_phram(void)
+static int __init init_phram(void)
 {
-	printk(KERN_ERR "phram loaded\n");
 	return 0;
 }
 
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/pmc551.c linuxppc-2.6.9-dream/drivers/mtd/devices/pmc551.c
--- linuxppc-2.6.9/drivers/mtd/devices/pmc551.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/pmc551.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: pmc551.c,v 1.28 2004/08/09 13:19:44 dwmw2 Exp $
+ * $Id: pmc551.c,v 1.30 2005/01/05 18:05:13 dwmw2 Exp $
  *
  * PMC551 PCI Mezzanine Ram Device
  *
@@ -113,7 +113,7 @@
 
 static int pmc551_erase (struct mtd_info *mtd, struct erase_info *instr)
 {
-        struct mypriv *priv = (struct mypriv *)mtd->priv;
+        struct mypriv *priv = mtd->priv;
         u32 soff_hi, soff_lo; /* start address offset hi/lo */
         u32 eoff_hi, eoff_lo; /* end address offset hi/lo */
         unsigned long end;
@@ -176,7 +176,7 @@
 
 static int pmc551_point (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char **mtdbuf)
 {
-        struct mypriv *priv = (struct mypriv *)mtd->priv;
+        struct mypriv *priv = mtd->priv;
         u32 soff_hi;
         u32 soff_lo;
 
@@ -217,7 +217,7 @@
 
 static int pmc551_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
 {
-        struct mypriv *priv = (struct mypriv *)mtd->priv;
+        struct mypriv *priv = mtd->priv;
         u32 soff_hi, soff_lo; /* start address offset hi/lo */
         u32 eoff_hi, eoff_lo; /* end address offset hi/lo */
         unsigned long end;
@@ -279,7 +279,7 @@
 
 static int pmc551_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
 {
-        struct mypriv *priv = (struct mypriv *)mtd->priv;
+        struct mypriv *priv = mtd->priv;
         u32 soff_hi, soff_lo; /* start address offset hi/lo */
         u32 eoff_hi, eoff_lo; /* end address offset hi/lo */
         unsigned long end;
@@ -630,10 +630,6 @@
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Mark Ferrell <mferrell@mvista.com>");
 MODULE_DESCRIPTION(PMC551_VERSION);
-MODULE_PARM(msize, "i");
-MODULE_PARM_DESC(msize, "memory size in Megabytes [1 - 1024]");
-MODULE_PARM(asize, "i");
-MODULE_PARM_DESC(asize, "aperture size, must be <= memsize [1-1024]");
 
 /*
  * Stuff these outside the ifdef so as to not bust compiled in driver support
@@ -645,10 +641,15 @@
 static int asize=0;
 #endif
 
+module_param(msize, int, 0);
+MODULE_PARM_DESC(msize, "memory size in Megabytes [1 - 1024]");
+module_param(asize, int, 0);
+MODULE_PARM_DESC(asize, "aperture size, must be <= memsize [1-1024]");
+
 /*
  * PMC551 Card Initialization
  */
-int __init init_pmc551(void)
+static int __init init_pmc551(void)
 {
         struct pci_dev *PCI_Device = NULL;
         struct mypriv *priv;
@@ -820,7 +821,7 @@
 	struct mypriv *priv;
 
 	while((mtd=pmc551list)) {
-		priv = (struct mypriv *)mtd->priv;
+		priv = mtd->priv;
 		pmc551list = priv->nextpmc551;
 		
 		if(priv->start) {
diff -Naur linuxppc-2.6.9/drivers/mtd/devices/slram.c linuxppc-2.6.9-dream/drivers/mtd/devices/slram.c
--- linuxppc-2.6.9/drivers/mtd/devices/slram.c	2004-10-18 23:53:05.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/devices/slram.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,6 +1,6 @@
 /*======================================================================
 
-  $Id: slram.c,v 1.31 2004/08/09 13:19:44 dwmw2 Exp $
+  $Id: slram.c,v 1.33 2005/01/05 18:05:13 dwmw2 Exp $
 
   This driver provides a method to access memory not used by the kernel
   itself (i.e. if the kernel commandline mem=xxx is used). To actually
@@ -66,22 +66,22 @@
 
 #ifdef MODULE
 static char *map[SLRAM_MAX_DEVICES_PARAMS];
+
+module_param_array(map, charp, NULL, 0);
+MODULE_PARM_DESC(map, "List of memory regions to map. \"map=<name>, <start>, <length / end>\"");
 #else
 static char *map;
 #endif
 
-MODULE_PARM(map, "3-" __MODULE_STRING(SLRAM_MAX_DEVICES_PARAMS) "s");
-MODULE_PARM_DESC(map, "List of memory regions to map. \"map=<name>, <start>, <length / end>\"");
-
 static slram_mtd_list_t *slram_mtdlist = NULL;
 
-int slram_erase(struct mtd_info *, struct erase_info *);
-int slram_point(struct mtd_info *, loff_t, size_t, size_t *, u_char **);
-void slram_unpoint(struct mtd_info *, u_char *, loff_t,	size_t);
-int slram_read(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
-int slram_write(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+static int slram_erase(struct mtd_info *, struct erase_info *);
+static int slram_point(struct mtd_info *, loff_t, size_t, size_t *, u_char **);
+static void slram_unpoint(struct mtd_info *, u_char *, loff_t,	size_t);
+static int slram_read(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+static int slram_write(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
 
-int slram_erase(struct mtd_info *mtd, struct erase_info *instr)
+static int slram_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
 	slram_priv_t *priv = mtd->priv;
 
@@ -103,24 +103,24 @@
 	return(0);
 }
 
-int slram_point(struct mtd_info *mtd, loff_t from, size_t len,
+static int slram_point(struct mtd_info *mtd, loff_t from, size_t len,
 		size_t *retlen, u_char **mtdbuf)
 {
-	slram_priv_t *priv = (slram_priv_t *)mtd->priv;
+	slram_priv_t *priv = mtd->priv;
 
 	*mtdbuf = priv->start + from;
 	*retlen = len;
 	return(0);
 }
 
-void slram_unpoint(struct mtd_info *mtd, u_char *addr, loff_t from, size_t len)
+static void slram_unpoint(struct mtd_info *mtd, u_char *addr, loff_t from, size_t len)
 {
 }
 
-int slram_read(struct mtd_info *mtd, loff_t from, size_t len,
+static int slram_read(struct mtd_info *mtd, loff_t from, size_t len,
 		size_t *retlen, u_char *buf)
 {
-	slram_priv_t *priv = (slram_priv_t *)mtd->priv;
+	slram_priv_t *priv = mtd->priv;
 	
 	memcpy(buf, priv->start + from, len);
 
@@ -128,10 +128,10 @@
 	return(0);
 }
 
-int slram_write(struct mtd_info *mtd, loff_t to, size_t len,
+static int slram_write(struct mtd_info *mtd, loff_t to, size_t len,
 		size_t *retlen, const u_char *buf)
 {
-	slram_priv_t *priv = (slram_priv_t *)mtd->priv;
+	slram_priv_t *priv = mtd->priv;
 
 	memcpy(priv->start + to, buf, len);
 
@@ -141,7 +141,7 @@
 
 /*====================================================================*/
 
-int register_device(char *name, unsigned long start, unsigned long length)
+static int register_device(char *name, unsigned long start, unsigned long length)
 {
 	slram_mtd_list_t **curmtd;
 
@@ -161,7 +161,7 @@
 	if ((*curmtd)->mtdinfo)	{
 		memset((char *)(*curmtd)->mtdinfo, 0, sizeof(struct mtd_info));
 		(*curmtd)->mtdinfo->priv =
-			(void *)kmalloc(sizeof(slram_priv_t), GFP_KERNEL);
+			kmalloc(sizeof(slram_priv_t), GFP_KERNEL);
 		
 		if (!(*curmtd)->mtdinfo->priv) {
 			kfree((*curmtd)->mtdinfo);
@@ -213,7 +213,7 @@
 	return(0);	
 }
 
-void unregister_devices(void)
+static void unregister_devices(void)
 {
 	slram_mtd_list_t *nextitem;
 
@@ -228,7 +228,7 @@
 	}
 }
 
-unsigned long handle_unit(unsigned long value, char *unit)
+static unsigned long handle_unit(unsigned long value, char *unit)
 {
 	if ((*unit == 'M') || (*unit == 'm')) {
 		return(value * 1024 * 1024);
@@ -238,7 +238,7 @@
 	return(value);
 }
 
-int parse_cmdline(char *devname, char *szstart, char *szlength)
+static int parse_cmdline(char *devname, char *szstart, char *szlength)
 {
 	char *buffer;
 	unsigned long devstart;
@@ -285,7 +285,7 @@
 
 #endif
 
-int init_slram(void)
+static int init_slram(void)
 {
 	char *devname;
 	int i;
diff -Naur linuxppc-2.6.9/drivers/mtd/ftl.c linuxppc-2.6.9-dream/drivers/mtd/ftl.c
--- linuxppc-2.6.9/drivers/mtd/ftl.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/ftl.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /* This version ported to the Linux-MTD system by dwmw2@infradead.org
- * $Id: ftl.c,v 1.53 2004/08/09 13:55:43 dwmw2 Exp $
+ * $Id: ftl.c,v 1.54 2004/11/16 18:33:15 dwmw2 Exp $
  *
  * Fixes: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
  * - fixes some leaks on failure in build_maps and ftl_notify_add, cleanups
@@ -80,7 +80,7 @@
 
 /* Parameters that can be set with 'insmod' */
 static int shuffle_freq = 50;
-MODULE_PARM(shuffle_freq, "i");
+module_param(shuffle_freq, int, 0);
 
 /*====================================================================*/
 
@@ -1067,16 +1067,18 @@
 		partition->mbd.blksize = SECTOR_SIZE;
 		partition->mbd.tr = tr;
 		partition->mbd.devnum = -1;
-		if (add_mtd_blktrans_dev((void *)partition))
-			kfree(partition);
-	
-	} else
-		kfree(partition);
+		if (!add_mtd_blktrans_dev((void *)partition))
+			return;
+	}
+
+	ftl_freepart(partition);
+	kfree(partition);
 }
 
 static void ftl_remove_dev(struct mtd_blktrans_dev *dev)
 {
 	del_mtd_blktrans_dev(dev);
+	ftl_freepart((partition_t *)dev);
 	kfree(dev);
 }
 
@@ -1094,7 +1096,7 @@
 
 int init_ftl(void)
 {
-	DEBUG(0, "$Id: ftl.c,v 1.53 2004/08/09 13:55:43 dwmw2 Exp $\n");
+	DEBUG(0, "$Id: ftl.c,v 1.54 2004/11/16 18:33:15 dwmw2 Exp $\n");
 
 	return register_mtd_blktrans(&ftl_tr);
 }
diff -Naur linuxppc-2.6.9/drivers/mtd/inftlcore.c linuxppc-2.6.9-dream/drivers/mtd/inftlcore.c
--- linuxppc-2.6.9/drivers/mtd/inftlcore.c	2004-10-18 23:53:13.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/inftlcore.c	2005-06-20 10:46:11.000000000 +0200
@@ -7,7 +7,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * Author: David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: inftlcore.c,v 1.17 2004/08/09 13:56:48 dwmw2 Exp $
+ * $Id: inftlcore.c,v 1.18 2004/11/16 18:28:59 dwmw2 Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -352,7 +352,7 @@
 	return targetEUN;
 }
 
-u16 INFTL_makefreeblock(struct INFTLrecord *inftl, unsigned pendingblock)
+static u16 INFTL_makefreeblock(struct INFTLrecord *inftl, unsigned pendingblock)
 {
 	/*
 	 * This is the part that needs some cleverness applied. 
@@ -877,7 +877,7 @@
 	return 0;
 }
 
-struct mtd_blktrans_ops inftl_tr = {
+static struct mtd_blktrans_ops inftl_tr = {
 	.name		= "inftl",
 	.major		= INFTL_MAJOR,
 	.part_bits	= INFTL_PARTN_BITS,
@@ -891,9 +891,9 @@
 
 extern char inftlmountrev[];
 
-int __init init_inftl(void)
+static int __init init_inftl(void)
 {
-	printk(KERN_INFO "INFTL: inftlcore.c $Revision: 1.17 $, "
+	printk(KERN_INFO "INFTL: inftlcore.c $Revision: 1.18 $, "
 		"inftlmount.c %s\n", inftlmountrev);
 
 	return register_mtd_blktrans(&inftl_tr);
diff -Naur linuxppc-2.6.9/drivers/mtd/inftlmount.c linuxppc-2.6.9-dream/drivers/mtd/inftlmount.c
--- linuxppc-2.6.9/drivers/mtd/inftlmount.c	2004-10-18 23:53:10.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/inftlmount.c	2005-06-20 10:46:11.000000000 +0200
@@ -8,7 +8,7 @@
  * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
  * Copyright (C) 2000 Netgem S.A.
  *
- * $Id: inftlmount.c,v 1.14 2004/08/09 13:57:42 dwmw2 Exp $
+ * $Id: inftlmount.c,v 1.16 2004/11/22 13:50:53 kalev Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -41,7 +41,7 @@
 #include <linux/mtd/inftl.h>
 #include <linux/mtd/compatmac.h>
 
-char inftlmountrev[]="$Revision: 1.14 $";
+char inftlmountrev[]="$Revision: 1.16 $";
 
 /*
  * find_boot_record: Find the INFTL Media Header and its Spare copy which
@@ -222,6 +222,8 @@
 			if (ip->Reserved0 != ip->firstUnit) {
 				struct erase_info *instr = &inftl->instr;
 
+				instr->mtd = inftl->mbd.mtd;
+
 				/*
 				 * 	Most likely this is using the
 				 * 	undocumented qiuck mount feature.
@@ -396,6 +398,7 @@
 	   _first_? */
 
 	/* Use async erase interface, test return code */
+	instr->mtd = inftl->mbd.mtd;
 	instr->addr = block * inftl->EraseSize;
 	instr->len = inftl->mbd.mtd->erasesize;
 	/* Erase one physical eraseblock at a time, even though the NAND api
diff -Naur linuxppc-2.6.9/drivers/mtd/Kconfig linuxppc-2.6.9-dream/drivers/mtd/Kconfig
--- linuxppc-2.6.9/drivers/mtd/Kconfig	2004-10-18 23:53:41.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/Kconfig	2005-06-20 10:46:11.000000000 +0200
@@ -1,4 +1,4 @@
-# $Id: Kconfig,v 1.6 2004/08/09 13:19:42 dwmw2 Exp $
+# $Id: Kconfig,v 1.7 2004/11/22 11:33:56 ijc Exp $
 
 menu "Memory Technology Devices (MTD)"
 
@@ -54,8 +54,8 @@
 	depends on MTD_PARTITIONS
 	---help---
 	  RedBoot is a ROM monitor and bootloader which deals with multiple
-	  'images' in flash devices by putting a table in the last erase
-	  block of the device, similar to a partition table, which gives
+	  'images' in flash devices by putting a table one of the erase
+	  blocks on the device, similar to a partition table, which gives
 	  the offsets, lengths and names of all the images stored in the
 	  flash.
 
@@ -68,6 +68,23 @@
 	  SA1100 map driver (CONFIG_MTD_SA1100) has an option for this, for 
 	  example.
 
+config MTD_REDBOOT_DIRECTORY_BLOCK
+	int "Location of RedBoot partition table"
+	depends on MTD_REDBOOT_PARTS
+	default "-1"
+	---help---
+	  This option is the Linux counterpart to the
+	  CYGNUM_REDBOOT_FIS_DIRECTORY_BLOCK RedBoot compile time
+	  option.
+
+	  The option specifies which Flash sectors holds the RedBoot
+	  partition table.  A zero or positive value gives an absolete
+	  erase block number. A negative value specifies a number of
+	  sectors before the end of the device.
+	  
+	  For example "2" means block number 2, "-1" means the last
+	  block and "-2" means the penultimate block.
+	  
 config MTD_REDBOOT_PARTS_UNALLOCATED
 	bool "  Include unallocated flash regions"
 	depends on MTD_REDBOOT_PARTS
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/amd76xrom.c linuxppc-2.6.9-dream/drivers/mtd/maps/amd76xrom.c
--- linuxppc-2.6.9/drivers/mtd/maps/amd76xrom.c	2004-10-18 23:53:44.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/amd76xrom.c	2005-06-20 10:46:11.000000000 +0200
@@ -2,7 +2,7 @@
  * amd76xrom.c
  *
  * Normal mappings of chips in physical memory
- * $Id: amd76xrom.c,v 1.12 2004/07/14 14:44:31 thayne Exp $
+ * $Id: amd76xrom.c,v 1.19 2004/11/28 09:40:39 dwmw2 Exp $
  */
 
 #include <linux/module.h>
@@ -12,61 +12,73 @@
 #include <asm/io.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+#include <linux/mtd/flashchip.h>
 #include <linux/config.h>
 #include <linux/pci.h>
 #include <linux/pci_ids.h>
+#include <linux/list.h>
 
 
 #define xstr(s) str(s)
 #define str(s) #s
 #define MOD_NAME xstr(KBUILD_BASENAME)
 
-#define MTD_DEV_NAME_LENGTH 16
+#define ADDRESS_NAME_LEN 18
+
+#define ROM_PROBE_STEP_SIZE (64*1024) /* 64KiB */
+
+struct amd76xrom_window {
+	void __iomem *virt;
+	unsigned long phys;
+	unsigned long size;
+	struct list_head maps;
+	struct resource rsrc;
+	struct pci_dev *pdev;
+};
 
 struct amd76xrom_map_info {
+	struct list_head list;
 	struct map_info map;
 	struct mtd_info *mtd;
-	void __iomem * window_addr;
-	u32 window_start, window_size;
-	struct pci_dev *pdev;
-	struct resource window_rsrc;
-	struct resource rom_rsrc;
-	char mtd_name[MTD_DEV_NAME_LENGTH];
+	struct resource rsrc;
+	char map_name[sizeof(MOD_NAME) + 2 + ADDRESS_NAME_LEN];
 };
 
-
-static struct amd76xrom_map_info amd76xrom_map = {
-	.map = {
-		.name = MOD_NAME,
-		.size = 0,
-		.bankwidth = 1,
-	}
-	/* remaining fields of structure are initialized to 0 */
+static struct amd76xrom_window amd76xrom_window = {
+	.maps = LIST_HEAD_INIT(amd76xrom_window.maps),
 };
 
-
-static void amd76xrom_cleanup(struct amd76xrom_map_info *info)
+static void amd76xrom_cleanup(struct amd76xrom_window *window)
 {
+	struct amd76xrom_map_info *map, *scratch;
 	u8 byte;
 
-	/* Disable writes through the rom window */
-	pci_read_config_byte(info->pdev, 0x40, &byte);
-	pci_write_config_byte(info->pdev, 0x40, byte & ~1);
-
-	if (info->mtd) {
-		del_mtd_device(info->mtd);
-		map_destroy(info->mtd);
-		info->mtd = NULL;
-		info->map.virt = NULL;
-	}
-	if (info->rom_rsrc.parent)
-		release_resource(&info->rom_rsrc);
-	if (info->window_rsrc.parent)
-		release_resource(&info->window_rsrc);
-
-	if (info->window_addr) {
-		iounmap(info->window_addr);
-		info->window_addr = NULL;
+	if (window->pdev) {
+		/* Disable writes through the rom window */
+		pci_read_config_byte(window->pdev, 0x40, &byte);
+		pci_write_config_byte(window->pdev, 0x40, byte & ~1);
+	}
+
+	/* Free all of the mtd devices */
+	list_for_each_entry_safe(map, scratch, &window->maps, list) {
+		if (map->rsrc.parent) {
+			release_resource(&map->rsrc);
+		}
+		del_mtd_device(map->mtd);
+		map_destroy(map->mtd);
+		list_del(&map->list);
+		kfree(map);
+	}
+	if (window->rsrc.parent) 
+		release_resource(&window->rsrc);
+
+	if (window->virt) {
+		iounmap(window->virt);
+		window->virt = NULL;
+		window->phys = 0;
+		window->size = 0;
+		window->pdev = NULL;
 	}
 }
 
@@ -74,167 +86,196 @@
 static int __devinit amd76xrom_init_one (struct pci_dev *pdev,
 	const struct pci_device_id *ent)
 {
-	struct rom_window {
-		u32 start;
-		u32 size;
-		u8 segen_bits;
-	};
-	static struct rom_window rom_window[] = {
-		/*
-		 * Need the 5MiB window for chips that have block lock/unlock
-		 * registers located below 4MiB window.
-		 */
-		{ 0xffb00000, 5*1024*1024, (1<<7) | (1<<6), },
-		{ 0xffc00000, 4*1024*1024, (1<<7), },
-		{ 0xffff0000, 64*1024,     0 },
-		{ 0         , 0,           0 },
-	};
-	static const u32 rom_probe_sizes[] = { 
-		5*1024*1024, 4*1024*1024, 2*1024*1024, 1024*1024, 512*1024, 
-		256*1024, 128*1024, 64*1024, 0};
 	static char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL };
 	u8 byte;
-	struct amd76xrom_map_info *info = &amd76xrom_map;
-	struct rom_window *window;
-	int i;
-	u32 rom_size;
-
-	info->pdev = pdev;
-	window = &rom_window[0];
-
-	while (window->size) {
-		/*
-		 * Try to reserve the window mem region.  If this fails then
-		 * it is likely due to a fragment of the window being
-		 * "reseved" by the BIOS.  In the case that the
-		 * request_mem_region() fails then once the rom size is
-		 * discovered we will try to reserve the unreserved fragment.
-		 */
-		info->window_rsrc.name = MOD_NAME;
-		info->window_rsrc.start = window->start;
-		info->window_rsrc.end = window->start + window->size - 1;
-		info->window_rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
-		if (request_resource(&iomem_resource, &info->window_rsrc)) {
-			info->window_rsrc.parent = NULL;
-			printk(KERN_ERR MOD_NAME
-			       " %s(): Unable to register resource"
-			       " 0x%.08lx-0x%.08lx - kernel bug?\n",
-			       __func__,
-			       info->window_rsrc.start, info->window_rsrc.end);
-		}
-
-		/* Enable the selected rom window */
-		pci_read_config_byte(pdev, 0x43, &byte);
-		pci_write_config_byte(pdev, 0x43, byte | window->segen_bits);
-
-		/* Enable writes through the rom window */
-		pci_read_config_byte(pdev, 0x40, &byte);
-		pci_write_config_byte(pdev, 0x40, byte | 1);
-
-		/* FIXME handle registers 0x80 - 0x8C the bios region locks */
-
-		printk(KERN_NOTICE MOD_NAME " window : %x at %x\n", 
-		       window->size, window->start);
-		/* For write accesses caches are useless */
-		info->window_addr = ioremap_nocache(window->start,
-						       window->size);
-
-		if (!info->window_addr) {
-			printk(KERN_ERR "Failed to ioremap\n");
-			continue;
-		}
+	struct amd76xrom_window *window = &amd76xrom_window;
+	struct amd76xrom_map_info *map = NULL;
+	unsigned long map_top;
+
+	/* Remember the pci dev I find the window in */
+	window->pdev = pdev;
+
+	/* Assume the rom window is properly setup, and find it's size */
+	pci_read_config_byte(pdev, 0x43, &byte);
+	if ((byte & ((1<<7)|(1<<6))) == ((1<<7)|(1<<6))) {
+		window->phys = 0xffb00000; /* 5MiB */
+	}
+	else if ((byte & (1<<7)) == (1<<7)) {
+		window->phys = 0xffc00000; /* 4MiB */
+	}
+	else {
+		window->phys = 0xffff0000; /* 64KiB */
+	}
+	window->size = 0xffffffffUL - window->phys + 1UL;
+	
+	/*
+	 * Try to reserve the window mem region.  If this fails then
+	 * it is likely due to a fragment of the window being
+	 * "reseved" by the BIOS.  In the case that the
+	 * request_mem_region() fails then once the rom size is
+	 * discovered we will try to reserve the unreserved fragment.
+	 */
+	window->rsrc.name = MOD_NAME;
+	window->rsrc.start = window->phys;
+	window->rsrc.end   = window->phys + window->size - 1;
+	window->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+	if (request_resource(&iomem_resource, &window->rsrc)) {
+		window->rsrc.parent = NULL;
+		printk(KERN_ERR MOD_NAME
+			" %s(): Unable to register resource"
+			" 0x%.08lx-0x%.08lx - kernel bug?\n",
+			__func__,
+			window->rsrc.start, window->rsrc.end);
+	}
 
-		info->mtd = NULL;
+#if 0
 
-		for(i = 0; (rom_size = rom_probe_sizes[i]); i++) {
-			char **chip_type;
-			if (rom_size > window->size) {
-				continue;
-			}
-			info->map.phys = window->start + window->size - rom_size;
-			info->map.virt = 
-				info->window_addr + window->size - rom_size;
-			info->map.size = rom_size;
-			simple_map_init(&info->map);
-			chip_type = rom_probe_types;
-			for(; !info->mtd && *chip_type; chip_type++) {
-				info->mtd = do_map_probe(*chip_type, &amd76xrom_map.map);
-			}
-			if (info->mtd) goto found_mtd;
-		}
-		iounmap(info->window_addr);
-		info->window_addr = NULL;
+	/* Enable the selected rom window */
+	pci_read_config_byte(pdev, 0x43, &byte);
+	pci_write_config_byte(pdev, 0x43, byte | rwindow->segen_bits);
+#endif
 
-		/* Disable writes through the rom window */
-		pci_read_config_byte(pdev, 0x40, &byte);
-		pci_write_config_byte(pdev, 0x40, byte & ~1);
+	/* Enable writes through the rom window */
+	pci_read_config_byte(pdev, 0x40, &byte);
+	pci_write_config_byte(pdev, 0x40, byte | 1);
+	
+	/* FIXME handle registers 0x80 - 0x8C the bios region locks */
+
+	/* For write accesses caches are useless */
+	window->virt = ioremap_nocache(window->phys, window->size);
+	if (!window->virt) {
+		printk(KERN_ERR MOD_NAME ": ioremap(%08lx, %08lx) failed\n",
+			window->phys, window->size);
+		goto out;
+	}
 
-		window++;
+	/* Get the first address to look for an rom chip at */
+	map_top = window->phys;
+#if 1
+	/* The probe sequence run over the firmware hub lock
+	 * registers sets them to 0x7 (no access).
+	 * Probe at most the last 4M of the address space.
+	 */
+	if (map_top < 0xffc00000) {
+		map_top = 0xffc00000;
 	}
-	goto failed;
+#endif
+	/* Loop  through and look for rom chips */
+	while((map_top - 1) < 0xffffffffUL) {
+		struct cfi_private *cfi;
+		unsigned long offset;
+		int i;
 
- found_mtd:
-	printk(KERN_NOTICE MOD_NAME " chip at offset: 0x%x\n",
-		window->size - rom_size);
-
-	info->mtd->owner = THIS_MODULE;
-
-	if (!info->window_rsrc.parent) {
-		/* failed to reserve entire window - try fragments */
-		info->window_rsrc.name = MOD_NAME;
-		info->window_rsrc.start = window->start;
-		info->window_rsrc.end = window->start + window->size - rom_size - 1;
-		info->window_rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
-		if (request_resource(&iomem_resource, &info->window_rsrc)) {
-			printk(KERN_ERR MOD_NAME
-			       ": cannot reserve window resource fragment\n");
-#if 0
+		if (!map) {
+			map = kmalloc(sizeof(*map), GFP_KERNEL);
+		}
+		if (!map) {
+			printk(KERN_ERR MOD_NAME ": kmalloc failed");
+			goto out;
+		}
+		memset(map, 0, sizeof(*map));
+		INIT_LIST_HEAD(&map->list);
+		map->map.name = map->map_name;
+		map->map.phys = map_top;
+		offset = map_top - window->phys;
+		map->map.virt = (void __iomem *)
+			(((unsigned long)(window->virt)) + offset);
+		map->map.size = 0xffffffffUL - map_top + 1UL;
+		/* Set the name of the map to the address I am trying */
+		sprintf(map->map_name, "%s @%08lx",
+			MOD_NAME, map->map.phys);
+
+		/* There is no generic VPP support */
+		for(map->map.bankwidth = 32; map->map.bankwidth; 
+			map->map.bankwidth >>= 1)
+		{
+			char **probe_type;
+			/* Skip bankwidths that are not supported */
+			if (!map_bankwidth_supported(map->map.bankwidth))
+				continue;
+
+			/* Setup the map methods */
+			simple_map_init(&map->map);
+
+			/* Try all of the probe methods */
+			probe_type = rom_probe_types;
+			for(; *probe_type; probe_type++) {
+				map->mtd = do_map_probe(*probe_type, &map->map);
+				if (map->mtd)
+					goto found;
+			}
+		}
+		map_top += ROM_PROBE_STEP_SIZE;
+		continue;
+	found:
+		/* Trim the size if we are larger than the map */
+		if (map->mtd->size > map->map.size) {
+			printk(KERN_WARNING MOD_NAME
+				" rom(%u) larger than window(%lu). fixing...\n",
+				map->mtd->size, map->map.size);
+			map->mtd->size = map->map.size;
+		}
+		if (window->rsrc.parent) {
 			/*
-			 * The BIOS e820 usually reserves this so it isn't
-			 * usually an error.
+			 * Registering the MTD device in iomem may not be possible
+			 * if there is a BIOS "reserved" and BUSY range.  If this
+			 * fails then continue anyway.
 			 */
-			goto failed;
-#endif
+			map->rsrc.name  = map->map_name;
+			map->rsrc.start = map->map.phys;
+			map->rsrc.end   = map->map.phys + map->mtd->size - 1;
+			map->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+			if (request_resource(&window->rsrc, &map->rsrc)) {
+				printk(KERN_ERR MOD_NAME
+					": cannot reserve MTD resource\n");
+				map->rsrc.parent = NULL;
+			}
 		}
-	}
 
-	add_mtd_device(info->mtd);
-	info->window_start = window->start;
-	info->window_size = window->size;
-
-	if (info->window_rsrc.parent) {
-		/*
-		 * Registering the MTD device in iomem may not be possible
-		 * if there is a BIOS "reserved" and BUSY range.  If this
-		 * fails then continue anyway.
-		 */
-		snprintf(info->mtd_name, MTD_DEV_NAME_LENGTH,
-			 "mtd%d", info->mtd->index);
-
-		info->rom_rsrc.name = info->mtd_name;
-		info->rom_rsrc.start = window->start + window->size - rom_size;
-		info->rom_rsrc.end = window->start + window->size - 1;
-		info->rom_rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
-		if (request_resource(&info->window_rsrc, &info->rom_rsrc)) {
-			printk(KERN_ERR MOD_NAME
-			       ": cannot reserve MTD resource\n");
-			info->rom_rsrc.parent = NULL;
+		/* Make the whole region visible in the map */
+		map->map.virt = window->virt;
+		map->map.phys = window->phys;
+		cfi = map->map.fldrv_priv;
+		for(i = 0; i < cfi->numchips; i++) {
+			cfi->chips[i].start += offset;
+		}
+		
+		/* Now that the mtd devices is complete claim and export it */
+		map->mtd->owner = THIS_MODULE;
+		if (add_mtd_device(map->mtd)) {
+			map_destroy(map->mtd);
+			map->mtd = NULL;
+			goto out;
 		}
+
+
+		/* Calculate the new value of map_top */
+		map_top += map->mtd->size;
+
+		/* File away the map structure */
+		list_add(&map->list, &window->maps);
+		map = NULL;
 	}
 
+ out:
+	/* Free any left over map structures */
+	if (map) {
+		kfree(map);
+	}
+	/* See if I have any map structures */
+	if (list_empty(&window->maps)) {
+		amd76xrom_cleanup(window);
+		return -ENODEV;
+	}
 	return 0;
-
- failed:
-	amd76xrom_cleanup(info);
-	return -ENODEV;
 }
 
 
 static void __devexit amd76xrom_remove_one (struct pci_dev *pdev)
 {
-	struct amd76xrom_map_info *info = &amd76xrom_map;
+	struct amd76xrom_window *window = &amd76xrom_window;
 
-	amd76xrom_cleanup(info);
+	amd76xrom_cleanup(window);
 }
 
 static struct pci_device_id amd76xrom_pci_tbl[] = {
@@ -257,7 +298,7 @@
 };
 #endif
 
-int __init init_amd76xrom(void)
+static int __init init_amd76xrom(void)
 {
 	struct pci_dev *pdev;
 	struct pci_device_id *id;
@@ -269,7 +310,6 @@
 		}
 	}
 	if (pdev) {
-		amd76xrom_map.pdev = pdev;
 		return amd76xrom_init_one(pdev, &amd76xrom_pci_tbl[0]);
 	}
 	return -ENXIO;
@@ -280,7 +320,7 @@
 
 static void __exit cleanup_amd76xrom(void)
 {
-	amd76xrom_remove_one(amd76xrom_map.pdev);
+	amd76xrom_remove_one(amd76xrom_window.pdev);
 }
 
 module_init(init_amd76xrom);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/arctic-mtd.c linuxppc-2.6.9-dream/drivers/mtd/maps/arctic-mtd.c
--- linuxppc-2.6.9/drivers/mtd/maps/arctic-mtd.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/arctic-mtd.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: arctic-mtd.c,v 1.11 2004/07/12 21:59:43 dwmw2 Exp $
+ * $Id: arctic-mtd.c,v 1.13 2004/11/04 13:24:14 gleixner Exp $
  * 
  * drivers/mtd/maps/arctic-mtd.c MTD mappings and partition tables for 
  *                              IBM 405LP Arctic boards.
@@ -98,7 +98,7 @@
 {
 	printk("%s: 0x%08x at 0x%08x\n", NAME, SIZE, PADDR);
 
-	arctic_mtd_map.virt = (unsigned long) ioremap(PADDR, SIZE);
+	arctic_mtd_map.virt = ioremap(PADDR, SIZE);
 
 	if (!arctic_mtd_map.virt) {
 		printk("%s: failed to ioremap 0x%x\n", NAME, PADDR);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/autcpu12-nvram.c linuxppc-2.6.9-dream/drivers/mtd/maps/autcpu12-nvram.c
--- linuxppc-2.6.9/drivers/mtd/maps/autcpu12-nvram.c	2004-10-18 23:55:24.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/autcpu12-nvram.c	2005-06-20 10:46:11.000000000 +0200
@@ -2,7 +2,7 @@
  * NV-RAM memory access on autcpu12 
  * (C) 2002 Thomas Gleixner (gleixner@autronix.de)
  *
- * $Id: autcpu12-nvram.c,v 1.6 2004/07/12 21:59:43 dwmw2 Exp $ 
+ * $Id: autcpu12-nvram.c,v 1.8 2004/11/04 13:24:14 gleixner Exp $ 
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -47,7 +47,7 @@
 {
 	int err, save0, save1;
 
-	autcpu12_sram_map.virt = (unsigned long)ioremap(0x12000000, SZ_128K);
+	autcpu12_sram_map.virt = ioremap(0x12000000, SZ_128K);
 	if (!autcpu12_sram_map.virt) {
 		printk("Failed to ioremap autcpu12 NV-RAM space\n");
 		err = -EIO;
@@ -76,7 +76,7 @@
 	/* We have a 128K found, restore 0x10000 and set size
 	 * to 128K
 	 */
-	ma[_write32(&autcpu12_sram_map,save1,0x10000);
+	map_write32(&autcpu12_sram_map,save1,0x10000);
 	autcpu12_sram_map.size = SZ_128K;
 
 map:
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/bast-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/bast-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/bast-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/bast-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,227 @@
+/* linux/drivers/mtd/maps/bast_flash.c
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ * Ben Dooks <ben@simtec.co.uk>
+ *
+ * Simtec Bast (EB2410ITX) NOR MTD Mapping driver
+ *
+ * Changelog:
+ *	20-Sep-2004  BJD  Initial version
+ *
+ * $Id: bast-flash.c,v 1.1 2004/09/21 14:29:04 bjd Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <asm/mach/flash.h>
+
+#include <asm/arch/map.h>
+#include <asm/arch/bast-map.h>
+#include <asm/arch/bast-cpld.h>
+
+#ifdef CONFIG_MTD_BAST_MAXSIZE
+#define AREA_MAXSIZE (CONFIG_MTD_BAST_MAXSIZE * (1024*1024))
+#else
+#define AREA_MAXSIZE (32*1024*1024)
+#endif
+
+#define PFX "bast-flash: "
+
+struct bast_flash_info {
+	struct mtd_info		*mtd;
+	struct map_info		 map;
+	struct mtd_partition	*partitions;
+	struct resource		*area;
+};
+
+static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
+
+static struct bast_flash_info *to_bast_info(struct device *dev)
+{
+	return (struct bast_flash_info *)dev_get_drvdata(dev);
+}
+
+static void bast_flash_setrw(int to)
+{
+	unsigned int val;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	val = __raw_readb(BAST_VA_CTRL3);
+	
+	if (to)
+		val |= BAST_CPLD_CTRL3_ROMWEN;
+	else
+		val &= ~BAST_CPLD_CTRL3_ROMWEN;
+
+	pr_debug("new cpld ctrl3=%02x\n", val);
+
+	__raw_writeb(val, BAST_VA_CTRL3);
+	local_irq_restore(flags);
+}
+
+static int bast_flash_remove(struct device *dev)
+{
+	struct bast_flash_info *info = to_bast_info(dev);
+
+	dev_set_drvdata(dev, NULL);
+
+	if (info == NULL) 
+		return 0;
+
+	if (info->map.virt != NULL)
+		iounmap(info->map.virt);
+
+	if (info->mtd) {
+		del_mtd_partitions(info->mtd);
+		map_destroy(info->mtd);
+	}
+
+	if (info->partitions)
+		kfree(info->partitions);
+
+	if (info->area) {
+		release_resource(info->area);
+		kfree(info->area);
+	}
+	
+	kfree(info);
+
+	return 0;
+}
+
+static int bast_flash_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bast_flash_info *info;
+	struct resource *res;
+	int err = 0;
+
+	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	if (info == NULL) {
+		printk(KERN_ERR PFX "no memory for flash info\n");
+		err = -ENOMEM;
+		goto exit_error;
+	}
+
+	memzero(info, sizeof(*info));
+	dev_set_drvdata(dev, info);
+
+	res = pdev->resource;  /* assume that the flash has one resource */
+
+	info->map.phys = res->start;
+	info->map.size = res->end - res->start + 1;
+	info->map.name = dev->bus_id;	
+	info->map.bankwidth = 2;
+	
+	if (info->map.size > AREA_MAXSIZE)
+		info->map.size = AREA_MAXSIZE;
+
+	pr_debug("%s: area %08lx, size %ld\n", __FUNCTION__,
+		 info->map.phys, info->map.size);
+	
+	info->area = request_mem_region(res->start, info->map.size,
+					pdev->name);
+	if (info->area == NULL) {
+		printk(KERN_ERR PFX "cannot reserve flash memory region\n");
+		err = -ENOENT;
+		goto exit_error;
+	}
+
+	info->map.virt = ioremap(res->start, info->map.size);
+	pr_debug("%s: virt at %08x\n", __FUNCTION__, (int)info->map.virt);
+
+	if (info->map.virt == 0) {
+		printk(KERN_ERR PFX "failed to ioremap() region\n");
+		err = -EIO;
+		goto exit_error;
+	}
+ 
+	simple_map_init(&info->map);
+
+	/* enable the write to the flash area */
+
+	bast_flash_setrw(1);
+
+	/* probe for the device(s) */
+
+	info->mtd = do_map_probe("jedec_probe", &info->map);
+	if (info->mtd == NULL)
+		info->mtd = do_map_probe("cfi_probe", &info->map);
+
+	if (info->mtd == NULL) {
+		printk(KERN_ERR PFX "map_probe() failed\n");
+		err = -ENXIO;
+		goto exit_error;
+	}
+
+	/* mark ourselves as the owner */
+	info->mtd->owner = THIS_MODULE;
+
+	err = parse_mtd_partitions(info->mtd, probes, &info->partitions, 0);
+	if (err > 0) {
+		err = add_mtd_partitions(info->mtd, info->partitions, err);
+		if (err) 
+			printk(KERN_ERR PFX "cannot add/parse partitions\n");
+	}
+
+	if (err == 0)
+		return 0;
+
+	/* fall through to exit error */
+
+ exit_error:
+	bast_flash_remove(dev);
+	return err;
+}
+
+static struct device_driver bast_flash_driver = {
+	.name		= "bast-nor",
+	.bus		= &platform_bus_type,
+	.probe		= bast_flash_probe,
+	.remove		= bast_flash_remove,
+};
+
+static int __init bast_flash_init(void)
+{
+	printk("BAST NOR-Flash Driver, (c) 2004 Simtec Electronics\n");
+	return driver_register(&bast_flash_driver);
+}
+
+static void __exit bast_flash_exit(void)
+{
+	driver_unregister(&bast_flash_driver);
+}
+
+module_init(bast_flash_init);
+module_exit(bast_flash_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
+MODULE_DESCRIPTION("BAST MTD Map driver");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/beech-mtd.c linuxppc-2.6.9-dream/drivers/mtd/maps/beech-mtd.c
--- linuxppc-2.6.9/drivers/mtd/maps/beech-mtd.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/beech-mtd.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: beech-mtd.c,v 1.8 2004/07/12 21:59:43 dwmw2 Exp $
+ * $Id: beech-mtd.c,v 1.10 2004/11/04 13:24:14 gleixner Exp $
  * 
  * drivers/mtd/maps/beech-mtd.c MTD mappings and partition tables for 
  *                              IBM 405LP Beech boards.
@@ -74,7 +74,7 @@
 {
 	printk("%s: 0x%08x at 0x%08x\n", NAME, SIZE, PADDR);
 
-	beech_mtd_map.virt = (unsigned long) ioremap(PADDR, SIZE);
+	beech_mtd_map.virt = ioremap(PADDR, SIZE);
 
 	if (!beech_mtd_map.virt) {
 		printk("%s: failed to ioremap 0x%x\n", NAME, PADDR);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/cdb89712.c linuxppc-2.6.9-dream/drivers/mtd/maps/cdb89712.c
--- linuxppc-2.6.9/drivers/mtd/maps/cdb89712.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/cdb89712.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Flash on Cirrus CDB89712
  *
- * $Id: cdb89712.c,v 1.8 2004/07/12 21:59:43 dwmw2 Exp $
+ * $Id: cdb89712.c,v 1.10 2004/11/04 13:24:14 gleixner Exp $
  */
 
 #include <linux/module.h>
@@ -44,7 +44,7 @@
 		goto out;
 	}
 	
-	cdb89712_flash_map.virt = (unsigned long)ioremap(FLASH_START, FLASH_SIZE);
+	cdb89712_flash_map.virt = ioremap(FLASH_START, FLASH_SIZE);
 	if (!cdb89712_flash_map.virt) {
 		printk(KERN_NOTICE "Failed to ioremap Cdb89712 FLASH space\n");
 		err = -EIO;
@@ -114,7 +114,7 @@
 		goto out;
 	}
 	
-	cdb89712_sram_map.virt = (unsigned long)ioremap(SRAM_START, SRAM_SIZE);
+	cdb89712_sram_map.virt = ioremap(SRAM_START, SRAM_SIZE);
 	if (!cdb89712_sram_map.virt) {
 		printk(KERN_NOTICE "Failed to ioremap Cdb89712 SRAM space\n");
 		err = -EIO;
@@ -182,7 +182,7 @@
 		goto out;
 	}
 	
-	cdb89712_bootrom_map.virt = (unsigned long)ioremap(BOOTROM_START, BOOTROM_SIZE);
+	cdb89712_bootrom_map.virt = ioremap(BOOTROM_START, BOOTROM_SIZE);
 	if (!cdb89712_bootrom_map.virt) {
 		printk(KERN_NOTICE "Failed to ioremap Cdb89712 BootROM space\n");
 		err = -EIO;
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/ceiva.c linuxppc-2.6.9-dream/drivers/mtd/maps/ceiva.c
--- linuxppc-2.6.9/drivers/mtd/maps/ceiva.c	2004-10-18 23:53:50.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/ceiva.c	2005-06-20 10:46:11.000000000 +0200
@@ -11,7 +11,7 @@
  *
  * (C) 2000 Nicolas Pitre <nico@cam.org>
  *
- * $Id: ceiva.c,v 1.10 2004/07/12 21:59:43 dwmw2 Exp $
+ * $Id: ceiva.c,v 1.11 2004/09/16 23:27:12 gleixner Exp $
  */
 
 #include <linux/config.h>
@@ -103,7 +103,7 @@
 	unsigned long base;
 	unsigned long size;
 	int width;
-	void __iomem *vbase;
+	void *vbase;
 	struct map_info *map;
 	struct mtd_info *mtd;
 	struct resource *res;
@@ -150,7 +150,7 @@
 			break;
 		}
 
-		clps[i].map->virt = clps[i].vbase;
+		clps[i].map->virt = (void __iomem *)clps[i].vbase;
 		clps[i].map->bankwidth = clps[i].width;
 		clps[i].map->size = clps[i].size;
 
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/cfi_flagadm.c linuxppc-2.6.9-dream/drivers/mtd/maps/cfi_flagadm.c
--- linuxppc-2.6.9/drivers/mtd/maps/cfi_flagadm.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/cfi_flagadm.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  Copyright  2001 Flaga hf. Medical Devices, Kri Davsson <kd@flaga.is>
  *
- *  $Id: cfi_flagadm.c,v 1.12 2004/07/12 21:59:43 dwmw2 Exp $
+ *  $Id: cfi_flagadm.c,v 1.14 2004/11/04 13:24:14 gleixner Exp $
  *  
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -96,7 +96,7 @@
 			FLASH_SIZE, FLASH_PHYS_ADDR);
 	
 	flagadm_map.phys = FLASH_PHYS_ADDR;
-	flagadm_map.virt = (unsigned long)ioremap(FLASH_PHYS_ADDR,
+	flagadm_map.virt = ioremap(FLASH_PHYS_ADDR,
 					FLASH_SIZE);
 
 	if (!flagadm_map.virt) {
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/chestnut.c linuxppc-2.6.9-dream/drivers/mtd/maps/chestnut.c
--- linuxppc-2.6.9/drivers/mtd/maps/chestnut.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/chestnut.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,91 @@
+/*
+ * drivers/mtd/maps/chestnut.c
+ *
+ * $Id: chestnut.c,v 1.1 2005/01/05 16:59:50 dwmw2 Exp $
+ *
+ * Flash map driver for IBM Chestnut (750FXGX Eval)
+ *
+ * Chose not to enable 8 bit flash as it contains the firmware and board
+ * info.  Thus only the 32bit flash is supported.
+ *
+ * Author: <source@mvista.com>
+ *
+ * 2004 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <platforms/chestnut.h>
+
+static struct map_info chestnut32_map = {
+   	.name 		= "User FS",
+   	.size 		= CHESTNUT_32BIT_SIZE,
+   	.bankwidth 	= 4,
+	.phys 		= CHESTNUT_32BIT_BASE,
+};
+
+static struct mtd_partition chestnut32_partitions[] = {
+	{
+		.name 	= "User FS",
+		.offset	= 0,
+		.size	= CHESTNUT_32BIT_SIZE,
+	}
+};
+
+static struct mtd_info *flash32;
+
+int __init init_chestnut(void)
+{
+	/* 32-bit FLASH */
+
+   	chestnut32_map.virt = ioremap(chestnut32_map.phys, chestnut32_map.size);
+
+   	if (!chestnut32_map.virt) {
+      		printk(KERN_NOTICE "Failed to ioremap 32-bit flash\n");
+		return -EIO;
+   	}
+
+	simple_map_init(&chestnut32_map);
+
+   	flash32 = do_map_probe("cfi_probe", &chestnut32_map);
+   	if (flash32) {
+   		flash32->owner = THIS_MODULE;
+   		add_mtd_partitions(flash32, chestnut32_partitions,
+					ARRAY_SIZE(chestnut32_partitions));
+   	} else {
+      		printk(KERN_NOTICE "map probe failed for 32-bit flash\n");
+		return -ENXIO;
+	}
+
+   	return 0;
+}
+
+static void __exit
+cleanup_chestnut(void)
+{
+   	if (flash32) {
+      		del_mtd_partitions(flash32);
+		map_destroy(flash32);
+   	}
+
+   	if (chestnut32_map.virt) {
+      		iounmap((void *)chestnut32_map.virt);
+	  	chestnut32_map.virt = 0;
+   	}
+}
+
+module_init(init_chestnut);
+module_exit(cleanup_chestnut);
+
+MODULE_DESCRIPTION("MTD map and partitions for IBM Chestnut (750fxgx Eval)");
+MODULE_AUTHOR("<source@mvista.com>");
+MODULE_LICENSE("GPL");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/cstm_mips_ixx.c linuxppc-2.6.9-dream/drivers/mtd/maps/cstm_mips_ixx.c
--- linuxppc-2.6.9/drivers/mtd/maps/cstm_mips_ixx.c	2004-10-18 23:53:22.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/cstm_mips_ixx.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: cstm_mips_ixx.c,v 1.10 2004/07/12 21:59:43 dwmw2 Exp $
+ * $Id: cstm_mips_ixx.c,v 1.12 2004/11/04 13:24:14 gleixner Exp $
  *
  * Mapping of a custom board with both AMD CFI and JEDEC flash in partitions.
  * Config with both CFI and JEDEC device support.
@@ -170,7 +170,7 @@
 
 
 		cstm_mips_ixx_map[i].phys = cstm_mips_ixx_board_desc[i].window_addr;
-		cstm_mips_ixx_map[i].virt = (unsigned long)ioremap(cstm_mips_ixx_board_desc[i].window_addr, cstm_mips_ixx_board_desc[i].window_size);
+		cstm_mips_ixx_map[i].virt = ioremap(cstm_mips_ixx_board_desc[i].window_addr, cstm_mips_ixx_board_desc[i].window_size);
 		if (!cstm_mips_ixx_map[i].virt) {
 			printk(KERN_WARNING "Failed to ioremap\n");
 			return -EIO;
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/db1550-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/db1550-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/db1550-flash.c	2004-10-18 23:53:44.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/db1550-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,10 +1,10 @@
 /*
  * Flash memory access on Alchemy Db1550 board
  * 
- * $Id: db1550-flash.c,v 1.3 2004/07/14 17:45:40 dwmw2 Exp $
+ * $Id: db1550-flash.c,v 1.7 2004/11/04 13:24:14 gleixner Exp $
  *
  * (C) 2004 Embedded Edge, LLC, based on db1550-flash.c:
- * (C) 2003 Pete Popov <pete_popov@yahoo.com>
+ * (C) 2003, 2004 Pete Popov <ppopov@embeddedalley.com>
  * 
  */
 
@@ -19,7 +19,6 @@
 #include <linux/mtd/partitions.h>
 
 #include <asm/io.h>
-#include <asm/au1000.h>
 
 #ifdef 	DEBUG_RW
 #define	DBG(x...)	printk(x)
@@ -132,7 +131,7 @@
 			window_addr = 0x1C000000;
 			window_size = 0x4000000; 
 #else /* USER ONLY */
-			window_addr = 0x1E000000;
+			window_addr = 0x18000000;
 			window_size = 0x4000000; 
 #endif
 	return 0;
@@ -160,10 +159,9 @@
 	 * Now let's probe for the actual flash.  Do it here since
 	 * specific machine settings might have been set above.
 	 */
-	printk(KERN_NOTICE "Pb1550 flash: probing %d-bit flash bus\n", 
+	printk(KERN_NOTICE "Db1550 flash: probing %d-bit flash bus\n", 
 			db1550_map.bankwidth*8);
-	db1550_map.virt = 
-		(unsigned long)ioremap(window_addr, window_size);
+	db1550_map.virt = ioremap(window_addr, window_size);
 	mymtd = do_map_probe("cfi_probe", &db1550_map);
 	if (!mymtd) return -ENXIO;
 	mymtd->owner = THIS_MODULE;
@@ -177,6 +175,7 @@
 	if (mymtd) {
 		del_mtd_partitions(mymtd);
 		map_destroy(mymtd);
+		iounmap((void *) db1550_map.virt);
 	}
 }
 
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/db1x00-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/db1x00-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/db1x00-flash.c	2004-10-18 23:53:21.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/db1x00-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,9 +1,9 @@
 /*
  * Flash memory access on Alchemy Db1xxx boards
  * 
- * $Id: db1x00-flash.c,v 1.3 2004/07/14 17:45:40 dwmw2 Exp $
+ * $Id: db1x00-flash.c,v 1.6 2004/11/04 13:24:14 gleixner Exp $
  *
- * (C) 2003 Pete Popov <ppopov@pacbell.net>
+ * (C) 2003 Pete Popov <ppopov@embeddedalley.com>
  * 
  */
 
@@ -18,8 +18,6 @@
 #include <linux/mtd/partitions.h>
 
 #include <asm/io.h>
-#include <asm/au1000.h>
-#include <asm/db1x00.h>
 
 #ifdef 	DEBUG_RW
 #define	DBG(x...)	printk(x)
@@ -27,11 +25,20 @@
 #define	DBG(x...)	
 #endif
 
+/* MTD CONFIG OPTIONS */
+#if defined(CONFIG_MTD_DB1X00_BOOT) && defined(CONFIG_MTD_DB1X00_USER)
+#define DB1X00_BOTH_BANKS
+#elif defined(CONFIG_MTD_DB1X00_BOOT) && !defined(CONFIG_MTD_DB1X00_USER)
+#define DB1X00_BOOT_ONLY
+#elif !defined(CONFIG_MTD_DB1X00_BOOT) && defined(CONFIG_MTD_DB1X00_USER)
+#define DB1X00_USER_ONLY
+#endif
+
 static unsigned long window_addr;
 static unsigned long window_size;
 static unsigned long flash_size;
 
-static BCSR * const bcsr = (BCSR *)0xAE000000;
+static unsigned short *bcsr = (unsigned short *)0xAE000000;
 static unsigned char flash_bankwidth = 4;
 
 /* 
@@ -113,7 +120,7 @@
  */
 int setup_flash_params(void)
 {
-	switch ((bcsr->status >> 14) & 0x3) {
+	switch ((bcsr[2] >> 14) & 0x3) {
 		case 0: /* 64Mbit devices */
 			flash_size = 0x800000; /* 8MB per part */
 #if defined(DB1X00_BOTH_BANKS)
@@ -192,7 +199,7 @@
 	 */
 	printk(KERN_NOTICE "Db1xxx flash: probing %d-bit flash bus\n", 
 			db1xxx_mtd_map.bankwidth*8);
-	db1xxx_mtd_map.virt = (unsigned long)ioremap(window_addr, window_size);
+	db1xxx_mtd_map.virt = ioremap(window_addr, window_size);
 	db1xxx_mtd = do_map_probe("cfi_probe", &db1xxx_mtd_map);
 	if (!db1xxx_mtd) return -ENXIO;
 	db1xxx_mtd->owner = THIS_MODULE;
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/dbox2-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/dbox2-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/dbox2-flash.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/dbox2-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: dbox2-flash.c,v 1.11 2004/07/12 21:59:43 dwmw2 Exp $
+ * $Id: dbox2-flash.c,v 1.13 2004/11/04 13:24:14 gleixner Exp $
  *
  * D-Box 2 flash driver
  */
@@ -75,7 +75,7 @@
 int __init init_dbox2_flash(void)
 {
        	printk(KERN_NOTICE "D-Box 2 flash driver (size->0x%X mem->0x%X)\n", WINDOW_SIZE, WINDOW_ADDR);
-	dbox2_flash_map.virt = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	dbox2_flash_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE);
 
 	if (!dbox2_flash_map.virt) {
 		printk("Failed to ioremap\n");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/dc21285.c linuxppc-2.6.9-dream/drivers/mtd/maps/dc21285.c
--- linuxppc-2.6.9/drivers/mtd/maps/dc21285.c	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/dc21285.c	2005-06-20 10:46:11.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  * 
- * $Id: dc21285.c,v 1.20 2004/07/12 22:38:29 dwmw2 Exp $
+ * $Id: dc21285.c,v 1.22 2004/11/01 13:39:21 rmk Exp $
  */
 #include <linux/config.h>
 #include <linux/module.h>
@@ -32,7 +32,8 @@
  * is unpredictible. So we have a 25us penalty per
  * write access.
  */
-static void nw_en_write(void) {
+static void nw_en_write(void)
+{
 	extern spinlock_t gpio_lock;
 	unsigned long flags;
 
@@ -55,53 +56,60 @@
 
 static map_word dc21285_read8(struct map_info *map, unsigned long ofs)
 {
-	return *(uint8_t*)(map->map_priv_1 + ofs);
+	map_word val;
+	val.x[0] = *(uint8_t*)(map->virt + ofs);
+	return val;
 }
 
 static map_word dc21285_read16(struct map_info *map, unsigned long ofs)
 {
-	return *(uint16_t*)(map->map_priv_1 + ofs);
+	map_word val;
+	val.x[0] = *(uint16_t*)(map->virt + ofs);
+	return val;
 }
 
 static map_word dc21285_read32(struct map_info *map, unsigned long ofs)
 {
-	return *(uint32_t*)(map->map_priv_1 + ofs);
+	map_word val;
+	val.x[0] = *(uint32_t*)(map->virt + ofs);
+	return val;
 }
 
 static void dc21285_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
 {
-	memcpy(to, (void*)(map->map_priv_1 + from), len);
+	memcpy(to, (void*)(map->virt + from), len);
 }
 
-static void dc21285_write(struct map_info *map, map_word d, unsigned long adr)
+static void dc21285_write8(struct map_info *map, const map_word d, unsigned long adr)
 {
 	if (machine_is_netwinder())
 		nw_en_write();
 	*CSR_ROMWRITEREG = adr & 3;
 	adr &= ~3;
-	*(uint8_t*)(map->map_priv_1 + adr) = d.x[0];
+	*(uint8_t*)(map->virt + adr) = d.x[0];
 }
 
-static void dc21285_write16(struct map_info *map, map_word d, unsigned long adr)
+static void dc21285_write16(struct map_info *map, const map_word d, unsigned long adr)
 {
 	if (machine_is_netwinder())
 		nw_en_write();
 	*CSR_ROMWRITEREG = adr & 3;
 	adr &= ~3;
-	*(uint16_t*)(map->map_priv_1 + adr) = d.x[0];
+	*(uint16_t*)(map->virt + adr) = d.x[0];
 }
 
-static void dc21285_write32(struct map_info *map, map_word d, unsigned long adr)
+static void dc21285_write32(struct map_info *map, const map_word d, unsigned long adr)
 {
 	if (machine_is_netwinder())
 		nw_en_write();
-	*(uint32_t*)(map->map_priv_1 + adr) = d.x[0];
+	*(uint32_t*)(map->virt + adr) = d.x[0];
 }
 
 static void dc21285_copy_to_32(struct map_info *map, unsigned long to, const void *from, ssize_t len)
 {
 	while (len > 0) {
-		uint32_t d = *((uint32_t*)from)++;
+		map_word d;
+		d.x[0] = *((uint32_t*)from)++;
 		dc21285_write32(map, d, to);
 		to += 4;
 		len -= 4;
@@ -111,7 +119,8 @@
 static void dc21285_copy_to_16(struct map_info *map, unsigned long to, const void *from, ssize_t len)
 {
 	while (len > 0) {
-		uint16_t d = *((uint16_t*)from)++;
+		map_word d;
+		d.x[0] = *((uint16_t*)from)++;
 		dc21285_write16(map, d, to);
 		to += 2;
 		len -= 2;
@@ -120,7 +129,8 @@
 
 static void dc21285_copy_to_8(struct map_info *map, unsigned long to, const void *from, ssize_t len)
 {
-	uint8_t d = *((uint8_t*)from)++;
+	map_word d;
+	d.x[0] = *((uint8_t*)from)++;
 	dc21285_write8(map, d, to);
 	to++;
 	len--;
@@ -135,8 +145,8 @@
 
 
 /* Partition stuff */
-static struct mtd_partition *dc21285_parts;
 #ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition *dc21285_parts;
 static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
 #endif
   
@@ -163,10 +173,10 @@
 			break;
 		case SA110_CNTL_ROMWIDTH_32: 
 			dc21285_map.bankwidth = 4; 
-			break;
 			dc21285_map.read = dc21285_read32;
 			dc21285_map.write = dc21285_write32;
 			dc21285_map.copy_to = dc21285_copy_to_32;
+			break;
 		default:
 			printk (KERN_ERR "DC21285 flash: undefined bankwidth\n");
 			return -ENXIO;
@@ -175,8 +185,8 @@
 		dc21285_map.bankwidth*8);
 
 	/* Let's map the flash area */
-	dc21285_map.map_priv_1 = (unsigned long)ioremap(DC21285_FLASH, 16*1024*1024);
-	if (!dc21285_map.map_priv_1) {
+	dc21285_map.virt = ioremap(DC21285_FLASH, 16*1024*1024);
+	if (!dc21285_map.virt) {
 		printk("Failed to ioremap\n");
 		return -EIO;
 	}
@@ -188,14 +198,14 @@
 	}
 
 	if (!dc21285_mtd) {
-		iounmap((void *)dc21285_map.map_priv_1);
+		iounmap(dc21285_map.virt);
 		return -ENXIO;
 	}	
 	
 	dc21285_mtd->owner = THIS_MODULE;
 
 #ifdef CONFIG_MTD_PARTITIONS
-	nrparts = parse_mtd_partitions(dc21285_mtd, probes, &dc21285_parts, (void *)0);
+	nrparts = parse_mtd_partitions(dc21285_mtd, probes, &dc21285_parts, 0);
 	if (nrparts > 0)
 		add_mtd_partitions(dc21285_mtd, dc21285_parts, nrparts);
 	else	
@@ -231,7 +241,7 @@
 		del_mtd_device(dc21285_mtd);
 
 	map_destroy(dc21285_mtd);
-	iounmap((void *)dc21285_map.map_priv_1);
+	iounmap(dc21285_map.virt);
 }
 
 module_init(init_dc21285);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/dilnetpc.c linuxppc-2.6.9-dream/drivers/mtd/maps/dilnetpc.c
--- linuxppc-2.6.9/drivers/mtd/maps/dilnetpc.c	2004-10-18 23:53:43.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/dilnetpc.c	2005-06-20 10:46:11.000000000 +0200
@@ -14,7 +14,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  *
- * $Id: dilnetpc.c,v 1.13 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: dilnetpc.c,v 1.17 2004/11/28 09:40:39 dwmw2 Exp $
  *
  * The DIL/Net PC is a tiny embedded PC board made by SSV Embedded Systems
  * featuring the AMD Elan SC410 processor. There are two variants of this
@@ -197,7 +197,7 @@
 ************************************************************
 */
 
-static spinlock_t dnpc_spin   = SPIN_LOCK_UNLOCKED;
+static spinlock_t dnpc_spin = SPIN_LOCK_UNLOCKED;
 static int        vpp_counter = 0;
 /*
 ** This is what has to be done for the DNP board ..
@@ -403,7 +403,7 @@
 	printk(KERN_NOTICE "DIL/Net %s flash: 0x%lx at 0x%lx\n", 
 		is_dnp ? "DNPC" : "ADNP", dnpc_map.size, dnpc_map.phys);
 
-	dnpc_map.virt = (unsigned long)ioremap_nocache(dnpc_map.phys, dnpc_map.size);
+	dnpc_map.virt = ioremap_nocache(dnpc_map.phys, dnpc_map.size);
 
 	dnpc_map_flash(dnpc_map.phys, dnpc_map.size);
 
@@ -413,7 +413,7 @@
 	}
 	simple_map_init(&dnpc_map);
 
-	printk("FLASH virtual address: 0x%lx\n", dnpc_map.virt);
+	printk("FLASH virtual address: 0x%p\n", dnpc_map.virt);
 
 	mymtd = do_map_probe("jedec_probe", &dnpc_map);
 
@@ -430,7 +430,7 @@
 			mymtd->erasesize = 0x10000;
 
 	if (!mymtd) {
-		iounmap((void *)dnpc_map.virt);
+		iounmap(dnpc_map.virt);
 		return -ENXIO;
 	}
 		
@@ -481,9 +481,9 @@
 		map_destroy(mymtd);
 	}
 	if (dnpc_map.virt) {
-		iounmap((void *)dnpc_map.virt);
+		iounmap(dnpc_map.virt);
 		dnpc_unmap_flash();
-		dnpc_map.virt = 0;
+		dnpc_map.virt = NULL;
 	}
 }
 
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/dmv182.c linuxppc-2.6.9-dream/drivers/mtd/maps/dmv182.c
--- linuxppc-2.6.9/drivers/mtd/maps/dmv182.c	2004-10-18 23:53:21.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/dmv182.c	2005-06-20 10:46:11.000000000 +0200
@@ -4,7 +4,7 @@
  * 
  * Flash map driver for the Dy4 SVME182 board
  * 
- * $Id: dmv182.c,v 1.3 2004/07/14 17:45:40 dwmw2 Exp $
+ * $Id: dmv182.c,v 1.5 2004/11/04 13:24:14 gleixner Exp $
  *
  * Copyright 2003-2004, TimeSys Corporation
  *
@@ -103,8 +103,7 @@
 
 	partitions = svme182_partitions;
 
-	svme182_map.virt = 
-		(unsigned long)ioremap(FLASH_BASE_ADDR, svme182_map.size);
+	svme182_map.virt = ioremap(FLASH_BASE_ADDR, svme182_map.size);
 		
 	if (svme182_map.virt == 0) {
 		printk("Failed to ioremap FLASH memory area.\n");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/dreambox.c linuxppc-2.6.9-dream/drivers/mtd/maps/dreambox.c
--- linuxppc-2.6.9/drivers/mtd/maps/dreambox.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/dreambox.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,162 @@
+/*
+ * dreambox.c - mapper for DreamBOX board. based on redwood.c.
+ *
+ *
+ * Copyright 2002 Felix Domke <tmbinc@gmx.net>
+ *
+ * original:
+ * Copyright 2001 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  History: 12/17/2001 - Armin
+ *  		migrated to use do_map_probe
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+#define WINDOW_ADDR 0x7f800000
+#define WINDOW_SIZE 0x00800000
+
+#define VPP_SWITCHING
+
+volatile u32 *gpio=0;
+
+void dreambox_flash_set_vpp( struct map_info * map, int i)
+{
+#ifdef VPP_SWITCHING
+    gpio[1] |= (1 << 19);
+    gpio[2] &= ~(0x3 << 6);
+    gpio[4] &= ~(0x3 << 6);
+    gpio[6] &= ~(1 << 19);
+
+    if (i)
+	gpio[0] |= (1 << 19);
+    else
+	gpio[0] &= ~(1 << 19);
+#endif
+}
+
+struct map_info dreambox_flash_map = {
+	name: "DreamBOX rev3+",
+	size: WINDOW_SIZE,
+	bankwidth: 2,
+	set_vpp: dreambox_flash_set_vpp
+};
+
+static struct mtd_partition dreambox_flash_partitions[] = {
+	{
+		name: "DreamBOX cramfs+squashfs",
+		offset: 0x000000,
+		size:   0x600000,
+	},
+	{
+		name: "DreamBOX jffs2",
+		offset: 0x600000,
+		size:   0x1c0000,
+	},
+	{
+		name: "DreamBOX OpenBIOS",
+		offset: 0x7c0000,
+		size:   0x040000,
+		mask_flags: MTD_WRITEABLE       /* force read-only */
+	},
+	{
+		name: "DreamBOX (w/o bootloader)",
+		offset: 0,
+		size:   0x7c0000,
+	},
+	{
+		name: "DreamBOX (w/ bootloader)",
+		offset: 0,
+		size:   0x800000,
+		mask_flags: MTD_WRITEABLE       /* force read-only */
+	},
+	{
+		name: "DreamBOX SquashedFS",
+		offset: 0x120000,
+		size:	0x4e0000
+	},
+	{
+		name: "DreamBOX Cramfs",
+		offset: 0,
+		size:	0x120000
+	}
+};
+#define NUM_DREAMBOX_FLASH_PARTITIONS \
+	(sizeof(dreambox_flash_partitions)/sizeof(dreambox_flash_partitions[0]))
+
+static struct mtd_info *dreambox_mtd;
+
+int __init init_dreambox_flash(void)
+{
+	printk(KERN_NOTICE "dreambox: flash mapping: %x at %x\n",
+	       WINDOW_SIZE, WINDOW_ADDR);
+
+	dreambox_flash_map.phys = WINDOW_ADDR;
+	dreambox_flash_map.virt =
+		(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!dreambox_flash_map.virt) {
+		printk("init_dreambox_flash: failed to ioremap\n");
+		return -EIO;
+	}
+	
+	simple_map_init(&dreambox_flash_map);
+
+	dreambox_flash_map.map_priv_1 = 0;
+	dreambox_flash_map.map_priv_2 = 0;
+	dreambox_mtd = do_map_probe("cfi_probe", &dreambox_flash_map);
+
+	if (dreambox_mtd) {
+		gpio=ioremap(0x40060000, 4096);
+		dreambox_flash_set_vpp(0,0);
+		printk("disable flash VPP\n");
+		dreambox_mtd->owner = THIS_MODULE;
+		return add_mtd_partitions(dreambox_mtd,
+					  dreambox_flash_partitions,
+					  NUM_DREAMBOX_FLASH_PARTITIONS);
+	}
+
+	return -ENXIO;
+}
+
+static void __exit cleanup_dreambox_flash(void)
+{
+	if (dreambox_mtd) {
+		iounmap((void*)gpio);
+		del_mtd_partitions(dreambox_mtd);
+		iounmap((void *)dreambox_flash_map.virt);
+		map_destroy(dreambox_mtd);
+	}
+}
+
+module_init(init_dreambox_flash);
+module_exit(cleanup_dreambox_flash);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/ebony.c linuxppc-2.6.9-dream/drivers/mtd/maps/ebony.c
--- linuxppc-2.6.9/drivers/mtd/maps/ebony.c	2005-10-01 14:12:17.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/ebony.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,11 +1,11 @@
 /*
- * $Id: ebony.c,v 1.10 2004/07/12 21:59:44 dwmw2 Exp $
- *
+ * $Id: ebony.c,v 1.15 2004/12/09 18:39:54 holindho Exp $
+ * 
  * Mapping for Ebony user flash
  *
- * Matt Porter <mporter@mvista.com>
+ * Matt Porter <mporter@kernel.crashing.org>
  *
- * Copyright 2002-2003 MontaVista Software Inc.
+ * Copyright 2002-2004 MontaVista Software Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -21,9 +21,9 @@
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
 #include <linux/config.h>
+#include <linux/version.h>
 #include <asm/io.h>
 #include <asm/ibm44x.h>
-#include <asm/ibm44x.h>
 #include <platforms/4xx/ebony.h>
 
 static struct mtd_info *flash;
@@ -64,7 +64,7 @@
 int __init init_ebony(void)
 {
 	u8 fpga0_reg;
-	unsigned long fpga0_adr;
+	u8 __iomem *fpga0_adr;
 	unsigned long long small_flash_base, large_flash_base;
 
 	fpga0_adr = ioremap64(EBONY_FPGA_ADDR, 16);
@@ -93,8 +93,7 @@
 		large_flash_base = EBONY_LARGE_FLASH_HIGH;
 
 	ebony_small_map.phys = small_flash_base;
-	ebony_small_map.virt =
-		(unsigned long)ioremap64(small_flash_base,
+	ebony_small_map.virt = ioremap64(small_flash_base,
 					 ebony_small_map.size);
 
 	if (!ebony_small_map.virt) {
@@ -104,7 +103,7 @@
 
 	simple_map_init(&ebony_small_map);
 
-	flash = do_map_probe("map_rom", &ebony_small_map);
+	flash = do_map_probe("jedec_probe", &ebony_small_map);
 	if (flash) {
 		flash->owner = THIS_MODULE;
 		add_mtd_partitions(flash, ebony_small_partitions,
@@ -115,8 +114,7 @@
 	}
 
 	ebony_large_map.phys = large_flash_base;
-	ebony_large_map.virt =
-		(unsigned long)ioremap64(large_flash_base,
+	ebony_large_map.virt = ioremap64(large_flash_base,
 					 ebony_large_map.size);
 
 	if (!ebony_large_map.virt) {
@@ -126,7 +124,7 @@
 
 	simple_map_init(&ebony_large_map);
 
-	flash = do_map_probe("cfi_probe", &ebony_large_map);
+	flash = do_map_probe("jedec_probe", &ebony_large_map);
 	if (flash) {
 		flash->owner = THIS_MODULE;
 		add_mtd_partitions(flash, ebony_large_partitions,
@@ -147,13 +145,13 @@
 	}
 
 	if (ebony_small_map.virt) {
-		iounmap((void *)ebony_small_map.virt);
-		ebony_small_map.virt = 0;
+		iounmap(ebony_small_map.virt);
+		ebony_small_map.virt = NULL;
 	}
 
 	if (ebony_large_map.virt) {
-		iounmap((void *)ebony_large_map.virt);
-		ebony_large_map.virt = 0;
+		iounmap(ebony_large_map.virt);
+		ebony_large_map.virt = NULL;
 	}
 }
 
@@ -161,5 +159,5 @@
 module_exit(cleanup_ebony);
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Matt Porter <mporter@mvista.com>");
+MODULE_AUTHOR("Matt Porter <mporter@kernel.crashing.org>");
 MODULE_DESCRIPTION("MTD map and partitions for IBM 440GP Ebony boards");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/edb7312.c linuxppc-2.6.9-dream/drivers/mtd/maps/edb7312.c
--- linuxppc-2.6.9/drivers/mtd/maps/edb7312.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/edb7312.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: edb7312.c,v 1.11 2004/07/14 09:52:55 dwmw2 Exp $
+ * $Id: edb7312.c,v 1.13 2004/11/04 13:24:14 gleixner Exp $
  *
  * Handle mapping of the NOR flash on Cogent EDB7312 boards
  *
@@ -71,19 +71,18 @@
 
 #endif
 
-static int mtd_parts_nb;
-static struct mtd_partition *mtd_parts;
+static int                   mtd_parts_nb = 0;
+static struct mtd_partition *mtd_parts    = 0;
 
 int __init init_edb7312nor(void)
 {
 	static const char *rom_probe_types[] = PROBETYPES;
 	const char **type;
-	const char *part_type = NULL;
+	const char *part_type = 0;
 
        	printk(KERN_NOTICE MSG_PREFIX "0x%08x at 0x%08x\n", 
 	       WINDOW_SIZE, WINDOW_ADDR);
-	edb7312nor_map.virt = (unsigned long)
-	  ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	edb7312nor_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE);
 
 	if (!edb7312nor_map.virt) {
 		printk(MSG_PREFIX "failed to ioremap\n");
@@ -92,7 +91,7 @@
 	
 	simple_map_init(&edb7312nor_map);
 
-	mymtd = NULL;
+	mymtd = 0;
 	type = rom_probe_types;
 	for(; !mymtd && *type; type++) {
 		mymtd = do_map_probe(*type, &edb7312nor_map);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/elan-104nc.c linuxppc-2.6.9-dream/drivers/mtd/maps/elan-104nc.c
--- linuxppc-2.6.9/drivers/mtd/maps/elan-104nc.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/elan-104nc.c	2005-06-20 10:46:11.000000000 +0200
@@ -16,7 +16,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 
-   $Id: elan-104nc.c,v 1.21 2004/07/12 22:38:29 dwmw2 Exp $
+   $Id: elan-104nc.c,v 1.25 2004/11/28 09:40:39 dwmw2 Exp $
 
 The ELAN-104NC has up to 8 Mibyte of Intel StrataFlash (28F320/28F640) in x16
 mode.  This drivers uses the CFI probe and Intel Extended Command Set drivers.
@@ -53,7 +53,7 @@
 #define PAGE_IO_SIZE 2
 
 static volatile int page_in_window = -1; // Current page in window.
-static unsigned long iomapadr;
+static void __iomem *iomapadr;
 static spinlock_t elan_104nc_spin = SPIN_LOCK_UNLOCKED;
 
 /* partition_info gives details on the logical partitions that the split the 
@@ -182,15 +182,15 @@
 		map_destroy( all_mtd );
 	}
 
-	iounmap((void *)iomapadr);
+	iounmap(iomapadr);
 }
 
-int __init init_elan_104nc(void)
+static int __init init_elan_104nc(void)
 {
 	/* Urg! We use I/O port 0x22 without request_region()ing it,
 	   because it's already allocated to the PIC. */
 
-  	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);
+  	iomapadr = ioremap(WINDOW_START, WINDOW_LENGTH);
 	if (!iomapadr) {
 		printk( KERN_ERR"%s: failed to ioremap memory region\n",
 			elan_104nc_map.name );
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/epxa10db-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/epxa10db-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/epxa10db-flash.c	2004-10-18 23:54:54.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/epxa10db-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -5,7 +5,7 @@
  *  Copyright (C) 2001 Altera Corporation
  *  Copyright (C) 2001 Red Hat, Inc.
  *
- * $Id: epxa10db-flash.c,v 1.11 2004/07/12 21:59:44 dwmw2 Exp $ 
+ * $Id: epxa10db-flash.c,v 1.13 2004/11/04 13:24:14 gleixner Exp $ 
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -62,7 +62,7 @@
 	
 	printk(KERN_NOTICE "%s flash device: 0x%x at 0x%x\n", BOARD_NAME, FLASH_SIZE, FLASH_START);
 
-	epxa_map.virt = (unsigned long)ioremap(FLASH_START, FLASH_SIZE);
+	epxa_map.virt = ioremap(FLASH_START, FLASH_SIZE);
 	if (!epxa_map.virt) {
 		printk("Failed to ioremap %s flash\n",BOARD_NAME);
 		return -EIO;
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/fortunet.c linuxppc-2.6.9-dream/drivers/mtd/maps/fortunet.c
--- linuxppc-2.6.9/drivers/mtd/maps/fortunet.c	2004-10-18 23:53:43.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/fortunet.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,6 +1,6 @@
 /* fortunet.c memory map
  *
- * $Id: fortunet.c,v 1.7 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: fortunet.c,v 1.9 2004/11/04 13:24:14 gleixner Exp $
  */
 
 #include <linux/module.h>
@@ -209,8 +209,8 @@
 
 			map_regions[ix].map_info.phys =	map_regions[ix].window_addr_physical,
 
-			map_regions[ix].map_info.virt =
-				(int)ioremap_nocache(
+			map_regions[ix].map_info.virt = 
+				ioremap_nocache(
 				map_regions[ix].window_addr_physical,
 				map_regions[ix].map_info.size);
 			if(!map_regions[ix].map_info.virt)
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/h720x-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/h720x-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/h720x-flash.c	2004-10-18 23:53:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/h720x-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -2,7 +2,7 @@
  * Flash memory access on Hynix GMS30C7201/HMS30C7202 based 
  * evaluation boards
  * 
- * $Id: h720x-flash.c,v 1.9 2004/07/14 17:45:40 dwmw2 Exp $
+ * $Id: h720x-flash.c,v 1.11 2004/11/04 13:24:14 gleixner Exp $
  *
  * (C) 2002 Jungjun Kim <jungjun.kim@hynix.com>
  *     2003 Thomas Gleixner <tglx@linutronix.de>	
@@ -73,7 +73,7 @@
 
 	char	*part_type = NULL;
 	
-	h720x_map.virt = (unsigned long)ioremap(FLASH_PHYS, FLASH_SIZE);
+	h720x_map.virt = ioremap(FLASH_PHYS, FLASH_SIZE);
 
 	if (!h720x_map.virt) {
 		printk(KERN_ERR "H720x-MTD: ioremap failed\n");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/ichxrom.c linuxppc-2.6.9-dream/drivers/mtd/maps/ichxrom.c
--- linuxppc-2.6.9/drivers/mtd/maps/ichxrom.c	2004-10-18 23:53:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/ichxrom.c	2005-06-20 10:46:11.000000000 +0200
@@ -2,7 +2,7 @@
  * ichxrom.c
  *
  * Normal mappings of chips in physical memory
- * $Id: ichxrom.c,v 1.8 2004/07/16 17:43:11 dwmw2 Exp $
+ * $Id: ichxrom.c,v 1.16 2004/11/28 09:40:39 dwmw2 Exp $
  */
 
 #include <linux/module.h>
@@ -12,187 +12,87 @@
 #include <asm/io.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+#include <linux/mtd/flashchip.h>
 #include <linux/config.h>
 #include <linux/pci.h>
 #include <linux/pci_ids.h>
-#include <linux/mtd/cfi.h>
+#include <linux/list.h>
 
 #define xstr(s) str(s)
 #define str(s) #s
 #define MOD_NAME xstr(KBUILD_BASENAME)
 
-#define MTD_DEV_NAME_LENGTH 16
-
-#define RESERVE_MEM_REGION 0
-
+#define ADDRESS_NAME_LEN 18
 
-#define MANUFACTURER_INTEL	0x0089
-#define I82802AB	0x00ad
-#define I82802AC	0x00ac
+#define ROM_PROBE_STEP_SIZE (64*1024) /* 64KiB */
 
-#define ICHX_FWH_REGION_START	0xFF000000UL
-#define ICHX_FWH_REGION_SIZE	0x01000000UL
 #define BIOS_CNTL	0x4e
 #define FWH_DEC_EN1	0xE3
 #define FWH_DEC_EN2	0xF0
 #define FWH_SEL1	0xE8
 #define FWH_SEL2	0xEE
 
-struct ichxrom_map_info {
-	struct map_info map;
-	struct mtd_info *mtd;
-	unsigned long window_addr;
+struct ichxrom_window {
+	void __iomem* virt;
+	unsigned long phys;
+	unsigned long size;
+	struct list_head maps;
+	struct resource rsrc;
 	struct pci_dev *pdev;
-	struct resource window_rsrc;
-	struct resource rom_rsrc;
-	char mtd_name[MTD_DEV_NAME_LENGTH];
 };
 
-static inline unsigned long addr(struct map_info *map, unsigned long ofs)
-{
-	unsigned long offset;
-	offset = ((8*1024*1024) - map->size) + ofs;
-	if (offset >= (4*1024*1024)) {
-		offset += 0x400000;
-	}
-	return map->map_priv_1 + 0x400000 + offset;
-}
-
-static inline unsigned long dbg_addr(struct map_info *map, unsigned long addr)
-{
-	return addr - map->map_priv_1 + ICHX_FWH_REGION_START;
-}
-	
-static map_word ichxrom_read(struct map_info *map, unsigned long ofs)
-{
-	map_word val;
-	int i;
-	switch(map->bankwidth) {
-	case 1:	 val.x[0] = __raw_readb(addr(map, ofs)); break;
-	case 2:	 val.x[0] = __raw_readw(addr(map, ofs)); break;
-	case 4:	 val.x[0] = __raw_readl(addr(map, ofs)); break;
-#if BITS_PER_LONG >= 64
-	case 8:	 val.x[0] = __raw_readq(addr(map, ofs)); break;
-#endif
-	default: val.x[0] = 0; break;
-	}
-	for(i = 1; i < map_words(map); i++) {
-		val.x[i] = 0;
-	}
-	return val;
-}
-
-static void ichxrom_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
-{
-	memcpy_fromio(to, addr(map, from), len);
-}
-
-static void ichxrom_write(struct map_info *map, map_word d, unsigned long ofs)
-{
-	switch(map->bankwidth) {
-	case 1: __raw_writeb(d.x[0], addr(map,ofs)); break;
-	case 2: __raw_writew(d.x[0], addr(map,ofs)); break;
-	case 4: __raw_writel(d.x[0], addr(map,ofs)); break;
-#if BITS_PER_LONG >= 64
-	case 8: __raw_writeq(d.x[0], addr(map,ofs)); break;
-#endif
-	}
-	mb();
-}
-
-static void ichxrom_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
-{
-	memcpy_toio(addr(map, to), from, len);
-}
-
-static struct ichxrom_map_info ichxrom_map = {
-	.map = {
-		.name = MOD_NAME,
-		.phys = NO_XIP,
-		.size = 0,
-		.bankwidth = 1,
-		.read = ichxrom_read,
-		.copy_from = ichxrom_copy_from,
-		.write = ichxrom_write,
-		.copy_to = ichxrom_copy_to,
-		/* Firmware hubs only use vpp when being programmed
-		 * in a factory setting.  So in-place programming
-		 * needs to use a different method.
-		 */
-	},
-	/* remaining fields of structure are initialized to 0 */
+struct ichxrom_map_info {
+	struct list_head list;
+	struct map_info map;
+	struct mtd_info *mtd;
+	struct resource rsrc;
+	char map_name[sizeof(MOD_NAME) + 2 + ADDRESS_NAME_LEN];
 };
 
-enum fwh_lock_state {
-	FWH_DENY_WRITE = 1,
-	FWH_IMMUTABLE  = 2,
-	FWH_DENY_READ  = 4,
+static struct ichxrom_window ichxrom_window = {
+	.maps = LIST_HEAD_INIT(ichxrom_window.maps),
 };
 
-static void ichxrom_cleanup(struct ichxrom_map_info *info)
+static void ichxrom_cleanup(struct ichxrom_window *window)
 {
+	struct ichxrom_map_info *map, *scratch;
 	u16 word;
 
 	/* Disable writes through the rom window */
-	pci_read_config_word(info->pdev, BIOS_CNTL, &word);
-	pci_write_config_word(info->pdev, BIOS_CNTL, word & ~1);
-
-	if (info->mtd) {
-		del_mtd_device(info->mtd);
-		map_destroy(info->mtd);
-		info->mtd = NULL;
-		info->map.virt = 0;
-	}
-	if (info->rom_rsrc.parent)
-		release_resource(&info->rom_rsrc);
-	if (info->window_rsrc.parent)
-		release_resource(&info->window_rsrc);
-
-	if (info->window_addr) {
-		iounmap((void *)(info->window_addr));
-		info->window_addr = 0;
-	}
-}
+	pci_read_config_word(window->pdev, BIOS_CNTL, &word);
+	pci_write_config_word(window->pdev, BIOS_CNTL, word & ~1);
 
-
-static int ichxrom_set_lock_state(struct mtd_info *mtd, loff_t ofs, size_t len,
-	enum fwh_lock_state state)
-{
-	struct map_info *map = mtd->priv;
-	unsigned long start = ofs;
-	unsigned long end = start + len -1;
-
-	/* FIXME do I need to guard against concurrency here? */
-	/* round down to 64K boundaries */
-	start = start & ~0xFFFF;
-	end = end & ~0xFFFF;
-	while (start <= end) {
-		unsigned long ctrl_addr;
-		ctrl_addr = addr(map, start) - 0x400000 + 2;
-		writeb(state, ctrl_addr);
-		start = start + 0x10000;
+	/* Free all of the mtd devices */
+	list_for_each_entry_safe(map, scratch, &window->maps, list) {
+		if (map->rsrc.parent)
+			release_resource(&map->rsrc);
+		del_mtd_device(map->mtd);
+		map_destroy(map->mtd);
+		list_del(&map->list);
+		kfree(map);
+	}
+	if (window->rsrc.parent)
+		release_resource(&window->rsrc);
+	if (window->virt) {
+		iounmap(window->virt);
+		window->virt = NULL;
+		window->phys = 0;
+		window->size = 0;
+		window->pdev = NULL;
 	}
-	return 0;
 }
 
-static int ichxrom_lock(struct mtd_info *mtd, loff_t ofs, size_t len)
-{
-	return ichxrom_set_lock_state(mtd, ofs, len, FWH_DENY_WRITE);
-}
-
-static int ichxrom_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
-{
-	return ichxrom_set_lock_state(mtd, ofs, len, 0);
-}
 
 static int __devinit ichxrom_init_one (struct pci_dev *pdev,
 	const struct pci_device_id *ent)
 {
+	static char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL };
+	struct ichxrom_window *window = &ichxrom_window;
+	struct ichxrom_map_info *map = NULL;
+	unsigned long map_top;
+	u8 byte;
 	u16 word;
-	struct ichxrom_map_info *info = &ichxrom_map;
-	unsigned long map_size;
-	static char *probes[] = { "cfi_probe", "jedec_probe" };
-	struct cfi_private *cfi;
 
 	/* For now I just handle the ichx and I assume there
 	 * are not a lot of resources up at the top of the address
@@ -204,26 +104,56 @@
 	 * Also you can page firmware hubs if an 8MB window isn't enough 
 	 * but don't currently handle that case either.
 	 */
+	window->pdev = pdev;
 
-	info->pdev = pdev;
+	/* Find a region continuous to the end of the ROM window  */
+	window->phys = 0;
+	pci_read_config_byte(pdev, FWH_DEC_EN1, &byte);
+	if (byte == 0xff) {
+		window->phys = 0xffc00000;
+		pci_read_config_byte(pdev, FWH_DEC_EN2, &byte);
+		if ((byte & 0x0f) == 0x0f) {
+			window->phys = 0xff400000;
+		}
+		else if ((byte & 0x0e) == 0x0e) {
+			window->phys = 0xff500000;
+		}
+		else if ((byte & 0x0c) == 0x0c) {
+			window->phys = 0xff600000;
+		}
+		else if ((byte & 0x08) == 0x08) {
+			window->phys = 0xff700000;
+		}
+	}
+	else if ((byte & 0xfe) == 0xfe) {
+		window->phys = 0xffc80000;
+	}
+	else if ((byte & 0xfc) == 0xfc) {
+		window->phys = 0xffd00000;
+	}
+	else if ((byte & 0xf8) == 0xf8) {
+		window->phys = 0xffd80000;
+	}
+	else if ((byte & 0xf0) == 0xf0) {
+		window->phys = 0xffe00000;
+	}
+	else if ((byte & 0xe0) == 0xe0) {
+		window->phys = 0xffe80000;
+	}
+	else if ((byte & 0xc0) == 0xc0) {
+		window->phys = 0xfff00000;
+	}
+	else if ((byte & 0x80) == 0x80) {
+		window->phys = 0xfff80000; 
+	}
 
-	/*
-	 * Try to reserve the window mem region.  If this fails then
-	 * it is likely due to the window being "reseved" by the BIOS.
-	 */
-	info->window_rsrc.name = MOD_NAME;
-	info->window_rsrc.start = ICHX_FWH_REGION_START;
-	info->window_rsrc.end = ICHX_FWH_REGION_START + ICHX_FWH_REGION_SIZE - 1;
-	info->window_rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
-	if (request_resource(&iomem_resource, &info->window_rsrc)) {
-		info->window_rsrc.parent = NULL;
-		printk(KERN_ERR MOD_NAME
-		       " %s(): Unable to register resource"
-		       " 0x%.08lx-0x%.08lx - kernel bug?\n",
-		       __func__,
-		       info->window_rsrc.start, info->window_rsrc.end);
+	if (window->phys == 0) {
+		printk(KERN_ERR MOD_NAME ": Rom window is closed\n");
+		goto out;
 	}
-	
+	window->phys -= 0x400000UL;
+	window->size = (0xffffffffUL - window->phys) + 1UL;
+
 	/* Enable writes through the rom window */
 	pci_read_config_word(pdev, BIOS_CNTL, &word);
 	if (!(word & 1)  && (word & (1<<1))) {
@@ -231,119 +161,167 @@
 		 * this device, so don't even try.
 		 */
 		printk(KERN_ERR MOD_NAME ": firmware access control, I can't enable writes\n");
-		goto failed;
+		goto out;
 	}
 	pci_write_config_word(pdev, BIOS_CNTL, word | 1);
 
-
-	/* Map the firmware hub into my address space. */
-	/* Does this use too much virtual address space? */
-	info->window_addr = (unsigned long)ioremap(
-		ICHX_FWH_REGION_START, ICHX_FWH_REGION_SIZE);
-	if (!info->window_addr) {
-		printk(KERN_ERR "Failed to ioremap\n");
-		goto failed;
+	/*
+	 * Try to reserve the window mem region.  If this fails then
+	 * it is likely due to the window being "reseved" by the BIOS.
+	 */
+	window->rsrc.name = MOD_NAME;
+	window->rsrc.start = window->phys;
+	window->rsrc.end   = window->phys + window->size - 1;
+	window->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+	if (request_resource(&iomem_resource, &window->rsrc)) {
+		window->rsrc.parent = NULL;
+		printk(KERN_DEBUG MOD_NAME
+			": %s(): Unable to register resource"
+			" 0x%.08lx-0x%.08lx - kernel bug?\n",
+			__func__,
+			window->rsrc.start, window->rsrc.end);
 	}
 
-	/* For now assume the firmware has setup all relevant firmware
-	 * windows.  We don't have enough information to handle this case
-	 * intelligently.
+	/* Map the firmware hub into my address space. */
+	window->virt = ioremap_nocache(window->phys, window->size);
+	if (!window->virt) {
+		printk(KERN_ERR MOD_NAME ": ioremap(%08lx, %08lx) failed\n",
+			window->phys, window->size);
+		goto out;
+	}
+
+	/* Get the first address to look for an rom chip at */
+	map_top = window->phys;
+	if ((window->phys & 0x3fffff) != 0) {
+		map_top = window->phys + 0x400000;
+	}
+#if 1
+	/* The probe sequence run over the firmware hub lock
+	 * registers sets them to 0x7 (no access).
+	 * Probe at most the last 4M of the address space.
 	 */
+	if (map_top < 0xffc00000) {
+		map_top = 0xffc00000;
+	}
+#endif
+	/* Loop through and look for rom chips */
+	while((map_top - 1) < 0xffffffffUL) {
+		struct cfi_private *cfi;
+		unsigned long offset;
+		int i;
 
-	/* FIXME select the firmware hub and enable a window to it. */
-
-	info->mtd = NULL;
-	info->map.map_priv_1 = info->window_addr;
+		if (!map) {
+			map = kmalloc(sizeof(*map), GFP_KERNEL);
+		}
+		if (!map) {
+			printk(KERN_ERR MOD_NAME ": kmalloc failed");
+			goto out;
+		}
+		memset(map, 0, sizeof(*map));
+		INIT_LIST_HEAD(&map->list);
+		map->map.name = map->map_name;
+		map->map.phys = map_top;
+		offset = map_top - window->phys;
+		map->map.virt = (void __iomem *)
+			(((unsigned long)(window->virt)) + offset);
+		map->map.size = 0xffffffffUL - map_top + 1UL;
+		/* Set the name of the map to the address I am trying */
+		sprintf(map->map_name, "%s @%08lx",
+			MOD_NAME, map->map.phys);
 
-	/* Loop through the possible bankwidths */
-	for(ichxrom_map.map.bankwidth = 4; ichxrom_map.map.bankwidth; ichxrom_map.map.bankwidth >>= 1) {
-		map_size = ICHX_FWH_REGION_SIZE;
-		while(!info->mtd && (map_size > 0)) {
-			int i;
-			info->map.size = map_size;
-			for(i = 0; i < sizeof(probes)/sizeof(char *); i++) {
-				info->mtd = do_map_probe(probes[i], &ichxrom_map.map);
-				if (info->mtd)
-					break;
+		/* Firmware hubs only use vpp when being programmed
+		 * in a factory setting.  So in-place programming
+		 * needs to use a different method.
+		 */
+		for(map->map.bankwidth = 32; map->map.bankwidth; 
+			map->map.bankwidth >>= 1)
+		{
+			char **probe_type;
+			/* Skip bankwidths that are not supported */
+			if (!map_bankwidth_supported(map->map.bankwidth))
+				continue;
+
+			/* Setup the map methods */
+			simple_map_init(&map->map);
+
+			/* Try all of the probe methods */
+			probe_type = rom_probe_types;
+			for(; *probe_type; probe_type++) {
+				map->mtd = do_map_probe(*probe_type, &map->map);
+				if (map->mtd)
+					goto found;
 			}
-			map_size -= 512*1024;
 		}
-		if (info->mtd)
-			break;
-	}
-	if (!info->mtd) {
-		goto failed;
-	}
-	cfi = ichxrom_map.map.fldrv_priv;
-	if ((cfi->mfr == MANUFACTURER_INTEL) && (
-		    (cfi->id == I82802AB) ||
-		    (cfi->id == I82802AC))) 
-	{
-		/* If it is a firmware hub put in the special lock
-		 * and unlock routines.
-		 */
-		info->mtd->lock = ichxrom_lock;
-		info->mtd->unlock = ichxrom_unlock;
-	}
-	if (info->mtd->size > info->map.size) {
-		printk(KERN_WARNING MOD_NAME " rom(%u) larger than window(%lu). fixing...\n",
-		       info->mtd->size, info->map.size);
-		info->mtd->size = info->map.size;
-	}
+		map_top += ROM_PROBE_STEP_SIZE;
+		continue;
+	found:
+		/* Trim the size if we are larger than the map */
+		if (map->mtd->size > map->map.size) {
+			printk(KERN_WARNING MOD_NAME
+				" rom(%u) larger than window(%lu). fixing...\n",
+				map->mtd->size, map->map.size);
+			map->mtd->size = map->map.size;
+		}
+		if (window->rsrc.parent) {
+			/*
+			 * Registering the MTD device in iomem may not be possible
+			 * if there is a BIOS "reserved" and BUSY range.  If this
+			 * fails then continue anyway.
+			 */
+			map->rsrc.name  = map->map_name;
+			map->rsrc.start = map->map.phys;
+			map->rsrc.end   = map->map.phys + map->mtd->size - 1;
+			map->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+			if (request_resource(&window->rsrc, &map->rsrc)) {
+				printk(KERN_ERR MOD_NAME
+					": cannot reserve MTD resource\n");
+				map->rsrc.parent = NULL;
+			}
+		}
+
+		/* Make the whole region visible in the map */
+		map->map.virt = window->virt;
+		map->map.phys = window->phys;
+		cfi = map->map.fldrv_priv;
+		for(i = 0; i < cfi->numchips; i++) {
+			cfi->chips[i].start += offset;
+		}
 		
-	info->mtd->owner = THIS_MODULE;
-	add_mtd_device(info->mtd);
+		/* Now that the mtd devices is complete claim and export it */
+		map->mtd->owner = THIS_MODULE;
+		if (add_mtd_device(map->mtd)) {
+			map_destroy(map->mtd);
+			map->mtd = NULL;
+			goto out;
+		}
 
-	if (info->window_rsrc.parent) {
-		/*
-		 * Registering the MTD device in iomem may not be possible
-		 * if there is a BIOS "reserved" and BUSY range.  If this
-		 * fails then continue anyway.
-		 */
-		snprintf(info->mtd_name, MTD_DEV_NAME_LENGTH,
-			 "mtd%d", info->mtd->index);
 
-		info->rom_rsrc.name = info->mtd_name;
-		info->rom_rsrc.start = ICHX_FWH_REGION_START
-			+ ICHX_FWH_REGION_SIZE - map_size;
-		info->rom_rsrc.end = ICHX_FWH_REGION_START
-			+ ICHX_FWH_REGION_SIZE;
-		info->rom_rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
-		if (request_resource(&info->window_rsrc, &info->rom_rsrc)) {
-			printk(KERN_ERR MOD_NAME
-			       ": cannot reserve MTD resource\n");
-			info->rom_rsrc.parent = NULL;
-		}
-	}
+		/* Calculate the new value of map_top */
+		map_top += map->mtd->size;
 
+		/* File away the map structure */
+		list_add(&map->list, &window->maps);
+		map = NULL;
+	}
+
+ out:
+	/* Free any left over map structures */
+	if (map) {
+		kfree(map);
+	}
+	/* See if I have any map structures */
+	if (list_empty(&window->maps)) {
+		ichxrom_cleanup(window);
+		return -ENODEV;
+	}
 	return 0;
-
- failed:
-	ichxrom_cleanup(info);
-	return -ENODEV;
 }
 
 
 static void __devexit ichxrom_remove_one (struct pci_dev *pdev)
 {
-	struct ichxrom_map_info *info = &ichxrom_map;
-	u16 word;
-
-	del_mtd_device(info->mtd);
-	map_destroy(info->mtd);
-	info->mtd = NULL;
-	info->map.map_priv_1 = 0;
-
-	iounmap((void *)(info->window_addr));
-	info->window_addr = 0;
-
-	/* Disable writes through the rom window */
-	pci_read_config_word(pdev, BIOS_CNTL, &word);
-	pci_write_config_word(pdev, BIOS_CNTL, word & ~1);
-
-#if RESERVE_MEM_REGION	
-	release_mem_region(ICHX_FWH_REGION_START, ICHX_FWH_REGION_SIZE);
-#endif
+	struct ichxrom_window *window = &ichxrom_window;
+	ichxrom_cleanup(window);
 }
 
 static struct pci_device_id ichxrom_pci_tbl[] __devinitdata = {
@@ -371,8 +349,7 @@
 };
 #endif
 
-static struct pci_dev *mydev;
-int __init init_ichxrom(void)
+static int __init init_ichxrom(void)
 {
 	struct pci_dev *pdev;
 	struct pci_device_id *id;
@@ -385,7 +362,6 @@
 		}
 	}
 	if (pdev) {
-		mydev = pdev;
 		return ichxrom_init_one(pdev, &ichxrom_pci_tbl[0]);
 	}
 	return -ENXIO;
@@ -396,7 +372,7 @@
 
 static void __exit cleanup_ichxrom(void)
 {
-	ichxrom_remove_one(mydev);
+	ichxrom_remove_one(ichxrom_window.pdev);
 }
 
 module_init(init_ichxrom);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/impa7.c linuxppc-2.6.9-dream/drivers/mtd/maps/impa7.c
--- linuxppc-2.6.9/drivers/mtd/maps/impa7.c	2004-10-18 23:53:41.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/impa7.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: impa7.c,v 1.11 2004/07/14 09:52:55 dwmw2 Exp $
+ * $Id: impa7.c,v 1.13 2004/11/04 13:24:14 gleixner Exp $
  *
  * Handle mapping of the NOR flash on implementa A7 boards
  *
@@ -77,7 +77,7 @@
 {
 	static const char *rom_probe_types[] = PROBETYPES;
 	const char **type;
-	const char *part_type = NULL;
+	const char *part_type = 0;
 	int i;
 	static struct { u_long addr; u_long size; } pt[NUM_FLASHBANKS] = {
 	  { WINDOW_ADDR0, WINDOW_SIZE0 },
@@ -91,15 +91,14 @@
 		       pt[i].size, pt[i].addr);
 
 		impa7_map[i].phys = pt[i].addr;
-		impa7_map[i].virt = (unsigned long)
-		  ioremap(pt[i].addr, pt[i].size);
+		impa7_map[i].virt = ioremap(pt[i].addr, pt[i].size);
 		if (!impa7_map[i].virt) {
 			printk(MSG_PREFIX "failed to ioremap\n");
 			return -EIO;
 		}
 		simple_map_init(&impa7_map[i]);
 
-		impa7_mtd[i] = NULL;
+		impa7_mtd[i] = 0;
 		type = rom_probe_types;
 		for(; !impa7_mtd[i] && *type; type++) {
 			impa7_mtd[i] = do_map_probe(*type, &impa7_map[i]);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/integrator-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/integrator-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/integrator-flash.c	2004-10-18 23:55:43.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/integrator-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -22,7 +22,7 @@
    This is access code for flashes using ARM's flash partitioning 
    standards.
 
-   $Id: integrator-flash.c,v 1.16 2004/07/12 21:59:44 dwmw2 Exp $
+   $Id: integrator-flash.c,v 1.18 2004/11/01 13:26:15 rmk Exp $
 
 ======================================================================*/
 
@@ -75,7 +75,7 @@
 	unsigned int size = res->end - res->start + 1;
 	struct armflash_info *info;
 	int err;
-	void *base;
+	void __iomem *base;
 
 	info = kmalloc(sizeof(struct armflash_info), GFP_KERNEL);
 	if (!info) {
@@ -110,7 +110,7 @@
 	info->map.size		= size;
 	info->map.bankwidth	= plat->width;
 	info->map.phys		= res->start;
-	info->map.virt		= (unsigned long) base;
+	info->map.virt		= base;
 	info->map.name		= dev->dev.bus_id;
 	info->map.set_vpp	= armflash_set_vpp;
 
@@ -179,7 +179,7 @@
 		if (info->parts)
 			kfree(info->parts);
 
-		iounmap((void *)info->map.virt);
+		iounmap(info->map.virt);
 		release_resource(info->res);
 		kfree(info->res);
 
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/integrator-flash-v24.c linuxppc-2.6.9-dream/drivers/mtd/maps/integrator-flash-v24.c
--- linuxppc-2.6.9/drivers/mtd/maps/integrator-flash-v24.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/integrator-flash-v24.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,258 +0,0 @@
-/*======================================================================
-
-    drivers/mtd/maps/armflash.c: ARM Flash Layout/Partitioning
-  
-    Copyright (C) 2000 ARM Limited
-  
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-  
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-  
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-  
-   This is access code for flashes using ARM's flash partitioning 
-   standards.
-
-   $Id: integrator-flash-v24.c,v 1.13 2004/07/12 21:59:44 dwmw2 Exp $
-
-======================================================================*/
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/ioport.h>
-#include <linux/init.h>
-
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/map.h>
-#include <linux/mtd/partitions.h>
-
-#include <asm/hardware.h>
-#include <asm/io.h>
-#include <asm/system.h>
-
-// board specific stuff - sorry, it should be in arch/arm/mach-*.
-#ifdef CONFIG_ARCH_INTEGRATOR
-
-#define FLASH_BASE	INTEGRATOR_FLASH_BASE
-#define FLASH_SIZE	INTEGRATOR_FLASH_SIZE
-
-#define FLASH_PART_SIZE 0x400000
-
-#define SC_CTRLC	(IO_ADDRESS(INTEGRATOR_SC_BASE) + INTEGRATOR_SC_CTRLC_OFFSET)
-#define SC_CTRLS	(IO_ADDRESS(INTEGRATOR_SC_BASE) + INTEGRATOR_SC_CTRLS_OFFSET)
-#define EBI_CSR1	(IO_ADDRESS(INTEGRATOR_EBI_BASE) + INTEGRATOR_EBI_CSR1_OFFSET)
-#define EBI_LOCK	(IO_ADDRESS(INTEGRATOR_EBI_BASE) + INTEGRATOR_EBI_LOCK_OFFSET)
-
-/*
- * Initialise the flash access systems:
- *  - Disable VPP
- *  - Assert WP
- *  - Set write enable bit in EBI reg
- */
-static void armflash_flash_init(void)
-{
-	unsigned int tmp;
-
-	__raw_writel(INTEGRATOR_SC_CTRL_nFLVPPEN | INTEGRATOR_SC_CTRL_nFLWP, SC_CTRLC);
-
-	tmp = __raw_readl(EBI_CSR1) | INTEGRATOR_EBI_WRITE_ENABLE;
-	__raw_writel(tmp, EBI_CSR1);
-
-	if (!(__raw_readl(EBI_CSR1) & INTEGRATOR_EBI_WRITE_ENABLE)) {
-		__raw_writel(0xa05f, EBI_LOCK);
-		__raw_writel(tmp, EBI_CSR1);
-		__raw_writel(0, EBI_LOCK);
-	}
-}
-
-/*
- * Shutdown the flash access systems:
- *  - Disable VPP
- *  - Assert WP
- *  - Clear write enable bit in EBI reg
- */
-static void armflash_flash_exit(void)
-{
-	unsigned int tmp;
-
-	__raw_writel(INTEGRATOR_SC_CTRL_nFLVPPEN | INTEGRATOR_SC_CTRL_nFLWP, SC_CTRLC);
-
-	/*
-	 * Clear the write enable bit in system controller EBI register.
-	 */
-	tmp = __raw_readl(EBI_CSR1) & ~INTEGRATOR_EBI_WRITE_ENABLE;
-	__raw_writel(tmp, EBI_CSR1);
-
-	if (__raw_readl(EBI_CSR1) & INTEGRATOR_EBI_WRITE_ENABLE) {
-		__raw_writel(0xa05f, EBI_LOCK);
-		__raw_writel(tmp, EBI_CSR1);
-		__raw_writel(0, EBI_LOCK);
-	}
-}
-
-static void armflash_flash_wp(int on)
-{
-	unsigned int reg;
-
-	if (on)
-		reg = SC_CTRLC;
-	else
-		reg = SC_CTRLS;
-
-	__raw_writel(INTEGRATOR_SC_CTRL_nFLWP, reg);
-}
-
-static void armflash_set_vpp(struct map_info *map, int on)
-{
-	unsigned int reg;
-
-	if (on)
-		reg = SC_CTRLS;
-	else
-		reg = SC_CTRLC;
-
-	__raw_writel(INTEGRATOR_SC_CTRL_nFLVPPEN, reg);
-}
-#endif
-
-#ifdef CONFIG_ARCH_P720T
-
-#define FLASH_BASE		(0x04000000)
-#define FLASH_SIZE		(64*1024*1024)
-
-#define FLASH_PART_SIZE 	(4*1024*1024)
-#define FLASH_BLOCK_SIZE	(128*1024)
-
-static void armflash_flash_init(void)
-{
-}
-
-static void armflash_flash_exit(void)
-{
-}
-
-static void armflash_flash_wp(int on)
-{
-}
-
-static void armflash_set_vpp(struct map_info *map, int on)
-{
-}
-#endif
-
-
-static struct map_info armflash_map =
-{
-	.name =		"AFS",
-	.set_vpp =	armflash_set_vpp,
-	.phys =		FLASH_BASE,
-};
-
-static struct mtd_info *mtd;
-static struct mtd_partition *parts;
-static const char *probes[] = { "RedBoot", "afs", NULL };
-
-static int __init armflash_cfi_init(void *base, u_int size)
-{
-	int ret;
-
-	armflash_flash_init();
-	armflash_flash_wp(1);
-
-	/*
-	 * look for CFI based flash parts fitted to this board
-	 */
-	armflash_map.size       = size;
-	armflash_map.bankwidth   = 4;
-	armflash_map.virt = (unsigned long) base;
-
-	simple_map_init(&armflash_map);
-
-	/*
-	 * Also, the CFI layer automatically works out what size
-	 * of chips we have, and does the necessary identification
-	 * for us automatically.
-	 */
-	mtd = do_map_probe("cfi_probe", &armflash_map);
-	if (!mtd)
-		return -ENXIO;
-
-	mtd->owner = THIS_MODULE;
-
-	ret = parse_mtd_partitions(mtd, probes, &parts, (void *)0);
-	if (ret > 0) {
-		ret = add_mtd_partitions(mtd, parts, ret);
-		if (ret)
-			printk(KERN_ERR "mtd partition registration "
-				"failed: %d\n", ret);
-	}
-
-	/*
-	 * If we got an error, free all resources.
-	 */
-	if (ret < 0) {
-		del_mtd_partitions(mtd);
-		map_destroy(mtd);
-	}
-
-	return ret;
-}
-
-static void armflash_cfi_exit(void)
-{
-	if (mtd) {
-		del_mtd_partitions(mtd);
-		map_destroy(mtd);
-	}
-	if (parts)
-		kfree(parts);
-}
-
-static int __init armflash_init(void)
-{
-	int err = -EBUSY;
-	void *base;
-
-	if (request_mem_region(FLASH_BASE, FLASH_SIZE, "flash") == NULL)
-		goto out;
-
-	base = ioremap(FLASH_BASE, FLASH_SIZE);
-	err = -ENOMEM;
-	if (base == NULL)
-		goto release;
-
-	err = armflash_cfi_init(base, FLASH_SIZE);
-	if (err) {
-		iounmap(base);
-release:
-		release_mem_region(FLASH_BASE, FLASH_SIZE);
-	}
-out:
-	return err;
-}
-
-static void __exit armflash_exit(void)
-{
-	armflash_cfi_exit();
-	iounmap((void *)armflash_map.virt);
-	release_mem_region(FLASH_BASE, FLASH_SIZE);
-	armflash_flash_exit();
-}
-
-module_init(armflash_init);
-module_exit(armflash_exit);
-
-MODULE_AUTHOR("ARM Ltd");
-MODULE_DESCRIPTION("ARM Integrator CFI map driver");
-MODULE_LICENSE("GPL");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/ipaq-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/ipaq-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/ipaq-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/ipaq-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,464 @@
+/*
+ * Flash memory access on iPAQ Handhelds (either SA1100 or PXA250 based)
+ * 
+ * (C) 2000 Nicolas Pitre <nico@cam.org>
+ * (C) 2002 Hewlett-Packard Company <jamey.hicks@hp.com>
+ * (C) 2003 Christian Pellegrin <chri@ascensit.com>, <chri@infis.univ.ts.it>: concatenation of multiple flashes
+ * 
+ * $Id: ipaq-flash.c,v 1.3 2004/11/04 13:24:15 gleixner Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <asm/page.h>
+#include <asm/mach-types.h>
+#include <asm/system.h>
+#include <asm/errno.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#ifdef CONFIG_MTD_CONCAT
+#include <linux/mtd/concat.h>
+#endif
+
+#include <asm/hardware.h>
+#include <asm/arch-sa1100/h3600.h>
+#include <asm/io.h>
+
+
+#ifndef CONFIG_IPAQ_HANDHELD
+#error This is for iPAQ Handhelds only
+#endif
+#ifdef CONFIG_SA1100_JORNADA56X
+
+static void jornada56x_set_vpp(struct map_info *map, int vpp)
+{
+	if (vpp)
+		GPSR = GPIO_GPIO26;
+	else
+		GPCR = GPIO_GPIO26;
+	GPDR |= GPIO_GPIO26;
+}
+
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+
+static void jornada720_set_vpp(struct map_info *map, int vpp)
+{
+	if (vpp)
+		PPSR |= 0x80;
+	else
+		PPSR &= ~0x80;
+	PPDR |= 0x80;
+}
+
+#endif
+
+#define MAX_IPAQ_CS 2		/* Number of CS we are going to test */
+
+#define IPAQ_MAP_INIT(X) \
+	{ \
+		name:		"IPAQ flash " X, \
+	}
+
+
+static struct map_info ipaq_map[MAX_IPAQ_CS] = {
+	IPAQ_MAP_INIT("bank 1"),
+	IPAQ_MAP_INIT("bank 2")
+};
+
+static struct mtd_info *my_sub_mtd[MAX_IPAQ_CS] = {
+	NULL,
+	NULL
+};
+
+/*
+ * Here are partition information for all known IPAQ-based devices.
+ * See include/linux/mtd/partitions.h for definition of the mtd_partition
+ * structure.
+ *
+ * The *_max_flash_size is the maximum possible mapped flash size which
+ * is not necessarily the actual flash size.  It must be no more than
+ * the value specified in the "struct map_desc *_io_desc" mapping
+ * definition for the corresponding machine.
+ *
+ * Please keep these in alphabetical order, and formatted as per existing
+ * entries.  Thanks.
+ */
+
+#ifdef CONFIG_IPAQ_HANDHELD
+static unsigned long h3xxx_max_flash_size = 0x04000000;
+static struct mtd_partition h3xxx_partitions[] = {
+	{
+		name:		"H3XXX boot firmware",
+#ifndef CONFIG_LAB
+		size:		0x00040000,
+#else
+		size:		0x00080000,
+#endif
+		offset:		0,
+#ifndef CONFIG_LAB
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+#endif
+	}, 
+	{
+		name:		"H3XXX root jffs2",
+#ifndef CONFIG_LAB
+		size:		0x2000000 - 2*0x40000, /* Warning, this is fixed later */
+		offset:		0x00040000,
+#else
+		size:		0x2000000 - 0x40000 - 0x80000, /* Warning, this is fixed later */
+		offset:		0x00080000,
+#endif
+	},
+	{
+		name:		"asset",
+		size:		0x40000,
+		offset:		0x2000000 - 0x40000, /* Warning, this is fixed later */
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}
+};
+
+#ifndef CONFIG_MTD_CONCAT
+static struct mtd_partition h3xxx_partitions_bank2[] = {
+	/* this is used only on 2 CS machines when concat is not present */
+	{
+		name:		"second H3XXX root jffs2",
+		size:		0x1000000 - 0x40000, /* Warning, this is fixed later */
+		offset:		0x00000000,
+	},
+	{
+		name:		"second asset",
+		size:		0x40000,
+		offset:		0x1000000 - 0x40000, /* Warning, this is fixed later */
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}
+};
+#endif
+
+static spinlock_t ipaq_vpp_lock = SPIN_LOCK_UNLOCKED;
+
+static void h3xxx_set_vpp(struct map_info *map, int vpp)
+{
+	static int nest = 0;
+	
+	spin_lock(&ipaq_vpp_lock);
+	if (vpp)
+		nest++;
+	else
+		nest--;
+	if (nest)
+		assign_h3600_egpio(IPAQ_EGPIO_VPP_ON, 1);
+	else
+		assign_h3600_egpio(IPAQ_EGPIO_VPP_ON, 0);
+	spin_unlock(&ipaq_vpp_lock);
+}
+
+#endif
+
+#if defined(CONFIG_SA1100_JORNADA56X) || defined(CONFIG_SA1100_JORNADA720)
+static unsigned long jornada_max_flash_size = 0x02000000;
+static struct mtd_partition jornada_partitions[] = {
+	{
+		name:		"Jornada boot firmware",
+		size:		0x00040000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"Jornada root jffs2",
+		size:		MTDPART_SIZ_FULL,
+		offset:		0x00040000,
+	}
+};
+#endif
+
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+static unsigned long cs_phys[] = {
+#ifdef CONFIG_ARCH_SA1100
+	SA1100_CS0_PHYS,
+	SA1100_CS1_PHYS,
+	SA1100_CS2_PHYS,
+	SA1100_CS3_PHYS,
+	SA1100_CS4_PHYS,
+	SA1100_CS5_PHYS,
+#else 
+	PXA_CS0_PHYS,
+	PXA_CS1_PHYS,
+	PXA_CS2_PHYS,
+	PXA_CS3_PHYS,
+	PXA_CS4_PHYS,
+	PXA_CS5_PHYS,
+#endif
+};
+
+static const char *part_probes[] = { "cmdlinepart", "RedBoot", NULL };
+
+static int __init h1900_special_case(void);
+
+int __init ipaq_mtd_init(void)
+{
+	struct mtd_partition *parts = NULL;
+	int nb_parts = 0;
+	int parsed_nr_parts = 0;
+	const char *part_type;
+	int i; /* used when we have >1 flash chips */
+	unsigned long tot_flashsize = 0; /* used when we have >1 flash chips */
+
+	/* Default flash bankwidth */
+	// ipaq_map.bankwidth = (MSC0 & MSC_RBW) ? 2 : 4;
+	
+	if (machine_is_h1900())
+	{
+		/* For our intents, the h1900 is not a real iPAQ, so we special-case it. */
+		return h1900_special_case();
+	}
+
+	if (machine_is_h3100() || machine_is_h1900())
+		for(i=0; i<MAX_IPAQ_CS; i++)
+			ipaq_map[i].bankwidth = 2;
+	else
+		for(i=0; i<MAX_IPAQ_CS; i++)
+			ipaq_map[i].bankwidth = 4;
+			
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+
+	simple_map_init(&ipaq_map[0]);
+	simple_map_init(&ipaq_map[1]);
+
+#ifdef CONFIG_IPAQ_HANDHELD
+	if (machine_is_ipaq()) {
+		parts = h3xxx_partitions;
+		nb_parts = ARRAY_SIZE(h3xxx_partitions);
+		for(i=0; i<MAX_IPAQ_CS; i++) {
+			ipaq_map[i].size = h3xxx_max_flash_size;
+			ipaq_map[i].set_vpp = h3xxx_set_vpp;
+			ipaq_map[i].phys = cs_phys[i];
+			ipaq_map[i].virt = __ioremap(cs_phys[i], 0x04000000, 0, 1);
+			if (machine_is_h3100 () || machine_is_h1900())
+				ipaq_map[i].bankwidth = 2;
+		}
+		if (machine_is_h3600()) {
+			/* No asset partition here */
+			h3xxx_partitions[1].size += 0x40000;
+			nb_parts--;
+		}
+	}
+#endif
+#ifdef CONFIG_ARCH_H5400
+	if (machine_is_h5400()) {
+		ipaq_map[0].size = 0x02000000;
+		ipaq_map[1].size = 0x02000000;
+		ipaq_map[1].phys = 0x02000000;
+		ipaq_map[1].virt = ipaq_map[0].virt + 0x02000000;
+	}
+#endif
+#ifdef CONFIG_ARCH_H1900
+	if (machine_is_h1900()) {
+		ipaq_map[0].size = 0x00400000;
+		ipaq_map[1].size = 0x02000000;
+		ipaq_map[1].phys = 0x00080000;
+		ipaq_map[1].virt = ipaq_map[0].virt + 0x00080000;
+	}
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA56X
+	if (machine_is_jornada56x()) {
+		parts = jornada_partitions;
+		nb_parts = ARRAY_SIZE(jornada_partitions);
+		ipaq_map[0].size = jornada_max_flash_size;
+		ipaq_map[0].set_vpp = jornada56x_set_vpp;
+		ipaq_map[0].virt = (__u32)__ioremap(0x0, 0x04000000, 0, 1);
+	}
+#endif
+#ifdef CONFIG_SA1100_JORNADA720
+	if (machine_is_jornada720()) {
+		parts = jornada_partitions;
+		nb_parts = ARRAY_SIZE(jornada_partitions);
+		ipaq_map[0].size = jornada_max_flash_size;
+		ipaq_map[0].set_vpp = jornada720_set_vpp;
+	}
+#endif
+
+
+	if (machine_is_ipaq()) { /* for iPAQs only */
+		for(i=0; i<MAX_IPAQ_CS; i++) {
+			printk(KERN_NOTICE "iPAQ flash: probing %d-bit flash bus, window=%lx with CFI.\n", ipaq_map[i].bankwidth*8, ipaq_map[i].virt);
+			my_sub_mtd[i] = do_map_probe("cfi_probe", &ipaq_map[i]);
+			if (!my_sub_mtd[i]) {
+				printk(KERN_NOTICE "iPAQ flash: probing %d-bit flash bus, window=%lx with JEDEC.\n", ipaq_map[i].bankwidth*8, ipaq_map[i].virt);
+				my_sub_mtd[i] = do_map_probe("jedec_probe", &ipaq_map[i]);
+			}
+			if (!my_sub_mtd[i]) {
+				printk(KERN_NOTICE "iPAQ flash: failed to find flash.\n");
+				if (i)
+					break;
+				else
+					return -ENXIO;
+			} else
+				printk(KERN_NOTICE "iPAQ flash: found %d bytes\n", my_sub_mtd[i]->size);
+			
+			/* do we really need this debugging? --joshua 20030703 */
+			// printk("my_sub_mtd[%d]=%p\n", i, my_sub_mtd[i]);
+			my_sub_mtd[i]->owner = THIS_MODULE;
+			tot_flashsize += my_sub_mtd[i]->size;
+		}
+#ifdef CONFIG_MTD_CONCAT
+		/* fix the asset location */
+#	ifdef CONFIG_LAB
+		h3xxx_partitions[1].size = tot_flashsize - 0x40000 - 0x80000 /* extra big boot block */;
+#	else
+		h3xxx_partitions[1].size = tot_flashsize - 2 * 0x40000;
+#	endif
+		h3xxx_partitions[2].offset = tot_flashsize - 0x40000;
+		/* and concat the devices */
+		mymtd = mtd_concat_create(&my_sub_mtd[0], i,
+					  "ipaq");
+		if (!mymtd) {
+			printk("Cannot create iPAQ concat device\n");
+			return -ENXIO;
+		}
+#else
+		mymtd = my_sub_mtd[0];
+
+		/* 
+		 *In the very near future, command line partition parsing
+		 * will use the device name as 'mtd-id' instead of a value
+		 * passed to the parse_cmdline_partitions() routine. Since
+		 * the bootldr says 'ipaq', make sure it continues to work. 
+		 */
+		mymtd->name = "ipaq";
+
+		if ((machine_is_h3600())) {
+#	ifdef CONFIG_LAB
+			h3xxx_partitions[1].size = my_sub_mtd[0]->size - 0x80000;
+#	else
+			h3xxx_partitions[1].size = my_sub_mtd[0]->size - 0x40000;
+#	endif
+			nb_parts = 2;
+		} else {
+#	ifdef CONFIG_LAB
+			h3xxx_partitions[1].size = my_sub_mtd[0]->size - 0x40000 - 0x80000; /* extra big boot block */
+#	else
+			h3xxx_partitions[1].size = my_sub_mtd[0]->size - 2*0x40000;
+#	endif
+			h3xxx_partitions[2].offset = my_sub_mtd[0]->size - 0x40000;
+		}
+
+		if (my_sub_mtd[1]) {
+#	ifdef CONFIG_LAB
+			h3xxx_partitions_bank2[0].size = my_sub_mtd[1]->size - 0x80000;
+#	else
+			h3xxx_partitions_bank2[0].size = my_sub_mtd[1]->size - 0x40000;
+#	endif
+			h3xxx_partitions_bank2[1].offset = my_sub_mtd[1]->size - 0x40000;
+		}
+#endif
+	}
+	else {
+		/*
+		 * Now let's probe for the actual flash.  Do it here since
+		 * specific machine settings might have been set above.
+		 */
+		printk(KERN_NOTICE "IPAQ flash: probing %d-bit flash bus, window=%lx\n", ipaq_map[0].bankwidth*8, ipaq_map[0].virt);
+		mymtd = do_map_probe("cfi_probe", &ipaq_map[0]);
+		if (!mymtd)
+			return -ENXIO;
+		mymtd->owner = THIS_MODULE;
+	}
+
+
+	/*
+	 * Dynamic partition selection stuff (might override the static ones)
+	 */
+
+	 i = parse_mtd_partitions(mymtd, part_probes, &parsed_parts, 0);
+			
+	 if (i > 0) {
+		 nb_parts = parsed_nr_parts = i;
+		 parts = parsed_parts;
+		 part_type = "dynamic";
+	 }
+
+	 if (!parts) {
+		 printk(KERN_NOTICE "IPAQ flash: no partition info available, registering whole flash at once\n");
+		 add_mtd_device(mymtd);
+#ifndef CONFIG_MTD_CONCAT
+		 if (my_sub_mtd[1])
+			 add_mtd_device(my_sub_mtd[1]);
+#endif
+	 } else {
+		 printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+		 add_mtd_partitions(mymtd, parts, nb_parts);
+#ifndef CONFIG_MTD_CONCAT
+		 if (my_sub_mtd[1])
+			 add_mtd_partitions(my_sub_mtd[1], h3xxx_partitions_bank2, ARRAY_SIZE(h3xxx_partitions_bank2));
+#endif
+	 }
+
+	 return 0;
+}
+
+static void __exit ipaq_mtd_cleanup(void)
+{
+	int i;
+
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+#ifndef CONFIG_MTD_CONCAT
+		if (my_sub_mtd[1])
+			del_mtd_partitions(my_sub_mtd[1]);
+#endif
+		map_destroy(mymtd);
+#ifdef CONFIG_MTD_CONCAT
+		for(i=0; i<MAX_IPAQ_CS; i++) 
+#else
+			for(i=1; i<MAX_IPAQ_CS; i++) 
+#endif		  
+			{
+				if (my_sub_mtd[i])
+					map_destroy(my_sub_mtd[i]);
+			}
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+static int __init h1900_special_case(void)
+{
+	/* The iPAQ h1900 is a special case - it has weird ROM. */
+	simple_map_init(&ipaq_map[0]);
+	ipaq_map[0].size = 0x80000;
+	ipaq_map[0].set_vpp = h3xxx_set_vpp;
+	ipaq_map[0].phys = 0x0;
+	ipaq_map[0].virt = __ioremap(0x0, 0x04000000, 0, 1);
+	ipaq_map[0].bankwidth = 2;
+	
+	printk(KERN_NOTICE "iPAQ flash: probing %d-bit flash bus, window=%lx with JEDEC.\n", ipaq_map[0].bankwidth*8, ipaq_map[0].virt);
+	mymtd = do_map_probe("jedec_probe", &ipaq_map[0]);
+	if (!mymtd)
+		return -ENODEV;
+	add_mtd_device(mymtd);
+	printk(KERN_NOTICE "iPAQ flash: registered h1910 flash\n");
+	
+	return 0;
+}
+
+module_init(ipaq_mtd_init);
+module_exit(ipaq_mtd_cleanup);
+
+MODULE_AUTHOR("Jamey Hicks");
+MODULE_DESCRIPTION("IPAQ CFI map driver");
+MODULE_LICENSE("MIT");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/iq80310.c linuxppc-2.6.9-dream/drivers/mtd/maps/iq80310.c
--- linuxppc-2.6.9/drivers/mtd/maps/iq80310.c	2004-10-18 23:55:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/iq80310.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: iq80310.c,v 1.18 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: iq80310.c,v 1.20 2004/11/04 13:24:15 gleixner Exp $
  *
  * Mapping for the Intel XScale IQ80310 evaluation board
  *
@@ -68,7 +68,7 @@
 	int parsed_nr_parts = 0;
 	int ret;
 
-	iq80310_map.virt = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	iq80310_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE);
 	if (!iq80310_map.virt) {
 		printk("Failed to ioremap\n");
 		return -EIO;
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/ixp2000.c linuxppc-2.6.9-dream/drivers/mtd/maps/ixp2000.c
--- linuxppc-2.6.9/drivers/mtd/maps/ixp2000.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/ixp2000.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: ixp2000.c,v 1.1 2004/09/02 00:13:41 dsaxena Exp $
+ * $Id: ixp2000.c,v 1.5 2004/11/16 17:15:48 dsaxena Exp $
  *
  * drivers/mtd/maps/ixp2000.c
  *
@@ -14,7 +14,7 @@
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
- *
+ * 
  */
 
 #include <linux/module.h>
@@ -44,8 +44,8 @@
 };
 
 static inline unsigned long flash_bank_setup(struct map_info *map, unsigned long ofs)
-{
-	unsigned long (*set_bank)(unsigned long) =
+{	
+	unsigned long (*set_bank)(unsigned long) = 
 		(unsigned long(*)(unsigned long))map->map_priv_2;
 
 	return (set_bank ? set_bank(ofs) : ofs);
@@ -53,15 +53,15 @@
 
 #ifdef __ARMEB__
 /*
- * Rev A0 and A1 of IXP2400 silicon have a broken addressing unit which
- * causes the lower address bits to be XORed with 0x11 on 8 bit accesses
- * and XORed with 0x10 on 16 bit accesses. See the spec update, erratta 44.
+ * Rev A0 and A1 of IXP2400 silicon have a broken addressing unit which 
+ * causes the lower address bits to be XORed with 0x11 on 8 bit accesses 
+ * and XORed with 0x10 on 16 bit accesses. See the spec update, erratum 44.
  */
-static int errata44_workaround = 0;
+static int erratum44_workaround = 0;
 
 static inline unsigned long address_fix8_write(unsigned long addr)
 {
-	if (errata44_workaround) {
+	if (erratum44_workaround) {
 		return (addr ^ 3);
 	}
 	return addr;
@@ -88,7 +88,7 @@
 			      unsigned long from, ssize_t len)
 {
 	from = flash_bank_setup(map, from);
-	while(len--)
+	while(len--) 
 		*(__u8 *) to++ = *(__u8 *)(map->map_priv_1 + from++);
 }
 
@@ -127,8 +127,8 @@
 	if (info->map.map_priv_1)
 		iounmap((void *) info->map.map_priv_1);
 
-	if (info->partitions)
-		kfree(info->partitions);
+	if (info->partitions) {
+		kfree(info->partitions); }
 
 	if (info->res) {
 		release_resource(info->res);
@@ -147,11 +147,11 @@
 	static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
 	struct platform_device *dev = to_platform_device(_dev);
 	struct ixp2000_flash_data *ixp_data = dev->dev.platform_data;
-	struct flash_platform_data *plat;
+	struct flash_platform_data *plat; 
 	struct ixp2000_flash_info *info;
 	unsigned long window_size;
 	int err = -1;
-
+	
 	if (!ixp_data)
 		return -ENODEV;
 
@@ -160,7 +160,7 @@
 		return -ENODEV;
 
 	window_size = dev->resource->end - dev->resource->start + 1;
-	dev_info(_dev, "Probe of IXP2000 flash(%d banks x %dM)\n",
+	dev_info(_dev, "Probe of IXP2000 flash(%d banks x %dMiB)\n", 
 			ixp_data->nr_banks, ((u32)window_size >> 20));
 
 	if (plat->width != 1) {
@@ -173,7 +173,7 @@
 	if(!info) {
 		err = -ENOMEM;
 		goto Error;
-	}
+	}	
 	memzero(info, sizeof(struct ixp2000_flash_info));
 
 	dev_set_drvdata(&dev->dev, info);
@@ -183,7 +183,7 @@
 	 * not attempt to do a direct access on us.
 	 */
 	info->map.phys = NO_XIP;
-
+	
 	info->nr_banks = ixp_data->nr_banks;
 	info->map.size = ixp_data->nr_banks * window_size;
 	info->map.bankwidth = 1;
@@ -191,7 +191,7 @@
 	/*
  	 * map_priv_2 is used to store a ptr to to the bank_setup routine
  	 */
-	info->map.map_priv_2 = (u32) ixp_data->bank_setup;
+	info->map.map_priv_2 = (void __iomem *) ixp_data->bank_setup;
 
 	info->map.name = dev->dev.bus_id;
 	info->map.read = ixp2000_flash_read8;
@@ -199,8 +199,8 @@
 	info->map.copy_from = ixp2000_flash_copy_from;
 	info->map.copy_to = ixp2000_flash_copy_to;
 
-	info->res = request_mem_region(dev->resource->start,
-			dev->resource->end - dev->resource->start + 1,
+	info->res = request_mem_region(dev->resource->start, 
+			dev->resource->end - dev->resource->start + 1, 
 			dev->dev.bus_id);
 	if (!info->res) {
 		dev_err(_dev, "Could not reserve memory region\n");
@@ -208,9 +208,8 @@
 		goto Error;
 	}
 
-	info->map.map_priv_1 =
-	    (unsigned long) ioremap(dev->resource->start,
-				    dev->resource->end - dev->resource->start + 1);
+	info->map.map_priv_1 = ioremap(dev->resource->start, 
+			    	dev->resource->end - dev->resource->start + 1);
 	if (!info->map.map_priv_1) {
 		dev_err(_dev, "Failed to ioremap flash region\n");
 		err = -EIO;
@@ -224,12 +223,12 @@
 
 #if defined(__ARMEB__)
 	/*
-	 * Enable errata 44 workaround for NPUs with broken slowport
+	 * Enable erratum 44 workaround for NPUs with broken slowport
 	 */
 
-	errata44_workaround = ixp2000_has_broken_slowport();
-	dev_info(_dev, "Errata 44 workaround %s\n",
-	       errata44_workaround ? "enabled" : "disabled");
+	erratum44_workaround = ixp2000_has_broken_slowport();
+	dev_info(_dev, "Erratum 44 workaround %s\n",
+	       erratum44_workaround ? "enabled" : "disabled");
 #endif
 
 	info->mtd = do_map_probe(plat->map_name, &info->map);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/ixp4xx.c linuxppc-2.6.9-dream/drivers/mtd/maps/ixp4xx.c
--- linuxppc-2.6.9/drivers/mtd/maps/ixp4xx.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/ixp4xx.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: ixp4xx.c,v 1.6 2004/09/17 00:25:06 gleixner Exp $
+ * $Id: ixp4xx.c,v 1.7 2004/11/04 13:24:15 gleixner Exp $
  *
  * drivers/mtd/maps/ixp4xx.c
  *
@@ -69,7 +69,7 @@
 		dest[len - 1] = BYTE0(src[i]);
 }
 
-/*
+/* 
  * Unaligned writes are ignored, causing the 8-bit
  * probe to fail and proceed to the 16-bit probe (which succeeds).
  */
@@ -79,7 +79,7 @@
 	       *(__u16 *) (map->map_priv_1 + adr) = d.x[0];
 }
 
-/*
+/* 
  * Fast write16 function without the probing check above
  */
 static void ixp4xx_write16(struct map_info *map, map_word d, unsigned long adr)
@@ -196,9 +196,8 @@
 		goto Error;
 	}
 
-	info->map.map_priv_1 =
-	    (void __iomem *) ioremap(dev->resource->start,
-				    dev->resource->end - dev->resource->start + 1);
+	info->map.map_priv_1 = ioremap(dev->resource->start,
+			    dev->resource->end - dev->resource->start + 1);
 	if (!info->map.map_priv_1) {
 		printk(KERN_ERR "IXP4XXFlash: Failed to ioremap region\n");
 		err = -EIO;
@@ -212,7 +211,7 @@
 		goto Error;
 	}
 	info->mtd->owner = THIS_MODULE;
-
+	
 	/* Use the fast version */
 	info->map.write = ixp4xx_write16,
 
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/Kconfig linuxppc-2.6.9-dream/drivers/mtd/maps/Kconfig
--- linuxppc-2.6.9/drivers/mtd/maps/Kconfig	2005-10-01 14:12:17.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/Kconfig	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 # drivers/mtd/maps/Kconfig
-# $Id: Kconfig,v 1.30 2004/07/21 00:16:14 jwboyer Exp $
+# $Id: Kconfig,v 1.42 2005/01/05 16:59:50 dwmw2 Exp $
 
 menu "Mapping drivers for chip access"
 	depends on MTD!=n
@@ -92,6 +92,25 @@
 	  demonstration board. If you have one of these boards and would like 
 	  to use the flash chips on it, say 'Y'.
 
+config MTD_TS5500
+	tristate "JEDEC Flash device mapped on Technologic Systems TS-5500"
+	depends on X86 && MTD_JEDECPROBE && MTD_PARTITIONS
+	help
+	  This provides a driver for the on-board flash of the Technologic
+	  System's TS-5500 board. The flash is split into 3 partitions
+	  which are accessed as separate MTD devices.
+
+	  mtd0 and mtd2 are the two BIOS drives. Unfortunately the BIOS
+	  uses a proprietary flash translation layer from General Software,
+	  which is not supported (the drives cannot be mounted). You can
+	  create your own file system (jffs for example), but the BIOS
+	  won't be able to boot from it.
+
+	  mtd1 allows you to reprogram your BIOS. BE VERY CAREFUL.
+
+	  Note that jumper 3 ("Write Enable Drive A") must be set
+	  otherwise detection won't succeeed.
+
 config MTD_SBC_GXX
 	tristate "CFI Flash device mapped on Arcom SBC-GXx boards"
 	depends on X86 && MTD_CFI_INTELEXT && MTD_PARTITIONS && MTD_COMPLEX_MAPPINGS
@@ -140,7 +159,7 @@
 
 config MTD_SCx200_DOCFLASH
 	tristate "Flash device mapped with DOCCS on NatSemi SCx200"
-	depends on X86 && MTD_CFI
+	depends on X86 && MTD_CFI && MTD_PARTITIONS
 	help
 	  Enable support for a flash chip mapped using the DOCCS signal on a
 	  National Semiconductor SCx200 processor.
@@ -160,7 +179,7 @@
 
 config MTD_ICHXROM
 	tristate "BIOS flash chip on Intel Controller Hub 2/3/4/5"
-	depends on X86 && MTD_JEDECPROBE && MTD_COMPLEX_MAPPINGS
+	depends on X86 && MTD_JEDECPROBE
 	help
 	  Support for treating the BIOS flash chip on ICHX motherboards
 	  as an MTD device - with this you can reprogram your BIOS.
@@ -335,7 +354,7 @@
 	tristate "CFI Flash device mapping on FlagaDM"
 	depends on PPC32 && 8xx && MTD_CFI
 	help
-	  Mapping for the Flaga digital module. If you dont have one, ignore
+	  Mapping for the Flaga digital module. If you don't have one, ignore
 	  this setting.
 
 config MTD_BEECH
@@ -354,16 +373,32 @@
 	  Arctic board. If you have one of these boards and would like to
 	  use the flash chips on it, say 'Y'.
 
+config MTD_WALNUT
+	tristate "Flash device mapped on IBM 405GP Walnut"
+	depends on MTD_JEDECPROBE && PPC32 && 40x && WALNUT
+	help
+	  This enables access routines for the flash chips on the IBM 405GP
+	  Walnut board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+	  
+config MTD_DREAMBOX
+	tristate "CFI Flash devices mapped on Dreambox"
+	depends on MTD_CFI && PPC32 && 4xx && 40x && (DM7000 || DM56xx)
+	default y
+	help
+	  This enables access routines for the flash chips on the Dreambox (DM7000).
+	  If you have a dreambox then say 'Y' here.	
+
 config MTD_EBONY
-	tristate "CFI Flash device mapped on IBM 440GP Ebony"
-	depends on MTD_CFI && PPC32 && 44x && EBONY
+	tristate "Flash devices mapped on IBM 440GP Ebony"
+	depends on MTD_JEDECPROBE && PPC32 && 44x && EBONY
 	help
 	  This enables access routines for the flash chips on the IBM 440GP
 	  Ebony board. If you have one of these boards and would like to
 	  use the flash chips on it, say 'Y'.
 
 config MTD_OCOTEA
-	tristate "CFI Flash device mapped on IBM 440GX Ocotea"
+	tristate "Flash devices mapped on IBM 440GX Ocotea"
 	depends on MTD_CFI && PPC32 && 44x && OCOTEA
 	help
 	  This enables access routines for the flash chips on the IBM 440GX
@@ -378,11 +413,19 @@
 	  Redwood board. If you have one of these boards and would like to
 	  use the flash chips on it, say 'Y'.
 
+config MTD_CHESTNUT
+	tristate "CFI Flash devices mapped on IBM 750FX or IBM 750GX Eval Boards"
+	depends on MTD_CFI && PPC32 && CHESTNUT && MTD_PARTITIONS
+	help
+	  This enables access routines for the flash chips on the IBM
+	  750FX and 750GX Eval Boards. If you have one of these boards and
+	  would like to use the flash chips on it, say 'Y'
+
 config MTD_CSTM_MIPS_IXX
 	tristate "Flash chip mapping on ITE QED-4N-S01B, Globespan IVR or custom board"
 	depends on MIPS && MTD_CFI && MTD_JEDECPROBE && MTD_PARTITIONS
 	help
-	  This provides a mapping driver for the Integrated Tecnology
+	  This provides a mapping driver for the Integrated Technology
 	  Express, Inc (ITE) QED-4N-S01B eval board and the Globespan IVR
 	  Reference Board. It provides the necessary addressing, length,
 	  buswidth, vpp code and addition setup of the flash device for
@@ -456,6 +499,12 @@
 	  the SA1100 and SA1110, including the Assabet and the Compaq iPAQ.
 	  If you have such a board, say 'Y'.
 
+config MTD_IPAQ
+	tristate "CFI Flash device mapped on Compaq/HP iPAQ"
+	depends on ARM && IPAQ_HANDHELD && MTD_CFI
+	help
+	  This provides a driver for the on-board flash of the iPAQ.
+
 config MTD_DC21285
 	tristate "CFI Flash device mapped on DC21285 Footbridge"
 	depends on ARM && MTD_CFI && ARCH_FOOTBRIDGE && MTD_COMPLEX_MAPPINGS
@@ -476,7 +525,7 @@
 	tristate "CFI Flash device mapped on Intel IXP4xx based systems"
 	depends on ARM && MTD_CFI && MTD_COMPLEX_MAPPINGS && ARCH_IXP4XX
 	help
-	  This eables MTD access to flash devices on platforms based 
+	  This enables MTD access to flash devices on platforms based 
 	  on Intel's IXP4xx family of network processors such as the
 	  IXDP425 and Coyote. If you have an IXP4xx based board and
 	  would like to use the flash chips on it, say 'Y'.
@@ -485,9 +534,9 @@
 	tristate "CFI Flash device mapped on Intel IXP2000 based systems"
 	depends on ARM && MTD_CFI && MTD_COMPLEX_MAPPINGS && ARCH_IXP2000
 	help
-	  This enables MTD access to flash devices on platforms based
+	  This enables MTD access to flash devices on platforms based 
 	  on Intel's IXP2000 family of network processors such as the
-	  IXDP2400 and IXDP2401. If you have an IXP2000 based board and
+	  IXDP425 and Coyote. If you have an IXP2000 based board and
 	  would like to use the flash chips on it, say 'Y'.
 
 config MTD_EPXA10DB
@@ -603,5 +652,28 @@
         help
           Map driver for Dy-4 SVME/DMV-182 board.
 
+config MTD_BAST
+	tristate "Map driver for Simtec BAST (EB2410ITX)"
+	depends on ARCH_BAST
+	select MTD_PARTITIONS
+	select MTD_MAP_BANK_WIDTH_16
+	select MTD_JEDECPROBE
+	help
+	  Map driver for NOR flash on the Simtec BAST (EB2410ITX).
+
+	  Note, this driver *cannot* over-ride the WP link on the
+	  board, or currently detect the state of the link.
+
+config MTD_BAST_MAXSIZE
+	int "Maximum size for BAST flash area (MiB)"
+	depends on MTD_BAST
+	default "4"
+
+config MTD_SHARP_SL
+	bool "ROM maped on Sharp SL Series"
+	depends on MTD && ARCH_PXA
+	help
+	  This enables access to the flash chip on the Sharp SL Series of PDAs.
+
 endmenu
 
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/l440gx.c linuxppc-2.6.9-dream/drivers/mtd/maps/l440gx.c
--- linuxppc-2.6.9/drivers/mtd/maps/l440gx.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/l440gx.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: l440gx.c,v 1.13 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: l440gx.c,v 1.17 2004/11/28 09:40:39 dwmw2 Exp $
  *
  * BIOS Flash chip on Intel 440GX board.
  *
@@ -30,7 +30,7 @@
 
 
 /* Is this really the vpp port? */
-void l440gx_set_vpp(struct map_info *map, int vpp)
+static void l440gx_set_vpp(struct map_info *map, int vpp)
 {
 	unsigned long l;
 
@@ -43,7 +43,7 @@
 	outl(l, VPP_PORT);
 }
 
-struct map_info l440gx_map = {
+static struct map_info l440gx_map = {
 	.name = "L440GX BIOS",
 	.size = WINDOW_SIZE,
 	.bankwidth = BUSWIDTH,
@@ -73,7 +73,7 @@
 		return -ENODEV;
 	}
 
-	l440gx_map.virt = (unsigned long)ioremap_nocache(WINDOW_ADDR, WINDOW_SIZE);
+	l440gx_map.virt = ioremap_nocache(WINDOW_ADDR, WINDOW_SIZE);
 
 	if (!l440gx_map.virt) {
 		printk(KERN_WARNING "Failed to ioremap L440GX flash region\n");
@@ -103,7 +103,7 @@
 		/* Allocate the resource region */
 		if (pci_assign_resource(pm_dev, PIIXE_IOBASE_RESOURCE) != 0) {
 			printk(KERN_WARNING "Could not allocate pm iobase resource\n");
-			iounmap((void *)l440gx_map.virt);
+			iounmap(l440gx_map.virt);
 			return -ENXIO;
 		}
 	}
@@ -137,7 +137,7 @@
 		return 0;
 	}
 
-	iounmap((void *)l440gx_map.virt);
+	iounmap(l440gx_map.virt);
 	return -ENXIO;
 }
 
@@ -146,7 +146,7 @@
 	del_mtd_device(mymtd);
 	map_destroy(mymtd);
 	
-	iounmap((void *)l440gx_map.virt);
+	iounmap(l440gx_map.virt);
 }
 
 module_init(init_l440gx);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/lasat.c linuxppc-2.6.9-dream/drivers/mtd/maps/lasat.c
--- linuxppc-2.6.9/drivers/mtd/maps/lasat.c	2004-10-18 23:53:22.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/lasat.c	2005-06-20 10:46:11.000000000 +0200
@@ -7,7 +7,7 @@
  * modify it under the terms of the GNU General Public License version
  * 2 as published by the Free Software Foundation.
  *
- * $Id: lasat.c,v 1.7 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: lasat.c,v 1.9 2004/11/04 13:24:15 gleixner Exp $
  *
  */
 
@@ -50,7 +50,7 @@
 	ENABLE_VPP((&lasat_map));
 
 	lasat_map.phys = lasat_flash_partition_start(LASAT_MTD_BOOTLOADER);
-	lasat_map.virt = (unsigned long)ioremap_nocache(
+	lasat_map.virt = ioremap_nocache(
 		        lasat_map.phys, lasat_board_info.li_flash_size);
 	lasat_map.size = lasat_board_info.li_flash_size;
 
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/lubbock-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/lubbock-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/lubbock-flash.c	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/lubbock-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: lubbock-flash.c,v 1.18 2004/09/28 18:54:40 nico Exp $
+ * $Id: lubbock-flash.c,v 1.19 2004/11/04 13:24:15 gleixner Exp $
  *
  * Map driver for the Lubbock developer platform.
  *
@@ -84,7 +84,7 @@
 	lubbock_maps[flashboot].name = "Lubbock Boot ROM";
 
 	for (i = 0; i < 2; i++) {
-		lubbock_maps[i].virt = (void __iomem *)ioremap(lubbock_maps[i].phys, WINDOW_SIZE);
+		lubbock_maps[i].virt = ioremap(lubbock_maps[i].phys, WINDOW_SIZE);
 		if (!lubbock_maps[i].virt) {
 			printk(KERN_WARNING "Failed to ioremap %s\n", lubbock_maps[i].name);
 			if (!ret)
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/Makefile linuxppc-2.6.9-dream/drivers/mtd/maps/Makefile
--- linuxppc-2.6.9/drivers/mtd/maps/Makefile	2005-10-01 14:12:17.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/Makefile	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # linux/drivers/maps/Makefile
 #
-# $Id: Makefile.common,v 1.14 2004/07/12 16:07:31 dwmw2 Exp $
+# $Id: Makefile.common,v 1.23 2005/01/05 17:06:36 dwmw2 Exp $
 
 ifeq ($(CONFIG_MTD_COMPLEX_MAPPINGS),y)
 obj-$(CONFIG_MTD)		+= map_funcs.o
@@ -10,6 +10,7 @@
 # Chip mappings
 obj-$(CONFIG_MTD_CDB89712)	+= cdb89712.o
 obj-$(CONFIG_MTD_ARM_INTEGRATOR)+= integrator-flash.o
+obj-$(CONFIG_MTD_BAST)		+= bast-flash.o
 obj-$(CONFIG_MTD_CFI_FLAGADM)	+= cfi_flagadm.o
 obj-$(CONFIG_MTD_CSTM_MIPS_IXX)	+= cstm_mips_ixx.o
 obj-$(CONFIG_MTD_DC21285)	+= dc21285.o
@@ -31,13 +32,16 @@
 obj-$(CONFIG_MTD_RPXLITE)	+= rpxlite.o
 obj-$(CONFIG_MTD_TQM8XXL)	+= tqm8xxl.o
 obj-$(CONFIG_MTD_SA1100)	+= sa1100-flash.o
+obj-$(CONFIG_MTD_IPAQ)		+= ipaq-flash.o
 obj-$(CONFIG_MTD_SBC_GXX)	+= sbc_gxx.o
 obj-$(CONFIG_MTD_SC520CDP)	+= sc520cdp.o
 obj-$(CONFIG_MTD_NETSC520)	+= netsc520.o
+obj-$(CONFIG_MTD_TS5500)	+= ts5500_flash.o
 obj-$(CONFIG_MTD_SUN_UFLASH)	+= sun_uflash.o
 obj-$(CONFIG_MTD_VMAX)		+= vmax301.o
 obj-$(CONFIG_MTD_SCx200_DOCFLASH)+= scx200_docflash.o
 obj-$(CONFIG_MTD_DBOX2)		+= dbox2-flash.o
+obj-$(CONFIG_MTD_DREAMBOX)	+= dreambox.o
 obj-$(CONFIG_MTD_OCELOT)	+= ocelot.o
 obj-$(CONFIG_MTD_SOLUTIONENGINE)+= solutionengine.o
 obj-$(CONFIG_MTD_PCI)		+= pci.o
@@ -51,6 +55,7 @@
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
 obj-$(CONFIG_MTD_FORTUNET)	+= fortunet.o
 obj-$(CONFIG_MTD_REDWOOD)	+= redwood.o
+obj-$(CONFIG_MTD_CHESTNUT)	+= chestnut.o
 obj-$(CONFIG_MTD_UCLINUX)	+= uclinux.o
 obj-$(CONFIG_MTD_NETtel)	+= nettel.o
 obj-$(CONFIG_MTD_SCB2_FLASH)	+= scb2_flash.o
@@ -58,6 +63,7 @@
 obj-$(CONFIG_MTD_OCOTEA)	+= ocotea.o
 obj-$(CONFIG_MTD_BEECH)		+= beech-mtd.o
 obj-$(CONFIG_MTD_ARCTIC)	+= arctic-mtd.o
+obj-$(CONFIG_MTD_WALNUT)        += walnut.o
 obj-$(CONFIG_MTD_H720X)		+= h720x-flash.o
 obj-$(CONFIG_MTD_SBC8240)	+= sbc8240.o
 obj-$(CONFIG_MTD_NOR_TOTO)	+= omap-toto-flash.o
@@ -66,3 +72,4 @@
 obj-$(CONFIG_MTD_IXP2000)	+= ixp2000.o
 obj-$(CONFIG_MTD_WRSBC8260)	+= wr_sbc82xx_flash.o
 obj-$(CONFIG_MTD_DMV182)	+= dmv182.o
+obj-$(CONFIG_MTD_SHARP_SL)	+= sharpsl-flash.o
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/mbx860.c linuxppc-2.6.9-dream/drivers/mtd/maps/mbx860.c
--- linuxppc-2.6.9/drivers/mtd/maps/mbx860.c	2004-10-18 23:53:45.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/mbx860.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: mbx860.c,v 1.6 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: mbx860.c,v 1.8 2004/11/04 13:24:15 gleixner Exp $
  *
  * Handle mapping of the flash on MBX860 boards
  *
@@ -60,7 +60,7 @@
 int __init init_mbx(void)
 {
 	printk(KERN_NOTICE "Motorola MBX flash device: 0x%x at 0x%x\n", WINDOW_SIZE*4, WINDOW_ADDR);
-	mbx_map.virt = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE * 4);
+	mbx_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE * 4);
 
 	if (!mbx_map.virt) {
 		printk("Failed to ioremap\n");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/mpc1211.c linuxppc-2.6.9-dream/drivers/mtd/maps/mpc1211.c
--- linuxppc-2.6.9/drivers/mtd/maps/mpc1211.c	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/mpc1211.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Flash on MPC-1211
  *
- * $Id: mpc1211.c,v 1.3 2004/07/14 17:45:40 dwmw2 Exp $
+ * $Id: mpc1211.c,v 1.4 2004/09/16 23:27:13 gleixner Exp $
  *
  * (C) 2002 Interface, Saito.K & Jeanne
  *
@@ -44,7 +44,7 @@
 	int nr_parts;
 
 	mpc1211_flash_map.phys = 0;
-	mpc1211_flash_map.virt = P2SEGADDR(0);
+	mpc1211_flash_map.virt = (void __iomem *)P2SEGADDR(0);
 
 	simple_map_init(&mpc1211_flash_map);
 
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/netsc520.c linuxppc-2.6.9-dream/drivers/mtd/maps/netsc520.c
--- linuxppc-2.6.9/drivers/mtd/maps/netsc520.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/netsc520.c	2005-06-20 10:46:11.000000000 +0200
@@ -3,7 +3,7 @@
  * Copyright (C) 2001 Mark Langsdorf (mark.langsdorf@amd.com)
  *	based on sc520cdp.c by Sysgo Real-Time Solutions GmbH
  *
- * $Id: netsc520.c,v 1.10 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: netsc520.c,v 1.13 2004/11/28 09:40:40 dwmw2 Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -95,7 +95,7 @@
 static int __init init_netsc520(void)
 {
 	printk(KERN_NOTICE "NetSc520 flash device: 0x%lx at 0x%lx\n", netsc520_map.size, netsc520_map.phys);
-	netsc520_map.virt = (unsigned long)ioremap_nocache(netsc520_map.phys, netsc520_map.size);
+	netsc520_map.virt = ioremap_nocache(netsc520_map.phys, netsc520_map.size);
 
 	if (!netsc520_map.virt) {
 		printk("Failed to ioremap_nocache\n");
@@ -111,7 +111,7 @@
 		mymtd = do_map_probe("map_rom", &netsc520_map);
 
 	if (!mymtd) {
-		iounmap((void *)netsc520_map.virt);
+		iounmap(netsc520_map.virt);
 		return -ENXIO;
 	}
 		
@@ -127,8 +127,8 @@
 		map_destroy(mymtd);
 	}
 	if (netsc520_map.virt) {
-		iounmap((void *)netsc520_map.virt);
-		netsc520_map.virt = 0;
+		iounmap(netsc520_map.virt);
+		netsc520_map.virt = NULL;
 	}
 }
 
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/nettel.c linuxppc-2.6.9-dream/drivers/mtd/maps/nettel.c
--- linuxppc-2.6.9/drivers/mtd/maps/nettel.c	2004-10-18 23:53:44.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/nettel.c	2005-06-20 10:46:11.000000000 +0200
@@ -6,7 +6,7 @@
  *      (C) Copyright 2000-2001, Greg Ungerer (gerg@snapgear.com)
  *      (C) Copyright 2001-2002, SnapGear (www.snapgear.com)
  *
- *	$Id: nettel.c,v 1.5 2004/07/12 21:59:44 dwmw2 Exp $
+ *	$Id: nettel.c,v 1.10 2005/01/05 17:11:29 dwmw2 Exp $
  */
 
 /****************************************************************************/
@@ -273,8 +273,7 @@
 	__asm__ ("wbinvd");
 
 	nettel_amd_map.phys = amdaddr;
-	nettel_amd_map.virt = (unsigned long)
-		ioremap_nocache(amdaddr, maxsize);
+	nettel_amd_map.virt = ioremap_nocache(amdaddr, maxsize);
 	if (!nettel_amd_map.virt) {
 		printk("SNAPGEAR: failed to ioremap() BOOTCS\n");
 		return(-EIO);
@@ -333,8 +332,8 @@
 
 		/* Destroy useless AMD MTD mapping */
 		amd_mtd = NULL;
-		iounmap((void *) nettel_amd_map.virt);
-		nettel_amd_map.virt = (unsigned long) NULL;
+		iounmap(nettel_amd_map.virt);
+		nettel_amd_map.virt = NULL;
 #else
 		/* Only AMD flash supported */
 		return(-ENXIO);
@@ -358,8 +357,7 @@
 	/* Probe for the the size of the first Intel flash */
 	nettel_intel_map.size = maxsize;
 	nettel_intel_map.phys = intel0addr;
-	nettel_intel_map.virt = (unsigned long)
-		ioremap_nocache(intel0addr, maxsize);
+	nettel_intel_map.virt = ioremap_nocache(intel0addr, maxsize);
 	if (!nettel_intel_map.virt) {
 		printk("SNAPGEAR: failed to ioremap() ROMCS1\n");
 		return(-EIO);
@@ -367,8 +365,8 @@
 	simple_map_init(&nettel_intel_map);
 
 	intel_mtd = do_map_probe("cfi_probe", &nettel_intel_map);
-	if (! intel_mtd) {
-		iounmap((void *) nettel_intel_map.virt);
+	if (!intel_mtd) {
+		iounmap(nettel_intel_map.virt);
 		return(-ENXIO);
 	}
 
@@ -389,11 +387,10 @@
 	/* Delete the old map and probe again to do both chips */
 	map_destroy(intel_mtd);
 	intel_mtd = NULL;
-	iounmap((void *) nettel_intel_map.virt);
+	iounmap(nettel_intel_map.virt);
 
 	nettel_intel_map.size = maxsize;
-	nettel_intel_map.virt = (unsigned long)
-		ioremap_nocache(intel0addr, maxsize);
+	nettel_intel_map.virt = ioremap_nocache(intel0addr, maxsize);
 	if (!nettel_intel_map.virt) {
 		printk("SNAPGEAR: failed to ioremap() ROMCS1/2\n");
 		return(-EIO);
@@ -472,8 +469,8 @@
 		map_destroy(amd_mtd);
 	}
 	if (nettel_amd_map.virt) {
-		iounmap((void *)nettel_amd_map.virt);
-		nettel_amd_map.virt = 0;
+		iounmap(nettel_amd_map.virt);
+		nettel_amd_map.virt = NULL;
 	}
 #ifdef CONFIG_MTD_CFI_INTELEXT
 	if (intel_mtd) {
@@ -481,7 +478,7 @@
 		map_destroy(intel_mtd);
 	}
 	if (nettel_intel_map.virt) {
-		iounmap((void *)nettel_intel_map.virt);
+		iounmap(nettel_intel_map.virt);
 		nettel_intel_map.virt = 0;
 	}
 #endif
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/ocelot.c linuxppc-2.6.9-dream/drivers/mtd/maps/ocelot.c
--- linuxppc-2.6.9/drivers/mtd/maps/ocelot.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/ocelot.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: ocelot.c,v 1.13 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: ocelot.c,v 1.16 2005/01/05 18:05:13 dwmw2 Exp $
  *
  * Flash on Momenco Ocelot
  */
@@ -28,7 +28,7 @@
 
 static void ocelot_ram_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
 {
-        struct map_info *map = (struct map_info *)mtd->priv;
+        struct map_info *map = mtd->priv;
 	size_t done = 0;
 
 	/* If we use memcpy, it does word-wide writes. Even though we told the 
@@ -81,7 +81,7 @@
 	iounmap(pld);
 
 	/* Now ioremap the NVRAM space */
-	ocelot_nvram_map.virt = (unsigned long)ioremap_nocache(NVRAM_WINDOW_ADDR, NVRAM_WINDOW_SIZE);
+	ocelot_nvram_map.virt = ioremap_nocache(NVRAM_WINDOW_ADDR, NVRAM_WINDOW_SIZE);
 	if (!ocelot_nvram_map.virt) {
 		printk(KERN_NOTICE "Failed to ioremap Ocelot NVRAM space\n");
 		return -EIO;
@@ -101,7 +101,7 @@
 	nvram_mtd->write = ocelot_ram_write;
 
 	/* Now map the flash space */
-	ocelot_flash_map.virt = (unsigned long)ioremap_nocache(FLASH_WINDOW_ADDR, FLASH_WINDOW_SIZE);
+	ocelot_flash_map.virt = ioremap_nocache(FLASH_WINDOW_ADDR, FLASH_WINDOW_SIZE);
 	if (!ocelot_flash_map.virt) {
 		printk(KERN_NOTICE "Failed to ioremap Ocelot flash space\n");
 		goto fail_2;
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/ocotea.c linuxppc-2.6.9-dream/drivers/mtd/maps/ocotea.c
--- linuxppc-2.6.9/drivers/mtd/maps/ocotea.c	2005-10-01 14:12:17.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/ocotea.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,9 +1,9 @@
 /*
  * Mapping for Ocotea user flash
  *
- * Matt Porter <mporter@mvista.com>
+ * Matt Porter <mporter@kernel.crashing.org>
  *
- * Copyright 2002-2003 MontaVista Software Inc.
+ * Copyright 2002-2004 MontaVista Software Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -19,6 +19,7 @@
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
 #include <linux/config.h>
+#include <linux/version.h>
 #include <asm/io.h>
 #include <asm/ibm44x.h>
 #include <platforms/4xx/ocotea.h>
@@ -63,7 +64,7 @@
 int __init init_ocotea(void)
 {
 	u8 fpga0_reg;
-	void * fpga0_adr;
+	u8 *fpga0_adr;
 	unsigned long long small_flash_base, large_flash_base;
 
 	fpga0_adr = ioremap64(OCOTEA_FPGA_ADDR, 16);
@@ -83,8 +84,7 @@
 	}
 
 	ocotea_small_map.phys = small_flash_base;
-	ocotea_small_map.virt =
-		(unsigned long)ioremap64(small_flash_base,
+	ocotea_small_map.virt = ioremap64(small_flash_base,
 					 ocotea_small_map.size);
 
 	if (!ocotea_small_map.virt) {
@@ -105,8 +105,7 @@
 	}
 
 	ocotea_large_map.phys = large_flash_base;
-	ocotea_large_map.virt =
-		(unsigned long)ioremap64(large_flash_base,
+	ocotea_large_map.virt = ioremap64(large_flash_base,
 					 ocotea_large_map.size);
 
 	if (!ocotea_large_map.virt) {
@@ -151,5 +150,5 @@
 module_exit(cleanup_ocotea);
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Matt Porter <mporter@mvista.com>");
+MODULE_AUTHOR("Matt Porter <mporter@kernel.crashing.org>");
 MODULE_DESCRIPTION("MTD map and partitions for IBM 440GX Ocotea boards");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/octagon-5066.c linuxppc-2.6.9-dream/drivers/mtd/maps/octagon-5066.c
--- linuxppc-2.6.9/drivers/mtd/maps/octagon-5066.c	2004-10-18 23:53:22.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/octagon-5066.c	2005-06-20 10:46:11.000000000 +0200
@@ -41,7 +41,7 @@
 
 static volatile char page_n_dev = 0;
 static unsigned long iomapadr;
-static spinlock_t oct5066_spin = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(oct5066_spin);
 
 /*
  * We use map_priv_1 to identify which device we are.
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/omap-toto-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/omap-toto-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/omap-toto-flash.c	2004-10-18 23:53:45.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/omap-toto-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *  (C) 2002 MontVista Software, Inc.
  *
- * $Id: omap-toto-flash.c,v 1.2 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: omap-toto-flash.c,v 1.3 2004/09/16 23:27:13 gleixner Exp $
  */
 
 #include <linux/config.h>
@@ -35,7 +35,7 @@
 static struct map_info omap_toto_map_flash = {
 	.name =		"OMAP Toto flash",
 	.bankwidth =	2,
-	.virt =		OMAP_TOTO_FLASH_BASE,
+	.virt =		(void __iomem *)OMAP_TOTO_FLASH_BASE,
 };
 
  
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/pb1550-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/pb1550-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/pb1550-flash.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/pb1550-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Flash memory access on Alchemy Pb1550 board
  * 
- * $Id: pb1550-flash.c,v 1.4 2004/07/14 17:45:40 dwmw2 Exp $
+ * $Id: pb1550-flash.c,v 1.6 2004/11/04 13:24:15 gleixner Exp $
  *
  * (C) 2004 Embedded Edge, LLC, based on pb1550-flash.c:
  * (C) 2003 Pete Popov <ppopov@pacbell.net>
@@ -178,8 +178,7 @@
 	 */
 	printk(KERN_NOTICE "Pb1550 flash: probing %d-bit flash bus\n", 
 			pb1550_map.bankwidth*8);
-	pb1550_map.virt = 
-		(unsigned long)ioremap(window_addr, window_size);
+	pb1550_map.virt = ioremap(window_addr, window_size);
 	mymtd = do_map_probe("cfi_probe", &pb1550_map);
 	if (!mymtd) return -ENXIO;
 	mymtd->owner = THIS_MODULE;
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/pb1xxx-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/pb1xxx-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/pb1xxx-flash.c	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/pb1xxx-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -3,7 +3,7 @@
  * 
  * (C) 2001 Pete Popov <ppopov@mvista.com>
  * 
- * $Id: pb1xxx-flash.c,v 1.11 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: pb1xxx-flash.c,v 1.14 2004/11/04 13:24:15 gleixner Exp $
  */
 
 #include <linux/config.h>
@@ -17,7 +17,6 @@
 #include <linux/mtd/partitions.h>
 
 #include <asm/io.h>
-#include <asm/au1000.h>
 
 #ifdef 	DEBUG_RW
 #define	DBG(x...)	printk(x)
@@ -150,7 +149,7 @@
 	 */
 	printk(KERN_NOTICE "Pb1xxx flash: probing %d-bit flash bus\n", 
 			BUSWIDTH*8);
-	pb1xxx_mtd_map.virt = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	pb1xxx_mtd_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE);
 
 	simple_map_init(&pb1xxx_mtd_map);
 
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/pci.c linuxppc-2.6.9-dream/drivers/mtd/maps/pci.c
--- linuxppc-2.6.9/drivers/mtd/maps/pci.c	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/pci.c	2005-06-20 10:46:11.000000000 +0200
@@ -7,7 +7,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- *  $Id: pci.c,v 1.8 2004/07/12 22:38:29 dwmw2 Exp $
+ *  $Id: pci.c,v 1.9 2004/11/28 09:40:40 dwmw2 Exp $
  * 
  * Generic PCI memory map driver.  We support the following boards:
  *  - Intel IQ80310 ATU.
@@ -33,7 +33,7 @@
 
 struct map_pci_info {
 	struct map_info map;
-	void *base;
+	void __iomem *base;
 	void (*exit)(struct pci_dev *dev, struct map_pci_info *map);
 	unsigned long (*translate)(struct map_pci_info *map, unsigned long ofs);
 	struct pci_dev *dev;
@@ -143,7 +143,7 @@
 intel_iq80310_exit(struct pci_dev *dev, struct map_pci_info *map)
 {
 	if (map->base)
-		iounmap((void *)map->base);
+		iounmap(map->base);
 	pci_write_config_dword(dev, 0x44, map->map.map_priv_2);
 }
 
@@ -236,7 +236,7 @@
 	u32 val;
 
 	if (map->base)
-		iounmap((void *)map->base);
+		iounmap(map->base);
 
 	/*
 	 * We need to undo the PCI BAR2/PCI ROM BAR address alteration.
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/pcmciamtd.c linuxppc-2.6.9-dream/drivers/mtd/maps/pcmciamtd.c
--- linuxppc-2.6.9/drivers/mtd/maps/pcmciamtd.c	2004-10-18 23:53:21.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/pcmciamtd.c	2005-06-20 10:46:11.000000000 +0200
@@ -800,7 +800,6 @@
 
 	/* Register with Card Services */
 	client_reg.dev_info = &dev_info;
-	client_reg.Attributes = INFO_IO_CLIENT | INFO_CARD_SHARE;
 	client_reg.EventMask =
 		CS_EVENT_RESET_PHYSICAL | CS_EVENT_CARD_RESET |
 		CS_EVENT_CARD_INSERTION | CS_EVENT_CARD_REMOVAL |
@@ -854,35 +853,7 @@
 {
 	DEBUG(1, DRIVER_DESC " unloading");
 	pcmcia_unregister_driver(&pcmciamtd_driver);
-
-	while(dev_list) {
-		dev_link_t *link = dev_list;
-
-		dev_list = link->next;
-		if (link) {
-			struct pcmciamtd_dev *dev = link->priv;
-			
- 			if(dev) {
-				if(link->state & DEV_PRESENT) {
-					if (!(link->state & DEV_STALE_LINK)) {
-						pcmciamtd_detach(link);
-					}
-					link->state &= ~DEV_PRESENT;
-					if(dev->mtd_info) {
-						del_mtd_device(dev->mtd_info);
-						info("mtd%d: Removed",
-						     dev->mtd_info->index);
-					}
-				}
-				if(dev->mtd_info) {
-					DEBUG(2, "Destroying map for mtd%d",
-					      dev->mtd_info->index);
-					map_destroy(dev->mtd_info);
-				}
-				kfree(dev);
-			}
-		}
-	}
+	BUG_ON(dev_list != NULL);
 }
 
 module_init(init_pcmciamtd);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/physmap.c linuxppc-2.6.9-dream/drivers/mtd/maps/physmap.c
--- linuxppc-2.6.9/drivers/mtd/maps/physmap.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/physmap.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: physmap.c,v 1.34 2004/07/21 00:16:14 jwboyer Exp $
+ * $Id: physmap.c,v 1.37 2004/11/28 09:40:40 dwmw2 Exp $
  *
  * Normal mappings of chips in physical memory
  *
@@ -51,7 +51,7 @@
 	const char **type;
 
        	printk(KERN_NOTICE "physmap flash device: %lx at %lx\n", physmap_map.size, physmap_map.phys);
-	physmap_map.virt = (unsigned long)ioremap(physmap_map.phys, physmap_map.size);
+	physmap_map.virt = ioremap(physmap_map.phys, physmap_map.size);
 
 	if (!physmap_map.virt) {
 		printk("Failed to ioremap\n");
@@ -92,7 +92,7 @@
 		return 0;
 	}
 
-	iounmap((void *)physmap_map.virt);
+	iounmap(physmap_map.virt);
 	return -ENXIO;
 }
 
@@ -112,8 +112,8 @@
 #endif
 	map_destroy(mymtd);
 
-	iounmap((void *)physmap_map.virt);
-	physmap_map.virt = 0;
+	iounmap(physmap_map.virt);
+	physmap_map.virt = NULL;
 }
 
 module_init(init_physmap);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/pnc2000.c linuxppc-2.6.9-dream/drivers/mtd/maps/pnc2000.c
--- linuxppc-2.6.9/drivers/mtd/maps/pnc2000.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/pnc2000.c	2005-06-20 10:46:11.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: pnc2000.c,v 1.15 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: pnc2000.c,v 1.17 2004/11/16 18:29:02 dwmw2 Exp $
  */
 
 #include <linux/module.h>
@@ -26,12 +26,12 @@
  */
 
 
-struct map_info pnc_map = {
+static struct map_info pnc_map = {
 	.name = "PNC-2000",
 	.size = WINDOW_SIZE,
 	.bankwidth = 4,
 	.phys = 0xFFFFFFFF,
-	.virt = WINDOW_ADDR,
+	.virt = (void __iomem *)WINDOW_ADDR,
 };
 
 
@@ -62,7 +62,7 @@
  */
 static struct mtd_info *mymtd;
 
-int __init init_pnc2000(void)
+static int __init init_pnc2000(void)
 {
 	printk(KERN_NOTICE "Photron PNC-2000 flash mapping: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
 
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/redwood.c linuxppc-2.6.9-dream/drivers/mtd/maps/redwood.c
--- linuxppc-2.6.9/drivers/mtd/maps/redwood.c	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/redwood.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: redwood.c,v 1.8 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: redwood.c,v 1.10 2004/11/04 13:24:15 gleixner Exp $
  *
  * drivers/mtd/maps/redwood.c
  *
@@ -131,8 +131,7 @@
 	printk(KERN_NOTICE "redwood: flash mapping: %x at %x\n",
 			WINDOW_SIZE, WINDOW_ADDR);
 
-	redwood_flash_map.virt =
-		(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	redwood_flash_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE);
 
 	if (!redwood_flash_map.virt) {
 		printk("init_redwood_flash: failed to ioremap\n");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/rpxlite.c linuxppc-2.6.9-dream/drivers/mtd/maps/rpxlite.c
--- linuxppc-2.6.9/drivers/mtd/maps/rpxlite.c	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/rpxlite.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: rpxlite.c,v 1.20 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: rpxlite.c,v 1.22 2004/11/04 13:24:15 gleixner Exp $
  *
  * Handle mapping of the flash on the RPX Lite and CLLF boards
  */
@@ -28,7 +28,7 @@
 int __init init_rpxlite(void)
 {
 	printk(KERN_NOTICE "RPX Lite or CLLF flash device: %x at %x\n", WINDOW_SIZE*4, WINDOW_ADDR);
-	rpxlite_map.virt = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE * 4);
+	rpxlite_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE * 4);
 
 	if (!rpxlite_map.virt) {
 		printk("Failed to ioremap\n");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/sa1100-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/sa1100-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/sa1100-flash.c	2004-10-18 23:53:44.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/sa1100-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -3,9 +3,8 @@
  * 
  * (C) 2000 Nicolas Pitre <nico@cam.org>
  * 
- * $Id: sa1100-flash.c,v 1.39 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: sa1100-flash.c,v 1.47 2004/11/01 13:44:36 rmk Exp $
  */
-
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
@@ -14,1339 +13,440 @@
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/err.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
 #include <linux/mtd/concat.h>
 
-#include <asm/hardware.h>
 #include <asm/mach-types.h>
 #include <asm/io.h>
 #include <asm/sizes.h>
+#include <asm/mach/flash.h>
 
-#include <asm/arch/h3600.h>
-
-#ifndef CONFIG_ARCH_SA1100
-#error This is for SA1100 architecture only
-#endif
-
-/*
- * This isnt complete yet, so...
- */
-#define CONFIG_MTD_SA1100_STATICMAP 1
-
-#ifdef CONFIG_MTD_SA1100_STATICMAP
-/*
- * Here are partition information for all known SA1100-based devices.
- * See include/linux/mtd/partitions.h for definition of the mtd_partition
- * structure.
- *
- * Please note:
- *  1. We no longer support static flash mappings via the machine io_desc
- *     structure.
- *  2. The flash size given should be the largest flash size that can
- *     be accommodated.
- *
- * The MTD layer will detect flash chip aliasing and reduce the size of
- * the map accordingly.
- *
- * Please keep these in alphabetical order, and formatted as per existing
- * entries.  Thanks.
- */
-
-#ifdef CONFIG_SA1100_ADSBITSY
-static struct mtd_partition adsbitsy_partitions[] = {
-	{
-		.name		= "bootROM",
-		.size		= 0x80000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "zImage",
-		.size		= 0x100000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "ramdisk.gz",
-		.size		= 0x300000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "User FS",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_ASSABET
-/* Phase 4 Assabet has two 28F160B3 flash parts in bank 0: */
-static struct mtd_partition assabet4_partitions[] = {
-	{
-		.name		= "bootloader",
-		.size		= 0x00020000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "bootloader params",
-		.size		= 0x00020000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "jffs",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-
-/* Phase 5 Assabet has two 28F128J3A flash parts in bank 0: */
-static struct mtd_partition assabet5_partitions[] = {
-	{
-		.name		= "bootloader",
-		.size		= 0x00040000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "bootloader params",
-		.size		= 0x00040000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "jffs",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-
-#define assabet_partitions	assabet5_partitions
-#endif
-
-#ifdef CONFIG_SA1100_BADGE4
+#if 0
 /*
- * 1 x Intel 28F320C3 Advanced+ Boot Block Flash (32 Mi bit)
- *   Eight 4 KiW Parameter Bottom Blocks (64 KiB)
- *   Sixty-three 32 KiW Main Blocks (4032 Ki b)
- *
- * <or>
- *
- * 1 x Intel 28F640C3 Advanced+ Boot Block Flash (64 Mi bit)
- *   Eight 4 KiW Parameter Bottom Blocks (64 KiB)
- *   One-hundred-twenty-seven 32 KiW Main Blocks (8128 Ki b)
+ * This is here for documentation purposes only - until these people
+ * submit their machine types.  It will be gone January 2005.
  */
-static struct mtd_partition badge4_partitions[] = {
-	{
-		.name		= "BLOB boot loader",
-		.offset		= 0,
-		.size		= 0x0000A000
-	}, {
-		.name		= "params",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 0x00006000
-	}, {
-		.name		= "root",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL
-	}
-};
-#endif
-
-
-#ifdef CONFIG_SA1100_CERF
-#ifdef CONFIG_SA1100_CERF_FLASH_32MB
-#  define CERF_FLASH_SIZE	0x02000000
-#elif defined CONFIG_SA1100_CERF_FLASH_16MB
-#  define CERF_FLASH_SIZE	0x01000000
-#elif defined CONFIG_SA1100_CERF_FLASH_8MB
-#  define CERF_FLASH_SIZE	0x00800000
-#else
-#  error "Undefined flash size for CERF in sa1100-flash.c"
-#endif
-
-static struct mtd_partition cerf_partitions[] = {
-	{
-		.name		= "Bootloader",
-		.size		= 0x00020000,
-		.offset		= 0x00000000,
-	}, {
-		.name		= "Params",
-		.size		= 0x00040000,
-		.offset		= 0x00020000,
-	}, {
-		.name		= "Kernel",
-		.size		= 0x00100000,
-		.offset		= 0x00060000,
-	}, {
-		.name		= "Filesystem",
-		.size		= CERF_FLASH_SIZE-0x00160000,
-		.offset		= 0x00160000,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_CONSUS
 static struct mtd_partition consus_partitions[] = {
 	{
-		.name		= "Consus boot firmware",
-		.offset		= 0,
-		.size		= 0x00040000,
-		.mask_flags	= MTD_WRITABLE, /* force read-only */
-	}, {
-		.name		= "Consus kernel",
-		.offset		= 0x00040000,
-		.size		= 0x00100000,
-		.mask_flags	= 0,
-	}, {
-		.name		= "Consus disk",
-		.offset		= 0x00140000,
-		/* The rest (up to 16M) for jffs.  We could put 0 and
-		   make it find the size automatically, but right now
-		   i have 32 megs.  jffs will use all 32 megs if given
-		   the chance, and this leads to horrible problems
-		   when you try to re-flash the image because blob
-		   won't erase the whole partition. */
-		.size		= 0x01000000 - 0x00140000,
-		.mask_flags	= 0,
-	}, {
-		/* this disk is a secondary disk, which can be used as
-		   needed, for simplicity, make it the size of the other
-		   consus partition, although realistically it could be
-		   the remainder of the disk (depending on the file
-		   system used) */
-		 .name		= "Consus disk2",
-		 .offset	= 0x01000000,
-		 .size		= 0x01000000 - 0x00140000,
-		 .mask_flags	= 0,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_FLEXANET
-/* Flexanet has two 28F128J3A flash parts in bank 0: */
-#define FLEXANET_FLASH_SIZE		0x02000000
-static struct mtd_partition flexanet_partitions[] = {
-	{
-		.name		= "bootloader",
-		.size		= 0x00040000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "bootloader params",
-		.size		= 0x00040000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "kernel",
-		.size		= 0x000C0000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "altkernel",
-		.size		= 0x000C0000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "root",
-		.size		= 0x00400000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "free1",
-		.size		= 0x00300000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "free2",
-		.size		= 0x00300000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "free3",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_FREEBIRD
-static struct mtd_partition freebird_partitions[] = {
-#ifdef CONFIG_SA1100_FREEBIRD_NEW
-	{
-		.name		= "firmware",
-		.size		= 0x00040000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "kernel",
-		.size		= 0x00080000,
-		.offset		= 0x00040000,
-	}, {
-		.name		= "params",
-		.size		= 0x00040000,
-		.offset		= 0x000C0000,
-	}, {
-		.name		= "initrd",
-		.size		= 0x00100000,
-		.offset		= 0x00100000,
-	}, {
-		.name		= "root cramfs",
-		.size		= 0x00300000,
-		.offset		= 0x00200000,
-	}, {
-		.name		= "usr cramfs",
-		.size		= 0x00C00000,
-		.offset		= 0x00500000,
-	}, {
-		.name		= "local",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= 0x01100000,
-	}
-#else
-	{
-		.size		= 0x00040000,
-		.offset		= 0,
-	}, {
-		.size		= 0x000c0000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.size		= 0x00400000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-#endif
-};
-#endif
-
-#ifdef CONFIG_SA1100_FRODO
-/* Frodo has 2 x 16M 28F128J3A flash chips in bank 0: */
-static struct mtd_partition frodo_partitions[] =
-{
-	{
-		.name		= "bootloader",
-		.size		= 0x00040000,
-		.offset		= 0x00000000,
-		.mask_flags	= MTD_WRITEABLE
-	}, {
-		.name		= "bootloader params",
-		.size		= 0x00040000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE
-	}, {
-		.name		= "kernel",
-		.size		= 0x00100000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE
-	}, {
-		.name		= "ramdisk",
-		.size		= 0x00400000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE
-	}, {
-		.name		= "file system",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_GRAPHICSCLIENT
-static struct mtd_partition graphicsclient_partitions[] = {
-	{
-		.name		= "zImage",
-		.size		= 0x100000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "ramdisk.gz",
-		.size		= 0x300000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "User FS",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_GRAPHICSMASTER
-static struct mtd_partition graphicsmaster_partitions[] = {
-	{
-		.name		= "zImage",
-		.size		= 0x100000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	},
-	{
-		.name		= "ramdisk.gz",
-		.size		= 0x300000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	},
-	{
-		.name		= "User FS",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_H3XXX
-static struct mtd_partition h3xxx_partitions[] = {
-	{
-		.name		= "H3XXX boot firmware",
-		.size		= 0x00040000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-#ifdef CONFIG_MTD_2PARTS_IPAQ
-		.name		= "H3XXX root jffs2",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= 0x00040000,
-#else
-		.name		= "H3XXX kernel",
-		.size		= 0x00080000,
-		.offset		= 0x00040000,
-	}, {
-		.name		= "H3XXX params",
-		.size		= 0x00040000,
-		.offset		= 0x000C0000,
-	}, {
-#ifdef CONFIG_JFFS2_FS
-		.name		= "H3XXX root jffs2",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= 0x00100000,
-#else
-		.name		= "H3XXX initrd",
-		.size		= 0x00100000,
-		.offset		= 0x00100000,
-	}, {
-		.name		= "H3XXX root cramfs",
-		.size		= 0x00300000,
-		.offset		= 0x00200000,
-	}, {
-		.name		= "H3XXX usr cramfs",
-		.size		= 0x00800000,
-		.offset		= 0x00500000,
-	}, {
-		.name		= "H3XXX usr local",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= 0x00d00000,
-#endif
-#endif
-	}
-};
-
-static void h3xxx_set_vpp(struct map_info *map, int vpp)
-{
-	assign_h3600_egpio(IPAQ_EGPIO_VPP_ON, vpp);
-}
-#else
-#define h3xxx_set_vpp NULL
-#endif
-
-#ifdef CONFIG_SA1100_HACKKIT
-static struct mtd_partition hackkit_partitions[] = {
-	{
-		.name		= "BLOB",
-		.size		= 0x00040000,
-		.offset		= 0x00000000,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "config",
-		.size		= 0x00040000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "kernel",
-		.size		= 0x00100000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "initrd",
-		.size		= 0x00180000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "rootfs",
-		.size		= 0x700000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "data",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_HUW_WEBPANEL
-static struct mtd_partition huw_webpanel_partitions[] = {
-	{
-		.name		= "Loader",
-		.size		= 0x00040000,
-		.offset		= 0,
-	}, {
-		.name		= "Sector 1",
-		.size		= 0x00040000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_JORNADA720
-static struct mtd_partition jornada720_partitions[] = {
-	{
-		.name		= "JORNADA720 boot firmware",
-		.size		= 0x00040000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "JORNADA720 kernel",
-		.size		= 0x000c0000,
-		.offset		= 0x00040000,
-	}, {
-		.name		= "JORNADA720 params",
-		.size		= 0x00040000,
-		.offset		= 0x00100000,
-	}, {
-		.name		= "JORNADA720 initrd",
-		.size		= 0x00100000,
-		.offset		= 0x00140000,
-	}, {
-		.name		= "JORNADA720 root cramfs",
-		.size		= 0x00300000,
-		.offset		= 0x00240000,
-	}, {
-		.name		= "JORNADA720 usr cramfs",
-		.size		= 0x00800000,
-		.offset		= 0x00540000,
-	}, {
-		.name		= "JORNADA720 usr local",
-		.size		= 0,  /* will expand to the end of the flash */
-		.offset		= 0x00d00000,
-	}
-};
-
-static void jornada720_set_vpp(struct map_info *map, int vpp)
-{
-	if (vpp)
-		PPSR |= 0x80;
-	else
-		PPSR &= ~0x80;
-	PPDR |= 0x80;
-}
-#else
-#define jornada720_set_vpp NULL
-#endif
-
-#ifdef CONFIG_SA1100_PANGOLIN
-static struct mtd_partition pangolin_partitions[] = {
-	{
-		.name		= "boot firmware",
-		.size		= 0x00080000,
-		.offset		= 0x00000000,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "kernel",
-		.size		= 0x00100000,
-		.offset		= 0x00080000,
-	}, {
-		.name		= "initrd",
-		.size		= 0x00280000,
-		.offset		= 0x00180000,
-	}, {
-		.name		= "initrd-test",
-		.size		= 0x03C00000,
-		.offset		= 0x00400000,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_PT_SYSTEM3
-/* erase size is 0x40000 == 256k partitions have to have this boundary */
-static struct mtd_partition system3_partitions[] = {
-	{
-		.name		= "BLOB",
-		.size		= 0x00040000,
-		.offset		= 0x00000000,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "config",
-		.size		= 0x00040000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "kernel",
-		.size		= 0x00100000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "root",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_SHANNON
-static struct mtd_partition shannon_partitions[] = {
-	{
-		.name		= "BLOB boot loader",
-		.offset		= 0,
-		.size		= 0x20000
-	},
-	{
-		.name		= "kernel",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 0xe0000
-	},
-	{ 
-		.name		= "initrd",
-		.offset		= MTDPART_OFS_APPEND,	
-		.size		= MTDPART_SIZ_FULL
-	}
-};
-
-#endif
-
-#ifdef CONFIG_SA1100_SHERMAN
-static struct mtd_partition sherman_partitions[] = {
-	{
-		.size		= 0x50000,
-		.offset		= 0,
-	}, {
-		.size		= 0x70000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.size		= 0x600000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.size		= 0xA0000,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_SIMPAD
-static struct mtd_partition simpad_partitions[] = {
-	{
-		.name		= "SIMpad boot firmware",
-		.size		= 0x00080000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "SIMpad kernel",
-		.size		= 0x00100000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-#ifdef CONFIG_ROOT_CRAMFS
-		.name		= "SIMpad root cramfs",
-		.size	     	=0x00D80000,
-		.offset		= MTDPART_OFS_APPEND
-
-	}, {
-		.name		= "SIMpad local jffs2",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND
-#else
-		.name		= "SIMpad root jffs2",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND
-#endif
-	}
-};
-#endif /* CONFIG_SA1100_SIMPAD */
-
-#ifdef CONFIG_SA1100_STORK
-static struct mtd_partition stork_partitions[] = {
-	{
-		.name		= "STORK boot firmware",
-		.size		= 0x00040000,
+		.name		= "Consus boot firmware",
 		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "STORK params",
 		.size		= 0x00040000,
-		.offset		= 0x00040000,
-	}, {
-		.name		= "STORK kernel",
-		.size		= 0x00100000,
-		.offset		= 0x00080000,
+		.mask_flags	= MTD_WRITABLE, /* force read-only */
 	}, {
-#ifdef CONFIG_JFFS2_FS
-		.name		= "STORK root jffs2",
-		.offset		= 0x00180000,
-		.size		= MTDPART_SIZ_FULL,
-#else
-		.name		= "STORK initrd",
+		.name		= "Consus kernel",
+		.offset		= 0x00040000,
 		.size		= 0x00100000,
-		.offset		= 0x00180000,
-	}, {
-		.name		= "STORK root cramfs",
-		.size		= 0x00300000,
-		.offset		= 0x00280000,
+		.mask_flags	= 0,
 	}, {
-		.name		= "STORK usr cramfs",
-		.size		= 0x00800000,
-		.offset		= 0x00580000,
+		.name		= "Consus disk",
+		.offset		= 0x00140000,
+		/* The rest (up to 16M) for jffs.  We could put 0 and
+		   make it find the size automatically, but right now
+		   i have 32 megs.  jffs will use all 32 megs if given
+		   the chance, and this leads to horrible problems
+		   when you try to re-flash the image because blob
+		   won't erase the whole partition. */
+		.size		= 0x01000000 - 0x00140000,
+		.mask_flags	= 0,
 	}, {
-		.name		= "STORK usr local",
-		.offset		= 0x00d80000,
-		.size		= MTDPART_SIZ_FULL,
-#endif
+		/* this disk is a secondary disk, which can be used as
+		   needed, for simplicity, make it the size of the other
+		   consus partition, although realistically it could be
+		   the remainder of the disk (depending on the file
+		   system used) */
+		 .name		= "Consus disk2",
+		 .offset	= 0x01000000,
+		 .size		= 0x01000000 - 0x00140000,
+		 .mask_flags	= 0,
 	}
 };
-#endif
 
-#ifdef CONFIG_SA1100_TRIZEPS
-static struct mtd_partition trizeps_partitions[] = {
+/* Frodo has 2 x 16M 28F128J3A flash chips in bank 0: */
+static struct mtd_partition frodo_partitions[] =
+{
 	{
-		.name		= "Bootloader",
-		.size		= 0x00100000,
-		.offset		= 0,
+		.name		= "bootloader",
+		.size		= 0x00040000,
+		.offset		= 0x00000000,
+		.mask_flags	= MTD_WRITEABLE
+	}, {
+		.name		= "bootloader params",
+		.size		= 0x00040000,
+		.offset		= MTDPART_OFS_APPEND,
+		.mask_flags	= MTD_WRITEABLE
 	}, {
-		.name		= "Kernel",
+		.name		= "kernel",
 		.size		= 0x00100000,
 		.offset		= MTDPART_OFS_APPEND,
+		.mask_flags	= MTD_WRITEABLE
 	}, {
-		.name		= "root",
-		.size		= MTDPART_SIZ_FULL,
+		.name		= "ramdisk",
+		.size		= 0x00400000,
 		.offset		= MTDPART_OFS_APPEND,
+		.mask_flags	= MTD_WRITEABLE
+	}, {
+		.name		= "file system",
+		.size		= MTDPART_SIZ_FULL,
+		.offset		= MTDPART_OFS_APPEND
 	}
 };
-#endif
 
-#ifdef CONFIG_SA1100_YOPY
-static struct mtd_partition yopy_partitions[] = {
+static struct mtd_partition jornada56x_partitions[] = {
 	{
-		.name		= "boot firmware",
+		.name		= "bootldr",
 		.size		= 0x00040000,
-		.offset		= 0x00000000,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "kernel",
-		.size		= 0x00080000,
-		.offset		= 0x00080000,
-	}, {
-		.name		= "initrd",
-		.size		= 0x00300000,
-		.offset		= 0x00100000,
+		.offset		= 0,
+		.mask_flags	= MTD_WRITEABLE,
 	}, {
-		.name		= "root",
-		.size		= 0x01000000,
-		.offset		= 0x00400000,
+		.name		= "rootfs",
+		.size		= MTDPART_SIZ_FULL,
+		.offset		= MTDPART_OFS_APPEND,
 	}
 };
-#endif
 
-static int __init sa1100_static_partitions(struct mtd_partition **parts)
+static void jornada56x_set_vpp(int vpp)
 {
-	int nb_parts = 0;
-
-#ifdef CONFIG_SA1100_ADSBITSY
-	if (machine_is_adsbitsy()) {
-		*parts       = adsbitsy_partitions;
-		nb_parts     = ARRAY_SIZE(adsbitsy_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_ASSABET
-	if (machine_is_assabet()) {
-		*parts       = assabet_partitions;
-		nb_parts     = ARRAY_SIZE(assabet_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_BADGE4
-	if (machine_is_badge4()) {
-		*parts       = badge4_partitions;
-		nb_parts     = ARRAY_SIZE(badge4_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_CERF
-	if (machine_is_cerf()) {
-		*parts       = cerf_partitions;
-		nb_parts     = ARRAY_SIZE(cerf_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_CONSUS
-	if (machine_is_consus()) {
-		*parts       = consus_partitions;
-		nb_parts     = ARRAY_SIZE(consus_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_FLEXANET
-	if (machine_is_flexanet()) {
-		*parts       = flexanet_partitions;
-		nb_parts     = ARRAY_SIZE(flexanet_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_FREEBIRD
-	if (machine_is_freebird()) {
-		*parts       = freebird_partitions;
-		nb_parts     = ARRAY_SIZE(freebird_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_FRODO
-	if (machine_is_frodo()) {
-		*parts       = frodo_partitions;
-		nb_parts     = ARRAY_SIZE(frodo_partitions);
-	}
-#endif	
-#ifdef CONFIG_SA1100_GRAPHICSCLIENT
-	if (machine_is_graphicsclient()) {
-		*parts       = graphicsclient_partitions;
-		nb_parts     = ARRAY_SIZE(graphicsclient_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_GRAPHICSMASTER
-	if (machine_is_graphicsmaster()) {
-		*parts       = graphicsmaster_partitions;
-		nb_parts     = ARRAY_SIZE(graphicsmaster_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_H3XXX
-	if (machine_is_h3xxx()) {
-		*parts       = h3xxx_partitions;
-		nb_parts     = ARRAY_SIZE(h3xxx_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_HACKKIT
-	if (machine_is_hackkit()) {
-		*parts = hackkit_partitions;
-		nb_parts = ARRAY_SIZE(hackkit_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_HUW_WEBPANEL
-	if (machine_is_huw_webpanel()) {
-		*parts       = huw_webpanel_partitions;
-		nb_parts     = ARRAY_SIZE(huw_webpanel_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_JORNADA720
-	if (machine_is_jornada720()) {
-		*parts       = jornada720_partitions;
-		nb_parts     = ARRAY_SIZE(jornada720_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_PANGOLIN
-	if (machine_is_pangolin()) {
-		*parts       = pangolin_partitions;
-		nb_parts     = ARRAY_SIZE(pangolin_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_PT_SYSTEM3
-	if (machine_is_pt_system3()) {
-		*parts       = system3_partitions;
-		nb_parts     = ARRAY_SIZE(system3_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_SHANNON
-	if (machine_is_shannon()) {
-		*parts       = shannon_partitions;
-		nb_parts     = ARRAY_SIZE(shannon_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_SHERMAN
-	if (machine_is_sherman()) {
-		*parts       = sherman_partitions;
-		nb_parts     = ARRAY_SIZE(sherman_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_SIMPAD
-	if (machine_is_simpad()) {
-		*parts       = simpad_partitions;
-		nb_parts     = ARRAY_SIZE(simpad_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_STORK
-	if (machine_is_stork()) {
-		*parts       = stork_partitions;
-		nb_parts     = ARRAY_SIZE(stork_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_TRIZEPS
-	if (machine_is_trizeps()) {
-		*parts       = trizeps_partitions;
-		nb_parts     = ARRAY_SIZE(trizeps_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_YOPY
-	if (machine_is_yopy()) {
-		*parts       = yopy_partitions;
-		nb_parts     = ARRAY_SIZE(yopy_partitions);
-	}
-#endif
-
-	return nb_parts;
+	if (vpp)
+		GPSR = GPIO_GPIO26;
+	else
+		GPCR = GPIO_GPIO26;
+	GPDR |= GPIO_GPIO26;
 }
+
+/*
+ * Machine        Phys          Size    set_vpp
+ * Consus    : SA1100_CS0_PHYS SZ_32M
+ * Frodo     : SA1100_CS0_PHYS SZ_32M
+ * Jornada56x: SA1100_CS0_PHYS SZ_32M jornada56x_set_vpp
+ */
 #endif
 
-struct sa_info {
-	unsigned long base;
-	unsigned long size;
-	int width;
-	void __iomem *vbase;
-        void (*set_vpp)(struct map_info *, int);
-	struct map_info *map;
+struct sa_subdev_info {
+	char name[16];
+	struct map_info map;
 	struct mtd_info *mtd;
-	struct resource *res;
+	struct flash_platform_data *data;
 };
 
-#define NR_SUBMTD 4
+struct sa_info {
+	struct mtd_partition	*parts;
+	struct mtd_info		*mtd;
+	int			num_subdev;
+	struct sa_subdev_info	subdev[0];
+};
 
-static struct sa_info info[NR_SUBMTD];
+static void sa1100_set_vpp(struct map_info *map, int on)
+{
+	struct sa_subdev_info *subdev = container_of(map, struct sa_subdev_info, map);
+	subdev->data->set_vpp(on);
+}
 
-static int __init sa1100_setup_mtd(struct sa_info *sa, int nr, struct mtd_info **rmtd)
+static void sa1100_destroy_subdev(struct sa_subdev_info *subdev)
 {
-	struct mtd_info *subdev[nr];
-	struct map_info *maps;
-	int i, found = 0, ret = 0;
+	if (subdev->mtd)
+		map_destroy(subdev->mtd);
+	if (subdev->map.virt)
+		iounmap(subdev->map.virt);
+	release_mem_region(subdev->map.phys, subdev->map.size);
+}
 
-	/*
-	 * Allocate the map_info structs in one go.
-	 */
-	maps = kmalloc(sizeof(struct map_info) * nr, GFP_KERNEL);
-	if (!maps)
-		return -ENOMEM;
+static int sa1100_probe_subdev(struct sa_subdev_info *subdev, struct resource *res)
+{
+	unsigned long phys;
+	unsigned int size;
+	int ret;
 
-	memset(maps, 0, sizeof(struct map_info) * nr);
+	phys = res->start;
+	size = res->end - phys + 1;
 
 	/*
-	 * Claim and then map the memory regions.
+	 * Retrieve the bankwidth from the MSC registers.
+	 * We currently only implement CS0 and CS1 here.
 	 */
-	for (i = 0; i < nr; i++) {
-		if (sa[i].base == (unsigned long)-1)
-			break;
+	switch (phys) {
+	default:
+		printk(KERN_WARNING "SA1100 flash: unknown base address "
+		       "0x%08lx, assuming CS0\n", phys);
 
-		sa[i].res = request_mem_region(sa[i].base, sa[i].size, "sa1100 flash");
-		if (!sa[i].res) {
-			ret = -EBUSY;
-			break;
-		}
-
-		sa[i].map = maps + i;
-
-		sa[i].vbase = ioremap(sa[i].base, sa[i].size);
-		if (!sa[i].vbase) {
-			ret = -ENOMEM;
-			break;
-		}
+	case SA1100_CS0_PHYS:
+		subdev->map.bankwidth = (MSC0 & MSC_RBW) ? 2 : 4;
+		break;
 
-		sa[i].map->virt = sa[i].vbase;
-		sa[i].map->phys = sa[i].base;
-		sa[i].map->set_vpp = sa[i].set_vpp;
-		sa[i].map->bankwidth = sa[i].width;
-		sa[i].map->size = sa[i].size;
-
-		simple_map_init(sa[i].map);
-
-		/*
-		 * Now let's probe for the actual flash.  Do it here since
-		 * specific machine settings might have been set above.
-		 */
-		sa[i].mtd = do_map_probe("cfi_probe", sa[i].map);
-		if (sa[i].mtd == NULL) {
-			ret = -ENXIO;
-			break;
-		}
-		sa[i].mtd->owner = THIS_MODULE;
-		subdev[i] = sa[i].mtd;
-
-		printk(KERN_INFO "SA1100 flash: CFI device at 0x%08lx, %dMiB, "
-			"%d-bit\n", sa[i].base, sa[i].mtd->size >> 20,
-			sa[i].width * 8);
-		found += 1;
+	case SA1100_CS1_PHYS:
+		subdev->map.bankwidth = ((MSC0 >> 16) & MSC_RBW) ? 2 : 4;
+		break;
 	}
 
-	/*
-	 * ENXIO is special.  It means we didn't find a chip when
-	 * we probed.  We need to tear down the mapping, free the
-	 * resource and mark it as such.
-	 */
-	if (ret == -ENXIO) {
-		iounmap(sa[i].vbase);
-		sa[i].vbase = NULL;
-		release_resource(sa[i].res);
-		sa[i].res = NULL;
+	if (!request_mem_region(phys, size, subdev->name)) {
+		ret = -EBUSY;
+		goto out;
 	}
 
-	/*
-	 * If we found one device, don't bother with concat support.
-	 * If we found multiple devices, use concat if we have it
-	 * available, otherwise fail.
-	 */
-	if (ret == 0 || ret == -ENXIO) {
-		if (found == 1) {
-			*rmtd = subdev[0];
-			ret = 0;
-		} else if (found > 1) {
-			/*
-			 * We detected multiple devices.  Concatenate
-			 * them together.
-			 */
-#ifdef CONFIG_MTD_CONCAT
-			*rmtd = mtd_concat_create(subdev, found,
-						  "sa1100 flash");
-			if (*rmtd == NULL)
-				ret = -ENXIO;
-#else
-			printk(KERN_ERR "SA1100 flash: multiple devices "
-			       "found but MTD concat support disabled.\n");
-			ret = -ENXIO;
-#endif
-		}
+	if (subdev->data->set_vpp)
+		subdev->map.set_vpp = sa1100_set_vpp;
+
+	subdev->map.phys = phys;
+	subdev->map.size = size;
+	subdev->map.virt = ioremap(phys, size);
+	if (!subdev->map.virt) {
+		ret = -ENOMEM;
+		goto err;
 	}
 
+	simple_map_init(&subdev->map);
+
 	/*
-	 * If we failed, clean up.
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
 	 */
-	if (ret) {
-		do {
-			if (sa[i].mtd)
-				map_destroy(sa[i].mtd);
-			if (sa[i].vbase)
-				iounmap(sa[i].vbase);
-			if (sa[i].res)
-				release_resource(sa[i].res);
-		} while (i--);
-
-		kfree(maps);
-	}
-
+	subdev->mtd = do_map_probe(subdev->data->map_name, &subdev->map);
+	if (subdev->mtd == NULL) {
+		ret = -ENXIO;
+		goto err;
+	}
+	subdev->mtd->owner = THIS_MODULE;
+
+	printk(KERN_INFO "SA1100 flash: CFI device at 0x%08lx, %dMiB, "
+		"%d-bit\n", phys, subdev->mtd->size >> 20,
+		subdev->map.bankwidth * 8);
+
+	return 0;
+
+ err:
+	sa1100_destroy_subdev(subdev);
+ out:
 	return ret;
 }
 
-static void __exit sa1100_destroy_mtd(struct sa_info *sa, struct mtd_info *mtd)
+static void sa1100_destroy(struct sa_info *info)
 {
 	int i;
 
-	del_mtd_partitions(mtd);
+	if (info->mtd) {
+		del_mtd_partitions(info->mtd);
 
 #ifdef CONFIG_MTD_CONCAT
-	if (mtd != sa[0].mtd)
-		mtd_concat_destroy(mtd);
+		if (info->mtd != info->subdev[0].mtd)
+			mtd_concat_destroy(info->mtd);
 #endif
-
-	for (i = NR_SUBMTD; i >= 0; i--) {
-		if (sa[i].mtd)
-			map_destroy(sa[i].mtd);
-		if (sa[i].vbase)
-			iounmap(sa[i].vbase);
-		if (sa[i].res)
-			release_resource(sa[i].res);
 	}
-	kfree(sa[0].map);
-}
 
-/*
- * A Thought: can we automatically detect the flash?
- *  - Check to see if the region is busy (yes -> failure)
- *  - Is the MSC setup for flash (no -> failure)
- *  - Probe for flash
- */
+	if (info->parts)
+		kfree(info->parts);
 
-static struct map_info sa1100_probe_map __initdata = {
-	.name		= "SA1100-flash",
-};
+	for (i = info->num_subdev - 1; i >= 0; i--)
+		sa1100_destroy_subdev(&info->subdev[i]);
+	kfree(info);
+}
 
-static void __init sa1100_probe_one_cs(unsigned int msc, unsigned long phys)
+static struct sa_info *__init
+sa1100_setup_mtd(struct platform_device *pdev, struct flash_platform_data *flash)
 {
-	struct mtd_info *mtd;
+	struct sa_info *info;
+	int nr, size, i, ret = 0;
 
-	printk(KERN_INFO "* Probing 0x%08lx: MSC = 0x%04x %d bit ",
-		phys, msc & 0xffff, msc & MSC_RBW ? 16 : 32);
-
-	if (check_mem_region(phys, 0x08000000)) {
-		printk("busy\n");
-		return;
-	}
+	/*
+	 * Count number of devices.
+	 */
+	for (nr = 0; ; nr++)
+		if (!platform_get_resource(pdev, IORESOURCE_MEM, nr))
+			break;
 
-	if ((msc & 3) == 1) {
-		printk("wrong type\n");
-		return;
+	if (nr == 0) {
+		ret = -ENODEV;
+		goto out;
 	}
 
-	sa1100_probe_map.bankwidth = msc & MSC_RBW ? 2 : 4;
-	sa1100_probe_map.size = SZ_1M;
-	sa1100_probe_map.phys = phys;
-	sa1100_probe_map.virt = (unsigned long)ioremap(phys, SZ_1M);
-	if (sa1100_probe_map.virt == 0)
-		goto fail;
-	simple_map_init(&sa1100_probe_map);
-
-	/* Shame cfi_probe blurts out kernel messages... */
-	mtd = do_map_probe("cfi_probe", &sa1100_probe_map);
-	if (mtd)
-		map_destroy(mtd);
-	iounmap((void *)sa1100_probe_map.virt);
-
-	if (!mtd)
-		goto fail;
+	size = sizeof(struct sa_info) + sizeof(struct sa_subdev_info) * nr;
 
-	printk("pass\n");
-	return;
+	/*
+	 * Allocate the map_info structs in one go.
+	 */
+	info = kmalloc(size, GFP_KERNEL);
+	if (!info) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
- fail:
-	printk("failed\n");
-}
+	memset(info, 0, size);
 
-static void __init sa1100_probe_flash(void)
-{
-	printk(KERN_INFO "-- SA11xx Flash probe.  Please report results.\n");
-	sa1100_probe_one_cs(MSC0, SA1100_CS0_PHYS);
-	sa1100_probe_one_cs(MSC0 >> 16, SA1100_CS1_PHYS);
-	sa1100_probe_one_cs(MSC1, SA1100_CS2_PHYS);
-	sa1100_probe_one_cs(MSC1 >> 16, SA1100_CS3_PHYS);
-	sa1100_probe_one_cs(MSC2, SA1100_CS4_PHYS);
-	sa1100_probe_one_cs(MSC2 >> 16, SA1100_CS5_PHYS);
-	printk(KERN_INFO "-- SA11xx Flash probe complete.\n");
-}
+	/*
+	 * Claim and then map the memory regions.
+	 */
+	for (i = 0; i < nr; i++) {
+		struct sa_subdev_info *subdev = &info->subdev[i];
+		struct resource *res;
 
-static int __init sa1100_locate_flash(void)
-{
-	int i, nr = -ENODEV;
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!res)
+			break;
 
-	sa1100_probe_flash();
+		subdev->map.name = subdev->name;
+		sprintf(subdev->name, "sa1100-%d", i);
+		subdev->data = flash;
 
-	if (machine_is_adsbitsy()) {
-		info[0].base = SA1100_CS1_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_assabet()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		info[1].base = SA1100_CS1_PHYS; /* neponset */
-		info[1].size = SZ_32M;
-		nr = 2;
-	}
-	if (machine_is_badge4()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_64M;
-		nr = 1;
-	}
-	if (machine_is_cerf()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_consus()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_flexanet()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_freebird()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_frodo()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_graphicsclient()) {
-		info[0].base = SA1100_CS1_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_graphicsmaster()) {
-		info[0].base = SA1100_CS1_PHYS;
-		info[0].size = SZ_16M;
-		nr = 1;
-	}
-	if (machine_is_h3xxx()) {
-		info[0].set_vpp = h3xxx_set_vpp;
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_huw_webpanel()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_16M;
-		nr = 1;
-	}
-	if (machine_is_itsy()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_jornada720()) {
-		info[0].set_vpp = jornada720_set_vpp;
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_nanoengine()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[1].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_pangolin()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_64M;
-		nr = 1;
-	}
-	if (machine_is_pfs168()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_pleb()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_4M;
-		info[1].base = SA1100_CS1_PHYS;
-		info[1].size = SZ_4M;
-		nr = 2;
-	}
-	if (machine_is_pt_system3()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_16M;
-		nr = 1;
-	}
-	if (machine_is_shannon()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_4M;
-		nr = 1;
-	}
-	if (machine_is_sherman()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_simpad()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_16M;
-		info[1].base = SA1100_CS1_PHYS;
-		info[1].size = SZ_16M;
-		nr = 2;
-	}
-	if (machine_is_stork()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_trizeps()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_16M;
-		nr = 1;
-	}
-	if (machine_is_victor()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_2M;
-		nr = 1;
-	}
-	if (machine_is_yopy()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_64M;
-		info[1].base = SA1100_CS1_PHYS;
-		info[1].size = SZ_64M;
-		nr = 2;
+		ret = sa1100_probe_subdev(subdev, res);
+		if (ret)
+			break;
 	}
 
-	if (nr < 0)
-		return nr;
+	info->num_subdev = i;
 
 	/*
-	 * Retrieve the bankwidth from the MSC registers.
-	 * We currently only implement CS0 and CS1 here.
+	 * ENXIO is special.  It means we didn't find a chip when we probed.
 	 */
-	for (i = 0; i < nr; i++) {
-		switch (info[i].base) {
-		default:
-			printk(KERN_WARNING "SA1100 flash: unknown base address "
-				"0x%08lx, assuming CS0\n", info[i].base);
-		case SA1100_CS0_PHYS:
-			info[i].width = (MSC0 & MSC_RBW) ? 2 : 4;
-			break;
+	if (ret != 0 && !(ret == -ENXIO && info->num_subdev > 0))
+		goto err;
 
-		case SA1100_CS1_PHYS:
-			info[i].width = ((MSC0 >> 16) & MSC_RBW) ? 2 : 4;
-			break;
-		}
+	/*
+	 * If we found one device, don't bother with concat support.  If
+	 * we found multiple devices, use concat if we have it available,
+	 * otherwise fail.  Either way, it'll be called "sa1100".
+	 */
+	if (info->num_subdev == 1) {
+		strcpy(info->subdev[0].name, "sa1100");
+		info->mtd = info->subdev[0].mtd;
+		ret = 0;
+	} else if (info->num_subdev > 1) {
+#ifdef CONFIG_MTD_CONCAT
+		struct mtd_info *cdev[nr];
+		/*
+		 * We detected multiple devices.  Concatenate them together.
+		 */
+		for (i = 0; i < info->num_subdev; i++)
+			cdev[i] = info->subdev[i].mtd;
+
+		info->mtd = mtd_concat_create(cdev, info->num_subdev,
+					      "sa1100");
+		if (info->mtd == NULL)
+			ret = -ENXIO;
+#else
+		printk(KERN_ERR "SA1100 flash: multiple devices "
+		       "found but MTD concat support disabled.\n");
+		ret = -ENXIO;
+#endif
 	}
 
-	return nr;
+	if (ret == 0)
+		return info;
+
+ err:
+	sa1100_destroy(info);
+ out:
+	return ERR_PTR(ret);
 }
 
-static struct mtd_partition *parsed_parts;
-const char *part_probes[] = { "cmdlinepart", "RedBoot", NULL };
+static const char *part_probes[] = { "cmdlinepart", "RedBoot", NULL };
 
-static void __init sa1100_locate_partitions(struct mtd_info *mtd)
+static int __init sa1100_mtd_probe(struct device *dev)
 {
+	struct platform_device *pdev = to_platform_device(dev);
+	struct flash_platform_data *flash = pdev->dev.platform_data;
+	struct mtd_partition *parts;
 	const char *part_type = NULL;
-	int nr_parts = 0;
+	struct sa_info *info;
+	int err, nr_parts = 0;
 
-	do {
-		/*
-		 * Partition selection stuff.
-		 */
+	if (!flash)
+		return -ENODEV;
+
+	info = sa1100_setup_mtd(pdev, flash);
+	if (IS_ERR(info)) {
+		err = PTR_ERR(info);
+		goto out;
+	}
+
+	/*
+	 * Partition selection stuff.
+	 */
 #ifdef CONFIG_MTD_PARTITIONS
-		nr_parts = parse_mtd_partitions(mtd, part_probes, &parsed_parts, 0);
-		if (nr_parts > 0) {
-			part_type = "dynamic";
-			break;
-		}
-#endif
-#ifdef CONFIG_MTD_SA1100_STATICMAP
-		nr_parts = sa1100_static_partitions(&parsed_parts);
-		if (nr_parts > 0) {
-			part_type = "static";
-			break;
-		}
+	nr_parts = parse_mtd_partitions(info->mtd, part_probes, &parts, 0);
+	if (nr_parts > 0) {
+		info->parts = parts;
+		part_type = "dynamic";
+	} else
 #endif
-	} while (0);
+	{
+		parts = flash->parts;
+		nr_parts = flash->nr_parts;
+		part_type = "static";
+	}
 
 	if (nr_parts == 0) {
 		printk(KERN_NOTICE "SA1100 flash: no partition info "
 			"available, registering whole flash\n");
-		add_mtd_device(mtd);
+		add_mtd_device(info->mtd);
 	} else {
 		printk(KERN_NOTICE "SA1100 flash: using %s partition "
 			"definition\n", part_type);
-		add_mtd_partitions(mtd, parsed_parts, nr_parts);
+		add_mtd_partitions(info->mtd, parts, nr_parts);
 	}
 
-	/* Always succeeds. */
+	dev_set_drvdata(dev, info);
+	err = 0;
+
+ out:
+	return err;
 }
 
-static void __exit sa1100_destroy_partitions(void)
+static int __exit sa1100_mtd_remove(struct device *dev)
 {
-	if (parsed_parts)
-		kfree(parsed_parts);
+	struct sa_info *info = dev_get_drvdata(dev);
+	dev_set_drvdata(dev, NULL);
+	sa1100_destroy(info);
+	return 0;
 }
 
-static struct mtd_info *mymtd;
-
-static int __init sa1100_mtd_init(void)
+#ifdef CONFIG_PM
+static int sa1100_mtd_suspend(struct device *dev, u32 state, u32 level)
 {
-	int ret;
-	int nr;
-
-	nr = sa1100_locate_flash();
-	if (nr < 0)
-		return nr;
+	struct sa_info *info = dev_get_drvdata(dev);
+	int ret = 0;
 
-	ret = sa1100_setup_mtd(info, nr, &mymtd);
-	if (ret == 0)
-		sa1100_locate_partitions(mymtd);
+	if (info && level == SUSPEND_SAVE_STATE)
+		ret = info->mtd->suspend(info->mtd);
 
 	return ret;
 }
 
-static void __exit sa1100_mtd_cleanup(void)
+static int sa1100_mtd_resume(struct device *dev, u32 level)
+{
+	struct sa_info *info = dev_get_drvdata(dev);
+	if (info && level == RESUME_RESTORE_STATE)
+		info->mtd->resume(info->mtd);
+	return 0;
+}
+#else
+#define sa1100_mtd_suspend NULL
+#define sa1100_mtd_resume  NULL
+#endif
+
+static struct device_driver sa1100_mtd_driver = {
+	.name		= "flash",
+	.bus		= &platform_bus_type,
+	.probe		= sa1100_mtd_probe,
+	.remove		= __exit_p(sa1100_mtd_remove),
+	.suspend	= sa1100_mtd_suspend,
+	.resume		= sa1100_mtd_resume,
+};
+
+static int __init sa1100_mtd_init(void)
+{
+	return driver_register(&sa1100_mtd_driver);
+}
+
+static void __exit sa1100_mtd_exit(void)
 {
-	sa1100_destroy_mtd(info, mymtd);
-	sa1100_destroy_partitions();
+	driver_unregister(&sa1100_mtd_driver);
 }
 
 module_init(sa1100_mtd_init);
-module_exit(sa1100_mtd_cleanup);
+module_exit(sa1100_mtd_exit);
 
 MODULE_AUTHOR("Nicolas Pitre");
 MODULE_DESCRIPTION("SA1100 CFI map driver");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/sbc_gxx.c linuxppc-2.6.9-dream/drivers/mtd/maps/sbc_gxx.c
--- linuxppc-2.6.9/drivers/mtd/maps/sbc_gxx.c	2004-10-18 23:54:32.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/sbc_gxx.c	2005-06-20 10:46:11.000000000 +0200
@@ -17,7 +17,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 
-   $Id: sbc_gxx.c,v 1.29 2004/07/12 22:38:29 dwmw2 Exp $
+   $Id: sbc_gxx.c,v 1.33 2004/11/28 09:40:40 dwmw2 Exp $
 
 The SBC-MediaGX / SBC-GXx has up to 16 MiB of 
 Intel StrataFlash (28F320/28F640) in x8 mode.  
@@ -84,8 +84,8 @@
 // Globals
 
 static volatile int page_in_window = -1; // Current page in window.
-static unsigned long iomapadr;
-static spinlock_t sbc_gxx_spin = SPIN_LOCK_UNLOCKED;
+static void __iomem *iomapadr;
+static DEFINE_SPINLOCK(sbc_gxx_spin);
 
 /* partition_info gives details on the logical partitions that the split the 
  * single flash device into. If the size if zero we use up to the end of the
@@ -189,13 +189,13 @@
 		map_destroy( all_mtd );
 	}
 
-	iounmap((void *)iomapadr);
+	iounmap(iomapadr);
 	release_region(PAGE_IO,PAGE_IO_SIZE);
 }
 
-int __init init_sbc_gxx(void)
+static int __init init_sbc_gxx(void)
 {
-  	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);
+  	iomapadr = ioremap(WINDOW_START, WINDOW_LENGTH);
 	if (!iomapadr) {
 		printk( KERN_ERR"%s: failed to ioremap memory region\n",
 			sbc_gxx_map.name );
@@ -206,7 +206,7 @@
 		printk( KERN_ERR"%s: IO ports 0x%x-0x%x in use\n",
 			sbc_gxx_map.name,
 			PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1 );
-		iounmap((void *)iomapadr);
+		iounmap(iomapadr);
 		return -EAGAIN;
 	}
 		
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/sc520cdp.c linuxppc-2.6.9-dream/drivers/mtd/maps/sc520cdp.c
--- linuxppc-2.6.9/drivers/mtd/maps/sc520cdp.c	2004-10-18 23:55:24.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/sc520cdp.c	2005-06-20 10:46:11.000000000 +0200
@@ -16,7 +16,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  *
- * $Id: sc520cdp.c,v 1.16 2004/07/12 21:59:45 dwmw2 Exp $
+ * $Id: sc520cdp.c,v 1.21 2004/12/13 10:27:08 dedekind Exp $
  *
  *
  * The SC520CDP is an evaluation board for the Elan SC520 processor available
@@ -186,12 +186,12 @@
 
 static void sc520cdp_setup_par(void)
 {
-	volatile unsigned long *mmcr;
+	volatile unsigned long __iomem *mmcr;
 	unsigned long mmcr_val;
 	int i, j;
 
 	/* map in SC520's MMCR area */
-	mmcr = (unsigned long *)ioremap_nocache(SC520_MMCR_BASE, SC520_MMCR_EXTENT);
+	mmcr = ioremap_nocache(SC520_MMCR_BASE, SC520_MMCR_EXTENT);
 	if(!mmcr) { /* ioremap_nocache failed: skip the PAR reprogramming */
 		/* force physical address fields to BIOS defaults: */
 		for(i = 0; i < NUM_FLASH_BANKS; i++)
@@ -223,7 +223,7 @@
 			sc520cdp_map[i].phys = par_table[i].default_address;
 		}
 	}
-	iounmap((void *)mmcr);
+	iounmap(mmcr);
 }
 #endif
 
@@ -241,7 +241,7 @@
 		printk(KERN_NOTICE "SC520 CDP flash device: 0x%lx at 0x%lx\n",
 		       sc520cdp_map[i].size, sc520cdp_map[i].phys);
 
-		sc520cdp_map[i].virt = (unsigned long)ioremap_nocache(sc520cdp_map[i].phys, sc520cdp_map[i].size);
+		sc520cdp_map[i].virt = ioremap_nocache(sc520cdp_map[i].phys, sc520cdp_map[i].size);
 
 		if (!sc520cdp_map[i].virt) {
 			printk("Failed to ioremap_nocache\n");
@@ -261,7 +261,7 @@
 			++devices_found;
 		}
 		else {
-			iounmap((void *)sc520cdp_map[i].virt);
+			iounmap(sc520cdp_map[i].virt);
 		}
 	}
 	if(devices_found >= 2) {
@@ -290,8 +290,8 @@
 		if (mymtd[i])
 			map_destroy(mymtd[i]);
 		if (sc520cdp_map[i].virt) {
-			iounmap((void *)sc520cdp_map[i].virt);
-			sc520cdp_map[i].virt = 0;
+			iounmap(sc520cdp_map[i].virt);
+			sc520cdp_map[i].virt = NULL;
 		}
 	}
 }
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/scb2_flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/scb2_flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/scb2_flash.c	2004-10-18 23:54:31.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/scb2_flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * MTD map driver for BIOS Flash on Intel SCB2 boards
- * $Id: scb2_flash.c,v 1.8 2004/07/12 21:59:45 dwmw2 Exp $
+ * $Id: scb2_flash.c,v 1.11 2004/11/28 09:40:40 dwmw2 Exp $
  * Copyright (C) 2002 Sun Microsystems, Inc.
  * Tim Hockin <thockin@sun.com>
  *
@@ -62,9 +62,9 @@
 #define SCB2_WINDOW	0x00100000
 
 
-static void *scb2_ioaddr;
+static void __iomem *scb2_ioaddr;
 static struct mtd_info *scb2_mtd;
-struct map_info scb2_map = {
+static struct map_info scb2_map = {
 	.name =      "SCB2 BIOS Flash",
 	.size =      0,
 	.bankwidth =  1,
@@ -163,7 +163,7 @@
 	}
 
 	scb2_map.phys = SCB2_ADDR;
-	scb2_map.virt = (unsigned long)scb2_ioaddr;
+	scb2_map.virt = scb2_ioaddr;
 	scb2_map.size = SCB2_WINDOW;
 
 	simple_map_init(&scb2_map);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/scx200_docflash.c linuxppc-2.6.9-dream/drivers/mtd/maps/scx200_docflash.c
--- linuxppc-2.6.9/drivers/mtd/maps/scx200_docflash.c	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/scx200_docflash.c	2005-06-20 10:46:11.000000000 +0200
@@ -2,7 +2,7 @@
 
    Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com>
 
-   $Id: scx200_docflash.c,v 1.6 2004/07/12 21:59:45 dwmw2 Exp $ 
+   $Id: scx200_docflash.c,v 1.10 2004/11/28 09:40:40 dwmw2 Exp $ 
 
    National Semiconductor SCx200 flash mapped with DOCCS
 */
@@ -26,23 +26,20 @@
 MODULE_DESCRIPTION("NatSemi SCx200 DOCCS Flash Driver");
 MODULE_LICENSE("GPL");
 
-/* Set this to one if you want to partition the flash */
-#define PARTITION 1
+static int probe = 0;		/* Don't autoprobe */
+static unsigned size = 0x1000000; /* 16 MiB the whole ISA address space */
+static unsigned width = 8;	/* Default to 8 bits wide */
+static char *flashtype = "cfi_probe";
 
-MODULE_PARM(probe, "i");
+module_param(probe, int, 0);
 MODULE_PARM_DESC(probe, "Probe for a BIOS mapping");
-MODULE_PARM(size, "i");
+module_param(size, int, 0);
 MODULE_PARM_DESC(size, "Size of the flash mapping");
-MODULE_PARM(width, "i");
+module_param(width, int, 0);
 MODULE_PARM_DESC(width, "Data width of the flash mapping (8/16)");
-MODULE_PARM(flashtype, "s");
+module_param(flashtype, charp, 0);
 MODULE_PARM_DESC(flashtype, "Type of MTD probe to do");
 
-static int probe = 0;		/* Don't autoprobe */
-static unsigned size = 0x1000000; /* 16 MiB the whole ISA address space */
-static unsigned width = 8;	/* Default to 8 bits wide */
-static char *flashtype = "cfi_probe";
-
 static struct resource docmem = {
 	.flags = IORESOURCE_MEM,
 	.name  = "NatSemi SCx200 DOCCS Flash",
@@ -50,7 +47,7 @@
 
 static struct mtd_info *mymtd;
 
-#if PARTITION
+#ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition partition_info[] = {
 	{ 
 		.name   = "DOCCS Boot kernel", 
@@ -81,7 +78,7 @@
 	.name      = "NatSemi SCx200 DOCCS Flash",
 };
 
-int __init init_scx200_docflash(void)
+static int __init init_scx200_docflash(void)
 {
 	unsigned u;
 	unsigned base;
@@ -180,7 +177,7 @@
 	simple_map_init(&scx200_docflash_map);
 
 	scx200_docflash_map.phys = docmem.start;
-	scx200_docflash_map.virt = (unsigned long)ioremap(docmem.start, scx200_docflash_map.size);
+	scx200_docflash_map.virt = ioremap(docmem.start, scx200_docflash_map.size);
 	if (!scx200_docflash_map.virt) {
 		printk(KERN_ERR NAME ": failed to ioremap the flash\n");
 		release_resource(&docmem);
@@ -190,7 +187,7 @@
 	mymtd = do_map_probe(flashtype, &scx200_docflash_map);
 	if (!mymtd) {
 		printk(KERN_ERR NAME ": unable to detect flash\n");
-		iounmap((void *)scx200_docflash_map.virt);
+		iounmap(scx200_docflash_map.virt);
 		release_resource(&docmem);
 		return -ENXIO;
 	}
@@ -200,7 +197,7 @@
 
 	mymtd->owner = THIS_MODULE;
 
-#if PARTITION
+#ifdef CONFIG_MTD_PARTITIONS
 	partition_info[3].offset = mymtd->size-partition_info[3].size;
 	partition_info[2].size = partition_info[3].offset-partition_info[2].offset;
 	add_mtd_partitions(mymtd, partition_info, NUM_PARTITIONS);
@@ -213,7 +210,7 @@
 static void __exit cleanup_scx200_docflash(void)
 {
 	if (mymtd) {
-#if PARTITION
+#ifdef CONFIG_MTD_PARTITIONS
 		del_mtd_partitions(mymtd);
 #else
 		del_mtd_device(mymtd);
@@ -221,7 +218,7 @@
 		map_destroy(mymtd);
 	}
 	if (scx200_docflash_map.virt) {
-		iounmap((void *)scx200_docflash_map.virt);
+		iounmap(scx200_docflash_map.virt);
 		release_resource(&docmem);
 	}
 }
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/sharpsl-flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/sharpsl-flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/sharpsl-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/sharpsl-flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,101 @@
+/*
+ * sharpsl-flash.c
+ * 
+ * Copyright (C) 2001 Lineo Japan, Inc.
+ * Copyright (C) 2002  SHARP
+ *
+ * $Id: sharpsl-flash.c,v 1.2 2004/11/24 20:38:06 rpurdie Exp $
+ *
+ * based on rpxlite.c,v 1.15 2001/10/02 15:05:14 dwmw2 Exp
+ *          Handle mapping of the flash on the RPX Lite and CLLF boards
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define WINDOW_ADDR 0x00000000
+#define WINDOW_SIZE 0x01000000
+#define BANK_WIDTH 2
+
+static struct mtd_info *mymtd;
+
+struct map_info sharpsl_map = {
+	.name = "sharpsl-flash",
+	.size = WINDOW_SIZE,
+	.bankwidth = BANK_WIDTH,
+	.phys = WINDOW_ADDR
+};
+
+static struct mtd_partition sharpsl_partitions[1] = {
+	{
+		name:		"Filesystem",
+		size:		0x006d0000,
+		offset:		0x00120000
+	}
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+int __init init_sharpsl(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type = "static";
+
+	printk(KERN_NOTICE "Sharp SL series flash device: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
+	sharpsl_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	if (!sharpsl_map.virt) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("map_rom", &sharpsl_map);
+	if (!mymtd) {
+		iounmap(sharpsl_map.virt);
+		return -ENXIO;
+	}
+
+	mymtd->owner = THIS_MODULE;
+
+	parts = sharpsl_partitions;
+	nb_parts = NB_OF(sharpsl_partitions);
+
+	printk(KERN_NOTICE "Using %s partision definition\n", part_type);
+	add_mtd_partitions(mymtd, parts, nb_parts);
+
+	return 0;
+}
+
+static void __exit cleanup_sharpsl(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (sharpsl_map.virt) {
+		iounmap(sharpsl_map.virt);
+		sharpsl_map.virt = 0;
+	}
+}
+
+module_init(init_sharpsl);
+module_exit(cleanup_sharpsl);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("SHARP (Original: Arnold Christensen <AKC@pel.dk>)");
+MODULE_DESCRIPTION("MTD map driver for SHARP SL series");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/solutionengine.c linuxppc-2.6.9-dream/drivers/mtd/maps/solutionengine.c
--- linuxppc-2.6.9/drivers/mtd/maps/solutionengine.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/solutionengine.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: solutionengine.c,v 1.13 2004/07/12 21:59:45 dwmw2 Exp $
+ * $Id: solutionengine.c,v 1.14 2004/09/16 23:27:14 gleixner Exp $
  *
  * Flash and EPROM on Hitachi Solution Engine and similar boards.
  *
@@ -62,9 +62,9 @@
 
 	/* First probe at offset 0 */
 	soleng_flash_map.phys = 0;
-	soleng_flash_map.virt = P2SEGADDR(0);
+	soleng_flash_map.virt = (void __iomem *)P2SEGADDR(0);
 	soleng_eprom_map.phys = 0x01000000;
-	soleng_eprom_map.virt = P1SEGADDR(0x01000000);
+	soleng_eprom_map.virt = (void __iomem *)P1SEGADDR(0x01000000);
 	simple_map_init(&soleng_eprom_map);
 	simple_map_init(&soleng_flash_map);
 	
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/sun_uflash.c linuxppc-2.6.9-dream/drivers/mtd/maps/sun_uflash.c
--- linuxppc-2.6.9/drivers/mtd/maps/sun_uflash.c	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/sun_uflash.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: sun_uflash.c,v 1.9 2004/07/12 21:59:45 dwmw2 Exp $
+/* $Id: sun_uflash.c,v 1.11 2004/11/04 13:24:15 gleixner Exp $
  *
  * sun_uflash - Driver implementation for user-programmable flash
  * present on many Sun Microsystems SME boardsets.
@@ -96,8 +96,7 @@
 		pdev->map.name = pdev->name;
 	}
 	pdev->map.phys = edev->resource[0].start;
-	pdev->map.virt = 
-		(unsigned long)ioremap_nocache(edev->resource[0].start, pdev->map.size);
+	pdev->map.virt = ioremap_nocache(edev->resource[0].start, pdev->map.size);
 	if(0 == pdev->map.virt) {
 		printk("%s: failed to map device\n", __FUNCTION__);
 		kfree(pdev->name);
@@ -110,7 +109,7 @@
 	/* MTD registration */
 	pdev->mtd = do_map_probe("cfi_probe", &pdev->map);
 	if(0 == pdev->mtd) {
-		iounmap((void *)pdev->map.virt);
+		iounmap(pdev->map.virt);
 		kfree(pdev->name);
 		kfree(pdev);
 		return(-ENXIO);
@@ -164,8 +163,8 @@
 			map_destroy(udev->mtd);
 		}
 		if(0 != udev->map.virt) {
-			iounmap((void*)udev->map.virt);
-			udev->map.virt = 0;
+			iounmap(udev->map.virt);
+			udev->map.virt = NULL;
 		}
 		if(0 != udev->name) {
 			kfree(udev->name);
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/tqm8xxl.c linuxppc-2.6.9-dream/drivers/mtd/maps/tqm8xxl.c
--- linuxppc-2.6.9/drivers/mtd/maps/tqm8xxl.c	2004-10-18 23:53:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/tqm8xxl.c	2005-06-20 10:46:11.000000000 +0200
@@ -2,7 +2,7 @@
  * Handle mapping of the flash memory access routines 
  * on TQM8xxL based devices.
  *
- * $Id: tqm8xxl.c,v 1.11 2004/07/12 21:59:45 dwmw2 Exp $
+ * $Id: tqm8xxl.c,v 1.13 2004/10/20 22:21:53 dwmw2 Exp $
  *
  * based on rpxlite.c
  *
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/ts5500_flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/ts5500_flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/ts5500_flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/ts5500_flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,141 @@
+/*
+ * ts5500_flash.c -- MTD map driver for Technology Systems TS-5500 board
+ *
+ * Copyright (C) 2004 Sean Young <sean@mess.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Note:
+ * - In order for detection to work, jumper 3 must be set.
+ * - Drive A and B use a proprietary FTL from General Software which isn't 
+ *   supported as of yet so standard drives can't be mounted; you can create 
+ *   your own (e.g. jffs) file system.
+ * - If you have created your own jffs file system and the bios overwrites 
+ *   it during boot, try disabling Drive A: and B: in the boot order.
+ *
+ * $Id: ts5500_flash.c,v 1.2 2004/11/28 09:40:40 dwmw2 Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+
+#ifdef CONFIG_MTD_PARTITIONS
+#include <linux/mtd/partitions.h>
+#endif
+
+#define WINDOW_ADDR	0x09400000
+#define WINDOW_SIZE	0x00200000
+
+static struct map_info ts5500_map = {
+	.name = "TS-5500 Flash",
+	.size = WINDOW_SIZE,
+	.bankwidth = 1,
+	.phys = WINDOW_ADDR
+};
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition ts5500_partitions[] = {
+	{
+		.name = "Drive A",
+		.offset = 0,
+		.size = 0x0e0000
+	},
+	{
+		.name = "BIOS",
+		.offset = 0x0e0000,
+		.size = 0x020000,
+	},
+	{
+		.name = "Drive B",
+		.offset = 0x100000,
+		.size = 0x100000
+	}
+};
+
+#define NUM_PARTITIONS (sizeof(ts5500_partitions)/sizeof(struct mtd_partition))
+
+#endif
+
+static struct mtd_info *mymtd;
+
+static int __init init_ts5500_map(void)
+{
+	int rc = 0;
+
+	ts5500_map.virt = ioremap_nocache(ts5500_map.phys, ts5500_map.size);
+
+	if(!ts5500_map.virt) {
+		printk(KERN_ERR "Failed to ioremap_nocache\n");
+		rc = -EIO;
+		goto err_out_ioremap;
+	}
+
+	simple_map_init(&ts5500_map);
+
+	mymtd = do_map_probe("jedec_probe", &ts5500_map);
+	if(!mymtd)
+		mymtd = do_map_probe("map_rom", &ts5500_map);
+
+	if(!mymtd) {
+		rc = -ENXIO;
+		goto err_out_map;
+	}
+
+	mymtd->owner = THIS_MODULE;
+#ifdef CONFIG_MTD_PARTITIONS
+	add_mtd_partitions(mymtd, ts5500_partitions, NUM_PARTITIONS);
+#else	
+	add_mtd_device(mymtd);
+#endif
+
+	return 0;
+
+err_out_map:
+	map_destroy(mymtd);
+err_out_ioremap:
+	iounmap(ts5500_map.virt);
+
+	return rc;
+}
+
+static void __exit cleanup_ts5500_map(void)
+{
+	if (mymtd) {
+#ifdef CONFIG_MTD_PARTITIONS
+		del_mtd_partitions(mymtd);
+#else
+		del_mtd_device(mymtd);
+#endif
+		map_destroy(mymtd);
+	}
+
+	if (ts5500_map.virt) {
+		iounmap(ts5500_map.virt);
+		ts5500_map.virt = NULL;
+	}
+}
+
+module_init(init_ts5500_map);
+module_exit(cleanup_ts5500_map);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sean Young <sean@mess.org>");
+MODULE_DESCRIPTION("MTD map driver for Techology Systems TS-5500 board");
+
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/uclinux.c linuxppc-2.6.9-dream/drivers/mtd/maps/uclinux.c
--- linuxppc-2.6.9/drivers/mtd/maps/uclinux.c	2004-10-18 23:55:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/uclinux.c	2005-06-20 10:46:11.000000000 +0200
@@ -5,7 +5,7 @@
  *
  *	(C) Copyright 2002, Greg Ungerer (gerg@snapgear.com)
  *
- * 	$Id: uclinux.c,v 1.7 2004/07/12 21:59:45 dwmw2 Exp $
+ * 	$Id: uclinux.c,v 1.10 2005/01/05 18:05:13 dwmw2 Exp $
  */
 
 /****************************************************************************/
@@ -47,7 +47,7 @@
 int uclinux_point(struct mtd_info *mtd, loff_t from, size_t len,
 	size_t *retlen, u_char **mtdbuf)
 {
-	struct map_info *map = (struct map_info *) mtd->priv;
+	struct map_info *map = mtd->priv;
 	*mtdbuf = (u_char *) (map->virt + ((int) from));
 	*retlen = len;
 	return(0);
@@ -71,7 +71,7 @@
 
 	mapp->virt = ioremap_nocache(mapp->phys, mapp->size);
 
-	if (!mapp->virt) {
+	if (mapp->virt == 0) {
 		printk("uclinux[mtd]: ioremap_nocache() failed\n");
 		return(-EIO);
 	}
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/walnut.c linuxppc-2.6.9-dream/drivers/mtd/maps/walnut.c
--- linuxppc-2.6.9/drivers/mtd/maps/walnut.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/walnut.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,122 @@
+/*
+ * $Id: walnut.c,v 1.2 2004/12/10 12:07:42 holindho Exp $
+ * 
+ * Mapping for Walnut flash
+ * (used ebony.c as a "framework")
+ * 
+ * Heikki Lindholm <holindho@infradead.org>
+ * 
+ * 
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+#include <linux/version.h>
+#include <asm/io.h>
+#include <asm/ibm4xx.h>
+#include <platforms/4xx/walnut.h>
+
+/* these should be in platforms/4xx/walnut.h ? */
+#define WALNUT_FLASH_ONBD_N(x)		(x & 0x02)
+#define WALNUT_FLASH_SRAM_SEL(x)	(x & 0x01)
+#define WALNUT_FLASH_LOW		0xFFF00000
+#define WALNUT_FLASH_HIGH		0xFFF80000
+#define WALNUT_FLASH_SIZE		0x80000
+
+static struct mtd_info *flash;
+
+static struct map_info walnut_map = {
+	.name =		"Walnut flash",
+	.size =		WALNUT_FLASH_SIZE,
+	.bankwidth =	1,
+};
+
+/* Actually, OpenBIOS is the last 128 KiB of the flash - better
+ * partitioning could be made */
+static struct mtd_partition walnut_partitions[] = {
+	{
+		.name =   "OpenBIOS",
+		.offset = 0x0,
+		.size =   WALNUT_FLASH_SIZE,
+		/*.mask_flags = MTD_WRITEABLE, */ /* force read-only */		
+	}
+};
+
+int __init init_walnut(void)
+{
+	u8 fpga_brds1;
+	void *fpga_brds1_adr;
+	void *fpga_status_adr;
+	unsigned long flash_base;
+
+	/* this should already be mapped (platform/4xx/walnut.c) */
+	fpga_status_adr = ioremap(WALNUT_FPGA_BASE, 8);
+	if (!fpga_status_adr)
+		return -ENOMEM;
+
+	fpga_brds1_adr = fpga_status_adr+5;
+	fpga_brds1 = readb(fpga_brds1_adr);
+	/* iounmap(fpga_status_adr); */
+
+	if (WALNUT_FLASH_ONBD_N(fpga_brds1)) {
+		printk("The on-board flash is disabled (U79 sw 5)!");
+		return -EIO;
+	}
+	if (WALNUT_FLASH_SRAM_SEL(fpga_brds1)) 
+		flash_base = WALNUT_FLASH_LOW;
+	else
+		flash_base = WALNUT_FLASH_HIGH;
+	
+	walnut_map.phys = flash_base;
+	walnut_map.virt =
+		(void __iomem *)ioremap(flash_base, walnut_map.size);
+
+	if (!walnut_map.virt) {
+		printk("Failed to ioremap flash.\n");
+		return -EIO;
+	}
+
+	simple_map_init(&walnut_map);
+
+	flash = do_map_probe("jedec_probe", &walnut_map);
+	if (flash) {
+		flash->owner = THIS_MODULE;
+		add_mtd_partitions(flash, walnut_partitions,
+					ARRAY_SIZE(walnut_partitions));
+	} else {
+		printk("map probe failed for flash\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static void __exit cleanup_walnut(void)
+{
+	if (flash) {
+		del_mtd_partitions(flash);
+		map_destroy(flash);
+	}
+
+	if (walnut_map.virt) {
+		iounmap((void *)walnut_map.virt);
+		walnut_map.virt = 0;
+	}
+}
+
+module_init(init_walnut);
+module_exit(cleanup_walnut);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Heikki Lindholm <holindho@infradead.org>");
+MODULE_DESCRIPTION("MTD map and partitions for IBM 405GP Walnut boards");
diff -Naur linuxppc-2.6.9/drivers/mtd/maps/wr_sbc82xx_flash.c linuxppc-2.6.9-dream/drivers/mtd/maps/wr_sbc82xx_flash.c
--- linuxppc-2.6.9/drivers/mtd/maps/wr_sbc82xx_flash.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/maps/wr_sbc82xx_flash.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: wr_sbc82xx_flash.c,v 1.5 2004/07/15 14:52:02 dwmw2 Exp $
+ * $Id: wr_sbc82xx_flash.c,v 1.7 2004/11/04 13:24:15 gleixner Exp $
  *
  * Map for flash chips on Wind River PowerQUICC II SBC82xx board.
  *
@@ -116,7 +116,7 @@
 		}
 		printk(" at %08lx)\n",  sbc82xx_flash_map[i].phys);
 
-		sbc82xx_flash_map[i].virt = (unsigned long)ioremap(sbc82xx_flash_map[i].phys, sbc82xx_flash_map[i].size);
+		sbc82xx_flash_map[i].virt = ioremap(sbc82xx_flash_map[i].phys, sbc82xx_flash_map[i].size);
 
 		if (!sbc82xx_flash_map[i].virt) {
 			printk("Failed to ioremap\n");
diff -Naur linuxppc-2.6.9/drivers/mtd/mtd_blkdevs.c linuxppc-2.6.9-dream/drivers/mtd/mtd_blkdevs.c
--- linuxppc-2.6.9/drivers/mtd/mtd_blkdevs.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/mtd_blkdevs.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: mtd_blkdevs.c,v 1.22 2004/07/12 12:35:28 dwmw2 Exp $
+ * $Id: mtd_blkdevs.c,v 1.24 2004/11/16 18:28:59 dwmw2 Exp $
  *
  * (C) 2003 David Woodhouse <dwmw2@infradead.org>
  *
@@ -81,7 +81,7 @@
 	struct request_queue *rq = tr->blkcore_priv->rq;
 
 	/* we might get involved when memory gets low, so use PF_MEMALLOC */
-	current->flags |= PF_MEMALLOC;
+	current->flags |= PF_MEMALLOC | PF_NOFREEZE;
 
 	daemonize("%sd", tr->name);
 
@@ -143,7 +143,7 @@
 }
 
 
-int blktrans_open(struct inode *i, struct file *f)
+static int blktrans_open(struct inode *i, struct file *f)
 {
 	struct mtd_blktrans_dev *dev;
 	struct mtd_blktrans_ops *tr;
@@ -174,7 +174,7 @@
 	return ret;
 }
 
-int blktrans_release(struct inode *i, struct file *f)
+static int blktrans_release(struct inode *i, struct file *f)
 {
 	struct mtd_blktrans_dev *dev;
 	struct mtd_blktrans_ops *tr;
@@ -326,7 +326,7 @@
 	return 0;
 }
 
-void blktrans_notify_remove(struct mtd_info *mtd)
+static void blktrans_notify_remove(struct mtd_info *mtd)
 {
 	struct list_head *this, *this2, *next;
 
@@ -342,7 +342,7 @@
 	}
 }
 
-void blktrans_notify_add(struct mtd_info *mtd)
+static void blktrans_notify_add(struct mtd_info *mtd)
 {
 	struct list_head *this;
 
diff -Naur linuxppc-2.6.9/drivers/mtd/mtdblock.c linuxppc-2.6.9-dream/drivers/mtd/mtdblock.c
--- linuxppc-2.6.9/drivers/mtd/mtdblock.c	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/mtdblock.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 /* 
  * Direct MTD block device access
  *
- * $Id: mtdblock.c,v 1.64 2003/10/04 17:14:14 dwmw2 Exp $
+ * $Id: mtdblock.c,v 1.66 2004/11/25 13:52:52 joern Exp $
  *
  * (C) 2000-2003 Nicolas Pitre <nico@cam.org>
  * (C) 1999-2003 David Woodhouse <dwmw2@infradead.org>
@@ -248,7 +248,7 @@
 			      unsigned long block, char *buf)
 {
 	struct mtdblk_dev *mtdblk = mtdblks[dev->devnum];
-	if (unlikely(!mtdblk->cache_data)) {
+	if (unlikely(!mtdblk->cache_data && mtdblk->cache_size)) {
 		mtdblk->cache_data = vmalloc(mtdblk->mtd->erasesize);
 		if (!mtdblk->cache_data)
 			return -EINTR;
@@ -361,7 +361,7 @@
 	kfree(dev);
 }
 
-struct mtd_blktrans_ops mtdblock_tr = {
+static struct mtd_blktrans_ops mtdblock_tr = {
 	.name		= "mtdblock",
 	.major		= 31,
 	.part_bits	= 0,
@@ -375,7 +375,7 @@
 	.owner		= THIS_MODULE,
 };
 
-int __init init_mtdblock(void)
+static int __init init_mtdblock(void)
 {
 	return register_mtd_blktrans(&mtdblock_tr);
 }
diff -Naur linuxppc-2.6.9/drivers/mtd/mtdblock.h linuxppc-2.6.9-dream/drivers/mtd/mtdblock.h
--- linuxppc-2.6.9/drivers/mtd/mtdblock.h	2004-10-18 23:53:45.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/mtdblock.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,35 +0,0 @@
-/*
- * drivers/mtd/mtdblock.h
- *
- * common defines for mtdblock-core and mtdblock-2x
- *
- * $Id: mtdblock.h,v 1.1 2002/11/27 10:33:37 gleixner Exp $
- *
- */
-
-#ifndef __MTD_MTDBLOCK_H__
-#define __MTD_MTDBLOCK_H__
-
-#define MAJOR_NR MTD_BLOCK_MAJOR
-#define DEVICE_NAME "mtdblock"
-
-struct mtdblk_dev {
-	struct mtd_info *mtd; /* Locked */
-	int count;
-	struct semaphore cache_sem;
-	unsigned char *cache_data;
-	unsigned long cache_offset;
-	unsigned int cache_size;
-	enum { STATE_EMPTY, STATE_CLEAN, STATE_DIRTY } cache_state;
-}; 
-
-extern int write_cached_data (struct mtdblk_dev *mtdblk);
-extern int do_cached_write (struct mtdblk_dev *mtdblk, unsigned long pos, 
-			    int len, const char *buf);
-extern int do_cached_read (struct mtdblk_dev *mtdblk, unsigned long pos, 
-			   int len, char *buf);
-
-extern void __exit cleanup_mtdblock(void);
-extern int __init init_mtdblock(void);
-
-#endif
diff -Naur linuxppc-2.6.9/drivers/mtd/mtdblock_ro.c linuxppc-2.6.9-dream/drivers/mtd/mtdblock_ro.c
--- linuxppc-2.6.9/drivers/mtd/mtdblock_ro.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/mtdblock_ro.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdblock_ro.c,v 1.18 2003/06/23 12:00:08 dwmw2 Exp $
+ * $Id: mtdblock_ro.c,v 1.19 2004/11/16 18:28:59 dwmw2 Exp $
  *
  * (C) 2003 David Woodhouse <dwmw2@infradead.org>
  *
@@ -58,7 +58,7 @@
 	kfree(dev);
 }
 
-struct mtd_blktrans_ops mtdblock_tr = {
+static struct mtd_blktrans_ops mtdblock_tr = {
 	.name		= "mtdblock",
 	.major		= 31,
 	.part_bits	= 0,
diff -Naur linuxppc-2.6.9/drivers/mtd/mtdchar.c linuxppc-2.6.9-dream/drivers/mtd/mtdchar.c
--- linuxppc-2.6.9/drivers/mtd/mtdchar.c	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/mtdchar.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdchar.c,v 1.64 2004/08/09 13:59:46 dwmw2 Exp $
+ * $Id: mtdchar.c,v 1.66 2005/01/05 18:05:11 dwmw2 Exp $
  *
  * Character-device access to raw MTD devices.
  *
@@ -61,7 +61,7 @@
 
 static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
 {
-	struct mtd_info *mtd=(struct mtd_info *)file->private_data;
+	struct mtd_info *mtd = file->private_data;
 
 	switch (orig) {
 	case 0:
@@ -134,7 +134,7 @@
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_close\n");
 
-	mtd = (struct mtd_info *)file->private_data;
+	mtd = file->private_data;
 	
 	if (mtd->sync)
 		mtd->sync(mtd);
@@ -151,7 +151,7 @@
 
 static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t *ppos)
 {
-	struct mtd_info *mtd = (struct mtd_info *)file->private_data;
+	struct mtd_info *mtd = file->private_data;
 	size_t retlen=0;
 	size_t total_retlen=0;
 	int ret=0;
@@ -179,7 +179,13 @@
 			return -ENOMEM;
 		
 		ret = MTD_READ(mtd, *ppos, len, &retlen, kbuf);
-		if (!ret) {
+		/* Nand returns -EBADMSG on ecc errors, but it returns
+		 * the data. For our userspace tools it is important
+		 * to dump areas with ecc errors ! 
+		 * Userspace software which accesses NAND this way
+		 * must be aware of the fact that it deals with NAND
+		 */
+		if (!ret || (ret == -EBADMSG)) {
 			*ppos += retlen;
 			if (copy_to_user(buf, kbuf, retlen)) {
 			        kfree(kbuf);
@@ -198,13 +204,13 @@
 		
 		kfree(kbuf);
 	}
-	
+
 	return total_retlen;
 } /* mtd_read */
 
 static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count,loff_t *ppos)
 {
-	struct mtd_info *mtd = (struct mtd_info *)file->private_data;
+	struct mtd_info *mtd = file->private_data;
 	char *kbuf;
 	size_t retlen;
 	size_t total_retlen=0;
@@ -270,7 +276,7 @@
 static int mtd_ioctl(struct inode *inode, struct file *file,
 		     u_int cmd, u_long arg)
 {
-	struct mtd_info *mtd = (struct mtd_info *)file->private_data;
+	struct mtd_info *mtd = file->private_data;
 	void __user *argp = (void __user *)arg;
 	int ret = 0;
 	u_long size;
diff -Naur linuxppc-2.6.9/drivers/mtd/mtdcore.c linuxppc-2.6.9-dream/drivers/mtd/mtdcore.c
--- linuxppc-2.6.9/drivers/mtd/mtdcore.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/mtdcore.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdcore.c,v 1.43 2004/07/23 15:20:46 dwmw2 Exp $
+ * $Id: mtdcore.c,v 1.44 2004/11/16 18:28:59 dwmw2 Exp $
  *
  * Core registration and callback routines for MTD
  * drivers and users.
@@ -382,7 +382,7 @@
 /*====================================================================*/
 /* Init code */
 
-int __init init_mtd(void)
+static int __init init_mtd(void)
 {
 #ifdef CONFIG_PROC_FS
 	if ((proc_mtd = create_proc_entry( "mtd", 0, NULL )))
diff -Naur linuxppc-2.6.9/drivers/mtd/mtdpart.c linuxppc-2.6.9-dream/drivers/mtd/mtdpart.c
--- linuxppc-2.6.9/drivers/mtd/mtdpart.c	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/mtdpart.c	2005-06-20 10:46:11.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: mtdpart.c,v 1.50 2004/08/10 16:18:34 dwmw2 Exp $
+ * $Id: mtdpart.c,v 1.51 2004/11/16 18:28:59 dwmw2 Exp $
  *
  * 	02-21-2002	Thomas Gleixner <gleixner@autronix.de>
  *			added support for read_oob, write_oob
@@ -526,7 +526,7 @@
 static spinlock_t part_parser_lock = SPIN_LOCK_UNLOCKED;
 static LIST_HEAD(part_parsers);
 
-struct mtd_part_parser *get_partition_parser(const char *name)
+static struct mtd_part_parser *get_partition_parser(const char *name)
 {
 	struct list_head *this;
 	void *ret = NULL;
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/au1550nd.c linuxppc-2.6.9-dream/drivers/mtd/nand/au1550nd.c
--- linuxppc-2.6.9/drivers/mtd/nand/au1550nd.c	2004-10-18 23:53:11.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/au1550nd.c	2005-06-20 10:46:11.000000000 +0200
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2004 Embedded Edge, LLC
  *
- * $Id: au1550nd.c,v 1.5 2004/05/17 07:19:35 ppopov Exp $
+ * $Id: au1550nd.c,v 1.11 2004/11/04 12:53:10 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +18,17 @@
 #include <linux/mtd/nand.h>
 #include <linux/mtd/partitions.h>
 #include <asm/io.h>
+
+/* fixme: this is ugly */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 0)
+#include <asm/mach-au1x00/au1000.h>
+#ifdef CONFIG_MIPS_PB1550
+#include <asm/mach-pb1x00/pb1550.h> 
+#endif
+#ifdef CONFIG_MIPS_DB1550
+#include <asm/mach-db1x00/db1x00.h> 
+#endif
+#else
 #include <asm/au1000.h>
 #ifdef CONFIG_MIPS_PB1550
 #include <asm/pb1550.h> 
@@ -25,18 +36,16 @@
 #ifdef CONFIG_MIPS_DB1550
 #include <asm/db1x00.h> 
 #endif
-
+#endif
 
 /*
  * MTD structure for NAND controller
  */
 static struct mtd_info *au1550_mtd = NULL;
-static volatile u32 p_nand;
-static int nand_width = 1; /* default, only x8 supported for now */
+static void __iomem *p_nand;
+static int nand_width = 1; /* default x8*/
 
-/* Internal buffers. Page buffer and oob buffer for one block*/
-static u_char data_buf[512 + 16];
-static u_char oob_buf[16 * 32];
+#define NAND_CS 1
 
 /*
  * Define partitions for flash device
@@ -70,183 +79,262 @@
 #endif
 };
 
-static inline void write_cmd_reg(u8 cmd)
+
+/**
+ * au_read_byte -  read one byte from the chip
+ * @mtd:	MTD device structure
+ *
+ *  read function for 8bit buswith
+ */
+static u_char au_read_byte(struct mtd_info *mtd)
 {
-	if (nand_width)
-		*((volatile u8 *)(p_nand + MEM_STNAND_CMD)) = cmd;
-	else
-		*((volatile u16 *)(p_nand + MEM_STNAND_CMD)) = cmd;
+	struct nand_chip *this = mtd->priv;
+	u_char ret = readb(this->IO_ADDR_R);
 	au_sync();
+	return ret;
 }
 
-static inline void write_addr_reg(u8 addr)
+/**
+ * au_write_byte -  write one byte to the chip
+ * @mtd:	MTD device structure
+ * @byte:	pointer to data byte to write
+ *
+ *  write function for 8it buswith
+ */
+static void au_write_byte(struct mtd_info *mtd, u_char byte)
 {
-	if (nand_width)
-		*((volatile u8 *)(p_nand + MEM_STNAND_ADDR)) = addr;
-	else
-		*((volatile u16 *)(p_nand + MEM_STNAND_ADDR)) = addr;
+	struct nand_chip *this = mtd->priv;
+	writeb(byte, this->IO_ADDR_W);
 	au_sync();
 }
 
-static inline void write_data_reg(u8 data)
+/**
+ * au_read_byte16 -  read one byte endianess aware from the chip
+ * @mtd:	MTD device structure
+ *
+ *  read function for 16bit buswith with 
+ * endianess conversion
+ */
+static u_char au_read_byte16(struct mtd_info *mtd)
 {
-	if (nand_width)
-		*((volatile u8 *)(p_nand + MEM_STNAND_DATA)) = data;
-	else
-		*((volatile u16 *)(p_nand + MEM_STNAND_DATA)) = data;
+	struct nand_chip *this = mtd->priv;
+	u_char ret = (u_char) cpu_to_le16(readw(this->IO_ADDR_R));
 	au_sync();
+	return ret;
 }
 
-static inline u32 read_data_reg(void)
+/**
+ * au_write_byte16 -  write one byte endianess aware to the chip
+ * @mtd:	MTD device structure
+ * @byte:	pointer to data byte to write
+ *
+ *  write function for 16bit buswith with
+ * endianess conversion
+ */
+static void au_write_byte16(struct mtd_info *mtd, u_char byte)
 {
-	u32 data;
-	if (nand_width) {
-		data = *((volatile u8 *)(p_nand + MEM_STNAND_DATA));
-		au_sync();
-	}
-	else {
-		data = *((volatile u16 *)(p_nand + MEM_STNAND_DATA));
-		au_sync();
-	}
-	return data;
+	struct nand_chip *this = mtd->priv;
+	writew(le16_to_cpu((u16) byte), this->IO_ADDR_W);
+	au_sync();
 }
 
-void au1550_hwcontrol(struct mtd_info *mtd, int cmd)
+/**
+ * au_read_word -  read one word from the chip
+ * @mtd:	MTD device structure
+ *
+ *  read function for 16bit buswith without 
+ * endianess conversion
+ */
+static u16 au_read_word(struct mtd_info *mtd)
 {
+	struct nand_chip *this = mtd->priv;
+	u16 ret = readw(this->IO_ADDR_R);
+	au_sync();
+	return ret;
 }
 
-int au1550_device_ready(struct mtd_info *mtd)
+/**
+ * au_write_word -  write one word to the chip
+ * @mtd:	MTD device structure
+ * @word:	data word to write
+ *
+ *  write function for 16bit buswith without 
+ * endianess conversion
+ */
+static void au_write_word(struct mtd_info *mtd, u16 word)
 {
-	int ready;
-	ready = (au_readl(MEM_STSTAT) & 0x1) ? 1 : 0;
-	return ready;
+	struct nand_chip *this = mtd->priv;
+	writew(word, this->IO_ADDR_W);
+	au_sync();
 }
 
-static u_char au1550_nand_read_byte(struct mtd_info *mtd)
+/**
+ * au_write_buf -  write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ *
+ *  write function for 8bit buswith
+ */
+static void au_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
 {
-	u_char ret;
-	ret = read_data_reg();
-	return ret;
-}
+	int i;
+	struct nand_chip *this = mtd->priv;
 
-static void au1550_nand_write_byte(struct mtd_info *mtd, u_char byte)
-{
-	write_data_reg((u8)byte);
+	for (i=0; i<len; i++) {
+		writeb(buf[i], this->IO_ADDR_W);
+		au_sync();
+	}
 }
 
-static void 
-au1550_nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
+/**
+ * au_read_buf -  read chip data into buffer 
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store date
+ * @len:	number of bytes to read
+ *
+ *  read function for 8bit buswith
+ */
+static void au_read_buf(struct mtd_info *mtd, u_char *buf, int len)
 {
 	int i;
+	struct nand_chip *this = mtd->priv;
 
-	for (i=0; i<len; i++)
-		write_data_reg(buf[i]);
+	for (i=0; i<len; i++) {
+		buf[i] = readb(this->IO_ADDR_R);
+		au_sync();	
+	}
 }
 
-static void 
-au1550_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+/**
+ * au_verify_buf -  Verify chip data against buffer 
+ * @mtd:	MTD device structure
+ * @buf:	buffer containing the data to compare
+ * @len:	number of bytes to compare
+ *
+ *  verify function for 8bit buswith
+ */
+static int au_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
 {
 	int i;
+	struct nand_chip *this = mtd->priv;
+
+	for (i=0; i<len; i++) {
+		if (buf[i] != readb(this->IO_ADDR_R))
+			return -EFAULT;
+		au_sync();
+	}
 
-	for (i=0; i<len; i++)
-		buf[i] = (u_char)read_data_reg();
+	return 0;
 }
 
-static int 
-au1550_nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
+/**
+ * au_write_buf16 -  write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ *
+ *  write function for 16bit buswith
+ */
+static void au_write_buf16(struct mtd_info *mtd, const u_char *buf, int len)
 {
 	int i;
+	struct nand_chip *this = mtd->priv;
+	u16 *p = (u16 *) buf;
+	len >>= 1;
+	
+	for (i=0; i<len; i++) {
+		writew(p[i], this->IO_ADDR_W);
+		au_sync();
+	}
+		
+}
 
-	for (i=0; i<len; i++)
-		if (buf[i] != (u_char)read_data_reg())
-			return -EFAULT;
+/**
+ * au_read_buf16 -  read chip data into buffer 
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store date
+ * @len:	number of bytes to read
+ *
+ *  read function for 16bit buswith
+ */
+static void au_read_buf16(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	u16 *p = (u16 *) buf;
+	len >>= 1;
 
-	return 0;
+	for (i=0; i<len; i++) {
+		p[i] = readw(this->IO_ADDR_R);
+		au_sync();
+	}
 }
 
-static void au1550_nand_select_chip(struct mtd_info *mtd, int chip)
+/**
+ * au_verify_buf16 -  Verify chip data against buffer 
+ * @mtd:	MTD device structure
+ * @buf:	buffer containing the data to compare
+ * @len:	number of bytes to compare
+ *
+ *  verify function for 16bit buswith
+ */
+static int au_verify_buf16(struct mtd_info *mtd, const u_char *buf, int len)
 {
-	switch(chip) {
-	case -1:
-		/* deassert chip enable */
-		au_writel(au_readl(MEM_STNDCTL) & ~0x20 , MEM_STNDCTL);
-		break;
-	case 0:
-		/* assert (force assert) chip enable */
-		au_writel(au_readl(MEM_STNDCTL) | 0x20 , MEM_STNDCTL);
-		break;
+	int i;
+	struct nand_chip *this = mtd->priv;
+	u16 *p = (u16 *) buf;
+	len >>= 1;
 
-	default:
-		BUG();
+	for (i=0; i<len; i++) {
+		if (p[i] != readw(this->IO_ADDR_R))
+			return -EFAULT;
+		au_sync();
 	}
+	return 0;
 }
 
-static void au1550_nand_command (struct mtd_info *mtd, unsigned command, 
-		int column, int page_addr)
+
+static void au1550_hwcontrol(struct mtd_info *mtd, int cmd)
 {
 	register struct nand_chip *this = mtd->priv;
 
-	/*
-	 * Write out the command to the device.
-	 */
-	if (command == NAND_CMD_SEQIN) {
-		int readcmd;
-
-		if (column >= mtd->oobblock) {
-			/* OOB area */
-			column -= mtd->oobblock;
-			readcmd = NAND_CMD_READOOB;
-		} else if (column < 256) {
-			/* First 256 bytes --> READ0 */
-			readcmd = NAND_CMD_READ0;
-		} else {
-			column -= 256;
-			readcmd = NAND_CMD_READ1;
-		}
-		write_cmd_reg(readcmd);
-	}
-	write_cmd_reg(command);
-
-	if (column != -1 || page_addr != -1) {
-
-		/* Serially input address */
-		if (column != -1)
-			write_addr_reg(column);
-		if (page_addr != -1) {
-			write_addr_reg((unsigned char) (page_addr & 0xff));
-			write_addr_reg(((page_addr >> 8) & 0xff));
-			/* One more address cycle for higher density devices */
-			if (mtd->size & 0x0c000000) 
-				write_addr_reg((unsigned char) ((page_addr >> 16) & 0x0f));
-		}
-	}
-	
-	switch (command) {
-			
-	case NAND_CMD_PAGEPROG:
-	case NAND_CMD_ERASE1:
-	case NAND_CMD_ERASE2:
-	case NAND_CMD_SEQIN:
-	case NAND_CMD_STATUS:
+	switch(cmd){
+
+	case NAND_CTL_SETCLE: this->IO_ADDR_W = p_nand + MEM_STNAND_CMD; break;
+	case NAND_CTL_CLRCLE: this->IO_ADDR_W = p_nand + MEM_STNAND_DATA; break;
+
+	case NAND_CTL_SETALE: this->IO_ADDR_W = p_nand + MEM_STNAND_ADDR; break;
+	case NAND_CTL_CLRALE: 
+		this->IO_ADDR_W = p_nand + MEM_STNAND_DATA; 
+		/* FIXME: Nobody knows why this is neccecary, 
+		 * but it works only that way */
+		udelay(1); 
 		break;
 
-	case NAND_CMD_RESET:
-		if (this->dev_ready)	
-			break;
-		udelay(this->chip_delay);
-		write_cmd_reg(NAND_CMD_STATUS);
-		while ( !(read_data_reg() & 0x40));
-		return;
-
-	/* This applies to read commands */	
-	default:
-		udelay (this->chip_delay);
+	case NAND_CTL_SETNCE: 
+		/* assert (force assert) chip enable */
+		au_writel((1<<(4+NAND_CS)) , MEM_STNDCTL); break;
+		break;
+
+	case NAND_CTL_CLRNCE: 
+ 		/* deassert chip enable */
+		au_writel(0, MEM_STNDCTL); break;
+		break;
 	}
+
+	this->IO_ADDR_R = this->IO_ADDR_W;
 	
-	/* wait until command is processed */
-	while (!this->dev_ready(mtd));
+	/* Drain the writebuffer */
+	au_sync();
 }
 
+int au1550_device_ready(struct mtd_info *mtd)
+{
+	int ret = (au_readl(MEM_STSTAT) & 0x1) ? 1 : 0;
+	au_sync();
+	return ret;
+}
 
 /*
  * Main initialization routine
@@ -255,7 +343,7 @@
 {
 	struct nand_chip *this;
 	u16 boot_swapboot = 0; /* default value */
-	u32 mem_time;
+	int retval;
 
 	/* Allocate memory for MTD device structure and private data */
 	au1550_mtd = kmalloc (sizeof(struct mtd_info) + 
@@ -275,11 +363,9 @@
 	/* Link the private data with the MTD structure */
 	au1550_mtd->priv = this;
 
-	/* disable interrupts */
-	au_writel(au_readl(MEM_STNDCTL) & ~(1<<8), MEM_STNDCTL);
 
-	/* disable NAND boot */
-	au_writel(au_readl(MEM_STNDCTL) & ~(1<<0), MEM_STNDCTL);
+	/* MEM_STNDCTL: disable ints, disable nand boot */
+	au_writel(0, MEM_STNDCTL);
 
 #ifdef CONFIG_MIPS_PB1550
 	/* set gpio206 high */
@@ -295,7 +381,6 @@
 		case 0xD:
 			/* x16 NAND Flash */
 			nand_width = 0;
-			printk("Pb1550 NAND: 16-bit NAND not supported by MTD\n");
 			break;
 		case 1:
 		case 9:
@@ -307,62 +392,62 @@
 			break;
 		default:
 			printk("Pb1550 NAND: bad boot:swap\n");
-			kfree(au1550_mtd);
-			return 1;
+			retval = -EINVAL;
+			goto outmem;
 	}
+#endif
 
 	/* Configure RCE1 - should be done by YAMON */
-	au_writel(0x5 | (nand_width << 22), MEM_STCFG1);
-	au_writel(NAND_TIMING, MEM_STTIME1);
-	mem_time = au_readl(MEM_STTIME1);
+	au_writel(0x5 | (nand_width << 22), 0xB4001010); /* MEM_STCFG1 */
+	au_writel(NAND_TIMING, 0xB4001014); /* MEM_STTIME1 */
 	au_sync();
 
-	/* setup and enable chip select */
+	/* setup and enable chip select, MEM_STADDR1 */
 	/* we really need to decode offsets only up till 0x20 */
 	au_writel((1<<28) | (NAND_PHYS_ADDR>>4) | 
 			(((NAND_PHYS_ADDR + 0x1000)-1) & (0x3fff<<18)>>18), 
 			MEM_STADDR1);
 	au_sync();
-#endif
-
-#ifdef CONFIG_MIPS_DB1550
-	/* Configure RCE1 - should be done by YAMON */
-	au_writel(0x00400005, MEM_STCFG1);
-	au_writel(0x00007774, MEM_STTIME1);
-	au_writel(0x12000FFF, MEM_STADDR1);
-#endif
 
-	p_nand = (volatile struct nand_regs *)ioremap(NAND_PHYS_ADDR, 0x1000);
+	p_nand = ioremap(NAND_PHYS_ADDR, 0x1000);
 
 	/* Set address of hardware control function */
 	this->hwcontrol = au1550_hwcontrol;
 	this->dev_ready = au1550_device_ready;
 	/* 30 us command delay time */
 	this->chip_delay = 30;		
-
-	this->cmdfunc = au1550_nand_command;
-	this->select_chip = au1550_nand_select_chip;
-	this->write_byte = au1550_nand_write_byte;
-	this->read_byte = au1550_nand_read_byte;
-	this->write_buf = au1550_nand_write_buf;
-	this->read_buf = au1550_nand_read_buf;
-	this->verify_buf = au1550_nand_verify_buf;
 	this->eccmode = NAND_ECC_SOFT;
 
-	/* Set internal data buffer */
-	this->data_buf = data_buf;
-	this->oob_buf = oob_buf;
+	this->options = NAND_NO_AUTOINCR;
+
+	if (!nand_width)
+		this->options |= NAND_BUSWIDTH_16;
+
+	this->read_byte = (!nand_width) ? au_read_byte16 : au_read_byte;
+	this->write_byte = (!nand_width) ? au_write_byte16 : au_write_byte;
+	this->write_word = au_write_word;
+	this->read_word = au_read_word;
+	this->write_buf = (!nand_width) ? au_write_buf16 : au_write_buf;
+	this->read_buf = (!nand_width) ? au_read_buf16 : au_read_buf;
+	this->verify_buf = (!nand_width) ? au_verify_buf16 : au_verify_buf;
 
 	/* Scan to find existence of the device */
 	if (nand_scan (au1550_mtd, 1)) {
-		kfree (au1550_mtd);
-		return -ENXIO;
+		retval = -ENXIO;
+		goto outio;
 	}
 
 	/* Register the partitions */
 	add_mtd_partitions(au1550_mtd, partition_info, NUM_PARTITIONS);
 
 	return 0;
+
+ outio:
+	iounmap ((void *)p_nand);
+	
+ outmem:
+	kfree (au1550_mtd);
+	return retval;
 }
 
 module_init(au1550_init);
@@ -375,16 +460,14 @@
 {
 	struct nand_chip *this = (struct nand_chip *) &au1550_mtd[1];
 
-	iounmap ((void *)p_nand);
-
-	/* Unregister partitions */
-	del_mtd_partitions(au1550_mtd);
-
-	/* Unregister the device */
-	del_mtd_device (au1550_mtd);
+	/* Release resources, unregister device */
+	nand_release (au1550_mtd);
 
 	/* Free the MTD device structure */
 	kfree (au1550_mtd);
+
+	/* Unmap */
+	iounmap ((void *)p_nand);
 }
 module_exit(au1550_cleanup);
 #endif
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/autcpu12.c linuxppc-2.6.9-dream/drivers/mtd/nand/autcpu12.c
--- linuxppc-2.6.9/drivers/mtd/nand/autcpu12.c	2004-10-18 23:53:22.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/autcpu12.c	2005-06-20 10:46:11.000000000 +0200
@@ -6,7 +6,7 @@
  *  Derived from drivers/mtd/spia.c
  * 	 Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  * 
- * $Id: autcpu12.c,v 1.20 2004/07/20 02:44:26 dwmw2 Exp $
+ * $Id: autcpu12.c,v 1.22 2004/11/04 12:53:10 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -48,17 +48,7 @@
 static int autcpu12_fio_pbase = AUTCPU12_PHYS_SMC;
 static int autcpu12_fio_ctrl = AUTCPU12_SMC_SELECT_OFFSET;
 static int autcpu12_pedr = AUTCPU12_SMC_PORT_OFFSET;
-static int autcpu12_fio_base;
-
-#ifdef MODULE
-MODULE_PARM(autcpu12_fio_pbase, "i");
-MODULE_PARM(autcpu12_fio_ctrl, "i");
-MODULE_PARM(autcpu12_pedr, "i");
-
-__setup("autcpu12_fio_pbase=",autcpu12_fio_pbase);
-__setup("autcpu12_fio_ctrl=",autcpu12_fio_ctrl);
-__setup("autcpu12_pedr=",autcpu12_pedr);
-#endif
+static void __iomem * autcpu12_fio_base;
 
 /*
  * Define partitions for flash devices
@@ -150,7 +140,7 @@
 	}
 
 	/* map physical adress */
-	autcpu12_fio_base=(unsigned long)ioremap(autcpu12_fio_pbase,SZ_1K);
+	autcpu12_fio_base = ioremap(autcpu12_fio_pbase,SZ_1K);
 	if(!autcpu12_fio_base){
 		printk("Ioremap autcpu12 SmartMedia Card failed\n");
 		err = -EIO;
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/diskonchip.c linuxppc-2.6.9-dream/drivers/mtd/nand/diskonchip.c
--- linuxppc-2.6.9/drivers/mtd/nand/diskonchip.c	2004-10-18 23:53:45.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/diskonchip.c	2005-06-20 10:46:11.000000000 +0200
@@ -8,16 +8,23 @@
  * Author: David Woodhouse <dwmw2@infradead.org>
  * Additional Diskonchip 2000 and Millennium support by Dan Brown <dan_brown@ieee.org>
  * Diskonchip Millennium Plus support by Kalev Lember <kalev@smartlink.ee>
- *
+ * 
+ * Error correction code lifted from the old docecc code
+ * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
+ * Copyright (C) 2000 Netgem S.A.
+ * converted to the generic Reed-Solomon library by Thomas Gleixner <tglx@linutronix.de>
+ *  
  * Interface to generic NAND code for M-Systems DiskOnChip devices
  *
- * $Id: diskonchip.c,v 1.34 2004/08/09 19:41:12 dbrown Exp $
+ * $Id: diskonchip.c,v 1.45 2005/01/05 18:05:14 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/delay.h>
+#include <linux/rslib.h>
+#include <linux/moduleparam.h>
 #include <asm/io.h>
 
 #include <linux/mtd/mtd.h>
@@ -62,7 +69,7 @@
 static struct mtd_info *doclist = NULL;
 
 struct doc_priv {
-	unsigned long virtadr;
+	void __iomem *virtadr;
 	unsigned long physadr;
 	u_char ChipID;
 	u_char CDSNControl;
@@ -96,28 +103,136 @@
 static void doc200x_select_chip(struct mtd_info *mtd, int chip);
 
 static int debug=0;
-MODULE_PARM(debug, "i");
+module_param(debug, int, 0);
 
 static int try_dword=1;
-MODULE_PARM(try_dword, "i");
+module_param(try_dword, int, 0);
 
 static int no_ecc_failures=0;
-MODULE_PARM(no_ecc_failures, "i");
+module_param(no_ecc_failures, int, 0);
 
+#ifdef CONFIG_MTD_PARTITIONS
 static int no_autopart=0;
-MODULE_PARM(no_autopart, "i");
+module_param(no_autopart, int, 0);
+#endif
 
 #ifdef MTD_NAND_DISKONCHIP_BBTWRITE
 static int inftl_bbt_write=1;
 #else
 static int inftl_bbt_write=0;
 #endif
-MODULE_PARM(inftl_bbt_write, "i");
+module_param(inftl_bbt_write, int, 0);
 
 static unsigned long doc_config_location = CONFIG_MTD_DISKONCHIP_PROBE_ADDRESS;
-MODULE_PARM(doc_config_location, "l");
+module_param(doc_config_location, ulong, 0);
 MODULE_PARM_DESC(doc_config_location, "Physical memory address at which to probe for DiskOnChip");
 
+
+/* Sector size for HW ECC */
+#define SECTOR_SIZE 512
+/* The sector bytes are packed into NB_DATA 10 bit words */
+#define NB_DATA (((SECTOR_SIZE + 1) * 8 + 6) / 10)
+/* Number of roots */
+#define NROOTS 4
+/* First consective root */
+#define FCR 510
+/* Number of symbols */
+#define NN 1023
+
+/* the Reed Solomon control structure */
+static struct rs_control *rs_decoder;
+
+/* 
+ * The HW decoder in the DoC ASIC's provides us a error syndrome,
+ * which we must convert to a standard syndrom usable by the generic
+ * Reed-Solomon library code.
+ *
+ * Fabrice Bellard figured this out in the old docecc code. I added
+ * some comments, improved a minor bit and converted it to make use
+ * of the generic Reed-Solomon libary. tglx
+ */
+static int doc_ecc_decode (struct rs_control *rs, uint8_t *data, uint8_t *ecc)
+{
+	int i, j, nerr, errpos[8];
+	uint8_t parity;
+	uint16_t ds[4], s[5], tmp, errval[8], syn[4];
+
+	/* Convert the ecc bytes into words */
+	ds[0] = ((ecc[4] & 0xff) >> 0) | ((ecc[5] & 0x03) << 8);
+	ds[1] = ((ecc[5] & 0xfc) >> 2) | ((ecc[2] & 0x0f) << 6);
+	ds[2] = ((ecc[2] & 0xf0) >> 4) | ((ecc[3] & 0x3f) << 4);
+	ds[3] = ((ecc[3] & 0xc0) >> 6) | ((ecc[0] & 0xff) << 2);
+	parity = ecc[1];
+
+	/* Initialize the syndrom buffer */
+	for (i = 0; i < NROOTS; i++)
+		s[i] = ds[0];
+	/* 
+	 *  Evaluate 
+	 *  s[i] = ds[3]x^3 + ds[2]x^2 + ds[1]x^1 + ds[0]
+	 *  where x = alpha^(FCR + i)
+	 */
+	for(j = 1; j < NROOTS; j++) {
+		if(ds[j] == 0)
+			continue;
+		tmp = rs->index_of[ds[j]];
+		for(i = 0; i < NROOTS; i++)
+			s[i] ^= rs->alpha_to[rs_modnn(rs, tmp + (FCR + i) * j)];
+	}
+
+	/* Calc s[i] = s[i] / alpha^(v + i) */
+	for (i = 0; i < NROOTS; i++) {
+		if (syn[i])
+ 			syn[i] = rs_modnn(rs, rs->index_of[s[i]] + (NN - FCR - i));
+	}
+	/* Call the decoder library */
+	nerr = decode_rs16(rs, NULL, NULL, 1019, syn, 0, errpos, 0, errval);
+
+	/* Incorrectable errors ? */
+	if (nerr < 0)
+		return nerr;
+
+	/* 
+	 * Correct the errors. The bitpositions are a bit of magic,
+	 * but they are given by the design of the de/encoder circuit
+	 * in the DoC ASIC's.
+	 */
+	for(i = 0;i < nerr; i++) {
+		int index, bitpos, pos = 1015 - errpos[i];
+		uint8_t val;
+		if (pos >= NB_DATA && pos < 1019)
+			continue;
+		if (pos < NB_DATA) {
+			/* extract bit position (MSB first) */
+			pos = 10 * (NB_DATA - 1 - pos) - 6;
+			/* now correct the following 10 bits. At most two bytes
+			   can be modified since pos is even */
+			index = (pos >> 3) ^ 1;
+			bitpos = pos & 7;
+			if ((index >= 0 && index < SECTOR_SIZE) || 
+			    index == (SECTOR_SIZE + 1)) {
+				val = (uint8_t) (errval[i] >> (2 + bitpos));
+				parity ^= val;
+				if (index < SECTOR_SIZE)
+					data[index] ^= val;
+			}
+			index = ((pos >> 3) + 1) ^ 1;
+			bitpos = (bitpos + 10) & 7;
+			if (bitpos == 0)
+				bitpos = 8;
+			if ((index >= 0 && index < SECTOR_SIZE) || 
+			    index == (SECTOR_SIZE + 1)) {
+				val = (uint8_t)(errval[i] << (8 - bitpos));
+				parity ^= val;
+				if (index < SECTOR_SIZE)
+					data[index] ^= val;
+			}
+		}
+	}
+	/* If the parity is wrong, no rescue possible */
+	return parity ? -1 : nerr;
+}
+
 static void DoC_Delay(struct doc_priv *doc, unsigned short cycles)
 {
 	volatile char dummy;
@@ -139,7 +254,7 @@
 /* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */
 static int _DoC_WaitReady(struct doc_priv *doc)
 {
-	unsigned long docptr = doc->virtadr;
+        void __iomem *docptr = doc->virtadr;
 	unsigned long timeo = jiffies + (HZ * 10);
 
 	if(debug) printk("_DoC_WaitReady...\n");
@@ -169,7 +284,7 @@
 
 static inline int DoC_WaitReady(struct doc_priv *doc)
 {
-	unsigned long docptr = doc->virtadr;
+        void __iomem *docptr = doc->virtadr;
 	int ret = 0;
 
 	if (DoC_is_MillenniumPlus(doc)) {
@@ -194,8 +309,8 @@
 static void doc2000_write_byte(struct mtd_info *mtd, u_char datum)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 
 	if(debug)printk("write_byte %02x\n", datum);
 	WriteDOC(datum, docptr, CDSNSlowIO);
@@ -205,8 +320,8 @@
 static u_char doc2000_read_byte(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	u_char ret;
 
 	ReadDOC(docptr, CDSNSlowIO);
@@ -220,8 +335,8 @@
 			     const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	int i;
 	if (debug)printk("writebuf of %d bytes: ", len);
 	for (i=0; i < len; i++) {
@@ -236,8 +351,8 @@
 			    u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
  	int i;
 
 	if (debug)printk("readbuf of %d bytes: ", len);
@@ -251,8 +366,8 @@
 			    u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
  	int i;
 
 	if (debug) printk("readbuf_dword of %d bytes: ", len);
@@ -272,8 +387,8 @@
 			      const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	int i;
 
 	for (i=0; i < len; i++)
@@ -285,7 +400,7 @@
 static uint16_t __init doc200x_ident_chip(struct mtd_info *mtd, int nr)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	uint16_t ret;
 
 	doc200x_select_chip(mtd, nr);
@@ -305,7 +420,7 @@
 			uint32_t dword;
 			uint8_t byte[4];
 		} ident;
-		unsigned long docptr = doc->virtadr;
+		void __iomem *docptr = doc->virtadr;
 
 		doc200x_hwcontrol(mtd, NAND_CTL_SETCLE);
 		doc2000_write_byte(mtd, NAND_CMD_READID);
@@ -327,7 +442,7 @@
 static void __init doc2000_count_chips(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	uint16_t mfrid;
 	int i;
 
@@ -348,7 +463,7 @@
 
 static int doc200x_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
 {
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 
 	int status;
 	
@@ -363,8 +478,8 @@
 static void doc2001_write_byte(struct mtd_info *mtd, u_char datum)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 
 	WriteDOC(datum, docptr, CDSNSlowIO);
 	WriteDOC(datum, docptr, Mil_CDSN_IO);
@@ -374,8 +489,8 @@
 static u_char doc2001_read_byte(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 
 	//ReadDOC(docptr, CDSNSlowIO);
 	/* 11.4.5 -- delay twice to allow extended length cycle */
@@ -389,8 +504,8 @@
 			     const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	int i;
 
 	for (i=0; i < len; i++)
@@ -403,8 +518,8 @@
 			    u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	int i;
 
 	/* Start read pipeline */
@@ -421,8 +536,8 @@
 			     const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	int i;
 
 	/* Start read pipeline */
@@ -441,8 +556,8 @@
 static u_char doc2001plus_read_byte(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	u_char ret;
 
         ReadDOC(docptr, Mplus_ReadPipeInit);
@@ -456,8 +571,8 @@
 			     const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	int i;
 
 	if (debug)printk("writebuf of %d bytes: ", len);
@@ -473,8 +588,8 @@
 			    u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	int i;
 
 	if (debug)printk("readbuf of %d bytes: ", len);
@@ -503,8 +618,8 @@
 			     const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	int i;
 
 	if (debug)printk("verifybuf of %d bytes: ", len);
@@ -529,8 +644,8 @@
 static void doc2001plus_select_chip(struct mtd_info *mtd, int chip)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	int floor = 0;
 
 	if(debug)printk("select chip (%d)\n", chip);
@@ -555,8 +670,8 @@
 static void doc200x_select_chip(struct mtd_info *mtd, int chip)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	int floor = 0;
 
 	if(debug)printk("select chip (%d)\n", chip);
@@ -582,8 +697,8 @@
 static void doc200x_hwcontrol(struct mtd_info *mtd, int cmd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 
 	switch(cmd) {
 	case NAND_CTL_SETNCE:
@@ -620,8 +735,8 @@
 static void doc2001plus_command (struct mtd_info *mtd, unsigned command, int column, int page_addr)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 
 	/*
 	 * Must terminate write pipeline before sending any commands
@@ -724,8 +839,8 @@
 static int doc200x_dev_ready(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 
 	if (DoC_is_MillenniumPlus(doc)) {
 		/* 11.4.2 -- must NOP four times before checking FR/B# */
@@ -762,8 +877,8 @@
 static void doc200x_enable_hwecc(struct mtd_info *mtd, int mode)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 
 	/* Prime the ECC engine */
 	switch(mode) {
@@ -781,8 +896,8 @@
 static void doc2001plus_enable_hwecc(struct mtd_info *mtd, int mode)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 
 	/* Prime the ECC engine */
 	switch(mode) {
@@ -802,8 +917,8 @@
 				 unsigned char *ecc_code)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	int i;
 	int emptymatch = 1;
 
@@ -860,8 +975,8 @@
 {
 	int i, ret = 0;
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	struct doc_priv *doc = this->priv;
+        void __iomem *docptr = doc->virtadr;
 	volatile u_char dummy;
 	int emptymatch = 1;
 	
@@ -914,7 +1029,7 @@
 		   erased block, in which case the ECC will not come out right.
 		   We'll suppress the error and tell the caller everything's
 		   OK.  Because it is. */
-		if (!emptymatch) ret = doc_decode_ecc (dat, calc_ecc);
+		if (!emptymatch) ret = doc_ecc_decode (rs_decoder, dat, calc_ecc);
 		if (ret > 0)
 			printk(KERN_ERR "doc200x_correct_data corrected %d errors\n", ret);
 	}	
@@ -948,7 +1063,7 @@
 				     const char *id, int findmirror)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	unsigned offs, end = (MAX_MEDIAHEADER_SCAN << this->phys_erase_shift);
 	int ret;
 	size_t retlen;
@@ -991,7 +1106,7 @@
 				struct mtd_partition *parts)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	int ret = 0;
 	u_char *buf;
 	struct NFTLMediaHeader *mh;
@@ -1087,7 +1202,7 @@
 				 struct mtd_partition *parts)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	int ret = 0;
 	u_char *buf;
 	struct INFTLMediaHeader *mh;
@@ -1212,7 +1327,7 @@
 {
 	int ret, numparts;
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	struct mtd_partition parts[2];
 
 	memset((char *) parts, 0, sizeof(parts));
@@ -1251,7 +1366,7 @@
 {
 	int ret, numparts;
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	struct mtd_partition parts[5];
 
 	if (this->numchips > doc->chips_per_floor) {
@@ -1310,7 +1425,7 @@
 static inline int __init doc2000_init(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 
 	this->write_byte = doc2000_write_byte;
 	this->read_byte = doc2000_read_byte;
@@ -1328,7 +1443,7 @@
 static inline int __init doc2001_init(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 
 	this->write_byte = doc2001_write_byte;
 	this->read_byte = doc2001_read_byte;
@@ -1360,7 +1475,7 @@
 static inline int __init doc2001plus_init(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 
 	this->write_byte = NULL;
 	this->read_byte = doc2001plus_read_byte;
@@ -1385,13 +1500,13 @@
 	struct mtd_info *mtd;
 	struct nand_chip *nand;
 	struct doc_priv *doc;
-	unsigned long virtadr;
+	void __iomem *virtadr;
 	unsigned char save_control;
 	unsigned char tmp, tmpb, tmpc;
 	int reg, len, numchips;
 	int ret = 0;
 
-	virtadr = (unsigned long)ioremap(physadr, DOC_IOREMAP_LEN);
+	virtadr = ioremap(physadr, DOC_IOREMAP_LEN);
 	if (!virtadr) {
 		printk(KERN_ERR "Diskonchip ioremap failed: 0x%x bytes at 0x%lx\n", DOC_IOREMAP_LEN, physadr);
 		return -EIO;
@@ -1482,7 +1597,7 @@
 		unsigned char oldval;
 		unsigned char newval;
 		nand = mtd->priv;
-		doc = (void *)nand->priv;
+		doc = nand->priv;
 		/* Use the alias resolution register to determine if this is
 		   in fact the same DOC aliased to a new address.  If writes
 		   to one chip's alias resolution register change the value on
@@ -1518,7 +1633,7 @@
 	      sizeof(struct nand_chip) +
 	      sizeof(struct doc_priv) +
 	      (2 * sizeof(struct nand_bbt_descr));
-	mtd = kmalloc(len, GFP_KERNEL);
+	mtd =  kmalloc(len, GFP_KERNEL);
 	if (!mtd) {
 		printk(KERN_ERR "DiskOnChip kmalloc (%d bytes) failed!\n", len);
 		ret = -ENOMEM;
@@ -1531,10 +1646,10 @@
 	nand->bbt_td		= (struct nand_bbt_descr *) (doc + 1);
 	nand->bbt_md		= nand->bbt_td + 1;
 
-	mtd->priv		= (void *) nand;
+	mtd->priv		= nand;
 	mtd->owner		= THIS_MODULE;
 
-	nand->priv		= (void *) doc;
+	nand->priv		= doc;
 	nand->select_chip	= doc200x_select_chip;
 	nand->hwcontrol		= doc200x_hwcontrol;
 	nand->dev_ready		= doc200x_dev_ready;
@@ -1543,7 +1658,7 @@
 	nand->enable_hwecc	= doc200x_enable_hwecc;
 	nand->calculate_ecc	= doc200x_calculate_ecc;
 	nand->correct_data	= doc200x_correct_data;
-	//nand->data_buf
+
 	nand->autooob		= &doc200x_oobinfo;
 	nand->eccmode		= NAND_ECC_HW6_512;
 	nand->options		= NAND_USE_FLASH_BBT | NAND_HWECC_SYNDROME;
@@ -1585,17 +1700,51 @@
 	   actually a DiskOnChip.  */
 	WriteDOC(save_control, virtadr, DOCControl);
 fail:
-	iounmap((void *)virtadr);
+	iounmap(virtadr);
 	return ret;
 }
 
-int __init init_nanddoc(void)
+static void release_nanddoc(void)
 {
-	int i;
+ 	struct mtd_info *mtd, *nextmtd;
+	struct nand_chip *nand;
+	struct doc_priv *doc;
+
+	for (mtd = doclist; mtd; mtd = nextmtd) {
+		nand = mtd->priv;
+		doc = nand->priv;
+
+		nextmtd = doc->nextdoc;
+		nand_release(mtd);
+		iounmap(doc->virtadr);
+		kfree(mtd);
+	}
+}
+
+static int __init init_nanddoc(void)
+{
+	int i, ret = 0;
+
+	/* We could create the decoder on demand, if memory is a concern.
+	 * This way we have it handy, if an error happens 
+	 *
+	 * Symbolsize is 10 (bits)
+	 * Primitve polynomial is x^10+x^3+1
+	 * first consecutive root is 510
+	 * primitve element to generate roots = 1
+	 * generator polinomial degree = 4
+	 */
+	rs_decoder = init_rs(10, 0x409, FCR, 1, NROOTS);
+ 	if (!rs_decoder) {
+		printk (KERN_ERR "DiskOnChip: Could not create a RS decoder\n");
+		return -ENOMEM;
+	}
 
 	if (doc_config_location) {
 		printk(KERN_INFO "Using configured DiskOnChip probe address 0x%lx\n", doc_config_location);
-		return doc_probe(doc_config_location);
+		ret = doc_probe(doc_config_location);
+		if (ret < 0)
+			goto outerr;
 	} else {
 		for (i=0; (doc_locations[i] != 0xffffffff); i++) {
 			doc_probe(doc_locations[i]);
@@ -1605,25 +1754,23 @@
 	   found, so the user knows we at least tried. */
 	if (!doclist) {
 		printk(KERN_INFO "No valid DiskOnChip devices found\n");
-		return -ENODEV;
+		ret = -ENODEV;
+		goto outerr;
 	}
 	return 0;
+outerr:
+	free_rs(rs_decoder);
+	return ret;
 }
 
-void __exit cleanup_nanddoc(void)
+static void __exit cleanup_nanddoc(void)
 {
-	struct mtd_info *mtd, *nextmtd;
-	struct nand_chip *nand;
-	struct doc_priv *doc;
+	/* Cleanup the nand/DoC resources */
+	release_nanddoc();
 
-	for (mtd = doclist; mtd; mtd = nextmtd) {
-		nand = mtd->priv;
-		doc = (void *)nand->priv;
-
-		nextmtd = doc->nextdoc;
-		nand_release(mtd);
-		iounmap((void *)doc->virtadr);
-		kfree(mtd);
+	/* Free the reed solomon resources */
+	if (rs_decoder) {
+		free_rs(rs_decoder);
 	}
 }
 
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/dreambox.c linuxppc-2.6.9-dream/drivers/mtd/nand/dreambox.c
--- linuxppc-2.6.9/drivers/mtd/nand/dreambox.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/dreambox.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,178 @@
+/*
+ *  drivers/mtd/nand/dreambox.c
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
+ *
+ *  Modified for Dreambox DM7020 by Felix Domke <tmbinc@elitedvb.net>
+ *
+ *
+ * $Id: dreambox.c,v 1.19 2003/04/20 07:24:40 gleixner Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   Dreambox board which utilizes the ... part. This is
+ *   a 128Mibit (16MiB x 8 bits) NAND flash device.
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+
+
+static struct mtd_info *dreambox_mtd = NULL;
+/*
+ * Define partitions for flash device
+ */
+const static struct mtd_partition partition_info[] = {
+	{
+		.name	= "complete",
+		.offset	= 0,
+		.size	= 32*1024*1024
+	},
+	{
+		.name	= "loader",
+		.offset	= 0,
+		.size	= 128*1024
+	},
+	{
+		.name	= "boot partition",
+		.offset	= 128*1024,
+		.size	= (2*1024-128-16)*1024
+	},
+	{
+		.name	= "root partition",
+		.offset	= 2*1024*1024,
+		.size	= 30*1024*1024
+	},
+};
+#define NUM_PARTITIONS 4
+
+/* 
+ *	hardware specific access to control-lines
+*/
+static void dreambox_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	switch(cmd){
+
+	case NAND_CTL_SETCLE: mtdcr(0x36, mfdcr(0x36) | 0x400); break;
+	case NAND_CTL_CLRCLE: mtdcr(0x36, mfdcr(0x36) & ~0x400); break;
+
+	case NAND_CTL_SETALE: (*(volatile unsigned long *) (0xe0060000)) |=  0x80000000 >> 17; break;
+	case NAND_CTL_CLRALE: (*(volatile unsigned long *) (0xe0060000)) &= ~(0x80000000 >> 17); break;
+
+	case NAND_CTL_SETNCE: (*(volatile unsigned long *) (0xe0060000)) &= ~(0x80000000 >> 16); (*(volatile unsigned long *) (0xe0060000)) |=  (0x80000000 >> 12); break;
+	case NAND_CTL_CLRNCE: (*(volatile unsigned long *) (0xe0060000)) |=  (0x80000000 >> 16); (*(volatile unsigned long *) (0xe0060000)) &= ~(0x80000000 >> 12); break;
+	default:
+		BUG();
+	}
+}
+
+static void dreambox_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+
+	int words = len >> 2;
+	unsigned long *res = (unsigned long*)buf;
+
+	volatile unsigned long *src = (void*)this->IO_ADDR_R;
+	while (words--)
+		*res++ = *src;
+
+	i = len & ~3;
+	len &= 3;
+	for (; i<len; i++)
+		buf[i] = readb(this->IO_ADDR_R);
+}
+
+/*
+ * Main initialization routine
+ */
+int __init dreambox_init (void)
+{
+	struct nand_chip *this;
+
+	/* Allocate memory for MTD device structure and private data */
+	dreambox_mtd = kmalloc (sizeof(struct mtd_info) + sizeof (struct nand_chip),
+				GFP_KERNEL);
+	if (!dreambox_mtd) {
+		printk ("Unable to allocate Dreambox NAND MTD device structure.\n");
+		return -ENOMEM;
+	}
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *) (&dreambox_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) dreambox_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) this, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	dreambox_mtd->priv = this;
+
+	// 0x7FE0 0000  read
+	// 0x7FD0 0000  write
+	
+	/* Set address of NAND IO lines */
+	this->IO_ADDR_R = ioremap_nocache(0xFFE00000, 4096);
+	this->IO_ADDR_W = ioremap_nocache(0xFFD00000, 4096);
+	
+	/* Set address of hardware control function */
+	this->hwcontrol = dreambox_hwcontrol;
+	this->read_buf = dreambox_nand_read_buf;
+	/* 15 us command delay time */
+	this->chip_delay = 15;		
+	this->eccmode = NAND_ECC_SOFT;
+
+	/* Scan to find existence of the device */
+	if (nand_scan (dreambox_mtd, 1)) {
+		kfree (dreambox_mtd);
+		return -ENXIO;
+	}
+
+	/* Allocate memory for internal data buffer */
+	this->data_buf = kmalloc (sizeof(u_char) * (dreambox_mtd->oobblock + dreambox_mtd->oobsize), GFP_KERNEL);
+
+	if (!this->data_buf) {
+		printk ("Unable to allocate NAND data buffer for Dreambox.\n");
+		kfree (dreambox_mtd);
+		return -ENOMEM;
+	}
+
+	/* Register the partitions */
+	add_mtd_partitions(dreambox_mtd, partition_info, NUM_PARTITIONS);
+
+	/* Return happy */
+	return 0;
+}
+module_init(dreambox_init);
+
+/*
+ * Clean up routine
+ */
+#ifdef MODULE
+static void __exit dreambox_cleanup (void)
+{
+	struct nand_chip *this = (struct nand_chip *) &dreambox_mtd[1];
+
+	/* Unregister the device */
+	del_mtd_device (dreambox_mtd);
+
+	/* Free internal data buffer */
+	kfree (this->data_buf);
+
+	/* Free the MTD device structure */
+	kfree (dreambox_mtd);
+}
+module_exit(dreambox_cleanup);
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Felix Domke <tmbinc@elitedvb.net>");
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/edb7312.c linuxppc-2.6.9-dream/drivers/mtd/nand/edb7312.c
--- linuxppc-2.6.9/drivers/mtd/nand/edb7312.c	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/edb7312.c	2005-06-20 10:46:11.000000000 +0200
@@ -6,7 +6,7 @@
  *  Derived from drivers/mtd/nand/autcpu12.c
  *       Copyright (c) 2001 Thomas Gleixner (gleixner@autronix.de)
  *
- * $Id: edb7312.c,v 1.8 2004/07/12 15:03:26 dwmw2 Exp $
+ * $Id: edb7312.c,v 1.11 2004/11/04 12:53:10 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -53,19 +53,9 @@
  * Module stuff
  */
 
-static int ep7312_fio_pbase = EP7312_FIO_PBASE;
-static int ep7312_pxdr = EP7312_PXDR;
-static int ep7312_pxddr = EP7312_PXDDR;
-
-#ifdef MODULE
-MODULE_PARM(ep7312_fio_pbase, "i");
-MODULE_PARM(ep7312_pxdr, "i");
-MODULE_PARM(ep7312_pxddr, "i");
-
-__setup("ep7312_fio_pbase=",ep7312_fio_pbase);
-__setup("ep7312_pxdr=",ep7312_pxdr);
-__setup("ep7312_pxddr=",ep7312_pxddr);
-#endif
+static unsigned long ep7312_fio_pbase = EP7312_FIO_PBASE;
+static void __iomem * ep7312_pxdr = (void __iomem *) EP7312_PXDR;
+static void __iomem * ep7312_pxddr = (void __iomem *) EP7312_PXDDR;
 
 #ifdef CONFIG_MTD_PARTITIONS
 /*
@@ -131,7 +121,7 @@
 	const char *part_type = 0;
 	int mtd_parts_nb = 0;
 	struct mtd_partition *mtd_parts = 0;
-	int ep7312_fio_base;
+	void __iomem * ep7312_fio_base;
 	
 	/* Allocate memory for MTD device structure and private data */
 	ep7312_mtd = kmalloc(sizeof(struct mtd_info) + 
@@ -143,7 +133,7 @@
 	}
 	
 	/* map physical adress */
-	ep7312_fio_base = (unsigned long)ioremap(ep7312_fio_pbase, SZ_1K);
+	ep7312_fio_base = ioremap(ep7312_fio_pbase, SZ_1K);
 	if(!ep7312_fio_base) {
 		printk("ioremap EDB7312 NAND flash failed\n");
 		kfree(ep7312_mtd);
@@ -181,16 +171,7 @@
 		return -ENXIO;
 	}
 	
-	/* Allocate memory for internal data buffer */
-	this->data_buf = kmalloc (sizeof(u_char) * (ep7312_mtd->oobblock + ep7312_mtd->oobsize), GFP_KERNEL);
-	if (!this->data_buf) {
-		printk("Unable to allocate NAND data buffer for EDB7312.\n");
-		iounmap((void *)ep7312_fio_base);
-		kfree (ep7312_mtd);
-		return -ENOMEM;
-	}
-	
-#ifdef CONFIG_PARTITIONS
+#ifdef CONFIG_MTD_PARTITIONS
 	ep7312_mtd->name = "edb7312-nand";
 	mtd_parts_nb = parse_mtd_partitions(ep7312_mtd, part_probes,
 					    &mtd_parts, 0);
@@ -221,8 +202,8 @@
 {
 	struct nand_chip *this = (struct nand_chip *) &ep7312_mtd[1];
 	
-	/* Unregister the device */
-	del_mtd_device (ep7312_mtd);
+	/* Release resources, unregister device */
+	nand_release (ap7312_mtd);
 	
 	/* Free internal data buffer */
 	kfree (this->data_buf);
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/h1910.c linuxppc-2.6.9-dream/drivers/mtd/nand/h1910.c
--- linuxppc-2.6.9/drivers/mtd/nand/h1910.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/h1910.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,208 @@
+/*
+ *  drivers/mtd/nand/h1910.c
+ *
+ *  Copyright (C) 2003 Joshua Wise (joshua@joshuawise.com)
+ *
+ *  Derived from drivers/mtd/nand/edb7312.c
+ *       Copyright (C) 2002 Marius Grger (mag@sysgo.de)
+ *       Copyright (c) 2001 Thomas Gleixner (gleixner@autronix.de)
+ *
+ * $Id: h1910.c,v 1.5 2004/11/04 12:53:10 gleixner Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   iPAQ h1910 board which utilizes the Samsung K9F2808 part. This is
+ *   a 128Mibit (16MiB x 8 bits) NAND flash device.
+ */
+
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h> /* for CLPS7111_VIRT_BASE */
+#include <asm/sizes.h>
+#include <asm/arch/h1900-gpio.h>
+#include <asm/arch/ipaq.h>
+
+/*
+ * MTD structure for EDB7312 board
+ */
+static struct mtd_info *h1910_nand_mtd = NULL;
+
+/*
+ * Module stuff
+ */
+
+#ifdef CONFIG_MTD_PARTITIONS
+/*
+ * Define static partitions for flash device
+ */
+static struct mtd_partition partition_info[] = {
+	{ name: "h1910 NAND Flash",
+		  offset: 0,
+		  size: 16*1024*1024 }
+};
+#define NUM_PARTITIONS 1
+
+#endif
+
+
+/* 
+ *	hardware specific access to control-lines
+ */
+static void h1910_hwcontrol(struct mtd_info *mtd, int cmd) 
+{
+	struct nand_chip* this = (struct nand_chip *) (mtd->priv);
+	
+	switch(cmd) {
+		
+	case NAND_CTL_SETCLE: 
+		this->IO_ADDR_R |= (1 << 2);
+		this->IO_ADDR_W |= (1 << 2);
+		break;
+	case NAND_CTL_CLRCLE: 
+		this->IO_ADDR_R &= ~(1 << 2);
+		this->IO_ADDR_W &= ~(1 << 2);
+		break;
+		
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_R |= (1 << 3);
+		this->IO_ADDR_W |= (1 << 3);
+		break;
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_R &= ~(1 << 3);
+		this->IO_ADDR_W &= ~(1 << 3);
+		break;
+		
+	case NAND_CTL_SETNCE:
+		break;
+	case NAND_CTL_CLRNCE:
+		break;
+	}
+}
+
+/*
+ *	read device ready pin
+ */
+#if 0
+static int h1910_device_ready(struct mtd_info *mtd)
+{
+	return (GPLR(55) & GPIO_bit(55));
+}
+#endif
+
+/*
+ * Main initialization routine
+ */
+static int __init h1910_init (void)
+{
+	struct nand_chip *this;
+	const char *part_type = 0;
+	int mtd_parts_nb = 0;
+	struct mtd_partition *mtd_parts = 0;
+	void __iomem *nandaddr;
+	
+	if (!machine_is_h1900())
+		return -ENODEV;
+		
+	nandaddr = __ioremap(0x08000000, 0x1000, 0, 1);
+	if (!nandaddr) {
+		printk("Failed to ioremap nand flash.\n");
+		return -ENOMEM;
+	}
+	
+	/* Allocate memory for MTD device structure and private data */
+	h1910_nand_mtd = kmalloc(sizeof(struct mtd_info) + 
+			     sizeof(struct nand_chip),
+			     GFP_KERNEL);
+	if (!h1910_nand_mtd) {
+		printk("Unable to allocate h1910 NAND MTD device structure.\n");
+		iounmap ((void *) nandaddr);
+		return -ENOMEM;
+	}
+	
+	/* Get pointer to private data */
+	this = (struct nand_chip *) (&h1910_nand_mtd[1]);
+	
+	/* Initialize structures */
+	memset((char *) h1910_nand_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) this, 0, sizeof(struct nand_chip));
+	
+	/* Link the private data with the MTD structure */
+	h1910_nand_mtd->priv = this;
+	
+	/*
+	 * Enable VPEN
+	 */
+	GPSR(37) = GPIO_bit(37);
+	
+	/* insert callbacks */
+	this->IO_ADDR_R = nandaddr;
+	this->IO_ADDR_W = nandaddr;
+	this->hwcontrol = h1910_hwcontrol;
+	this->dev_ready = NULL;	/* unknown whether that was correct or not so we will just do it like this */
+	/* 15 us command delay time */
+	this->chip_delay = 50;
+	this->eccmode = NAND_ECC_SOFT;
+	this->options = NAND_NO_AUTOINCR;
+	
+	/* Scan to find existence of the device */
+	if (nand_scan (h1910_nand_mtd, 1)) {
+		printk(KERN_NOTICE "No NAND device - returning -ENXIO\n");
+		kfree (h1910_nand_mtd);
+		iounmap ((void *) nandaddr);
+		return -ENXIO;
+	}
+	
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	mtd_parts_nb = parse_cmdline_partitions(h1910_nand_mtd, &mtd_parts, 
+						"h1910-nand");
+	if (mtd_parts_nb > 0)
+	  part_type = "command line";
+	else
+	  mtd_parts_nb = 0;
+#endif
+	if (mtd_parts_nb == 0)
+	{
+		mtd_parts = partition_info;
+		mtd_parts_nb = NUM_PARTITIONS;
+		part_type = "static";
+	}
+	
+	/* Register the partitions */
+	printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+	add_mtd_partitions(h1910_nand_mtd, mtd_parts, mtd_parts_nb);
+	
+	/* Return happy */
+	return 0;
+}
+module_init(h1910_init);
+
+/*
+ * Clean up routine
+ */
+static void __exit h1910_cleanup (void)
+{
+	struct nand_chip *this = (struct nand_chip *) &h1910_nand_mtd[1];
+	
+	/* Release resources, unregister device */
+	nand_release (h1910_nand_mtd);
+
+	/* Release io resource */
+	iounmap ((void *) this->IO_ADDR_W);
+
+	/* Free the MTD device structure */
+	kfree (h1910_nand_mtd);
+}
+module_exit(h1910_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Joshua Wise <joshua at joshuawise dot com>");
+MODULE_DESCRIPTION("NAND flash driver for iPAQ h1910");
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/Kconfig linuxppc-2.6.9-dream/drivers/mtd/nand/Kconfig
--- linuxppc-2.6.9/drivers/mtd/nand/Kconfig	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/Kconfig	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 # drivers/mtd/nand/Kconfig
-# $Id: Kconfig,v 1.17 2004/08/10 14:24:07 dwmw2 Exp $
+# $Id: Kconfig,v 1.26 2005/01/05 12:42:24 dwmw2 Exp $
 
 menu "NAND Flash Device Drivers"
 	depends on MTD!=n
@@ -7,6 +7,7 @@
 config MTD_NAND
 	tristate "NAND Device Support"
 	depends on MTD
+	select MTD_NAND_IDS
 	help
 	  This enables support for accessing all type of NAND flash
 	  devices. For further information see
@@ -36,6 +37,12 @@
 	  This enables the driver for the Cirrus Logic EBD7312 evaluation 
 	  board to access the onboard NAND Flash.
 
+config MTD_NAND_H1900
+	tristate "iPAQ H1900 flash"
+	depends on ARM && MTD_NAND && ARCH_PXA && MTD_PARTITIONS
+	help
+	  This enables the driver for the iPAQ h1900 flash.
+
 config MTD_NAND_SPIA
 	tristate "NAND Flash device on SPIA board"
 	depends on ARM && ARCH_P720T && MTD_NAND
@@ -48,10 +55,15 @@
 	help
 	  Support for NAND flash on Texas Instruments Toto platform.
 
+config MTD_NAND_DM7020
+	tristate "NAND Flash device on DM7020"
+	depends on DM7020
+	default y
+	help
+	  If you had to ask, you don't have one. Say 'N'.
+
 config MTD_NAND_IDS
 	tristate
-	default y if MTD_NAND = y || MTD_DOC2000 = y || MTD_DOC2001 = y || MTD_DOC2001PLUS = y
-	default m if MTD_NAND = m || MTD_DOC2000 = m || MTD_DOC2001 = m || MTD_DOC2001PLUS = m
 
 config MTD_NAND_TX4925NDFMC
 	tristate "SmartMedia Card on Toshiba RBTX4925 reference board"
@@ -74,15 +86,54 @@
 	  This enables the driver for the NAND flash controller on the
 	  AMD/Alchemy 1550 SOC.
 
+config MTD_NAND_RTC_FROM4
+	tristate "Renesas Flash ROM 4-slot interface board (FROM_BOARD4)"
+	depends on MTD_NAND && SH_SOLUTION_ENGINE
+	select REED_SOLOMON
+	select REED_SOLOMON_DEC8
+	help
+	  This enables the driver for the Renesas Technology AG-AND 
+	  flash interface board (FROM_BOARD4)
+
 config MTD_NAND_PPCHAMELEONEVB
 	tristate "NAND Flash device on PPChameleonEVB board"
 	depends on PPCHAMELEONEVB && MTD_NAND
 	help
-	  This enables the NAND flash driver on the PPChameleon EVB Board.	
+	  This enables the NAND flash driver on the PPChameleon EVB Board.
+
+config MTD_NAND_S3C2410
+	tristate "NAND Flash support for S3C2410 SoC"
+	depends on ARCH_S3C2410 && MTD_NAND
+	help
+	  This enables the NAND flash controller on the S3C2410.
+
+	  No board specfic support is done by this driver, each board
+	  must advertise a platform_device for the driver to attach. 
+
+config MTD_NAND_S3C2410_DEBUG
+	bool "S3C2410 NAND driver debug"
+	depends on MTD_NAND_S3C2410
+	help
+	  Enable debugging of the S3C2410 NAND driver
+
+config MTD_NAND_S3C2410_HWECC
+	bool "S3C2410 NAND Hardware ECC"
+	depends on MTD_NAND_S3C2410
+	help
+	  Enable the use of the S3C2410's internal ECC generator when
+	  using NAND. Early versions of the chip have had problems with
+	  incorrect ECC generation, and if using these, the default of
+	  software ECC is preferable.
+
+	  If you lay down a device with the hardware ECC, then you will
+	  currently not be able to switch to software, as there is no
+	  implementation for ECC method used by the S3C2410
 
 config MTD_NAND_DISKONCHIP
 	tristate "DiskOnChip 2000, Millennium and Millennium Plus (NAND reimplementation) (EXPERIMENTAL)"
 	depends on MTD_NAND && EXPERIMENTAL
+	select REED_SOLOMON
+	select REED_SOLOMON_DEC16
 	help
 	  This is a reimplementation of M-Systems DiskOnChip 2000,
 	  Millennium and Millennium Plus as a standard NAND device driver,
@@ -147,4 +198,17 @@
 	  Even if you leave this disabled, you can enable BBT writes at module
 	  load time (assuming you build diskonchip as a module) with the module
 	  parameter "inftl_bbt_write=1".
+	  
+ config MTD_NAND_SHARPSL
+ 	bool "Support for NAND Flash on Sharp SL Series (C7xx + others)"
+ 	depends on MTD_NAND	&& ARCH_PXA
+ 
+ config MTD_NAND_NANDSIM
+ 	bool "Support for NAND Flash Simulator"
+ 	depends on MTD_NAND && MTD_PARTITIONS
+
+	help
+	  The simulator may simulate verious NAND flash chips for the
+	  MTD nand layer.
+ 
 endmenu
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/Makefile linuxppc-2.6.9-dream/drivers/mtd/nand/Makefile
--- linuxppc-2.6.9/drivers/mtd/nand/Makefile	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/Makefile	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # linux/drivers/nand/Makefile
 #
-# $Id: Makefile.common,v 1.9 2004/07/12 16:07:31 dwmw2 Exp $
+# $Id: Makefile.common,v 1.15 2004/11/26 12:28:22 dedekind Exp $
 
 obj-$(CONFIG_MTD_NAND)			+= nand.o nand_ecc.o
 obj-$(CONFIG_MTD_NAND_IDS)		+= nand_ids.o
@@ -14,6 +14,12 @@
 obj-$(CONFIG_MTD_NAND_TX4938NDFMC)	+= tx4938ndfmc.o
 obj-$(CONFIG_MTD_NAND_AU1550)		+= au1550nd.o
 obj-$(CONFIG_MTD_NAND_PPCHAMELEONEVB)	+= ppchameleonevb.o
+obj-$(CONFIG_MTD_NAND_S3C2410)		+= s3c2410.o
 obj-$(CONFIG_MTD_NAND_DISKONCHIP)	+= diskonchip.o
+obj-$(CONFIG_MTD_NAND_H1900)		+= h1910.o
+obj-$(CONFIG_MTD_NAND_RTC_FROM4)	+= rtc_from4.o
+obj-$(CONFIG_MTD_NAND_SHARPSL)		+= sharpsl.o
+obj-$(CONFIG_MTD_NAND_NANDSIM)		+= nandsim.o
+obj-$(CONFIG_MTD_NAND_DM7020)		+= dreambox.o
 
 nand-objs = nand_base.o nand_bbt.o
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/nand_base.c linuxppc-2.6.9-dream/drivers/mtd/nand/nand_base.c
--- linuxppc-2.6.9/drivers/mtd/nand/nand_base.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/nand_base.c	2005-06-20 10:46:11.000000000 +0200
@@ -24,6 +24,10 @@
  *  
  *  05-19-2004  tglx: Basic support for Renesas AG-AND chips
  *
+ *  09-24-2004  tglx: add support for hardware controllers (e.g. ECC) shared
+ *		among multiple independend devices. Suggestions and initial patch
+ *		from Ben Dooks <ben-mtd@fluff.org>
+ *
  * Credits:
  *	David Woodhouse for adding multichip support  
  *	
@@ -37,7 +41,7 @@
  *	The AG-AND chips have nice features for speed improvement,
  *	which are not supported yet. Read / program 4 pages in one go.
  *
- * $Id: nand_base.c,v 1.115 2004/08/09 13:19:45 dwmw2 Exp $
+ * $Id: nand_base.c,v 1.126 2004/12/13 11:22:25 lavinen Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -131,25 +135,31 @@
 #define nand_verify_pages(...) (0)
 #endif
 		
-static void nand_get_chip (struct nand_chip *this, struct mtd_info *mtd, int new_state);
+static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state);
 
 /**
- * nand_release_chip - [GENERIC] release chip
+ * nand_release_device - [GENERIC] release chip
  * @mtd:	MTD device structure
  * 
  * Deselect, release chip lock and wake up anyone waiting on the device 
  */
-static void nand_release_chip (struct mtd_info *mtd)
+static void nand_release_device (struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
 
 	/* De-select the NAND device */
 	this->select_chip(mtd, -1);
+	/* Do we have a hardware controller ? */
+	if (this->controller) {
+		spin_lock(&this->controller->lock);
+		this->controller->active = NULL;
+		spin_unlock(&this->controller->lock);
+	}
 	/* Release the chip */
-	spin_lock_bh (&this->chip_lock);
+	spin_lock (&this->chip_lock);
 	this->state = FL_READY;
 	wake_up (&this->wq);
-	spin_unlock_bh (&this->chip_lock);
+	spin_unlock (&this->chip_lock);
 }
 
 /**
@@ -388,7 +398,7 @@
 		chipnr = (int)(ofs >> this->chip_shift);
 
 		/* Grab the lock and see if the device is available */
-		nand_get_chip (this, mtd, FL_READING);
+		nand_get_device (this, mtd, FL_READING);
 
 		/* Select the NAND device */
 		this->select_chip(mtd, chipnr);
@@ -410,7 +420,7 @@
 		
 	if (getchip) {
 		/* Deselect and wake up anyone waiting on the device */
-		nand_release_chip(mtd);
+		nand_release_device(mtd);
 	}	
 	
 	return res;
@@ -533,8 +543,8 @@
 		if (page_addr != -1) {
 			this->write_byte(mtd, (unsigned char) (page_addr & 0xff));
 			this->write_byte(mtd, (unsigned char) ((page_addr >> 8) & 0xff));
-			/* One more address cycle for higher density devices */
-			if (this->chipsize & 0x0c000000) 
+			/* One more address cycle for devices > 32MiB */
+			if (this->chipsize > (32 << 20))
 				this->write_byte(mtd, (unsigned char) ((page_addr >> 16) & 0x0f));
 		}
 		/* Latch in address */
@@ -689,15 +699,16 @@
 }
 
 /**
- * nand_get_chip - [GENERIC] Get chip for selected access
+ * nand_get_device - [GENERIC] Get chip for selected access
  * @this:	the nand chip descriptor
  * @mtd:	MTD device structure
  * @new_state:	the state which is requested 
  *
  * Get the device and lock it for exclusive access
  */
-static void nand_get_chip (struct nand_chip *this, struct mtd_info *mtd, int new_state)
+static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state)
 {
+	struct nand_chip *active = this;
 
 	DECLARE_WAITQUEUE (wait, current);
 
@@ -705,19 +716,29 @@
 	 * Grab the lock and see if the device is available 
 	*/
 retry:
-	spin_lock_bh (&this->chip_lock);
-
-	if (this->state == FL_READY) {
-		this->state = new_state;
-		spin_unlock_bh (&this->chip_lock);
-		return;
+	/* Hardware controller shared among independend devices */
+	if (this->controller) {
+		spin_lock (&this->controller->lock);
+		if (this->controller->active)
+			active = this->controller->active;
+		else
+			this->controller->active = this;
+		spin_unlock (&this->controller->lock);
 	}
-
+	
+	if (active == this) {
+		spin_lock (&this->chip_lock);
+		if (this->state == FL_READY) {
+			this->state = new_state;
+			spin_unlock (&this->chip_lock);
+			return;
+		}
+	}	
 	set_current_state (TASK_UNINTERRUPTIBLE);
-	add_wait_queue (&this->wq, &wait);
-	spin_unlock_bh (&this->chip_lock);
+	add_wait_queue (&active->wq, &wait);
+	spin_unlock (&active->chip_lock);
 	schedule ();
-	remove_wait_queue (&this->wq, &wait);
+	remove_wait_queue (&active->wq, &wait);
 	goto retry;
 }
 
@@ -747,7 +768,6 @@
 	 * any case on any machine. */
 	ndelay (100);
 
-	spin_lock_bh (&this->chip_lock);
 	if ((state == FL_ERASING) && (this->options & NAND_IS_AND))
 		this->cmdfunc (mtd, NAND_CMD_STATUS_MULTI, -1, -1);
 	else	
@@ -755,24 +775,19 @@
 
 	while (time_before(jiffies, timeo)) {		
 		/* Check, if we were interrupted */
-		if (this->state != state) {
-			spin_unlock_bh (&this->chip_lock);
+		if (this->state != state)
 			return 0;
-		}
+
 		if (this->dev_ready) {
 			if (this->dev_ready(mtd))
+				break;	
+		} else {
+			if (this->read_byte(mtd) & NAND_STATUS_READY)
 				break;
 		}
-		if (this->read_byte(mtd) & NAND_STATUS_READY)
-			break;
-						
-		spin_unlock_bh (&this->chip_lock);
 		yield ();
-		spin_lock_bh (&this->chip_lock);
 	}
 	status = (int) this->read_byte(mtd);
-	spin_unlock_bh (&this->chip_lock);
-
 	return status;
 }
 
@@ -795,7 +810,7 @@
 	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
 {
 	int 	i, status;
-	u_char	ecc_code[8];
+	u_char	ecc_code[32];
 	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
 	int  	*oob_config = oobsel->eccpos;
 	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
@@ -825,18 +840,8 @@
 		}
 		this->write_buf(mtd, this->data_poi, mtd->oobblock);
 		break;
-		
-	/* Hardware ecc 8 byte / 512 byte data */	
-	case NAND_ECC_HW8_512:	
-		eccbytes += 2;
-	/* Hardware ecc 6 byte / 512 byte data */	
-	case NAND_ECC_HW6_512:	
-		eccbytes += 3;
-	/* Hardware ecc 3 byte / 256 data */	
-	/* Hardware ecc 3 byte / 512 byte data */	
-	case NAND_ECC_HW3_256:		
-	case NAND_ECC_HW3_512:
-		eccbytes += 3;
+	default:
+		eccbytes = this->eccbytes;
 		for (; eccsteps; eccsteps--) {
 			/* enable hardware ecc logic for write */
 			this->enable_hwecc(mtd, NAND_ECC_WRITE);
@@ -849,14 +854,9 @@
 			 * the data bytes (words) */
 			if (this->options & NAND_HWECC_SYNDROME)
 				this->write_buf(mtd, ecc_code, eccbytes);
-
 			datidx += this->eccsize;
 		}
 		break;
-
-	default:
-		printk (KERN_WARNING "Invalid NAND_ECC_MODE %d\n", this->eccmode);
-		BUG();	
 	}
 										
 	/* Write out OOB data */
@@ -1036,7 +1036,7 @@
         int eccmode, eccsteps;
 	int	*oob_config, datidx;
 	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
-	int	eccbytes = 3;
+	int	eccbytes;
 	int	compareecc = 1;
 	int	oobreadlen;
 
@@ -1051,7 +1051,7 @@
 	}
 
 	/* Grab the lock and see if the device is available */
-	nand_get_chip (this, mtd ,FL_READING);
+	nand_get_device (this, mtd ,FL_READING);
 
 	/* use userspace supplied oobinfo, if zero */
 	if (oobsel == NULL)
@@ -1077,19 +1077,9 @@
 
 	end = mtd->oobblock;
 	ecc = this->eccsize;
-	switch (eccmode) {
-	case NAND_ECC_HW6_512: /* Hardware ECC 6 byte / 512 byte data  */
-		eccbytes = 6;
-		break;						
-	case NAND_ECC_HW8_512: /* Hardware ECC 8 byte / 512 byte data  */
-		eccbytes = 8;
-		break;
-	case NAND_ECC_NONE:
-		compareecc = 0;
-		break;						
-	}	 
-
-	if (this->options & NAND_HWECC_SYNDROME)
+	eccbytes = this->eccbytes;
+	
+	if ((eccmode == NAND_ECC_NONE) || (this->options & NAND_HWECC_SYNDROME))
 		compareecc = 0;
 
 	oobreadlen = mtd->oobsize;
@@ -1149,13 +1139,10 @@
 			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc) 
 				this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
 			break;	
-			
-		case NAND_ECC_HW3_256: /* Hardware ECC 3 byte /256 byte data */
-		case NAND_ECC_HW3_512: /* Hardware ECC 3 byte /512 byte data */	
-		case NAND_ECC_HW6_512: /* Hardware ECC 6 byte / 512 byte data  */
-		case NAND_ECC_HW8_512: /* Hardware ECC 8 byte / 512 byte data  */
+
+		default:
 			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=eccbytes, datidx += ecc) {
-				this->enable_hwecc(mtd, NAND_ECC_READ);	
+				this->enable_hwecc(mtd, NAND_ECC_READ);
 				this->read_buf(mtd, &data_poi[datidx], ecc);
 
 				/* HW ecc with syndrome calculation must read the
@@ -1178,10 +1165,6 @@
 				}	
 			}
 			break;						
-
-		default:
-			printk (KERN_WARNING "Invalid NAND_ECC_MODE %d\n", this->eccmode);
-			BUG();	
 		}
 
 		/* read oobdata */
@@ -1281,7 +1264,7 @@
 	}
 
 	/* Deselect and wake up anyone waiting on the device */
-	nand_release_chip(mtd);
+	nand_release_device(mtd);
 
 	/*
 	 * Return success, if no ECC failures, else -EBADMSG
@@ -1328,7 +1311,7 @@
 	}
 
 	/* Grab the lock and see if the device is available */
-	nand_get_chip (this, mtd , FL_READING);
+	nand_get_device (this, mtd , FL_READING);
 
 	/* Select the NAND device */
 	this->select_chip(mtd, chipnr);
@@ -1379,7 +1362,7 @@
 	}
 
 	/* Deselect and wake up anyone waiting on the device */
-	nand_release_chip(mtd);
+	nand_release_device(mtd);
 
 	/* Return happy */
 	*retlen = len;
@@ -1413,7 +1396,7 @@
 	}
 
 	/* Grab the lock and see if the device is available */
-	nand_get_chip (this, mtd , FL_READING);
+	nand_get_device (this, mtd , FL_READING);
 
 	this->select_chip (mtd, chip);
 	
@@ -1442,7 +1425,7 @@
 	}
 
 	/* Deselect and wake up anyone waiting on the device */
-	nand_release_chip(mtd);
+	nand_release_device(mtd);
 	return 0;
 }
 
@@ -1564,7 +1547,7 @@
 	}
 
 	/* Grab the lock and see if the device is available */
-	nand_get_chip (this, mtd, FL_WRITING);
+	nand_get_device (this, mtd, FL_WRITING);
 
 	/* Calculate chipnr */
 	chipnr = (int)(to >> this->chip_shift);
@@ -1669,7 +1652,7 @@
 
 out:
 	/* Deselect and wake up anyone waiting on the device */
-	nand_release_chip(mtd);
+	nand_release_device(mtd);
 
 	return ret;
 }
@@ -1709,7 +1692,7 @@
 	}
 
 	/* Grab the lock and see if the device is available */
-	nand_get_chip (this, mtd, FL_WRITING);
+	nand_get_device (this, mtd, FL_WRITING);
 
 	/* Select the NAND device */
 	this->select_chip(mtd, chipnr);
@@ -1771,7 +1754,7 @@
 	ret = 0;
 out:
 	/* Deselect and wake up anyone waiting on the device */
-	nand_release_chip(mtd);
+	nand_release_device(mtd);
 
 	return ret;
 }
@@ -1838,7 +1821,7 @@
 	}
 
 	/* Grab the lock and see if the device is available */
-	nand_get_chip (this, mtd, FL_WRITING);
+	nand_get_device (this, mtd, FL_WRITING);
 
 	/* Get the current chip-nr */
 	chipnr = (int) (to >> this->chip_shift);
@@ -1952,7 +1935,7 @@
 	ret = 0;
 out:
 	/* Deselect and wake up anyone waiting on the device */
-	nand_release_chip(mtd);
+	nand_release_device(mtd);
 
 	*retlen = written;
 	return ret;
@@ -2041,7 +2024,7 @@
 	instr->fail_addr = 0xffffffff;
 
 	/* Grab the lock and see if the device is available */
-	nand_get_chip (this, mtd, FL_ERASING);
+	nand_get_device (this, mtd, FL_ERASING);
 
 	/* Shift to get first page */
 	page = (int) (instr->addr >> this->page_shift);
@@ -2112,7 +2095,7 @@
 		mtd_erase_callback(instr);
 
 	/* Deselect and wake up anyone waiting on the device */
-	nand_release_chip(mtd);
+	nand_release_device(mtd);
 
 	/* Return more or less happy */
 	return ret;
@@ -2127,43 +2110,13 @@
 static void nand_sync (struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	DECLARE_WAITQUEUE (wait, current);
 
 	DEBUG (MTD_DEBUG_LEVEL3, "nand_sync: called\n");
 
-retry:
-	/* Grab the spinlock */
-	spin_lock_bh (&this->chip_lock);
-
-	/* See what's going on */
-	switch (this->state) {
-	case FL_READY:
-	case FL_SYNCING:
-		this->state = FL_SYNCING;
-		spin_unlock_bh (&this->chip_lock);
-		break;
-
-	default:
-		/* Not an idle state */
-		add_wait_queue (&this->wq, &wait);
-		spin_unlock_bh (&this->chip_lock);
-		schedule ();
-
-		remove_wait_queue (&this->wq, &wait);
-		goto retry;
-	}
-
-	/* Lock the device */
-	spin_lock_bh (&this->chip_lock);
-
-	/* Set the device to be ready again */
-	if (this->state == FL_SYNCING) {
-		this->state = FL_READY;
-		wake_up (&this->wq);
-	}
-
-	/* Unlock the device */
-	spin_unlock_bh (&this->chip_lock);
+	/* Grab the lock and see if the device is available */
+	nand_get_device (this, mtd, FL_SYNCING);
+	/* Release it and go back */
+	nand_release_device (mtd);
 }
 
 
@@ -2448,8 +2401,19 @@
 	 * fallback to software ECC 
 	*/
 	this->eccsize = 256;	/* set default eccsize */	
+	this->eccbytes = 3;
 
 	switch (this->eccmode) {
+	case NAND_ECC_HW12_2048:
+		if (mtd->oobblock < 2048) {
+			printk(KERN_WARNING "2048 byte HW ECC not possible on %d byte page size, fallback to SW ECC\n",
+			       mtd->oobblock);
+			this->eccmode = NAND_ECC_SOFT;
+			this->calculate_ecc = nand_calculate_ecc;
+			this->correct_data = nand_correct_data;
+		} else
+			this->eccsize = 2048;
+		break;
 
 	case NAND_ECC_HW3_512: 
 	case NAND_ECC_HW6_512: 
@@ -2459,16 +2423,13 @@
 			this->eccmode = NAND_ECC_SOFT;
 			this->calculate_ecc = nand_calculate_ecc;
 			this->correct_data = nand_correct_data;
-			break;		
 		} else 
-			this->eccsize = 512; /* set eccsize to 512 and fall through for function check */
-
+			this->eccsize = 512; /* set eccsize to 512 */
+		break;
+			
 	case NAND_ECC_HW3_256:
-		if (this->calculate_ecc && this->correct_data && this->enable_hwecc)
-			break;
-		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
-		BUG();	
-
+		break;
+		
 	case NAND_ECC_NONE: 
 		printk (KERN_WARNING "NAND_ECC_NONE selected by board driver. This is not recommended !!\n");
 		this->eccmode = NAND_ECC_NONE;
@@ -2483,11 +2444,32 @@
 		printk (KERN_WARNING "Invalid NAND_ECC_MODE %d\n", this->eccmode);
 		BUG();	
 	}	
-	
+
+	/* Check hardware ecc function availability and adjust number of ecc bytes per 
+	 * calculation step
+	*/
+	switch (this->eccmode) {
+	case NAND_ECC_HW12_2048:
+		this->eccbytes += 4;
+	case NAND_ECC_HW8_512: 
+		this->eccbytes += 2;
+	case NAND_ECC_HW6_512: 
+		this->eccbytes += 3;
+	case NAND_ECC_HW3_512: 
+	case NAND_ECC_HW3_256:
+		if (this->calculate_ecc && this->correct_data && this->enable_hwecc)
+			break;
+		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
+		BUG();	
+	}
+		
 	mtd->eccsize = this->eccsize;
 	
 	/* Set the number of read / write steps for one page to ensure ECC generation */
 	switch (this->eccmode) {
+	case NAND_ECC_HW12_2048:
+		this->eccsteps = mtd->oobblock / 2048;
+		break;
 	case NAND_ECC_HW3_512:
 	case NAND_ECC_HW6_512:
 	case NAND_ECC_HW8_512:
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/nand_bbt.c linuxppc-2.6.9-dream/drivers/mtd/nand/nand_bbt.c
--- linuxppc-2.6.9/drivers/mtd/nand/nand_bbt.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/nand_bbt.c	2005-06-20 10:46:11.000000000 +0200
@@ -6,7 +6,7 @@
  *   
  *  Copyright (C) 2004 Thomas Gleixner (tglx@linutronix.de)
  *
- * $Id: nand_bbt.c,v 1.24 2004/06/28 08:25:35 gleixner Exp $
+ * $Id: nand_bbt.c,v 1.28 2004/11/13 10:19:09 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -114,6 +114,7 @@
  * @num:	the number of bbt descriptors to read
  * @bits:	number of bits per block
  * @offs:	offset in the memory table
+ * @reserved_block_code:	Pattern to identify reserved blocks
  *
  * Read the bad block table starting from page.
  *
@@ -261,6 +262,10 @@
 
 	printk (KERN_INFO "Scanning device for bad blocks\n");
 
+#if defined(CONFIG_DM7020)
+	len = 2;
+	buf = kmalloc((512+16)*2, GFP_KERNEL);
+#else
 	if (bd->options & NAND_BBT_SCANALLPAGES)
 		len = 1 << (this->bbt_erase_shift - this->page_shift);
 	else {
@@ -269,6 +274,8 @@
 		else	
 			len = 1;
 	}
+#endif
+
 	scanlen	= mtd->oobblock + mtd->oobsize;
 	readlen = len * mtd->oobblock;
 	ooblen = len * mtd->oobsize;
@@ -304,6 +311,9 @@
 		i += 2;
 		from += (1 << this->bbt_erase_shift);
 	}
+#if defined(CONFIG_DM7020)
+	kfree(buf);
+#endif
 }
 
 /**
@@ -796,7 +806,7 @@
 
 	len = mtd->size >> (this->bbt_erase_shift + 2);
 	/* Allocate memory (2bit per block) */
-	this->bbt = (uint8_t *) kmalloc (len, GFP_KERNEL);
+	this->bbt = kmalloc (len, GFP_KERNEL);
 	if (!this->bbt) {
 		printk (KERN_ERR "nand_scan_bbt: Out of memory\n");
 		return -ENOMEM;
@@ -1000,25 +1010,27 @@
 		return nand_scan_bbt (mtd, &agand_flashbased);
 	}
 	
+	
 	/* Is a flash based bad block table requested ? */
 	if (this->options & NAND_USE_FLASH_BBT) {
 		/* Use the default pattern descriptors */	
 		if (!this->bbt_td) {	
 			this->bbt_td = &bbt_main_descr;
 			this->bbt_md = &bbt_mirror_descr;
-		}	
-		if (mtd->oobblock > 512)
-			return nand_scan_bbt (mtd, &largepage_flashbased);
-		else	
-			return nand_scan_bbt (mtd, &smallpage_flashbased);			
+		}
+		if (!this->badblock_pattern) {
+			this->badblock_pattern = (mtd->oobblock > 512) ?
+				&largepage_flashbased : &smallpage_flashbased;
+		}
 	} else {
 		this->bbt_td = NULL;
 		this->bbt_md = NULL;
-		if (mtd->oobblock > 512)
-			return nand_scan_bbt (mtd, &largepage_memorybased);
-		else
-			return nand_scan_bbt (mtd, &smallpage_memorybased);
+		if (!this->badblock_pattern) {
+			this->badblock_pattern = (mtd->oobblock > 512) ?
+				&largepage_memorybased : &smallpage_memorybased;
+		}
 	}
+	return nand_scan_bbt (mtd, this->badblock_pattern);
 }
 
 /**
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/nandsim.c linuxppc-2.6.9-dream/drivers/mtd/nand/nandsim.c
--- linuxppc-2.6.9/drivers/mtd/nand/nandsim.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/nandsim.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,1613 @@
+/*
+ * NAND flash simulator.
+ *
+ * Author: Artem B. Bityuckiy <dedekind@oktetlabs.ru>, <dedekind@infradead.org>
+ *
+ * Copyright (C) 2004 Nokia Corporation 
+ *
+ * Note: NS means "NAND Simulator".
+ * Note: Input means input TO flash chip, output means output FROM chip.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * $Id: nandsim.c,v 1.7 2004/12/06 11:53:06 dedekind Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#ifdef CONFIG_NS_ABS_POS
+#include <asm/io.h>
+#endif
+
+
+/* Default simulator parameters values */
+#if !defined(CONFIG_NANDSIM_FIRST_ID_BYTE)  || \
+    !defined(CONFIG_NANDSIM_SECOND_ID_BYTE) || \
+    !defined(CONFIG_NANDSIM_THIRD_ID_BYTE)  || \
+    !defined(CONFIG_NANDSIM_FOURTH_ID_BYTE)
+#define CONFIG_NANDSIM_FIRST_ID_BYTE  0x98
+#define CONFIG_NANDSIM_SECOND_ID_BYTE 0x39
+#define CONFIG_NANDSIM_THIRD_ID_BYTE  0xFF /* No byte */
+#define CONFIG_NANDSIM_FOURTH_ID_BYTE 0xFF /* No byte */
+#endif
+
+#ifndef CONFIG_NANDSIM_ACCESS_DELAY
+#define CONFIG_NANDSIM_ACCESS_DELAY 25
+#endif
+#ifndef CONFIG_NANDSIM_PROGRAMM_DELAY
+#define CONFIG_NANDSIM_PROGRAMM_DELAY 200
+#endif
+#ifndef CONFIG_NANDSIM_ERASE_DELAY
+#define CONFIG_NANDSIM_ERASE_DELAY 2
+#endif
+#ifndef CONFIG_NANDSIM_OUTPUT_CYCLE
+#define CONFIG_NANDSIM_OUTPUT_CYCLE 40
+#endif
+#ifndef CONFIG_NANDSIM_INPUT_CYCLE
+#define CONFIG_NANDSIM_INPUT_CYCLE  50
+#endif
+#ifndef CONFIG_NANDSIM_BUS_WIDTH
+#define CONFIG_NANDSIM_BUS_WIDTH  8
+#endif
+#ifndef CONFIG_NANDSIM_DO_DELAYS
+#define CONFIG_NANDSIM_DO_DELAYS  0
+#endif
+#ifndef CONFIG_NANDSIM_LOG
+#define CONFIG_NANDSIM_LOG        0
+#endif
+#ifndef CONFIG_NANDSIM_DBG
+#define CONFIG_NANDSIM_DBG        0
+#endif
+
+static uint first_id_byte  = CONFIG_NANDSIM_FIRST_ID_BYTE;
+static uint second_id_byte = CONFIG_NANDSIM_SECOND_ID_BYTE;
+static uint third_id_byte  = CONFIG_NANDSIM_THIRD_ID_BYTE;
+static uint fourth_id_byte = CONFIG_NANDSIM_FOURTH_ID_BYTE;
+static uint access_delay   = CONFIG_NANDSIM_ACCESS_DELAY;
+static uint programm_delay = CONFIG_NANDSIM_PROGRAMM_DELAY;
+static uint erase_delay    = CONFIG_NANDSIM_ERASE_DELAY;
+static uint output_cycle   = CONFIG_NANDSIM_OUTPUT_CYCLE;
+static uint input_cycle    = CONFIG_NANDSIM_INPUT_CYCLE;
+static uint bus_width      = CONFIG_NANDSIM_BUS_WIDTH;
+static uint do_delays      = CONFIG_NANDSIM_DO_DELAYS;
+static uint log            = CONFIG_NANDSIM_LOG;
+static uint dbg            = CONFIG_NANDSIM_DBG;
+
+module_param(first_id_byte,  uint, 0400);
+module_param(second_id_byte, uint, 0400);
+module_param(third_id_byte,  uint, 0400);
+module_param(fourth_id_byte, uint, 0400);
+module_param(access_delay,   uint, 0400);
+module_param(programm_delay, uint, 0400);
+module_param(erase_delay,    uint, 0400);
+module_param(output_cycle,   uint, 0400);
+module_param(input_cycle,    uint, 0400);
+module_param(bus_width,      uint, 0400);
+module_param(do_delays,      uint, 0400);
+module_param(log,            uint, 0400);
+module_param(dbg,            uint, 0400);
+
+MODULE_PARM_DESC(first_id_byte,  "The fist byte returned by NAND Flash 'read ID' command (manufaturer ID)");
+MODULE_PARM_DESC(second_id_byte, "The second byte returned by NAND Flash 'read ID' command (chip ID)");
+MODULE_PARM_DESC(third_id_byte,  "The third byte returned by NAND Flash 'read ID' command");
+MODULE_PARM_DESC(fourth_id_byte, "The fourth byte returned by NAND Flash 'read ID' command");
+MODULE_PARM_DESC(access_delay,   "Initial page access delay (microiseconds)");
+MODULE_PARM_DESC(programm_delay, "Page programm delay (microseconds");
+MODULE_PARM_DESC(erase_delay,    "Sector erase delay (milliseconds)");
+MODULE_PARM_DESC(output_cycle,   "Word output (from flash) time (nanodeconds)");
+MODULE_PARM_DESC(input_cycle,    "Word input (to flash) time (nanodeconds)");
+MODULE_PARM_DESC(bus_width,      "Chip's bus width (8- or 16-bit)");
+MODULE_PARM_DESC(do_delays,      "Simulate NAND delays using busy-waits if not zero");
+MODULE_PARM_DESC(log,            "Perform logging if not zero");
+MODULE_PARM_DESC(dbg,            "Output debug information if not zero");
+
+/* The largest possible page size */
+#define NS_LARGEST_PAGE_SIZE	2048
+	
+/* The prefix for simulator output */
+#define NS_OUTPUT_PREFIX "[nandsim]"
+
+/* Simulator's output macros (logging, debugging, warning, error) */
+#define NS_LOG(args...) \
+	do { if (log) printk(KERN_DEBUG NS_OUTPUT_PREFIX " log: " args); } while(0)
+#define NS_DBG(args...) \
+	do { if (dbg) printk(KERN_DEBUG NS_OUTPUT_PREFIX " debug: " args); } while(0)
+#define NS_WARN(args...) \
+	do { printk(KERN_WARNING NS_OUTPUT_PREFIX " warnig: " args); } while(0)
+#define NS_ERR(args...) \
+	do { printk(KERN_ERR NS_OUTPUT_PREFIX " errorr: " args); } while(0)
+
+/* Busy-wait delay macros (microseconds, milliseconds) */
+#define NS_UDELAY(us) \
+        do { if (do_delays) udelay(us); } while(0)
+#define NS_MDELAY(us) \
+        do { if (do_delays) mdelay(us); } while(0)
+	
+/* Is the nandsim structure initialized ? */
+#define NS_IS_INITIALIZED(ns) ((ns)->geom.totsz != 0)
+
+/* Good operation completion status */
+#define NS_STATUS_OK(ns) (NAND_STATUS_READY | (NAND_STATUS_WP * ((ns)->lines.wp == 0)))
+
+/* Operation failed completion status */
+#define NS_STATUS_FAILED(ns) (NAND_STATUS_FAIL | NS_STATUS_OK(ns)) 
+
+/* Calculate the page offset in flash RAM image by (row, column) address */
+#define NS_RAW_OFFSET(ns) \
+	(((ns)->regs.row << (ns)->geom.pgshift) + ((ns)->regs.row * (ns)->geom.oobsz) + (ns)->regs.column)
+	
+/* Calculate the OOB offset in flash RAM image by (row, column) address */
+#define NS_RAW_OFFSET_OOB(ns) (NS_RAW_OFFSET(ns) + ns->geom.pgsz)
+
+/* After a command is input, the simulator goes to one of the following states */
+#define STATE_CMD_READ0        0x00000001 /* read data from the beginning of page */
+#define STATE_CMD_READ1        0x00000002 /* read data from the second half of page */
+#define STATE_CMD_READSTART      0x00000003 /* read data second command (large page devices) */
+#define STATE_CMD_PAGEPROG     0x00000004 /* start page programm */
+#define STATE_CMD_READOOB      0x00000005 /* read OOB area */
+#define STATE_CMD_ERASE1       0x00000006 /* sector erase first command */
+#define STATE_CMD_STATUS       0x00000007 /* read status */
+#define STATE_CMD_STATUS_M     0x00000008 /* read multi-plane status (isn't implemented) */
+#define STATE_CMD_SEQIN        0x00000009 /* sequential data imput */
+#define STATE_CMD_READID       0x0000000A /* read ID */
+#define STATE_CMD_ERASE2       0x0000000B /* sector erase second command */
+#define STATE_CMD_RESET        0x0000000C /* reset */
+#define STATE_CMD_MASK         0x0000000F /* command states mask */
+
+/* After an addres is input, the simulator goes to one of these states */
+#define STATE_ADDR_PAGE        0x00000010 /* full (row, column) address is accepted */
+#define STATE_ADDR_SEC         0x00000020 /* sector address was accepted */
+#define STATE_ADDR_ZERO        0x00000030 /* one byte zero address was accepted */
+#define STATE_ADDR_MASK        0x00000030 /* address states mask */
+
+/* Durind data input/output the simulator is in these states */
+#define STATE_DATAIN           0x00000100 /* waiting for data input */
+#define STATE_DATAIN_MASK      0x00000100 /* data input states mask */
+
+#define STATE_DATAOUT          0x00001000 /* waiting for page data output */
+#define STATE_DATAOUT_ID       0x00002000 /* waiting for ID bytes output */
+#define STATE_DATAOUT_STATUS   0x00003000 /* waiting for status output */
+#define STATE_DATAOUT_STATUS_M 0x00004000 /* waiting for multi-plane status output */
+#define STATE_DATAOUT_MASK     0x00007000 /* data output states mask */
+
+/* Previous operation is done, ready to accept new requests */
+#define STATE_READY            0x00000000
+
+/* This state is used to mark that the next state isn't known yet */
+#define STATE_UNKNOWN          0x10000000
+
+/* Simulator's actions bit masks */
+#define ACTION_CPY       0x00100000 /* copy page/OOB to the internal buffer */
+#define ACTION_PRGPAGE   0x00200000 /* programm the internal buffer to flash */
+#define ACTION_SECERASE  0x00300000 /* erase sector */
+#define ACTION_ZEROOFF   0x00400000 /* don't add any offset to address */
+#define ACTION_HALFOFF   0x00500000 /* add to address half of page */
+#define ACTION_OOBOFF    0x00600000 /* add to address OOB offset */
+#define ACTION_MASK      0x00700000 /* action mask */
+
+#define NS_OPER_NUM      12 /* Number of operations supported by the simulator */
+#define NS_OPER_STATES   6  /* Maximum number of states in operation */
+
+#define OPT_ANY          0xFFFFFFFF /* any chip supports this operation */
+#define OPT_PAGE256      0x00000001 /* 256-byte  page chips */
+#define OPT_PAGE512      0x00000002 /* 512-byte  page chips */
+#define OPT_PAGE2048     0x00000008 /* 2048-byte page chips */
+#define OPT_SMARTMEDIA   0x00000010 /* SmartMedia technology chips */
+#define OPT_AUTOINCR     0x00000020 /* page number auto inctimentation is possible */
+#define OPT_PAGE512_8BIT 0x00000040 /* 512-byte page chips with 8-bit bus width */
+#define OPT_LARGEPAGE    (OPT_PAGE2048) /* 2048-byte page chips */
+#define OPT_SMALLPAGE    (OPT_PAGE256  | OPT_PAGE512)  /* 256 and 512-byte page chips */
+
+/* Remove action bits ftom state */
+#define NS_STATE(x) ((x) & ~ACTION_MASK)
+	
+/* 
+ * Maximum previous states which need to be saved. Currently saving is
+ * only needed for page programm operation with preceeded read command
+ * (which is only valid for 512-byte pages).
+ */
+#define NS_MAX_PREVSTATES 1
+
+/* 
+ * The structure which describes all the internal simulator data.
+ */
+struct nandsim {
+	struct mtd_partition part;
+
+	uint busw;              /* flash chip bus width (8 or 16) */
+	u_char ids[4];          /* chip's ID bytes */
+	uint32_t options;       /* chip's characteristic bits */
+	uint32_t state;         /* current chip state */
+	uint32_t nxstate;       /* next expected state */
+	
+	uint32_t *op;           /* current operation, NULL operations isn't known yet  */
+	uint32_t pstates[NS_MAX_PREVSTATES]; /* previous states */
+	uint16_t npstates;      /* number of previous states saved */
+	uint16_t stateidx;      /* current state index */
+
+	/* The simulated NAND flash image */
+	union flash_media {
+		u_char *byte;
+		uint16_t    *word;
+	} mem;
+
+	/* Internal buffer of page + OOB size bytes */
+	union internal_buffer {
+		u_char *byte;    /* for byte access */
+		uint16_t *word;  /* for 16-bit word access */
+	} buf;
+
+	/* NAND flash "geometry" */
+	struct nandsin_geometry {
+		uint32_t totsz;     /* total flash size, bytes */
+		uint32_t secsz;     /* flash sector (erase block) size, bytes */
+		uint pgsz;          /* NAND flash page size, bytes */
+		uint oobsz;         /* page OOB area size, bytes */
+		uint32_t totszoob;  /* total flash size including OOB, bytes */
+		uint pgszoob;       /* page size including OOB , bytes*/
+		uint secszoob;      /* sector size including OOB, bytes */
+		uint pgnum;         /* total number of pages */
+		uint pgsec;         /* number of pages per sector */
+		uint secshift;      /* bits number in sector size */
+		uint pgshift;       /* bits number in page size */
+		uint oobshift;      /* bits number in OOB size */
+		uint pgaddrbytes;   /* bytes per page address */
+		uint secaddrbytes;  /* bytes per sector address */
+		uint idbytes;       /* the number ID bytes that this chip outputs */
+	} geom;
+
+	/* NAND flash internal registers */
+	struct nandsim_regs {
+		unsigned command; /* the command register */
+		u_char   status;  /* the status register */
+		uint     row;     /* the page number */
+		uint     column;  /* the offset within page */
+		uint     count;   /* internal counter */
+		uint     num;     /* number of bytes which must be processed */
+		uint     off;     /* fixed page offset */
+	} regs;
+
+	/* NAND flash lines state */
+        struct ns_lines_status {
+                int ce;  /* chip Enable */
+                int cle; /* command Latch Enable */
+                int ale; /* address Latch Enable */
+                int wp;  /* write Protect */
+        } lines;
+};
+
+/*
+ * Operations array. To perform any operation the simulator must pass
+ * through the correspondent states chain.
+ */
+static struct nandsim_operations {
+	uint32_t reqopts;  /* options which are required to perform the operation */
+	uint32_t states[NS_OPER_STATES]; /* operation's states */
+} ops[NS_OPER_NUM] = {
+	/* Read page + OOB from the beginning */
+	{OPT_SMALLPAGE, {STATE_CMD_READ0 | ACTION_ZEROOFF, STATE_ADDR_PAGE | ACTION_CPY,
+			STATE_DATAOUT, STATE_READY}},
+	/* Read page + OOB from the second half */
+	{OPT_PAGE512_8BIT, {STATE_CMD_READ1 | ACTION_HALFOFF, STATE_ADDR_PAGE | ACTION_CPY,
+			STATE_DATAOUT, STATE_READY}},
+	/* Read OOB */
+	{OPT_SMALLPAGE, {STATE_CMD_READOOB | ACTION_OOBOFF, STATE_ADDR_PAGE | ACTION_CPY,
+			STATE_DATAOUT, STATE_READY}},
+	/* Programm page starting from the beginning */
+	{OPT_ANY, {STATE_CMD_SEQIN, STATE_ADDR_PAGE, STATE_DATAIN,
+			STATE_CMD_PAGEPROG | ACTION_PRGPAGE, STATE_READY}},
+	/* Programm page starting from the beginning */
+	{OPT_SMALLPAGE, {STATE_CMD_READ0, STATE_CMD_SEQIN | ACTION_ZEROOFF, STATE_ADDR_PAGE,
+			      STATE_DATAIN, STATE_CMD_PAGEPROG | ACTION_PRGPAGE, STATE_READY}},
+	/* Programm page starting from the second half */
+	{OPT_PAGE512, {STATE_CMD_READ1, STATE_CMD_SEQIN | ACTION_HALFOFF, STATE_ADDR_PAGE,
+			      STATE_DATAIN, STATE_CMD_PAGEPROG | ACTION_PRGPAGE, STATE_READY}},
+	/* Programm OOB */
+	{OPT_SMALLPAGE, {STATE_CMD_READOOB, STATE_CMD_SEQIN | ACTION_OOBOFF, STATE_ADDR_PAGE,
+			      STATE_DATAIN, STATE_CMD_PAGEPROG | ACTION_PRGPAGE, STATE_READY}},
+	/* Erase sector */
+	{OPT_ANY, {STATE_CMD_ERASE1, STATE_ADDR_SEC, STATE_CMD_ERASE2 | ACTION_SECERASE, STATE_READY}},
+	/* Read status */
+	{OPT_ANY, {STATE_CMD_STATUS, STATE_DATAOUT_STATUS, STATE_READY}},
+	/* Read multi-plane status */
+	{OPT_SMARTMEDIA, {STATE_CMD_STATUS_M, STATE_DATAOUT_STATUS_M, STATE_READY}},
+	/* Read ID */
+	{OPT_ANY, {STATE_CMD_READID, STATE_ADDR_ZERO, STATE_DATAOUT_ID, STATE_READY}},
+	/* Large page devices read page */
+	{OPT_LARGEPAGE, {STATE_CMD_READ0, STATE_ADDR_PAGE, STATE_CMD_READSTART | ACTION_CPY,
+			       STATE_DATAOUT, STATE_READY}}
+};
+
+/* MTD structure for NAND controller */
+static struct mtd_info *nsmtd;
+
+static u_char ns_verify_buf[NS_LARGEST_PAGE_SIZE];
+
+/*
+ * Initialize the nandsim structure.
+ *
+ * RETURNS: 0 if success, -ERRNO if failure.
+ */
+static int
+init_nandsim(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct nandsim   *ns   = (struct nandsim *)(chip->priv);
+	int i;
+
+	if (NS_IS_INITIALIZED(ns)) {
+		NS_ERR("init_nandsim: nandsim is already initialized\n");
+		return -EIO;
+	}
+
+	/* Force mtd to not do delays */
+	chip->chip_delay = 0;
+
+	/* Initialize the NAND flash parameters */
+	ns->busw = chip->options & NAND_BUSWIDTH_16 ? 16 : 8;
+	ns->geom.totsz    = mtd->size;
+	ns->geom.pgsz     = mtd->oobblock;
+	ns->geom.oobsz    = mtd->oobsize;
+	ns->geom.secsz    = mtd->erasesize;
+	ns->geom.pgszoob  = ns->geom.pgsz + ns->geom.oobsz;
+	ns->geom.pgnum    = ns->geom.totsz / ns->geom.pgsz;
+	ns->geom.totszoob = ns->geom.totsz + ns->geom.pgnum * ns->geom.oobsz;
+	ns->geom.secshift = ffs(ns->geom.secsz) - 1;
+	ns->geom.pgshift  = chip->page_shift;
+	ns->geom.oobshift = ffs(ns->geom.oobsz) - 1;
+	ns->geom.pgsec    = ns->geom.secsz / ns->geom.pgsz;
+	ns->geom.secszoob = ns->geom.secsz + ns->geom.oobsz * ns->geom.pgsec;
+	ns->options = 0;
+
+	if (ns->geom.pgsz == 256) {
+		ns->options |= OPT_PAGE256;
+	}
+	else if (ns->geom.pgsz == 512) {
+		ns->options |= (OPT_PAGE512 | OPT_AUTOINCR);
+		if (ns->busw == 8)
+			ns->options |= OPT_PAGE512_8BIT;
+	} else if (ns->geom.pgsz == 2048) {
+		ns->options |= OPT_PAGE2048;
+	} else {
+		NS_ERR("init_nandsim: unknown page size %u\n", ns->geom.pgsz);
+		return -EIO;
+	}
+
+	if (ns->options & OPT_SMALLPAGE) {
+		if (ns->geom.totsz < (64 << 20)) {
+			ns->geom.pgaddrbytes  = 3;
+			ns->geom.secaddrbytes = 2;
+		} else {
+			ns->geom.pgaddrbytes  = 4;
+			ns->geom.secaddrbytes = 3;
+		}
+	} else {
+		if (ns->geom.totsz <= (128 << 20)) {
+			ns->geom.pgaddrbytes  = 5;
+			ns->geom.secaddrbytes = 2;
+		} else {
+			ns->geom.pgaddrbytes  = 5;
+			ns->geom.secaddrbytes = 3;
+		}
+	}
+	
+	/* Detect how many ID bytes the NAND chip outputs */
+        for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+                if (second_id_byte != nand_flash_ids[i].id)
+                        continue;
+		if (!(nand_flash_ids[i].options & NAND_NO_AUTOINCR))
+			ns->options |= OPT_AUTOINCR;
+	}
+
+	if (ns->busw == 16)
+		NS_WARN("16-bit flashes support wasn't tested\n");
+
+	printk("flash size: %u MiB\n",          ns->geom.totsz >> 20);
+	printk("page size: %u bytes\n",         ns->geom.pgsz);
+	printk("OOB area size: %u bytes\n",     ns->geom.oobsz);
+	printk("sector size: %u KiB\n",         ns->geom.secsz >> 10);
+	printk("pages number: %u\n",            ns->geom.pgnum);
+	printk("pages per sector: %u\n",        ns->geom.pgsec);
+	printk("bus width: %u\n",               ns->busw);
+	printk("bits in sector size: %u\n",     ns->geom.secshift);
+	printk("bits in page size: %u\n",       ns->geom.pgshift);
+	printk("bits in OOB size: %u\n",        ns->geom.oobshift);
+	printk("flash size with OOB: %u KiB\n", ns->geom.totszoob >> 10);
+	printk("page address bytes: %u\n",      ns->geom.pgaddrbytes);
+	printk("sector address bytes: %u\n",    ns->geom.secaddrbytes);
+	printk("options: %#x\n",                ns->options);
+
+	/* Map / allocate and initialize the flash image */
+#ifdef CONFIG_NS_ABS_POS
+	ns->mem.byte = ioremap(CONFIG_NS_ABS_POS, ns->geom.totszoob);
+	if (!ns->mem.byte) {
+		NS_ERR("init_nandsim: failed to map the NAND flash image at address %p\n", 
+			(void *)CONFIG_NS_ABS_POS);
+		return -ENOMEM;
+	}
+#else
+	ns->mem.byte = vmalloc(ns->geom.totszoob);
+	if (!ns->mem.byte) {
+		NS_ERR("init_nandsim: unable to allocate %u bytes for flash image\n",
+			ns->geom.totszoob);
+		return -ENOMEM;
+	}
+	memset(ns->mem.byte, 0xFF, ns->geom.totszoob);
+#endif
+
+	/* Allocate / initialize the internal buffer */
+	ns->buf.byte = kmalloc(ns->geom.pgszoob, GFP_KERNEL);
+	if (!ns->buf.byte) {
+		NS_ERR("init_nandsim: unable to allocate %u bytes for the internal buffer\n",
+			ns->geom.pgszoob);
+		goto error;
+	}
+	memset(ns->buf.byte, 0xFF, ns->geom.pgszoob);
+
+	/* Fill the partition_info structure */
+	ns->part.name   = "NAND simulator partition";
+	ns->part.offset = 0;
+	ns->part.size   = ns->geom.totsz;
+
+	return 0;
+
+error:
+#ifdef CONFIG_NS_ABS_POS
+	iounmap(ns->mem.byte);
+#else
+	vfree(ns->mem.byte);
+#endif
+
+	return -ENOMEM;
+}
+
+/*
+ * Free the nandsim structure.
+ */
+static void
+free_nandsim(struct nandsim *ns)
+{
+	kfree(ns->buf.byte);
+
+#ifdef CONFIG_NS_ABS_POS
+	iounmap(ns->mem.byte);
+#else
+	vfree(ns->mem.byte);
+#endif
+
+	return;
+}
+
+/*
+ * Returns the string representation of 'state' state.
+ */
+static char *
+get_state_name(uint32_t state)
+{
+	switch (NS_STATE(state)) {
+		case STATE_CMD_READ0:
+			return "STATE_CMD_READ0";
+		case STATE_CMD_READ1:
+			return "STATE_CMD_READ1";
+		case STATE_CMD_PAGEPROG:
+			return "STATE_CMD_PAGEPROG";
+		case STATE_CMD_READOOB:
+			return "STATE_CMD_READOOB";
+		case STATE_CMD_READSTART:
+			return "STATE_CMD_READSTART";
+		case STATE_CMD_ERASE1:
+			return "STATE_CMD_ERASE1";
+		case STATE_CMD_STATUS:
+			return "STATE_CMD_STATUS";
+		case STATE_CMD_STATUS_M:
+			return "STATE_CMD_STATUS_M";
+		case STATE_CMD_SEQIN:
+			return "STATE_CMD_SEQIN";
+		case STATE_CMD_READID:
+			return "STATE_CMD_READID";
+		case STATE_CMD_ERASE2:
+			return "STATE_CMD_ERASE2";
+		case STATE_CMD_RESET:
+			return "STATE_CMD_RESET";
+		case STATE_ADDR_PAGE:
+			return "STATE_ADDR_PAGE";
+		case STATE_ADDR_SEC:
+			return "STATE_ADDR_SEC";
+		case STATE_ADDR_ZERO:
+			return "STATE_ADDR_ZERO";
+		case STATE_DATAIN:
+			return "STATE_DATAIN";
+		case STATE_DATAOUT:
+			return "STATE_DATAOUT";
+		case STATE_DATAOUT_ID:
+			return "STATE_DATAOUT_ID";
+		case STATE_DATAOUT_STATUS:
+			return "STATE_DATAOUT_STATUS";
+		case STATE_DATAOUT_STATUS_M:
+			return "STATE_DATAOUT_STATUS_M";
+		case STATE_READY:
+			return "STATE_READY";
+		case STATE_UNKNOWN:
+			return "STATE_UNKNOWN";
+	}
+
+	NS_ERR("get_state_name: unknown state, BUG\n");
+	return NULL;
+}
+
+/*
+ * Check if command is valid.
+ *
+ * RETURNS: 1 if wrong command, 0 if right.
+ */
+static int
+check_command(int cmd)
+{
+	switch (cmd) {
+		
+	case NAND_CMD_READ0:
+	case NAND_CMD_READSTART:
+	case NAND_CMD_PAGEPROG:
+	case NAND_CMD_READOOB:
+	case NAND_CMD_ERASE1:
+	case NAND_CMD_STATUS:
+	case NAND_CMD_SEQIN:
+	case NAND_CMD_READID:
+	case NAND_CMD_ERASE2:
+	case NAND_CMD_RESET:
+	case NAND_CMD_READ1:
+		return 0;
+		
+	case NAND_CMD_STATUS_MULTI:
+	default:
+		return 1;
+	}
+}
+
+/*
+ * Returns state after command is accepted by command number.
+ */
+static uint32_t
+get_state_by_command(unsigned command)
+{
+	switch (command) {
+		case NAND_CMD_READ0:
+			return STATE_CMD_READ0;
+		case NAND_CMD_READ1:
+			return STATE_CMD_READ1;
+		case NAND_CMD_PAGEPROG:
+			return STATE_CMD_PAGEPROG;
+		case NAND_CMD_READSTART:
+			return STATE_CMD_READSTART;
+		case NAND_CMD_READOOB:
+			return STATE_CMD_READOOB;
+		case NAND_CMD_ERASE1:
+			return STATE_CMD_ERASE1;
+		case NAND_CMD_STATUS:
+			return STATE_CMD_STATUS;
+		case NAND_CMD_STATUS_MULTI:
+			return STATE_CMD_STATUS_M;
+		case NAND_CMD_SEQIN:
+			return STATE_CMD_SEQIN;
+		case NAND_CMD_READID:
+			return STATE_CMD_READID;
+		case NAND_CMD_ERASE2:
+			return STATE_CMD_ERASE2;
+		case NAND_CMD_RESET:
+			return STATE_CMD_RESET;
+	}
+
+	NS_ERR("get_state_by_command: unknown command, BUG\n");
+	return 0;
+}
+
+/*
+ * Move an address byte to the correspondent internal register.
+ */
+static inline void
+accept_addr_byte(struct nandsim *ns, u_char bt)
+{
+	uint byte = (uint)bt;
+	
+	if (ns->regs.count < (ns->geom.pgaddrbytes - ns->geom.secaddrbytes))
+		ns->regs.column |= (byte << 8 * ns->regs.count);
+	else {
+		ns->regs.row |= (byte << 8 * (ns->regs.count -
+						ns->geom.pgaddrbytes +
+						ns->geom.secaddrbytes));
+	}
+
+	return;
+}
+		
+/*
+ * Switch to STATE_READY state.
+ */
+static inline void 
+switch_to_ready_state(struct nandsim *ns, u_char status)
+{
+	NS_DBG("switch_to_ready_state: switch to %s state\n", get_state_name(STATE_READY));
+
+	ns->state       = STATE_READY;
+	ns->nxstate     = STATE_UNKNOWN;
+	ns->op          = NULL;
+	ns->npstates    = 0;
+	ns->stateidx    = 0;
+	ns->regs.num    = 0;
+	ns->regs.count  = 0;
+	ns->regs.off    = 0;
+	ns->regs.row    = 0;
+	ns->regs.column = 0;
+	ns->regs.status = status;
+}
+
+/*
+ * If the operation isn't known yet, try to find it in the global array
+ * of supported operations.
+ *
+ * Operation can be unknown because of the following.
+ *   1. New command was accepted and this is the firs call to find the
+ *      correspondent states chain. In this case ns->npstates = 0;
+ *   2. There is several operations which begin with the same command(s)
+ *      (for example program from the second half and read from the
+ *      second half operations both begin with the READ1 command). In this
+ *      case the ns->pstates[] array contains previous states.
+ * 
+ * Thus, the function tries to find operation containing the following
+ * states (if the 'flag' parameter is 0):
+ *    ns->pstates[0], ... ns->pstates[ns->npstates], ns->state
+ *
+ * If (one and only one) matching operation is found, it is accepted (
+ * ns->ops, ns->state, ns->nxstate are initialized, ns->npstate is
+ * zeroed).
+ * 
+ * If there are several maches, the current state is pushed to the
+ * ns->pstates.
+ *
+ * The operation can be unknown only while commands are input to the chip.
+ * As soon as address command is accepted, the operation must be known.
+ * In such situation the function is called with 'flag' != 0, and the
+ * operation is searched using the following pattern:
+ *     ns->pstates[0], ... ns->pstates[ns->npstates], <address input>
+ * 
+ * It is supposed that this pattern must either match one operation on
+ * none. There can't be ambiguity in that case.
+ *
+ * If no matches found, the functions does the following:
+ *   1. if there are saved states present, try to ignore them and search
+ *      again only using the last command. If nothing was found, switch
+ *      to the STATE_READY state.
+ *   2. if there are no saved states, switch to the STATE_READY state.
+ *
+ * RETURNS: -2 - no matched operations found.
+ *          -1 - several matches.
+ *           0 - operation is found.
+ */
+static int
+find_operation(struct nandsim *ns, uint32_t flag)
+{
+	int opsfound = 0;
+	int i, j, idx = 0;
+	
+	for (i = 0; i < NS_OPER_NUM; i++) {
+
+		int found = 1;
+	
+		if (!(ns->options & ops[i].reqopts))
+			/* Ignore operations we can't perform */
+			continue;
+			
+		if (flag) {
+			if (!(ops[i].states[ns->npstates] & STATE_ADDR_MASK))
+				continue;
+		} else {
+			if (NS_STATE(ns->state) != NS_STATE(ops[i].states[ns->npstates]))
+				continue;
+		}
+
+		for (j = 0; j < ns->npstates; j++) 
+			if (NS_STATE(ops[i].states[j]) != NS_STATE(ns->pstates[j])
+				&& (ns->options & ops[idx].reqopts)) {
+				found = 0;
+				break;
+			}
+
+		if (found) {
+			idx = i;
+			opsfound += 1;
+		}
+	}
+
+	if (opsfound == 1) {
+		/* Exact match */
+		ns->op = &ops[idx].states[0];
+		if (flag) {
+			/* 
+			 * In this case the find_operation function was
+			 * called when address has just began input. But it isn't
+			 * yet fully input and the current state must
+			 * not be one of STATE_ADDR_*, but the STATE_ADDR_*
+			 * state must be the next state (ns->nxstate).
+			 */
+			ns->stateidx = ns->npstates - 1;
+		} else {
+			ns->stateidx = ns->npstates;
+		}
+		ns->npstates = 0;
+		ns->state = ns->op[ns->stateidx];
+		ns->nxstate = ns->op[ns->stateidx + 1];
+		NS_DBG("find_operation: operation found, index: %d, state: %s, nxstate %s\n",
+				idx, get_state_name(ns->state), get_state_name(ns->nxstate));
+		return 0;
+	}
+	
+	if (opsfound == 0) {
+		/* Nothing was found. Try to ignore previous commands (if any) and search again */
+		if (ns->npstates != 0) {
+			NS_DBG("find_operation: no operation found, try again with state %s\n",
+					get_state_name(ns->state));
+			ns->npstates = 0;
+			return find_operation(ns, 0);
+
+		}
+		NS_DBG("find_operation: no operations found\n");
+		switch_to_ready_state(ns, NS_STATUS_FAILED(ns));
+		return -2;
+	}
+	
+	if (flag) {
+		/* This shouldn't happen */
+		NS_DBG("find_operation: BUG, operation must be known if address is input\n");
+		return -2;
+	}
+	
+	NS_DBG("find_operation: there is still ambiguity\n");
+
+	ns->pstates[ns->npstates++] = ns->state;
+
+	return -1;
+}
+
+/*
+ * If state has any action bit, perform this action.
+ *
+ * RETURNS: 0 if success, -1 if error.
+ */
+static int
+do_state_action(struct nandsim *ns, uint32_t action)
+{
+	int i, num;
+	int busdiv = ns->busw == 8 ? 1 : 2;
+
+	action &= ACTION_MASK;
+	
+	/* Check that page address input is correct */
+	if (action != ACTION_SECERASE && ns->regs.row >= ns->geom.pgnum) {
+		NS_WARN("do_state_action: wrong page number (%#x)\n", ns->regs.row);
+		return -1;
+	}
+
+	switch (action) {
+
+	case ACTION_CPY:
+		/*
+		 * Copy page data to the internal buffer.
+		 */
+
+		/* Column shouldn't be very large */
+		if (ns->regs.column >= (ns->geom.pgszoob - ns->regs.off)) {
+			NS_ERR("do_state_action: column number is too large\n");
+			break;
+		}
+		num = ns->geom.pgszoob - ns->regs.off - ns->regs.column;
+		memcpy(ns->buf.byte, ns->mem.byte + NS_RAW_OFFSET(ns) + ns->regs.off, num);
+
+		NS_DBG("do_state_action: (ACTION_CPY:) copy %d bytes to int buf, raw offset %d\n",
+			num, NS_RAW_OFFSET(ns) + ns->regs.off);
+		
+		if (ns->regs.off == 0)
+			NS_LOG("read page %d\n", ns->regs.row);
+		else if (ns->regs.off < ns->geom.pgsz)
+			NS_LOG("read page %d (second half)\n", ns->regs.row);
+		else
+			NS_LOG("read OOB of page %d\n", ns->regs.row);
+		
+		NS_UDELAY(access_delay);
+		NS_UDELAY(input_cycle * ns->geom.pgsz / 1000 / busdiv);
+
+		break;
+
+	case ACTION_SECERASE:
+		/*
+		 * Erase sector.
+		 */
+		
+		if (ns->lines.wp) {
+			NS_ERR("do_state_action: device is write-protected, ignore sector erase\n");
+			return -1;
+		}
+		
+		if (ns->regs.row >= ns->geom.pgnum - ns->geom.pgsec
+			|| (ns->regs.row & ~(ns->geom.secsz - 1))) {
+			NS_ERR("do_state_action: wrong sector address (%#x)\n", ns->regs.row);
+			return -1;
+		}
+		
+		ns->regs.row = (ns->regs.row <<
+				8 * (ns->geom.pgaddrbytes - ns->geom.secaddrbytes)) | ns->regs.column;
+		ns->regs.column = 0;
+		
+		NS_DBG("do_state_action: erase sector at address %#x, off = %d\n",
+				ns->regs.row, NS_RAW_OFFSET(ns));
+		NS_LOG("erase sector %d\n", ns->regs.row >> (ns->geom.secshift - ns->geom.pgshift));
+
+		memset(ns->mem.byte + NS_RAW_OFFSET(ns), 0xFF, ns->geom.secszoob);
+		
+		NS_MDELAY(erase_delay);
+		
+		break;
+
+	case ACTION_PRGPAGE:
+		/*
+		 * Programm page - move internal buffer data to the page.
+		 */
+
+		if (ns->lines.wp) {
+			NS_WARN("do_state_action: device is write-protected, programm\n");
+			return -1;
+		}
+
+		num = ns->geom.pgszoob - ns->regs.off - ns->regs.column;
+		if (num != ns->regs.count) {
+			NS_ERR("do_state_action: too few bytes were input (%d instead of %d)\n",
+					ns->regs.count, num);
+			return -1;
+		}
+
+		for (i = 0; i < num; i++)
+			ns->mem.byte[NS_RAW_OFFSET(ns) + ns->regs.off + i] &= ns->buf.byte[i];
+
+		NS_DBG("do_state_action: copy %d bytes from int buf to (%#x, %#x), raw off = %d\n",
+			num, ns->regs.row, ns->regs.column, NS_RAW_OFFSET(ns) + ns->regs.off);
+		NS_LOG("programm page %d\n", ns->regs.row);
+		
+		NS_UDELAY(programm_delay);
+		NS_UDELAY(output_cycle * ns->geom.pgsz / 1000 / busdiv);
+		
+		break;
+	
+	case ACTION_ZEROOFF:
+		NS_DBG("do_state_action: set internal offset to 0\n");
+		ns->regs.off = 0;
+		break;
+
+	case ACTION_HALFOFF:
+		if (!(ns->options & OPT_PAGE512_8BIT)) {
+			NS_ERR("do_state_action: BUG! can't skip half of page for non-512"
+				"byte page size 8x chips\n");
+			return -1;
+		}
+		NS_DBG("do_state_action: set internal offset to %d\n", ns->geom.pgsz/2);
+		ns->regs.off = ns->geom.pgsz/2;
+		break;
+
+	case ACTION_OOBOFF:
+		NS_DBG("do_state_action: set internal offset to %d\n", ns->geom.pgsz);
+		ns->regs.off = ns->geom.pgsz;
+		break;
+		
+	default:
+		NS_DBG("do_state_action: BUG! unknown action\n");
+	}
+
+	return 0;
+}
+
+/*
+ * Switch simulator's state.
+ */
+static void
+switch_state(struct nandsim *ns)
+{
+	if (ns->op) {
+		/*
+		 * The current operation have already been identified.
+		 * Just follow the states chain.
+		 */
+		
+		ns->stateidx += 1;
+		ns->state = ns->nxstate;
+		ns->nxstate = ns->op[ns->stateidx + 1];
+
+		NS_DBG("switch_state: operation is known, switch to the next state, "
+			"state: %s, nxstate: %s\n",
+			get_state_name(ns->state), get_state_name(ns->nxstate));
+
+		/* See, whether we need to do some action */
+		if ((ns->state & ACTION_MASK) && do_state_action(ns, ns->state) < 0) {
+			switch_to_ready_state(ns, NS_STATUS_FAILED(ns));
+			return;
+		}
+		
+	} else {
+		/*
+		 * We don't yet know which operation we perform.
+		 * Try to identify it.
+		 */
+
+		/*  
+		 *  The only event causing the switch_state function to
+		 *  be called with yet unknown operation is new command.
+		 */
+		ns->state = get_state_by_command(ns->regs.command);
+
+		NS_DBG("switch_state: operation is unknown, try to find it\n");
+
+		if (find_operation(ns, 0) != 0)
+			return;
+
+		if ((ns->state & ACTION_MASK) && do_state_action(ns, ns->state) < 0) {
+			switch_to_ready_state(ns, NS_STATUS_FAILED(ns));
+			return;
+		}
+	}
+
+	/* For 16x devices column means the page offset in words */
+	if ((ns->nxstate & STATE_ADDR_MASK) && ns->busw == 16) {
+		NS_DBG("switch_state: double the column number for 16x device\n");
+		ns->regs.column <<= 1;
+	}
+
+	if (NS_STATE(ns->nxstate) == STATE_READY) {
+		/*
+		 * The current state is the last. Return to STATE_READY
+		 */
+
+		u_char status = NS_STATUS_OK(ns);
+		
+		/* In case of data states, see if all bytes were input/output */
+		if ((ns->state & (STATE_DATAIN_MASK | STATE_DATAOUT_MASK))
+			&& ns->regs.count != ns->regs.num) {
+			NS_WARN("switch_state: not all bytes were processed, %d left\n",
+					ns->regs.num - ns->regs.count);
+			status = NS_STATUS_FAILED(ns);
+		}
+				
+		NS_DBG("switch_state: operation complete, switch to STATE_READY state\n");
+
+		switch_to_ready_state(ns, status);
+
+		return;
+	} else if (ns->nxstate & (STATE_DATAIN_MASK | STATE_DATAOUT_MASK)) {
+		/* 
+		 * If the next state is data input/output, switch to it now
+		 */
+		
+		ns->state      = ns->nxstate;
+		ns->nxstate    = ns->op[++ns->stateidx + 1];
+		ns->regs.num   = ns->regs.count = 0;
+
+		NS_DBG("switch_state: the next state is data I/O, switch, "
+			"state: %s, nxstate: %s\n",
+			get_state_name(ns->state), get_state_name(ns->nxstate));
+
+		/*
+		 * Set the internal register to the count of bytes which
+		 * are expected to be input or output
+		 */
+		switch (NS_STATE(ns->state)) {
+			case STATE_DATAIN:
+			case STATE_DATAOUT:
+				ns->regs.num = ns->geom.pgszoob - ns->regs.off - ns->regs.column;
+				break;
+				
+			case STATE_DATAOUT_ID:
+				ns->regs.num = ns->geom.idbytes;
+				break;
+				
+			case STATE_DATAOUT_STATUS:
+			case STATE_DATAOUT_STATUS_M:
+				ns->regs.count = ns->regs.num = 0;
+				break;
+				
+			default:
+				NS_ERR("switch_state: BUG! unknown data state\n");
+		}
+
+	} else if (ns->nxstate & STATE_ADDR_MASK) {
+		/*
+		 * If the next state is address input, set the internal
+		 * register to the number of expected address bytes
+		 */
+
+		ns->regs.count = 0;
+		
+		switch (NS_STATE(ns->nxstate)) {
+			case STATE_ADDR_PAGE:
+				ns->regs.num = ns->geom.pgaddrbytes;
+		
+				break;
+			case STATE_ADDR_SEC:
+				ns->regs.num = ns->geom.secaddrbytes;
+				break;
+	
+			case STATE_ADDR_ZERO:
+				ns->regs.num = 1;
+				break;
+
+			default:
+				NS_ERR("switch_state: BUG! unknown address state\n");
+		}
+	} else {
+		/* 
+		 * Just reset internal counters.
+		 */
+
+		ns->regs.num = 0;
+		ns->regs.count = 0;
+	}
+}
+
+static void
+ns_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct nandsim *ns = (struct nandsim *)((struct nand_chip *)mtd->priv)->priv;
+
+	switch (cmd) {
+
+	/* set CLE line high */
+	case NAND_CTL_SETCLE:
+		NS_DBG("ns_hwcontrol: start command latch cycles\n");
+		ns->lines.cle  = 1;
+		break;
+
+	/* set CLE line low */
+	case NAND_CTL_CLRCLE:
+		NS_DBG("ns_hwcontrol: stop command latch cycles\n");
+		ns->lines.cle  = 0;
+		break;
+
+	/* set ALE line high */
+	case NAND_CTL_SETALE:
+		NS_DBG("ns_hwcontrol: start address latch cycles\n");
+		ns->lines.ale   = 1;
+		break;
+
+	/* set ALE line low */
+	case NAND_CTL_CLRALE:
+		NS_DBG("ns_hwcontrol: stop address latch cycles\n");
+		ns->lines.ale  = 0;
+		break;
+
+	/* set WP line high */
+	case NAND_CTL_SETWP:
+		NS_DBG("ns_hwcontrol: enable write protection\n");
+		ns->lines.wp = 1;
+		break;
+
+	/* set WP line low */
+	case NAND_CTL_CLRWP:
+		NS_DBG("ns_hwcontrol: disable write protection\n");
+		ns->lines.wp = 0;
+		break;
+
+	/* set CE line low */
+	case NAND_CTL_SETNCE:
+		NS_DBG("ns_hwcontrol: enable chip\n");
+		ns->lines.ce = 1;
+		break;
+
+	/* set CE line high */
+	case NAND_CTL_CLRNCE:
+		NS_DBG("ns_hwcontrol: disable chip\n");
+		ns->lines.ce = 0;
+		break;
+
+	default:
+		NS_ERR("hwcontrol: unknown command\n");
+        }
+
+	return;
+}
+
+static u_char
+ns_nand_read_byte(struct mtd_info *mtd)
+{
+        struct nandsim *ns = (struct nandsim *)((struct nand_chip *)mtd->priv)->priv;
+	u_char outb = 0x00;
+
+	/* Sanity and correctness checks */
+	if (!ns->lines.ce) {
+		NS_ERR("read_byte: chip is disabled, return %#x\n", (uint)outb);
+		return outb;
+	}
+	if (ns->lines.ale || ns->lines.cle) {
+		NS_ERR("read_byte: ALE or CLE pin is high, return %#x\n", (uint)outb);
+		return outb;
+	}
+	if (!(ns->state & STATE_DATAOUT_MASK)) {
+		NS_WARN("read_byte: unexpected data output cycle, state is %s "
+			"return %#x\n", get_state_name(ns->state), (uint)outb);
+		return outb;
+	}
+
+	/* Status register may be read as many times as it is wanted */
+	if (NS_STATE(ns->state) == STATE_DATAOUT_STATUS) {
+		NS_DBG("read_byte: return %#x status\n", ns->regs.status);
+		return ns->regs.status;
+	}
+
+	/* Check if there is any data in the internal buffer which may be read */
+	if (ns->regs.count == ns->regs.num) {
+		NS_WARN("read_byte: no more data to output, return %#x\n", (uint)outb);
+		return outb;
+	}
+
+	switch (NS_STATE(ns->state)) {
+		case STATE_DATAOUT:
+			if (ns->busw == 8) {
+				outb = ns->buf.byte[ns->regs.count];
+				ns->regs.count += 1;
+			} else {
+				outb = (u_char)cpu_to_le16(ns->buf.word[ns->regs.count >> 1]);
+				ns->regs.count += 2;
+			}
+			break;
+		case STATE_DATAOUT_ID:
+			NS_DBG("read_byte: read ID byte %d, total = %d\n", ns->regs.count, ns->regs.num);
+			outb = ns->ids[ns->regs.count];
+			ns->regs.count += 1;
+			break;
+		default:
+			BUG();
+	}
+	
+	if (ns->regs.count == ns->regs.num) {
+		NS_DBG("read_byte: all bytes were read\n");
+
+		/*
+		 * The OPT_AUTOINCR allows to read next conseqitive pages without
+		 * new read operation cycle.
+		 */
+		if ((ns->options & OPT_AUTOINCR) && NS_STATE(ns->state) == STATE_DATAOUT) {
+			ns->regs.count = 0;
+			if (ns->regs.row + 1 < ns->geom.pgnum)
+				ns->regs.row += 1;
+			NS_DBG("read_byte: switch to the next page (%#x)\n", ns->regs.row);
+			do_state_action(ns, ACTION_CPY);
+		}
+		else if (NS_STATE(ns->nxstate) == STATE_READY)
+			switch_state(ns);
+		
+	}
+	
+	return outb;
+}
+
+static void
+ns_nand_write_byte(struct mtd_info *mtd, u_char byte)
+{
+        struct nandsim *ns = (struct nandsim *)((struct nand_chip *)mtd->priv)->priv;
+	
+	/* Sanity and correctness checks */
+	if (!ns->lines.ce) {
+		NS_ERR("write_byte: chip is disabled, ignore write\n");
+		return;
+	}
+	if (ns->lines.ale && ns->lines.cle) {
+		NS_ERR("write_byte: ALE and CLE pins are high simultaneously, ignore write\n");
+		return;
+	}
+			
+	if (ns->lines.cle == 1) {
+		/*
+		 * The byte written is a command.
+		 */
+
+		if (byte == NAND_CMD_RESET) {
+			NS_LOG("reset chip\n");
+			switch_to_ready_state(ns, NS_STATUS_OK(ns));
+			return;
+		}
+
+		/* 
+		 * Chip might still be in STATE_DATAOUT
+		 * (if OPT_AUTOINCR feature is supported), STATE_DATAOUT_STATUS or
+		 * STATE_DATAOUT_STATUS_M state. If so, switch state.
+		 */
+		if (NS_STATE(ns->state) == STATE_DATAOUT_STATUS
+			|| NS_STATE(ns->state) == STATE_DATAOUT_STATUS_M
+			|| ((ns->options & OPT_AUTOINCR) && NS_STATE(ns->state) == STATE_DATAOUT))
+			switch_state(ns);
+
+		/* Check if chip is expecting command */
+		if (NS_STATE(ns->nxstate) != STATE_UNKNOWN && !(ns->nxstate & STATE_CMD_MASK)) {
+			/*
+			 * We are in situation when something else (not command)
+			 * was expected but command was input. In this case ignore
+			 * previous command(s)/state(s) and accept the last one.
+			 */
+			NS_WARN("write_byte: command (%#x) wasn't expected, expected state is %s, "
+				"ignore previous states\n", (uint)byte, get_state_name(ns->nxstate));
+			switch_to_ready_state(ns, NS_STATUS_FAILED(ns));
+		}
+		
+		/* Check that the command byte is correct */
+		if (check_command(byte)) {
+			NS_ERR("write_byte: unknown command %#x\n", (uint)byte);
+			return;
+		}
+		
+		NS_DBG("command byte corresponding to %s state accepted\n",
+			get_state_name(get_state_by_command(byte)));
+		ns->regs.command = byte;
+		switch_state(ns);
+
+	} else if (ns->lines.ale == 1) {
+		/*
+		 * The byte written is an address.
+		 */
+
+		if (NS_STATE(ns->nxstate) == STATE_UNKNOWN) {
+
+			NS_DBG("write_byte: operation isn't known yet, identify it\n");
+
+			if (find_operation(ns, 1) < 0)
+				return;
+			
+			if ((ns->state & ACTION_MASK) && do_state_action(ns, ns->state) < 0) {
+				switch_to_ready_state(ns, NS_STATUS_FAILED(ns));
+				return;
+			}
+				
+			ns->regs.count = 0;
+			switch (NS_STATE(ns->nxstate)) {
+				case STATE_ADDR_PAGE:
+					ns->regs.num = ns->geom.pgaddrbytes;
+					break;
+				case STATE_ADDR_SEC:
+					ns->regs.num = ns->geom.secaddrbytes;
+					break;
+				case STATE_ADDR_ZERO:
+					ns->regs.num = 1;
+					break;
+				default:
+					BUG();
+			}
+		}
+
+		/* Check that chip is expecting address */
+		if (!(ns->nxstate & STATE_ADDR_MASK)) {
+			NS_ERR("write_byte: address (%#x) isn't expected, expected state is %s, "
+				"switch to STATE_READY\n", (uint)byte, get_state_name(ns->nxstate));
+			switch_to_ready_state(ns, NS_STATUS_FAILED(ns));
+			return;
+		}
+		
+		/* Check if this is expected byte */
+		if (ns->regs.count == ns->regs.num) {
+			NS_ERR("write_byte: no more address bytes expected\n");
+			switch_to_ready_state(ns, NS_STATUS_FAILED(ns));
+			return;
+		}
+
+		accept_addr_byte(ns, byte);
+
+		ns->regs.count += 1;
+
+		NS_DBG("write_byte: address byte %#x was accepted (%d bytes input, %d expected)\n",
+				(uint)byte, ns->regs.count, ns->regs.num);
+
+		if (ns->regs.count == ns->regs.num) {
+			NS_DBG("address (%#x, %#x) is accepted\n", ns->regs.row, ns->regs.column);
+			switch_state(ns);
+		}
+		
+	} else {
+		/*
+		 * The byte written is an input data.
+		 */
+		
+		/* Check that chip is expecting data input */
+		if (!(ns->state & STATE_DATAIN_MASK)) {
+			NS_ERR("write_byte: data input (%#x) isn't expected, state is %s, "
+				"switch to %s\n", (uint)byte,
+				get_state_name(ns->state), get_state_name(STATE_READY));
+			switch_to_ready_state(ns, NS_STATUS_FAILED(ns));
+			return;
+		}
+
+		/* Check if this is expected byte */
+		if (ns->regs.count == ns->regs.num) {
+			NS_WARN("write_byte: %u input bytes has already been accepted, ignore write\n",
+					ns->regs.num);
+			return;
+		}
+
+		if (ns->busw == 8) {
+			ns->buf.byte[ns->regs.count] = byte;
+			ns->regs.count += 1;
+		} else {
+			ns->buf.word[ns->regs.count >> 1] = cpu_to_le16((uint16_t)byte);
+			ns->regs.count += 2;
+		}
+	}
+
+	return;
+}
+
+static int
+ns_device_ready(struct mtd_info *mtd)
+{
+	NS_DBG("device_ready\n");
+	return 1;
+}
+
+static uint16_t
+ns_nand_read_word(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+
+	NS_DBG("read_word\n");
+	
+	return chip->read_byte(mtd) | (chip->read_byte(mtd) << 8);
+}
+
+static void
+ns_nand_write_word(struct mtd_info *mtd, uint16_t word)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	
+	NS_DBG("write_word\n");
+	
+	chip->write_byte(mtd, word & 0xFF);
+	chip->write_byte(mtd, word >> 8);
+}
+
+static void 
+ns_nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+        struct nandsim *ns = (struct nandsim *)((struct nand_chip *)mtd->priv)->priv;
+
+	/* Check that chip is expecting data input */
+	if (!(ns->state & STATE_DATAIN_MASK)) {
+		NS_ERR("write_buf: data input isn't expected, state is %s, "
+			"switch to STATE_READY\n", get_state_name(ns->state));
+		switch_to_ready_state(ns, NS_STATUS_FAILED(ns));
+		return;
+	}
+
+	/* Check if these are expected bytes */
+	if (ns->regs.count + len > ns->regs.num) {
+		NS_ERR("write_buf: too many input bytes\n");
+		switch_to_ready_state(ns, NS_STATUS_FAILED(ns));
+		return;
+	}
+
+	memcpy(ns->buf.byte + ns->regs.count, buf, len);
+	ns->regs.count += len;
+	
+	if (ns->regs.count == ns->regs.num) {
+		NS_DBG("write_buf: %d bytes were written\n", ns->regs.count);
+	}
+}
+
+static void 
+ns_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+        struct nandsim *ns = (struct nandsim *)((struct nand_chip *)mtd->priv)->priv;
+
+	/* Sanity and correctness checks */
+	if (!ns->lines.ce) {
+		NS_ERR("read_buf: chip is disabled\n");
+		return;
+	}
+	if (ns->lines.ale || ns->lines.cle) {
+		NS_ERR("read_buf: ALE or CLE pin is high\n");
+		return;
+	}
+	if (!(ns->state & STATE_DATAOUT_MASK)) {
+		NS_WARN("read_buf: unexpected data output cycle, current state is %s\n",
+			get_state_name(ns->state));
+		return;
+	}
+
+	if (NS_STATE(ns->state) != STATE_DATAOUT) {
+		int i;
+
+		for (i = 0; i < len; i++)
+			buf[i] = ((struct nand_chip *)mtd->priv)->read_byte(mtd);
+
+		return;
+	}
+
+	/* Check if these are expected bytes */
+	if (ns->regs.count + len > ns->regs.num) {
+		NS_ERR("read_buf: too many bytes to read\n");
+		switch_to_ready_state(ns, NS_STATUS_FAILED(ns));
+		return;
+	}
+
+	memcpy(buf, ns->buf.byte + ns->regs.count, len);
+	ns->regs.count += len;
+	
+	if (ns->regs.count == ns->regs.num) {
+		if ((ns->options & OPT_AUTOINCR) && NS_STATE(ns->state) == STATE_DATAOUT) {
+			ns->regs.count = 0;
+			if (ns->regs.row + 1 < ns->geom.pgnum)
+				ns->regs.row += 1;
+			NS_DBG("read_buf: switch to the next page (%#x)\n", ns->regs.row);
+			do_state_action(ns, ACTION_CPY);
+		}
+		else if (NS_STATE(ns->nxstate) == STATE_READY)
+			switch_state(ns);
+	}
+	
+	return;
+}
+
+static int 
+ns_nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	ns_nand_read_buf(mtd, (u_char *)&ns_verify_buf[0], len);
+
+	if (!memcmp(buf, &ns_verify_buf[0], len)) {
+		NS_DBG("verify_buf: the buffer is OK\n");
+		return 0;
+	} else {
+		NS_DBG("verify_buf: the buffer is wrong\n");
+		return -EFAULT;
+	}
+}
+
+/*
+ * Having only NAND chip IDs we call nand_scan which detects NAND flash
+ * parameters and then calls scan_bbt in order to scan/find/build the
+ * NAND flash bad block table. But since at that moment the NAND flash
+ * image isn't allocated in the simulator, errors arise. To avoid this
+ * we redefine the scan_bbt callback and initialize the nandsim structure
+ * before the flash media scanning.
+ */
+int ns_scan_bbt(struct mtd_info *mtd)
+{ 
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct nandsim   *ns   = (struct nandsim *)(chip->priv);
+	int retval;
+
+	if (!NS_IS_INITIALIZED(ns))
+		if ((retval = init_nandsim(mtd)) != 0) {
+			NS_ERR("scan_bbt: can't initialize the nandsim structure\n");
+			return retval;
+		}
+	if ((retval = nand_default_bbt(mtd)) != 0) {
+		free_nandsim(ns);
+		return retval;
+	}
+
+	return 0;
+}
+
+/*
+ * Module initialization function
+ */
+int __init ns_init_module(void)
+{
+	struct nand_chip *chip;
+	struct nandsim *nand;
+	int retval = -ENOMEM;
+
+	if (bus_width != 8 && bus_width != 16) {
+		NS_ERR("wrong bus width (%d), use only 8 or 16\n", bus_width);
+		return -EINVAL;
+	}
+	
+	/* Allocate and initialize mtd_info, nand_chip and nandsim structures */
+	nsmtd = kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip)
+				+ sizeof(struct nandsim), GFP_KERNEL);
+	if (!nsmtd) {
+		NS_ERR("unable to allocate core structures.\n");
+		return -ENOMEM;
+	}
+	memset(nsmtd, 0, sizeof(struct mtd_info) + sizeof(struct nand_chip) +
+			sizeof(struct nandsim));
+	chip        = (struct nand_chip *)(nsmtd + 1);
+        nsmtd->priv = (void *)chip;
+	nand        = (struct nandsim *)(chip + 1);
+	chip->priv  = (void *)nand;	
+
+	/*
+	 * Register simulator's callbacks.
+	 */
+	chip->hwcontrol  = ns_hwcontrol;
+	chip->read_byte  = ns_nand_read_byte;
+	chip->dev_ready  = ns_device_ready;
+	chip->scan_bbt   = ns_scan_bbt;
+	chip->write_byte = ns_nand_write_byte;
+	chip->write_buf  = ns_nand_write_buf;
+	chip->read_buf   = ns_nand_read_buf;
+	chip->verify_buf = ns_nand_verify_buf;
+	chip->write_word = ns_nand_write_word;
+	chip->read_word  = ns_nand_read_word;
+	chip->eccmode    = NAND_ECC_SOFT;
+
+	/* 
+	 * Perform minimum nandsim structure initialization to handle
+	 * the initial ID read command correctly 
+	 */
+	if (third_id_byte != 0xFF || fourth_id_byte != 0xFF)
+		nand->geom.idbytes = 4;
+	else
+		nand->geom.idbytes = 2;
+	nand->regs.status = NS_STATUS_OK(nand);
+	nand->nxstate = STATE_UNKNOWN;
+	nand->options |= OPT_PAGE256; /* temporary value */
+	nand->ids[0] = first_id_byte;
+	nand->ids[1] = second_id_byte;
+	nand->ids[2] = third_id_byte;
+	nand->ids[3] = fourth_id_byte;
+	if (bus_width == 16) {
+		nand->busw = 16;
+		chip->options |= NAND_BUSWIDTH_16;
+	}
+
+	if ((retval = nand_scan(nsmtd, 1)) != 0) {
+		NS_ERR("can't register NAND Simulator\n");
+		if (retval > 0)
+			retval = -ENXIO;
+		goto error;
+	}
+
+	/* Register NAND as one big partition */
+	add_mtd_partitions(nsmtd, &nand->part, 1);
+
+        return 0;
+
+error:
+	kfree(nsmtd);
+
+	return retval;
+}
+
+module_init(ns_init_module);
+
+/*
+ * Module clean-up function
+ */
+static void __exit ns_cleanup_module(void)
+{
+	struct nandsim *ns = (struct nandsim *)(((struct nand_chip *)nsmtd->priv)->priv);
+
+	free_nandsim(ns);    /* Free nandsim private resources */
+	nand_release(nsmtd); /* Unregisterd drived */
+	kfree(nsmtd);        /* Free other structures */
+}
+
+module_exit(ns_cleanup_module);
+
+MODULE_LICENSE ("GPL");
+MODULE_AUTHOR ("Artem B. Bityuckiy");
+MODULE_DESCRIPTION ("The NAND flash simulator");
+
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/ppchameleonevb.c linuxppc-2.6.9-dream/drivers/mtd/nand/ppchameleonevb.c
--- linuxppc-2.6.9/drivers/mtd/nand/ppchameleonevb.c	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/ppchameleonevb.c	2005-06-20 10:46:11.000000000 +0200
@@ -6,7 +6,7 @@
  *  Derived from drivers/mtd/nand/edb7312.c
  *
  *
- * $Id: ppchameleonevb.c,v 1.2 2004/05/05 22:09:54 gleixner Exp $
+ * $Id: ppchameleonevb.c,v 1.6 2004/11/05 16:07:16 kalev Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -64,22 +64,17 @@
 /*
  * Module stuff
  */
-static int ppchameleon_fio_pbase 	= CFG_NAND0_PADDR;
-static int ppchameleonevb_fio_pbase = CFG_NAND1_PADDR;
+static unsigned long ppchameleon_fio_pbase 	= CFG_NAND0_PADDR;
+static unsigned long ppchameleonevb_fio_pbase = CFG_NAND1_PADDR;
 
 #ifdef MODULE
-MODULE_PARM(ppchameleon_fio_pbase, "i");
+module_param(ppchameleon_fio_pbase, ulong, 0);
+module_param(ppchameleonevb_fio_pbase, ulong, 0);
+#else
 __setup("ppchameleon_fio_pbase=",ppchameleon_fio_pbase);
-MODULE_PARM(ppchameleonevb_fio_pbase, "i");
 __setup("ppchameleonevb_fio_pbase=",ppchameleonevb_fio_pbase);
 #endif
 
-/* Internal buffers. Page buffer and oob buffer for one block */
-static u_char data_buf[2048 + 64];
-static u_char oob_buf[64 * 64];
-static u_char data_buf_evb[512 + 16];
-static u_char oob_buf_evb[16 * 32];
-
 #ifdef CONFIG_MTD_PARTITIONS
 /*
  * Define static partitions for flash devices
@@ -196,8 +191,8 @@
 	const char *part_type = 0;
 	int mtd_parts_nb = 0;
 	struct mtd_partition *mtd_parts = 0;
-	int ppchameleon_fio_base;
-	int ppchameleonevb_fio_base;
+	void __iomem *ppchameleon_fio_base;
+	void __iomem *ppchameleonevb_fio_base;
 
 
 	/*********************************
@@ -205,15 +200,14 @@
 	*********************************/
 	/* Allocate memory for MTD device structure and private data */
 	ppchameleon_mtd = kmalloc(sizeof(struct mtd_info) +
-			     sizeof(struct nand_chip),
-			     GFP_KERNEL);
+						      sizeof(struct nand_chip), GFP_KERNEL);
 	if (!ppchameleon_mtd) {
 		printk("Unable to allocate PPChameleon NAND MTD device structure.\n");
 		return -ENOMEM;
 	}
 
 	/* map physical address */
-	ppchameleon_fio_base = (unsigned long)ioremap(ppchameleon_fio_pbase, SZ_4M);
+	ppchameleon_fio_base = ioremap(ppchameleon_fio_pbase, SZ_4M);
 	if(!ppchameleon_fio_base) {
 		printk("ioremap PPChameleon NAND flash failed\n");
 		kfree(ppchameleon_mtd);
@@ -264,10 +258,6 @@
 	/* ECC mode */
 	this->eccmode = NAND_ECC_SOFT;
 
-	/* Set internal data buffer */
-	this->data_buf = data_buf;
-	this->oob_buf = oob_buf;
-
 	/* Scan to find existence of the device (it could not be mounted) */
 	if (nand_scan (ppchameleon_mtd, 1)) {
 		iounmap((void *)ppchameleon_fio_base);
@@ -309,15 +299,14 @@
 	****************************/
 	/* Allocate memory for MTD device structure and private data */
 	ppchameleonevb_mtd = kmalloc(sizeof(struct mtd_info) +
-			     sizeof(struct nand_chip),
-			     GFP_KERNEL);
+							 sizeof(struct nand_chip), GFP_KERNEL);
 	if (!ppchameleonevb_mtd) {
 		printk("Unable to allocate PPChameleonEVB NAND MTD device structure.\n");
 		return -ENOMEM;
 	}
 
 	/* map physical address */
-	ppchameleonevb_fio_base = (unsigned long)ioremap(ppchameleonevb_fio_pbase, SZ_4M);
+	ppchameleonevb_fio_base = ioremap(ppchameleonevb_fio_pbase, SZ_4M);
 	if(!ppchameleonevb_fio_base) {
 		printk("ioremap PPChameleonEVB NAND flash failed\n");
 		kfree(ppchameleonevb_mtd);
@@ -349,7 +338,8 @@
 	out_be32((volatile unsigned*)GPIO0_TSRH, in_be32((volatile unsigned*)GPIO0_TSRH) & 0xFFFFFFF0);
 	out_be32((volatile unsigned*)GPIO0_TSRL, in_be32((volatile unsigned*)GPIO0_TSRL) & 0x3FFFFFFF);
 	/* enable output driver */
-	out_be32((volatile unsigned*)GPIO0_TCR, in_be32((volatile unsigned*)GPIO0_TCR) | NAND_EVB_nCE_GPIO_PIN | NAND_EVB_CLE_GPIO_PIN | NAND_EVB_ALE_GPIO_PIN);
+	out_be32((volatile unsigned*)GPIO0_TCR, in_be32((volatile unsigned*)GPIO0_TCR) | NAND_EVB_nCE_GPIO_PIN | 
+		 NAND_EVB_CLE_GPIO_PIN | NAND_EVB_ALE_GPIO_PIN);
 #ifdef USE_READY_BUSY_PIN
 	/* three-state select */
 	out_be32((volatile unsigned*)GPIO0_TSRL, in_be32((volatile unsigned*)GPIO0_TSRL) & 0xFFFFFFFC);
@@ -359,7 +349,6 @@
 	out_be32((volatile unsigned*)GPIO0_ISR1L, (in_be32((volatile unsigned*)GPIO0_ISR1L) & 0xFFFFFFFC) | 0x00000001);
 #endif
 
-
 	/* insert callbacks */
 	this->IO_ADDR_R = ppchameleonevb_fio_base;
 	this->IO_ADDR_W = ppchameleonevb_fio_base;
@@ -372,10 +361,6 @@
 	/* ECC mode */
 	this->eccmode = NAND_ECC_SOFT;
 
-	/* Set internal data buffer */
-	this->data_buf = data_buf_evb;
-	this->oob_buf = oob_buf_evb;
-
 	/* Scan to find existence of the device */
 	if (nand_scan (ppchameleonevb_mtd, 1)) {
 		iounmap((void *)ppchameleonevb_fio_base);
@@ -412,15 +397,20 @@
  */
 static void __exit ppchameleonevb_cleanup (void)
 {
-	struct nand_chip *this = (struct nand_chip *) &ppchameleonevb_mtd[1];
-
-	/* Unregister the device */
-	del_mtd_device (ppchameleonevb_mtd);
+	struct nand_chip *this;
 
-	/* Free internal data buffer */
-	kfree (this->data_buf);
+	/* Release resources, unregister device(s) */
+	nand_release (ppchameleon_mtd);
+	nand_release (ppchameleonevb_mtd);
+	
+	/* Release iomaps */
+	this = (struct nand_chip *) &ppchameleon_mtd[1];
+	iounmap((void *) this->IO_ADDR_R;
+	this = (struct nand_chip *) &ppchameleonevb_mtd[1];
+	iounmap((void *) this->IO_ADDR_R;
 
 	/* Free the MTD device structure */
+	kfree (ppchameleon_mtd);
 	kfree (ppchameleonevb_mtd);
 }
 module_exit(ppchameleonevb_cleanup);
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/rtc_from4.c linuxppc-2.6.9-dream/drivers/mtd/nand/rtc_from4.c
--- linuxppc-2.6.9/drivers/mtd/nand/rtc_from4.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/rtc_from4.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,559 @@
+/*
+ *  drivers/mtd/nand/rtc_from4.c
+ *
+ *  Copyright (C) 2004  Red Hat, Inc.
+ * 
+ *  Derived from drivers/mtd/nand/spia.c
+ *       Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
+ *
+ * $Id: rtc_from4.c,v 1.7 2004/11/04 12:53:10 gleixner Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Overview:
+ *   This is a device driver for the AG-AND flash device found on the
+ *   Renesas Technology Corp. Flash ROM 4-slot interface board (FROM_BOARD4), 
+ *   which utilizes the Renesas HN29V1G91T-30 part. 
+ *   This chip is a 1 GBibit (128MiB x 8 bits) AG-AND flash device.
+ */
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/rslib.h>
+#include <linux/module.h>
+#include <linux/mtd/compatmac.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+
+/*
+ * MTD structure for Renesas board
+ */
+static struct mtd_info *rtc_from4_mtd = NULL;
+
+#define RTC_FROM4_MAX_CHIPS	2
+
+/* HS77x9 processor register defines */
+#define SH77X9_BCR1	((volatile unsigned short *)(0xFFFFFF60))
+#define SH77X9_BCR2	((volatile unsigned short *)(0xFFFFFF62))
+#define SH77X9_WCR1	((volatile unsigned short *)(0xFFFFFF64))
+#define SH77X9_WCR2	((volatile unsigned short *)(0xFFFFFF66))
+#define SH77X9_MCR	((volatile unsigned short *)(0xFFFFFF68))
+#define SH77X9_PCR	((volatile unsigned short *)(0xFFFFFF6C))
+#define SH77X9_FRQCR	((volatile unsigned short *)(0xFFFFFF80))
+
+/*
+ * Values specific to the Renesas Technology Corp. FROM_BOARD4 (used with HS77x9 processor)
+ */
+/* Address where flash is mapped */
+#define RTC_FROM4_FIO_BASE	0x14000000
+
+/* CLE and ALE are tied to address lines 5 & 4, respectively */
+#define RTC_FROM4_CLE		(1 << 5)
+#define RTC_FROM4_ALE		(1 << 4)
+
+/* address lines A24-A22 used for chip selection */
+#define RTC_FROM4_NAND_ADDR_SLOT3	(0x00800000)
+#define RTC_FROM4_NAND_ADDR_SLOT4	(0x00C00000)
+#define RTC_FROM4_NAND_ADDR_FPGA	(0x01000000)
+/* mask address lines A24-A22 used for chip selection */
+#define RTC_FROM4_NAND_ADDR_MASK	(RTC_FROM4_NAND_ADDR_SLOT3 | RTC_FROM4_NAND_ADDR_SLOT4 | RTC_FROM4_NAND_ADDR_FPGA)
+
+/* FPGA status register for checking device ready (bit zero) */
+#define RTC_FROM4_FPGA_SR		(RTC_FROM4_NAND_ADDR_FPGA | 0x00000002)
+#define RTC_FROM4_DEVICE_READY		0x0001
+
+/* FPGA Reed-Solomon ECC Control register */
+
+#define RTC_FROM4_RS_ECC_CTL		(RTC_FROM4_NAND_ADDR_FPGA | 0x00000050)
+#define RTC_FROM4_RS_ECC_CTL_CLR	(1 << 7)
+#define RTC_FROM4_RS_ECC_CTL_GEN	(1 << 6)
+#define RTC_FROM4_RS_ECC_CTL_FD_E	(1 << 5)
+
+/* FPGA Reed-Solomon ECC code base */
+#define RTC_FROM4_RS_ECC		(RTC_FROM4_NAND_ADDR_FPGA | 0x00000060)
+#define RTC_FROM4_RS_ECCN		(RTC_FROM4_NAND_ADDR_FPGA | 0x00000080)
+
+/* FPGA Reed-Solomon ECC check register */
+#define RTC_FROM4_RS_ECC_CHK		(RTC_FROM4_NAND_ADDR_FPGA | 0x00000070)
+#define RTC_FROM4_RS_ECC_CHK_ERROR	(1 << 7)
+
+/* Undefine for software ECC */
+#define RTC_FROM4_HWECC	1
+
+/*
+ * Module stuff
+ */
+static void __iomem *rtc_from4_fio_base = P2SEGADDR(RTC_FROM4_FIO_BASE);
+
+const static struct mtd_partition partition_info[] = {
+        {
+                .name   = "Renesas flash partition 1",
+                .offset = 0,
+                .size   = MTDPART_SIZ_FULL
+        },
+};
+#define NUM_PARTITIONS 1
+
+/* 
+ *	hardware specific flash bbt decriptors
+ *	Note: this is to allow debugging by disabling 
+ *		NAND_BBT_CREATE and/or NAND_BBT_WRITE
+ *
+ */
+static uint8_t bbt_pattern[] = {'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr rtc_from4_bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 40,
+	.len = 4,
+	.veroffs = 44,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr rtc_from4_bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 40,
+	.len = 4,
+	.veroffs = 44,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+
+
+#ifdef RTC_FROM4_HWECC
+
+/* the Reed Solomon control structure */
+static struct rs_control *rs_decoder;
+
+/* 
+ *      hardware specific Out Of Band information
+ */
+static struct nand_oobinfo rtc_from4_nand_oobinfo = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 32,
+	.eccpos = {
+		 0,  1,  2,  3,  4,  5,  6,  7,
+		 8,  9, 10, 11, 12, 13, 14, 15,
+		16, 17, 18, 19, 20, 21, 22, 23,
+		24, 25, 26, 27, 28, 29, 30, 31},
+	.oobfree = { {32, 32} }
+};
+
+/* Aargh. I missed the reversed bit order, when I
+ * was talking to Renesas about the FPGA.
+ *
+ * The table is used for bit reordering and inversion
+ * of the ecc byte which we get from the FPGA
+ */
+static uint8_t revbits[256] = {
+        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
+        0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+        0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
+        0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
+        0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
+        0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
+        0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
+        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
+        0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
+        0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
+        0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
+        0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
+        0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
+        0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
+        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
+        0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
+        0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
+        0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
+        0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
+        0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
+        0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
+        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+        0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
+        0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
+        0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
+        0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
+        0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
+        0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
+        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
+        0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
+        0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
+        0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
+};
+
+#endif
+
+
+
+/* 
+ * rtc_from4_hwcontrol - hardware specific access to control-lines
+ * @mtd:	MTD device structure
+ * @cmd:	hardware control command
+ *
+ * Address lines (A5 and A4) are used to control Command and Address Latch 
+ * Enable on this board, so set the read/write address appropriately.
+ *
+ * Chip Enable is also controlled by the Chip Select (CS5) and 
+ * Address lines (A24-A22), so no action is required here.
+ *
+ */
+static void rtc_from4_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *) (mtd->priv);
+	
+	switch(cmd) {
+		
+	case NAND_CTL_SETCLE: 
+		this->IO_ADDR_W = (void __iomem *)((unsigned long)this->IO_ADDR_W | RTC_FROM4_CLE);
+		break;
+	case NAND_CTL_CLRCLE: 
+		this->IO_ADDR_W = (void __iomem *)((unsigned long)this->IO_ADDR_W & ~RTC_FROM4_CLE);
+		break;
+		
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void __iomem *)((unsigned long)this->IO_ADDR_W | RTC_FROM4_ALE);
+		break;
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void __iomem *)((unsigned long)this->IO_ADDR_W & ~RTC_FROM4_ALE);
+		break;
+		
+	case NAND_CTL_SETNCE:
+		break;
+	case NAND_CTL_CLRNCE:
+		break;
+
+	}
+}
+
+
+/*
+ * rtc_from4_nand_select_chip - hardware specific chip select
+ * @mtd:	MTD device structure
+ * @chip:	Chip to select (0 == slot 3, 1 == slot 4)
+ *
+ * The chip select is based on address lines A24-A22.
+ * This driver uses flash slots 3 and 4 (A23-A22).
+ *
+ */
+static void rtc_from4_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+        struct nand_chip *this = mtd->priv;
+
+	this->IO_ADDR_R = (void __iomem *)((unsigned long)this->IO_ADDR_R & ~RTC_FROM4_NAND_ADDR_MASK);
+	this->IO_ADDR_W = (void __iomem *)((unsigned long)this->IO_ADDR_W & ~RTC_FROM4_NAND_ADDR_MASK);
+
+        switch(chip) {
+
+        case 0:		/* select slot 3 chip */
+		this->IO_ADDR_R = (void __iomem *)((unsigned long)this->IO_ADDR_R | RTC_FROM4_NAND_ADDR_SLOT3);
+		this->IO_ADDR_W = (void __iomem *)((unsigned long)this->IO_ADDR_W | RTC_FROM4_NAND_ADDR_SLOT3);
+                break;
+        case 1:		/* select slot 4 chip */
+		this->IO_ADDR_R = (void __iomem *)((unsigned long)this->IO_ADDR_R | RTC_FROM4_NAND_ADDR_SLOT4);
+		this->IO_ADDR_W = (void __iomem *)((unsigned long)this->IO_ADDR_W | RTC_FROM4_NAND_ADDR_SLOT4);
+                break;
+
+        }
+}
+
+
+
+/*
+ * rtc_from4_nand_device_ready - hardware specific ready/busy check
+ * @mtd:	MTD device structure
+ *
+ * This board provides the Ready/Busy state in the status register
+ * of the FPGA.  Bit zero indicates the RDY(1)/BSY(0) signal.
+ *
+ */
+static int rtc_from4_nand_device_ready(struct mtd_info *mtd)
+{
+	unsigned short status;
+
+	status = *((volatile unsigned short *)(rtc_from4_fio_base + RTC_FROM4_FPGA_SR));
+
+	return (status & RTC_FROM4_DEVICE_READY);
+
+}
+
+#ifdef RTC_FROM4_HWECC
+/*
+ * rtc_from4_enable_hwecc - hardware specific hardware ECC enable function
+ * @mtd:	MTD device structure
+ * @mode:	I/O mode; read or write
+ *
+ * enable hardware ECC for data read or write 
+ *
+ */
+static void rtc_from4_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	volatile unsigned short * rs_ecc_ctl = (volatile unsigned short *)(rtc_from4_fio_base + RTC_FROM4_RS_ECC_CTL);
+	unsigned short status;
+
+	switch (mode) {
+	    case NAND_ECC_READ :
+		status =  RTC_FROM4_RS_ECC_CTL_CLR 
+			| RTC_FROM4_RS_ECC_CTL_FD_E;
+
+		*rs_ecc_ctl = status;
+		break;
+
+	    case NAND_ECC_READSYN :
+		status =  0x00;
+
+		*rs_ecc_ctl = status;
+		break;
+
+	    case NAND_ECC_WRITE :
+		status =  RTC_FROM4_RS_ECC_CTL_CLR 
+			| RTC_FROM4_RS_ECC_CTL_GEN 
+			| RTC_FROM4_RS_ECC_CTL_FD_E;
+
+		*rs_ecc_ctl = status;
+		break;
+
+	    default:
+		BUG();
+		break;
+	}
+
+}
+
+/*
+ * rtc_from4_calculate_ecc - hardware specific code to read ECC code
+ * @mtd:	MTD device structure
+ * @dat:	buffer containing the data to generate ECC codes
+ * @ecc_code	ECC codes calculated
+ *
+ * The ECC code is calculated by the FPGA.  All we have to do is read the values
+ * from the FPGA registers.
+ *
+ * Note: We read from the inverted registers, since data is inverted before
+ * the code is calculated. So all 0xff data (blank page) results in all 0xff rs code
+ *
+ */
+static void rtc_from4_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	volatile unsigned short * rs_eccn = (volatile unsigned short *)(rtc_from4_fio_base + RTC_FROM4_RS_ECCN);
+	unsigned short value;
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		value = *rs_eccn;
+		ecc_code[i] = (unsigned char)value;
+		rs_eccn++;
+	}
+	ecc_code[7] |= 0x0f;	/* set the last four bits (not used) */
+}
+
+/*
+ * rtc_from4_correct_data - hardware specific code to correct data using ECC code
+ * @mtd:	MTD device structure
+ * @buf:	buffer containing the data to generate ECC codes
+ * @ecc1	ECC codes read
+ * @ecc2	ECC codes calculated
+ *
+ * The FPGA tells us fast, if there's an error or not. If no, we go back happy
+ * else we read the ecc results from the fpga and call the rs library to decode
+ * and hopefully correct the error
+ *
+ * For now I use the code, which we read from the FLASH to use the RS lib,
+ * as the syndrom conversion has a unresolved issue.
+ */
+static int rtc_from4_correct_data(struct mtd_info *mtd, const u_char *buf, u_char *ecc1, u_char *ecc2)
+{
+	int i, j, res;
+	unsigned short status; 
+	uint16_t par[6], syn[6], tmp;
+	uint8_t ecc[8];
+        volatile unsigned short *rs_ecc;
+
+	status = *((volatile unsigned short *)(rtc_from4_fio_base + RTC_FROM4_RS_ECC_CHK));
+
+	if (!(status & RTC_FROM4_RS_ECC_CHK_ERROR)) {
+		return 0;
+	}
+
+	/* Read the syndrom pattern from the FPGA and correct the bitorder */
+	rs_ecc = (volatile unsigned short *)(rtc_from4_fio_base + RTC_FROM4_RS_ECC);
+        for (i = 0; i < 8; i++) {
+                ecc[i] = revbits[(*rs_ecc) & 0xFF];
+                rs_ecc++;
+        }
+
+	/* convert into 6 10bit syndrome fields */
+	par[5] = rs_decoder->index_of[(((uint16_t)ecc[0] >> 0) & 0x0ff) | 
+				      (((uint16_t)ecc[1] << 8) & 0x300)];
+	par[4] = rs_decoder->index_of[(((uint16_t)ecc[1] >> 2) & 0x03f) |
+				      (((uint16_t)ecc[2] << 6) & 0x3c0)];
+	par[3] = rs_decoder->index_of[(((uint16_t)ecc[2] >> 4) & 0x00f) |
+				      (((uint16_t)ecc[3] << 4) & 0x3f0)];
+	par[2] = rs_decoder->index_of[(((uint16_t)ecc[3] >> 6) & 0x003) |
+				      (((uint16_t)ecc[4] << 2) & 0x3fc)];
+	par[1] = rs_decoder->index_of[(((uint16_t)ecc[5] >> 0) & 0x0ff) |
+				      (((uint16_t)ecc[6] << 8) & 0x300)];
+	par[0] = (((uint16_t)ecc[6] >> 2) & 0x03f) | (((uint16_t)ecc[7] << 6) & 0x3c0);
+
+	/* Convert to computable syndrome */
+	for (i = 0; i < 6; i++) {
+		syn[i] = par[0];
+		for (j = 1; j < 6; j++)
+			if (par[j] != rs_decoder->nn)
+				syn[i] ^= rs_decoder->alpha_to[rs_modnn(rs_decoder, par[j] + i * j)];
+
+		/* Convert to index form */
+		syn[i] = rs_decoder->index_of[syn[i]];
+	}
+
+	/* Let the library code do its magic.*/
+	res = decode_rs8(rs_decoder, buf, par, 512, syn, 0, NULL, 0xff, NULL);
+	if (res > 0) {
+		DEBUG (MTD_DEBUG_LEVEL0, "rtc_from4_correct_data: " 
+			"ECC corrected %d errors on read\n", res);
+	}
+	return res;
+}
+#endif
+
+/*
+ * Main initialization routine
+ */
+int __init rtc_from4_init (void)
+{
+	struct nand_chip *this;
+	unsigned short bcr1, bcr2, wcr2;
+
+	/* Allocate memory for MTD device structure and private data */
+	rtc_from4_mtd = kmalloc(sizeof(struct mtd_info) + sizeof (struct nand_chip),
+				GFP_KERNEL);
+	if (!rtc_from4_mtd) {
+		printk ("Unable to allocate Renesas NAND MTD device structure.\n");
+		return -ENOMEM;
+	}
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *) (&rtc_from4_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) rtc_from4_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) this, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	rtc_from4_mtd->priv = this;
+
+	/* set area 5 as PCMCIA mode to clear the spec of tDH(Data hold time;9ns min) */
+	bcr1 = *SH77X9_BCR1 & ~0x0002;
+	bcr1 |= 0x0002;
+	*SH77X9_BCR1 = bcr1;
+
+	/* set */
+	bcr2 = *SH77X9_BCR2 & ~0x0c00;
+	bcr2 |= 0x0800;
+	*SH77X9_BCR2 = bcr2;
+
+	/* set area 5 wait states */
+	wcr2 = *SH77X9_WCR2 & ~0x1c00;
+	wcr2 |= 0x1c00;
+	*SH77X9_WCR2 = wcr2;
+
+	/* Set address of NAND IO lines */
+	this->IO_ADDR_R = rtc_from4_fio_base;
+	this->IO_ADDR_W = rtc_from4_fio_base;
+	/* Set address of hardware control function */
+	this->hwcontrol = rtc_from4_hwcontrol;
+	/* Set address of chip select function */
+        this->select_chip = rtc_from4_nand_select_chip;
+	/* command delay time (in us) */
+	this->chip_delay = 100;
+	/* return the status of the Ready/Busy line */
+	this->dev_ready = rtc_from4_nand_device_ready;
+
+#ifdef RTC_FROM4_HWECC
+	printk(KERN_INFO "rtc_from4_init: using hardware ECC detection.\n");
+
+        this->eccmode = NAND_ECC_HW8_512;
+	this->options |= NAND_HWECC_SYNDROME;
+	/* set the nand_oobinfo to support FPGA H/W error detection */
+	this->autooob = &rtc_from4_nand_oobinfo;
+	this->enable_hwecc = rtc_from4_enable_hwecc;
+	this->calculate_ecc = rtc_from4_calculate_ecc;
+	this->correct_data = rtc_from4_correct_data;
+#else
+	printk(KERN_INFO "rtc_from4_init: using software ECC detection.\n");
+
+	this->eccmode = NAND_ECC_SOFT;
+#endif
+
+	/* set the bad block tables to support debugging */
+	this->bbt_td = &rtc_from4_bbt_main_descr;
+	this->bbt_md = &rtc_from4_bbt_mirror_descr;
+
+	/* Scan to find existence of the device */
+	if (nand_scan(rtc_from4_mtd, RTC_FROM4_MAX_CHIPS)) {
+		kfree(rtc_from4_mtd);
+		return -ENXIO;
+	}
+
+	/* Register the partitions */
+	add_mtd_partitions(rtc_from4_mtd, partition_info, NUM_PARTITIONS);
+
+#ifdef RTC_FROM4_HWECC
+	/* We could create the decoder on demand, if memory is a concern.
+	 * This way we have it handy, if an error happens 
+	 *
+	 * Symbolsize is 10 (bits)
+	 * Primitve polynomial is x^10+x^3+1
+	 * first consecutive root is 0
+	 * primitve element to generate roots = 1
+	 * generator polinomial degree = 6
+	 */
+	rs_decoder = init_rs(10, 0x409, 0, 1, 6);
+	if (!rs_decoder) {
+		printk (KERN_ERR "Could not create a RS decoder\n");
+		nand_release(rtc_from4_mtd);
+		kfree(rtc_from4_mtd);
+		return -ENOMEM;
+	}
+#endif
+	/* Return happy */
+	return 0;
+}
+module_init(rtc_from4_init);
+
+
+/*
+ * Clean up routine
+ */
+#ifdef MODULE
+static void __exit rtc_from4_cleanup (void)
+{
+	/* Release resource, unregister partitions */
+	nand_release(rtc_from4_mtd);
+
+	/* Free the MTD device structure */
+	kfree (rtc_from4_mtd);
+
+#ifdef RTC_FROM4_HWECC
+	/* Free the reed solomon resources */
+	if (rs_decoder) {
+		free_rs(rs_decoder);
+	}
+#endif
+}
+module_exit(rtc_from4_cleanup);
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("d.marlin <dmarlin@redhat.com");
+MODULE_DESCRIPTION("Board-specific glue layer for AG-AND flash on Renesas FROM_BOARD4");
+
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/s3c2410.c linuxppc-2.6.9-dream/drivers/mtd/nand/s3c2410.c
--- linuxppc-2.6.9/drivers/mtd/nand/s3c2410.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/s3c2410.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,704 @@
+/* linux/drivers/mtd/nand/s3c2410.c
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ * Ben Dooks <ben@simtec.co.uk>
+ *
+ * Samsung S3C2410 NAND driver
+ *
+ * Changelog:
+ *	21-Sep-2004  BJD  Initial version
+ *	23-Sep-2004  BJD  Mulitple device support
+ *	28-Sep-2004  BJD  Fixed ECC placement for Hardware mode
+ *	12-Oct-2004  BJD  Fixed errors in use of platform data
+ *
+ * $Id: s3c2410.c,v 1.7 2005/01/05 18:05:14 dwmw2 Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <config/mtd/nand/s3c2410/hwecc.h>
+#include <config/mtd/nand/s3c2410/debug.h>
+
+#ifdef CONFIG_MTD_NAND_S3C2410_DEBUG
+#define DEBUG
+#endif
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <asm/hardware/clock.h>
+
+#include <asm/arch/regs-nand.h>
+#include <asm/arch/nand.h>
+
+#define PFX "s3c2410-nand: "
+
+#ifdef CONFIG_MTD_NAND_S3C2410_HWECC
+static int hardware_ecc = 1;
+#else
+static int hardware_ecc = 0;
+#endif
+
+/* new oob placement block for use with hardware ecc generation
+ */
+
+static struct nand_oobinfo nand_hw_eccoob = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 3,
+	.eccpos = {0, 1, 2 },
+	.oobfree = { {8, 8} }
+};
+
+/* controller and mtd information */
+
+struct s3c2410_nand_info;
+
+struct s3c2410_nand_mtd {
+	struct mtd_info			mtd;
+	struct nand_chip		chip;
+	struct s3c2410_nand_set		*set;
+	struct s3c2410_nand_info	*info;
+	int				scan_res;
+};
+
+/* overview of the s3c2410 nand state */
+
+struct s3c2410_nand_info {
+	/* mtd info */
+	struct nand_hw_control		controller;
+	struct s3c2410_nand_mtd		*mtds;
+	struct s3c2410_platform_nand	*platform;
+
+	/* device info */
+	struct device			*device;
+	struct resource			*area;
+	struct clk			*clk;
+	void				*regs;
+	int				mtd_count;
+};
+
+/* conversion functions */
+
+static struct s3c2410_nand_mtd *s3c2410_nand_mtd_toours(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct s3c2410_nand_mtd, mtd);
+}
+
+static struct s3c2410_nand_info *s3c2410_nand_mtd_toinfo(struct mtd_info *mtd)
+{
+	return s3c2410_nand_mtd_toours(mtd)->info;
+}
+
+static struct s3c2410_nand_info *to_nand_info(struct device *dev)
+{
+	return dev_get_drvdata(dev);
+}
+
+static struct s3c2410_platform_nand *to_nand_plat(struct device *dev)
+{
+	return dev->platform_data;
+}
+
+/* timing calculations */
+
+#define NS_IN_KHZ 10000000
+
+static int s3c2410_nand_calc_rate(int wanted, unsigned long clk, int max)
+{
+	int result;
+
+	result = (wanted * NS_IN_KHZ) / clk;
+	result++;
+
+	pr_debug("result %d from %ld, %d\n", result, clk, wanted);
+
+	if (result > max) {
+		printk("%d ns is too big for current clock rate %ld\n",
+		       wanted, clk);
+		return -1;
+	}
+
+	if (result < 1)
+		result = 1;
+
+	return result;
+}
+
+#define to_ns(ticks,clk) (((clk) * (ticks)) / NS_IN_KHZ)
+
+/* controller setup */
+
+static int s3c2410_nand_inithw(struct s3c2410_nand_info *info, 
+			       struct device *dev)
+{
+	struct s3c2410_platform_nand *plat = to_nand_plat(dev);
+	unsigned int tacls, twrph0, twrph1;
+	unsigned long clkrate = clk_get_rate(info->clk);
+	unsigned long cfg;
+
+	/* calculate the timing information for the controller */
+
+	if (plat != NULL) {
+		tacls = s3c2410_nand_calc_rate(plat->tacls, clkrate, 8);
+		twrph0 = s3c2410_nand_calc_rate(plat->twrph0, clkrate, 8);
+		twrph1 = s3c2410_nand_calc_rate(plat->twrph1, clkrate, 8);
+	} else {
+		/* default timings */
+		tacls = 8;
+		twrph0 = 8;
+		twrph1 = 8;
+	}
+	
+	if (tacls < 0 || twrph0 < 0 || twrph1 < 0) {
+		printk(KERN_ERR PFX "cannot get timings suitable for board\n");
+		return -EINVAL;
+	}
+
+	printk(KERN_INFO PFX "timing: Tacls %ldns, Twrph0 %ldns, Twrph1 %ldns\n",
+	       to_ns(tacls, clkrate),
+	       to_ns(twrph0, clkrate),
+	       to_ns(twrph1, clkrate));
+
+	cfg  = S3C2410_NFCONF_EN;
+	cfg |= S3C2410_NFCONF_TACLS(tacls-1);
+	cfg |= S3C2410_NFCONF_TWRPH0(twrph0-1);
+	cfg |= S3C2410_NFCONF_TWRPH1(twrph1-1);
+
+	pr_debug(PFX "NF_CONF is 0x%lx\n", cfg);
+
+	writel(cfg, info->regs + S3C2410_NFCONF);
+	return 0;
+}
+
+/* select chip */
+
+static void s3c2410_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	struct s3c2410_nand_info *info;
+	struct s3c2410_nand_mtd *nmtd; 
+	struct nand_chip *this = mtd->priv;
+	unsigned long cur;
+
+	nmtd = this->priv;
+	info = nmtd->info;
+
+	cur = readl(info->regs + S3C2410_NFCONF);
+
+	if (chip == -1) {
+		cur |= S3C2410_NFCONF_nFCE;
+	} else {
+		if (chip > nmtd->set->nr_chips) {
+			printk(KERN_ERR PFX "chip %d out of range\n", chip);
+			return;
+		}
+
+		if (info->platform != NULL) {
+			if (info->platform->select_chip != NULL)
+				(info->platform->select_chip)(nmtd->set, chip);
+		}
+
+		cur &= ~S3C2410_NFCONF_nFCE;
+	}
+
+	writel(cur, info->regs + S3C2410_NFCONF);
+}
+
+/* command and control functions */
+
+static void s3c2410_nand_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	unsigned long cur;
+
+	switch (cmd) {
+	case NAND_CTL_SETNCE:
+		cur = readl(info->regs + S3C2410_NFCONF);
+		cur &= ~S3C2410_NFCONF_nFCE;
+		writel(cur, info->regs + S3C2410_NFCONF);
+		break;
+
+	case NAND_CTL_CLRNCE:
+		cur = readl(info->regs + S3C2410_NFCONF);
+		cur |= S3C2410_NFCONF_nFCE;
+		writel(cur, info->regs + S3C2410_NFCONF);
+		break;
+
+		/* we don't need to implement these */
+	case NAND_CTL_SETCLE:
+	case NAND_CTL_CLRCLE:
+	case NAND_CTL_SETALE:
+	case NAND_CTL_CLRALE:
+		pr_debug(PFX "s3c2410_nand_hwcontrol(%d) unusedn", cmd);
+		break;
+	}
+}
+
+/* s3c2410_nand_command
+ *
+ * This function implements sending commands and the relevant address
+ * information to the chip, via the hardware controller. Since the
+ * S3C2410 generates the correct ALE/CLE signaling automatically, we
+ * do not need to use hwcontrol.
+*/
+
+static void s3c2410_nand_command (struct mtd_info *mtd, unsigned command,
+				  int column, int page_addr)
+{
+	register struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	register struct nand_chip *this = mtd->priv;
+
+	/*
+	 * Write out the command to the device.
+	 */
+	if (command == NAND_CMD_SEQIN) {
+		int readcmd;
+
+		if (column >= mtd->oobblock) {
+			/* OOB area */
+			column -= mtd->oobblock;
+			readcmd = NAND_CMD_READOOB;
+		} else if (column < 256) {
+			/* First 256 bytes --> READ0 */
+			readcmd = NAND_CMD_READ0;
+		} else {
+			column -= 256;
+			readcmd = NAND_CMD_READ1;
+		}
+		
+		writeb(readcmd, info->regs + S3C2410_NFCMD);
+	}
+	writeb(command, info->regs + S3C2410_NFCMD);
+
+	/* Set ALE and clear CLE to start address cycle */
+
+	if (column != -1 || page_addr != -1) {
+
+		/* Serially input address */
+		if (column != -1) {
+			/* Adjust columns for 16 bit buswidth */
+			if (this->options & NAND_BUSWIDTH_16)
+				column >>= 1;
+			writeb(column, info->regs + S3C2410_NFADDR);
+		}
+		if (page_addr != -1) {
+			writeb((unsigned char) (page_addr), info->regs + S3C2410_NFADDR);
+			writeb((unsigned char) (page_addr >> 8), info->regs + S3C2410_NFADDR);
+			/* One more address cycle for higher density devices */
+			if (this->chipsize & 0x0c000000) 
+				writeb((unsigned char) ((page_addr >> 16) & 0x0f),
+				       info->regs + S3C2410_NFADDR);
+		}
+		/* Latch in address */
+	}
+	
+	/* 
+	 * program and erase have their own busy handlers 
+	 * status and sequential in needs no delay
+	*/
+	switch (command) {
+			
+	case NAND_CMD_PAGEPROG:
+	case NAND_CMD_ERASE1:
+	case NAND_CMD_ERASE2:
+	case NAND_CMD_SEQIN:
+	case NAND_CMD_STATUS:
+		return;
+
+	case NAND_CMD_RESET:
+		if (this->dev_ready)	
+			break;
+
+		udelay(this->chip_delay);
+		writeb(NAND_CMD_STATUS, info->regs + S3C2410_NFCMD);
+
+		while ( !(this->read_byte(mtd) & 0x40));
+		return;
+
+	/* This applies to read commands */	
+	default:
+		/* 
+		 * If we don't have access to the busy pin, we apply the given
+		 * command delay
+		*/
+		if (!this->dev_ready) {
+			udelay (this->chip_delay);
+			return;
+		}	
+	}
+	
+	/* Apply this short delay always to ensure that we do wait tWB in
+	 * any case on any machine. */
+	ndelay (100);
+	/* wait until command is processed */
+	while (!this->dev_ready(mtd));
+}
+
+
+/* s3c2410_nand_devready()
+ *
+ * returns 0 if the nand is busy, 1 if it is ready
+*/
+
+static int s3c2410_nand_devready(struct mtd_info *mtd)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	
+	return readb(info->regs + S3C2410_NFSTAT) & S3C2410_NFSTAT_BUSY;
+}
+
+/* ECC handling functions */
+
+static int s3c2410_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *calc_ecc)
+{
+	pr_debug("s3c2410_nand_correct_data(%p,%p,%p,%p)\n",
+		 mtd, dat, read_ecc, calc_ecc);
+
+	pr_debug("eccs: read %02x,%02x,%02x vs calc %02x,%02x,%02x\n",
+		 read_ecc[0], read_ecc[1], read_ecc[2],
+		 calc_ecc[0], calc_ecc[1], calc_ecc[2]);
+
+	if (read_ecc[0] == calc_ecc[0] &&
+	    read_ecc[1] == calc_ecc[1] &&
+	    read_ecc[2] == calc_ecc[2]) 
+		return 0;
+
+	/* we curently have no method for correcting the error */
+
+	return -1;
+}
+
+static void s3c2410_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	unsigned long ctrl;
+
+	ctrl = readl(info->regs + S3C2410_NFCONF);
+	ctrl |= S3C2410_NFCONF_INITECC;
+	writel(ctrl, info->regs + S3C2410_NFCONF);
+}
+
+static int s3c2410_nand_calculate_ecc(struct mtd_info *mtd,
+				      const u_char *dat, u_char *ecc_code)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+
+	ecc_code[0] = readb(info->regs + S3C2410_NFECC + 0);
+	ecc_code[1] = readb(info->regs + S3C2410_NFECC + 1);
+	ecc_code[2] = readb(info->regs + S3C2410_NFECC + 2);
+
+	pr_debug("calculate_ecc: returning ecc %02x,%02x,%02x\n",
+		 ecc_code[0], ecc_code[1], ecc_code[2]);
+
+	return 0;
+}
+
+
+/* over-ride the standard functions for a little more speed? */
+
+static void s3c2410_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	struct nand_chip *this = mtd->priv;
+	readsb(this->IO_ADDR_R, buf, len);
+}
+
+static void s3c2410_nand_write_buf(struct mtd_info *mtd,
+				   const u_char *buf, int len)
+{
+	struct nand_chip *this = mtd->priv;
+	writesb(this->IO_ADDR_W, buf, len);
+}
+
+/* device management functions */
+
+static int s3c2410_nand_remove(struct device *dev)
+{
+	struct s3c2410_nand_info *info = to_nand_info(dev);
+
+	dev_set_drvdata(dev, NULL);
+
+	if (info == NULL) 
+		return 0;
+
+	/* first thing we need to do is release all our mtds
+	 * and their partitions, then go through freeing the
+	 * resources used 
+	 */
+	
+	if (info->mtds != NULL) {
+		struct s3c2410_nand_mtd *ptr = info->mtds;
+		int mtdno;
+
+		for (mtdno = 0; mtdno < info->mtd_count; mtdno++, ptr++) {
+			pr_debug("releasing mtd %d (%p)\n", mtdno, ptr);
+			nand_release(&ptr->mtd);
+		}
+
+		kfree(info->mtds);
+	}
+
+	/* free the common resources */
+
+	if (info->clk != NULL && !IS_ERR(info->clk)) {
+		clk_disable(info->clk);
+		clk_unuse(info->clk);
+		clk_put(info->clk);
+	}
+
+	if (info->regs != NULL) {
+		iounmap(info->regs);
+		info->regs = NULL;
+	}
+
+	if (info->area != NULL) {
+		release_resource(info->area);
+		kfree(info->area);
+		info->area = NULL;
+	}
+
+	kfree(info);
+
+	return 0;
+}
+
+#ifdef CONFIG_MTD_PARTITIONS
+static int s3c2410_nand_add_partition(struct s3c2410_nand_info *info,
+				      struct s3c2410_nand_mtd *mtd,
+				      struct s3c2410_nand_set *set)
+{
+	if (set == NULL)
+		return add_mtd_device(&mtd->mtd);
+
+	if (set->nr_partitions > 0 && set->partitions != NULL) {
+		return add_mtd_partitions(&mtd->mtd,
+					  set->partitions,
+					  set->nr_partitions);
+	}
+
+	return add_mtd_device(&mtd->mtd);
+}
+#else
+static int s3c2410_nand_add_partition(struct s3c2410_nand_info *info,
+				      struct s3c2410_nand_mtd *mtd,
+				      struct s3c2410_nand_set *set)
+{
+	return add_mtd_device(&mtd->mtd);
+}
+#endif
+
+/* s3c2410_nand_init_chip
+ *
+ * init a single instance of an chip 
+*/
+
+static void s3c2410_nand_init_chip(struct s3c2410_nand_info *info,
+				   struct s3c2410_nand_mtd *nmtd,
+				   struct s3c2410_nand_set *set)
+{
+	struct nand_chip *chip = &nmtd->chip;
+
+	chip->IO_ADDR_R	   = (char *)info->regs + S3C2410_NFDATA;
+	chip->IO_ADDR_W    = (char *)info->regs + S3C2410_NFDATA;
+	chip->hwcontrol    = s3c2410_nand_hwcontrol;
+	chip->dev_ready    = s3c2410_nand_devready;
+	chip->cmdfunc      = s3c2410_nand_command;
+	chip->write_buf    = s3c2410_nand_write_buf;
+	chip->read_buf     = s3c2410_nand_read_buf;
+	chip->select_chip  = s3c2410_nand_select_chip;
+	chip->chip_delay   = 50;
+	chip->priv	   = nmtd;
+	chip->options	   = 0;
+	chip->controller   = &info->controller;
+
+	nmtd->info	   = info;
+	nmtd->mtd.priv	   = chip;
+	nmtd->set	   = set;
+
+	if (hardware_ecc) {
+		chip->correct_data  = s3c2410_nand_correct_data;
+		chip->enable_hwecc  = s3c2410_nand_enable_hwecc;
+		chip->calculate_ecc = s3c2410_nand_calculate_ecc;
+		chip->eccmode	    = NAND_ECC_HW3_512;
+		chip->autooob       = &nand_hw_eccoob;
+	} else {
+		chip->eccmode	    = NAND_ECC_SOFT;
+	}
+}
+
+/* s3c2410_nand_probe
+ *
+ * called by device layer when it finds a device matching
+ * one our driver can handled. This code checks to see if
+ * it can allocate all necessary resources then calls the
+ * nand layer to look for devices
+*/
+
+static int s3c2410_nand_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct s3c2410_platform_nand *plat = to_nand_plat(dev);
+	struct s3c2410_nand_info *info;
+	struct s3c2410_nand_mtd *nmtd;
+	struct s3c2410_nand_set *sets;
+	struct resource *res;
+	int err = 0;
+	int size;
+	int nr_sets;
+	int setno;
+
+	pr_debug("s3c2410_nand_probe(%p)\n", dev);
+
+	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	if (info == NULL) {
+		printk(KERN_ERR PFX "no memory for flash info\n");
+		err = -ENOMEM;
+		goto exit_error;
+	}
+
+	memzero(info, sizeof(*info));
+	dev_set_drvdata(dev, info);
+
+	spin_lock_init(&info->controller.lock);
+
+	/* get the clock source and enable it */
+
+	info->clk = clk_get(dev, "nand");
+	if (IS_ERR(info->clk)) {
+		printk(KERN_ERR PFX "failed to get clock");
+		err = -ENOENT;
+		goto exit_error;
+	}
+
+	clk_use(info->clk);
+	clk_enable(info->clk);
+
+	/* allocate and map the resource */
+
+	res = pdev->resource;  /* assume that the flash has one resource */
+	size = res->end - res->start + 1;
+
+	info->area = request_mem_region(res->start, size, pdev->name);
+
+	if (info->area == NULL) {
+		printk(KERN_ERR PFX "cannot reserve register region\n");
+		err = -ENOENT;
+		goto exit_error;
+	}
+
+	info->device = dev;
+	info->platform = plat;
+	info->regs = ioremap(res->start, size);
+
+	if (info->regs == NULL) {
+		printk(KERN_ERR PFX "cannot reserve register region\n");
+		err = -EIO;
+		goto exit_error;
+	}		
+
+	printk(KERN_INFO PFX "mapped registers at %p\n", info->regs);
+
+	/* initialise the hardware */
+
+	err = s3c2410_nand_inithw(info, dev);
+	if (err != 0)
+		goto exit_error;
+
+	sets = (plat != NULL) ? plat->sets : NULL;
+	nr_sets = (plat != NULL) ? plat->nr_sets : 1;
+
+	info->mtd_count = nr_sets;
+
+	/* allocate our information */
+
+	size = nr_sets * sizeof(*info->mtds);
+	info->mtds = kmalloc(size, GFP_KERNEL);
+	if (info->mtds == NULL) {
+		printk(KERN_ERR PFX "failed to allocate mtd storage\n");
+		err = -ENOMEM;
+		goto exit_error;
+	}
+
+	memzero(info->mtds, size);
+
+	/* initialise all possible chips */
+
+	nmtd = info->mtds;
+
+	for (setno = 0; setno < nr_sets; setno++, nmtd++) {
+		pr_debug("initialising set %d (%p, info %p)\n",
+			 setno, nmtd, info);
+		
+		s3c2410_nand_init_chip(info, nmtd, sets);
+
+		nmtd->scan_res = nand_scan(&nmtd->mtd,
+					   (sets) ? sets->nr_chips : 1);
+
+		if (nmtd->scan_res == 0) {
+			s3c2410_nand_add_partition(info, nmtd, sets);
+		}
+
+		if (sets != NULL)
+			sets++;
+	}
+	
+	pr_debug("initialised ok\n");
+	return 0;
+
+ exit_error:
+	s3c2410_nand_remove(dev);
+
+	if (err == 0)
+		err = -EINVAL;
+	return err;
+}
+
+static struct device_driver s3c2410_nand_driver = {
+	.name		= "s3c2410-nand",
+	.bus		= &platform_bus_type,
+	.probe		= s3c2410_nand_probe,
+	.remove		= s3c2410_nand_remove,
+};
+
+static int __init s3c2410_nand_init(void)
+{
+	printk("S3C2410 NAND Driver, (c) 2004 Simtec Electronics\n");
+	return driver_register(&s3c2410_nand_driver);
+}
+
+static void __exit s3c2410_nand_exit(void)
+{
+	driver_unregister(&s3c2410_nand_driver);
+}
+
+module_init(s3c2410_nand_init);
+module_exit(s3c2410_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
+MODULE_DESCRIPTION("S3C2410 MTD NAND driver");
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/sharpsl.c linuxppc-2.6.9-dream/drivers/mtd/nand/sharpsl.c
--- linuxppc-2.6.9/drivers/mtd/nand/sharpsl.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/sharpsl.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,260 @@
+/*
+ * drivers/mtd/nand/sharpsl.c
+ *
+ *  Copyright (C) 2004 Richard Purdie
+ *
+ *  $Id: sharpsl.c,v 1.3 2005/01/03 14:53:50 rpurdie Exp $
+ *
+ *  Based on Sharp's NAND driver sharp_sl.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/genhd.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+static void __iomem *sharpsl_io_base;
+static int sharpsl_phys_base = 0x0C000000;
+
+/* register offset */
+#define ECCLPLB	 	sharpsl_io_base+0x00	/* line parity 7 - 0 bit */
+#define ECCLPUB	 	sharpsl_io_base+0x04	/* line parity 15 - 8 bit */
+#define ECCCP	   	sharpsl_io_base+0x08	/* column parity 5 - 0 bit */
+#define ECCCNTR	 	sharpsl_io_base+0x0C	/* ECC byte counter */
+#define ECCCLRR	 	sharpsl_io_base+0x10	/* cleare ECC */
+#define FLASHIO	 	sharpsl_io_base+0x14	/* Flash I/O */
+#define FLASHCTL	sharpsl_io_base+0x18	/* Flash Control */
+
+/* Flash control bit */
+#define FLRYBY		(1 << 5)
+#define FLCE1		(1 << 4)
+#define FLWP		(1 << 3)
+#define FLALE		(1 << 2)
+#define FLCLE		(1 << 1)
+#define FLCE0		(1 << 0)
+
+
+/*
+ * MTD structure for SharpSL
+ */
+static struct mtd_info *sharpsl_mtd = NULL;
+
+/*
+ * Define partitions for flash device
+ */
+#define DEFAULT_NUM_PARTITIONS 3
+
+static int nr_partitions;
+static struct mtd_partition sharpsl_nand_default_partition_info[] = {
+	{
+	.name = "System Area",
+	.offset = 0,
+	.size = 7 * 1024 * 1024,
+	},
+	{
+	.name = "Root Filesystem",
+	.offset = 7 * 1024 * 1024,
+	.size = 30 * 1024 * 1024,
+	},
+	{
+	.name = "Home Filesystem",
+	.offset = MTDPART_OFS_APPEND ,
+	.size = MTDPART_SIZ_FULL ,
+	},
+};
+
+/* 
+ *	hardware specific access to control-lines
+ */
+static void
+sharpsl_nand_hwcontrol(struct mtd_info* mtd, int cmd)
+{
+	switch (cmd) {
+	case NAND_CTL_SETCLE: 
+		writeb(readb(FLASHCTL) | FLCLE, FLASHCTL);
+		break;
+	case NAND_CTL_CLRCLE:
+		writeb(readb(FLASHCTL) & ~FLCLE, FLASHCTL);
+		break;
+
+	case NAND_CTL_SETALE:
+		writeb(readb(FLASHCTL) | FLALE, FLASHCTL);
+		break;
+	case NAND_CTL_CLRALE:
+		writeb(readb(FLASHCTL) & ~FLALE, FLASHCTL);
+		break;
+
+	case NAND_CTL_SETNCE: 
+		writeb(readb(FLASHCTL) & ~(FLCE0|FLCE1), FLASHCTL);
+		break;
+	case NAND_CTL_CLRNCE: 
+		writeb(readb(FLASHCTL) | (FLCE0|FLCE1), FLASHCTL);
+		break;
+	}
+}
+
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+
+static struct nand_bbt_descr sharpsl_bbt = {
+	.options = 0,
+	.offs = 4,
+	.len = 2,
+	.pattern = scan_ff_pattern
+};
+
+static int
+sharpsl_nand_dev_ready(struct mtd_info* mtd)
+{
+	return !((readb(FLASHCTL) & FLRYBY) == 0);
+}
+
+static void
+sharpsl_nand_enable_hwecc(struct mtd_info* mtd, int mode)
+{
+	writeb(0 ,ECCCLRR);
+}
+
+static int
+sharpsl_nand_calculate_ecc(struct mtd_info* mtd, const u_char* dat,
+				u_char* ecc_code)
+{
+	ecc_code[0] = ~readb(ECCLPUB);
+	ecc_code[1] = ~readb(ECCLPLB);
+	ecc_code[2] = (~readb(ECCCP) << 2) | 0x03;
+	return readb(ECCCNTR) != 0;
+}
+
+
+#ifdef CONFIG_MTD_PARTITIONS
+const char *part_probes[] = { "cmdlinepart", NULL };
+#endif
+
+
+/*
+ * Main initialization routine
+ */
+int __init
+sharpsl_nand_init(void)
+{
+	struct nand_chip *this;
+	struct mtd_partition* sharpsl_partition_info;
+	int err = 0;
+
+	/* Allocate memory for MTD device structure and private data */
+	sharpsl_mtd = kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip),
+				GFP_KERNEL);
+	if (!sharpsl_mtd) {
+		printk ("Unable to allocate SharpSL NAND MTD device structure.\n");
+		return -ENOMEM;
+	}
+	
+	/* map physical adress */
+	sharpsl_io_base = ioremap(sharpsl_phys_base, 0x1000);
+	if(!sharpsl_io_base){
+		printk("ioremap to access Sharp SL NAND chip failed\n");
+		kfree(sharpsl_mtd);
+		return -EIO;
+	}
+	
+	/* Get pointer to private data */
+	this = (struct nand_chip *) (&sharpsl_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) sharpsl_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) this, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	sharpsl_mtd->priv = this;
+
+	/*
+	 * PXA initialize
+	 */
+	writeb(readb(FLASHCTL) | FLWP, FLASHCTL);
+
+	/* Set address of NAND IO lines */
+	this->IO_ADDR_R = FLASHIO;
+	this->IO_ADDR_W = FLASHIO;
+	/* Set address of hardware control function */
+	this->hwcontrol = sharpsl_nand_hwcontrol;
+	this->dev_ready = sharpsl_nand_dev_ready;
+	/* 15 us command delay time */
+	this->chip_delay = 15;
+	/* set eccmode using hardware ECC */
+	this->eccmode = NAND_ECC_HW3_256;
+	this->enable_hwecc = sharpsl_nand_enable_hwecc;
+	this->calculate_ecc = sharpsl_nand_calculate_ecc;
+	this->correct_data = nand_correct_data;
+	this->badblock_pattern = &sharpsl_bbt;
+
+	/* Scan to find existence of the device */
+	err=nand_scan(sharpsl_mtd,1);
+	if (err) {
+		iounmap(sharpsl_io_base);
+		kfree(sharpsl_mtd);
+		return err;
+	}
+
+	/* Register the partitions */
+	sharpsl_mtd->name = "sharpsl-nand";
+	nr_partitions = parse_mtd_partitions(sharpsl_mtd, part_probes,
+						&sharpsl_partition_info, 0);
+						 
+	if (nr_partitions <= 0) {
+		nr_partitions = DEFAULT_NUM_PARTITIONS;
+		sharpsl_partition_info = sharpsl_nand_default_partition_info;
+		if (machine_is_poodle()) {
+			sharpsl_partition_info[1].size=22 * 1024 * 1024;
+		} else if (machine_is_corgi() || machine_is_shepherd()) {
+			sharpsl_partition_info[1].size=25 * 1024 * 1024;
+		} else if (machine_is_husky()) {
+			sharpsl_partition_info[1].size=53 * 1024 * 1024;
+		} 		
+	}
+
+	if (machine_is_husky()) {
+		/* Need to use small eraseblock size for backward compatibility */
+		sharpsl_mtd->flags |= MTD_NO_VIRTBLOCKS;
+	}
+
+	add_mtd_partitions(sharpsl_mtd, sharpsl_partition_info, nr_partitions);
+
+	/* Return happy */
+	return 0;
+}
+module_init(sharpsl_nand_init);
+
+/*
+ * Clean up routine
+ */
+#ifdef MODULE
+static void __exit sharpsl_nand_cleanup(void)
+{
+	struct nand_chip *this = (struct nand_chip *) &sharpsl_mtd[1];
+
+	/* Release resources, unregister device */
+	nand_release(sharpsl_mtd);
+
+	iounmap(sharpsl_io_base);
+
+	/* Free the MTD device structure */
+	kfree(sharpsl_mtd);
+}
+module_exit(sharpsl_nand_cleanup);
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Richard Purdie <rpurdie@rpsys.net>");
+MODULE_DESCRIPTION("Device specific logic for NAND flash on Sharp SL-C7xx Series");
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/spia.c linuxppc-2.6.9-dream/drivers/mtd/nand/spia.c
--- linuxppc-2.6.9/drivers/mtd/nand/spia.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/spia.c	2005-06-20 10:46:11.000000000 +0200
@@ -8,7 +8,7 @@
  *			to controllines	(due to change in nand.c)
  *			page_cache added
  *
- * $Id: spia.c,v 1.21 2003/07/11 15:12:29 dwmw2 Exp $
+ * $Id: spia.c,v 1.24 2004/11/04 12:53:10 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -59,10 +59,10 @@
 static int spia_pedr = SPIA_PEDR;
 static int spia_peddr = SPIA_PEDDR;
 
-MODULE_PARM(spia_io_base, "i");
-MODULE_PARM(spia_fio_base, "i");
-MODULE_PARM(spia_pedr, "i");
-MODULE_PARM(spia_peddr, "i");
+module_param(spia_io_base, int, 0);
+module_param(spia_fio_base, int, 0);
+module_param(spia_pedr, int, 0);
+module_param(spia_peddr, int, 0);
 
 /*
  * Define partitions for flash device
@@ -132,8 +132,8 @@
 	(*(volatile unsigned char *) (spia_io_base + spia_peddr)) = 0x07;
 
 	/* Set address of NAND IO lines */
-	this->IO_ADDR_R = spia_fio_base;
-	this->IO_ADDR_W = spia_fio_base;
+	this->IO_ADDR_R = (void __iomem *) spia_fio_base;
+	this->IO_ADDR_W = (void __iomem *) spia_fio_base;
 	/* Set address of hardware control function */
 	this->hwcontrol = spia_hwcontrol;
 	/* 15 us command delay time */
@@ -145,14 +145,6 @@
 		return -ENXIO;
 	}
 
-	/* Allocate memory for internal data buffer */
-	this->data_buf = kmalloc (sizeof(u_char) * (spia_mtd->oobblock + spia_mtd->oobsize), GFP_KERNEL);
-	if (!this->data_buf) {
-		printk ("Unable to allocate NAND data buffer for SPIA.\n");
-		kfree (spia_mtd);
-		return -ENOMEM;
-	}
-
 	/* Register the partitions */
 	add_mtd_partitions(spia_mtd, partition_info, NUM_PARTITIONS);
 
@@ -167,13 +159,8 @@
 #ifdef MODULE
 static void __exit spia_cleanup (void)
 {
-	struct nand_chip *this = (struct nand_chip *) &spia_mtd[1];
-
-	/* Unregister the device */
-	del_mtd_device (spia_mtd);
-
-	/* Free internal data buffer */
-	kfree (this->data_buf);
+	/* Release resources, unregister device */
+	nand_release (spia_mtd);
 
 	/* Free the MTD device structure */
 	kfree (spia_mtd);
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/toto.c linuxppc-2.6.9-dream/drivers/mtd/nand/toto.c
--- linuxppc-2.6.9/drivers/mtd/nand/toto.c	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/toto.c	2005-06-20 10:46:11.000000000 +0200
@@ -15,7 +15,7 @@
  *   This is a device driver for the NAND flash device found on the
  *   TI fido board. It supports 32MiB and 64MiB cards
  *
- * $Id: toto.c,v 1.2 2003/10/21 10:04:58 dwmw2 Exp $
+ * $Id: toto.c,v 1.4 2004/10/05 13:50:20 gleixner Exp $
  */
 
 #include <linux/slab.h>
@@ -37,7 +37,7 @@
  */
 static struct mtd_info *toto_mtd = NULL;
 
-static int toto_io_base = OMAP_FLASH_1_BASE;
+static unsigned long toto_io_base = OMAP_FLASH_1_BASE;
 
 #define CONFIG_NAND_WORKAROUND 1
 
@@ -155,14 +155,6 @@
 		goto out_mtd;
 	}
 
-	/* Allocate memory for internal data buffer */
-	this->data_buf = kmalloc (sizeof(u_char) * (toto_mtd->oobblock + toto_mtd->oobsize), GFP_KERNEL);
-	if (!this->data_buf) {
-		printk (KERN_WARNING "Unable to allocate NAND data buffer for toto.\n");
-		err = -ENOMEM;
-		goto out_mtd;
-	}
-
 	/* Register the partitions */
 	switch(toto_mtd->size){
 		case SZ_64M: add_mtd_partitions(toto_mtd, partition_info64M, NUM_PARTITIONS64M); break; 
@@ -194,16 +186,8 @@
  */
 static void __exit toto_cleanup (void)
 {
-	struct nand_chip *this = (struct nand_chip *) &toto_mtd[1];
-
-	/* Unregister partitions */
-	del_mtd_partitions(toto_mtd);
-	
-	/* Unregister the device */
-	del_mtd_device (toto_mtd);
-
-	/* Free internal data buffers */
-	kfree (this->data_buf);
+	/* Release resources, unregister device */
+	nand_release (toto_mtd);
 
 	/* Free the MTD device structure */
 	kfree (toto_mtd);
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/tx4925ndfmc.c linuxppc-2.6.9-dream/drivers/mtd/nand/tx4925ndfmc.c
--- linuxppc-2.6.9/drivers/mtd/nand/tx4925ndfmc.c	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/tx4925ndfmc.c	2005-06-20 10:46:11.000000000 +0200
@@ -11,7 +11,7 @@
  * Derived from drivers/mtd/autcpu12.c
  *       Copyright (c) 2001 Thomas Gleixner (gleixner@autronix.de)
  *
- * $Id: tx4925ndfmc.c,v 1.3 2004/07/20 02:44:26 dwmw2 Exp $
+ * $Id: tx4925ndfmc.c,v 1.5 2004/10/05 13:50:20 gleixner Exp $
  *
  * Copyright (C) 2001 Toshiba Corporation 
  * 
@@ -340,8 +340,8 @@
 	tx4925ndfmc_mtd->priv = this;
 
 	/* Set address of NAND IO lines */
-	this->IO_ADDR_R = (unsigned long)&(tx4925_ndfmcptr->dtr);
-	this->IO_ADDR_W = (unsigned long)&(tx4925_ndfmcptr->dtr);
+	this->IO_ADDR_R = (void __iomem *)&(tx4925_ndfmcptr->dtr);
+	this->IO_ADDR_W = (void __iomem *)&(tx4925_ndfmcptr->dtr);
 	this->hwcontrol = tx4925ndfmc_hwcontrol;
 	this->enable_hwecc = tx4925ndfmc_enable_hwecc;
 	this->calculate_ecc = tx4925ndfmc_readecc;
@@ -363,14 +363,6 @@
 		goto out_ior;
 	}
 
-	/* Allocate memory for internal data buffer */
-	this->data_buf = kmalloc (sizeof(u_char) * (tx4925ndfmc_mtd->oobblock + tx4925ndfmc_mtd->oobsize), GFP_KERNEL);
-	if (!this->data_buf) {
-		printk ("Unable to allocate NAND data buffer for RBTX4925.\n");
-		err = -ENOMEM;
-		goto out_ior;
-	}
-
 	/* Register the partitions */
 #ifdef CONFIG_MTD_CMDLINE_PARTS
         {
@@ -391,14 +383,12 @@
 		default: {
 			printk ("Unsupported SmartMedia device\n"); 
 			err = -ENXIO;
-			goto out_buf;
+			goto out_ior;
 		}
 	}
 #endif /* ifdef CONFIG_MTD_CMDLINE_PARTS */
 	goto out;
 
-out_buf:
-	kfree (this->data_buf);    
 out_ior:
 out:
 	return err;
@@ -412,16 +402,8 @@
 #ifdef MODULE
 static void __exit tx4925ndfmc_cleanup (void)
 {
-	struct nand_chip *this = (struct nand_chip *) &tx4925ndfmc_mtd[1];
-
-	/* Unregister partitions */
-	del_mtd_partitions(tx4925ndfmc_mtd);
-	
-	/* Unregister the device */
-	del_mtd_device (tx4925ndfmc_mtd);
-
-	/* Free internal data buffers */
-	kfree (this->data_buf);
+	/* Release resources, unregister device */
+	nand_release (tx4925ndfmc_mtd);
 
 	/* Free the MTD device structure */
 	kfree (tx4925ndfmc_mtd);
diff -Naur linuxppc-2.6.9/drivers/mtd/nand/tx4938ndfmc.c linuxppc-2.6.9-dream/drivers/mtd/nand/tx4938ndfmc.c
--- linuxppc-2.6.9/drivers/mtd/nand/tx4938ndfmc.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nand/tx4938ndfmc.c	2005-06-20 10:46:11.000000000 +0200
@@ -10,7 +10,7 @@
  *
  * Based on spia.c by Steven J. Hill
  *
- * $Id: tx4938ndfmc.c,v 1.2 2004/03/27 19:55:53 gleixner Exp $
+ * $Id: tx4938ndfmc.c,v 1.4 2004/10/05 13:50:20 gleixner Exp $
  *
  * Copyright (C) 2000-2001 Toshiba Corporation 
  *
@@ -365,14 +365,6 @@
 		return -ENXIO;
 	}
 
-	/* Allocate memory for internal data buffer */
-	this->data_buf = kmalloc (sizeof(u_char) * (tx4938ndfmc_mtd->oobblock + tx4938ndfmc_mtd->oobsize), GFP_KERNEL);
-	if (!this->data_buf) {
-		printk ("Unable to allocate NAND data buffer for TX4938.\n");
-		kfree (tx4938ndfmc_mtd);
-		return -ENOMEM;
-	}
-
 	if (protected) {
 		printk(KERN_INFO "TX4938 NDFMC: write protected.\n");
 		tx4938ndfmc_mtd->flags &= ~(MTD_WRITEABLE | MTD_ERASEABLE);
@@ -401,19 +393,11 @@
  */
 static void __exit tx4938ndfmc_cleanup (void)
 {
-	struct nand_chip *this = (struct nand_chip *) tx4938ndfmc_mtd->priv;
-
-	/* Unregister the device */
-#ifdef CONFIG_MTD_CMDLINE_PARTS
-	del_mtd_partitions(tx4938ndfmc_mtd);
-#endif
-	del_mtd_device (tx4938ndfmc_mtd);
+	/* Release resources, unregister device */
+	nand_release (tx4938ndfmc_mtd);
 
 	/* Free the MTD device structure */
 	kfree (tx4938ndfmc_mtd);
-
-	/* Free internal data buffer */
-	kfree (this->data_buf);
 }
 module_exit(tx4938ndfmc_cleanup);
 
diff -Naur linuxppc-2.6.9/drivers/mtd/nftlcore.c linuxppc-2.6.9-dream/drivers/mtd/nftlcore.c
--- linuxppc-2.6.9/drivers/mtd/nftlcore.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nftlcore.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 /* Linux driver for NAND Flash Translation Layer      */
 /* (c) 1999 Machine Vision Holdings, Inc.             */
 /* Author: David Woodhouse <dwmw2@infradead.org>      */
-/* $Id: nftlcore.c,v 1.96 2004/06/28 13:52:55 dbrown Exp $ */
+/* $Id: nftlcore.c,v 1.97 2004/11/16 18:28:59 dwmw2 Exp $ */
 
 /*
   The contents of this file are distributed under the GNU General
@@ -421,7 +421,7 @@
 	return targetEUN;
 }
 
-u16 NFTL_makefreeblock( struct NFTLrecord *nftl , unsigned pendingblock)
+static u16 NFTL_makefreeblock( struct NFTLrecord *nftl , unsigned pendingblock)
 {
 	/* This is the part that needs some cleverness applied. 
 	   For now, I'm doing the minimum applicable to actually
@@ -731,7 +731,7 @@
  ****************************************************************************/
 
 
-struct mtd_blktrans_ops nftl_tr = {
+static struct mtd_blktrans_ops nftl_tr = {
 	.name		= "nftl",
 	.major		= NFTL_MAJOR,
 	.part_bits	= NFTL_PARTN_BITS,
@@ -747,9 +747,9 @@
 
 extern char nftlmountrev[];
 
-int __init init_nftl(void)
+static int __init init_nftl(void)
 {
-	printk(KERN_INFO "NFTL driver: nftlcore.c $Revision: 1.96 $, nftlmount.c %s\n", nftlmountrev);
+	printk(KERN_INFO "NFTL driver: nftlcore.c $Revision: 1.97 $, nftlmount.c %s\n", nftlmountrev);
 
 	return register_mtd_blktrans(&nftl_tr);
 }
diff -Naur linuxppc-2.6.9/drivers/mtd/nftlmount.c linuxppc-2.6.9-dream/drivers/mtd/nftlmount.c
--- linuxppc-2.6.9/drivers/mtd/nftlmount.c	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/nftlmount.c	2005-06-20 10:46:11.000000000 +0200
@@ -4,7 +4,7 @@
  * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
  * Copyright (C) 2000 Netgem S.A.
  *
- * $Id: nftlmount.c,v 1.36 2004/06/28 13:52:55 dbrown Exp $
+ * $Id: nftlmount.c,v 1.40 2004/11/22 14:38:29 kalev Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -31,7 +31,7 @@
 
 #define SECTORSIZE 512
 
-char nftlmountrev[]="$Revision: 1.36 $";
+char nftlmountrev[]="$Revision: 1.40 $";
 
 /* find_boot_record: Find the NFTL Media Header and its Spare copy which contains the
  *	various device information of the NFTL partition and Bad Unit Table. Update
@@ -41,7 +41,6 @@
 static int find_boot_record(struct NFTLrecord *nftl)
 {
 	struct nftl_uci1 h1;
-	struct nftl_oob oob;
 	unsigned int block, boot_record_count = 0;
 	size_t retlen;
 	u8 buf[SECTORSIZE];
@@ -319,6 +318,7 @@
 	memset(instr, 0, sizeof(struct erase_info));
 
 	/* XXX: use async erase interface, XXX: test return code */
+	instr->mtd = nftl->mbd.mtd;
 	instr->addr = block * nftl->EraseSize;
 	instr->len = nftl->EraseSize;
 	MTD_ERASE(nftl->mbd.mtd, instr);
diff -Naur linuxppc-2.6.9/drivers/mtd/redboot.c linuxppc-2.6.9-dream/drivers/mtd/redboot.c
--- linuxppc-2.6.9/drivers/mtd/redboot.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/mtd/redboot.c	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: redboot.c,v 1.15 2004/08/10 07:55:16 dwmw2 Exp $
+ * $Id: redboot.c,v 1.17 2004/11/22 11:33:56 ijc Exp $
  *
  * Parse RedBoot-style Flash Image System (FIS) tables and
  * produce a Linux partition array to match.
@@ -30,6 +30,9 @@
 	struct fis_list *next;
 };
 
+static int directory = CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK;
+module_param(directory, int, 0);
+
 static inline int redboot_checksum(struct fis_image_desc *img)
 {
 	/* RedBoot doesn't actually write the desc_cksum field yet AFAICT */
@@ -50,6 +53,8 @@
 	char *nullname;
 	int namelen = 0;
 	int nulllen = 0;
+	int numslots;
+	unsigned long offset;
 #ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
 	static char nullstring[] = "unallocated";
 #endif
@@ -59,8 +64,15 @@
 	if (!buf)
 		return -ENOMEM;
 
-	/* Read the start of the last erase block */
-	ret = master->read(master, master->size - master->erasesize,
+	if ( directory < 0 )
+		offset = master->size + directory*master->erasesize;
+	else
+		offset = directory*master->erasesize;
+
+	printk(KERN_NOTICE "Searching for RedBoot partition table in %s at offset 0x%lx\n",
+	       master->name, offset);
+
+	ret = master->read(master, offset,
 			   master->erasesize, &retlen, (void *)buf);
 
 	if (ret)
@@ -71,12 +83,16 @@
 		goto out;
 	}
 
-	/* RedBoot image could appear in any of the first three slots */
-	for (i = 0; i < 3; i++) {
-		if (!memcmp(buf[i].name, "RedBoot", 8))
+	numslots = (master->erasesize / sizeof(struct fis_image_desc));
+	for (i = 0; i < numslots; i++) {
+		if (buf[i].name[0] == 0xff) {
+			i = numslots;
+			break;
+		}
+		if (!memcmp(buf[i].name, "FIS directory", 14))
 			break;
 	}
-	if (i == 3) {
+	if (i == numslots) {
 		/* Didn't find it */
 		printk(KERN_NOTICE "No RedBoot partition table detected in %s\n",
 		       master->name);
@@ -84,7 +100,7 @@
 		goto out;
 	}
 
-	for (i = 0; i < master->erasesize / sizeof(struct fis_image_desc); i++) {
+	for (i = 0; i < numslots; i++) {
 		struct fis_list *new_fl, **prev;
 
 		if (buf[i].name[0] == 0xff)
diff -Naur linuxppc-2.6.9/drivers/net/8390.h linuxppc-2.6.9-dream/drivers/net/8390.h
--- linuxppc-2.6.9/drivers/net/8390.h	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/net/8390.h	2005-06-20 10:46:11.000000000 +0200
@@ -88,7 +88,7 @@
 #define E8390_RX_IRQ_MASK	0x5
 #define E8390_RXCONFIG		0x4	/* EN0_RXCR: broadcasts, no multicast,errors */
 #define E8390_RXOFF		0x20	/* EN0_RXCR: Accept no packets */
-#define E8390_TXCONFIG		0x00	/* EN0_TXCR: Normal transmit mode */
+#define E8390_TXCONFIG		0x80	/* EN0_TXCR: Normal transmit mode */
 #define E8390_TXOFF		0x02	/* EN0_TXCR: Transmitter off */
 
 /*  Register accessed at EN_CMD, the 8390 base addr.  */
@@ -135,6 +135,52 @@
 
 #elif defined(CONFIG_NET_CBUS) || defined(CONFIG_NE_H8300) || defined(CONFIG_NE_H8300_MODULE)
 #define EI_SHIFT(x)	(ei_local->reg_offset[x])
+#elif defined(CONFIG_DM7020)
+extern int shift_five;
+#define EI_SHIFT(x)	((x)<<(shift_five?5:1))
+#elif defined(CONFIG_DM56xx)
+#define EI_SHIFT(x)	(2 * (x))
+#undef inb
+#undef inb_p
+#undef insb
+#undef insw
+#undef outb
+#undef outb_p
+#undef outsb
+#undef outsw
+
+#define inb(port)		(inw((port)) >> 8)
+#define outb(val,port)		(outw((val) << 8, (port)))
+#define inb_p(port)		(inw((port)) >> 8)
+#define outb_p(val,port)	(outw((val) << 8, (port)))
+
+extern __inline__ void insb(volatile u8 *port, void *buf, int ns)
+{
+	int i;
+	for (i = 0; i < ns; i++)
+		((u8 *)buf)[i] = inb(port);
+}
+
+extern __inline__ void insw(volatile u16 *port, void *buf, int ns)
+{
+	int i;
+	for (i = 0; i < ns; i++)
+		((u16 *)buf)[i] = inw(port);
+}
+
+extern __inline__ void outsb(volatile u8 *port, const void *buf, int ns)
+{
+	int i;
+	for (i = 0; i < ns; i++)
+		outb(((const u8 *)buf)[i], port);
+}
+
+extern __inline__ void outsw(volatile u16 *port, const void *buf, int ns)
+{
+	int i;
+	for (i = 0; i < ns; i++)
+		outw(((const u16 *)buf)[i], port);
+}
 #else
 #define EI_SHIFT(x)	(x)
 #endif
diff -Naur linuxppc-2.6.9/drivers/net/asix_phyreset.c linuxppc-2.6.9-dream/drivers/net/asix_phyreset.c
--- linuxppc-2.6.9/drivers/net/asix_phyreset.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/net/asix_phyreset.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,161 @@
+#define MDIO_SHIFT_CLK  0x01
+#define MDIO_DIR_WRITE  0x02
+#define MDIO_DATA_WRITE0 (0x00)
+#define MDIO_DATA_WRITE1 (0x08)
+#define MDIO_DATA_READ  (0x04 | MDIO_DIR_WRITE)
+#define MDIO_ENB_IN   0x00
+
+#define NIC_BASE        0x72000600
+#define CR              NIC_BASE+ 0x00
+#define PBMASK          0xC0
+
+static void mdio_delay(void)
+{
+	short bla;
+	volatile unsigned short *nic=ioremap(0xf2000000, PAGE_SIZE);
+	bla = nic[0];
+	iounmap((void*)nic);
+}
+
+static void my_out16(unsigned long addr, unsigned short data)
+{
+	volatile unsigned char *nic=ioremap(0xf2000000, PAGE_SIZE * 16);
+	//unsigned long base = addr & 0xffff0000;
+  unsigned long reg = addr & 0xff;
+  //unsigned short newdata = (data >> 8) | ((data & 0xff) << 8);
+
+  reg <<= 5;
+
+  //unsigned long newaddr = base | reg;
+
+  //s1printf("out16(%x,%x)\n",newaddr,newdata);
+	nic[reg] = data;
+
+  //out16(newaddr,newdata);
+	iounmap((void*)nic);
+}
+
+static unsigned short my_in16(unsigned long addr)
+{
+	volatile unsigned char *nic=ioremap(0xf2000000, PAGE_SIZE * 16);
+ // unsigned long base = addr & 0xffff0000;
+  unsigned long reg = addr & 0xff;
+  unsigned short data;
+
+  reg <<= 5;
+
+  //unsigned long newaddr = base | reg;
+
+  //data = in16(newaddr);
+	data = nic[reg];
+
+	iounmap((void*)nic);
+
+  //s1printf("in16(%x) -> %x\n",newaddr,data);
+
+ // return (data >> 8) | ((data & 0xff) << 8);
+  return data;
+}
+
+static void write_nic(unsigned long reg_addr,
+            unsigned char value, unsigned char page)
+{
+
+   unsigned char        cr;
+
+//  reg_addr <<= 5;
+
+   //in8(NIC_DMA); /* add delay prior to each chip access */
+   cr=my_in16(CR);
+   if ((cr&PBMASK)!=page) {
+      cr&=0x3F;
+      //in8(NIC_DMA); /* add delay prior to each chip access */
+      (void)my_out16(CR, cr|page);
+   }
+   //in8(NIC_DMA); /* add delay prior to each chip access */
+   (void)my_out16(reg_addr, value);
+   return;
+}
+
+static void mdio_sync(int bits)
+{
+//  long mdio_addr = 0x72000628;
+  long mdio_addr = 0x72000014;
+
+  /* Establish sync by sending at least 32 logic ones. */
+  while (-- bits >= 0) {
+    write_nic(mdio_addr,MDIO_DATA_WRITE1, 0);
+    mdio_delay();
+    write_nic(mdio_addr,MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, 0);
+    mdio_delay();
+  }
+}
+
+static void mdio_write(int phy_id, int location, int value)
+{
+//  long ioaddr = 0x72000628;
+  long ioaddr = 0x72000014;
+  int write_cmd = 0x50020000 | (phy_id << 23) | (location << 18) | value;
+  long mdio_addr = ioaddr;
+  int i;
+
+  mdio_sync(32);
+
+  /* Shift the command bits out. */
+  for (i = 31; i >= 0; i--) {
+    int dataval = (write_cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;
+    write_nic(mdio_addr,dataval, 0);
+    mdio_delay();
+    write_nic(mdio_addr,dataval | MDIO_SHIFT_CLK, 0);
+    mdio_delay();
+  }
+  /* Leave the interface idle. */
+  for (i = 1; i >= 0; i--) {
+    write_nic(mdio_addr,MDIO_ENB_IN, 0);
+    mdio_delay();
+    write_nic(mdio_addr,MDIO_ENB_IN | MDIO_SHIFT_CLK,0);
+    mdio_delay();
+  }
+  return;
+}
+
+void asix_hardreset(void)
+{
+	volatile unsigned long *gpios = (unsigned long*) ioremap_nocache(0x40060000, PAGE_SIZE);
+	gpios[1] |= 0x80;
+	printk("[ASIX] reset network if...");
+	gpios[0] |= 0x80; // reset network if
+	udelay(100*1000);
+	gpios[0] &= ~0x80;
+	printk("ok\n");
+	iounmap(gpios);
+}
+
+int asix_phyreset(void)
+{
+	int i=0;
+	printk("[ASIX] reset phy...\n");
+	mdio_write(0x10, 0, 0x800);   //PHY powerdown
+
+	while(i++ < 1000)
+		udelay(2500);
+
+	mdio_write(0x10, 0, 0x1200);
+	printk("ok\n");
+
+//	printk("TCR: %08x\n",my_in16(0xD));
+//	printk("TR : %08x\n",my_in16(0x15));
+//	printk("GPI: %x\n",ne[0x17<<5]);
+
+	//for(i=0;i<1000;i++)
+	 // udelay(2500);
+
+	//ne[0x0D<<5] |= 0x80;
+
+//	printk("GPI: %x\n",ne[0x17<<5]);
+
+//	printk("[ASIX] done reset phy\n");
+
+	return 0;
+}
+
diff -Naur linuxppc-2.6.9/drivers/net/Kconfig linuxppc-2.6.9-dream/drivers/net/Kconfig
--- linuxppc-2.6.9/drivers/net/Kconfig	2005-10-01 14:12:17.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/net/Kconfig	2005-06-20 10:46:11.000000000 +0200
@@ -828,7 +828,7 @@
 	tristate "SMC 91C9x/91C1xxx support"
 	select CRC32
 	select MII
-	depends on NET_ETHERNET && (ARM || REDWOOD_5 || REDWOOD_6 || M32R)
+	depends on NET_ETHERNET && (ARM || REDWOOD_5 || REDWOOD_6 || DM7000 || M32R)
 	help
 	  This is a driver for SMC's 91x series of Ethernet chipsets,
 	  including the SMC91C94 and the SMC91C111. Say Y if you want it
@@ -1086,7 +1086,7 @@
 
 config NE2000
 	tristate "NE2000/NE1000 support"
-	depends on NET_ISA || (Q40 && m) || M32R
+	depends on NET_ISA || (Q40 && m) || DM56xx || DM7020 || M32R
 	select CRC32
 	---help---
 	  If you have a network (Ethernet) card of this type, say Y and read
diff -Naur linuxppc-2.6.9/drivers/net/ne.c linuxppc-2.6.9-dream/drivers/net/ne.c
--- linuxppc-2.6.9/drivers/net/ne.c	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/net/ne.c	2005-06-20 10:46:11.000000000 +0200
@@ -54,6 +54,8 @@
 #include <asm/system.h>
 #include <asm/io.h>
 
+#include <asm/ibm4xx.h>
+
 #include "8390.h"
 
 #define DRV_NAME "ne"
@@ -75,7 +77,7 @@
 /* A zero-terminated list of I/O addresses to be probed at boot. */
 #ifndef MODULE
 static unsigned int netcard_portlist[] __initdata = {
-	0x300, 0x280, 0x320, 0x340, 0x360, 0x380, 0
+/*	0x300, 0x280, 0x320, 0x340, 0x360, 0x380,*/ 0
 };
 #endif
 
@@ -119,11 +121,17 @@
 /* ---- No user-serviceable parts below ---- */
 
 #define NE_BASE	 (dev->base_addr)
+
 #define NE_CMD	 	0x00
+#if defined(CONFIG_DM56xx) || defined(CONFIG_DM7020)
+#define NE_DATAPORT	EI_SHIFT(0x10)	/* NatSemi-defined port window offset. */
+#define NE_RESET	EI_SHIFT(0x1f)	/* Issue a read to reset, a write to clear. */
+#define NE_IO_EXTENT	EI_SHIFT(0x20)
+#else
 #define NE_DATAPORT	0x10	/* NatSemi-defined port window offset. */
 #define NE_RESET	0x1f	/* Issue a read to reset, a write to clear. */
 #define NE_IO_EXTENT	0x20
-
+#endif
 #define NE1SM_START_PG	0x20	/* First page of TX buffer */
 #define NE1SM_STOP_PG 	0x40	/* Last page +1 of RX ring */
 #define NESM_START_PG	0x40	/* First page of TX buffer */
@@ -173,13 +181,37 @@
 	E2010	 starts at 0x100 and ends at 0x4000.
 	E2010-x starts at 0x100 and ends at 0xffff.  */
 
+static int first = 1;
+
+#if defined(CONFIG_DM7020)
+int shift_five=1;
+#endif
 static int __init do_ne_probe(struct net_device *dev)
 {
+#if defined(CONFIG_DM7020)
+	unsigned int base_addr = dev->base_addr = (unsigned int)ioremap(0xf2000000,4096);
+	__u8 *p = (__u8*)base_addr;
+	if (*p == 0xFF)
+	{
+		shift_five=0;
+		base_addr = dev->base_addr = (unsigned int)ioremap(0xf2000600,4096);
+	}
+#elif defined(CONFIG_DM56xx)
+	unsigned int base_addr = dev->base_addr = (unsigned int)ioremap(0xf2000600,4096);
+#else
 	unsigned int base_addr = dev->base_addr;
+#endif
+
 #ifndef MODULE
-	int orig_irq = dev->irq;
+	int orig_irq = dev->irq = 29;
 #endif
 
+	if(first)
+		first = 0;
+	else
+		return -1;
+			
+
 	SET_MODULE_OWNER(dev);
 
 	/* First check any supplied i/o locations. User knows best. <cough> */
@@ -192,6 +224,7 @@
 	if (isapnp_present() && (ne_probe_isapnp(dev) == 0))
 		return 0;
 
+#if 0
 #ifndef MODULE
 	/* Last resort. The semi-risky ISA auto-probe. */
 	for (base_addr = 0; netcard_portlist[base_addr] != 0; base_addr++) {
@@ -201,6 +234,7 @@
 			return 0;
 	}
 #endif
+#endif
 
 	return -ENODEV;
 }
@@ -286,6 +320,10 @@
 	return -ENODEV;
 }
 
+#if defined(CONFIG_DM7020)
+#include "asix_phyreset.c"
+#endif
+
 static int __init ne_probe1(struct net_device *dev, int ioaddr)
 {
 	int i;
@@ -296,7 +334,20 @@
 	int neX000, ctron, copam, bad_card;
 	int reg0, ret;
 	static unsigned version_printed;
+#if defined(CONFIG_DM56xx)
+	unsigned char dev_addr[6];
+#elif defined(CONFIG_DM7020)
+//	asix_hardware_reset();
+
+	if ( shift_five )
+//	mtdcr(0x82, 0x20188466);
+//	mtdcr(0x82, 0x2018856e);
+		mtdcr(0x82, 0x2038c328);
+//	mtdcr(0x82, 0x2038c576);
 
+//	asix_phyreset();
+#endif
+	
 	if (!request_region(ioaddr, NE_IO_EXTENT, DRV_NAME))
 		return -EBUSY;
 
@@ -310,13 +361,24 @@
 	{
 		int regd;
 		outb_p(E8390_NODMA+E8390_PAGE1+E8390_STOP, ioaddr + E8390_CMD);
+#if defined(CONFIG_DM56xx)
+		for (i = 0; i < ETHER_ADDR_LEN; i++)
+			dev_addr[i] = inb_p(ioaddr + EN1_PHYS_SHIFT(i));
+		regd = inb_p(ioaddr + EI_SHIFT(0x0d));
+		outb_p(0xff, ioaddr + EI_SHIFT(0x0d));
+#else
 		regd = inb_p(ioaddr + 0x0d);
 		outb_p(0xff, ioaddr + 0x0d);
+#endif
 		outb_p(E8390_NODMA+E8390_PAGE0, ioaddr + E8390_CMD);
 		inb_p(ioaddr + EN0_COUNTER0); /* Clear the counter by reading. */
 		if (inb_p(ioaddr + EN0_COUNTER0) != 0) {
 			outb_p(reg0, ioaddr);
+#if defined(CONFIG_DM56xx)
+			outb_p(regd, ioaddr + EI_SHIFT(0x0d));	/* Restore the old values. */
+#else
 			outb_p(regd, ioaddr + 0x0d);	/* Restore the old values. */
+#endif
 			ret = -ENODEV;
 			goto err_out;
 		}
@@ -337,6 +399,8 @@
 
 	/* Reset card. Who knows what dain-bramaged state it was left in. */
 
+	outb_p(E8390_NODMA+E8390_PAGE0, ioaddr + E8390_CMD);
+
 	{
 		unsigned long reset_start_time = jiffies;
 
@@ -350,8 +414,7 @@
 				break;
 			} else {
 				printk(" not found (no reset ack).\n");
-				ret = -ENODEV;
-				goto err_out;
+				break;
 			}
 		}
 
@@ -425,6 +488,7 @@
 	}
 	else
 	{
+#if 0	
 #ifdef SUPPORT_NE_BAD_CLONES
 		/* Ack!  Well, there might be a *bad* NE*000 clone there.
 		   Check for total bogus addresses. */
@@ -455,7 +519,32 @@
 		ret = -ENXIO;
 		goto err_out;
 #endif
+#endif
+	}
+
+#if defined(CONFIG_DM56xx)
+	dev->irq = 25;
+	mtdcr(0x44, mfdcr(0x44) | 0x40);
+
+	if ( !(dev_addr[0] + dev_addr[1] + dev_addr[2] + dev_addr[3] + dev_addr[4] + dev_addr[5]) )
+	{
+		unsigned char *hw_addr=(unsigned char*) ioremap(0x7fffffc0,PAGE_SIZE);
+		if ( hw_addr[0] == 0xCA ) // DM500
+		{
+			mtdcr(0x82,0xFF00BFFE);
+			memcpy(dev_addr, hw_addr+7, 6);
+			iounmap((void*)hw_addr);
+		}
+		else
+		{
+			mtdcr(0x82,0x2038DA0C);
+			iounmap((void*)hw_addr);
+    			hw_addr=(unsigned char*) ioremap(0xa0006600,PAGE_SIZE);
+			memcpy(dev_addr, hw_addr, 6);
+			iounmap((void*)hw_addr);
+		}
 	}
+#endif
 
 	if (dev->irq < 2)
 	{
@@ -480,6 +569,20 @@
 		goto err_out;
 	}
 
+#if defined(CONFIG_DM7020)
+	{
+		unsigned long sr;
+		
+		sr = mfdcr(0x44);
+		sr |= 0x4;
+		mtdcr(0x44,sr);
+		
+		sr = mfdcr(0x45);
+		sr |= 0x04;
+		mtdcr(0x45, sr);
+	}
+#endif
+
 	/* Snarf the interrupt now.  There's no point in waiting since we cannot
 	   share and the board will usually be enabled. */
 	ret = request_irq(dev->irq, ei_interrupt, 0, name, dev);
@@ -498,12 +601,20 @@
 			= inb_p(ioaddr + EN1_PHYS_SHIFT(i));
 		printk(" %2.2x", SA_prom[i]);
 	}
+#elif defined(CONFIG_DM56xx)
+	for(i = 0; i < ETHER_ADDR_LEN; i++) {
+		printk(" %2.2x", dev_addr[i]);
+		dev->dev_addr[i] = dev_addr[i];
+	}
 #else
 	for(i = 0; i < ETHER_ADDR_LEN; i++) {
 		printk(" %2.2x", SA_prom[i]);
 		dev->dev_addr[i] = SA_prom[i];
 	}
 #endif
+	
+	bd_t *bip = (bd_t *) &__res;
+	memcpy(dev->dev_addr, bip->bi_enetaddr, 6);
 
 	printk("\n%s: %s found at %#x, using IRQ %d.\n",
 		dev->name, name, ioaddr, dev->irq);
@@ -645,16 +756,46 @@
 	outb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);
 	outb_p(ring_offset >> 8, nic_base + EN0_RSARHI);
 	outb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);
-	if (ei_status.word16)
+	if (ei_status.word16) 
 	{
-		insw(NE_BASE + NE_DATAPORT,buf,count>>1);
-		if (count & 0x01)
+#if defined(CONFIG_DM7020)
+		if ( !shift_five )
+#endif
 		{
-			buf[count-1] = inb(NE_BASE + NE_DATAPORT);
+			insw(NE_BASE + NE_DATAPORT,buf,count>>1);
+			if (count & 0x01)
+			{
+				buf[count-1] = inb(NE_BASE + NE_DATAPORT);
 #ifdef NE_SANITY_CHECK
-			xfer_count++;
+				xfer_count++;
 #endif
+			}
 		}
+#if defined(CONFIG_DM7020)
+		else
+		{
+#if 0
+			static void *dmamem;
+		
+			if (!dmamem)
+				dmamem = ioremap_nocache(0x3F00000, 4096);
+
+			mtdcr(0x31, 0);
+			mtdcr(0x32, 0x00800000);
+			mtdcr(0xC2, 0x3F00000);
+			mtdcr(0xC3, 0x72000000 + NE_DATAPORT);
+			mtdcr(0xC0, 0xAEC84F13);
+			mtdcr(0xC1, (count + 15) >> 4);
+			while (mfdcr(0x0c0) & 0x80000000);
+			if (!(mfdcr(0xe0) & 0x80000000))
+				panic("stb_dma status: %08x\n", mfdcr(0xe0));
+			mtdcr(0xe0, 0x88888888); // clear all bits
+			memcpy(buf, dmamem, count);
+#else
+			fast_insline(NE_BASE + NE_DATAPORT, buf, (count+15)>>4);
+#endif
+		}
+#endif
 	} else {
 		insb(NE_BASE + NE_DATAPORT, buf, count);
 	}
@@ -745,7 +886,16 @@
 
 	outb_p(E8390_RWRITE+E8390_START, nic_base + NE_CMD);
 	if (ei_status.word16) {
-		outsw(NE_BASE + NE_DATAPORT, buf, count>>1);
+#if defined(CONFIG_DM7020)
+		if (shift_five)
+		{
+			fast_outsl(NE_BASE + NE_DATAPORT, buf, count >> 2);
+			buf += count & ~3;
+			count &= 3;
+		}
+#endif
+		if ( count >= 2)
+			outsw(NE_BASE + NE_DATAPORT, buf, count >> 1);
 	} else {
 		outsb(NE_BASE + NE_DATAPORT, buf, count);
 	}
diff -Naur linuxppc-2.6.9/drivers/net/smc91x.c linuxppc-2.6.9-dream/drivers/net/smc91x.c
--- linuxppc-2.6.9/drivers/net/smc91x.c	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/net/smc91x.c	2005-06-20 10:46:11.000000000 +0200
@@ -55,12 +55,10 @@
  *                                  smc_phy_configure
  *                                - clean up (and fix stack overrun) in PHY
  *                                  MII read/write functions
- *   09/15/04  Hayato Fujiwara    - Add m32r support.
- *                                - Modify for SMP kernel; Change spin-locked
- *                                  regions.
+ *   22/09/04  Nicolas Pitre      big update (see commit log for details)
  */
 static const char version[] =
-	"smc91x.c: v1.0, mar 07 2003 by Nicolas Pitre <nico@cam.org>\n";
+	"smc91x.c: v1.1, sep 22 2004 by Nicolas Pitre <nico@cam.org>\n";
 
 /* Debugging level */
 #ifndef SMC_DEBUG
@@ -75,7 +73,7 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
-#include <linux/timer.h>
+#include <linux/interrupt.h>
 #include <linux/errno.h>
 #include <linux/ioport.h>
 #include <linux/crc32.h>
@@ -83,6 +81,7 @@
 #include <linux/spinlock.h>
 #include <linux/ethtool.h>
 #include <linux/mii.h>
+#include <linux/workqueue.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -177,7 +176,8 @@
 	 * packet, I will store the skbuff here, until I get the
 	 * desired memory.  Then, I'll send it out and free it.
 	 */
-	struct sk_buff *saved_skb;
+	struct sk_buff *pending_tx_skb;
+	struct tasklet_struct tx_task;
 
  	/*
 	 * these are things that the kernel wants me to keep, so users
@@ -203,6 +203,8 @@
 	u32	msg_enable;
 	u32	phy_type;
 	struct mii_if_info mii;
+	struct work_struct phy_configure;
+
 	spinlock_t lock;
 
 #ifdef SMC_USE_PXA_DMA
@@ -215,7 +217,7 @@
 #define DBG(n, args...)					\
 	do {						\
 		if (SMC_DEBUG >= (n))			\
-			printk(KERN_DEBUG args);	\
+			printk(args);	\
 	} while (0)
 
 #define PRINTK(args...)   printk(args)
@@ -260,17 +262,21 @@
 /* this enables an interrupt in the interrupt mask register */
 #define SMC_ENABLE_INT(x) do {						\
 	unsigned char mask;						\
+	spin_lock_irq(&lp->lock);					\
 	mask = SMC_GET_INT_MASK();					\
 	mask |= (x);							\
 	SMC_SET_INT_MASK(mask);						\
+	spin_unlock_irq(&lp->lock);					\
 } while (0)
 
 /* this disables an interrupt from the interrupt mask register */
 #define SMC_DISABLE_INT(x) do {						\
 	unsigned char mask;						\
+	spin_lock_irq(&lp->lock);					\
 	mask = SMC_GET_INT_MASK();					\
 	mask &= ~(x);							\
 	SMC_SET_INT_MASK(mask);						\
+	spin_unlock_irq(&lp->lock);					\
 } while (0)
 
 /*
@@ -299,10 +305,17 @@
 static void smc_reset(struct net_device *dev)
 {
 	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = netdev_priv(dev);
 	unsigned int ctl, cfg;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
+	/* Disable all interrupts */
+	spin_lock(&lp->lock);
+	SMC_SELECT_BANK(2);
+	SMC_SET_INT_MASK(0);
+	spin_unlock(&lp->lock);
+
 	/*
 	 * This resets the registers mostly to defaults, but doesn't
 	 * affect EEPROM.  That seems unnecessary
@@ -358,20 +371,24 @@
 	 * transmitted packets, to make the best use out of our limited
 	 * memory
 	 */
-#if ! THROTTLE_TX_PKTS
-	ctl |= CTL_AUTO_RELEASE;
-#else
-	ctl &= ~CTL_AUTO_RELEASE;
-#endif
+	if(!THROTTLE_TX_PKTS)
+		ctl |= CTL_AUTO_RELEASE;
+	else
+		ctl &= ~CTL_AUTO_RELEASE;
 	SMC_SET_CTL(ctl);
 
-	/* Disable all interrupts */
-	SMC_SELECT_BANK(2);
-	SMC_SET_INT_MASK(0);
-
 	/* Reset the MMU */
+	SMC_SELECT_BANK(2);
 	SMC_SET_MMU_CMD(MC_RESET);
 	SMC_WAIT_MMU_BUSY();
+
+	/* clear anything saved */
+	if (lp->pending_tx_skb != NULL) {
+		dev_kfree_skb (lp->pending_tx_skb);
+		lp->pending_tx_skb = NULL;
+		lp->stats.tx_errors++;
+		lp->stats.tx_aborted_errors++;
+	}
 }
 
 /*
@@ -390,24 +407,39 @@
 	SMC_SET_TCR(lp->tcr_cur_mode);
 	SMC_SET_RCR(lp->rcr_cur_mode);
 
+	SMC_SELECT_BANK(1);
+	SMC_SET_MAC_ADDR(dev->dev_addr);
+
 	/* now, enable interrupts */
 	mask = IM_EPH_INT|IM_RX_OVRN_INT|IM_RCV_INT;
 	if (lp->version >= (CHIP_91100 << 4))
 		mask |= IM_MDINT;
 	SMC_SELECT_BANK(2);
 	SMC_SET_INT_MASK(mask);
+
+	/*
+	 * From this point the register bank must _NOT_ be switched away
+	 * to something else than bank 2 without proper locking against
+	 * races with any tasklet or interrupt handlers until smc_shutdown()
+	 * or smc_reset() is called.
+	 */
 }
 
 /*
  * this puts the device in an inactive state
  */
-static void smc_shutdown(unsigned long ioaddr)
+static void smc_shutdown(struct net_device *dev)
 {
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = netdev_priv(dev);
+
 	DBG(2, "%s: %s\n", CARDNAME, __FUNCTION__);
 
 	/* no more interrupts for me */
+	spin_lock(&lp->lock);
 	SMC_SELECT_BANK(2);
 	SMC_SET_INT_MASK(0);
+	spin_unlock(&lp->lock);
 
 	/* and tell the card to stay away from that nasty outside world */
 	SMC_SELECT_BANK(0);
@@ -440,6 +472,7 @@
 
 	/* read from start of packet */
 	SMC_SET_PTR(PTR_READ | PTR_RCV | PTR_AUTOINC);
+	udelay(1);
 
 	/* First two words are status and packet length */
 	SMC_GET_PKT_HDR(status, packet_len);
@@ -449,6 +482,8 @@
 		packet_len, packet_len);
 
 	if (unlikely(status & RS_ERRORS)) {
+		SMC_WAIT_MMU_BUSY();
+		SMC_SET_MMU_CMD(MC_RELEASE);
 		lp->stats.rx_errors++;
 		if (status & RS_ALGNERR)
 			lp->stats.rx_frame_errors++;
@@ -466,17 +501,21 @@
 			lp->stats.multicast++;
 
 		/*
-		 * Actual payload is packet_len - 4 (or 3 if odd byte).
+		 * Actual payload is packet_len - 6 (or 5 if odd byte).
 		 * We want skb_reserve(2) and the final ctrl word
 		 * (2 bytes, possibly containing the payload odd byte).
-		 * Ence packet_len - 4 + 2 + 2.
+		 * Furthermore, we add 2 bytes to allow rounding up to
+		 * multiple of 4 bytes on 32 bit buses.
+		 * Ence packet_len - 6 + 2 + 2 + 2.
 		 */
 		skb = dev_alloc_skb(packet_len);
 		if (unlikely(skb == NULL)) {
 			printk(KERN_NOTICE "%s: Low memory, packet dropped.\n",
 				dev->name);
+			SMC_WAIT_MMU_BUSY();
+			SMC_SET_MMU_CMD(MC_RELEASE);
 			lp->stats.rx_dropped++;
-			goto done;
+			return;
 		}
 
 		/* Align IP header to 32 bits */
@@ -487,14 +526,18 @@
 			status |= RS_ODDFRAME;
 
 		/*
-		 * If odd length: packet_len - 3,
-		 * otherwise packet_len - 4.
+		 * If odd length: packet_len - 5,
+		 * otherwise packet_len - 6.
+		 * With the trailing ctrl byte it's packet_len - 4.
 		 */
-		data_len = packet_len - ((status & RS_ODDFRAME) ? 3 : 4);
+		data_len = packet_len - ((status & RS_ODDFRAME) ? 5 : 6);
 		data = skb_put(skb, data_len);
-		SMC_PULL_DATA(data, packet_len - 2);
+		SMC_PULL_DATA(data, packet_len - 4);
+
+		SMC_WAIT_MMU_BUSY();
+		SMC_SET_MMU_CMD(MC_RELEASE);
 
-		PRINT_PKT(data, packet_len - 2);
+		PRINT_PKT(data, packet_len - 4);
 
 		dev->last_rx = jiffies;
 		skb->dev = dev;
@@ -503,34 +546,76 @@
 		lp->stats.rx_packets++;
 		lp->stats.rx_bytes += data_len;
 	}
-
-done:
-	SMC_WAIT_MMU_BUSY();
-	SMC_SET_MMU_CMD(MC_RELEASE);
 }
 
+#ifdef CONFIG_SMP
+/*
+ * On SMP we have the following problem:
+ *
+ * 	A = smc_hardware_send_pkt()
+ * 	B = smc_hard_start_xmit()
+ * 	C = smc_interrupt()
+ *
+ * A and B can never be executed simultaneously.  However, at least on UP,
+ * it is possible (and even desirable) for C to interrupt execution of
+ * A or B in order to have better RX reliability and avoid overruns.
+ * C, just like A and B, must have exclusive access to the chip and
+ * each of them must lock against any other concurrent access.
+ * Unfortunately this is not possible to have C suspend execution of A or
+ * B taking place on another CPU. On UP this is no an issue since A and B
+ * are run from softirq context and C from hard IRQ context, and there is
+ * no other CPU where concurrent access can happen.
+ * If ever there is a way to force at least B and C to always be executed
+ * on the same CPU then we could use read/write locks to protect against
+ * any other concurrent access and C would always interrupt B. But life
+ * isn't that easy in a SMP world...
+ */
+#define smc_special_trylock(lock)					\
+({									\
+	int __ret;							\
+	local_irq_disable();						\
+	__ret = spin_trylock(lock);					\
+	if (!__ret)							\
+		local_irq_enable();					\
+	__ret;								\
+})
+#define smc_special_lock(lock)		spin_lock_irq(lock)
+#define smc_special_unlock(lock)	spin_unlock_irq(lock)
+#else
+#define smc_special_trylock(lock)	(1)
+#define smc_special_lock(lock)		do { } while (0)
+#define smc_special_unlock(lock)	do { } while (0)
+#endif
+
 /*
  * This is called to actually send a packet to the chip.
- * Returns non-zero when successful.
  */
-static void smc_hardware_send_packet(struct net_device *dev)
+static void smc_hardware_send_pkt(unsigned long data)
 {
+	struct net_device *dev = (struct net_device *)data;
 	struct smc_local *lp = netdev_priv(dev);
 	unsigned long ioaddr = dev->base_addr;
-	struct sk_buff *skb = lp->saved_skb;
+	struct sk_buff *skb;
 	unsigned int packet_no, len;
 	unsigned char *buf;
 
 	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
 
+	if (!smc_special_trylock(&lp->lock)) {
+		netif_stop_queue(dev);
+		tasklet_schedule(&lp->tx_task);
+		return;
+	}
+
+	skb = lp->pending_tx_skb;
+	lp->pending_tx_skb = NULL;
 	packet_no = SMC_GET_AR();
 	if (unlikely(packet_no & AR_FAILED)) {
 		printk("%s: Memory allocation failed.\n", dev->name);
-		lp->saved_skb = NULL;
 		lp->stats.tx_errors++;
 		lp->stats.tx_fifo_errors++;
-		dev_kfree_skb_any(skb);
-		return;
+		smc_special_unlock(&lp->lock);
+		goto done;
 	}
 
 	/* point to the beginning of the packet */
@@ -555,15 +640,33 @@
 	/* Send final ctl word with the last byte if there is one */
 	SMC_outw(((len & 1) ? (0x2000 | buf[len-1]) : 0), ioaddr, DATA_REG);
 
-	/* and let the chipset deal with it */
+	/*
+	 * If THROTTLE_TX_PKTS is set, we look at the TX_EMPTY flag
+	 * before queueing this packet for TX, and if it's clear then
+	 * we stop the queue here.  This will have the effect of
+	 * having at most 2 packets queued for TX in the chip's memory
+	 * at all time. If THROTTLE_TX_PKTS is not set then the queue
+	 * is stopped only when memory allocation (MC_ALLOC) does not
+	 * succeed right away.
+	 */
+	if (THROTTLE_TX_PKTS && !(SMC_GET_INT() & IM_TX_EMPTY_INT))
+		netif_stop_queue(dev);
+
+	/* queue the packet for TX */
 	SMC_SET_MMU_CMD(MC_ENQUEUE);
 	SMC_ACK_INT(IM_TX_EMPTY_INT);
+	smc_special_unlock(&lp->lock);
 
 	dev->trans_start = jiffies;
-	dev_kfree_skb_any(skb);
-	lp->saved_skb = NULL;
 	lp->stats.tx_packets++;
 	lp->stats.tx_bytes += len;
+
+	SMC_ENABLE_INT(IM_TX_INT | IM_TX_EMPTY_INT);
+
+done:	if (!THROTTLE_TX_PKTS)
+		netif_wake_queue(dev);
+
+	dev_kfree_skb(skb);
 }
 
 /*
@@ -576,15 +679,12 @@
 {
 	struct smc_local *lp = netdev_priv(dev);
 	unsigned long ioaddr = dev->base_addr;
-	unsigned int numPages, poll_count, status, saved_bank;
-	unsigned long flags;
+	unsigned int numPages, poll_count, status;
 
 	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
 
-	spin_lock_irqsave(&lp->lock, flags);
-
-	BUG_ON(lp->saved_skb != NULL);
-	lp->saved_skb = skb;
+	BUG_ON(lp->pending_tx_skb != NULL);
+	lp->pending_tx_skb = skb;
 
 	/*
 	 * The MMU wants the number of pages to be the number of 256 bytes
@@ -600,17 +700,16 @@
 	numPages = ((skb->len & ~1) + (6 - 1)) >> 8;
 	if (unlikely(numPages > 7)) {
 		printk("%s: Far too big packet error.\n", dev->name);
-		lp->saved_skb = NULL;
+		lp->pending_tx_skb = NULL;
 		lp->stats.tx_errors++;
 		lp->stats.tx_dropped++;
 		dev_kfree_skb(skb);
-		spin_unlock_irqrestore(&lp->lock, flags);
 		return 0;
 	}
 
+	smc_special_lock(&lp->lock);
+
 	/* now, try to allocate the memory */
-	saved_bank = SMC_CURRENT_BANK();
-	SMC_SELECT_BANK(2);
 	SMC_SET_MMU_CMD(MC_ALLOC | numPages);
 
 	/*
@@ -626,6 +725,8 @@
 		}
    	} while (--poll_count);
 
+	smc_special_unlock(&lp->lock);
+
    	if (!poll_count) {
 		/* oh well, wait until the chip finds memory later */
 		netif_stop_queue(dev);
@@ -635,25 +736,10 @@
 		/*
 		 * Allocation succeeded: push packet to the chip's own memory
 		 * immediately.
-		 *
-		 * If THROTTLE_TX_PKTS is selected that means we don't want
-		 * more than a single TX packet taking up space in the chip's
-		 * internal memory at all time, in which case we stop the
-		 * queue right here until we're notified of TX completion.
-		 *
-		 * Otherwise we're quite happy to feed more TX packets right
-		 * away for better TX throughput, in which case the queue is
-		 * left active.
 		 */  
-#if THROTTLE_TX_PKTS
-		netif_stop_queue(dev);
-#endif
-		smc_hardware_send_packet(dev);
-		SMC_ENABLE_INT(IM_TX_INT | IM_TX_EMPTY_INT);
+		smc_hardware_send_pkt((unsigned long)dev);
 	}
 
-	SMC_SELECT_BANK(saved_bank);
-	spin_unlock_irqrestore(&lp->lock, flags);
 	return 0;
 }
 
@@ -767,10 +853,8 @@
 static int smc_phy_read(struct net_device *dev, int phyaddr, int phyreg)
 {
 	unsigned long ioaddr = dev->base_addr;
-	unsigned int phydata, old_bank;
+	unsigned int phydata;
 
-	/* Save the current bank, and select bank 3 */
-	old_bank = SMC_CURRENT_BANK();
 	SMC_SELECT_BANK(3);
 
 	/* Idle - 32 ones */
@@ -786,7 +870,7 @@
 	SMC_SET_MII(SMC_GET_MII() & ~(MII_MCLK|MII_MDOE|MII_MDO));
 
 	/* And select original bank */
-	SMC_SELECT_BANK(old_bank);
+	SMC_SELECT_BANK(2);
 
 	DBG(3, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",
 		__FUNCTION__, phyaddr, phyreg, phydata);
@@ -801,10 +885,7 @@
 			  int phydata)
 {
 	unsigned long ioaddr = dev->base_addr;
-	unsigned int old_bank;
 
-	/* Save the current bank, and select bank 3 */
-	old_bank = SMC_CURRENT_BANK();
 	SMC_SELECT_BANK(3);
 
 	/* Idle - 32 ones */
@@ -817,7 +898,7 @@
 	SMC_SET_MII(SMC_GET_MII() & ~(MII_MCLK|MII_MDOE|MII_MDO));
 
 	/* And select original bank */
-	SMC_SELECT_BANK(old_bank);
+	SMC_SELECT_BANK(2);
 
 	DBG(3, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",
 		__FUNCTION__, phyaddr, phyreg, phydata);
@@ -893,7 +974,9 @@
 	smc_phy_write(dev, phyaddr, MII_BMCR, bmcr);
 
 	/* Re-Configure the Receive/Phy Control register */
+	SMC_SELECT_BANK(0);
 	SMC_SET_RPC(lp->rpc_cur_mode);
+	SMC_SELECT_BANK(2);
 
 	return 1;
 }
@@ -941,13 +1024,10 @@
  */
 static void smc_phy_powerdown(struct net_device *dev, int phy)
 {
-	struct smc_local *lp = netdev_priv(dev);
 	unsigned int bmcr;
 
-	spin_lock_irq(&lp->lock);
 	bmcr = smc_phy_read(dev, phy, MII_BMCR);
 	smc_phy_write(dev, phy, MII_BMCR, bmcr | BMCR_PDOWN);
-	spin_unlock_irq(&lp->lock);
 }
 
 /*
@@ -964,8 +1044,6 @@
 	unsigned long ioaddr = dev->base_addr;
 
 	if (mii_check_media(&lp->mii, netif_msg_link(lp), init)) {
-		unsigned int old_bank;
-
 		/* duplex state has changed */
 		if (lp->mii.full_duplex) {
 			lp->tcr_cur_mode |= TCR_SWFDUP;
@@ -973,10 +1051,8 @@
 			lp->tcr_cur_mode &= ~TCR_SWFDUP;
 		}
 
-		old_bank = SMC_CURRENT_BANK();
 		SMC_SELECT_BANK(0);
 		SMC_SET_TCR(lp->tcr_cur_mode);
-		SMC_SELECT_BANK(old_bank);
 	}
 }
 
@@ -989,8 +1065,9 @@
  * of autonegotiation.)  If the RPC ANEG bit is cleared, the selection
  * is controlled by the RPC SPEED and RPC DPLX bits.
  */
-static void smc_phy_configure(struct net_device *dev)
+static void smc_phy_configure(void *data)
 {
+	struct net_device *dev = data;
 	struct smc_local *lp = netdev_priv(dev);
 	unsigned long ioaddr = dev->base_addr;
 	int phyaddr = lp->mii.phy_id;
@@ -1117,12 +1194,13 @@
 {
 	struct smc_local *lp = netdev_priv(dev);
 	unsigned long ioaddr = dev->base_addr;
-	unsigned int old_carrier, new_carrier, old_bank;
+	unsigned int old_carrier, new_carrier;
 
-	old_bank = SMC_CURRENT_BANK();
-	SMC_SELECT_BANK(0);
 	old_carrier = netif_carrier_ok(dev) ? 1 : 0;
+
+	SMC_SELECT_BANK(0);
 	new_carrier = SMC_inw(ioaddr, EPH_STATUS_REG) & ES_LINK_OK ? 1 : 0;
+	SMC_SELECT_BANK(2);
 
 	if (init || (old_carrier != new_carrier)) {
 		if (!new_carrier) {
@@ -1134,24 +1212,20 @@
 			printk(KERN_INFO "%s: link %s\n", dev->name,
 			       new_carrier ? "up" : "down");
 	}
-	SMC_SELECT_BANK(old_bank);
 }
 
 static void smc_eph_interrupt(struct net_device *dev)
 {
 	unsigned long ioaddr = dev->base_addr;
-	unsigned int old_bank, ctl;
+	unsigned int ctl;
 
 	smc_10bt_check_media(dev, 0);
 
-	old_bank = SMC_CURRENT_BANK();
 	SMC_SELECT_BANK(1);
-
 	ctl = SMC_GET_CTL();
 	SMC_SET_CTL(ctl & ~CTL_LE_ENABLE);
 	SMC_SET_CTL(ctl);
-
-	SMC_SELECT_BANK(old_bank);
+	SMC_SELECT_BANK(2);
 }
 
 /*
@@ -1164,14 +1238,12 @@
 	unsigned long ioaddr = dev->base_addr;
 	struct smc_local *lp = netdev_priv(dev);
 	int status, mask, timeout, card_stats;
-	int saved_bank, saved_pointer;
+	int saved_pointer;
 
 	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
 
 	spin_lock(&lp->lock);
 
-	saved_bank = SMC_CURRENT_BANK();
-	SMC_SELECT_BANK(2);
 	saved_pointer = SMC_GET_PTR();
 	mask = SMC_GET_INT_MASK();
 	SMC_SET_INT_MASK(0);
@@ -1182,7 +1254,7 @@
 	do {
 		status = SMC_GET_INT();
 
-		DBG(2, "%s: IRQ 0x%02x MASK 0x%02x MEM 0x%04x FIFO 0x%04x\n",
+		DBG(2, "%s: INT 0x%02x MASK 0x%02x MEM 0x%04x FIFO 0x%04x\n",
 			dev->name, status, mask,
 			({ int meminfo; SMC_SELECT_BANK(0);
 			   meminfo = SMC_GET_MIR();
@@ -1200,17 +1272,12 @@
 			DBG(3, "%s: TX int\n", dev->name);
 			smc_tx(dev);
 			SMC_ACK_INT(IM_TX_INT);
-#if THROTTLE_TX_PKTS
-			netif_wake_queue(dev);
-#endif
+			if (THROTTLE_TX_PKTS)
+				netif_wake_queue(dev);
 		} else if (status & IM_ALLOC_INT) {
 			DBG(3, "%s: Allocation irq\n", dev->name);
-			smc_hardware_send_packet(dev);
-			mask |= (IM_TX_INT | IM_TX_EMPTY_INT);
+			tasklet_hi_schedule(&lp->tx_task);
 			mask &= ~IM_ALLOC_INT;
-#if ! THROTTLE_TX_PKTS
-			netif_wake_queue(dev);
-#endif
 		} else if (status & IM_TX_EMPTY_INT) {
 			DBG(3, "%s: TX empty\n", dev->name);
 			mask &= ~IM_TX_EMPTY_INT;
@@ -1240,17 +1307,16 @@
 			SMC_ACK_INT(IM_ERCV_INT);
 			PRINTK("%s: UNSUPPORTED: ERCV INTERRUPT \n", dev->name);
 		}
-
 	} while (--timeout);
 
 	/* restore register states */
-	SMC_SET_INT_MASK(mask);
 	SMC_SET_PTR(saved_pointer);
-	SMC_SELECT_BANK(saved_bank);
+	SMC_SET_INT_MASK(mask);
+
+	spin_unlock(&lp->lock);
 
 	DBG(3, "%s: Interrupt done (%d loops)\n", dev->name, 8-timeout);
 
-	spin_unlock(&lp->lock);
 	/*
 	 * We return IRQ_HANDLED unconditionally here even if there was
 	 * nothing to do.  There is a possibility that a packet might
@@ -1266,101 +1332,39 @@
 static void smc_timeout(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
-	unsigned long flags;
+	unsigned long ioaddr = dev->base_addr;
+	int status, mask, meminfo, fifo;
 
-	spin_lock_irqsave(&lp->lock, flags);
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
+	spin_lock_irq(&lp->lock);
+	status = SMC_GET_INT();
+	mask = SMC_GET_INT_MASK();
+	fifo = SMC_GET_FIFO();
+	SMC_SELECT_BANK(0);
+	meminfo = SMC_GET_MIR();
+	SMC_SELECT_BANK(2);
+	spin_unlock_irq(&lp->lock);
+	PRINTK( "%s: INT 0x%02x MASK 0x%02x MEM 0x%04x FIFO 0x%04x\n",
+		dev->name, status, mask, meminfo, fifo );
+
 	smc_reset(dev);
 	smc_enable(dev);
 
-#if 0
 	/*
 	 * Reconfiguring the PHY doesn't seem like a bad idea here, but
-	 * it introduced a problem.  Now that this is a timeout routine,
-	 * we are getting called from within an interrupt context.
-	 * smc_phy_configure() calls msleep() which calls
-	 * schedule_timeout() which calls schedule().  When schedule()
-	 * is called from an interrupt context, it prints out
-	 * "Scheduling in interrupt" and then calls BUG().  This is
-	 * obviously not desirable.  This was worked around by removing
-	 * the call to smc_phy_configure() here because it didn't seem
-	 * absolutely necessary.  Ultimately, if msleep() is
-	 * supposed to be usable from an interrupt context (which it
-	 * looks like it thinks it should handle), it should be fixed.
+	 * smc_phy_configure() calls msleep() which calls schedule_timeout()
+	 * which calls schedule().  Ence we use a work queue.
 	 */
 	if (lp->phy_type != 0)
-		smc_phy_configure(dev);
-#endif
+		schedule_work(&lp->phy_configure);
 
-	/* clear anything saved */
-	if (lp->saved_skb != NULL) {
-		dev_kfree_skb (lp->saved_skb);
-		lp->saved_skb = NULL;
-		lp->stats.tx_errors++;
-		lp->stats.tx_aborted_errors++;
-	}
 	/* We can accept TX packets again */
 	dev->trans_start = jiffies;
-
-	spin_unlock_irqrestore(&lp->lock, flags);
-
 	netif_wake_queue(dev);
 }
 
 /*
- *    This sets the internal hardware table to filter out unwanted multicast
- *    packets before they take up memory.
- *
- *    The SMC chip uses a hash table where the high 6 bits of the CRC of
- *    address are the offset into the table.  If that bit is 1, then the
- *    multicast packet is accepted.  Otherwise, it's dropped silently.
- *
- *    To use the 6 bits as an offset into the table, the high 3 bits are the
- *    number of the 8 bit register, while the low 3 bits are the bit within
- *    that register.
- *
- *    This routine is based very heavily on the one provided by Peter Cammaert.
- */
-static void
-smc_setmulticast(unsigned long ioaddr, int count, struct dev_mc_list *addrs)
-{
-	int i;
-	unsigned char multicast_table[8];
-	struct dev_mc_list *cur_addr;
-
-	/* table for flipping the order of 3 bits */
-	static unsigned char invert3[] = { 0, 4, 2, 6, 1, 5, 3, 7 };
-
-	/* start with a table of all zeros: reject all */
-	memset(multicast_table, 0, sizeof(multicast_table));
-
-	cur_addr = addrs;
-	for (i = 0; i < count; i++, cur_addr = cur_addr->next) {
-		int position;
-
-		/* do we have a pointer here? */
-		if (!cur_addr)
-			break;
-		/* make sure this is a multicast address - shouldn't this
-		   be a given if we have it here ? */
-		if (!(*cur_addr->dmi_addr & 1))
-			continue;
-
-		/* only use the low order bits */
-		position = crc32_le(~0, cur_addr->dmi_addr, 6) & 0x3f;
-
-		/* do some messy swapping to put the bit in the right spot */
-		multicast_table[invert3[position&7]] |=
-					(1<<invert3[(position>>3)&7]);
-
-	}
-	/* now, the table can be loaded into the chipset */
-	SMC_SELECT_BANK(3);
-	SMC_SET_MCAST(multicast_table);
-}
-
-/*
  * This routine will, depending on the values passed to it,
  * either make it accept multicast packets, go into
  * promiscuous mode (for TCPDUMP and cousins) or accept
@@ -1370,14 +1374,14 @@
 {
 	struct smc_local *lp = netdev_priv(dev);
 	unsigned long ioaddr = dev->base_addr;
+	unsigned char multicast_table[8];
+	int update_multicast = 0;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
-	SMC_SELECT_BANK(0);
 	if (dev->flags & IFF_PROMISC) {
 		DBG(2, "%s: RCR_PRMS\n", dev->name);
 		lp->rcr_cur_mode |= RCR_PRMS;
-		SMC_SET_RCR(lp->rcr_cur_mode);
 	}
 
 /* BUG?  I never disable promiscuous mode if multicasting was turned on.
@@ -1391,38 +1395,78 @@
 	 * checked before the table is
 	 */
 	else if (dev->flags & IFF_ALLMULTI || dev->mc_count > 16) {
-		lp->rcr_cur_mode |= RCR_ALMUL;
-		SMC_SET_RCR(lp->rcr_cur_mode);
 		DBG(2, "%s: RCR_ALMUL\n", dev->name);
+		lp->rcr_cur_mode |= RCR_ALMUL;
 	}
 
 	/*
-	 * We just get all multicast packets even if we only want them
-	 * from one source.  This will be changed at some future point.
+	 * This sets the internal hardware table to filter out unwanted
+	 * multicast packets before they take up memory.
+	 *
+	 * The SMC chip uses a hash table where the high 6 bits of the CRC of
+	 * address are the offset into the table.  If that bit is 1, then the
+	 * multicast packet is accepted.  Otherwise, it's dropped silently.
+	 *
+	 * To use the 6 bits as an offset into the table, the high 3 bits are
+	 * the number of the 8 bit register, while the low 3 bits are the bit
+	 * within that register.
 	 */
 	else if (dev->mc_count)  {
-		/* support hardware multicasting */
+		int i;
+		struct dev_mc_list *cur_addr;
+
+		/* table for flipping the order of 3 bits */
+		static const unsigned char invert3[] = {0, 4, 2, 6, 1, 5, 3, 7};
+
+		/* start with a table of all zeros: reject all */
+		memset(multicast_table, 0, sizeof(multicast_table));
+
+		cur_addr = dev->mc_list;
+		for (i = 0; i < dev->mc_count; i++, cur_addr = cur_addr->next) {
+			int position;
+
+			/* do we have a pointer here? */
+			if (!cur_addr)
+				break;
+			/* make sure this is a multicast address -
+		   	   shouldn't this be a given if we have it here ? */
+			if (!(*cur_addr->dmi_addr & 1))
+				continue;
+
+			/* only use the low order bits */
+			position = crc32_le(~0, cur_addr->dmi_addr, 6) & 0x3f;
+
+			/* do some messy swapping to put the bit in the right spot */
+			multicast_table[invert3[position&7]] |=
+				(1<<invert3[(position>>3)&7]);
+		}
 
 		/* be sure I get rid of flags I might have set */
 		lp->rcr_cur_mode &= ~(RCR_PRMS | RCR_ALMUL);
-		SMC_SET_RCR(lp->rcr_cur_mode);
-		/*
-		 * NOTE: this has to set the bank, so make sure it is the
-		 * last thing called.  The bank is set to zero at the top
-		 */
-		smc_setmulticast(ioaddr, dev->mc_count, dev->mc_list);
+
+		/* now, the table can be loaded into the chipset */
+		update_multicast = 1;
 	} else  {
 		DBG(2, "%s: ~(RCR_PRMS|RCR_ALMUL)\n", dev->name);
 		lp->rcr_cur_mode &= ~(RCR_PRMS | RCR_ALMUL);
-		SMC_SET_RCR(lp->rcr_cur_mode);
 
 		/*
 		 * since I'm disabling all multicast entirely, I need to
 		 * clear the multicast list
 		 */
+		memset(multicast_table, 0, sizeof(multicast_table));
+		update_multicast = 1;
+	}
+
+	spin_lock_irq(&lp->lock);
+	SMC_SELECT_BANK(0);
+	SMC_SET_RCR(lp->rcr_cur_mode);
+	if (update_multicast) {
 		SMC_SELECT_BANK(3);
-		SMC_CLEAR_MCAST();
+		SMC_SET_MCAST(multicast_table);
 	}
+	SMC_SELECT_BANK(2);
+	spin_unlock_irq(&lp->lock);
 }
 
 
@@ -1435,7 +1479,6 @@
 smc_open(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
-	unsigned long ioaddr = dev->base_addr;
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
@@ -1445,13 +1488,10 @@
 	 * address using ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx
 	 */
 	if (!is_valid_ether_addr(dev->dev_addr)) {
-		DBG(2, "smc_open: no valid ethernet hw addr\n");
+		PRINTK("%s: no valid ethernet hw addr\n", __FUNCTION__);
 		return -EINVAL;
 	}
 
-	/* clear out all the junk that was put here before... */
-	lp->saved_skb = NULL;
-
 	/* Setup the default Register Modes */
 	lp->tcr_cur_mode = TCR_DEFAULT;
 	lp->rcr_cur_mode = RCR_DEFAULT;
@@ -1468,10 +1508,7 @@
 	smc_reset(dev);
 	smc_enable(dev);
 
-	SMC_SELECT_BANK(1);
-	SMC_SET_MAC_ADDR(dev->dev_addr);
-
-	/* Configure the PHY */
+	/* Configure the PHY, initialize the link state */
 	if (lp->phy_type != 0)
 		smc_phy_configure(dev);
 	else {
@@ -1480,12 +1517,6 @@
 		spin_unlock_irq(&lp->lock);
 	}
 
-	/*
-	 * make sure to initialize the link state with netif_carrier_off()
-	 * somewhere, too --jgarzik
-	 *
-	 * smc_phy_configure() and smc_10bt_check_media() does that. --rmk
-	 */
 	netif_start_queue(dev);
 	return 0;
 }
@@ -1507,10 +1538,17 @@
 	netif_carrier_off(dev);
 
 	/* clear everything */
-	smc_shutdown(dev->base_addr);
+	smc_shutdown(dev);
 
-	if (lp->phy_type != 0)
+	if (lp->phy_type != 0) {
+		flush_scheduled_work();
 		smc_phy_powerdown(dev, lp->mii.phy_id);
+	}
+
+	if (lp->pending_tx_skb) {
+		dev_kfree_skb(lp->pending_tx_skb);
+		lp->pending_tx_skb = NULL;
+	}
 
 	return 0;
 }
@@ -1800,6 +1838,7 @@
 	/* fill in some of the fields */
 	dev->base_addr = ioaddr;
 	lp->version = revision_register & 0xff;
+	spin_lock_init(&lp->lock);
 
 	/* Get the MAC address */
 	SMC_SELECT_BANK(1);
@@ -1855,7 +1894,8 @@
 	dev->set_multicast_list = smc_set_multicast_list;
 	dev->ethtool_ops = &smc_ethtool_ops;
 
-	spin_lock_init(&lp->lock);
+	tasklet_init(&lp->tx_task, smc_hardware_send_pkt, (unsigned long)dev);
+	INIT_WORK(&lp->phy_configure, smc_phy_configure, dev);
 	lp->mii.phy_id_mask = 0x1f;
 	lp->mii.reg_num_mask = 0x1f;
 	lp->mii.force_media = 0;
@@ -1885,9 +1925,8 @@
       	if (retval)
       		goto err_out;
 
-#if !defined(__m32r__)
 	set_irq_type(dev->irq, IRQT_RISING);
-#endif
+
 #ifdef SMC_USE_PXA_DMA
 	{
 		int dma = pxa_request_dma(dev->name, DMA_PRIO_LOW,
@@ -2121,7 +2160,7 @@
 	if (ndev && level == SUSPEND_DISABLE) {
 		if (netif_running(ndev)) {
 			netif_device_detach(ndev);
-			smc_shutdown(ndev->base_addr);
+			smc_shutdown(ndev);
 		}
 	}
 	return 0;
@@ -2134,15 +2173,12 @@
 
 	if (ndev && level == RESUME_ENABLE) {
 		struct smc_local *lp = netdev_priv(ndev);
-		unsigned long ioaddr = ndev->base_addr;
 
 		if (pdev->num_resources == 3)
 			smc_enable_device(pdev->resource[2].start);
 		if (netif_running(ndev)) {
 			smc_reset(ndev);
 			smc_enable(ndev);
-			SMC_SELECT_BANK(1);
-			SMC_SET_MAC_ADDR(ndev->dev_addr);
 			if (lp->phy_type != 0)
 				smc_phy_configure(ndev);
 			netif_device_attach(ndev);
diff -Naur linuxppc-2.6.9/drivers/net/smc91x.h linuxppc-2.6.9-dream/drivers/net/smc91x.h
--- linuxppc-2.6.9/drivers/net/smc91x.h	2004-10-18 23:54:54.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/net/smc91x.h	2005-06-20 10:46:11.000000000 +0200
@@ -59,7 +59,7 @@
 #define SMC_insw(a, r, p, l)	readsw((a) + (r), p, l)
 #define SMC_outsw(a, r, p, l)	writesw((a) + (r), p, l)
 
-#elif defined(CONFIG_REDWOOD_5) || defined(CONFIG_REDWOOD_6)
+#elif defined(CONFIG_REDWOOD_5) || defined(CONFIG_REDWOOD_6) || defined(CONFIG_DM7000)
 
 /* We can only do 16-bit reads and writes in the static memory space. */
 #define SMC_CAN_USE_8BIT	0
@@ -86,13 +86,7 @@
 #define SMC_outsw(a, r, p, l) 						\
 	do {								\
 		unsigned long __port = (a) + (r);			\
-		u16 *__p = (u16 *)(p);					\
-		int __l = (l);						\
-		while (__l > 0) {					\
-			/* Believe it or not, the swab isn't needed. */	\
-			outw( /* swab16 */ (*__p++), __port);		\
-			__l--;						\
-		}							\
+		_fast_outsw(__port, p, l); \
 	} while (0)
 #define set_irq_type(irq, type)
 
@@ -284,7 +278,6 @@
 }
 #endif  /* SMC_USE_PXA_DMA */
 
-
 /* Because of bank switching, the LAN91x uses only 16 I/O ports */
 #ifndef SMC_IO_SHIFT
 #define SMC_IO_SHIFT	0
diff -Naur linuxppc-2.6.9/drivers/usb/class/audio.c linuxppc-2.6.9-dream/drivers/usb/class/audio.c
--- linuxppc-2.6.9/drivers/usb/class/audio.c	2005-10-01 14:12:19.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/class/audio.c	2005-09-19 21:40:05.000000000 +0200
@@ -212,6 +212,9 @@
 
 #define dprintk(x)
 
+#undef abs
+extern int abs(int __x) __attribute_const__; /* Shut up warning */
+
 /* --------------------------------------------------------------------- */
 
 /*
@@ -395,6 +398,17 @@
 
 /* --------------------------------------------------------------------- */
 
+/* prevent picking up a bogus abs macro */
+#undef abs
+static inline int abs(int x)
+{
+        if (x < 0)
+		return -x;
+	return x;
+}
+                                
+/* --------------------------------------------------------------------- */
+
 static inline unsigned ld2(unsigned int x)
 {
 	unsigned r = 0;
@@ -1954,9 +1968,9 @@
 	struct usb_audio_state *s;
 
 	down(&open_sem);
-	list_for_each(devs, &audiodevs) {
+	for (devs = audiodevs.next; devs != &audiodevs; devs = devs->next) {
 		s = list_entry(devs, struct usb_audio_state, audiodev);
-		list_for_each(mdevs, &s->mixerlist) {
+		for (mdevs = s->mixerlist.next; mdevs != &s->mixerlist; mdevs = mdevs->next) {
 			ms = list_entry(mdevs, struct usb_mixerdev, list);
 			if (ms->dev_mixer == minor)
 				goto mixer_found;
@@ -1974,7 +1988,7 @@
 	s->count++;
 
 	up(&open_sem);
-	return nonseekable_open(inode, file);
+	return 0;
 }
 
 static int usb_audio_release_mixdev(struct inode *inode, struct file *file)
@@ -1994,7 +2008,6 @@
 {
 	struct usb_mixerdev *ms = (struct usb_mixerdev *)file->private_data;
 	int i, j, val;
-	int __user *user_arg = (int __user *)arg;
 
 	if (!ms->state->usbdev)
 		return -ENODEV;
@@ -2021,7 +2034,7 @@
 		return 0;
 	}
 	if (cmd == OSS_GETVERSION)
-		return put_user(SOUND_VERSION, user_arg);
+		return put_user(SOUND_VERSION, (int *)arg);
 	if (_IOC_TYPE(cmd) != 'M' || _IOC_SIZE(cmd) != sizeof(int))
 		return -EINVAL;
 	if (_IOC_DIR(cmd) == _IOC_READ) {
@@ -2030,27 +2043,27 @@
 			val = get_rec_src(ms);
 			if (val < 0)
 				return val;
-			return put_user(val, user_arg);
+			return put_user(val, (int *)arg);
 
 		case SOUND_MIXER_DEVMASK: /* Arg contains a bit for each supported device */
 			for (val = i = 0; i < ms->numch; i++)
 				val |= 1 << ms->ch[i].osschannel;
-			return put_user(val, user_arg);
+			return put_user(val, (int *)arg);
 
 		case SOUND_MIXER_RECMASK: /* Arg contains a bit for each supported recording source */
 			for (val = i = 0; i < ms->numch; i++)
 				if (ms->ch[i].slctunitid)
 					val |= 1 << ms->ch[i].osschannel;
-			return put_user(val, user_arg);
+			return put_user(val, (int *)arg);
 
 		case SOUND_MIXER_STEREODEVS: /* Mixer channels supporting stereo */
 			for (val = i = 0; i < ms->numch; i++)
 				if (ms->ch[i].flags & (MIXFLG_STEREOIN | MIXFLG_STEREOOUT))
 					val |= 1 << ms->ch[i].osschannel;
-			return put_user(val, user_arg);
+			return put_user(val, (int *)arg);
 			
 		case SOUND_MIXER_CAPS:
-			return put_user(SOUND_CAP_EXCL_INPUT, user_arg);
+			return put_user(SOUND_CAP_EXCL_INPUT, (int *)arg);
 
 		default:
 			i = _IOC_NR(cmd);
@@ -2058,7 +2071,7 @@
 				return -EINVAL;
 			for (j = 0; j < ms->numch; j++) {
 				if (ms->ch[j].osschannel == i) {
-					return put_user(ms->ch[j].value, user_arg);
+					return put_user(ms->ch[j].value, (int *)arg);
 				}
 			}
 			return -EINVAL;
@@ -2069,7 +2082,7 @@
 	ms->modcnt++;
 	switch (_IOC_NR(cmd)) {
 	case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
-		if (get_user(val, user_arg))
+		if (get_user(val, (int *)arg))
 			return -EFAULT;
 		return set_rec_src(ms, val);
 
@@ -2080,11 +2093,11 @@
 		for (j = 0; j < ms->numch && ms->ch[j].osschannel != i; j++);
 		if (j >= ms->numch)
 			return -EINVAL;
-		if (get_user(val, user_arg))
+		if (get_user(val, (int *)arg))
 			return -EFAULT;
 		if (wrmixer(ms, j, val))
 			return -EIO;
-		return put_user(ms->ch[j].value, user_arg);
+		return put_user(ms->ch[j].value, (int *)arg);
 	}
 }
 
@@ -2147,6 +2160,8 @@
 	unsigned int ptr;
 	int cnt, err;
 
+	if (ppos != &file->f_pos)
+		return -ESPIPE;
 	if (as->usbin.dma.mapped)
 		return -ENXIO;
 	if (!as->usbin.dma.ready && (ret = prog_dmabuf_in(as)))
@@ -2214,6 +2229,8 @@
 	unsigned int start_thr;
 	int cnt, err;
 
+	if (ppos != &file->f_pos)
+		return -ESPIPE;
 	if (as->usbout.dma.mapped)
 		return -ENXIO;
 	if (!as->usbout.dma.ready && (ret = prog_dmabuf_out(as)))
@@ -2353,7 +2370,6 @@
 {
 	struct usb_audiodev *as = (struct usb_audiodev *)file->private_data;
 	struct usb_audio_state *s = as->state;
-	int __user *user_arg = (int __user *)arg;
 	unsigned long flags;
 	audio_buf_info abinfo;
 	count_info cinfo;
@@ -2371,7 +2387,7 @@
 #endif
 	switch (cmd) {
 	case OSS_GETVERSION:
-		return put_user(SOUND_VERSION, user_arg);
+		return put_user(SOUND_VERSION, (int *)arg);
 
 	case SNDCTL_DSP_SYNC:
 		if (file->f_mode & FMODE_WRITE)
@@ -2383,7 +2399,7 @@
 
 	case SNDCTL_DSP_GETCAPS:
 		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME | DSP_CAP_TRIGGER | 
-				DSP_CAP_MMAP | DSP_CAP_BATCH, user_arg);
+				DSP_CAP_MMAP | DSP_CAP_BATCH, (int *)arg);
 
 	case SNDCTL_DSP_RESET:
 		if (file->f_mode & FMODE_WRITE) {
@@ -2397,7 +2413,7 @@
 		return 0;
 
 	case SNDCTL_DSP_SPEED:
-		if (get_user(val, user_arg))
+		if (get_user(val, (int *)arg))
 			return -EFAULT;
 		if (val >= 0) {
 			if (val < 4000)
@@ -2407,12 +2423,10 @@
 			if (set_format(as, file->f_mode, AFMT_QUERY, val))
 				return -EIO;
 		}
-		return put_user((file->f_mode & FMODE_READ) ? 
-				as->usbin.dma.srate : as->usbout.dma.srate,
-				user_arg);
+		return put_user((file->f_mode & FMODE_READ) ? as->usbin.dma.srate : as->usbout.dma.srate, (int *)arg);
 
 	case SNDCTL_DSP_STEREO:
-		if (get_user(val, user_arg))
+		if (get_user(val, (int *)arg))
 			return -EFAULT;
 		val2 = (file->f_mode & FMODE_READ) ? as->usbin.dma.format : as->usbout.dma.format;
 		if (val)
@@ -2424,7 +2438,7 @@
 		return 0;
 
 	case SNDCTL_DSP_CHANNELS:
-		if (get_user(val, user_arg))
+		if (get_user(val, (int *)arg))
 			return -EFAULT;
 		if (val != 0) {
 			val2 = (file->f_mode & FMODE_READ) ? as->usbin.dma.format : as->usbout.dma.format;
@@ -2436,14 +2450,14 @@
 				return -EIO;
 		}
 		val2 = (file->f_mode & FMODE_READ) ? as->usbin.dma.format : as->usbout.dma.format;
-		return put_user(AFMT_ISSTEREO(val2) ? 2 : 1, user_arg);
+		return put_user(AFMT_ISSTEREO(val2) ? 2 : 1, (int *)arg);
 
 	case SNDCTL_DSP_GETFMTS: /* Returns a mask */
 		return put_user(AFMT_U8 | AFMT_U16_LE | AFMT_U16_BE |
-				AFMT_S8 | AFMT_S16_LE | AFMT_S16_BE, user_arg);
+				AFMT_S8 | AFMT_S16_LE | AFMT_S16_BE, (int *)arg);
 
 	case SNDCTL_DSP_SETFMT: /* Selects ONE fmt*/
-		if (get_user(val, user_arg))
+		if (get_user(val, (int *)arg))
 			return -EFAULT;
 		if (val != AFMT_QUERY) {
 			if (hweight32(val) != 1)
@@ -2457,7 +2471,7 @@
 				return -EIO;
 		}
 		val2 = (file->f_mode & FMODE_READ) ? as->usbin.dma.format : as->usbout.dma.format;
-		return put_user(val2 & ~AFMT_STEREO, user_arg);
+		return put_user(val2 & ~AFMT_STEREO, (int *)arg);
 
 	case SNDCTL_DSP_POST:
 		return 0;
@@ -2468,10 +2482,10 @@
 			val |= PCM_ENABLE_INPUT;
 		if (file->f_mode & FMODE_WRITE && as->usbout.flags & FLG_RUNNING) 
 			val |= PCM_ENABLE_OUTPUT;
-		return put_user(val, user_arg);
+		return put_user(val, (int *)arg);
 
 	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, user_arg))
+		if (get_user(val, (int *)arg))
 			return -EFAULT;
 		if (file->f_mode & FMODE_READ) {
 			if (val & PCM_ENABLE_INPUT) {
@@ -2529,7 +2543,7 @@
 		spin_lock_irqsave(&as->lock, flags);
 		val = as->usbout.dma.count;
 		spin_unlock_irqrestore(&as->lock, flags);
-		return put_user(val, user_arg);
+		return put_user(val, (int *)arg);
 
 	case SNDCTL_DSP_GETIPTR:
 		if (!(file->f_mode & FMODE_READ))
@@ -2563,14 +2577,14 @@
 		if (file->f_mode & FMODE_WRITE) {
 			if ((val = prog_dmabuf_out(as)))
 				return val;
-			return put_user(as->usbout.dma.fragsize, user_arg);
+			return put_user(as->usbout.dma.fragsize, (int *)arg);
 		}
 		if ((val = prog_dmabuf_in(as)))
 			return val;
-		return put_user(as->usbin.dma.fragsize, user_arg);
+		return put_user(as->usbin.dma.fragsize, (int *)arg);
 
 	case SNDCTL_DSP_SETFRAGMENT:
-		if (get_user(val, user_arg))
+		if (get_user(val, (int *)arg))
 			return -EFAULT;
 		if (file->f_mode & FMODE_READ) {
 			as->usbin.dma.ossfragshift = val & 0xffff;
@@ -2598,7 +2612,7 @@
 		if ((file->f_mode & FMODE_READ && as->usbin.dma.subdivision) ||
 		    (file->f_mode & FMODE_WRITE && as->usbout.dma.subdivision))
 			return -EINVAL;
-		if (get_user(val, user_arg))
+		if (get_user(val, (int *)arg))
 			return -EFAULT;
 		if (val != 1 && val != 2 && val != 4)
 			return -EINVAL;
@@ -2609,17 +2623,15 @@
 		return 0;
 
 	case SOUND_PCM_READ_RATE:
-		return put_user((file->f_mode & FMODE_READ) ? 
-				as->usbin.dma.srate : as->usbout.dma.srate,
-				user_arg);
+		return put_user((file->f_mode & FMODE_READ) ? as->usbin.dma.srate : as->usbout.dma.srate, (int *)arg);
 
 	case SOUND_PCM_READ_CHANNELS:
 		val2 = (file->f_mode & FMODE_READ) ? as->usbin.dma.format : as->usbout.dma.format;
-		return put_user(AFMT_ISSTEREO(val2) ? 2 : 1, user_arg);
+		return put_user(AFMT_ISSTEREO(val2) ? 2 : 1, (int *)arg);
 
 	case SOUND_PCM_READ_BITS:
 		val2 = (file->f_mode & FMODE_READ) ? as->usbin.dma.format : as->usbout.dma.format;
-		return put_user(AFMT_IS16BIT(val2) ? 16 : 8, user_arg);
+		return put_user(AFMT_IS16BIT(val2) ? 16 : 8, (int *)arg);
 
 	case SOUND_PCM_WRITE_FILTER:
 	case SNDCTL_DSP_SETSYNCRO:
@@ -2640,9 +2652,9 @@
 
 	for (;;) {
 		down(&open_sem);
-		list_for_each(devs, &audiodevs) {
+		for (devs = audiodevs.next; devs != &audiodevs; devs = devs->next) {
 			s = list_entry(devs, struct usb_audio_state, audiodev);
-			list_for_each(adevs, &s->audiolist) {
+			for (adevs = s->audiolist.next; adevs != &s->audiolist; adevs = adevs->next) {
 				as = list_entry(adevs, struct usb_audiodev, list);
 				if (!((as->dev_audio ^ minor) & ~0xf))
 					goto device_found;
@@ -2684,7 +2696,7 @@
 	as->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
 	s->count++;
 	up(&open_sem);
-	return nonseekable_open(inode, file);
+	return 0;
 }
 
 static int usb_audio_release(struct inode *inode, struct file *file)
@@ -3122,18 +3134,12 @@
 {
 	struct usb_device *dev = state->s->usbdev;
 	struct mixerchannel *ch;
-	unsigned char *buf;
+	unsigned char buf[2];
 	__s16 v1;
 	unsigned int v2, v3;
 
 	if (!state->nrmixch || state->nrmixch > SOUND_MIXER_NRDEVICES)
 		return;
-	buf = kmalloc(sizeof(*buf) * 2, GFP_KERNEL);
-	if (!buf) {
-		printk(KERN_ERR "prepmixch: out of memory\n") ;
-		return;
-	}
-
 	ch = &state->mixch[state->nrmixch-1];
 	switch (ch->selector) {
 	case 0:  /* mixer unit request */
@@ -3245,16 +3251,13 @@
 	default:
 		goto err;
 	}
-
- freebuf:
-	kfree(buf);
 	return;
+
  err:
 	printk(KERN_ERR "usbaudio: mixer request device %u if %u unit %u ch %u selector %u failed\n", 
 	       dev->devnum, state->ctrlif, ch->unitid, ch->chnum, ch->selector);
 	if (state->nrmixch)
 		state->nrmixch--;
-	goto freebuf;
 }
 
 
@@ -3840,7 +3843,7 @@
 	usb_set_intfdata (intf, NULL);
 
 	/* deregister all audio and mixer devices, so no new processes can open this device */
-	list_for_each(list, &s->audiolist) {
+	for(list = s->audiolist.next; list != &s->audiolist; list = list->next) {
 		as = list_entry(list, struct usb_audiodev, list);
 		usbin_disc(as);
 		usbout_disc(as);
@@ -3852,7 +3855,7 @@
 		}
 		as->dev_audio = -1;
 	}
-	list_for_each(list, &s->mixerlist) {
+	for(list = s->mixerlist.next; list != &s->mixerlist; list = list->next) {
 		ms = list_entry(list, struct usb_mixerdev, list);
 		if (ms->dev_mixer >= 0) {
 			unregister_sound_mixer(ms->dev_mixer);
diff -Naur linuxppc-2.6.9/drivers/usb/class/bluetty.c linuxppc-2.6.9-dream/drivers/usb/class/bluetty.c
--- linuxppc-2.6.9/drivers/usb/class/bluetty.c	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/class/bluetty.c	2005-09-19 21:40:05.000000000 +0200
@@ -988,13 +988,21 @@
 static void bluetooth_softint(void *private)
 {
 	struct usb_bluetooth *bluetooth = get_usb_bluetooth ((struct usb_bluetooth *)private, __FUNCTION__);
+	struct tty_struct *tty;
 
 	dbg("%s", __FUNCTION__);
 
-	if (!bluetooth)
+	if (!bluetooth) {
 		return;
+	}
+
+	tty = bluetooth->tty;
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) && tty->ldisc.write_wakeup) {
+		dbg("%s - write wakeup call.", __FUNCTION__);
+		(tty->ldisc.write_wakeup)(tty);
+	}
 
-	tty_wakeup(bluetooth->tty);
+	wake_up_interruptible(&tty->write_wait);
 }
 
 
@@ -1226,7 +1234,7 @@
 	.chars_in_buffer =	bluetooth_chars_in_buffer,
 };
 
-static int usb_bluetooth_init(void)
+int usb_bluetooth_init(void)
 {
 	int i;
 	int result;
@@ -1275,7 +1283,7 @@
 }
 
 
-static void usb_bluetooth_exit(void)
+void usb_bluetooth_exit(void)
 {
 	usb_deregister(&usb_bluetooth_driver);
 	tty_unregister_driver(bluetooth_tty_driver);
diff -Naur linuxppc-2.6.9/drivers/usb/class/cdc-acm.c linuxppc-2.6.9-dream/drivers/usb/class/cdc-acm.c
--- linuxppc-2.6.9/drivers/usb/class/cdc-acm.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/class/cdc-acm.c	2005-09-19 21:40:05.000000000 +0200
@@ -5,7 +5,6 @@
  * Copyright (c) 1999 Pavel Machek	<pavel@suse.cz>
  * Copyright (c) 1999 Johannes Erdfelt	<johannes@erdfelt.com>
  * Copyright (c) 2000 Vojtech Pavlik	<vojtech@suse.cz>
- * Copyright (c) 2004 Oliver Neukum	<oliver@neukum.name>
  *
  * USB Abstract Control Model driver for USB modems and ISDN adapters
  *
@@ -28,7 +27,6 @@
  *	v0.22 - probe only the control interface. if usbcore doesn't choose the
  *		config we want, sysadmin changes bConfigurationValue in sysfs.
  *	v0.23 - use softirq for rx processing, as needed by tty layer
- *	v0.24 - change probe method to evaluate CDC union descriptor
  */
 
 /*
@@ -61,9 +59,6 @@
 #include <asm/uaccess.h>
 #include <linux/usb.h>
 #include <asm/byteorder.h>
-#include <asm/unaligned.h>
-
-#include "cdc-acm.h"
 
 /*
  * Version Information
@@ -72,12 +67,102 @@
 #define DRIVER_AUTHOR "Armin Fuerst, Pavel Machek, Johannes Erdfelt, Vojtech Pavlik"
 #define DRIVER_DESC "USB Abstract Control Model driver for USB modems and ISDN adapters"
 
+/*
+ * CMSPAR, some architectures can't have space and mark parity.
+ */
+
+#ifndef CMSPAR
+#define CMSPAR			0
+#endif
+
+/*
+ * Major and minor numbers.
+ */
+
+#define ACM_TTY_MAJOR		166
+#define ACM_TTY_MINORS		32
+
+/*
+ * Requests.
+ */
+
+#define USB_RT_ACM		(USB_TYPE_CLASS | USB_RECIP_INTERFACE)
+
+#define ACM_REQ_COMMAND		0x00
+#define ACM_REQ_RESPONSE	0x01
+#define ACM_REQ_SET_FEATURE	0x02
+#define ACM_REQ_GET_FEATURE	0x03
+#define ACM_REQ_CLEAR_FEATURE	0x04
+
+#define ACM_REQ_SET_LINE	0x20
+#define ACM_REQ_GET_LINE	0x21
+#define ACM_REQ_SET_CONTROL	0x22
+#define ACM_REQ_SEND_BREAK	0x23
+
+/*
+ * IRQs.
+ */
+
+#define ACM_IRQ_NETWORK		0x00
+#define ACM_IRQ_LINE_STATE	0x20
+
+/*
+ * Output control lines.
+ */
+
+#define ACM_CTRL_DTR		0x01
+#define ACM_CTRL_RTS		0x02
+
+/*
+ * Input control lines and line errors.
+ */
+
+#define ACM_CTRL_DCD		0x01
+#define ACM_CTRL_DSR		0x02
+#define ACM_CTRL_BRK		0x04
+#define ACM_CTRL_RI		0x08
+
+#define ACM_CTRL_FRAMING	0x10
+#define ACM_CTRL_PARITY		0x20
+#define ACM_CTRL_OVERRUN	0x40
+
+/*
+ * Line speed and caracter encoding.
+ */
+
+struct acm_line {
+	__u32 speed;
+	__u8 stopbits;
+	__u8 parity;
+	__u8 databits;
+} __attribute__ ((packed));
+
+/*
+ * Internal driver structures.
+ */
+
+struct acm {
+	struct usb_device *dev;				/* the corresponding usb device */
+	struct usb_interface *control;			/* control interface */
+	struct usb_interface *data;			/* data interface */
+	struct tty_struct *tty;				/* the corresponding tty */
+	struct urb *ctrlurb, *readurb, *writeurb;	/* urbs */
+	struct acm_line line;				/* line coding (bits, stop, parity) */
+	struct work_struct work;			/* work queue entry for line discipline waking up */
+	struct tasklet_struct bh;			/* rx processing */
+	unsigned int ctrlin;				/* input control lines (DCD, DSR, RI, break, overruns) */
+	unsigned int ctrlout;				/* output control lines (DTR, RTS) */
+	unsigned int writesize;				/* max packet size for the output bulk endpoint */
+	unsigned int used;				/* someone has this acm's device open */
+	unsigned int minor;				/* acm minor number */
+	unsigned char throttle;				/* throttled by tty layer */
+	unsigned char clocal;				/* termios CLOCAL */
+};
+
 static struct usb_driver acm_driver;
 static struct tty_driver *acm_tty_driver;
 static struct acm *acm_table[ACM_TTY_MINORS];
 
-static DECLARE_MUTEX(open_sem);
-
 #define ACM_READY(acm)	(acm && acm->dev && acm->used)
 
 /*
@@ -110,7 +195,7 @@
 {
 	struct acm *acm = urb->context;
 	struct usb_ctrlrequest *dr = urb->transfer_buffer;
-	unsigned char *data;
+	unsigned char *data = (unsigned char *)(dr + 1);
 	int newctrl;
 	int status;
 
@@ -132,7 +217,6 @@
 	if (!ACM_READY(acm))
 		goto exit;
 
-	data = (unsigned char *)(dr + 1);
 	switch (dr->bRequest) {
 
 		case ACM_IRQ_NETWORK:
@@ -142,7 +226,7 @@
 
 		case ACM_IRQ_LINE_STATE:
 
-			newctrl = le16_to_cpu(get_unaligned((__le16 *) data));
+			newctrl = le16_to_cpup((__u16 *) data);
 
 			if (acm->tty && !acm->clocal && (acm->ctrlin & ~newctrl & ACM_CTRL_DCD)) {
 				dbg("calling hangup");
@@ -175,7 +259,6 @@
 static void acm_read_bulk(struct urb *urb, struct pt_regs *regs)
 {
 	struct acm *acm = urb->context;
-	dbg("Entering acm_read_bulk with status %d\n", urb->status);
 
 	if (!ACM_READY(acm))
 		return;
@@ -194,7 +277,6 @@
 	struct tty_struct *tty = acm->tty;
 	unsigned char *data = urb->transfer_buffer;
 	int i = 0;
-	dbg("Entering acm_rx_tasklet");
 
 	if (urb->actual_length > 0 && !acm->throttle)  {
 		for (i = 0; i < urb->actual_length && !acm->throttle; i++) {
@@ -205,20 +287,14 @@
 			}
 			tty_insert_flip_char(tty, data[i], 0);
 		}
-		dbg("Handed %d bytes to tty layer", i+1);
 		tty_flip_buffer_push(tty);
 	}
 
-	spin_lock(&acm->throttle_lock);
 	if (acm->throttle) {
-		dbg("Throtteling noticed");
 		memmove(data, data + i, urb->actual_length - i);
 		urb->actual_length -= i;
-		acm->resubmit_to_unthrottle = 1;
-		spin_unlock(&acm->throttle_lock);
 		return;
 	}
-	spin_unlock(&acm->throttle_lock);
 
 	urb->actual_length = 0;
 	urb->dev = acm->dev;
@@ -232,27 +308,28 @@
 static void acm_write_bulk(struct urb *urb, struct pt_regs *regs)
 {
 	struct acm *acm = (struct acm *)urb->context;
-	dbg("Entering acm_write_bulk with status %d\n", urb->status);
 
 	if (!ACM_READY(acm))
-		goto out;
+		return;
 
 	if (urb->status)
 		dbg("nonzero write bulk status received: %d", urb->status);
 
 	schedule_work(&acm->work);
-out:
-	acm->ready_for_write = 1;
 }
 
 static void acm_softint(void *private)
 {
 	struct acm *acm = private;
-	dbg("Entering acm_softint.\n");
-	
+	struct tty_struct *tty = acm->tty;
+
 	if (!ACM_READY(acm))
 		return;
-	tty_wakeup(acm->tty);
+
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) && tty->ldisc.write_wakeup)
+		(tty->ldisc.write_wakeup)(tty);
+
+	wake_up_interruptible(&tty->write_wait);
 }
 
 /*
@@ -262,7 +339,6 @@
 static int acm_tty_open(struct tty_struct *tty, struct file *filp)
 {
 	struct acm *acm = acm_table[tty->index];
-	dbg("Entering acm_tty_open.\n");
 
 	if (!acm || !acm->dev)
 		return -EINVAL;
@@ -270,43 +346,30 @@
 	tty->driver_data = acm;
 	acm->tty = tty;
 
-        down(&open_sem);
+        lock_kernel();
 
-	if (acm->used) {
-		goto done;
+	if (acm->used++) {
+                unlock_kernel();
+                return 0;
         }
 
+        unlock_kernel();
+
 	acm->ctrlurb->dev = acm->dev;
-	if (usb_submit_urb(acm->ctrlurb, GFP_KERNEL)) {
+	if (usb_submit_urb(acm->ctrlurb, GFP_KERNEL))
 		dbg("usb_submit_urb(ctrl irq) failed");
-		goto bail_out;
-	}
 
 	acm->readurb->dev = acm->dev;
-	if (usb_submit_urb(acm->readurb, GFP_KERNEL)) {
+	if (usb_submit_urb(acm->readurb, GFP_KERNEL))
 		dbg("usb_submit_urb(read bulk) failed");
-		goto bail_out_and_unlink;
-	}
 
-	if (0 > acm_set_control(acm, acm->ctrlout = ACM_CTRL_DTR | ACM_CTRL_RTS))
-		goto full_bailout;
+	acm_set_control(acm, acm->ctrlout = ACM_CTRL_DTR | ACM_CTRL_RTS);
 
 	/* force low_latency on so that our tty_push actually forces the data through, 
 	   otherwise it is scheduled, and with high data rates data can get lost. */
 	tty->low_latency = 1;
 
-done:
-	acm->used++;
-	up(&open_sem);
 	return 0;
-
-full_bailout:
-	usb_unlink_urb(acm->readurb);
-bail_out_and_unlink:
-	usb_unlink_urb(acm->ctrlurb);
-bail_out:
-	up(&open_sem);
-	return -EIO;
 }
 
 static void acm_tty_close(struct tty_struct *tty, struct file *filp)
@@ -316,7 +379,6 @@
 	if (!acm || !acm->used)
 		return;
 
-	down(&open_sem);
 	if (!--acm->used) {
 		if (acm->dev) {
 			acm_set_control(acm, acm->ctrlout = 0);
@@ -332,40 +394,35 @@
 			kfree(acm);
 		}
 	}
-	up(&open_sem);
 }
 
 static int acm_tty_write(struct tty_struct *tty, int from_user, const unsigned char *buf, int count)
 {
 	struct acm *acm = tty->driver_data;
 	int stat;
-	dbg("Entering acm_tty_write to write %d bytes from %s space,\n", count, from_user ? "user" : "kernel");
 
 	if (!ACM_READY(acm))
 		return -EINVAL;
-	if (!acm->ready_for_write)
+	if (acm->writeurb->status == -EINPROGRESS)
 		return 0;
 	if (!count)
 		return 0;
 
 	count = (count > acm->writesize) ? acm->writesize : count;
 
-	dbg("Get %d bytes from %s space...", count, from_user ? "user" : "kernel");
 	if (from_user) {
-		if (copy_from_user(acm->write_buffer, (void __user *)buf, count))
+		if (copy_from_user(acm->writeurb->transfer_buffer, (void __user *)buf, count))
 			return -EFAULT;
 	} else
-		memcpy(acm->write_buffer, buf, count);
-	dbg("  Successfully copied.\n");
+		memcpy(acm->writeurb->transfer_buffer, buf, count);
 
 	acm->writeurb->transfer_buffer_length = count;
 	acm->writeurb->dev = acm->dev;
 
-	acm->ready_for_write = 0;
-	stat = usb_submit_urb(acm->writeurb, from_user ? GFP_KERNEL : GFP_ATOMIC);
+	/* GFP_KERNEL probably works if from_user */
+	stat = usb_submit_urb(acm->writeurb, GFP_ATOMIC);
 	if (stat < 0) {
 		dbg("usb_submit_urb(write bulk) failed");
-		acm->ready_for_write = 1;
 		return stat;
 	}
 
@@ -377,7 +434,7 @@
 	struct acm *acm = tty->driver_data;
 	if (!ACM_READY(acm))
 		return -EINVAL;
-	return !acm->ready_for_write ? 0 : acm->writesize;
+	return acm->writeurb->status == -EINPROGRESS ? 0 : acm->writesize;
 }
 
 static int acm_tty_chars_in_buffer(struct tty_struct *tty)
@@ -385,7 +442,7 @@
 	struct acm *acm = tty->driver_data;
 	if (!ACM_READY(acm))
 		return -EINVAL;
-	return !acm->ready_for_write ? acm->writeurb->transfer_buffer_length : 0;
+	return acm->writeurb->status == -EINPROGRESS ? acm->writeurb->transfer_buffer_length : 0;
 }
 
 static void acm_tty_throttle(struct tty_struct *tty)
@@ -393,9 +450,7 @@
 	struct acm *acm = tty->driver_data;
 	if (!ACM_READY(acm))
 		return;
-	spin_lock_bh(&acm->throttle_lock);
 	acm->throttle = 1;
-	spin_unlock_bh(&acm->throttle_lock);
 }
 
 static void acm_tty_unthrottle(struct tty_struct *tty)
@@ -403,13 +458,9 @@
 	struct acm *acm = tty->driver_data;
 	if (!ACM_READY(acm))
 		return;
-	spin_lock_bh(&acm->throttle_lock);
 	acm->throttle = 0;
-	spin_unlock_bh(&acm->throttle_lock);
-	if (acm->resubmit_to_unthrottle) {
-		acm->resubmit_to_unthrottle = 0;
+	if (acm->readurb->status != -EINPROGRESS)
 		acm_read_bulk(acm->readurb, NULL);
-	}
 }
 
 static void acm_tty_break_ctl(struct tty_struct *tty, int state)
@@ -519,246 +570,153 @@
 static int acm_probe (struct usb_interface *intf,
 		      const struct usb_device_id *id)
 {
-	struct union_desc *union_header = NULL;
-	char *buffer = intf->altsetting->extra;
-	int buflen = intf->altsetting->extralen;
-	struct usb_interface *control_interface;
-	struct usb_interface *data_interface;
-	struct usb_endpoint_descriptor *epctrl;
-	struct usb_endpoint_descriptor *epread;
-	struct usb_endpoint_descriptor *epwrite;
-	struct usb_device *usb_dev = interface_to_usbdev(intf);
+	struct usb_device *dev;
 	struct acm *acm;
-	int minor;
-	int ctrlsize,readsize;
-	u8 *buf;
-	u8 ac_management_function = 0;
-	u8 call_management_function = 0;
-	int call_interface_num = -1;
-	int data_interface_num;
+	struct usb_host_config *cfacm;
+	struct usb_interface *data;
+	struct usb_host_interface *ifcom, *ifdata;
+	struct usb_endpoint_descriptor *epctrl, *epread, *epwrite;
+	int readsize, ctrlsize, minor, j;
+	unsigned char *buf;
+
+	dev = interface_to_usbdev (intf);
+
+		cfacm = dev->actconfig;
+
+		for (j = 0; j < cfacm->desc.bNumInterfaces - 1; j++) {
+		    
+			if (usb_interface_claimed(cfacm->interface[j]) ||
+			    usb_interface_claimed(cfacm->interface[j + 1]))
+			continue;
+
+			/* We know we're probe()d with the control interface.
+			 * FIXME ACM doesn't guarantee the data interface is
+			 * adjacent to the control interface, or that if one
+			 * is there it's not for call management ... so use
+			 * the cdc union descriptor whenever there is one.
+			 */
+			ifcom = intf->cur_altsetting;
+			if (intf == cfacm->interface[j]) {
+				ifdata = cfacm->interface[j + 1]->cur_altsetting;
+				data = cfacm->interface[j + 1];
+			} else if (intf == cfacm->interface[j + 1]) {
+				ifdata = cfacm->interface[j]->cur_altsetting;
+				data = cfacm->interface[j];
+			} else
+				continue;
+
+			if (ifdata->desc.bInterfaceClass != 10 || ifdata->desc.bNumEndpoints < 2)
+				continue;
+
+			epctrl = &ifcom->endpoint[0].desc;
+			epread = &ifdata->endpoint[0].desc;
+			epwrite = &ifdata->endpoint[1].desc;
+
+			if ((epctrl->bEndpointAddress & 0x80) != 0x80 || (epctrl->bmAttributes & 3) != 3 ||
+			   (epread->bmAttributes & 3) != 2 || (epwrite->bmAttributes & 3) != 2 ||
+			   ((epread->bEndpointAddress & 0x80) ^ (epwrite->bEndpointAddress & 0x80)) != 0x80)
+				continue;
+
+			if ((epread->bEndpointAddress & 0x80) != 0x80) {
+				epread = &ifdata->endpoint[1].desc;
+				epwrite = &ifdata->endpoint[0].desc;
+			}
 
-	if (!buffer) {
-		err("Wierd descriptor references");
-		return -EINVAL;
-	}
+			for (minor = 0; minor < ACM_TTY_MINORS && acm_table[minor]; minor++);
+			if (acm_table[minor]) {
+				err("no more free acm devices");
+				return -ENODEV;
+			}
 
-	while (buflen > 0) {
-		if (buffer [1] != USB_DT_CS_INTERFACE) {
-			err("skipping garbage");
-			goto next_desc;
-		}
+			if (!(acm = kmalloc(sizeof(struct acm), GFP_KERNEL))) {
+				err("out of memory");
+				return -ENOMEM;
+			}
+			memset(acm, 0, sizeof(struct acm));
 
-		switch (buffer [2]) {
-			case CDC_UNION_TYPE: /* we've found it */
-				if (union_header) {
-					err("More than one union descriptor, skipping ...");
-					goto next_desc;
-				}
-				union_header = (struct union_desc *)buffer;
-				break;
-			case CDC_COUNTRY_TYPE: /* maybe somehow export */
-				break; /* for now we ignore it */
-			case CDC_AC_MANAGEMENT_TYPE:
-				ac_management_function = buffer[3];
-				break;
-			case CDC_CALL_MANAGEMENT_TYPE:
-				call_management_function = buffer[3];
-				call_interface_num = buffer[4];
-				if ((call_management_function & 3) != 3)
-					err("This device cannot do calls on its own. It is no modem.");
-				break;
-				
-			default:
-				err("Ignoring extra header");
-				break;
+			ctrlsize = epctrl->wMaxPacketSize;
+			readsize = epread->wMaxPacketSize;
+			acm->writesize = epwrite->wMaxPacketSize;
+			acm->control = intf;
+			acm->data = data;
+			acm->minor = minor;
+			acm->dev = dev;
+
+			acm->bh.func = acm_rx_tasklet;
+			acm->bh.data = (unsigned long) acm;
+			INIT_WORK(&acm->work, acm_softint, acm);
+
+			if (!(buf = kmalloc(ctrlsize + readsize + acm->writesize, GFP_KERNEL))) {
+				err("out of memory");
+				kfree(acm);
+				return -ENOMEM;
 			}
-next_desc:
-		buflen -= buffer[0];
-		buffer += buffer[0];
-	}
 
-	if (!union_header) {
-		if (call_interface_num > 0) {
-			dev_dbg(&intf->dev,"No union descriptor, using call management descriptor\n");
-			data_interface = usb_ifnum_to_if(usb_dev, (data_interface_num = call_interface_num));
-			control_interface = intf;
-		} else {
-			dev_dbg(&intf->dev,"No union descriptor, giving up\n");
-			return -ENODEV;
-		}
-	} else {
-		control_interface = usb_ifnum_to_if(usb_dev, union_header->bMasterInterface0);
-		data_interface = usb_ifnum_to_if(usb_dev, (data_interface_num = union_header->bSlaveInterface0));
-		if (!control_interface || !data_interface) {
-			dev_dbg(&intf->dev,"no interfaces\n");
-			return -ENODEV;
-		}
-	}
-	
-		if (data_interface_num != call_interface_num)
-			dev_dbg(&intf->dev,"Seperate call control interface. That is not fully supported.");
-
-	if (usb_interface_claimed(data_interface)) { /* valid in this context */
-		dev_dbg(&intf->dev,"The data interface isn't available\n");
-		return -EBUSY;
-	}
-
-	/*workaround for switched interfaces */
-	if (data_interface->cur_altsetting->desc.bInterfaceClass != CDC_DATA_INTERFACE_TYPE) {
-		if (control_interface->cur_altsetting->desc.bInterfaceClass == CDC_DATA_INTERFACE_TYPE) {
-			struct usb_interface *t;
-			dev_dbg(&intf->dev,"Your device has switched interfaces.\n");
-
-			t = control_interface;
-			control_interface = data_interface;
-			data_interface = t;
-		} else {
-			return -EINVAL;
-		}
-	}
-	if (data_interface->cur_altsetting->desc.bNumEndpoints < 2)
-		return -EINVAL;
+			acm->ctrlurb = usb_alloc_urb(0, GFP_KERNEL);
+			if (!acm->ctrlurb) {
+				err("out of memory");
+				kfree(acm);
+				kfree(buf);
+				return -ENOMEM;
+			}
+			acm->readurb = usb_alloc_urb(0, GFP_KERNEL);
+			if (!acm->readurb) {
+				err("out of memory");
+				usb_free_urb(acm->ctrlurb);
+				kfree(acm);
+				kfree(buf);
+				return -ENOMEM;
+			}
+			acm->writeurb = usb_alloc_urb(0, GFP_KERNEL);
+			if (!acm->writeurb) {
+				err("out of memory");
+				usb_free_urb(acm->readurb);
+				usb_free_urb(acm->ctrlurb);
+				kfree(acm);
+				kfree(buf);
+				return -ENOMEM;
+			}
 
-	epctrl = &control_interface->cur_altsetting->endpoint[0].desc;
-	epread = &data_interface->cur_altsetting->endpoint[0].desc;
-	epwrite = &data_interface->cur_altsetting->endpoint[1].desc;
-
-
-	/* workaround for switched endpoints */
-	if ((epread->bEndpointAddress & USB_DIR_IN) != USB_DIR_IN) {
-		/* descriptors are swapped */
-		struct usb_endpoint_descriptor *t;
-		dev_dbg(&intf->dev,"The data interface has switched endpoints\n");
-		
-		t = epread;
-		epread = epwrite;
-		epwrite = t;
-	}
-	dbg("interfaces are valid");
-	for (minor = 0; minor < ACM_TTY_MINORS && acm_table[minor]; minor++);
-
-	if (acm_table[minor]) {
-		err("no more free acm devices");
-		return -ENODEV;
-	}
-
-	if (!(acm = kmalloc(sizeof(struct acm), GFP_KERNEL))) {
-		dev_dbg(&intf->dev, "out of memory (acm kmalloc)\n");
-		goto alloc_fail;
-	}
-	memset(acm, 0, sizeof(struct acm));
-
-	ctrlsize = epctrl->wMaxPacketSize;
-	readsize = epread->wMaxPacketSize;
-	acm->writesize = epwrite->wMaxPacketSize;
-	acm->control = control_interface;
-	acm->data = data_interface;
-	acm->minor = minor;
-	acm->dev = usb_dev;
-	acm->ctrl_caps = ac_management_function;
-	acm->ctrlsize = ctrlsize;
-	acm->readsize = readsize;
-	acm->bh.func = acm_rx_tasklet;
-	acm->bh.data = (unsigned long) acm;
-	INIT_WORK(&acm->work, acm_softint, acm);
-	spin_lock_init(&acm->throttle_lock);
-	acm->ready_for_write = 1;
-
-	buf = usb_buffer_alloc(usb_dev, ctrlsize, GFP_KERNEL, &acm->ctrl_dma);
-	if (!buf) {
-		dev_dbg(&intf->dev, "out of memory (ctrl buffer alloc)\n");
-		goto alloc_fail2;
-	}
-	acm->ctrl_buffer = buf;
-
-	buf = usb_buffer_alloc(usb_dev, readsize, GFP_KERNEL, &acm->read_dma);
-	if (!buf) {
-		dev_dbg(&intf->dev, "out of memory (read buffer alloc)\n");
-		goto alloc_fail3;
-	}
-	acm->read_buffer = buf;
-
-	buf = usb_buffer_alloc(usb_dev, acm->writesize, GFP_KERNEL, &acm->write_dma);
-	if (!buf) {
-		dev_dbg(&intf->dev, "out of memory (write buffer alloc)\n");
-		goto alloc_fail4;
-	}
-	acm->write_buffer = buf;	
-
-	acm->ctrlurb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!acm->ctrlurb) {
-		dev_dbg(&intf->dev, "out of memory (ctrlurb kmalloc)\n");
-		goto alloc_fail5;
-	}
-	acm->readurb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!acm->readurb) {
-		dev_dbg(&intf->dev, "out of memory (readurb kmalloc)\n");
-		goto alloc_fail6;
-	}
-	acm->writeurb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!acm->writeurb) {
-		dev_dbg(&intf->dev, "out of memory (writeurb kmalloc)\n");
-		goto alloc_fail7;
-	}
-
-	usb_fill_int_urb(acm->ctrlurb, usb_dev, usb_rcvintpipe(usb_dev, epctrl->bEndpointAddress),
-			 acm->ctrl_buffer, ctrlsize, acm_ctrl_irq, acm, epctrl->bInterval);
-	acm->ctrlurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-	acm->ctrlurb->transfer_dma = acm->ctrl_dma;
-
-	usb_fill_bulk_urb(acm->readurb, usb_dev, usb_rcvbulkpipe(usb_dev, epread->bEndpointAddress),
-			  acm->read_buffer, readsize, acm_read_bulk, acm);
-	acm->readurb->transfer_flags |= URB_NO_FSBR | URB_NO_TRANSFER_DMA_MAP;
-	acm->readurb->transfer_dma = acm->read_dma;
-
-	usb_fill_bulk_urb(acm->writeurb, usb_dev, usb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress),
-			  acm->write_buffer, acm->writesize, acm_write_bulk, acm);
-	acm->writeurb->transfer_flags |= URB_NO_FSBR | URB_NO_TRANSFER_DMA_MAP;
-	acm->writeurb->transfer_dma = acm->write_dma;
-
-	dev_info(&intf->dev, "ttyACM%d: USB ACM device\n", minor);
-
-	acm_set_control(acm, acm->ctrlout);
-
-	acm->line.speed = cpu_to_le32(9600);
-	acm->line.databits = 8;
-	acm_set_line(acm, &acm->line);
+			usb_fill_int_urb(acm->ctrlurb, dev, usb_rcvintpipe(dev, epctrl->bEndpointAddress),
+				buf, ctrlsize, acm_ctrl_irq, acm, epctrl->bInterval);
 
-	usb_driver_claim_interface(&acm_driver, data_interface, acm);
+			usb_fill_bulk_urb(acm->readurb, dev, usb_rcvbulkpipe(dev, epread->bEndpointAddress),
+				buf += ctrlsize, readsize, acm_read_bulk, acm);
+			acm->readurb->transfer_flags |= URB_NO_FSBR;
 
-	tty_register_device(acm_tty_driver, minor, &intf->dev);
+			usb_fill_bulk_urb(acm->writeurb, dev, usb_sndbulkpipe(dev, epwrite->bEndpointAddress),
+				buf += readsize, acm->writesize, acm_write_bulk, acm);
+			acm->writeurb->transfer_flags |= URB_NO_FSBR;
 
-	acm_table[minor] = acm;
-	usb_set_intfdata (intf, acm);
-	return 0;
+			dev_info(&intf->dev, "ttyACM%d: USB ACM device", minor);
 
-alloc_fail7:
-	usb_free_urb(acm->readurb);
-alloc_fail6:
-	usb_free_urb(acm->ctrlurb);
-alloc_fail5:
-	usb_buffer_free(usb_dev, acm->writesize, acm->write_buffer, acm->write_dma);
-alloc_fail4:
-	usb_buffer_free(usb_dev, readsize, acm->read_buffer, acm->read_dma);
-alloc_fail3:
-	usb_buffer_free(usb_dev, ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);
-alloc_fail2:
-	kfree(acm);
-alloc_fail:
-	return -ENOMEM;
+			acm_set_control(acm, acm->ctrlout);
+
+			acm->line.speed = cpu_to_le32(9600);
+			acm->line.databits = 8;
+			acm_set_line(acm, &acm->line);
+
+			usb_driver_claim_interface(&acm_driver, data, acm);
+
+			tty_register_device(acm_tty_driver, minor, &intf->dev);
+
+			acm_table[minor] = acm;
+			usb_set_intfdata (intf, acm);
+			return 0;
+		}
+
+	return -EIO;
 }
 
 static void acm_disconnect(struct usb_interface *intf)
 {
 	struct acm *acm = usb_get_intfdata (intf);
-	struct usb_device *usb_dev = interface_to_usbdev(intf);
 
 	if (!acm || !acm->dev) {
 		dbg("disconnect on nonexisting interface");
 		return;
 	}
 
-	down(&open_sem);
 	acm->dev = NULL;
 	usb_set_intfdata (intf, NULL);
 
@@ -766,11 +724,7 @@
 	usb_unlink_urb(acm->readurb);
 	usb_unlink_urb(acm->writeurb);
 
-	flush_scheduled_work(); /* wait for acm_softint */
-
-	usb_buffer_free(usb_dev, acm->writesize, acm->write_buffer, acm->write_dma);
-	usb_buffer_free(usb_dev, acm->readsize, acm->read_buffer, acm->read_dma);
-	usb_buffer_free(usb_dev, acm->ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);
+	kfree(acm->ctrlurb->transfer_buffer);
 
 	usb_driver_release_interface(&acm_driver, acm->data);
 
@@ -781,12 +735,9 @@
 		usb_free_urb(acm->readurb);
 		usb_free_urb(acm->writeurb);
 		kfree(acm);
-		up(&open_sem);
 		return;
 	}
 
-	up(&open_sem);
-
 	if (acm->tty)
 		tty_hangup(acm->tty);
 }
diff -Naur linuxppc-2.6.9/drivers/usb/class/cdc-acm.h linuxppc-2.6.9-dream/drivers/usb/class/cdc-acm.h
--- linuxppc-2.6.9/drivers/usb/class/cdc-acm.h	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/class/cdc-acm.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,127 +0,0 @@
-/*
- *
- * Includes for cdc-acm.c
- *
- * Mainly take from usbnet's cdc-ether part
- *
- */
-
-/*
- * CMSPAR, some architectures can't have space and mark parity.
- */
-
-#ifndef CMSPAR
-#define CMSPAR			0
-#endif
-
-/*
- * Major and minor numbers.
- */
-
-#define ACM_TTY_MAJOR		166
-#define ACM_TTY_MINORS		32
-
-/*
- * Requests.
- */
-
-#define USB_RT_ACM		(USB_TYPE_CLASS | USB_RECIP_INTERFACE)
-
-#define ACM_REQ_COMMAND		0x00
-#define ACM_REQ_RESPONSE	0x01
-#define ACM_REQ_SET_FEATURE	0x02
-#define ACM_REQ_GET_FEATURE	0x03
-#define ACM_REQ_CLEAR_FEATURE	0x04
-
-#define ACM_REQ_SET_LINE	0x20
-#define ACM_REQ_GET_LINE	0x21
-#define ACM_REQ_SET_CONTROL	0x22
-#define ACM_REQ_SEND_BREAK	0x23
-
-/*
- * IRQs.
- */
-
-#define ACM_IRQ_NETWORK		0x00
-#define ACM_IRQ_LINE_STATE	0x20
-
-/*
- * Output control lines.
- */
-
-#define ACM_CTRL_DTR		0x01
-#define ACM_CTRL_RTS		0x02
-
-/*
- * Input control lines and line errors.
- */
-
-#define ACM_CTRL_DCD		0x01
-#define ACM_CTRL_DSR		0x02
-#define ACM_CTRL_BRK		0x04
-#define ACM_CTRL_RI		0x08
-
-#define ACM_CTRL_FRAMING	0x10
-#define ACM_CTRL_PARITY		0x20
-#define ACM_CTRL_OVERRUN	0x40
-
-/*
- * Line speed and caracter encoding.
- */
-
-struct acm_line {
-	__le32 speed;
-	__u8 stopbits;
-	__u8 parity;
-	__u8 databits;
-} __attribute__ ((packed));
-
-/*
- * Internal driver structures.
- */
-
-struct acm {
-	struct usb_device *dev;				/* the corresponding usb device */
-	struct usb_interface *control;			/* control interface */
-	struct usb_interface *data;			/* data interface */
-	struct tty_struct *tty;				/* the corresponding tty */
-	struct urb *ctrlurb, *readurb, *writeurb;	/* urbs */
-	u8 *ctrl_buffer, *read_buffer, *write_buffer;	/* buffers of urbs */
-	dma_addr_t ctrl_dma, read_dma, write_dma;	/* dma handles of buffers */
-	struct acm_line line;				/* line coding (bits, stop, parity) */
-	struct work_struct work;			/* work queue entry for line discipline waking up */
-	struct tasklet_struct bh;			/* rx processing */
-	spinlock_t throttle_lock;			/* synchronize throtteling and read callback */
-	unsigned int ctrlin;				/* input control lines (DCD, DSR, RI, break, overruns) */
-	unsigned int ctrlout;				/* output control lines (DTR, RTS) */
-	unsigned int writesize;				/* max packet size for the output bulk endpoint */
-	unsigned int readsize,ctrlsize;			/* buffer sizes for freeing */
-	unsigned int used;				/* someone has this acm's device open */
-	unsigned int minor;				/* acm minor number */
-	unsigned char throttle;				/* throttled by tty layer */
-	unsigned char clocal;				/* termios CLOCAL */
-	unsigned char ready_for_write;			/* write urb can be used */
-	unsigned char resubmit_to_unthrottle;		/* throtteling has disabled the read urb */
-	unsigned int ctrl_caps;				/* control capabilities from the class specific header */
-};
-
-/* "Union Functional Descriptor" from CDC spec 5.2.3.X */
-struct union_desc {
-	u8	bLength;
-	u8	bDescriptorType;
-	u8	bDescriptorSubType;
-
-	u8	bMasterInterface0;
-	u8	bSlaveInterface0;
-	/* ... and there could be other slave interfaces */
-} __attribute__ ((packed));
-
-/* class specific descriptor types */
-#define CDC_CALL_MANAGEMENT_TYPE	0x01
-#define CDC_AC_MANAGEMENT_TYPE		0x02
-#define CDC_UNION_TYPE			0x06
-#define CDC_COUNTRY_TYPE		0x07
-
-#define CDC_DATA_INTERFACE_TYPE	0x0a
-
-
diff -Naur linuxppc-2.6.9/drivers/usb/class/usblp.c linuxppc-2.6.9-dream/drivers/usb/class/usblp.c
--- linuxppc-2.6.9/drivers/usb/class/usblp.c	2004-10-18 23:53:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/class/usblp.c	2005-09-19 21:40:05.000000000 +0200
@@ -75,7 +75,6 @@
 #define IOCNR_HP_SET_CHANNEL		4
 #define IOCNR_GET_BUS_ADDRESS		5
 #define IOCNR_GET_VID_PID		6
-#define IOCNR_SOFT_RESET		7
 /* Get device_id string: */
 #define LPIOC_GET_DEVICE_ID(len) _IOC(_IOC_READ, 'P', IOCNR_GET_DEVICE_ID, len)
 /* The following ioctls were added for http://hpoj.sourceforge.net: */
@@ -91,8 +90,6 @@
 #define LPIOC_GET_BUS_ADDRESS(len) _IOC(_IOC_READ, 'P', IOCNR_GET_BUS_ADDRESS, len)
 /* Get two-int array: [0]=vendor ID, [1]=product ID: */
 #define LPIOC_GET_VID_PID(len) _IOC(_IOC_READ, 'P', IOCNR_GET_VID_PID, len)
-/* Perform class specific soft reset */
-#define LPIOC_SOFT_RESET _IOC(_IOC_NONE, 'P', IOCNR_SOFT_RESET, 0);
 
 /*
  * A DEVICE_ID string may include the printer's serial number.
@@ -221,7 +218,7 @@
 static int usblp_cache_device_id_string(struct usblp *usblp);
 
 /* forward reference to make our lives easier */
-static struct usb_driver usblp_driver;
+extern struct usb_driver usblp_driver;
 
 /*
  * Functions for usblp control messages.
@@ -229,21 +226,11 @@
 
 static int usblp_ctrl_msg(struct usblp *usblp, int request, int type, int dir, int recip, int value, void *buf, int len)
 {
-	int retval;
-	int index = usblp->ifnum;
-
-	/* High byte has the interface index.
-	   Low byte has the alternate setting.
-	 */
-	if ((request == USBLP_REQ_GET_ID) && (type == USB_TYPE_CLASS)) {
-	  index = (usblp->ifnum<<8)|usblp->protocol[usblp->current_protocol].alt_setting;
-	}
-
-	retval = usb_control_msg(usblp->dev,
+	int retval = usb_control_msg(usblp->dev,
 		dir ? usb_rcvctrlpipe(usblp->dev, 0) : usb_sndctrlpipe(usblp->dev, 0),
-		request, type | dir | recip, value, index, buf, len, USBLP_WRITE_TIMEOUT);
-	dbg("usblp_control_msg: rq: 0x%02x dir: %d recip: %d value: %d idx: %d len: %#x result: %d",
-		request, !!dir, recip, value, index, len, retval);
+		request, type | dir | recip, value, usblp->ifnum, buf, len, USBLP_WRITE_TIMEOUT);
+	dbg("usblp_control_msg: rq: 0x%02x dir: %d recip: %d value: %d len: %#x result: %d",
+		request, !!dir, recip, value, len, retval);
 	return retval < 0 ? retval : 0;
 }
 
@@ -397,6 +384,10 @@
 {
 	info("usblp%d: removed", usblp->minor);
 
+	usb_buffer_free (usblp->dev, USBLP_BUF_SIZE,
+			usblp->writebuf, usblp->writeurb->transfer_dma);
+	usb_buffer_free (usblp->dev, USBLP_BUF_SIZE,
+			usblp->readbuf, usblp->readurb->transfer_dma);
 	kfree (usblp->device_id_string);
 	kfree (usblp->statusbuf);
 	usb_free_urb(usblp->writeurb);
@@ -449,9 +440,6 @@
 		goto done;
 	}
 
-	dbg("usblp_ioctl: cmd=0x%x (%c nr=%d len=%d dir=%d)", cmd, _IOC_TYPE(cmd),
-		_IOC_NR(cmd), _IOC_SIZE(cmd), _IOC_DIR(cmd) );
-
 	if (_IOC_TYPE(cmd) == 'P')	/* new-style ioctl number */
 
 		switch (_IOC_NR(cmd)) {
@@ -586,13 +574,6 @@
 					usblp->minor, twoints[0], twoints[1]);
 				break;
 
-			case IOCNR_SOFT_RESET:
-				if (_IOC_DIR(cmd) != _IOC_NONE) {
-					retval = -EINVAL;
-					goto done;
-				}
-				retval = usblp_reset(usblp);
-				break;
 			default:
 				retval = -ENOTTY;
 		}
@@ -767,7 +748,6 @@
 			usblp->minor, usblp->readurb->status);
 		usblp->readurb->dev = usblp->dev;
  		usblp->readcount = 0;
-		usblp->rcomplete = 0;
 		if (usb_submit_urb(usblp->readurb, GFP_KERNEL) < 0)
 			dbg("error submitting urb");
 		count = -EIO;
@@ -847,7 +827,7 @@
 		       const struct usb_device_id *id)
 {
 	struct usb_device *dev = interface_to_usbdev (intf);
-	struct usblp *usblp = NULL;
+	struct usblp *usblp = 0;
 	int protocol;
 	int retval;
 
@@ -1015,7 +995,7 @@
 			continue;
 
 		/* Look for bulk OUT and IN endpoints. */
-		epwrite = epread = NULL;
+		epwrite = epread = 0;
 		for (e = 0; e < ifd->desc.bNumEndpoints; e++) {
 			epd = &ifd->endpoint[e].desc;
 
@@ -1125,7 +1105,7 @@
 	/* First two bytes are length in big-endian.
 	 * They count themselves, and we copy them into
 	 * the user's buffer. */
-	length = be16_to_cpu(*((__be16 *)usblp->device_id_string));
+	length = be16_to_cpu(*((u16 *)usblp->device_id_string));
 	if (length < 2)
 		length = 2;
 	else if (length >= USBLP_DEVICE_ID_SIZE)
@@ -1155,10 +1135,6 @@
 	usb_set_intfdata (intf, NULL);
 
 	usblp_unlink_urbs(usblp);
-	usb_buffer_free (usblp->dev, USBLP_BUF_SIZE,
-			usblp->writebuf, usblp->writeurb->transfer_dma);
-	usb_buffer_free (usblp->dev, USBLP_BUF_SIZE,
-			usblp->readbuf, usblp->readurb->transfer_dma);
 
 	if (!usblp->used)
 		usblp_cleanup (usblp);
@@ -1208,6 +1184,6 @@
 
 MODULE_AUTHOR( DRIVER_AUTHOR );
 MODULE_DESCRIPTION( DRIVER_DESC );
-module_param(proto_bias, int, S_IRUGO | S_IWUSR);
+MODULE_PARM(proto_bias, "i");
 MODULE_PARM_DESC(proto_bias, "Favourite protocol number");
 MODULE_LICENSE("GPL");
diff -Naur linuxppc-2.6.9/drivers/usb/class/usb-midi.c linuxppc-2.6.9-dream/drivers/usb/class/usb-midi.c
--- linuxppc-2.6.9/drivers/usb/class/usb-midi.c	2004-10-18 23:53:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/class/usb-midi.c	2005-09-19 21:40:05.000000000 +0200
@@ -55,39 +55,39 @@
 /* ------------------------------------------------------------------------- */
 
 static int singlebyte = 0;
-module_param(singlebyte, int, 0);
+MODULE_PARM(singlebyte,"i");
 MODULE_PARM_DESC(singlebyte,"Enable sending MIDI messages with single message packet");
 
 static int maxdevices = 4;
-module_param(maxdevices, int, 0);
+MODULE_PARM(maxdevices,"i");
 MODULE_PARM_DESC(maxdevices,"Max number of allocatable MIDI device");
 
 static int uvendor     = -1;
-module_param(uvendor, int, 0);
+MODULE_PARM(uvendor,"i");
 MODULE_PARM_DESC(uvendor, "The USB Vendor ID of a semi-compliant interface");
 
 static int uproduct    = -1;
-module_param(uproduct, int, 0);
+MODULE_PARM(uproduct,"i");
 MODULE_PARM_DESC(uproduct, "The USB Product ID of a semi-compliant interface");
 
 static int uinterface  = -1;
-module_param(uinterface, int, 0);
+MODULE_PARM(uinterface,"i");
 MODULE_PARM_DESC(uinterface, "The Interface number of a semi-compliant interface");
 
 static int ualt        = -1;
-module_param(ualt, int, 0);
+MODULE_PARM(ualt,"i");
 MODULE_PARM_DESC(ualt, "The optional alternative setting of a semi-compliant interface");
 
 static int umin        = -1;
-module_param(umin, int, 0);
+MODULE_PARM(umin,"i");
 MODULE_PARM_DESC(umin, "The input endpoint of a semi-compliant interface");
 
 static int umout       = -1;
-module_param(umout, int, 0);
+MODULE_PARM(umout,"i");
 MODULE_PARM_DESC(umout, "The output endpoint of a semi-compliant interface");
 
 static int ucable      = -1;
-module_param(ucable, int, 0);
+MODULE_PARM(ucable,"i");
 MODULE_PARM_DESC(ucable, "The cable number used for a semi-compliant interface");
 
 /** Note -- the usb_string() returns only Latin-1 characters.
@@ -95,7 +95,7 @@
  * unicode16LE-to-JIS routine is needed to wrap around usb_get_string().
  **/
 static unsigned short ulangid      = 0x0409; /** 0x0411 for Japanese **/
-module_param(ulangid, ushort, 0);
+MODULE_PARM(ulangid,"h");
 MODULE_PARM_DESC(ulangid, "The optional preferred USB Language ID for all devices");
 
 MODULE_AUTHOR("NAGANO Daisuke <breeze.nagano@nifty.ne.jp>");
@@ -646,6 +646,9 @@
 	ssize_t ret;
 	DECLARE_WAITQUEUE(wait, current);
 
+	if ( ppos != &file->f_pos ) {
+		return -ESPIPE;
+	}
 	if ( !access_ok(VERIFY_READ, buffer, count) ) {
 		return -EFAULT;
 	}
@@ -725,6 +728,9 @@
 	ssize_t ret;
 	unsigned long int flags;
 
+	if ( ppos != &file->f_pos ) {
+		return -ESPIPE;
+	}
 	if ( !access_ok(VERIFY_READ, buffer, count) ) {
 		return -EFAULT;
 	}
@@ -817,9 +823,9 @@
 
 	for(;;) {
 		down(&open_sem);
-		list_for_each(devs, &mididevs) {
+		for (devs = mididevs.next; devs != &mididevs; devs = devs->next) {
 			s = list_entry(devs, struct usb_midi_state, mididev);
-			list_for_each(mdevs, &s->midiDevList) {
+			for (mdevs = s->midiDevList.next; mdevs != &s->midiDevList; mdevs = mdevs->next) {
 				m = list_entry(mdevs, struct usb_mididev, list);
 				if ( !((m->dev_midi ^ minor) & ~0xf) )
 					goto device_found;
@@ -914,7 +920,7 @@
 	printk(KERN_INFO "usb-midi: Open Succeeded. minor= %d.\n", minor);
 #endif
 
-	return nonseekable_open(inode, file); /** Success. **/
+	return 0; /** Success. **/
 }
 
 
@@ -945,7 +951,7 @@
 	if ( m->open_mode & FMODE_READ ) {
 	        unsigned long int flagsep;
 	        spin_lock_irqsave( &m->min.ep->lock, flagsep );
-                m->min.ep->cables[m->min.cableId] = NULL; // discard cable
+                m->min.ep->cables[m->min.cableId] = 0; // discard cable
                 m->min.ep->readers -= 1;
 		m->open_mode &= ~FMODE_READ;
 		if ( m->min.ep->readers == 0 &&
@@ -961,7 +967,7 @@
 	up(&open_sem);
 	wake_up(&open_wait);
 
-	file->private_data = NULL;
+	file->private_data = 0;
 	return 0;
 }
 
@@ -1288,7 +1294,7 @@
 	unsigned char jack2string[256];
 #endif
 
-	u = NULL;
+	u = 0;
 	/* find audiocontrol interface */
 	p1 = find_csinterface_descriptor( buffer, bufSize, NULL,
 					  MS_HEADER, ifnum, altSetting);
@@ -1308,7 +1314,7 @@
 	if ( !u ) {
 		return NULL;
 	}
-	u->deviceName = NULL;
+	u->deviceName = 0;
 	u->idVendor = d->descriptor.idVendor;
 	u->idProduct = d->descriptor.idProduct;
 	u->interface = ifnum;
@@ -1382,7 +1388,7 @@
 
 	if (quirks==0) {
 		/* MIDISTREAM */
-		p2 = NULL;
+		p2 = 0;
 		for (p1 = find_descriptor(buffer, bufSize, NULL, USB_DT_ENDPOINT,
 					  ifnum, altSetting ); p1; p1 = next ) {
 			next = find_descriptor(buffer, bufSize, p1, USB_DT_ENDPOINT,
@@ -1391,7 +1397,7 @@
 					     ifnum, altSetting ); 
 
 			if ( p2 && next && ( p2 > next ) )
-				p2 = NULL;
+				p2 = 0;
 
 			if ( p1[0] < 9 || !p2 || p2[0] < 4 )
 				continue;
@@ -1934,8 +1940,8 @@
 	if ( ucable < 0 || ucable > 15 )
 		ucable = 0;
 
-	u.deviceName = NULL; /* A flag for alloc_usb_midi_device to get device
-				name from device. */
+	u.deviceName = 0; /* A flag for alloc_usb_midi_device to get device name
+			     from device. */
 	u.idVendor   = uvendor;
 	u.idProduct  = uproduct;
 	u.interface  = uinterface;
@@ -2012,7 +2018,7 @@
 	s->usbdev = NULL;
 	usb_set_intfdata (intf, NULL);
 
-	list_for_each(list, &s->midiDevList) {
+	for ( list = s->midiDevList.next; list != &s->midiDevList; list = list->next ) {
 		m = list_entry(list, struct usb_mididev, list);
 		wake_up(&(m->min.ep->wait));
 		wake_up(&(m->mout.ep->wait));
diff -Naur linuxppc-2.6.9/drivers/usb/core/buffer.c linuxppc-2.6.9-dream/drivers/usb/core/buffer.c
--- linuxppc-2.6.9/drivers/usb/core/buffer.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/buffer.c	2005-09-19 21:40:05.000000000 +0200
@@ -94,7 +94,7 @@
 		struct dma_pool		*pool = hcd->pool [i];
 		if (pool) {
 			dma_pool_destroy (pool);
-			hcd->pool[i] = NULL;
+			hcd->pool [i] = 0;
 		}
 	}
 }
diff -Naur linuxppc-2.6.9/drivers/usb/core/config.c linuxppc-2.6.9-dream/drivers/usb/core/config.c
--- linuxppc-2.6.9/drivers/usb/core/config.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/config.c	2005-09-19 21:40:05.000000000 +0200
@@ -1,380 +1,330 @@
-#include <linux/config.h>
-
-#ifdef CONFIG_USB_DEBUG
-#define DEBUG
-#endif
-
 #include <linux/usb.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/device.h>
 #include <asm/byteorder.h>
 
 
 #define USB_MAXALTSETTING		128	/* Hard limit */
 #define USB_MAXENDPOINTS		30	/* Hard limit */
 
-#define USB_MAXCONFIG			8	/* Arbitrary limit */
-
-
-static inline const char *plural(int n)
-{
-	return (n == 1 ? "" : "s");
-}
+/* these maximums are arbitrary */
+#define USB_MAXCONFIG			8
+#define USB_MAXINTERFACES		32
 
-static int find_next_descriptor(unsigned char *buffer, int size,
-    int dt1, int dt2, int *num_skipped)
+static int usb_parse_endpoint(struct usb_host_endpoint *endpoint, unsigned char *buffer, int size)
 {
-	struct usb_descriptor_header *h;
-	int n = 0;
 	unsigned char *buffer0 = buffer;
+	struct usb_descriptor_header *header;
+	unsigned char *begin;
+	int numskipped;
 
-	/* Find the next descriptor of type dt1 or dt2 */
-	while (size > 0) {
-		h = (struct usb_descriptor_header *) buffer;
-		if (h->bDescriptorType == dt1 || h->bDescriptorType == dt2)
-			break;
-		buffer += h->bLength;
-		size -= h->bLength;
-		++n;
+	header = (struct usb_descriptor_header *)buffer;
+	if (header->bDescriptorType != USB_DT_ENDPOINT) {
+		warn("unexpected descriptor 0x%X, expecting endpoint, 0x%X",
+			header->bDescriptorType, USB_DT_ENDPOINT);
+		return -EINVAL;
 	}
 
-	/* Store the number of descriptors skipped and return the
-	 * number of bytes skipped */
-	if (num_skipped)
-		*num_skipped = n;
-	return buffer - buffer0;
-}
-
-static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
-    int asnum, struct usb_host_interface *ifp, int num_ep,
-    unsigned char *buffer, int size)
-{
-	unsigned char *buffer0 = buffer;
-	struct usb_endpoint_descriptor *d;
-	struct usb_host_endpoint *endpoint;
-	int n, i;
-
-	d = (struct usb_endpoint_descriptor *) buffer;
-	buffer += d->bLength;
-	size -= d->bLength;
-
-	if (d->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE)
-		n = USB_DT_ENDPOINT_AUDIO_SIZE;
-	else if (d->bLength >= USB_DT_ENDPOINT_SIZE)
-		n = USB_DT_ENDPOINT_SIZE;
+	if (header->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE)
+		memcpy(&endpoint->desc, buffer, USB_DT_ENDPOINT_AUDIO_SIZE);
+	else if (header->bLength >= USB_DT_ENDPOINT_SIZE)
+		memcpy(&endpoint->desc, buffer, USB_DT_ENDPOINT_SIZE);
 	else {
-		dev_warn(ddev, "config %d interface %d altsetting %d has an "
-		    "invalid endpoint descriptor of length %d, skipping\n",
-		    cfgno, inum, asnum, d->bLength);
-		goto skip_to_next_endpoint_or_interface_descriptor;
+		warn("invalid endpoint descriptor");
+		return -EINVAL;
 	}
 
-	i = d->bEndpointAddress & ~USB_ENDPOINT_DIR_MASK;
-	if (i >= 16 || i == 0) {
-		dev_warn(ddev, "config %d interface %d altsetting %d has an "
-		    "invalid endpoint with address 0x%X, skipping\n",
-		    cfgno, inum, asnum, d->bEndpointAddress);
-		goto skip_to_next_endpoint_or_interface_descriptor;
+	if ((endpoint->desc.bEndpointAddress & ~USB_ENDPOINT_DIR_MASK) >= 16) {
+		warn("invalid endpoint address 0x%X",
+		    endpoint->desc.bEndpointAddress);
+		return -EINVAL;
 	}
 
-	/* Only store as many endpoints as we have room for */
-	if (ifp->desc.bNumEndpoints >= num_ep)
-		goto skip_to_next_endpoint_or_interface_descriptor;
+	le16_to_cpus(&endpoint->desc.wMaxPacketSize);
 
-	endpoint = &ifp->endpoint[ifp->desc.bNumEndpoints];
-	++ifp->desc.bNumEndpoints;
+	buffer += header->bLength;
+	size -= header->bLength;
 
-	memcpy(&endpoint->desc, d, n);
-	le16_to_cpus(&endpoint->desc.wMaxPacketSize);
+	/* Skip over any Class Specific or Vendor Specific descriptors */
+	begin = buffer;
+	numskipped = 0;
+	while (size >= sizeof(struct usb_descriptor_header)) {
+		header = (struct usb_descriptor_header *)buffer;
+
+		/* If we find another "proper" descriptor then we're done  */
+		if ((header->bDescriptorType == USB_DT_ENDPOINT) ||
+		    (header->bDescriptorType == USB_DT_INTERFACE))
+			break;
+
+		dbg("skipping descriptor 0x%X", header->bDescriptorType);
+		numskipped++;
 
-	/* Skip over any Class Specific or Vendor Specific descriptors;
-	 * find the next endpoint or interface descriptor */
-	endpoint->extra = buffer;
-	i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
-	    USB_DT_INTERFACE, &n);
-	endpoint->extralen = i;
-	if (n > 0)
-		dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
-		    n, plural(n), "endpoint");
-	return buffer - buffer0 + i;
-
-skip_to_next_endpoint_or_interface_descriptor:
-	i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
-	    USB_DT_INTERFACE, NULL);
-	return buffer - buffer0 + i;
+		buffer += header->bLength;
+		size -= header->bLength;
+	}
+	if (numskipped) {
+		dbg("skipped %d class/vendor specific endpoint descriptors", numskipped);
+		endpoint->extra = begin;
+		endpoint->extralen = buffer - begin;
+	}
+
+	return buffer - buffer0;
 }
 
-void usb_release_interface_cache(struct kref *ref)
+static void usb_free_intf(struct usb_interface *intf)
 {
-	struct usb_interface_cache *intfc = ref_to_usb_interface_cache(ref);
 	int j;
 
-	for (j = 0; j < intfc->num_altsetting; j++)
-		kfree(intfc->altsetting[j].endpoint);
-	kfree(intfc);
+	if (intf->altsetting) {
+		for (j = 0; j < intf->num_altsetting; j++) {
+			struct usb_host_interface *as = &intf->altsetting[j];
+
+			kfree(as->endpoint);
+		}
+		kfree(intf->altsetting);
+	}
+	kfree(intf);
 }
 
-static int usb_parse_interface(struct device *ddev, int cfgno,
-    struct usb_host_config *config, unsigned char *buffer, int size,
-    u8 inums[], u8 nalts[])
+static int usb_parse_interface(struct usb_host_config *config, unsigned char *buffer, int size)
 {
 	unsigned char *buffer0 = buffer;
 	struct usb_interface_descriptor	*d;
 	int inum, asnum;
-	struct usb_interface_cache *intfc;
-	struct usb_host_interface *alt;
-	int i, n;
-	int len, retval;
-	int num_ep, num_ep_orig;
+	struct usb_interface *interface;
+	struct usb_host_interface *ifp;
+	int len, numskipped;
+	struct usb_descriptor_header *header;
+	unsigned char *begin;
+	int i, retval;
 
 	d = (struct usb_interface_descriptor *) buffer;
-	buffer += d->bLength;
-	size -= d->bLength;
-
-	if (d->bLength < USB_DT_INTERFACE_SIZE)
-		goto skip_to_next_interface_descriptor;
+	if (d->bDescriptorType != USB_DT_INTERFACE) {
+		warn("unexpected descriptor 0x%X, expecting interface, 0x%X",
+			d->bDescriptorType, USB_DT_INTERFACE);
+		return -EINVAL;
+	}
 
-	/* Which interface entry is this? */
-	intfc = NULL;
 	inum = d->bInterfaceNumber;
-	for (i = 0; i < config->desc.bNumInterfaces; ++i) {
-		if (inums[i] == inum) {
-			intfc = config->intf_cache[i];
-			break;
+	if (inum >= config->desc.bNumInterfaces) {
+
+		/* Skip to the next interface descriptor */
+		buffer += d->bLength;
+		size -= d->bLength;
+		while (size >= sizeof(struct usb_descriptor_header)) {
+			header = (struct usb_descriptor_header *) buffer;
+
+			if (header->bDescriptorType == USB_DT_INTERFACE)
+				break;
+			buffer += header->bLength;
+			size -= header->bLength;
 		}
+		return buffer - buffer0;
 	}
-	if (!intfc || intfc->num_altsetting >= nalts[i])
-		goto skip_to_next_interface_descriptor;
 
-	/* Check for duplicate altsetting entries */
+	interface = config->interface[inum];
 	asnum = d->bAlternateSetting;
-	for ((i = 0, alt = &intfc->altsetting[0]);
-	      i < intfc->num_altsetting;
-	     (++i, ++alt)) {
-		if (alt->desc.bAlternateSetting == asnum) {
-			dev_warn(ddev, "Duplicate descriptor for config %d "
-			    "interface %d altsetting %d, skipping\n",
-			    cfgno, inum, asnum);
-			goto skip_to_next_interface_descriptor;
-		}
+	if (asnum >= interface->num_altsetting) {
+		warn("invalid alternate setting %d for interface %d",
+		    asnum, inum);
+		return -EINVAL;
 	}
 
-	++intfc->num_altsetting;
-	memcpy(&alt->desc, d, USB_DT_INTERFACE_SIZE);
-
-	/* Skip over any Class Specific or Vendor Specific descriptors;
-	 * find the first endpoint or interface descriptor */
-	alt->extra = buffer;
-	i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
-	    USB_DT_INTERFACE, &n);
-	alt->extralen = i;
-	if (n > 0)
-		dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
-		    n, plural(n), "interface");
-	buffer += i;
-	size -= i;
-
-	/* Allocate space for the right(?) number of endpoints */
-	num_ep = num_ep_orig = alt->desc.bNumEndpoints;
-	alt->desc.bNumEndpoints = 0;		// Use as a counter
-	if (num_ep > USB_MAXENDPOINTS) {
-		dev_warn(ddev, "too many endpoints for config %d interface %d "
-		    "altsetting %d: %d, using maximum allowed: %d\n",
-		    cfgno, inum, asnum, num_ep, USB_MAXENDPOINTS);
-		num_ep = USB_MAXENDPOINTS;
-	}
-
-	len = sizeof(struct usb_host_endpoint) * num_ep;
-	alt->endpoint = kmalloc(len, GFP_KERNEL);
-	if (!alt->endpoint)
-		return -ENOMEM;
-	memset(alt->endpoint, 0, len);
+	ifp = &interface->altsetting[asnum];
+	if (ifp->desc.bLength) {
+		warn("duplicate descriptor for interface %d altsetting %d",
+		    inum, asnum);
+		return -EINVAL;
+	}
+	memcpy(&ifp->desc, buffer, USB_DT_INTERFACE_SIZE);
+
+	buffer += d->bLength;
+	size -= d->bLength;
 
-	/* Parse all the endpoint descriptors */
-	n = 0;
-	while (size > 0) {
-		if (((struct usb_descriptor_header *) buffer)->bDescriptorType
-		     == USB_DT_INTERFACE)
+	/* Skip over any Class Specific or Vendor Specific descriptors */
+	begin = buffer;
+	numskipped = 0;
+	while (size >= sizeof(struct usb_descriptor_header)) {
+		header = (struct usb_descriptor_header *)buffer;
+
+		/* If we find another "proper" descriptor then we're done  */
+		if ((header->bDescriptorType == USB_DT_INTERFACE) ||
+		    (header->bDescriptorType == USB_DT_ENDPOINT))
 			break;
-		retval = usb_parse_endpoint(ddev, cfgno, inum, asnum, alt,
-		    num_ep, buffer, size);
+
+		dbg("skipping descriptor 0x%X", header->bDescriptorType);
+		numskipped++;
+
+		buffer += header->bLength;
+		size -= header->bLength;
+	}
+	if (numskipped) {
+		dbg("skipped %d class/vendor specific interface descriptors", numskipped);
+		ifp->extra = begin;
+		ifp->extralen = buffer - begin;
+	}
+
+	if (ifp->desc.bNumEndpoints > USB_MAXENDPOINTS) {
+		warn("too many endpoints for interface %d altsetting %d",
+		    inum, asnum);
+		return -EINVAL;
+	}
+
+	len = ifp->desc.bNumEndpoints * sizeof(struct usb_host_endpoint);
+	ifp->endpoint = kmalloc(len, GFP_KERNEL);
+	if (!ifp->endpoint) {
+		err("out of memory");
+		return -ENOMEM;
+	}
+	memset(ifp->endpoint, 0, len);
+
+	for (i = 0; i < ifp->desc.bNumEndpoints; i++) {
+		if (size < USB_DT_ENDPOINT_SIZE) {
+			warn("ran out of descriptors while parsing endpoints");
+			return -EINVAL;
+		}
+
+		retval = usb_parse_endpoint(ifp->endpoint + i, buffer, size);
 		if (retval < 0)
 			return retval;
-		++n;
 
 		buffer += retval;
 		size -= retval;
 	}
 
-	if (n != num_ep_orig)
-		dev_warn(ddev, "config %d interface %d altsetting %d has %d "
-		    "endpoint descriptor%s, different from the interface "
-		    "descriptor's value: %d\n",
-		    cfgno, inum, asnum, n, plural(n), num_ep_orig);
 	return buffer - buffer0;
-
-skip_to_next_interface_descriptor:
-	i = find_next_descriptor(buffer, size, USB_DT_INTERFACE,
-	    USB_DT_INTERFACE, NULL);
-	return buffer - buffer0 + i;
 }
 
-int usb_parse_configuration(struct device *ddev, int cfgidx,
-    struct usb_host_config *config, unsigned char *buffer, int size)
+int usb_parse_configuration(struct usb_host_config *config, char *buffer, int size)
 {
-	unsigned char *buffer0 = buffer;
-	int cfgno;
 	int nintf, nintf_orig;
-	int i, j, n;
-	struct usb_interface_cache *intfc;
-	unsigned char *buffer2;
+	int i, j;
+	struct usb_interface *interface;
+	char *buffer2;
 	int size2;
 	struct usb_descriptor_header *header;
-	int len, retval;
-	u8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];
+	int numskipped, len;
+	char *begin;
+	int retval;
 
 	memcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);
 	if (config->desc.bDescriptorType != USB_DT_CONFIG ||
 	    config->desc.bLength < USB_DT_CONFIG_SIZE) {
-		dev_err(ddev, "invalid descriptor for config index %d: "
-		    "type = 0x%X, length = %d\n", cfgidx,
-		    config->desc.bDescriptorType, config->desc.bLength);
+		warn("invalid configuration descriptor");
 		return -EINVAL;
 	}
-	cfgno = config->desc.bConfigurationValue;
-
-	buffer += config->desc.bLength;
-	size -= config->desc.bLength;
+	config->desc.wTotalLength = size;
 
 	nintf = nintf_orig = config->desc.bNumInterfaces;
 	if (nintf > USB_MAXINTERFACES) {
-		dev_warn(ddev, "config %d has too many interfaces: %d, "
-		    "using maximum allowed: %d\n",
-		    cfgno, nintf, USB_MAXINTERFACES);
-		nintf = USB_MAXINTERFACES;
+		warn("too many interfaces (%d max %d)",
+		    nintf, USB_MAXINTERFACES);
+		config->desc.bNumInterfaces = nintf = USB_MAXINTERFACES;
 	}
 
-	/* Go through the descriptors, checking their length and counting the
-	 * number of altsettings for each interface */
-	n = 0;
-	for ((buffer2 = buffer, size2 = size);
-	      size2 > 0;
-	     (buffer2 += header->bLength, size2 -= header->bLength)) {
-
-		if (size2 < sizeof(struct usb_descriptor_header)) {
-			dev_warn(ddev, "config %d descriptor has %d excess "
-			    "byte%s, ignoring\n",
-			    cfgno, size2, plural(size2));
-			break;
+	for (i = 0; i < nintf; ++i) {
+		interface = config->interface[i] =
+		    kmalloc(sizeof(struct usb_interface), GFP_KERNEL);
+		dbg("kmalloc IF %p, numif %i", interface, i);
+		if (!interface) {
+			err("out of memory");
+			return -ENOMEM;
 		}
+		memset(interface, 0, sizeof(struct usb_interface));
+	}
 
+	/* Go through the descriptors, checking their length and counting the
+	 * number of altsettings for each interface */
+	buffer2 = buffer;
+	size2 = size;
+	j = 0;
+	while (size2 >= sizeof(struct usb_descriptor_header)) {
 		header = (struct usb_descriptor_header *) buffer2;
 		if ((header->bLength > size2) || (header->bLength < 2)) {
-			dev_warn(ddev, "config %d has an invalid descriptor "
-			    "of length %d, skipping remainder of the config\n",
-			    cfgno, header->bLength);
-			break;
+			warn("invalid descriptor of length %d", header->bLength);
+			return -EINVAL;
 		}
 
 		if (header->bDescriptorType == USB_DT_INTERFACE) {
 			struct usb_interface_descriptor *d;
-			int inum;
-
-			d = (struct usb_interface_descriptor *) header;
-			if (d->bLength < USB_DT_INTERFACE_SIZE) {
-				dev_warn(ddev, "config %d has an invalid "
-				    "interface descriptor of length %d, "
-				    "skipping\n", cfgno, d->bLength);
-				continue;
-			}
 
-			inum = d->bInterfaceNumber;
-			if (inum >= nintf_orig)
-				dev_warn(ddev, "config %d has an invalid "
-				    "interface number: %d but max is %d\n",
-				    cfgno, inum, nintf_orig - 1);
-
-			/* Have we already encountered this interface?
-			 * Count its altsettings */
-			for (i = 0; i < n; ++i) {
-				if (inums[i] == inum)
-					break;
+			if (header->bLength < USB_DT_INTERFACE_SIZE) {
+				warn("invalid interface descriptor");
+				return -EINVAL;
 			}
-			if (i < n) {
-				if (nalts[i] < 255)
-					++nalts[i];
-			} else if (n < USB_MAXINTERFACES) {
-				inums[n] = inum;
-				nalts[n] = 1;
-				++n;
+			d = (struct usb_interface_descriptor *) header;
+			i = d->bInterfaceNumber;
+			if (i >= nintf_orig) {
+				warn("invalid interface number (%d/%d)",
+				    i, nintf_orig);
+				return -EINVAL;
 			}
+			if (i < nintf)
+				++config->interface[i]->num_altsetting;
 
-		} else if (header->bDescriptorType == USB_DT_DEVICE ||
-			    header->bDescriptorType == USB_DT_CONFIG)
-			dev_warn(ddev, "config %d contains an unexpected "
-			    "descriptor of type 0x%X, skipping\n",
-			    cfgno, header->bDescriptorType);
-
-	}	/* for ((buffer2 = buffer, size2 = size); ...) */
-	size = buffer2 - buffer;
-	config->desc.wTotalLength = buffer2 - buffer0;
-
-	if (n != nintf)
-		dev_warn(ddev, "config %d has %d interface%s, different from "
-		    "the descriptor's value: %d\n",
-		    cfgno, n, plural(n), nintf_orig);
-	else if (n == 0)
-		dev_warn(ddev, "config %d has no interfaces?\n", cfgno);
-	config->desc.bNumInterfaces = nintf = n;
-
-	/* Check for missing interface numbers */
-	for (i = 0; i < nintf; ++i) {
-		for (j = 0; j < nintf; ++j) {
-			if (inums[j] == i)
-				break;
+		} else if ((header->bDescriptorType == USB_DT_DEVICE ||
+		    header->bDescriptorType == USB_DT_CONFIG) && j) {
+			warn("unexpected descriptor type 0x%X", header->bDescriptorType);
+			return -EINVAL;
 		}
-		if (j >= nintf)
-			dev_warn(ddev, "config %d has no interface number "
-			    "%d\n", cfgno, i);
+
+		j = 1;
+		buffer2 += header->bLength;
+		size2 -= header->bLength;
 	}
 
-	/* Allocate the usb_interface_caches and altsetting arrays */
-	for (i = 0; i < nintf; ++i) {
-		j = nalts[i];
-		if (j > USB_MAXALTSETTING) {
-			dev_warn(ddev, "too many alternate settings for "
-			    "config %d interface %d: %d, "
-			    "using maximum allowed: %d\n",
-			    cfgno, inums[i], j, USB_MAXALTSETTING);
-			nalts[i] = j = USB_MAXALTSETTING;
+	/* Allocate the altsetting arrays */
+	for (i = 0; i < config->desc.bNumInterfaces; ++i) {
+		interface = config->interface[i];
+		if (interface->num_altsetting > USB_MAXALTSETTING) {
+			warn("too many alternate settings for interface %d (%d max %d)\n",
+			    i, interface->num_altsetting, USB_MAXALTSETTING);
+			return -EINVAL;
+		}
+		if (interface->num_altsetting == 0) {
+			warn("no alternate settings for interface %d", i);
+			return -EINVAL;
 		}
 
-		len = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;
-		config->intf_cache[i] = intfc = kmalloc(len, GFP_KERNEL);
-		if (!intfc)
+		len = sizeof(*interface->altsetting) * interface->num_altsetting;
+		interface->altsetting = kmalloc(len, GFP_KERNEL);
+		if (!interface->altsetting) {
+			err("couldn't kmalloc interface->altsetting");
 			return -ENOMEM;
-		memset(intfc, 0, len);
-		kref_init(&intfc->ref);
+		}
+		memset(interface->altsetting, 0, len);
 	}
 
-	/* Skip over any Class Specific or Vendor Specific descriptors;
-	 * find the first interface descriptor */
-	config->extra = buffer;
-	i = find_next_descriptor(buffer, size, USB_DT_INTERFACE,
-	    USB_DT_INTERFACE, &n);
-	config->extralen = i;
-	if (n > 0)
-		dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
-		    n, plural(n), "configuration");
-	buffer += i;
-	size -= i;
+	buffer += config->desc.bLength;
+	size -= config->desc.bLength;
+
+	/* Skip over any Class Specific or Vendor Specific descriptors */
+	begin = buffer;
+	numskipped = 0;
+	while (size >= sizeof(struct usb_descriptor_header)) {
+		header = (struct usb_descriptor_header *)buffer;
+
+		/* If we find another "proper" descriptor then we're done  */
+		if ((header->bDescriptorType == USB_DT_ENDPOINT) ||
+		    (header->bDescriptorType == USB_DT_INTERFACE))
+			break;
+
+		dbg("skipping descriptor 0x%X", header->bDescriptorType);
+		numskipped++;
+
+		buffer += header->bLength;
+		size -= header->bLength;
+	}
+	if (numskipped) {
+		dbg("skipped %d class/vendor specific configuration descriptors", numskipped);
+		config->extra = begin;
+		config->extralen = buffer - begin;
+	}
 
 	/* Parse all the interface/altsetting descriptors */
-	while (size > 0) {
-		retval = usb_parse_interface(ddev, cfgno, config,
-		    buffer, size, inums, nalts);
+	while (size >= sizeof(struct usb_descriptor_header)) {
+		retval = usb_parse_interface(config, buffer, size);
 		if (retval < 0)
 			return retval;
 
@@ -384,20 +334,16 @@
 
 	/* Check for missing altsettings */
 	for (i = 0; i < nintf; ++i) {
-		intfc = config->intf_cache[i];
-		for (j = 0; j < intfc->num_altsetting; ++j) {
-			for (n = 0; n < intfc->num_altsetting; ++n) {
-				if (intfc->altsetting[n].desc.
-				    bAlternateSetting == j)
-					break;
+		interface = config->interface[i];
+		for (j = 0; j < interface->num_altsetting; ++j) {
+			if (!interface->altsetting[j].desc.bLength) {
+				warn("missing altsetting %d for interface %d", j, i);
+				return -EINVAL;
 			}
-			if (n >= intfc->num_altsetting)
-				dev_warn(ddev, "config %d interface %d has no "
-				    "altsetting %d\n", cfgno, inums[i], j);
 		}
 	}
 
-	return 0;
+	return size;
 }
 
 // hub-only!! ... and only exported for reset/reinit path.
@@ -414,20 +360,19 @@
 			kfree(dev->rawdescriptors[i]);
 
 		kfree(dev->rawdescriptors);
-		dev->rawdescriptors = NULL;
 	}
 
 	for (c = 0; c < dev->descriptor.bNumConfigurations; c++) {
 		struct usb_host_config *cf = &dev->config[c];
 
 		for (i = 0; i < cf->desc.bNumInterfaces; i++) {
-			if (cf->intf_cache[i])
-				kref_put(&cf->intf_cache[i]->ref, 
-					  usb_release_interface_cache);
+			struct usb_interface *ifp = cf->interface[i];
+
+			if (ifp)
+				usb_free_intf(ifp);
 		}
 	}
 	kfree(dev->config);
-	dev->config = NULL;
 }
 
 
@@ -435,97 +380,102 @@
 // (used by real hubs and virtual root hubs)
 int usb_get_configuration(struct usb_device *dev)
 {
-	struct device *ddev = &dev->dev;
 	int ncfg = dev->descriptor.bNumConfigurations;
-	int result = -ENOMEM;
+	int result;
 	unsigned int cfgno, length;
 	unsigned char *buffer;
 	unsigned char *bigbuffer;
  	struct usb_config_descriptor *desc;
 
 	if (ncfg > USB_MAXCONFIG) {
-		dev_warn(ddev, "too many configurations: %d, "
-		    "using maximum allowed: %d\n", ncfg, USB_MAXCONFIG);
+		warn("too many configurations (%d max %d)",
+		    ncfg, USB_MAXCONFIG);
 		dev->descriptor.bNumConfigurations = ncfg = USB_MAXCONFIG;
 	}
 
 	if (ncfg < 1) {
-		dev_err(ddev, "no configurations\n");
+		warn("no configurations");
 		return -EINVAL;
 	}
 
 	length = ncfg * sizeof(struct usb_host_config);
 	dev->config = kmalloc(length, GFP_KERNEL);
-	if (!dev->config)
-		goto err2;
+	if (!dev->config) {
+		err("out of memory");
+		return -ENOMEM;
+	}
 	memset(dev->config, 0, length);
 
 	length = ncfg * sizeof(char *);
 	dev->rawdescriptors = kmalloc(length, GFP_KERNEL);
-	if (!dev->rawdescriptors)
-		goto err2;
+	if (!dev->rawdescriptors) {
+		err("out of memory");
+		return -ENOMEM;
+	}
 	memset(dev->rawdescriptors, 0, length);
 
-	buffer = kmalloc(USB_DT_CONFIG_SIZE, GFP_KERNEL);
-	if (!buffer)
-		goto err2;
+	buffer = kmalloc(8, GFP_KERNEL);
+	if (!buffer) {
+		err("unable to allocate memory for configuration descriptors");
+		return -ENOMEM;
+	}
 	desc = (struct usb_config_descriptor *)buffer;
 
 	for (cfgno = 0; cfgno < ncfg; cfgno++) {
-		/* We grab just the first descriptor so we know how long
-		 * the whole configuration is */
-		result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,
-		    buffer, USB_DT_CONFIG_SIZE);
-		if (result < 0) {
-			dev_err(ddev, "unable to read config index %d "
-			    "descriptor/%s\n", cfgno, "start");
-			goto err;
-		} else if (result < 4) {
-			dev_err(ddev, "config index %d descriptor too short "
-			    "(expected %i, got %i)\n", cfgno,
-			    USB_DT_CONFIG_SIZE, result);
-			result = -EINVAL;
+		/* We grab the first 8 bytes so we know how long the whole */
+		/*  configuration is */
+		result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno, buffer, 8);
+		if (result < 8) {
+			if (result < 0)
+				err("unable to get descriptor");
+			else {
+				warn("config descriptor too short (expected %i, got %i)", 8, result);
+				result = -EINVAL;
+			}
 			goto err;
 		}
-		length = max((int) le16_to_cpu(desc->wTotalLength),
-		    USB_DT_CONFIG_SIZE);
 
-		/* Now that we know the length, get the whole thing */
+  	  	/* Get the full buffer */
+		length = max((int) le16_to_cpu(desc->wTotalLength), USB_DT_CONFIG_SIZE);
+
 		bigbuffer = kmalloc(length, GFP_KERNEL);
 		if (!bigbuffer) {
+			err("unable to allocate memory for configuration descriptors");
 			result = -ENOMEM;
 			goto err;
 		}
-		result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,
-		    bigbuffer, length);
+
+		/* Now that we know the length, get the whole thing */
+		result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno, bigbuffer, length);
 		if (result < 0) {
-			dev_err(ddev, "unable to read config index %d "
-			    "descriptor/%s\n", cfgno, "all");
+			err("couldn't get all of config descriptors");
 			kfree(bigbuffer);
 			goto err;
 		}
+
 		if (result < length) {
-			dev_warn(ddev, "config index %d descriptor too short "
-			    "(expected %i, got %i)\n", cfgno, length, result);
-			length = result;
+			err("config descriptor too short (expected %i, got %i)", length, result);
+			result = -EINVAL;
+			kfree(bigbuffer);
+			goto err;
 		}
 
 		dev->rawdescriptors[cfgno] = bigbuffer;
 
-		result = usb_parse_configuration(&dev->dev, cfgno,
-		    &dev->config[cfgno], bigbuffer, length);
-		if (result < 0) {
+		result = usb_parse_configuration(&dev->config[cfgno], bigbuffer, length);
+		if (result > 0)
+			dbg("descriptor data left");
+		else if (result < 0) {
 			++cfgno;
 			goto err;
 		}
 	}
-	result = 0;
 
+	kfree(buffer);
+	return 0;
 err:
 	kfree(buffer);
 	dev->descriptor.bNumConfigurations = cfgno;
-err2:
-	if (result == -ENOMEM)
-		dev_err(ddev, "out of memory\n");
 	return result;
 }
+
diff -Naur linuxppc-2.6.9/drivers/usb/core/devices.c linuxppc-2.6.9-dream/drivers/usb/core/devices.c
--- linuxppc-2.6.9/drivers/usb/core/devices.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/devices.c	2005-09-19 21:40:05.000000000 +0200
@@ -232,21 +232,13 @@
 	return start;
 }
 
-static char *usb_dump_interface_descriptor(char *start, char *end,
-	const struct usb_interface_cache *intfc,
-	const struct usb_interface *iface,
-	int setno)
+static char *usb_dump_interface_descriptor(char *start, char *end, const struct usb_interface *iface, int setno)
 {
-	const struct usb_interface_descriptor *desc = &intfc->altsetting[setno].desc;
-	char *driver_name = "";
+	struct usb_interface_descriptor *desc = &iface->altsetting[setno].desc;
 
 	if (start > end)
 		return start;
-	down_read(&usb_bus_type.subsys.rwsem);
-	if (iface)
-		driver_name = (iface->dev.driver
-				? iface->dev.driver->name
-				: "(none)");
+	lock_kernel(); /* driver might be unloaded */
 	start += sprintf(start, format_iface,
 			 desc->bInterfaceNumber,
 			 desc->bAlternateSetting,
@@ -255,8 +247,8 @@
 			 class_decode(desc->bInterfaceClass),
 			 desc->bInterfaceSubClass,
 			 desc->bInterfaceProtocol,
-			 driver_name);
-	up_read(&usb_bus_type.subsys.rwsem);
+			 iface->driver ? iface->driver->name : "(none)");
+	unlock_kernel();
 	return start;
 }
 
@@ -264,14 +256,13 @@
 	int speed,
 	char *start,
 	char *end,
-	const struct usb_interface_cache *intfc,
 	const struct usb_interface *iface,
 	int setno
 ) {
-	const struct usb_host_interface *desc = &intfc->altsetting[setno];
+	struct usb_host_interface *desc = &iface->altsetting[setno];
 	int i;
 
-	start = usb_dump_interface_descriptor(start, end, intfc, iface, setno);
+	start = usb_dump_interface_descriptor(start, end, iface, setno);
 	for (i = 0; i < desc->desc.bNumEndpoints; i++) {
 		if (start > end)
 			return start;
@@ -283,8 +274,9 @@
 
 /* TBD:
  * 0. TBDs
- * 1. marking active interface altsettings (code lists all, but should mark
+ * 1. marking active config and ifaces (code lists all, but should mark
  *    which ones are active, if any)
+ * 2. add <halted> status to each endpoint line
  */
 
 static char *usb_dump_config_descriptor(char *start, char *end, const struct usb_config_descriptor *desc, int active)
@@ -309,7 +301,6 @@
 )
 {
 	int i, j;
-	struct usb_interface_cache *intfc;
 	struct usb_interface *interface;
 
 	if (start > end)
@@ -318,13 +309,14 @@
 		return start + sprintf(start, "(null Cfg. desc.)\n");
 	start = usb_dump_config_descriptor(start, end, &config->desc, active);
 	for (i = 0; i < config->desc.bNumInterfaces; i++) {
-		intfc = config->intf_cache[i];
 		interface = config->interface[i];
-		for (j = 0; j < intfc->num_altsetting; j++) {
+		if (!interface)
+			break;
+		for (j = 0; j < interface->num_altsetting; j++) {
 			if (start > end)
 				return start;
 			start = usb_dump_interface(speed,
-				start, end, intfc, interface, j);
+					start, end, interface, j);
 		}
 	}
 	return start;
@@ -401,7 +393,7 @@
 		return start;
 	
 	start = usb_dump_device_strings (start, end, dev);
-
+	
 	for (i = 0; i < dev->descriptor.bNumConfigurations; i++) {
 		if (start > end)
 			return start;
@@ -451,7 +443,6 @@
  * nbytes - the maximum number of bytes to write
  * skip_bytes - the number of bytes to skip before writing anything
  * file_offset - the offset into the devices file on completion
- * The caller must own the usbdev->serialize semaphore.
  */
 static ssize_t usb_device_dump(char __user **buffer, size_t *nbytes, loff_t *skip_bytes, loff_t *file_offset,
 				struct usb_device *usbdev, struct usb_bus *bus, int level, int index, int count)
@@ -552,13 +543,9 @@
 	
 	/* Now look at all of this device's children. */
 	for (chix = 0; chix < usbdev->maxchild; chix++) {
-		struct usb_device *childdev = usbdev->children[chix];
-
-		if (childdev) {
-			down(&childdev->serialize);
-			ret = usb_device_dump(buffer, nbytes, skip_bytes, file_offset, childdev,
+		if (usbdev->children[chix]) {
+			ret = usb_device_dump(buffer, nbytes, skip_bytes, file_offset, usbdev->children[chix],
 					bus, level + 1, chix, ++cnt);
-			up(&childdev->serialize);
 			if (ret == -EFAULT)
 				return total_written;
 			total_written += ret;
@@ -583,16 +570,11 @@
 
 	/* enumerate busses */
 	down (&usb_bus_list_lock);
-	list_for_each(buslist, &usb_bus_list) {
+	for (buslist = usb_bus_list.next; buslist != &usb_bus_list; buslist = buslist->next) {
 		/* print devices for this bus */
 		bus = list_entry(buslist, struct usb_bus, bus_list);
-
 		/* recurse through all children of the root hub */
-		if (!bus->root_hub)
-			continue;
-		down(&bus->root_hub->serialize);
 		ret = usb_device_dump(&buf, &nbytes, &skip_bytes, ppos, bus->root_hub, bus, 0, 0, 0);
-		up(&bus->root_hub->serialize);
 		if (ret < 0) {
 			up(&usb_bus_list_lock);
 			return ret;
diff -Naur linuxppc-2.6.9/drivers/usb/core/devio.c linuxppc-2.6.9-dream/drivers/usb/core/devio.c
--- linuxppc-2.6.9/drivers/usb/core/devio.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/devio.c	2005-09-19 21:40:05.000000000 +0200
@@ -45,7 +45,6 @@
 #include <linux/usbdevice_fs.h>
 #include <asm/uaccess.h>
 #include <asm/byteorder.h>
-#include <linux/moduleparam.h>
 
 #include "hcd.h"	/* for usbcore internals */
 #include "usb.h"
@@ -55,30 +54,12 @@
 	struct dev_state *ps;
 	struct task_struct *task;
 	unsigned int signr;
-	unsigned int ifnum;
+	unsigned int intf;
 	void __user *userbuffer;
 	void __user *userurb;
 	struct urb *urb;
 };
 
-static int usbfs_snoop = 0;
-module_param (usbfs_snoop, bool, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC (usbfs_snoop, "true to log all usbfs traffic");
-
-#define snoop(dev, format, arg...)				\
-	do {							\
-		if (usbfs_snoop)				\
-			dev_info( dev , format , ## arg);	\
-	} while (0)
-
-
-#define	MAX_USBFS_BUFFER_SIZE	16384
-
-static inline int connected (struct usb_device *dev)
-{
-	return dev->state != USB_STATE_NOTATTACHED;
-}
-
 static loff_t usbdev_lseek(struct file *file, loff_t offset, int orig)
 {
 	loff_t ret;
@@ -106,15 +87,14 @@
 static ssize_t usbdev_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 {
 	struct dev_state *ps = (struct dev_state *)file->private_data;
-	struct usb_device *dev = ps->dev;
 	ssize_t ret = 0;
 	unsigned len;
 	loff_t pos;
 	int i;
 
 	pos = *ppos;
-	down(&dev->serialize);
-	if (!connected(dev)) {
+	down_read(&ps->devsem);
+	if (!ps->dev) {
 		ret = -ENODEV;
 		goto err;
 	} else if (pos < 0) {
@@ -126,7 +106,7 @@
 		len = sizeof(struct usb_device_descriptor) - pos;
 		if (len > nbytes)
 			len = nbytes;
-		if (copy_to_user(buf, ((char *)&dev->descriptor) + pos, len)) {
+		if (copy_to_user(buf, ((char *)&ps->dev->descriptor) + pos, len)) {
 			ret = -EFAULT;
 			goto err;
 		}
@@ -138,31 +118,20 @@
 	}
 
 	pos = sizeof(struct usb_device_descriptor);
-	for (i = 0; nbytes && i < dev->descriptor.bNumConfigurations; i++) {
+	for (i = 0; nbytes && i < ps->dev->descriptor.bNumConfigurations; i++) {
 		struct usb_config_descriptor *config =
-			(struct usb_config_descriptor *)dev->rawdescriptors[i];
+			(struct usb_config_descriptor *)ps->dev->rawdescriptors[i];
 		unsigned int length = le16_to_cpu(config->wTotalLength);
 
 		if (*ppos < pos + length) {
-
-			/* The descriptor may claim to be longer than it
-			 * really is.  Here is the actual allocated length. */
-			unsigned alloclen =
-				dev->config[i].desc.wTotalLength;
-
 			len = length - (*ppos - pos);
 			if (len > nbytes)
 				len = nbytes;
 
-			/* Simply don't write (skip over) unallocated parts */
-			if (alloclen > (*ppos - pos)) {
-				alloclen -= (*ppos - pos);
-				if (copy_to_user(buf,
-				    dev->rawdescriptors[i] + (*ppos - pos),
-				    min(len, alloclen))) {
-					ret = -EFAULT;
-					goto err;
-				}
+			if (copy_to_user(buf,
+			    ps->dev->rawdescriptors[i] + (*ppos - pos), len)) {
+				ret = -EFAULT;
+				goto err;
 			}
 
 			*ppos += len;
@@ -175,10 +144,35 @@
 	}
 
 err:
-	up(&dev->serialize);
+	up_read(&ps->devsem);
 	return ret;
 }
 
+extern inline unsigned int ld2(unsigned int x)
+{
+        unsigned int r = 0;
+        
+        if (x >= 0x10000) {
+                x >>= 16;
+                r += 16;
+        }
+        if (x >= 0x100) {
+                x >>= 8;
+                r += 8;
+        }
+        if (x >= 0x10) {
+                x >>= 4;
+                r += 4;
+        }
+        if (x >= 4) {
+                x >>= 2;
+                r += 2;
+        }
+        if (x >= 2)
+                r++;
+        return r;
+}
+
 /*
  * async list handling
  */
@@ -208,7 +202,7 @@
         kfree(as);
 }
 
-static inline void async_newpending(struct async *as)
+extern __inline__ void async_newpending(struct async *as)
 {
         struct dev_state *ps = as->ps;
         unsigned long flags;
@@ -218,7 +212,7 @@
         spin_unlock_irqrestore(&ps->lock, flags);
 }
 
-static inline void async_removepending(struct async *as)
+extern __inline__ void async_removepending(struct async *as)
 {
         struct dev_state *ps = as->ps;
         unsigned long flags;
@@ -228,7 +222,7 @@
         spin_unlock_irqrestore(&ps->lock, flags);
 }
 
-static inline struct async *async_getcompleted(struct dev_state *ps)
+extern __inline__ struct async *async_getcompleted(struct dev_state *ps)
 {
         unsigned long flags;
         struct async *as = NULL;
@@ -242,7 +236,7 @@
         return as;
 }
 
-static inline struct async *async_getpending(struct dev_state *ps, void __user *userurb)
+extern __inline__ struct async *async_getpending(struct dev_state *ps, void __user *userurb)
 {
         unsigned long flags;
         struct async *as;
@@ -271,7 +265,7 @@
 		sinfo.si_signo = as->signr;
 		sinfo.si_errno = as->urb->status;
 		sinfo.si_code = SI_ASYNCIO;
-		sinfo.si_addr = as->userurb;
+		sinfo.si_addr = (void *)as->userurb;
 		send_sig_info(as->signr, &sinfo, as->task);
 	}
         wake_up(&ps->wait);
@@ -292,14 +286,11 @@
 		spin_lock_irqsave(&ps->lock, flags);
 	}
 	spin_unlock_irqrestore(&ps->lock, flags);
-	as = async_getcompleted(ps);
-	while (as) {
+	while ((as = async_getcompleted(ps)))
 		free_async(as);
-		as = async_getcompleted(ps);
-	}
 }
 
-static void destroy_async_on_interface (struct dev_state *ps, unsigned int ifnum)
+static void destroy_async_on_interface (struct dev_state *ps, unsigned int intf)
 {
 	struct list_head *p, *q, hitlist;
 	unsigned long flags;
@@ -307,13 +298,13 @@
 	INIT_LIST_HEAD(&hitlist);
 	spin_lock_irqsave(&ps->lock, flags);
 	list_for_each_safe(p, q, &ps->async_pending)
-		if (ifnum == list_entry(p, struct async, asynclist)->ifnum)
+		if (intf == list_entry(p, struct async, asynclist)->intf)
 			list_move_tail(p, &hitlist);
 	spin_unlock_irqrestore(&ps->lock, flags);
 	destroy_async(ps, &hitlist);
 }
 
-static inline void destroy_all_async(struct dev_state *ps)
+extern __inline__ void destroy_all_async(struct dev_state *ps)
 {
 	        destroy_async(ps, &ps->async_pending);
 }
@@ -333,24 +324,22 @@
 static void driver_disconnect(struct usb_interface *intf)
 {
 	struct dev_state *ps = usb_get_intfdata (intf);
-	unsigned int ifnum = intf->altsetting->desc.bInterfaceNumber;
 
 	if (!ps)
 		return;
 
-	/* NOTE:  this relies on usbcore having canceled and completed
-	 * all pending I/O requests; 2.6 does that.
-	 */
-
-	if (likely(ifnum < 8*sizeof(ps->ifclaimed)))
-		clear_bit(ifnum, &ps->ifclaimed);
-	else
-		warn("interface number %u out of range", ifnum);
+	/* this waits till synchronous requests complete */
+	down_write (&ps->devsem);
 
+	/* prevent new I/O requests */
+	ps->dev = 0;
+	ps->ifclaimed = 0;
 	usb_set_intfdata (intf, NULL);
 
 	/* force async requests to complete */
-	destroy_async_on_interface(ps, ifnum);
+	destroy_all_async (ps);
+
+	up_write (&ps->devsem);
 }
 
 struct usb_driver usbdevfs_driver = {
@@ -360,110 +349,122 @@
 	.disconnect =	driver_disconnect,
 };
 
-static int claimintf(struct dev_state *ps, unsigned int ifnum)
+static int claimintf(struct dev_state *ps, unsigned int intf)
 {
 	struct usb_device *dev = ps->dev;
-	struct usb_interface *intf;
+	struct usb_interface *iface;
 	int err;
 
-	if (ifnum >= 8*sizeof(ps->ifclaimed))
+	if (intf >= 8*sizeof(ps->ifclaimed) || !dev
+			|| intf >= dev->actconfig->desc.bNumInterfaces)
 		return -EINVAL;
 	/* already claimed */
-	if (test_bit(ifnum, &ps->ifclaimed))
+	if (test_bit(intf, &ps->ifclaimed))
 		return 0;
-
-	/* lock against other changes to driver bindings */
-	down_write(&usb_bus_type.subsys.rwsem);
-	intf = usb_ifnum_to_if(dev, ifnum);
-	if (!intf)
-		err = -ENOENT;
-	else
-		err = usb_driver_claim_interface(&usbdevfs_driver, intf, ps);
-	up_write(&usb_bus_type.subsys.rwsem);
-	if (err == 0)
-		set_bit(ifnum, &ps->ifclaimed);
+	iface = dev->actconfig->interface[intf];
+	err = -EBUSY;
+	lock_kernel();
+	if (!usb_interface_claimed(iface)) {
+		usb_driver_claim_interface(&usbdevfs_driver, iface, ps);
+		set_bit(intf, &ps->ifclaimed);
+		err = 0;
+	}
+	unlock_kernel();
 	return err;
 }
 
-static int releaseintf(struct dev_state *ps, unsigned int ifnum)
+static int releaseintf(struct dev_state *ps, unsigned int intf)
 {
 	struct usb_device *dev;
-	struct usb_interface *intf;
+	struct usb_interface *iface;
 	int err;
 
+	if (intf >= 8*sizeof(ps->ifclaimed))
+		return -EINVAL;
 	err = -EINVAL;
-	if (ifnum >= 8*sizeof(ps->ifclaimed))
-		return err;
 	dev = ps->dev;
-	/* lock against other changes to driver bindings */
-	down_write(&usb_bus_type.subsys.rwsem);
-	intf = usb_ifnum_to_if(dev, ifnum);
-	if (!intf)
-		err = -ENOENT;
-	else if (test_and_clear_bit(ifnum, &ps->ifclaimed)) {
-		usb_driver_release_interface(&usbdevfs_driver, intf);
+	down(&dev->serialize);
+	if (test_and_clear_bit(intf, &ps->ifclaimed)) {
+		iface = dev->actconfig->interface[intf];
+		usb_driver_release_interface(&usbdevfs_driver, iface);
 		err = 0;
 	}
-	up_write(&usb_bus_type.subsys.rwsem);
+	up(&dev->serialize);
 	return err;
 }
 
-static int checkintf(struct dev_state *ps, unsigned int ifnum)
+static int checkintf(struct dev_state *ps, unsigned int intf)
 {
-	if (ifnum >= 8*sizeof(ps->ifclaimed))
+	if (intf >= 8*sizeof(ps->ifclaimed))
 		return -EINVAL;
-	if (test_bit(ifnum, &ps->ifclaimed))
+	if (test_bit(intf, &ps->ifclaimed))
 		return 0;
 	/* if not yet claimed, claim it for the driver */
-	dev_warn(&ps->dev->dev, "usbfs: process %d (%s) did not claim interface %u before use\n",
-	       current->pid, current->comm, ifnum);
-	return claimintf(ps, ifnum);
+	printk(KERN_WARNING "usbfs: process %d (%s) did not claim interface %u before use\n",
+	       current->pid, current->comm, intf);
+	return claimintf(ps, intf);
 }
 
 static int findintfep(struct usb_device *dev, unsigned int ep)
 {
 	unsigned int i, j, e;
-        struct usb_interface *intf;
+        struct usb_interface *iface;
 	struct usb_host_interface *alts;
 	struct usb_endpoint_descriptor *endpt;
 
 	if (ep & ~(USB_DIR_IN|0xf))
 		return -EINVAL;
-	if (!dev->actconfig)
-		return -ESRCH;
 	for (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {
-		intf = dev->actconfig->interface[i];
-		for (j = 0; j < intf->num_altsetting; j++) {
-                        alts = &intf->altsetting[j];
+		iface = dev->actconfig->interface[i];
+		for (j = 0; j < iface->num_altsetting; j++) {
+                        alts = &iface->altsetting[j];
 			for (e = 0; e < alts->desc.bNumEndpoints; e++) {
 				endpt = &alts->endpoint[e].desc;
 				if (endpt->bEndpointAddress == ep)
-					return alts->desc.bInterfaceNumber;
+					return i;
 			}
 		}
 	}
 	return -ENOENT; 
 }
 
+static int findintfif(struct usb_device *dev, unsigned int ifn)
+{
+	unsigned int i;
+
+	if (ifn & ~0xff)
+		return -EINVAL;
+	for (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {
+		if (dev->actconfig->interface[i]->
+				altsetting[0].desc.bInterfaceNumber == ifn)
+			return i;
+	}
+	return -ENOENT; 
+}
+
 static int check_ctrlrecip(struct dev_state *ps, unsigned int requesttype, unsigned int index)
 {
-	int ret = 0;
+	int ret;
 
 	if (USB_TYPE_VENDOR == (USB_TYPE_MASK & requesttype))
 		return 0;
 
-	index &= 0xff;
 	switch (requesttype & USB_RECIP_MASK) {
 	case USB_RECIP_ENDPOINT:
-		if ((ret = findintfep(ps->dev, index)) >= 0)
-			ret = checkintf(ps, ret);
+		if ((ret = findintfep(ps->dev, index & 0xff)) < 0)
+			return ret;
+		if ((ret = checkintf(ps, ret)))
+			return ret;
 		break;
 
 	case USB_RECIP_INTERFACE:
-		ret = checkintf(ps, index);
+		if ((ret = findintfif(ps->dev, index & 0xff)) < 0)
+			return ret;
+		if ((ret = checkintf(ps, ret)))
+			return ret;
 		break;
 	}
-	return ret;
+	return 0;
 }
 
 /*
@@ -476,7 +477,8 @@
 	int ret;
 
 	/* 
-	 * no locking necessary here, as chrdev_open has the kernel lock
+	 * no locking necessary here, as both sys_open (actually filp_open)
+	 * and the hub thread have the kernel lock
 	 * (still acquire the kernel lock for safety)
 	 */
 	ret = -ENOMEM;
@@ -485,7 +487,7 @@
 
 	lock_kernel();
 	ret = -ENOENT;
-	dev = usb_get_dev(inode->u.generic_ip);
+	dev = inode->u.generic_ip;
 	if (!dev) {
 		kfree(ps);
 		goto out;
@@ -497,6 +499,7 @@
 	INIT_LIST_HEAD(&ps->async_pending);
 	INIT_LIST_HEAD(&ps->async_completed);
 	init_waitqueue_head(&ps->wait);
+	init_rwsem(&ps->devsem);
 	ps->discsignr = 0;
 	ps->disctask = current;
 	ps->disccontext = NULL;
@@ -513,21 +516,18 @@
 static int usbdev_release(struct inode *inode, struct file *file)
 {
 	struct dev_state *ps = (struct dev_state *)file->private_data;
-	struct usb_device *dev = ps->dev;
-	unsigned int ifnum;
+	unsigned int i;
 
-	down(&dev->serialize);
+	lock_kernel();
 	list_del_init(&ps->list);
 
-	if (connected(dev)) {
-		for (ifnum = 0; ps->ifclaimed && ifnum < 8*sizeof(ps->ifclaimed); ifnum++)
-			if (test_bit(ifnum, &ps->ifclaimed))
-				releaseintf(ps, ifnum);
-		destroy_all_async(ps);
+	if (ps->dev) {
+		for (i = 0; ps->ifclaimed && i < 8*sizeof(ps->ifclaimed); i++)
+			if (test_bit(i, &ps->ifclaimed))
+				releaseintf(ps, i);
 	}
-	up(&dev->serialize);
-	usb_put_dev(dev);
-	ps->dev = NULL;
+	unlock_kernel();
+	destroy_all_async(ps);
 	kfree(ps);
         return 0;
 }
@@ -538,7 +538,7 @@
 	struct usbdevfs_ctrltransfer ctrl;
 	unsigned int tmo;
 	unsigned char *tbuf;
-	int i, j, ret;
+	int i, ret;
 
 	if (copy_from_user(&ctrl, arg, sizeof(ctrl)))
 		return -EFAULT;
@@ -554,20 +554,9 @@
 			free_page((unsigned long)tbuf);
 			return -EINVAL;
 		}
-		snoop(&dev->dev, "control read: bRequest=%02x bRrequestType=%02x wValue=%04x wIndex=%04x\n", 
-			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue, ctrl.wIndex);
-
-		up(&dev->serialize);
 		i = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), ctrl.bRequest, ctrl.bRequestType,
 				       ctrl.wValue, ctrl.wIndex, tbuf, ctrl.wLength, tmo);
-		down(&dev->serialize);
 		if ((i > 0) && ctrl.wLength) {
-			if (usbfs_snoop) {
-				dev_info(&dev->dev, "control read: data ");
-				for (j = 0; j < ctrl.wLength; ++j)
-					printk ("%02x ", (unsigned char)(tbuf)[j]);
-				printk("\n");
-			}
 			if (copy_to_user(ctrl.data, tbuf, ctrl.wLength)) {
 				free_page((unsigned long)tbuf);
 				return -EFAULT;
@@ -580,25 +569,15 @@
 				return -EFAULT;
 			}
 		}
-		snoop(&dev->dev, "control write: bRequest=%02x bRrequestType=%02x wValue=%04x wIndex=%04x\n", 
-			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue, ctrl.wIndex);
-		if (usbfs_snoop) {
-			dev_info(&dev->dev, "control write: data: ");
-			for (j = 0; j < ctrl.wLength; ++j)
-				printk ("%02x ", (unsigned char)(tbuf)[j]);
-			printk("\n");
-		}
-		up(&dev->serialize);
 		i = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), ctrl.bRequest, ctrl.bRequestType,
 				       ctrl.wValue, ctrl.wIndex, tbuf, ctrl.wLength, tmo);
-		down(&dev->serialize);
 	}
 	free_page((unsigned long)tbuf);
 	if (i<0) {
-		dev_printk(KERN_DEBUG, &dev->dev, "usbfs: USBDEVFS_CONTROL "
-			   "failed cmd %s rqt %u rq %u len %u ret %d\n",
-			   current->comm, ctrl.bRequestType, ctrl.bRequest,
-			   ctrl.wLength, i);
+		printk(KERN_DEBUG "usbfs: USBDEVFS_CONTROL failed "
+			"cmd %s dev %d rqt %u rq %u len %u ret %d\n", 
+			current->comm,
+		       dev->devnum, ctrl.bRequestType, ctrl.bRequest, ctrl.wLength, i);
 	}
 	return i;
 }
@@ -625,8 +604,6 @@
 	if (!usb_maxpacket(dev, pipe, !(bulk.ep & USB_DIR_IN)))
 		return -EINVAL;
 	len1 = bulk.len;
-	if (len1 > MAX_USBFS_BUFFER_SIZE)
-		return -EINVAL;
 	if (!(tbuf = kmalloc(len1, GFP_KERNEL)))
 		return -ENOMEM;
 	tmo = (bulk.timeout * HZ + 999) / 1000;
@@ -635,9 +612,7 @@
 			kfree(tbuf);
 			return -EINVAL;
 		}
-		up(&dev->serialize);
 		i = usb_bulk_msg(dev, pipe, tbuf, len1, &len2, tmo);
-		down(&dev->serialize);
 		if (!i && len2) {
 			if (copy_to_user(bulk.data, tbuf, len2)) {
 				kfree(tbuf);
@@ -651,14 +626,12 @@
 				return -EFAULT;
 			}
 		}
-		up(&dev->serialize);
 		i = usb_bulk_msg(dev, pipe, tbuf, len1, &len2, tmo);
-		down(&dev->serialize);
 	}
 	kfree(tbuf);
 	if (i < 0) {
-		dev_warn(&dev->dev, "usbfs: USBDEVFS_BULK failed "
-			 "ep 0x%x len %u ret %d\n", bulk.ep, bulk.len, i);
+		printk(KERN_WARNING "usbfs: USBDEVFS_BULK failed dev %d ep 0x%x len %u ret %d\n", 
+		       dev->devnum, bulk.ep, bulk.len, i);
 		return i;
 	}
 	return len2;
@@ -703,22 +676,20 @@
 static int proc_getdriver(struct dev_state *ps, void __user *arg)
 {
 	struct usbdevfs_getdriver gd;
-	struct usb_interface *intf;
+	struct usb_interface *interface;
 	int ret;
 
 	if (copy_from_user(&gd, arg, sizeof(gd)))
 		return -EFAULT;
-	down_read(&usb_bus_type.subsys.rwsem);
-	intf = usb_ifnum_to_if(ps->dev, gd.interface);
-	if (!intf || !intf->dev.driver)
-		ret = -ENODATA;
-	else {
-		strncpy(gd.driver, intf->dev.driver->name,
-				sizeof(gd.driver));
-		ret = (copy_to_user(arg, &gd, sizeof(gd)) ? -EFAULT : 0);
-	}
-	up_read(&usb_bus_type.subsys.rwsem);
-	return ret;
+	if ((ret = findintfif(ps->dev, gd.interface)) < 0)
+		return ret;
+	interface = ps->dev->actconfig->interface[ret];
+	if (!interface->driver)
+		return -ENODATA;
+	strcpy(gd.driver, interface->driver->name);
+	if (copy_to_user(arg, &gd, sizeof(gd)))
+		return -EFAULT;
+	return 0;
 }
 
 static int proc_connectinfo(struct dev_state *ps, void __user *arg)
@@ -734,69 +705,55 @@
 
 static int proc_resetdevice(struct dev_state *ps)
 {
-	return __usb_reset_device(ps->dev);
+	int i, ret;
+
+	ret = usb_reset_device(ps->dev);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < ps->dev->actconfig->desc.bNumInterfaces; i++) {
+		struct usb_interface *intf = ps->dev->actconfig->interface[i];
 
+		/* Don't simulate interfaces we've claimed */
+		if (test_bit(i, &ps->ifclaimed))
+			continue;
+
+		err ("%s - this function is broken", __FUNCTION__);
+		if (intf->driver && ps->dev) {
+			usb_probe_interface (&intf->dev);
+		}
+	}
+
+	return 0;
 }
 
 static int proc_setintf(struct dev_state *ps, void __user *arg)
 {
 	struct usbdevfs_setinterface setintf;
+	struct usb_interface *interface;
 	int ret;
 
 	if (copy_from_user(&setintf, arg, sizeof(setintf)))
 		return -EFAULT;
-	if ((ret = checkintf(ps, setintf.interface)))
+	if ((ret = findintfif(ps->dev, setintf.interface)) < 0)
 		return ret;
-	return usb_set_interface(ps->dev, setintf.interface,
-			setintf.altsetting);
+	interface = ps->dev->actconfig->interface[ret];
+	if (interface->driver) {
+		if ((ret = checkintf(ps, ret)))
+			return ret;
+	}
+	if (usb_set_interface(ps->dev, setintf.interface, setintf.altsetting))
+		return -EINVAL;
+	return 0;
 }
 
 static int proc_setconfig(struct dev_state *ps, void __user *arg)
 {
 	unsigned int u;
-	int status = 0;
- 	struct usb_host_config *actconfig;
 
 	if (get_user(u, (unsigned int __user *)arg))
 		return -EFAULT;
-
- 	actconfig = ps->dev->actconfig;
- 
- 	/* Don't touch the device if any interfaces are claimed.
- 	 * It could interfere with other drivers' operations, and if
-	 * an interface is claimed by usbfs it could easily deadlock.
-	 */
- 	if (actconfig) {
- 		int i;
- 
- 		for (i = 0; i < actconfig->desc.bNumInterfaces; ++i) {
- 			if (usb_interface_claimed(actconfig->interface[i])) {
-				dev_warn (&ps->dev->dev,
-					"usbfs: interface %d claimed "
-					"while '%s' sets config #%d\n",
-					actconfig->interface[i]
-						->cur_altsetting
-						->desc.bInterfaceNumber,
-					current->comm, u);
-#if 0	/* FIXME:  enable in 2.6.10 or so */
- 				status = -EBUSY;
-				break;
-#endif
-			}
- 		}
- 	}
-
-	/* SET_CONFIGURATION is often abused as a "cheap" driver reset,
-	 * so avoid usb_set_configuration()'s kick to sysfs
-	 */
-	if (status == 0) {
-		if (actconfig && actconfig->desc.bConfigurationValue == u)
-			status = usb_reset_configuration(ps->dev);
-		else
-			status = usb_set_configuration(ps->dev, u);
-	}
-
-	return status;
+	return usb_set_configuration(ps->dev, u);
 }
 
 static int proc_submiturb(struct dev_state *ps, void __user *arg)
@@ -807,7 +764,7 @@
 	struct async *as;
 	struct usb_ctrlrequest *dr = NULL;
 	unsigned int u, totlen, isofrmlen;
-	int ret, interval = 0, ifnum = -1;
+	int ret, interval = 0, intf = -1;
 
 	if (copy_from_user(&uurb, arg, sizeof(uurb)))
 		return -EFAULT;
@@ -819,9 +776,9 @@
 	if (uurb.signr != 0 && (uurb.signr < SIGRTMIN || uurb.signr > SIGRTMAX))
 		return -EINVAL;
 	if (!(uurb.type == USBDEVFS_URB_TYPE_CONTROL && (uurb.endpoint & ~USB_ENDPOINT_DIR_MASK) == 0)) {
-		if ((ifnum = findintfep(ps->dev, uurb.endpoint)) < 0)
-			return ifnum;
-		if ((ret = checkintf(ps, ifnum)))
+		if ((intf = findintfep(ps->dev, uurb.endpoint)) < 0)
+			return intf;
+		if ((ret = checkintf(ps, intf)))
 			return ret;
 	}
 	switch(uurb.type) {
@@ -861,7 +818,7 @@
 
 	case USBDEVFS_URB_TYPE_BULK:
 		uurb.number_of_packets = 0;
-		if (uurb.buffer_length > MAX_USBFS_BUFFER_SIZE)
+		if (uurb.buffer_length > 16384)
 			return -EINVAL;
 		if (!access_ok((uurb.endpoint & USB_DIR_IN) ? VERIFY_WRITE : VERIFY_READ, uurb.buffer, uurb.buffer_length))
 			return -EFAULT;
@@ -871,13 +828,10 @@
 		/* arbitrary limit */
 		if (uurb.number_of_packets < 1 || uurb.number_of_packets > 128)
 			return -EINVAL;
-		if (!(ep_desc = usb_epnum_to_ep_desc(ps->dev, uurb.endpoint)))
-			return -ENOENT;
-		interval = 1 << min (15, ep_desc->bInterval - 1);
 		isofrmlen = sizeof(struct usbdevfs_iso_packet_desc) * uurb.number_of_packets;
 		if (!(isopkt = kmalloc(isofrmlen, GFP_KERNEL)))
 			return -ENOMEM;
-		if (copy_from_user(isopkt, &((struct usbdevfs_urb __user *)arg)->iso_frame_desc, isofrmlen)) {
+		if (copy_from_user(isopkt, &((struct usbdevfs_urb *)arg)->iso_frame_desc, isofrmlen)) {
 			kfree(isopkt);
 			return -EFAULT;
 		}
@@ -899,11 +853,8 @@
 		uurb.number_of_packets = 0;
 		if (!(ep_desc = usb_epnum_to_ep_desc(ps->dev, uurb.endpoint)))
 			return -ENOENT;
-		if (ps->dev->speed == USB_SPEED_HIGH)
-			interval = 1 << min (15, ep_desc->bInterval - 1);
-		else
-			interval = ep_desc->bInterval;
-		if (uurb.buffer_length > MAX_USBFS_BUFFER_SIZE)
+		interval = ep_desc->bInterval;
+		if (uurb.buffer_length > 16384)
 			return -EINVAL;
 		if (!access_ok((uurb.endpoint & USB_DIR_IN) ? VERIFY_WRITE : VERIFY_READ, uurb.buffer, uurb.buffer_length))
 			return -EFAULT;
@@ -951,7 +902,7 @@
 	else
 		as->userbuffer = NULL;
 	as->signr = uurb.signr;
-	as->ifnum = ifnum;
+	as->intf = intf;
 	as->task = current;
 	if (!(uurb.endpoint & USB_DIR_IN)) {
 		if (copy_from_user(as->urb->transfer_buffer, uurb.buffer, as->urb->transfer_buffer_length)) {
@@ -961,7 +912,7 @@
 	}
         async_newpending(as);
         if ((ret = usb_submit_urb(as->urb, GFP_KERNEL))) {
-		dev_printk(KERN_DEBUG, &ps->dev->dev, "usbfs: usb_submit_urb returned %d\n", ret);
+		printk(KERN_DEBUG "usbfs: usb_submit_urb returned %d\n", ret);
                 async_removepending(as);
                 free_async(as);
                 return ret;
@@ -983,27 +934,29 @@
 static int processcompl(struct async *as)
 {
 	struct urb *urb = as->urb;
-	struct usbdevfs_urb __user *userurb = as->userurb;
 	unsigned int i;
 
 	if (as->userbuffer)
 		if (copy_to_user(as->userbuffer, urb->transfer_buffer, urb->transfer_buffer_length))
 			return -EFAULT;
-	if (put_user(urb->status, &userurb->status))
+	if (put_user(urb->status,
+		     &((struct usbdevfs_urb *)as->userurb)->status))
 		return -EFAULT;
-	if (put_user(urb->actual_length, &userurb->actual_length))
+	if (put_user(urb->actual_length,
+		     &((struct usbdevfs_urb *)as->userurb)->actual_length))
 		return -EFAULT;
-	if (put_user(urb->error_count, &userurb->error_count))
+	if (put_user(urb->error_count,
+		     &((struct usbdevfs_urb *)as->userurb)->error_count))
 		return -EFAULT;
 
 	if (!(usb_pipeisoc(urb->pipe)))
 		return 0;
 	for (i = 0; i < urb->number_of_packets; i++) {
 		if (put_user(urb->iso_frame_desc[i].actual_length,
-			     &userurb->iso_frame_desc[i].actual_length))
+			     &((struct usbdevfs_urb *)as->userurb)->iso_frame_desc[i].actual_length))
 			return -EFAULT;
 		if (put_user(urb->iso_frame_desc[i].status,
-			     &userurb->iso_frame_desc[i].status))
+			     &((struct usbdevfs_urb *)as->userurb)->iso_frame_desc[i].status))
 			return -EFAULT;
 	}
 	return 0;
@@ -1014,19 +967,18 @@
         DECLARE_WAITQUEUE(wait, current);
 	struct async *as = NULL;
 	void __user *addr;
-	struct usb_device *dev = ps->dev;
 	int ret;
 
 	add_wait_queue(&ps->wait, &wait);
-	while (connected(dev)) {
+	while (ps->dev) {
 		__set_current_state(TASK_INTERRUPTIBLE);
 		if ((as = async_getcompleted(ps)))
 			break;
 		if (signal_pending(current))
 			break;
-		up(&dev->serialize);
+		up_read(&ps->devsem);
 		schedule();
-		down(&dev->serialize);
+		down_read(&ps->devsem);
 	}
 	remove_wait_queue(&ps->wait, &wait);
 	set_current_state(TASK_RUNNING);
@@ -1036,7 +988,7 @@
 		free_async(as);
 		if (ret)
 			return ret;
-		if (put_user(addr, (void __user * __user *)arg))
+		if (put_user(addr, (void **)arg))
 			return -EFAULT;
 		return 0;
 	}
@@ -1058,7 +1010,7 @@
 	free_async(as);
 	if (ret)
 		return ret;
-	if (put_user(addr, (void __user * __user *)arg))
+	if (put_user(addr, (void **)arg))
 		return -EFAULT;
 	return 0;
 }
@@ -1078,23 +1030,28 @@
 
 static int proc_claiminterface(struct dev_state *ps, void __user *arg)
 {
-	unsigned int ifnum;
+	unsigned int intf;
+	int ret;
 
-	if (get_user(ifnum, (unsigned int __user *)arg))
+	if (get_user(intf, (unsigned int __user *)arg))
 		return -EFAULT;
-	return claimintf(ps, ifnum);
+	if ((ret = findintfif(ps->dev, intf)) < 0)
+		return ret;
+	return claimintf(ps, ret);
 }
 
 static int proc_releaseinterface(struct dev_state *ps, void __user *arg)
 {
-	unsigned int ifnum;
+	unsigned int intf;
 	int ret;
 
-	if (get_user(ifnum, (unsigned int __user *)arg))
+	if (get_user(intf, (unsigned int __user *)arg))
 		return -EFAULT;
-	if ((ret = releaseintf(ps, ifnum)) < 0)
+	if ((ret = findintfif(ps->dev, intf)) < 0)
+		return ret;
+	if ((ret = releaseintf(ps, intf)) < 0)
 		return ret;
-	destroy_async_on_interface (ps, ifnum);
+	destroy_async_on_interface (ps, intf);
 	return 0;
 }
 
@@ -1102,10 +1059,10 @@
 {
 	struct usbdevfs_ioctl	ctrl;
 	int			size;
-	void			*buf = NULL;
+	void			*buf = 0;
 	int			retval = 0;
-	struct usb_interface    *intf = NULL;
-	struct usb_driver       *driver = NULL;
+	struct usb_interface    *ifp = 0;
+	struct usb_driver       *driver = 0;
 
 	/* get input parameters and alloc buffer */
 	if (copy_from_user(&ctrl, arg, sizeof (ctrl)))
@@ -1123,48 +1080,57 @@
 		}
 	}
 
-	if (!connected(ps->dev)) {
-		if (buf)
-			kfree(buf);
-		return -ENODEV;
-	}
-
-	if (ps->dev->state != USB_STATE_CONFIGURED)
-		retval = -ENODEV;
-	else if (!(intf = usb_ifnum_to_if (ps->dev, ctrl.ifno)))
+       if (!ps->dev)
+               retval = -ENODEV;
+       else if (!(ifp = usb_ifnum_to_if (ps->dev, ctrl.ifno)))
                retval = -EINVAL;
-	else switch (ctrl.ioctl_code) {
+       else switch (ctrl.ioctl_code) {
 
-	/* disconnect kernel driver from interface */
-	case USBDEVFS_DISCONNECT:
-		down_write(&usb_bus_type.subsys.rwsem);
-		if (intf->dev.driver) {
-			driver = to_usb_driver(intf->dev.driver);
-			dev_dbg (&intf->dev, "disconnect by usbfs\n");
-			usb_driver_release_interface(driver, intf);
+       /* disconnect kernel driver from interface, leaving it unbound.  */
+       /* maybe unbound - you get no guarantee it stays unbound */
+       case USBDEVFS_DISCONNECT:
+		/* this function is misdesigned - retained for compatibility */
+		lock_kernel();
+		driver = ifp->driver;
+		if (driver) {
+			dbg ("disconnect '%s' from dev %d interface %d",
+			     driver->name, ps->dev->devnum, ctrl.ifno);
+			usb_unbind_interface(&ifp->dev);
 		} else
 			retval = -ENODATA;
-		up_write(&usb_bus_type.subsys.rwsem);
+		unlock_kernel();
 		break;
 
 	/* let kernel drivers try to (re)bind to the interface */
 	case USBDEVFS_CONNECT:
-		bus_rescan_devices(intf->dev.bus);
+		lock_kernel();
+		retval = usb_probe_interface (&ifp->dev);
+		unlock_kernel();
 		break;
 
 	/* talk directly to the interface's driver */
 	default:
-		down_read(&usb_bus_type.subsys.rwsem);
-		if (intf->dev.driver)
-			driver = to_usb_driver(intf->dev.driver);
+		/* BKL used here to protect against changing the binding
+		 * of this driver to this device, as well as unloading its
+		 * driver module.
+		 */
+		lock_kernel ();
+		driver = ifp->driver;
 		if (driver == 0 || driver->ioctl == 0) {
-			retval = -ENOTTY;
+			unlock_kernel();
+			retval = -ENOSYS;
 		} else {
-			retval = driver->ioctl (intf, ctrl.ioctl_code, buf);
+			if (!try_module_get (driver->owner)) {
+				unlock_kernel();
+				retval = -ENOSYS;
+				break;
+			}
+			unlock_kernel ();
+			retval = driver->ioctl (ifp, ctrl.ioctl_code, buf);
 			if (retval == -ENOIOCTLCMD)
 				retval = -ENOTTY;
+			module_put (driver->owner);
 		}
-		up_read(&usb_bus_type.subsys.rwsem);
 	}
 
 	/* cleanup and return */
@@ -1186,115 +1152,95 @@
 static int usbdev_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
 {
 	struct dev_state *ps = (struct dev_state *)file->private_data;
-	struct usb_device *dev = ps->dev;
-	void __user *p = (void __user *)arg;
 	int ret = -ENOTTY;
 
 	if (!(file->f_mode & FMODE_WRITE))
 		return -EPERM;
-	down(&dev->serialize);
-	if (!connected(dev)) {
-		up(&dev->serialize);
+	down_read(&ps->devsem);
+	if (!ps->dev) {
+		up_read(&ps->devsem);
 		return -ENODEV;
 	}
-
 	switch (cmd) {
 	case USBDEVFS_CONTROL:
-		snoop(&dev->dev, "%s: CONTROL\n", __FUNCTION__);
-		ret = proc_control(ps, p);
+		ret = proc_control(ps, (void __user *)arg);
 		if (ret >= 0)
 			inode->i_mtime = CURRENT_TIME;
 		break;
 
 	case USBDEVFS_BULK:
-		snoop(&dev->dev, "%s: BULK\n", __FUNCTION__);
-		ret = proc_bulk(ps, p);
+		ret = proc_bulk(ps, (void __user *)arg);
 		if (ret >= 0)
 			inode->i_mtime = CURRENT_TIME;
 		break;
 
 	case USBDEVFS_RESETEP:
-		snoop(&dev->dev, "%s: RESETEP\n", __FUNCTION__);
-		ret = proc_resetep(ps, p);
+		ret = proc_resetep(ps, (void __user *)arg);
 		if (ret >= 0)
 			inode->i_mtime = CURRENT_TIME;
 		break;
 
 	case USBDEVFS_RESET:
-		snoop(&dev->dev, "%s: RESET\n", __FUNCTION__);
 		ret = proc_resetdevice(ps);
 		break;
 
 	case USBDEVFS_CLEAR_HALT:
-		snoop(&dev->dev, "%s: CLEAR_HALT\n", __FUNCTION__);
-		ret = proc_clearhalt(ps, p);
+		ret = proc_clearhalt(ps, (void __user *)arg);
 		if (ret >= 0)
 			inode->i_mtime = CURRENT_TIME;
 		break;
 
 	case USBDEVFS_GETDRIVER:
-		snoop(&dev->dev, "%s: GETDRIVER\n", __FUNCTION__);
-		ret = proc_getdriver(ps, p);
+		ret = proc_getdriver(ps, (void __user *)arg);
 		break;
 
 	case USBDEVFS_CONNECTINFO:
-		snoop(&dev->dev, "%s: CONNECTINFO\n", __FUNCTION__);
-		ret = proc_connectinfo(ps, p);
+		ret = proc_connectinfo(ps, (void __user *)arg);
 		break;
 
 	case USBDEVFS_SETINTERFACE:
-		snoop(&dev->dev, "%s: SETINTERFACE\n", __FUNCTION__);
-		ret = proc_setintf(ps, p);
+		ret = proc_setintf(ps, (void __user *)arg);
 		break;
 
 	case USBDEVFS_SETCONFIGURATION:
-		snoop(&dev->dev, "%s: SETCONFIGURATION\n", __FUNCTION__);
-		ret = proc_setconfig(ps, p);
+		ret = proc_setconfig(ps, (void __user *)arg);
 		break;
 
 	case USBDEVFS_SUBMITURB:
-		snoop(&dev->dev, "%s: SUBMITURB\n", __FUNCTION__);
-		ret = proc_submiturb(ps, p);
+		ret = proc_submiturb(ps, (void __user *)arg);
 		if (ret >= 0)
 			inode->i_mtime = CURRENT_TIME;
 		break;
 
 	case USBDEVFS_DISCARDURB:
-		snoop(&dev->dev, "%s: DISCARDURB\n", __FUNCTION__);
-		ret = proc_unlinkurb(ps, p);
+		ret = proc_unlinkurb(ps, (void __user *)arg);
 		break;
 
 	case USBDEVFS_REAPURB:
-		snoop(&dev->dev, "%s: REAPURB\n", __FUNCTION__);
-		ret = proc_reapurb(ps, p);
+		ret = proc_reapurb(ps, (void __user *)arg);
 		break;
 
 	case USBDEVFS_REAPURBNDELAY:
-		snoop(&dev->dev, "%s: REAPURBDELAY\n", __FUNCTION__);
-		ret = proc_reapurbnonblock(ps, p);
+		ret = proc_reapurbnonblock(ps, (void __user *)arg);
 		break;
 
 	case USBDEVFS_DISCSIGNAL:
-		snoop(&dev->dev, "%s: DISCSIGNAL\n", __FUNCTION__);
-		ret = proc_disconnectsignal(ps, p);
+		ret = proc_disconnectsignal(ps, (void __user *)arg);
 		break;
 
 	case USBDEVFS_CLAIMINTERFACE:
-		snoop(&dev->dev, "%s: CLAIMINTERFACE\n", __FUNCTION__);
-		ret = proc_claiminterface(ps, p);
+		ret = proc_claiminterface(ps, (void __user *)arg);
 		break;
 
 	case USBDEVFS_RELEASEINTERFACE:
-		snoop(&dev->dev, "%s: RELEASEINTERFACE\n", __FUNCTION__);
-		ret = proc_releaseinterface(ps, p);
+		ret = proc_releaseinterface(ps, (void __user *)arg);
 		break;
 
 	case USBDEVFS_IOCTL:
-		snoop(&dev->dev, "%s: IOCTL\n", __FUNCTION__);
-		ret = proc_ioctl(ps, p);
+		ret = proc_ioctl(ps, (void __user *) arg);
 		break;
 	}
-	up(&dev->serialize);
+	up_read(&ps->devsem);
 	if (ret >= 0)
 		inode->i_atime = CURRENT_TIME;
 	return ret;
@@ -1309,7 +1255,7 @@
 	poll_wait(file, &ps->wait, wait);
 	if (file->f_mode & FMODE_WRITE && !list_empty(&ps->async_completed))
 		mask |= POLLOUT | POLLWRNORM;
-	if (!connected(ps->dev))
+	if (!ps->dev)
 		mask |= POLLERR | POLLHUP;
 	return mask;
 }
diff -Naur linuxppc-2.6.9/drivers/usb/core/driverfs.c linuxppc-2.6.9-dream/drivers/usb/core/driverfs.c
--- linuxppc-2.6.9/drivers/usb/core/driverfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/core/driverfs.c	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,192 @@
+/*
+ * drivers/usb/core/driverfs.c
+ *
+ * (C) Copyright 2002 David Brownell
+ * (C) Copyright 2002 Greg Kroah-Hartman
+ * (C) Copyright 2002 IBM Corp.
+ *
+ * All of the driverfs file attributes for usb devices and interfaces.
+ *
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+
+#ifdef CONFIG_USB_DEBUG
+	#define DEBUG
+#else
+	#undef DEBUG
+#endif
+#include <linux/usb.h>
+
+#include "usb.h"
+
+/* Active configuration fields */
+#define usb_actconfig_show(field, multiplier, format_string)		\
+static ssize_t  show_##field (struct device *dev, char *buf)		\
+{									\
+	struct usb_device *udev;					\
+									\
+	udev = to_usb_device (dev);					\
+	if (udev->actconfig)						\
+		return sprintf (buf, format_string,			\
+				udev->actconfig->desc.field * multiplier);	\
+	else								\
+		return 0;						\
+}									\
+
+#define usb_actconfig_attr(field, multiplier, format_string)		\
+usb_actconfig_show(field, multiplier, format_string)			\
+static DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
+
+usb_actconfig_attr (bNumInterfaces, 1, "%2d\n")
+usb_actconfig_attr (bmAttributes, 1, "%2x\n")
+usb_actconfig_attr (bMaxPower, 2, "%3dmA\n")
+
+/* configuration value is always present, and r/w */
+usb_actconfig_show(bConfigurationValue, 1, "%u\n");
+
+static ssize_t
+set_bConfigurationValue (struct device *dev, const char *buf, size_t count)
+{
+	struct usb_device	*udev = udev = to_usb_device (dev);
+	int			config, value;
+
+	if (sscanf (buf, "%u", &config) != 1 || config > 255)
+		return -EINVAL;
+	value = usb_set_configuration (udev, config);
+	return (value < 0) ? value : count;
+}
+
+static DEVICE_ATTR(bConfigurationValue, S_IRUGO | S_IWUSR, 
+		show_bConfigurationValue, set_bConfigurationValue);
+
+/* String fields */
+#define usb_string_attr(name, field)		\
+static ssize_t  show_##name(struct device *dev, char *buf)		\
+{									\
+	struct usb_device *udev;					\
+	int len;							\
+									\
+	udev = to_usb_device (dev);					\
+	len = usb_string(udev, udev->descriptor.field, buf, PAGE_SIZE);	\
+	if (len < 0)							\
+		return 0;						\
+	buf[len] = '\n';						\
+	buf[len+1] = 0;							\
+	return len+1;							\
+}									\
+static DEVICE_ATTR(name, S_IRUGO, show_##name, NULL);
+
+usb_string_attr(product, iProduct);
+usb_string_attr(manufacturer, iManufacturer);
+usb_string_attr(serial, iSerialNumber);
+
+static ssize_t
+show_speed (struct device *dev, char *buf)
+{
+	struct usb_device *udev;
+	char *speed;
+
+	udev = to_usb_device (dev);
+
+	switch (udev->speed) {
+	case USB_SPEED_LOW:
+		speed = "1.5";
+		break;
+	case USB_SPEED_UNKNOWN:
+	case USB_SPEED_FULL:
+		speed = "12";
+		break;
+	case USB_SPEED_HIGH:
+		speed = "480";
+		break;
+	default:
+		speed = "unknown";
+	}
+	return sprintf (buf, "%s\n", speed);
+}
+static DEVICE_ATTR(speed, S_IRUGO, show_speed, NULL);
+
+/* Descriptor fields */
+#define usb_descriptor_attr(field, format_string)			\
+static ssize_t								\
+show_##field (struct device *dev, char *buf)				\
+{									\
+	struct usb_device *udev;					\
+									\
+	udev = to_usb_device (dev);					\
+	return sprintf (buf, format_string, udev->descriptor.field);	\
+}									\
+static DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
+
+usb_descriptor_attr (idVendor, "%04x\n")
+usb_descriptor_attr (idProduct, "%04x\n")
+usb_descriptor_attr (bcdDevice, "%04x\n")
+usb_descriptor_attr (bDeviceClass, "%02x\n")
+usb_descriptor_attr (bDeviceSubClass, "%02x\n")
+usb_descriptor_attr (bDeviceProtocol, "%02x\n")
+usb_descriptor_attr (bNumConfigurations, "%d\n")
+
+
+void usb_create_driverfs_dev_files (struct usb_device *udev)
+{
+	struct device *dev = &udev->dev;
+
+	/* current configuration's attributes */
+	device_create_file (dev, &dev_attr_bNumInterfaces);
+	device_create_file (dev, &dev_attr_bConfigurationValue);
+	device_create_file (dev, &dev_attr_bmAttributes);
+	device_create_file (dev, &dev_attr_bMaxPower);
+
+	/* device attributes */
+	device_create_file (dev, &dev_attr_idVendor);
+	device_create_file (dev, &dev_attr_idProduct);
+	device_create_file (dev, &dev_attr_bcdDevice);
+	device_create_file (dev, &dev_attr_bDeviceClass);
+	device_create_file (dev, &dev_attr_bDeviceSubClass);
+	device_create_file (dev, &dev_attr_bDeviceProtocol);
+	device_create_file (dev, &dev_attr_bNumConfigurations);
+
+	/* speed varies depending on how you connect the device */
+	device_create_file (dev, &dev_attr_speed);
+	// FIXME iff there are other speed configs, show how many
+
+	if (udev->descriptor.iManufacturer)
+		device_create_file (dev, &dev_attr_manufacturer);
+	if (udev->descriptor.iProduct)
+		device_create_file (dev, &dev_attr_product);
+	if (udev->descriptor.iSerialNumber)
+		device_create_file (dev, &dev_attr_serial);
+}
+
+/* Interface fields */
+#define usb_intf_attr(field, format_string)				\
+static ssize_t								\
+show_##field (struct device *dev, char *buf)				\
+{									\
+	struct usb_interface *intf = to_usb_interface (dev);		\
+									\
+	return sprintf (buf, format_string, intf->cur_altsetting->desc.field); \
+}									\
+static DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
+
+usb_intf_attr (bInterfaceNumber, "%02x\n")
+usb_intf_attr (bAlternateSetting, "%2d\n")
+usb_intf_attr (bNumEndpoints, "%02x\n")
+usb_intf_attr (bInterfaceClass, "%02x\n")
+usb_intf_attr (bInterfaceSubClass, "%02x\n")
+usb_intf_attr (bInterfaceProtocol, "%02x\n")
+usb_intf_attr (iInterface, "%02x\n")
+
+void usb_create_driverfs_intf_files (struct usb_interface *intf)
+{
+	device_create_file (&intf->dev, &dev_attr_bInterfaceNumber);
+	device_create_file (&intf->dev, &dev_attr_bAlternateSetting);
+	device_create_file (&intf->dev, &dev_attr_bNumEndpoints);
+	device_create_file (&intf->dev, &dev_attr_bInterfaceClass);
+	device_create_file (&intf->dev, &dev_attr_bInterfaceSubClass);
+	device_create_file (&intf->dev, &dev_attr_bInterfaceProtocol);
+	device_create_file (&intf->dev, &dev_attr_iInterface);
+}
diff -Naur linuxppc-2.6.9/drivers/usb/core/file.c linuxppc-2.6.9-dream/drivers/usb/core/file.c
--- linuxppc-2.6.9/drivers/usb/core/file.c	2004-10-18 23:55:35.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/file.c	2005-09-19 21:40:05.000000000 +0200
@@ -79,25 +79,14 @@
 
 int usb_major_init(void)
 {
-	int error;
-
-	error = register_chrdev(USB_MAJOR, "usb", &usb_fops);
-	if (error) {
+	if (register_chrdev(USB_MAJOR, "usb", &usb_fops)) {
 		err("unable to get major %d for usb devices", USB_MAJOR);
-		goto out;
-	}
-
-	error = class_register(&usb_class);
-	if (error) {
-		err("class_register failed for usb devices");
-		unregister_chrdev(USB_MAJOR, "usb");
-		goto out;
+		return -EBUSY;
 	}
 
 	devfs_mk_dir("usb");
-
-out:
-	return error;
+	class_register(&usb_class);
+	return 0;
 }
 
 void usb_major_cleanup(void)
diff -Naur linuxppc-2.6.9/drivers/usb/core/hcd.c linuxppc-2.6.9-dream/drivers/usb/core/hcd.c
--- linuxppc-2.6.9/drivers/usb/core/hcd.c	2004-10-18 23:54:32.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/hcd.c	2005-09-19 21:40:05.000000000 +0200
@@ -42,8 +42,6 @@
 #include <asm/byteorder.h>
 
 #include <linux/usb.h>
-
-#include "usb.h"
 #include "hcd.h"
 
 
@@ -102,9 +100,6 @@
 /* used when updating hcd data */
 static spinlock_t hcd_data_lock = SPIN_LOCK_UNLOCKED;
 
-/* wait queue for synchronous unlinks */
-DECLARE_WAIT_QUEUE_HEAD(usb_kill_urb_queue);
-
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -174,10 +169,10 @@
 	0x01,       /*  __u8  bNumInterfaces; (1) */
 	0x01,       /*  __u8  bConfigurationValue; */
 	0x00,       /*  __u8  iConfiguration; */
-	0xc0,       /*  __u8  bmAttributes; 
-				 Bit 7: must be set,
+	0x40,       /*  __u8  bmAttributes; 
+				 Bit 7: Bus-powered,
 				     6: Self-powered,
-				     5: Remote wakeup,
+				     5 Remote-wakwup,
 				     4..0: resvd */
 	0x00,       /*  __u8  MaxPower; */
       
@@ -221,10 +216,10 @@
 	0x01,       /*  __u8  bNumInterfaces; (1) */
 	0x01,       /*  __u8  bConfigurationValue; */
 	0x00,       /*  __u8  iConfiguration; */
-	0xc0,       /*  __u8  bmAttributes; 
-				 Bit 7: must be set,
+	0x40,       /*  __u8  bmAttributes; 
+				 Bit 7: Bus-powered,
 				     6: Self-powered,
-				     5: Remote wakeup,
+				     5 Remote-wakwup,
 				     4..0: resvd */
 	0x00,       /*  __u8  MaxPower; */
       
@@ -327,15 +322,13 @@
 /* Root hub control transfers execute synchronously */
 static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 {
-	struct usb_ctrlrequest *cmd;
+	struct usb_ctrlrequest *cmd = (struct usb_ctrlrequest *) urb->setup_packet;
  	u16		typeReq, wValue, wIndex, wLength;
-	const u8	*bufp = NULL;
+	const u8	*bufp = 0;
 	u8		*ubuf = urb->transfer_buffer;
 	int		len = 0;
-	int		patch_wakeup = 0;
 	unsigned long	flags;
 
-	cmd = (struct usb_ctrlrequest *) urb->setup_packet;
 	typeReq  = (cmd->bRequestType << 8) | cmd->bRequest;
 	wValue   = le16_to_cpu (cmd->wValue);
 	wIndex   = le16_to_cpu (cmd->wIndex);
@@ -352,21 +345,13 @@
 	/* DEVICE REQUESTS */
 
 	case DeviceRequest | USB_REQ_GET_STATUS:
-		ubuf [0] = (hcd->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP)
-				| (1 << USB_DEVICE_SELF_POWERED);
+		// DEVICE_REMOTE_WAKEUP
+		ubuf [0] = 1; // selfpowered
 		ubuf [1] = 0;
-		break;
+			/* FALLTHROUGH */
 	case DeviceOutRequest | USB_REQ_CLEAR_FEATURE:
-		if (wValue == USB_DEVICE_REMOTE_WAKEUP)
-			hcd->remote_wakeup = 0;
-		else
-			goto error;
-		break;
 	case DeviceOutRequest | USB_REQ_SET_FEATURE:
-		if (hcd->can_wakeup && wValue == USB_DEVICE_REMOTE_WAKEUP)
-			hcd->remote_wakeup = 1;
-		else
-			goto error;
+		dev_dbg (hcd->self.controller, "no device features yet yet\n");
 		break;
 	case DeviceRequest | USB_REQ_GET_CONFIGURATION:
 		ubuf [0] = 1;
@@ -392,8 +377,6 @@
 				bufp = fs_rh_config_descriptor;
 				len = sizeof fs_rh_config_descriptor;
 			}
-			if (hcd->can_wakeup)
-				patch_wakeup = 1;
 			break;
 		case USB_DT_STRING << 8:
 			urb->actual_length = rh_string (
@@ -433,14 +416,9 @@
 
 	default:
 		/* non-generic request */
-		if (HCD_IS_SUSPENDED (hcd->state))
-			urb->status = -EAGAIN;
-		else if (!HCD_IS_RUNNING (hcd->state))
-			urb->status = -ENODEV;
-		else
-			urb->status = hcd->driver->hub_control (hcd,
-				typeReq, wValue, wIndex,
-				ubuf, wLength);
+		urb->status = hcd->driver->hub_control (hcd,
+			typeReq, wValue, wIndex,
+			ubuf, wLength);
 		break;
 error:
 		/* "protocol stall" on error */
@@ -459,11 +437,6 @@
 		urb->actual_length = len;
 		// always USB_DIR_IN, toward host
 		memcpy (ubuf, bufp, len);
-
-		/* report whether RH hardware supports remote wakeup */
-		if (patch_wakeup)
-			((struct usb_config_descriptor *)ubuf)->bmAttributes
-				|= USB_CONFIG_ATT_WAKEUP;
 	}
 
 	/* any errors get returned through the urb completion */
@@ -539,7 +512,7 @@
 		hcd->rh_timer.data = 0;
 		urb->actual_length = length;
 		urb->status = 0;
-		urb->hcpriv = NULL;
+		urb->hcpriv = 0;
 	} else
 		mod_timer (&hcd->rh_timer, jiffies + HZ/4);
 	spin_unlock (&hcd_data_lock);
@@ -572,7 +545,7 @@
 
 /*-------------------------------------------------------------------------*/
 
-int usb_rh_status_dequeue (struct usb_hcd *hcd, struct urb *urb)
+void usb_rh_status_dequeue (struct usb_hcd *hcd, struct urb *urb)
 {
 	unsigned long	flags;
 
@@ -581,10 +554,9 @@
 	hcd->rh_timer.data = 0;
 
 	local_irq_save (flags);
-	urb->hcpriv = NULL;
+	urb->hcpriv = 0;
 	usb_hcd_giveback_urb (hcd, urb, NULL);
 	local_irq_restore (flags);
-	return 0;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -626,9 +598,9 @@
 	.release	= &usb_host_release,
 };
 
-int usb_host_init(void)
+void usb_host_init(void)
 {
-	return class_register(&usb_host_class);
+	class_register(&usb_host_class);
 }
 
 void usb_host_cleanup(void)
@@ -706,11 +678,8 @@
 	if (busnum < USB_MAXBUS) {
 		set_bit (busnum, busmap.busmap);
 		bus->busnum = busnum;
-	} else {
-		printk (KERN_ERR "%s: too many buses\n", usbcore_name);
-		up(&usb_bus_list_lock);
-		return -E2BIG;
-	}
+	} else
+		warn ("too many buses");
 
 	snprintf(bus->class_dev.class_id, BUS_ID_SIZE, "usb%d", busnum);
 	bus->class_dev.class = &usb_host_class;
@@ -769,9 +738,8 @@
  *
  * The USB host controller calls this function to register the root hub
  * properly with the USB subsystem.  It sets up the device properly in
- * the device tree and stores the root_hub pointer in the bus structure,
- * then calls usb_new_device() to register the usb device.  It also
- * assigns the root hub's USB address (always 1).
+ * the device model tree, and then calls usb_new_device() to register the
+ * usb device.  It also assigns the root hub's USB address (always 1).
  */
 int usb_register_root_hub (struct usb_device *usb_dev, struct device *parent_dev)
 {
@@ -783,30 +751,12 @@
 	memset (&usb_dev->bus->devmap.devicemap, 0,
 			sizeof usb_dev->bus->devmap.devicemap);
 	set_bit (devnum, usb_dev->bus->devmap.devicemap);
-	usb_set_device_state(usb_dev, USB_STATE_ADDRESS);
+	usb_dev->state = USB_STATE_ADDRESS;
 
-	down (&usb_bus_list_lock);
-	usb_dev->bus->root_hub = usb_dev;
-
-	usb_dev->epmaxpacketin[0] = usb_dev->epmaxpacketout[0] = 64;
-	retval = usb_get_device_descriptor(usb_dev, USB_DT_DEVICE_SIZE);
-	if (retval != sizeof usb_dev->descriptor) {
-		usb_dev->bus->root_hub = NULL;
-		up (&usb_bus_list_lock);
-		dev_dbg (parent_dev, "can't read %s device descriptor %d\n",
-				usb_dev->dev.bus_id, retval);
-		return (retval < 0) ? retval : -EMSGSIZE;
-	}
-
-	down (&usb_dev->serialize);
 	retval = usb_new_device (usb_dev);
-	up (&usb_dev->serialize);
-	if (retval) {
-		usb_dev->bus->root_hub = NULL;
+	if (retval)
 		dev_err (parent_dev, "can't register root hub for %s, %d\n",
 				usb_dev->dev.bus_id, retval);
-	}
-	up (&usb_bus_list_lock);
 	return retval;
 }
 EXPORT_SYMBOL (usb_register_root_hub);
@@ -854,7 +804,7 @@
 			tmp = HS_USECS_ISO (bytecount);
 		return tmp;
 	default:
-		pr_debug ("%s: bogus device speed!\n", usbcore_name);
+		dbg ("bogus device speed!");
 		return -1;
 	}
 }
@@ -1036,6 +986,7 @@
 static void urb_unlink (struct urb *urb)
 {
 	unsigned long		flags;
+	struct usb_device	*dev;
 
 	/* Release any periodic transfer bandwidth */
 	if (urb->bandwidth)
@@ -1046,8 +997,9 @@
 
 	spin_lock_irqsave (&hcd_data_lock, flags);
 	list_del_init (&urb->urb_list);
+	dev = urb->dev;
 	spin_unlock_irqrestore (&hcd_data_lock, flags);
-	usb_put_dev (urb->dev);
+	usb_put_dev (dev);
 }
 
 
@@ -1084,28 +1036,23 @@
 	// FIXME:  verify that quiescing hc works right (RH cleans up)
 
 	spin_lock_irqsave (&hcd_data_lock, flags);
-	if (unlikely (urb->reject))
-		status = -EPERM;
-	else if (HCD_IS_RUNNING (hcd->state) &&
-			hcd->state != USB_STATE_QUIESCING) {
+	if (HCD_IS_RUNNING (hcd->state) && hcd->state != USB_STATE_QUIESCING) {
 		usb_get_dev (urb->dev);
 		list_add_tail (&urb->urb_list, &dev->urb_list);
 		status = 0;
-	} else
+	} else {
+		INIT_LIST_HEAD (&urb->urb_list);
 		status = -ESHUTDOWN;
+	}
 	spin_unlock_irqrestore (&hcd_data_lock, flags);
-	if (status) {
-		INIT_LIST_HEAD (&urb->urb_list);
+	if (status)
 		return status;
-	}
 
 	/* increment urb's reference count as part of giving it to the HCD
 	 * (which now controls it).  HCD guarantees that it either returns
 	 * an error or calls giveback(), but not both.
 	 */
 	urb = usb_get_urb (urb);
-	atomic_inc (&urb->use_count);
-
 	if (urb->dev == hcd->self.root_hub) {
 		/* NOTE:  requirement on hub callers (usbfs and the hub
 		 * driver, for now) that URBs' urb->transfer_buffer be
@@ -1142,12 +1089,9 @@
 
 	status = hcd->driver->urb_enqueue (hcd, urb, mem_flags);
 done:
-	if (unlikely (status)) {
-		urb_unlink (urb);
-		atomic_dec (&urb->use_count);
-		if (urb->reject)
-			wake_up (&usb_kill_urb_queue);
+	if (status) {
 		usb_put_urb (urb);
+		urb_unlink (urb);
 	}
 	return status;
 }
@@ -1170,39 +1114,60 @@
  * soon as practical.  we've already set up the urb's return status,
  * but we can't know if the callback completed already.
  */
-static int
+static void
 unlink1 (struct usb_hcd *hcd, struct urb *urb)
 {
-	int		value;
-
 	if (urb == (struct urb *) hcd->rh_timer.data)
-		value = usb_rh_status_dequeue (hcd, urb);
+		usb_rh_status_dequeue (hcd, urb);
 	else {
+		int		value;
 
-		/* The only reason an HCD might fail this call is if
-		 * it has not yet fully queued the urb to begin with.
-		 * Such failures should be harmless. */
+		/* failures "should" be harmless */
 		value = hcd->driver->urb_dequeue (hcd, urb);
+		if (value != 0)
+			dev_dbg (hcd->self.controller,
+				"dequeue %p --> %d\n",
+				urb, value);
 	}
+}
 
-	if (value != 0)
-		dev_dbg (hcd->self.controller, "dequeue %p --> %d\n",
-				urb, value);
-	return value;
+struct completion_splice {		// modified urb context:
+	/* did we complete? */
+	struct completion	done;
+
+	/* original urb data */
+	usb_complete_t		complete;
+	void			*context;
+};
+
+static void unlink_complete (struct urb *urb, struct pt_regs *regs)
+{
+	struct completion_splice	*splice;
+
+	splice = (struct completion_splice *) urb->context;
+
+	/* issue original completion call */
+	urb->complete = splice->complete;
+	urb->context = splice->context;
+	urb->complete (urb, regs);
+
+	/* then let the synchronous unlink call complete */
+	complete (&splice->done);
 }
 
 /*
- * called in any context
+ * called in any context; note ASYNC_UNLINK restrictions
  *
  * caller guarantees urb won't be recycled till both unlink()
  * and the urb's completion function return
  */
-static int hcd_unlink_urb (struct urb *urb, int status)
+static int hcd_unlink_urb (struct urb *urb)
 {
 	struct hcd_dev			*dev;
-	struct usb_hcd			*hcd = NULL;
-	struct device			*sys = NULL;
+	struct usb_hcd			*hcd = 0;
+	struct device			*sys = 0;
 	unsigned long			flags;
+	struct completion_splice	splice;
 	struct list_head		*tmp;
 	int				retval;
 
@@ -1254,6 +1219,8 @@
 
 	/* Any status except -EINPROGRESS means something already started to
 	 * unlink this URB from the hardware.  So there's no more work to do.
+	 *
+	 * FIXME use better explicit urb state
 	 */
 	if (urb->status != -EINPROGRESS) {
 		retval = -EBUSY;
@@ -1271,19 +1238,62 @@
 		hcd->saw_irq = 1;
 	}
 
-	urb->status = status;
-
+	/* maybe set up to block until the urb's completion fires.  the
+	 * lower level hcd code is always async, locking on urb->status
+	 * updates; an intercepted completion unblocks us.
+	 */
+	if (!(urb->transfer_flags & URB_ASYNC_UNLINK)) {
+		if (in_interrupt ()) {
+			dev_dbg (hcd->self.controller, 
+				"non-async unlink in_interrupt");
+			retval = -EWOULDBLOCK;
+			goto done;
+		}
+		/* synchronous unlink: block till we see the completion */
+		init_completion (&splice.done);
+		splice.complete = urb->complete;
+		splice.context = urb->context;
+		urb->complete = unlink_complete;
+		urb->context = &splice;
+		urb->status = -ENOENT;
+	} else {
+		/* asynchronous unlink */
+		urb->status = -ECONNRESET;
+	}
 	spin_unlock (&hcd_data_lock);
 	spin_unlock_irqrestore (&urb->lock, flags);
 
-	retval = unlink1 (hcd, urb);
-	if (retval == 0)
-		retval = -EINPROGRESS;
-	return retval;
+	// FIXME remove splicing, so this becomes unlink1 (hcd, urb);
+	if (urb == (struct urb *) hcd->rh_timer.data) {
+		usb_rh_status_dequeue (hcd, urb);
+		retval = 0;
+	} else {
+		retval = hcd->driver->urb_dequeue (hcd, urb);
+
+		/* hcds shouldn't really fail these calls, but... */
+		if (retval) {
+			dev_dbg (sys, "dequeue %p --> %d\n", urb, retval);
+			if (!(urb->transfer_flags & URB_ASYNC_UNLINK)) {
+				spin_lock_irqsave (&urb->lock, flags);
+				urb->complete = splice.complete;
+				urb->context = splice.context;
+				spin_unlock_irqrestore (&urb->lock, flags);
+			}
+			goto bye;
+		}
+	}
+
+    	/* block till giveback, if needed */
+	if (urb->transfer_flags & URB_ASYNC_UNLINK)
+		return -EINPROGRESS;
+
+	wait_for_completion (&splice.done);
+	return 0;
 
 done:
 	spin_unlock (&hcd_data_lock);
 	spin_unlock_irqrestore (&urb->lock, flags);
+bye:
 	if (retval != -EIDRM && sys && sys->driver)
 		dev_dbg (sys, "hcd_unlink_urb %p fail %d\n", urb, retval);
 	return retval;
@@ -1314,10 +1324,13 @@
 
 rescan:
 	/* (re)block new requests, as best we can */
-	if (endpoint & USB_DIR_IN)
+	if (endpoint & USB_DIR_IN) {
+		usb_endpoint_halt (udev, epnum, 0);
 		udev->epmaxpacketin [epnum] = 0;
-	else
+	} else {
+		usb_endpoint_halt (udev, epnum, 1);
 		udev->epmaxpacketout [epnum] = 0;
+	}
 
 	/* then kill any current requests */
 	spin_lock (&hcd_data_lock);
@@ -1381,71 +1394,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-#ifdef	CONFIG_USB_SUSPEND
-
-static int hcd_hub_suspend (struct usb_bus *bus)
-{
-	struct usb_hcd		*hcd;
-
-	hcd = container_of (bus, struct usb_hcd, self);
-	if (hcd->driver->hub_suspend)
-		return hcd->driver->hub_suspend (hcd);
-	return 0;
-}
-
-static int hcd_hub_resume (struct usb_bus *bus)
-{
-	struct usb_hcd		*hcd;
-
-	hcd = container_of (bus, struct usb_hcd, self);
-	if (hcd->driver->hub_resume)
-		return hcd->driver->hub_resume (hcd);
-	return 0;
-}
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef	CONFIG_USB_OTG
-
-/**
- * usb_bus_start_enum - start immediate enumeration (for OTG)
- * @bus: the bus (must use hcd framework)
- * @port: 1-based number of port; usually bus->otg_port
- * Context: in_interrupt()
- *
- * Starts enumeration, with an immediate reset followed later by
- * khubd identifying and possibly configuring the device.
- * This is needed by OTG controller drivers, where it helps meet
- * HNP protocol timing requirements for starting a port reset.
- */
-int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num)
-{
-	struct usb_hcd		*hcd;
-	int			status = -EOPNOTSUPP;
-
-	/* NOTE: since HNP can't start by grabbing the bus's address0_sem,
-	 * boards with root hubs hooked up to internal devices (instead of
-	 * just the OTG port) may need more attention to resetting...
-	 */
-	hcd = container_of (bus, struct usb_hcd, self);
-	if (port_num && hcd->driver->start_port_reset)
-		status = hcd->driver->start_port_reset(hcd, port_num);
-
-	/* run khubd shortly after (first) root port reset finishes;
-	 * it may issue others, until at least 50 msecs have passed.
-	 */
-	if (status == 0)
-		mod_timer(&hcd->rh_timer, jiffies + msecs_to_jiffies(10));
-	return status;
-}
-EXPORT_SYMBOL (usb_bus_start_enum);
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
 /* called by khubd, rmmod, apmd, or other thread for hcd-private cleanup.
  * we're guaranteed that the device is fully quiesced.  also, that each
  * endpoint has been hcd_endpoint_disabled.
@@ -1500,10 +1448,6 @@
 	.buffer_alloc =		hcd_buffer_alloc,
 	.buffer_free =		hcd_buffer_free,
 	.disable =		hcd_endpoint_disable,
-#ifdef	CONFIG_USB_SUSPEND
-	.hub_suspend =		hcd_hub_suspend,
-	.hub_resume =		hcd_hub_resume,
-#endif
 };
 EXPORT_SYMBOL (usb_hcd_operations);
 
@@ -1549,9 +1493,6 @@
 
 	/* pass ownership to the completion handler */
 	urb->complete (urb, regs);
-	atomic_dec (&urb->use_count);
-	if (unlikely (urb->reject))
-		wake_up (&usb_kill_urb_queue);
 	usb_put_urb (urb);
 }
 EXPORT_SYMBOL (usb_hcd_giveback_urb);
@@ -1595,13 +1536,11 @@
 	unsigned		i;
 
 	/* hc's root hub is removed later removed in hcd->stop() */
-	down (&hub->serialize);
-	usb_set_device_state(hub, USB_STATE_NOTATTACHED);
+	hub->state = USB_STATE_NOTATTACHED;
 	for (i = 0; i < hub->maxchild; i++) {
 		if (hub->children [i])
 			usb_disconnect (&hub->children [i]);
 	}
-	up (&hub->serialize);
 }
 
 /**
diff -Naur linuxppc-2.6.9/drivers/usb/core/hcd.h linuxppc-2.6.9-dream/drivers/usb/core/hcd.h
--- linuxppc-2.6.9/drivers/usb/core/hcd.h	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/hcd.h	2005-09-19 21:40:05.000000000 +0200
@@ -74,10 +74,8 @@
 	 */
 	struct hc_driver	*driver;	/* hw-specific hooks */
 	unsigned		saw_irq : 1;
-	unsigned		can_wakeup:1;	/* hw supports wakeup? */
-	unsigned		remote_wakeup:1;/* sw should use wakeup? */
 	int			irq;		/* irq allocated */
-	void __iomem		*regs;		/* device memory/io */
+	void			*regs;		/* device memory/io */
 
 #ifdef	CONFIG_PCI
 	int			region;		/* pci region for regs */
@@ -96,7 +94,7 @@
 #	define	USB_STATE_RUNNING	(__ACTIVE)
 #	define	USB_STATE_QUIESCING	(__SUSPEND|__TRANSIENT|__ACTIVE)
 #	define	USB_STATE_RESUMING	(__SUSPEND|__TRANSIENT)
-#	define	HCD_STATE_SUSPENDED	(__SUSPEND)
+#	define	USB_STATE_SUSPENDED	(__SUSPEND)
 
 #define	HCD_IS_RUNNING(state) ((state) & __ACTIVE)
 #define	HCD_IS_SUSPENDED(state) ((state) & __SUSPEND)
@@ -142,7 +140,7 @@
 	int (*deallocate)(struct usb_device *);
 	int (*get_frame_number) (struct usb_device *usb_dev);
 	int (*submit_urb) (struct urb *urb, int mem_flags);
-	int (*unlink_urb) (struct urb *urb, int status);
+	int (*unlink_urb) (struct urb *urb);
 
 	/* allocate dma-consistent buffer for URB_DMA_NOMAPPING */
 	void *(*buffer_alloc)(struct usb_bus *bus, size_t size,
@@ -152,10 +150,6 @@
 			void *addr, dma_addr_t dma);
 
 	void (*disable)(struct usb_device *udev, int bEndpointAddress);
-
-	/* global suspend/resume of bus */
-	int (*hub_suspend)(struct usb_bus *);
-	int (*hub_resume)(struct usb_bus *);
 };
 
 /* each driver provides one of these, and hardware init support */
@@ -177,9 +171,6 @@
 	int	(*reset) (struct usb_hcd *hcd);
 	int	(*start) (struct usb_hcd *hcd);
 
-	/* NOTE:  these suspend/resume calls relate to the HC as
-	 * a whole, not just the root hub; they're for bus glue.
-	 */
 	/* called after all devices were suspended */
 	int	(*suspend) (struct usb_hcd *hcd, u32 state);
 
@@ -210,14 +201,11 @@
 	int		(*hub_control) (struct usb_hcd *hcd,
 				u16 typeReq, u16 wValue, u16 wIndex,
 				char *buf, u16 wLength);
-	int		(*hub_suspend)(struct usb_hcd *);
-	int		(*hub_resume)(struct usb_hcd *);
-	int		(*start_port_reset)(struct usb_hcd *, unsigned port_num);
 };
 
 extern void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb, struct pt_regs *regs);
 extern void usb_bus_init (struct usb_bus *bus);
-extern int usb_rh_status_dequeue (struct usb_hcd *hcd, struct urb *urb);
+extern void usb_rh_status_dequeue (struct usb_hcd *hcd, struct urb *urb);
 
 #ifdef CONFIG_PCI
 struct pci_dev;
@@ -253,10 +241,17 @@
 extern struct usb_device *usb_alloc_dev(struct usb_device *parent,
 					struct usb_bus *, unsigned port);
 extern int usb_new_device(struct usb_device *dev);
+extern void usb_choose_address(struct usb_device *dev);
 extern void usb_disconnect(struct usb_device **);
 
+/* exported to hub driver ONLY to support usb_reset_device () */
 extern int usb_get_configuration(struct usb_device *dev);
 extern void usb_destroy_configuration(struct usb_device *dev);
+extern int usb_set_address(struct usb_device *dev);
+
+/* use these only before the device's address has been set */
+#define usb_snddefctrl(dev)		((PIPE_CONTROL << 30))
+#define usb_rcvdefctrl(dev)		((PIPE_CONTROL << 30) | USB_DIR_IN)
 
 /*-------------------------------------------------------------------------*/
 
@@ -280,6 +275,10 @@
 #define EndpointOutRequest \
 	((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)<<8)
 
+/* table 9.6 standard features */
+#define DEVICE_REMOTE_WAKEUP	1
+#define ENDPOINT_HALT		0
+
 /* class requests from the USB 2.0 hub spec, table 11-15 */
 /* GetBusState and SetHubDescriptor are optional, omitted */
 #define ClearHubFeature		(0x2000 | USB_REQ_CLEAR_FEATURE)
@@ -332,7 +331,7 @@
 #define HS_USECS(bytes) NS_TO_US ( ((55 * 8 * 2083)/1000) \
 	+ ((2083UL * (3167 + BitTime (bytes)))/1000) \
 	+ USB2_HOST_DELAY)
-#define HS_USECS_ISO(bytes) NS_TO_US ( ((38 * 8 * 2083)/1000) \
+#define HS_USECS_ISO(bytes) NS_TO_US ( ((long)(38 * 8 * 2.083)) \
 	+ ((2083UL * (3167 + BitTime (bytes)))/1000) \
 	+ USB2_HOST_DELAY)
 
@@ -349,18 +348,11 @@
 extern int usb_register_root_hub (struct usb_device *usb_dev,
 		struct device *parent_dev);
 
-static inline int hcd_register_root (struct usb_device *usb_dev,
-		struct usb_hcd *hcd)
+/* for portability to 2.4, hcds should call this */
+static inline int hcd_register_root (struct usb_hcd *hcd)
 {
-	/* hcd->driver->start() reported can_wakeup, probably with
-	 * assistance from board's boot firmware.
-	 * NOTE:  normal devices won't enable wakeup by default.
-	 */
-	if (hcd->can_wakeup)
-		dev_dbg (hcd->self.controller, "supports USB remote wakeup\n");
-	hcd->remote_wakeup = hcd->can_wakeup;
-
-	return usb_register_root_hub (usb_dev, hcd->self.controller);
+	return usb_register_root_hub (
+		hcd_to_bus (hcd)->root_hub, hcd->self.controller);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -369,7 +361,6 @@
 
 extern struct list_head usb_bus_list;
 extern struct semaphore usb_bus_list_lock;
-extern wait_queue_head_t usb_kill_urb_queue;
 
 extern struct usb_bus *usb_bus_get (struct usb_bus *bus);
 extern void usb_bus_put (struct usb_bus *bus);
@@ -377,6 +368,8 @@
 extern int usb_find_interface_driver (struct usb_device *dev,
 	struct usb_interface *interface);
 
+#define usb_endpoint_halt(dev, ep, out) ((dev)->halted[out] |= (1 << (ep)))
+
 #define usb_endpoint_out(ep_dir)	(!((ep_dir) & USB_DIR_IN))
 
 /*
diff -Naur linuxppc-2.6.9/drivers/usb/core/hcd-pci.c linuxppc-2.6.9-dream/drivers/usb/core/hcd-pci.c
--- linuxppc-2.6.9/drivers/usb/core/hcd-pci.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/hcd-pci.c	2005-09-19 21:40:05.000000000 +0200
@@ -65,7 +65,7 @@
 {
 	struct hc_driver	*driver;
 	unsigned long		resource, len;
-	void __iomem		*base;
+	void			*base;
 	struct usb_hcd		*hcd;
 	int			retval, region;
 	char			buf [8], *bufp = buf;
@@ -80,8 +80,7 @@
 		return -ENODEV;
 	
         if (!dev->irq) {
-        	dev_err (&dev->dev,
-			"Found HC with no IRQ.  Check BIOS/PCI %s setup!\n",
+        	err ("Found HC with no IRQ.  Check BIOS/PCI %s setup!",
 			pci_name(dev));
    	        return -ENODEV;
         }
@@ -91,17 +90,16 @@
 		resource = pci_resource_start (dev, 0);
 		len = pci_resource_len (dev, 0);
 		if (!request_mem_region (resource, len, driver->description)) {
-			dev_dbg (&dev->dev, "controller already in use\n");
+			dbg ("controller already in use");
 			return -EBUSY;
 		}
 		base = ioremap_nocache (resource, len);
 		if (base == NULL) {
-			dev_dbg (&dev->dev, "error mapping memory\n");
+			dbg ("error mapping memory");
 			retval = -EFAULT;
 clean_1:
 			release_mem_region (resource, len);
-			dev_err (&dev->dev, "init %s fail, %d\n",
-				pci_name(dev), retval);
+			err ("init %s fail, %d", pci_name(dev), retval);
 			return retval;
 		}
 
@@ -118,10 +116,10 @@
 				break;
 		}
 		if (region == PCI_ROM_RESOURCE) {
-			dev_dbg (&dev->dev, "no i/o regions available\n");
+			dbg ("no i/o regions available");
 			return -EBUSY;
 		}
-		base = (void __iomem *) resource;
+		base = (void *) resource;
 	}
 
 	// driver->reset(), later on, will transfer device from
@@ -129,7 +127,7 @@
 
 	hcd = driver->hcd_alloc ();
 	if (hcd == NULL){
-		dev_dbg (&dev->dev, "hcd alloc fail\n");
+		dbg ("hcd alloc fail");
 		retval = -ENOMEM;
 clean_2:
 		if (driver->flags & HCD_MEMORY) {
@@ -137,8 +135,7 @@
 			goto clean_1;
 		} else {
 			release_region (resource, len);
-			dev_err (&dev->dev, "init %s fail, %d\n",
-				pci_name(dev), retval);
+			err ("init %s fail, %d", pci_name(dev), retval);
 			return retval;
 		}
 	}
@@ -196,16 +193,13 @@
 	hcd->self.op = &usb_hcd_operations;
 	hcd->self.hcpriv = (void *) hcd;
 	hcd->self.release = &hcd_pci_release;
-	init_timer (&hcd->rh_timer);
 
 	INIT_LIST_HEAD (&hcd->dev_list);
 
 	usb_register_bus (&hcd->self);
 
-	if ((retval = driver->start (hcd)) < 0) {
-		dev_err (hcd->self.controller, "init error %d\n", retval);
+	if ((retval = driver->start (hcd)) < 0)
 		usb_hcd_pci_remove (dev);
-	}
 
 	return retval;
 } 
@@ -229,6 +223,7 @@
 void usb_hcd_pci_remove (struct pci_dev *dev)
 {
 	struct usb_hcd		*hcd;
+	struct usb_device	*hub;
 
 	hcd = pci_get_drvdata(dev);
 	if (!hcd)
@@ -238,16 +233,17 @@
 	if (in_interrupt ())
 		BUG ();
 
+	hub = hcd->self.root_hub;
 	if (HCD_IS_RUNNING (hcd->state))
 		hcd->state = USB_STATE_QUIESCING;
 
 	dev_dbg (hcd->self.controller, "roothub graceful disconnect\n");
-	usb_disconnect (&hcd->self.root_hub);
+	usb_disconnect (&hub);
 
 	hcd->driver->stop (hcd);
 	hcd_buffer_destroy (hcd);
 	hcd->state = USB_STATE_HALT;
-	pci_set_drvdata(dev, NULL);
+	pci_set_drvdata (dev, 0);
 
 	free_irq (hcd->irq, hcd);
 	if (hcd->driver->flags & HCD_MEMORY) {
@@ -277,54 +273,36 @@
 {
 	struct usb_hcd		*hcd;
 	int			retval = 0;
-	int			has_pci_pm;
 
 	hcd = pci_get_drvdata(dev);
-
-	/* even when the PCI layer rejects some of the PCI calls
-	 * below, HCs can try global suspend and reduce DMA traffic.
-	 * PM-sensitive HCDs may already have done this.
-	 */
-	has_pci_pm = pci_find_capability(dev, PCI_CAP_ID_PM);
-	if (has_pci_pm)
-		dev_dbg(hcd->self.controller, "suspend D%d --> D%d\n",
+	dev_dbg (hcd->self.controller, "suspend D%d --> D%d\n",
 			dev->current_state, state);
 
 	switch (hcd->state) {
 	case USB_STATE_HALT:
 		dev_dbg (hcd->self.controller, "halted; hcd not suspended\n");
 		break;
-	case HCD_STATE_SUSPENDED:
+	case USB_STATE_SUSPENDED:
 		dev_dbg (hcd->self.controller, "hcd already suspended\n");
 		break;
 	default:
+		/* remote wakeup needs hub->suspend() cooperation */
+		// pci_enable_wake (dev, 3, 1);
+
+		pci_save_state (dev, hcd->pci_state);
+
+		/* driver may want to disable DMA etc */
+		hcd->state = USB_STATE_QUIESCING;
 		retval = hcd->driver->suspend (hcd, state);
 		if (retval)
 			dev_dbg (hcd->self.controller, 
 					"suspend fail, retval %d\n",
 					retval);
-		else {
-			hcd->state = HCD_STATE_SUSPENDED;
-			pci_save_state (dev, hcd->pci_state);
-#ifdef	CONFIG_USB_SUSPEND
-			pci_enable_wake (dev, state, hcd->remote_wakeup);
-			pci_enable_wake (dev, 4, hcd->remote_wakeup);
-#endif
-			/* no DMA or IRQs except in D0 */
-			pci_disable_device (dev);
-			free_irq (hcd->irq, hcd);
-			
-			if (has_pci_pm)
-				retval = pci_set_power_state (dev, state);
-			dev->dev.power.power_state = state;
-			if (retval < 0) {
-				dev_dbg (&dev->dev,
-						"PCI suspend fail, %d\n",
-						retval);
-				(void) usb_hcd_pci_resume (dev);
-			}
-		}
+		else
+			hcd->state = USB_STATE_SUSPENDED;
 	}
+
+ 	pci_set_power_state (dev, state);
 	return retval;
 }
 EXPORT_SYMBOL (usb_hcd_pci_suspend);
@@ -339,37 +317,23 @@
 {
 	struct usb_hcd		*hcd;
 	int			retval;
-	int			has_pci_pm;
 
 	hcd = pci_get_drvdata(dev);
-	has_pci_pm = pci_find_capability(dev, PCI_CAP_ID_PM);
-	if (has_pci_pm)
-		dev_dbg(hcd->self.controller, "resume from state D%d\n",
-				dev->current_state);
+	dev_dbg (hcd->self.controller, "resume from state D%d\n",
+			dev->current_state);
 
-	if (hcd->state != HCD_STATE_SUSPENDED) {
+	if (hcd->state != USB_STATE_SUSPENDED) {
 		dev_dbg (hcd->self.controller, 
 				"can't resume, not suspended!\n");
 		return -EL3HLT;
 	}
 	hcd->state = USB_STATE_RESUMING;
 
-	if (has_pci_pm)
-		pci_set_power_state (dev, 0);
-	dev->dev.power.power_state = 0;
-	retval = request_irq (dev->irq, usb_hcd_irq, SA_SHIRQ,
-				hcd->description, hcd);
-	if (retval < 0) {
-		dev_err (hcd->self.controller,
-			"can't restore IRQ after resume!\n");
-		return retval;
-	}
-	pci_set_master (dev);
+	pci_set_power_state (dev, 0);
 	pci_restore_state (dev, hcd->pci_state);
-#ifdef	CONFIG_USB_SUSPEND
-	pci_enable_wake (dev, dev->current_state, 0);
-	pci_enable_wake (dev, 4, 0);
-#endif
+
+	/* remote wakeup needs hub->suspend() cooperation */
+	// pci_enable_wake (dev, 3, 0);
 
 	retval = hcd->driver->resume (hcd);
 	if (!HCD_IS_RUNNING (hcd->state)) {
diff -Naur linuxppc-2.6.9/drivers/usb/core/hub.c linuxppc-2.6.9-dream/drivers/usb/core/hub.c
--- linuxppc-2.6.9/drivers/usb/core/hub.c	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/hub.c	2005-09-19 21:40:05.000000000 +0200
@@ -9,21 +9,20 @@
  */
 
 #include <linux/config.h>
-#ifdef CONFIG_USB_DEBUG
-	#define DEBUG
-#else
-	#undef DEBUG
-#endif
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/module.h>
-#include <linux/moduleparam.h>
 #include <linux/completion.h>
 #include <linux/sched.h>
 #include <linux/list.h>
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/ioctl.h>
+#ifdef CONFIG_USB_DEBUG
+	#define DEBUG
+#else
+	#undef DEBUG
+#endif
 #include <linux/usb.h>
 #include <linux/usbdevice_fs.h>
 #include <linux/suspend.h>
@@ -36,24 +35,17 @@
 #include "hcd.h"
 #include "hub.h"
 
-/* Protect struct usb_device state and children members */
-static spinlock_t device_state_lock = SPIN_LOCK_UNLOCKED;
-
 /* Wakes up khubd */
 static spinlock_t hub_event_lock = SPIN_LOCK_UNLOCKED;
+static DECLARE_MUTEX(usb_address0_sem);
 
 static LIST_HEAD(hub_event_list);	/* List of hubs needing servicing */
+static LIST_HEAD(hub_list);		/* List of all hubs (for cleanup) */
 
 static DECLARE_WAIT_QUEUE_HEAD(khubd_wait);
 static pid_t khubd_pid = 0;			/* PID of khubd */
 static DECLARE_COMPLETION(khubd_exited);
 
-/* cycle leds on hubs that aren't blinking for attention */
-static int blinkenlights = 0;
-module_param (blinkenlights, bool, S_IRUGO);
-MODULE_PARM_DESC (blinkenlights, "true to cycle leds on hubs");
-
-
 #ifdef	DEBUG
 static inline char *portspeed (int portstatus)
 {
@@ -67,15 +59,15 @@
 #endif
 
 /* for dev_info, dev_dbg, etc */
-static inline struct device *hubdev (struct usb_device *hdev)
+static inline struct device *hubdev (struct usb_device *dev)
 {
-	return &hdev->actconfig->interface[0]->dev;
+	return &dev->actconfig->interface[0]->dev;
 }
 
 /* USB 2.0 spec Section 11.24.4.5 */
-static int get_hub_descriptor(struct usb_device *hdev, void *data, int size)
+static int get_hub_descriptor(struct usb_device *dev, void *data, int size)
 {
-	return usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),
+	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 		USB_REQ_GET_DESCRIPTOR, USB_DIR_IN | USB_RT_HUB,
 		USB_DT_HUB << 8, 0, data, size, HZ * USB_CTRL_GET_TIMEOUT);
 }
@@ -83,134 +75,39 @@
 /*
  * USB 2.0 spec Section 11.24.2.1
  */
-static int clear_hub_feature(struct usb_device *hdev, int feature)
+static int clear_hub_feature(struct usb_device *dev, int feature)
 {
-	return usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 		USB_REQ_CLEAR_FEATURE, USB_RT_HUB, feature, 0, NULL, 0, HZ);
 }
 
 /*
  * USB 2.0 spec Section 11.24.2.2
+ * BUG: doesn't handle port indicator selector in high byte of wIndex
  */
-static int clear_port_feature(struct usb_device *hdev, int port, int feature)
+static int clear_port_feature(struct usb_device *dev, int port, int feature)
 {
-	return usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 		USB_REQ_CLEAR_FEATURE, USB_RT_PORT, feature, port, NULL, 0, HZ);
 }
 
 /*
  * USB 2.0 spec Section 11.24.2.13
+ * BUG: doesn't handle port indicator selector in high byte of wIndex
  */
-static int set_port_feature(struct usb_device *hdev, int port, int feature)
+static int set_port_feature(struct usb_device *dev, int port, int feature)
 {
-	return usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 		USB_REQ_SET_FEATURE, USB_RT_PORT, feature, port, NULL, 0, HZ);
 }
 
 /*
- * USB 2.0 spec Section 11.24.2.7.1.10 and table 11-7
- * for info about using port indicators
- */
-static void set_port_led(
-	struct usb_device *hdev,
-	int port,
-	int selector
-)
-{
-	int status = set_port_feature(hdev, (selector << 8) | port,
-			USB_PORT_FEAT_INDICATOR);
-	if (status < 0)
-		dev_dbg (hubdev (hdev),
-			"port %d indicator %s status %d\n",
-			port,
-			({ char *s; switch (selector) {
-			case HUB_LED_AMBER: s = "amber"; break;
-			case HUB_LED_GREEN: s = "green"; break;
-			case HUB_LED_OFF: s = "off"; break;
-			case HUB_LED_AUTO: s = "auto"; break;
-			default: s = "??"; break;
-			}; s; }),
-			status);
-}
-
-#define	LED_CYCLE_PERIOD	((2*HZ)/3)
-
-static void led_work (void *__hub)
-{
-	struct usb_hub		*hub = __hub;
-	struct usb_device	*hdev = hub->hdev;
-	unsigned		i;
-	unsigned		changed = 0;
-	int			cursor = -1;
-
-	if (hdev->state != USB_STATE_CONFIGURED || hub->quiescing)
-		return;
-
-	for (i = 0; i < hub->descriptor->bNbrPorts; i++) {
-		unsigned	selector, mode;
-
-		/* 30%-50% duty cycle */
-
-		switch (hub->indicator[i]) {
-		/* cycle marker */
-		case INDICATOR_CYCLE:
-			cursor = i;
-			selector = HUB_LED_AUTO;
-			mode = INDICATOR_AUTO;
-			break;
-		/* blinking green = sw attention */
-		case INDICATOR_GREEN_BLINK:
-			selector = HUB_LED_GREEN;
-			mode = INDICATOR_GREEN_BLINK_OFF;
-			break;
-		case INDICATOR_GREEN_BLINK_OFF:
-			selector = HUB_LED_OFF;
-			mode = INDICATOR_GREEN_BLINK;
-			break;
-		/* blinking amber = hw attention */
-		case INDICATOR_AMBER_BLINK:
-			selector = HUB_LED_AMBER;
-			mode = INDICATOR_AMBER_BLINK_OFF;
-			break;
-		case INDICATOR_AMBER_BLINK_OFF:
-			selector = HUB_LED_OFF;
-			mode = INDICATOR_AMBER_BLINK;
-			break;
-		/* blink green/amber = reserved */
-		case INDICATOR_ALT_BLINK:
-			selector = HUB_LED_GREEN;
-			mode = INDICATOR_ALT_BLINK_OFF;
-			break;
-		case INDICATOR_ALT_BLINK_OFF:
-			selector = HUB_LED_AMBER;
-			mode = INDICATOR_ALT_BLINK;
-			break;
-		default:
-			continue;
-		}
-		if (selector != HUB_LED_AUTO)
-			changed = 1;
-		set_port_led(hdev, i + 1, selector);
-		hub->indicator[i] = mode;
-	}
-	if (!changed && blinkenlights) {
-		cursor++;
-		cursor %= hub->descriptor->bNbrPorts;
-		set_port_led(hdev, cursor + 1, HUB_LED_GREEN);
-		hub->indicator[cursor] = INDICATOR_CYCLE;
-		changed++;
-	}
-	if (changed)
-		schedule_delayed_work(&hub->leds, LED_CYCLE_PERIOD);
-}
-
-/*
  * USB 2.0 spec Section 11.24.2.6
  */
-static int get_hub_status(struct usb_device *hdev,
+static int get_hub_status(struct usb_device *dev,
 		struct usb_hub_status *data)
 {
-	return usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),
+	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 		USB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_HUB, 0, 0,
 		data, sizeof(*data), HZ * USB_CTRL_GET_TIMEOUT);
 }
@@ -218,10 +115,10 @@
 /*
  * USB 2.0 spec Section 11.24.2.7
  */
-static int get_port_status(struct usb_device *hdev, int port,
+static int get_port_status(struct usb_device *dev, int port,
 		struct usb_port_status *data)
 {
-	return usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),
+	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 		USB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, 0, port,
 		data, sizeof(*data), HZ * USB_CTRL_GET_TIMEOUT);
 }
@@ -231,14 +128,19 @@
 {
 	struct usb_hub *hub = (struct usb_hub *)urb->context;
 	int status;
-	int i;
-	unsigned long bits;
+
+	spin_lock(&hub_event_lock);
+	hub->urb_active = 0;
+	if (hub->urb_complete) {	/* disconnect or rmmod */
+		complete(hub->urb_complete);
+		goto done;
+	}
 
 	switch (urb->status) {
 	case -ENOENT:		/* synchronous unlink */
 	case -ECONNRESET:	/* async unlink */
 	case -ESHUTDOWN:	/* hardware going away */
-		return;
+		goto done;
 
 	default:		/* presumably an error */
 		/* Cause a hub reset after 10 consecutive errors */
@@ -250,40 +152,35 @@
 	
 	/* let khubd handle things */
 	case 0:			/* we got data:  port status changed */
-		bits = 0;
-		for (i = 0; i < urb->actual_length; ++i)
-			bits |= ((unsigned long) ((*hub->buffer)[i]))
-					<< (i*8);
-		hub->event_bits[0] = bits;
 		break;
 	}
 
 	hub->nerrors = 0;
 
 	/* Something happened, let khubd figure it out */
-	spin_lock(&hub_event_lock);
 	if (list_empty(&hub->event_list)) {
-		list_add_tail(&hub->event_list, &hub_event_list);
+		list_add(&hub->event_list, &hub_event_list);
 		wake_up(&khubd_wait);
 	}
-	spin_unlock(&hub_event_lock);
 
 resubmit:
-	if (hub->quiescing)
-		return;
-
 	if ((status = usb_submit_urb (hub->urb, GFP_ATOMIC)) != 0
-			&& status != -ENODEV && status != -EPERM)
-		dev_err (&hub->intf->dev, "resubmit --> %d\n", status);
+			/* ENODEV means we raced disconnect() */
+			&& status != -ENODEV)
+		dev_err (&hub->intf->dev, "resubmit --> %d\n", urb->status);
+	if (status == 0)
+		hub->urb_active = 1;
+done:
+	spin_unlock(&hub_event_lock);
 }
 
 /* USB 2.0 spec Section 11.24.2.3 */
 static inline int
-hub_clear_tt_buffer (struct usb_device *hdev, u16 devinfo, u16 tt)
+hub_clear_tt_buffer (struct usb_device *hub, u16 devinfo, u16 tt)
 {
-	return usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),
-			       HUB_CLEAR_TT_BUFFER, USB_RT_PORT, devinfo,
-			       tt, NULL, 0, HZ);
+	return usb_control_msg (hub, usb_rcvctrlpipe (hub, 0),
+		HUB_CLEAR_TT_BUFFER, USB_RT_PORT,
+		devinfo, tt, 0, 0, HZ);
 }
 
 /*
@@ -301,7 +198,7 @@
 	while (!list_empty (&hub->tt.clear_list)) {
 		struct list_head	*temp;
 		struct usb_tt_clear	*clear;
-		struct usb_device	*hdev = hub->hdev;
+		struct usb_device	*dev;
 		int			status;
 
 		temp = hub->tt.clear_list.next;
@@ -310,12 +207,13 @@
 
 		/* drop lock so HCD can concurrently report other TT errors */
 		spin_unlock_irqrestore (&hub->tt.lock, flags);
-		status = hub_clear_tt_buffer (hdev, clear->devinfo, clear->tt);
+		dev = interface_to_usbdev (hub->intf);
+		status = hub_clear_tt_buffer (dev, clear->devinfo, clear->tt);
 		spin_lock_irqsave (&hub->tt.lock, flags);
 
 		if (status)
-			dev_err (&hdev->dev,
-				"clear tt %d (%04x) error %d\n",
+			err ("usb-%s-%s clear tt %d (%04x) error %d",
+				dev->bus->bus_name, dev->devpath,
 				clear->tt, clear->devinfo, status);
 		kfree (clear);
 	}
@@ -335,9 +233,9 @@
  * It may not be possible for that hub to handle additional full (or low)
  * speed transactions until that state is fully cleared out.
  */
-void usb_hub_tt_clear_buffer (struct usb_device *udev, int pipe)
+void usb_hub_tt_clear_buffer (struct usb_device *dev, int pipe)
 {
-	struct usb_tt		*tt = udev->tt;
+	struct usb_tt		*tt = dev->tt;
 	unsigned long		flags;
 	struct usb_tt_clear	*clear;
 
@@ -346,15 +244,16 @@
 	 * there can be many TTs per hub).  even if they're uncommon.
 	 */
 	if ((clear = kmalloc (sizeof *clear, SLAB_ATOMIC)) == 0) {
-		dev_err (&udev->dev, "can't save CLEAR_TT_BUFFER state\n");
+		err ("can't save CLEAR_TT_BUFFER state for hub at usb-%s-%s",
+			dev->bus->bus_name, tt->hub->devpath);
 		/* FIXME recover somehow ... RESET_TT? */
 		return;
 	}
 
 	/* info that CLEAR_TT_BUFFER needs */
-	clear->tt = tt->multi ? udev->ttport : 1;
+	clear->tt = tt->multi ? dev->ttport : 1;
 	clear->devinfo = usb_pipeendpoint (pipe);
-	clear->devinfo |= udev->devnum << 4;
+	clear->devinfo |= dev->devnum << 4;
 	clear->devinfo |= usb_pipecontrol (pipe)
 			? (USB_ENDPOINT_XFER_CONTROL << 11)
 			: (USB_ENDPOINT_XFER_BULK << 11);
@@ -370,28 +269,29 @@
 
 static void hub_power_on(struct usb_hub *hub)
 {
+	struct usb_device *dev;
 	int i;
 
-	/* if hub supports power switching, enable power on each port */
-	if ((hub->descriptor->wHubCharacteristics & HUB_CHAR_LPSM) < 2) {
-		dev_dbg(&hub->intf->dev, "enabling power on all ports\n");
-		for (i = 0; i < hub->descriptor->bNbrPorts; i++)
-			set_port_feature(hub->hdev, i + 1,
-					USB_PORT_FEAT_POWER);
-	}
+	/* Enable power to the ports */
+	dev_dbg(hubdev(interface_to_usbdev(hub->intf)),
+		"enabling power on all ports\n");
+	dev = interface_to_usbdev(hub->intf);
+	for (i = 0; i < hub->descriptor->bNbrPorts; i++)
+		set_port_feature(dev, i + 1, USB_PORT_FEAT_POWER);
 
 	/* Wait for power to be enabled */
-	msleep(hub->descriptor->bPwrOn2PwrGood * 2);
+	wait_ms(hub->descriptor->bPwrOn2PwrGood * 2);
 }
 
 static int hub_hub_status(struct usb_hub *hub,
 		u16 *status, u16 *change)
 {
+	struct usb_device *dev = interface_to_usbdev (hub->intf);
 	int ret;
 
-	ret = get_hub_status(hub->hdev, &hub->status->hub);
+	ret = get_hub_status(dev, &hub->status->hub);
 	if (ret < 0)
-		dev_err (&hub->intf->dev,
+		dev_err (hubdev (dev),
 			"%s failed (err = %d)\n", __FUNCTION__, ret);
 	else {
 		*status = le16_to_cpu(hub->status->hub.wHubStatus);
@@ -404,14 +304,14 @@
 static int hub_configure(struct usb_hub *hub,
 	struct usb_endpoint_descriptor *endpoint)
 {
-	struct usb_device *hdev = hub->hdev;
-	struct device *hub_dev = &hub->intf->dev;
+	struct usb_device *dev = interface_to_usbdev (hub->intf);
+	struct device *hub_dev;
 	u16 hubstatus, hubchange;
 	unsigned int pipe;
 	int maxp, ret;
 	char *message;
 
-	hub->buffer = usb_buffer_alloc(hdev, sizeof(*hub->buffer), GFP_KERNEL,
+	hub->buffer = usb_buffer_alloc(dev, sizeof(*hub->buffer), GFP_KERNEL,
 			&hub->buffer_dma);
 	if (!hub->buffer) {
 		message = "can't allocate hub irq buffer";
@@ -437,7 +337,7 @@
 	 * hub->descriptor can handle USB_MAXCHILDREN ports,
 	 * but the hub can/will return fewer bytes here.
 	 */
-	ret = get_hub_descriptor(hdev, hub->descriptor,
+	ret = get_hub_descriptor(dev, hub->descriptor,
 			sizeof(*hub->descriptor));
 	if (ret < 0) {
 		message = "can't read hub descriptor";
@@ -448,9 +348,10 @@
 		goto fail;
 	}
 
-	hdev->maxchild = hub->descriptor->bNbrPorts;
-	dev_info (hub_dev, "%d port%s detected\n", hdev->maxchild,
-		(hdev->maxchild == 1) ? "" : "s");
+	hub_dev = hubdev(dev);
+	dev->maxchild = hub->descriptor->bNbrPorts;
+	dev_info (hub_dev, "%d port%s detected\n", dev->maxchild,
+		(dev->maxchild == 1) ? "" : "s");
 
 	le16_to_cpus(&hub->descriptor->wHubCharacteristics);
 
@@ -458,11 +359,11 @@
 		int	i;
 		char	portstr [USB_MAXCHILDREN + 1];
 
-		for (i = 0; i < hdev->maxchild; i++)
+		for (i = 0; i < dev->maxchild; i++)
 			portstr[i] = hub->descriptor->DeviceRemovable
 				    [((i + 1) / 8)] & (1 << ((i + 1) % 8))
 				? 'F' : 'R';
-		portstr[hdev->maxchild] = 0;
+		portstr[dev->maxchild] = 0;
 		dev_dbg(hub_dev, "compound device; port removable status: %s\n", portstr);
 	} else
 		dev_dbg(hub_dev, "standalone hub\n");
@@ -476,7 +377,7 @@
 			break;
 		case 0x02:
 		case 0x03:
-			dev_dbg(hub_dev, "no power switching (usb 1.0)\n");
+			dev_dbg(hub_dev, "unknown reserved power switching mode\n");
 			break;
 	}
 
@@ -496,32 +397,32 @@
 	spin_lock_init (&hub->tt.lock);
 	INIT_LIST_HEAD (&hub->tt.clear_list);
 	INIT_WORK (&hub->tt.kevent, hub_tt_kevent, hub);
-	switch (hdev->descriptor.bDeviceProtocol) {
+	switch (dev->descriptor.bDeviceProtocol) {
 		case 0:
 			break;
 		case 1:
 			dev_dbg(hub_dev, "Single TT\n");
-			hub->tt.hub = hdev;
+			hub->tt.hub = dev;
 			break;
 		case 2:
-			ret = usb_set_interface(hdev, 0, 1);
+			ret = usb_set_interface(dev, 0, 1);
 			if (ret == 0) {
 				dev_dbg(hub_dev, "TT per port\n");
 				hub->tt.multi = 1;
 			} else
 				dev_err(hub_dev, "Using single TT (err %d)\n",
 					ret);
-			hub->tt.hub = hdev;
+			hub->tt.hub = dev;
 			break;
 		default:
 			dev_dbg(hub_dev, "Unrecognized hub protocol %d\n",
-				hdev->descriptor.bDeviceProtocol);
+				dev->descriptor.bDeviceProtocol);
 			break;
 	}
 
 	switch (hub->descriptor->wHubCharacteristics & HUB_CHAR_TTTT) {
 		case 0x00:
-			if (hdev->descriptor.bDeviceProtocol != 0)
+			if (dev->descriptor.bDeviceProtocol != 0)
 				dev_dbg(hub_dev, "TT requires at most 8 FS bit times\n");
 			break;
 		case 0x20:
@@ -535,33 +436,14 @@
 			break;
 	}
 
-	/* probe() zeroes hub->indicator[] */
-	if (hub->descriptor->wHubCharacteristics & HUB_CHAR_PORTIND) {
-		hub->has_indicators = 1;
-		dev_dbg(hub_dev, "Port indicators are supported\n");
-	}
+	dev_dbg(hub_dev, "Port indicators are %s supported\n", 
+	    (hub->descriptor->wHubCharacteristics & HUB_CHAR_PORTIND)
+	    	? "" : "not");
 
 	dev_dbg(hub_dev, "power on to power good time: %dms\n",
 		hub->descriptor->bPwrOn2PwrGood * 2);
-
-	/* power budgeting mostly matters with bus-powered hubs,
-	 * and battery-powered root hubs (may provide just 8 mA).
-	 */
-	ret = usb_get_status(hdev, USB_RECIP_DEVICE, 0, &hubstatus);
-	if (ret < 0) {
-		message = "can't get hub status";
-		goto fail;
-	}
-	cpu_to_le16s(&hubstatus);
-	if ((hubstatus & (1 << USB_DEVICE_SELF_POWERED)) == 0) {
-		dev_dbg(hub_dev, "hub controller current requirement: %dmA\n",
-			hub->descriptor->bHubContrCurrent);
-		hub->power_budget = (501 - hub->descriptor->bHubContrCurrent)
-					/ 2;
-		dev_dbg(hub_dev, "%dmA bus power budget for children\n",
-			hub->power_budget * 2);
-	}
-
+	dev_dbg(hub_dev, "hub controller current requirement: %dmA\n",
+		hub->descriptor->bHubContrCurrent);
 
 	ret = hub_hub_status(hub, &hubstatus, &hubchange);
 	if (ret < 0) {
@@ -569,19 +451,16 @@
 		goto fail;
 	}
 
-	/* local power status reports aren't always correct */
-	if (hdev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_SELFPOWER)
-		dev_dbg(hub_dev, "local power source is %s\n",
-			(hubstatus & HUB_STATUS_LOCAL_POWER)
-			? "lost (inactive)" : "good");
-
-	if ((hub->descriptor->wHubCharacteristics & HUB_CHAR_OCPM) == 0)
-		dev_dbg(hub_dev, "%sover-current condition exists\n",
-			(hubstatus & HUB_STATUS_OVERCURRENT) ? "" : "no ");
+	dev_dbg(hub_dev, "local power source is %s\n",
+		(hubstatus & HUB_STATUS_LOCAL_POWER)
+		? "lost (inactive)" : "good");
+
+	dev_dbg(hub_dev, "%sover-current condition exists\n",
+		(hubstatus & HUB_STATUS_OVERCURRENT) ? "" : "no ");
 
 	/* Start the interrupt endpoint */
-	pipe = usb_rcvintpipe(hdev, endpoint->bEndpointAddress);
-	maxp = usb_maxpacket(hdev, pipe, usb_pipeout(pipe));
+	pipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);
+	maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
 
 	if (maxp > sizeof(*hub->buffer))
 		maxp = sizeof(*hub->buffer);
@@ -593,7 +472,7 @@
 		goto fail;
 	}
 
-	usb_fill_int_urb(hub->urb, hdev, pipe, *hub->buffer, maxp, hub_irq,
+	usb_fill_int_urb(hub->urb, dev, pipe, *hub->buffer, maxp, hub_irq,
 		hub, endpoint->bInterval);
 	hub->urb->transfer_dma = hub->buffer_dma;
 	hub->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
@@ -602,78 +481,55 @@
 		message = "couldn't submit status urb";
 		goto fail;
 	}
+	hub->urb_active = 1;
 
 	/* Wake up khubd */
 	wake_up(&khubd_wait);
 
-	/* maybe start cycling the hub leds */
-	if (hub->has_indicators && blinkenlights) {
-		set_port_led(hdev, 1, HUB_LED_GREEN);
-		hub->indicator [0] = INDICATOR_CYCLE;
-		schedule_delayed_work(&hub->leds, LED_CYCLE_PERIOD);
-	}
-
 	hub_power_on(hub);
 
 	return 0;
 
 fail:
-	dev_err (hub_dev, "config failed, %s (err %d)\n",
+	dev_err (&hub->intf->dev, "config failed, %s (err %d)\n",
 			message, ret);
 	/* hub_disconnect() frees urb and descriptor */
 	return ret;
 }
 
-static unsigned highspeed_hubs;
-
-static void hub_quiesce(struct usb_hub *hub)
-{
-	/* stop khubd and related activity */
-	hub->quiescing = 1;
-	usb_kill_urb(hub->urb);
-	if (hub->has_indicators)
-		cancel_delayed_work(&hub->leds);
-	if (hub->has_indicators || hub->tt.hub)
-		flush_scheduled_work();
-}
-
-#ifdef	CONFIG_USB_SUSPEND
-
-static void hub_reactivate(struct usb_hub *hub)
-{
-	int	status;
-
-	hub->quiescing = 0;
-	status = usb_submit_urb(hub->urb, GFP_NOIO);
-	if (status < 0)
-		dev_err(&hub->intf->dev, "reactivate --> %d\n", status);
-	if (hub->has_indicators && blinkenlights)
-		schedule_delayed_work(&hub->leds, LED_CYCLE_PERIOD);
-}
-
-#endif
-
 static void hub_disconnect(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata (intf);
-	struct usb_device *hdev;
+	DECLARE_COMPLETION(urb_complete);
+	unsigned long flags;
 
 	if (!hub)
 		return;
-	hdev = hub->hdev;
-
-	if (hdev->speed == USB_SPEED_HIGH)
-		highspeed_hubs--;
 
 	usb_set_intfdata (intf, NULL);
+	spin_lock_irqsave(&hub_event_lock, flags);
+	hub->urb_complete = &urb_complete;
 
-	hub_quiesce(hub);
-	usb_free_urb(hub->urb);
-	hub->urb = NULL;
-
-	spin_lock_irq(&hub_event_lock);
+	/* Delete it and then reset it */
 	list_del_init(&hub->event_list);
-	spin_unlock_irq(&hub_event_lock);
+	list_del_init(&hub->hub_list);
+
+	spin_unlock_irqrestore(&hub_event_lock, flags);
+
+	down(&hub->khubd_sem); /* Wait for khubd to leave this hub alone. */
+	up(&hub->khubd_sem);
+
+	/* assuming we used keventd, it must quiesce too */
+	if (hub->tt.hub)
+		flush_scheduled_work ();
+
+	if (hub->urb) {
+		usb_unlink_urb(hub->urb);
+		if (hub->urb_active)
+			wait_for_completion(&urb_complete);
+		usb_free_urb(hub->urb);
+		hub->urb = NULL;
+	}
 
 	if (hub->descriptor) {
 		kfree(hub->descriptor);
@@ -686,7 +542,8 @@
 	}
 
 	if (hub->buffer) {
-		usb_buffer_free(hdev, sizeof(*hub->buffer), hub->buffer,
+		usb_buffer_free(interface_to_usbdev(intf),
+				sizeof(*hub->buffer), hub->buffer,
 				hub->buffer_dma);
 		hub->buffer = NULL;
 	}
@@ -699,44 +556,47 @@
 {
 	struct usb_host_interface *desc;
 	struct usb_endpoint_descriptor *endpoint;
-	struct usb_device *hdev;
+	struct usb_device *dev;
 	struct usb_hub *hub;
-	struct device *hub_dev;
+	unsigned long flags;
 
 	desc = intf->cur_altsetting;
-	hdev = interface_to_usbdev(intf);
-	hub_dev = &intf->dev;
+	dev = interface_to_usbdev(intf);
 
 	/* Some hubs have a subclass of 1, which AFAICT according to the */
 	/*  specs is not defined, but it works */
 	if ((desc->desc.bInterfaceSubClass != 0) &&
 	    (desc->desc.bInterfaceSubClass != 1)) {
 descriptor_error:
-		dev_err (hub_dev, "bad descriptor, ignoring hub\n");
+		dev_err (&intf->dev, "bad descriptor, ignoring hub\n");
 		return -EIO;
 	}
 
 	/* Multiple endpoints? What kind of mutant ninja-hub is this? */
-	if (desc->desc.bNumEndpoints != 1)
+	if (desc->desc.bNumEndpoints != 1) {
 		goto descriptor_error;
+	}
 
 	endpoint = &desc->endpoint[0].desc;
 
 	/* Output endpoint? Curiouser and curiouser.. */
-	if (!(endpoint->bEndpointAddress & USB_DIR_IN))
+	if (!(endpoint->bEndpointAddress & USB_DIR_IN)) {
 		goto descriptor_error;
+	}
 
 	/* If it's not an interrupt endpoint, we'd better punt! */
 	if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
-			!= USB_ENDPOINT_XFER_INT)
+			!= USB_ENDPOINT_XFER_INT) {
 		goto descriptor_error;
+		return -EIO;
+	}
 
 	/* We found a hub */
-	dev_info (hub_dev, "USB hub found\n");
+	dev_info (hubdev (dev), "USB hub found\n");
 
 	hub = kmalloc(sizeof(*hub), GFP_KERNEL);
 	if (!hub) {
-		dev_dbg (hub_dev, "couldn't kmalloc hub struct\n");
+		err("couldn't kmalloc hub struct");
 		return -ENOMEM;
 	}
 
@@ -744,13 +604,15 @@
 
 	INIT_LIST_HEAD(&hub->event_list);
 	hub->intf = intf;
-	hub->hdev = hdev;
-	INIT_WORK(&hub->leds, led_work, hub);
+	init_MUTEX(&hub->khubd_sem);
 
-	usb_set_intfdata (intf, hub);
+	/* Record the new hub's existence */
+	spin_lock_irqsave(&hub_event_lock, flags);
+	INIT_LIST_HEAD(&hub->hub_list);
+	list_add(&hub->hub_list, &hub_list);
+	spin_unlock_irqrestore(&hub_event_lock, flags);
 
-	if (hdev->speed == USB_SPEED_HIGH)
-		highspeed_hubs++;
+	usb_set_intfdata (intf, hub);
 
 	if (hub_configure(hub, endpoint) >= 0)
 		return 0;
@@ -762,7 +624,7 @@
 static int
 hub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)
 {
-	struct usb_device *hdev = interface_to_usbdev (intf);
+	struct usb_device *hub = interface_to_usbdev (intf);
 
 	/* assert ifno == 0 (part of hub spec) */
 	switch (code) {
@@ -772,16 +634,16 @@
 		int i;
 
 		spin_lock_irqsave(&hub_event_lock, flags);
-		if (hdev->devnum <= 0)
+		if (hub->devnum <= 0)
 			info->nports = 0;
 		else {
-			info->nports = hdev->maxchild;
+			info->nports = hub->maxchild;
 			for (i = 0; i < info->nports; i++) {
-				if (hdev->children[i] == NULL)
+				if (hub->children[i] == NULL)
 					info->port[i] = 0;
 				else
 					info->port[i] =
-						hdev->children[i]->devnum;
+						hub->children[i]->devnum;
 			}
 		}
 		spin_unlock_irqrestore(&hub_event_lock, flags);
@@ -794,28 +656,27 @@
 	}
 }
 
-/* caller has locked the hub and must own the device lock */
 static int hub_reset(struct usb_hub *hub)
 {
-	struct usb_device *hdev = hub->hdev;
+	struct usb_device *dev = interface_to_usbdev(hub->intf);
 	int i;
 
 	/* Disconnect any attached devices */
 	for (i = 0; i < hub->descriptor->bNbrPorts; i++) {
-		if (hdev->children[i])
-			usb_disconnect(&hdev->children[i]);
+		if (dev->children[i])
+			usb_disconnect(&dev->children[i]);
 	}
 
 	/* Attempt to reset the hub */
 	if (hub->urb)
-		usb_kill_urb(hub->urb);
+		usb_unlink_urb(hub->urb);
 	else
 		return -1;
 
-	if (__usb_reset_device(hdev))
+	if (usb_reset_device(dev))
 		return -1;
 
-	hub->urb->dev = hdev;                                                    
+	hub->urb->dev = dev;                                                    
 	if (usb_submit_urb(hub->urb, GFP_KERNEL))
 		return -1;
 
@@ -824,453 +685,36 @@
 	return 0;
 }
 
-/* caller has locked the hub */
-/* FIXME!  This routine should be subsumed into hub_reset */
-static void hub_start_disconnect(struct usb_device *hdev)
+static void hub_start_disconnect(struct usb_device *dev)
 {
-	struct usb_device *parent = hdev->parent;
+	struct usb_device *parent = dev->parent;
 	int i;
 
 	/* Find the device pointer to disconnect */
 	if (parent) {
 		for (i = 0; i < parent->maxchild; i++) {
-			if (parent->children[i] == hdev) {
+			if (parent->children[i] == dev) {
 				usb_disconnect(&parent->children[i]);
 				return;
 			}
 		}
 	}
 
-	dev_err(&hdev->dev, "cannot disconnect hub!\n");
-}
-
-
-static void recursively_mark_NOTATTACHED(struct usb_device *udev)
-{
-	int i;
-
-	for (i = 0; i < udev->maxchild; ++i) {
-		if (udev->children[i])
-			recursively_mark_NOTATTACHED(udev->children[i]);
-	}
-	udev->state = USB_STATE_NOTATTACHED;
-}
-
-/* grab device/port lock, returning index of that port (zero based).
- * protects the upstream link used by this device from concurrent
- * tree operations like suspend, resume, reset, and disconnect, which
- * apply to everything downstream of a given port.
- */
-static int locktree(struct usb_device *udev)
-{
-	int			t;
-	struct usb_device	*hdev;
-
-	if (!udev)
-		return -ENODEV;
-
-	/* root hub is always the first lock in the series */
-	hdev = udev->parent;
-	if (!hdev) {
-		down(&udev->serialize);
-		return 0;
-	}
-
-	/* on the path from root to us, lock everything from
-	 * top down, dropping parent locks when not needed
-	 *
-	 * NOTE: if disconnect were to ignore the locking, we'd need
-	 * to get extra refcounts to everything since hdev->children
-	 * and udev->parent could be invalidated while we work...
-	 */
-	t = locktree(hdev);
-	if (t < 0)
-		return t;
-	spin_lock_irq(&device_state_lock);
-	for (t = 0; t < hdev->maxchild; t++) {
-		if (hdev->children[t] == udev) {
-			/* everything is fail-fast once disconnect
-			 * processing starts
-			 */
-			if (udev->state == USB_STATE_NOTATTACHED)
-				break;
-
-			/* when everyone grabs locks top->bottom,
-			 * non-overlapping work may be concurrent
-			 */
-			spin_unlock_irq(&device_state_lock);
-			down(&udev->serialize);
-			up(&hdev->serialize);
-			return t;
-		}
-	}
-	spin_unlock_irq(&device_state_lock);
-	up(&hdev->serialize);
-	return -ENODEV;
-}
-
-/**
- * usb_set_device_state - change a device's current state (usbcore-internal)
- * @udev: pointer to device whose state should be changed
- * @new_state: new state value to be stored
- *
- * udev->state is _not_ protected by the device lock.  This
- * is so that devices can be marked as disconnected as soon as possible,
- * without having to wait for the semaphore to be released.  Instead,
- * changes to the state must be protected by the device_state_lock spinlock.
- *
- * Once a device has been added to the device tree, all changes to its state
- * should be made using this routine.  The state should _not_ be set directly.
- *
- * If udev->state is already USB_STATE_NOTATTACHED then no change is made.
- * Otherwise udev->state is set to new_state, and if new_state is
- * USB_STATE_NOTATTACHED then all of udev's descendant's states are also set
- * to USB_STATE_NOTATTACHED.
- */
-void usb_set_device_state(struct usb_device *udev,
-		enum usb_device_state new_state)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&device_state_lock, flags);
-	if (udev->state == USB_STATE_NOTATTACHED)
-		;	/* do nothing */
-	else if (new_state != USB_STATE_NOTATTACHED)
-		udev->state = new_state;
-	else
-		recursively_mark_NOTATTACHED(udev);
-	spin_unlock_irqrestore(&device_state_lock, flags);
-}
-
-
-static void choose_address(struct usb_device *udev)
-{
-	int		devnum;
-	struct usb_bus	*bus = udev->bus;
-
-	/* If khubd ever becomes multithreaded, this will need a lock */
-
-	/* Try to allocate the next devnum beginning at bus->devnum_next. */
-	devnum = find_next_zero_bit(bus->devmap.devicemap, 128,
-			bus->devnum_next);
-	if (devnum >= 128)
-		devnum = find_next_zero_bit(bus->devmap.devicemap, 128, 1);
-
-	bus->devnum_next = ( devnum >= 127 ? 1 : devnum + 1);
-
-	if (devnum < 128) {
-		set_bit(devnum, bus->devmap.devicemap);
-		udev->devnum = devnum;
-	}
-}
-
-static void release_address(struct usb_device *udev)
-{
-	if (udev->devnum > 0) {
-		clear_bit(udev->devnum, udev->bus->devmap.devicemap);
-		udev->devnum = -1;
-	}
-}
-
-/**
- * usb_disconnect - disconnect a device (usbcore-internal)
- * @pdev: pointer to device being disconnected, into a locked hub
- * Context: !in_interrupt ()
- *
- * Something got disconnected. Get rid of it, and all of its children.
- * If *pdev is a normal device then the parent hub should be locked.
- * If *pdev is a root hub then this routine will acquire the
- * usb_bus_list_lock on behalf of the caller.
- *
- * Only hub drivers (including virtual root hub drivers for host
- * controllers) should ever call this.
- *
- * This call is synchronous, and may not be used in an interrupt context.
- */
-void usb_disconnect(struct usb_device **pdev)
-{
-	struct usb_device	*udev = *pdev;
-	int			i;
-
-	if (!udev) {
-		pr_debug ("%s nodev\n", __FUNCTION__);
-		return;
-	}
-
-	/* mark the device as inactive, so any further urb submissions for
-	 * this device (and any of its children) will fail immediately.
-	 * this quiesces everyting except pending urbs.
-	 */
-	usb_set_device_state(udev, USB_STATE_NOTATTACHED);
-
-	/* lock the bus list on behalf of HCDs unregistering their root hubs */
-	if (!udev->parent)
-		down(&usb_bus_list_lock);
-	down(&udev->serialize);
-
-	dev_info (&udev->dev, "USB disconnect, address %d\n", udev->devnum);
-
-	/* Free up all the children before we remove this device */
-	for (i = 0; i < USB_MAXCHILDREN; i++) {
-		if (udev->children[i])
-			usb_disconnect(&udev->children[i]);
-	}
-
-	/* deallocate hcd/hardware state ... nuking all pending urbs and
-	 * cleaning up all state associated with the current configuration
-	 * so that the hardware is now fully quiesced.
-	 */
-	usb_disable_device(udev, 0);
-
-	/* Free the device number, remove the /proc/bus/usb entry and
-	 * the sysfs attributes, and delete the parent's children[]
-	 * (or root_hub) pointer.
-	 */
-	dev_dbg (&udev->dev, "unregistering device\n");
-	release_address(udev);
-	usbfs_remove_device(udev);
-	usb_remove_sysfs_dev_files(udev);
-
-	/* Avoid races with recursively_mark_NOTATTACHED() and locktree() */
-	spin_lock_irq(&device_state_lock);
-	*pdev = NULL;
-	spin_unlock_irq(&device_state_lock);
-
-	up(&udev->serialize);
-	if (!udev->parent)
-		up(&usb_bus_list_lock);
-
-	device_unregister(&udev->dev);
-}
-
-static int choose_configuration(struct usb_device *udev)
-{
-	int c, i;
-
-	/* NOTE: this should interact with hub power budgeting */
-
-	c = udev->config[0].desc.bConfigurationValue;
-	if (udev->descriptor.bNumConfigurations != 1) {
-		for (i = 0; i < udev->descriptor.bNumConfigurations; i++) {
-			struct usb_interface_descriptor	*desc;
-
-			/* heuristic:  Linux is more likely to have class
-			 * drivers, so avoid vendor-specific interfaces.
-			 */
-			desc = &udev->config[i].intf_cache[0]
-					->altsetting->desc;
-			if (desc->bInterfaceClass == USB_CLASS_VENDOR_SPEC)
-				continue;
-			/* COMM/2/all is CDC ACM, except 0xff is MSFT RNDIS */
-			if (desc->bInterfaceClass == USB_CLASS_COMM
-					&& desc->bInterfaceSubClass == 2
-					&& desc->bInterfaceProtocol == 0xff)
-				continue;
-			c = udev->config[i].desc.bConfigurationValue;
-			break;
-		}
-		dev_info(&udev->dev,
-			"configuration #%d chosen from %d choices\n",
-			c, udev->descriptor.bNumConfigurations);
-	}
-	return c;
-}
-
-#ifdef DEBUG
-static void show_string(struct usb_device *udev, char *id, int index)
-{
-	char *buf;
-
-	if (!index)
-		return;
-	if (!(buf = kmalloc(256, GFP_KERNEL)))
-		return;
-	if (usb_string(udev, index, buf, 256) > 0)
-		dev_printk(KERN_INFO, &udev->dev, "%s: %s\n", id, buf);
-	kfree(buf);
-}
-
-#else
-static inline void show_string(struct usb_device *udev, char *id, int index)
-{}
-#endif
-
-#ifdef	CONFIG_USB_OTG
-#include "otg_whitelist.h"
-#endif
-
-/**
- * usb_new_device - perform initial device setup (usbcore-internal)
- * @udev: newly addressed device (in ADDRESS state)
- *
- * This is called with devices which have been enumerated, but not yet
- * configured.  The device descriptor is available, but not descriptors
- * for any device configuration.  The caller must have locked udev and
- * either the parent hub (if udev is a normal device) or else the
- * usb_bus_list_lock (if udev is a root hub).  The parent's pointer to
- * udev has already been installed, but udev is not yet visible through
- * sysfs or other filesystem code.
- *
- * Returns 0 for success (device is configured and listed, with its
- * interfaces, in sysfs); else a negative errno value.
- *
- * This call is synchronous, and may not be used in an interrupt context.
- *
- * Only the hub driver should ever call this; root hub registration
- * uses it indirectly.
- */
-int usb_new_device(struct usb_device *udev)
-{
-	int err;
-	int c;
-
-	err = usb_get_configuration(udev);
-	if (err < 0) {
-		dev_err(&udev->dev, "can't read configurations, error %d\n",
-			err);
-		goto fail;
-	}
-
-	/* Tell the world! */
-	dev_dbg(&udev->dev, "new device strings: Mfr=%d, Product=%d, "
-			"SerialNumber=%d\n",
-			udev->descriptor.iManufacturer,
-			udev->descriptor.iProduct,
-			udev->descriptor.iSerialNumber);
-
-	if (udev->descriptor.iProduct)
-		show_string(udev, "Product",
-				udev->descriptor.iProduct);
-	if (udev->descriptor.iManufacturer)
-		show_string(udev, "Manufacturer",
-				udev->descriptor.iManufacturer);
-	if (udev->descriptor.iSerialNumber)
-		show_string(udev, "SerialNumber",
-				udev->descriptor.iSerialNumber);
-
-#ifdef	CONFIG_USB_OTG
-	/*
-	 * OTG-aware devices on OTG-capable root hubs may be able to use SRP,
-	 * to wake us after we've powered off VBUS; and HNP, switching roles
-	 * "host" to "peripheral".  The OTG descriptor helps figure this out.
-	 */
-	if (!udev->bus->is_b_host
-			&& udev->config
-			&& udev->parent == udev->bus->root_hub) {
-		struct usb_otg_descriptor	*desc = 0;
-		struct usb_bus			*bus = udev->bus;
-
-		/* descriptor may appear anywhere in config */
-		if (__usb_get_extra_descriptor (udev->rawdescriptors[0],
-					udev->config[0].desc.wTotalLength,
-					USB_DT_OTG, (void **) &desc) == 0) {
-			if (desc->bmAttributes & USB_OTG_HNP) {
-				unsigned		port;
-				struct usb_device	*root = udev->parent;
-				
-				for (port = 0; port < root->maxchild; port++) {
-					if (root->children[port] == udev)
-						break;
-				}
-				port++;
-
-				dev_info(&udev->dev,
-					"Dual-Role OTG device on %sHNP port\n",
-					(port == bus->otg_port)
-						? "" : "non-");
-
-				/* enable HNP before suspend, it's simpler */
-				if (port == bus->otg_port)
-					bus->b_hnp_enable = 1;
-				err = usb_control_msg(udev,
-					usb_sndctrlpipe(udev, 0),
-					USB_REQ_SET_FEATURE, 0,
-					bus->b_hnp_enable
-						? USB_DEVICE_B_HNP_ENABLE
-						: USB_DEVICE_A_ALT_HNP_SUPPORT,
-					0, NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
-				if (err < 0) {
-					/* OTG MESSAGE: report errors here,
-					 * customize to match your product.
-					 */
-					dev_info(&udev->dev,
-						"can't set HNP mode; %d\n",
-						err);
-					bus->b_hnp_enable = 0;
-				}
-			}
-		}
-	}
-
-	if (!is_targeted(udev)) {
-
-		/* Maybe it can talk to us, though we can't talk to it.
-		 * (Includes HNP test device.)
-		 */
-		if (udev->bus->b_hnp_enable || udev->bus->is_b_host) {
-			static int __usb_suspend_device (struct usb_device *,
-						int port, u32 state);
-			err = __usb_suspend_device(udev,
-					udev->bus->otg_port - 1,
-					PM_SUSPEND_MEM);
-			if (err < 0)
-				dev_dbg(&udev->dev, "HNP fail, %d\n", err);
-		}
-		err = -ENODEV;
-		goto fail;
-	}
-#endif
-
-	/* put device-specific files into sysfs */
-	err = device_add (&udev->dev);
-	if (err) {
-		dev_err(&udev->dev, "can't device_add, error %d\n", err);
-		goto fail;
-	}
-	usb_create_sysfs_dev_files (udev);
-
-	/* choose and set the configuration. that registers the interfaces
-	 * with the driver core, and lets usb device drivers bind to them.
-	 */
-	c = choose_configuration(udev);
-	if (c < 0)
-		dev_warn(&udev->dev,
-				"can't choose an initial configuration\n");
-	else {
-		err = usb_set_configuration(udev, c);
-		if (err) {
-			dev_err(&udev->dev, "can't set config #%d, error %d\n",
-					c, err);
-			usb_remove_sysfs_dev_files(udev);
-			device_del(&udev->dev);
-			goto fail;
-		}
-	}
-
-	/* USB device state == configured ... usable */
-
-	/* add a /proc/bus/usb entry */
-	usbfs_add_device(udev);
-	return 0;
-
-fail:
-	usb_set_device_state(udev, USB_STATE_NOTATTACHED);
-	return err;
+	err("cannot disconnect hub %s", dev->devpath);
 }
 
-
-static int hub_port_status(struct usb_device *hdev, int port,
+static int hub_port_status(struct usb_device *dev, int port,
 			       u16 *status, u16 *change)
 {
-	struct usb_hub *hub = usb_get_intfdata(hdev->actconfig->interface[0]);
+	struct usb_hub *hub = usb_get_intfdata(dev->actconfig->interface[0]);
 	int ret;
 
 	if (!hub)
 		return -ENODEV;
 
-	ret = get_port_status(hdev, port + 1, &hub->status->port);
+	ret = get_port_status(dev, port + 1, &hub->status->port);
 	if (ret < 0)
-		dev_err (&hub->intf->dev,
+		dev_err (hubdev (dev),
 			"%s failed (err = %d)\n", __FUNCTION__, ret);
 	else {
 		*status = le16_to_cpu(hub->status->port.wPortStatus);
@@ -1280,18 +724,16 @@
 	return ret;
 }
 
-#define PORT_RESET_TRIES	5
-#define SET_ADDRESS_TRIES	2
-#define GET_DESCRIPTOR_TRIES	2
-#define SET_CONFIG_TRIES	2
-
+#define HUB_RESET_TRIES		5
+#define HUB_PROBE_TRIES		2
 #define HUB_ROOT_RESET_TIME	50	/* times are in msec */
 #define HUB_SHORT_RESET_TIME	10
 #define HUB_LONG_RESET_TIME	200
 #define HUB_RESET_TIMEOUT	500
 
-static int hub_port_wait_reset(struct usb_device *hdev, int port,
-				struct usb_device *udev, unsigned int delay)
+/* return: -1 on error, 0 on success, 1 on disconnect.  */
+static int hub_port_wait_reset(struct usb_device *hub, int port,
+				struct usb_device *dev, unsigned int delay)
 {
 	int delay_time, ret;
 	u16 portstatus;
@@ -1301,30 +743,31 @@
 			delay_time < HUB_RESET_TIMEOUT;
 			delay_time += delay) {
 		/* wait to give the device a chance to reset */
-		msleep(delay);
+		wait_ms(delay);
 
 		/* read and decode port status */
-		ret = hub_port_status(hdev, port, &portstatus, &portchange);
-		if (ret < 0)
-			return ret;
+		ret = hub_port_status(hub, port, &portstatus, &portchange);
+		if (ret < 0) {
+			return -1;
+		}
 
 		/* Device went away? */
 		if (!(portstatus & USB_PORT_STAT_CONNECTION))
-			return -ENOTCONN;
+			return 1;
 
 		/* bomb out completely if something weird happened */
 		if ((portchange & USB_PORT_STAT_C_CONNECTION))
-			return -EINVAL;
+			return -1;
 
 		/* if we`ve finished resetting, then break out of the loop */
 		if (!(portstatus & USB_PORT_STAT_RESET) &&
 		    (portstatus & USB_PORT_STAT_ENABLE)) {
 			if (portstatus & USB_PORT_STAT_HIGH_SPEED)
-				udev->speed = USB_SPEED_HIGH;
+				dev->speed = USB_SPEED_HIGH;
 			else if (portstatus & USB_PORT_STAT_LOW_SPEED)
-				udev->speed = USB_SPEED_LOW;
+				dev->speed = USB_SPEED_LOW;
 			else
-				udev->speed = USB_SPEED_FULL;
+				dev->speed = USB_SPEED_FULL;
 			return 0;
 		}
 
@@ -1332,1077 +775,235 @@
 		if (delay_time >= 2 * HUB_SHORT_RESET_TIME)
 			delay = HUB_LONG_RESET_TIME;
 
-		dev_dbg (hubdev (hdev),
+		dev_dbg (hubdev (hub),
 			"port %d not reset yet, waiting %dms\n",
 			port + 1, delay);
 	}
 
-	return -EBUSY;
+	return -1;
 }
 
-static int hub_port_reset(struct usb_device *hdev, int port,
-				struct usb_device *udev, unsigned int delay)
+/* return: -1 on error, 0 on success, 1 on disconnect.  */
+static int hub_port_reset(struct usb_device *hub, int port,
+				struct usb_device *dev, unsigned int delay)
 {
 	int i, status;
-	struct device *hub_dev = hubdev (hdev);
 
 	/* Reset the port */
-	for (i = 0; i < PORT_RESET_TRIES; i++) {
-		status = set_port_feature(hdev, port + 1, USB_PORT_FEAT_RESET);
-		if (status)
-			dev_err(hub_dev, "cannot reset port %d (err = %d)\n",
-					port + 1, status);
-		else
-			status = hub_port_wait_reset(hdev, port, udev, delay);
+	for (i = 0; i < HUB_RESET_TRIES; i++) {
+		set_port_feature(hub, port + 1, USB_PORT_FEAT_RESET);
 
 		/* return on disconnect or reset */
-		if (status == -ENOTCONN || status == 0) {
-			clear_port_feature(hdev,
+		status = hub_port_wait_reset(hub, port, dev, delay);
+		if (status != -1) {
+			clear_port_feature(hub,
 				port + 1, USB_PORT_FEAT_C_RESET);
-			/* FIXME need disconnect() for NOTATTACHED device */
-			usb_set_device_state(udev, status
+			dev->state = status
 					? USB_STATE_NOTATTACHED
-					: USB_STATE_DEFAULT);
+					: USB_STATE_DEFAULT;
 			return status;
 		}
 
-		dev_dbg (hub_dev,
+		dev_dbg (hubdev (hub),
 			"port %d not enabled, trying reset again...\n",
 			port + 1);
 		delay = HUB_LONG_RESET_TIME;
 	}
 
-	dev_err (hub_dev,
+	dev_err (hubdev (hub),
 		"Cannot enable port %i.  Maybe the USB cable is bad?\n",
 		port + 1);
 
-	return status;
+	return -1;
 }
 
-static int hub_port_disable(struct usb_device *hdev, int port)
+int hub_port_disable(struct usb_device *hub, int port)
 {
 	int ret;
 
-	if (hdev->children[port]) {
-		/* FIXME need disconnect() for NOTATTACHED device */
-		usb_set_device_state(hdev->children[port],
-				USB_STATE_NOTATTACHED);
-	}
-	ret = clear_port_feature(hdev, port + 1, USB_PORT_FEAT_ENABLE);
+	ret = clear_port_feature(hub, port + 1, USB_PORT_FEAT_ENABLE);
 	if (ret)
-		dev_err(hubdev(hdev), "cannot disable port %d (err = %d)\n",
+		dev_err(hubdev(hub), "cannot disable port %d (err = %d)\n",
 			port + 1, ret);
 
 	return ret;
 }
 
-#ifdef	CONFIG_USB_SUSPEND
-
-/*
- * Selective port suspend reduces power; most suspended devices draw
- * less than 500 uA.  It's also used in OTG, along with remote wakeup.
- * All devices below the suspended port are also suspended.
+/* USB 2.0 spec, 7.1.7.3 / fig 7-29:
+ *
+ * Between connect detection and reset signaling there must be a delay
+ * of 100ms at least for debounce and power-settling. The corresponding
+ * timer shall restart whenever the downstream port detects a disconnect.
+ * 
+ * Apparently there are some bluetooth and irda-dongles and a number
+ * of low-speed devices which require longer delays of about 200-400ms.
+ * Not covered by the spec - but easy to deal with.
  *
- * Devices leave suspend state when the host wakes them up.  Some devices
- * also support "remote wakeup", where the device can activate the USB
- * tree above them to deliver data, such as a keypress or packet.  In
- * some cases, this wakes the USB host.
+ * This implementation uses 400ms minimum debounce timeout and checks
+ * every 25ms for transient disconnects to restart the delay.
  */
-static int hub_port_suspend(struct usb_device *hdev, int port)
-{
-	int			status;
-	struct usb_device	*udev;
-
-	udev = hdev->children[port - 1];
-	// dev_dbg(hubdev(hdev), "suspend port %d\n", port);
 
-	/* enable remote wakeup when appropriate; this lets the device
-	 * wake up the upstream hub (including maybe the root hub).
-	 *
-	 * NOTE:  OTG devices may issue remote wakeup (or SRP) even when
-	 * we don't explicitly enable it here.
-	 */
-	if (udev->actconfig
-			// && FIXME (remote wakeup enabled on this bus)
-			// ... currently assuming it's always appropriate
-			&& (udev->actconfig->desc.bmAttributes
-				& USB_CONFIG_ATT_WAKEUP) != 0) {
-		status = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-				USB_REQ_SET_FEATURE, USB_RECIP_DEVICE,
-				USB_DEVICE_REMOTE_WAKEUP, 0,
-				NULL, 0,
-				USB_CTRL_SET_TIMEOUT);
-		if (status)
-			dev_dbg(&udev->dev,
-				"won't remote wakeup, status %d\n",
-				status);
-	}
-
-	/* see 7.1.7.6 */
-	status = set_port_feature(hdev, port, USB_PORT_FEAT_SUSPEND);
-	if (status) {
-		dev_dbg(hubdev(hdev),
-			"can't suspend port %d, status %d\n",
-			port, status);
-		/* paranoia:  "should not happen" */
-		(void) usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
-				USB_DEVICE_REMOTE_WAKEUP, 0,
-				NULL, 0,
-				USB_CTRL_SET_TIMEOUT);
-	} else {
-		/* device has up to 10 msec to fully suspend */
-		dev_dbg(&udev->dev, "usb suspend\n");
-		udev->state = USB_STATE_SUSPENDED;
-		msleep(10);
-	}
-	return status;
-}
+#define HUB_DEBOUNCE_TIMEOUT	400
+#define HUB_DEBOUNCE_STEP	 25
+#define HUB_DEBOUNCE_STABLE	  4
 
-/*
- * Devices on USB hub ports have only one "suspend" state, corresponding
- * to ACPI D2 (PM_SUSPEND_MEM), "may cause the device to lose some context".
- * State transitions include:
- *
- *   - suspend, resume ... when the VBUS power link stays live
- *   - suspend, disconnect ... VBUS lost
- *
- * Once VBUS drop breaks the circuit, the port it's using has to go through
- * normal re-enumeration procedures, starting with enabling VBUS power.
- * Other than re-initializing the hub (plug/unplug, except for root hubs),
- * Linux (2.6) currently has NO mechanisms to initiate that:  no khubd
- * timer, no SRP, no requests through sysfs.
- */
-static int __usb_suspend_device (struct usb_device *udev, int port, u32 state)
+/* return: -1 on error, 0 on success, 1 on disconnect.  */
+static int hub_port_debounce(struct usb_device *hub, int port)
 {
-	int	status;
+	int ret;
+	int delay_time, stable_count;
+	u16 portchange, portstatus;
+	unsigned connection;
 
-	if (port < 0)
-		return port;
+	connection = 0;
+	stable_count = 0;
+	for (delay_time = 0; delay_time < HUB_DEBOUNCE_TIMEOUT; delay_time += HUB_DEBOUNCE_STEP) {
+		wait_ms(HUB_DEBOUNCE_STEP);
 
-	/* NOTE:  udev->serialize released on all real returns! */
+		ret = hub_port_status(hub, port, &portstatus, &portchange);
+		if (ret < 0)
+			return -1;
 
-	if (state <= udev->dev.power.power_state
-			|| state < PM_SUSPEND_MEM
-			|| udev->state == USB_STATE_SUSPENDED
-			|| udev->state == USB_STATE_NOTATTACHED) {
-		up(&udev->serialize);
-		return 0;
-	}
+		if ((portstatus & USB_PORT_STAT_CONNECTION) == connection) {
+			if (connection) {
+				if (++stable_count == HUB_DEBOUNCE_STABLE)
+					break;
+			}
+		} else {
+			stable_count = 0;
+		}
+		connection = portstatus & USB_PORT_STAT_CONNECTION;
 
-	/* suspend interface drivers; if this is a hub, it
-	 * suspends the child devices
-	 */
-	if (udev->actconfig) {
-		int	i;
-
-		for (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {
-			struct usb_interface	*intf;
-			struct usb_driver	*driver;
-
-			intf = udev->actconfig->interface[i];
-			if (state <= intf->dev.power.power_state)
-				continue;
-			if (!intf->dev.driver)
-				continue;
-			driver = to_usb_driver(intf->dev.driver);
-
-			if (driver->suspend) {
-				status = driver->suspend(intf, state);
-				if (intf->dev.power.power_state != state
-						|| status)
-					dev_err(&intf->dev,
-						"suspend %d fail, code %d\n",
-						state, status);
-			}
-
-			/* only drivers with suspend() can ever resume();
-			 * and after power loss, even they won't.
-			 * bus_rescan_devices() can rebind drivers later.
-			 *
-			 * FIXME the PM core self-deadlocks when unbinding
-			 * drivers during suspend/resume ... everything grabs
-			 * dpm_sem (not a spinlock, ugh).  we want to unbind,
-			 * since we know every driver's probe/disconnect works
-			 * even for drivers that can't suspend.
-			 */
-			if (!driver->suspend || state > PM_SUSPEND_MEM) {
-#if 1
-				dev_warn(&intf->dev, "resume is unsafe!\n");
-#else
-				down_write(&usb_bus_type.rwsem);
-				device_release_driver(&intf->dev);
-				up_write(&usb_bus_type.rwsem);
-#endif
-			}
-		}
-	}
-
-	/*
-	 * FIXME this needs port power off call paths too, to help force
-	 * USB into the "generic" PM model.  At least for devices on
-	 * ports that aren't using ganged switching (usually root hubs).
-	 *
-	 * NOTE: SRP-capable links should adopt more aggressive poweroff
-	 * policies (when HNP doesn't apply) once we have mechanisms to
-	 * turn power back on!  (Likely not before 2.7...)
-	 */
-	if (state > PM_SUSPEND_MEM) {
-		dev_warn(&udev->dev, "no poweroff yet, suspending instead\n");
-		state = PM_SUSPEND_MEM;
-	}
-
-	/* "global suspend" of the HC-to-USB interface (root hub), or
-	 * "selective suspend" of just one hub-device link.
-	 */
-	if (!udev->parent) {
-		struct usb_bus	*bus = udev->bus;
-		if (bus && bus->op->hub_suspend)
-			status = bus->op->hub_suspend (bus);
-		else
-			status = -EOPNOTSUPP;
-	} else
-		status = hub_port_suspend(udev->parent, port + 1);
-
-	if (status == 0)
-		udev->dev.power.power_state = state;
-	up(&udev->serialize);
-	return status;
-}
-
-/**
- * usb_suspend_device - suspend a usb device
- * @udev: device that's no longer in active use
- * @state: PM_SUSPEND_MEM to suspend
- * Context: must be able to sleep; device not locked
- *
- * Suspends a USB device that isn't in active use, conserving power.
- * Devices may wake out of a suspend, if anything important happens,
- * using the remote wakeup mechanism.  They may also be taken out of
- * suspend by the host, using usb_resume_device().  It's also routine
- * to disconnect devices while they are suspended.
- *
- * Suspending OTG devices may trigger HNP, if that's been enabled
- * between a pair of dual-role devices.  That will change roles, such
- * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.
- *
- * Returns 0 on success, else negative errno.
- */
-int usb_suspend_device(struct usb_device *udev, u32 state)
-{
-	return __usb_suspend_device(udev, locktree(udev), state);
-}
-
-/*
- * hardware resume signaling is finished, either because of selective
- * resume (by host) or remote wakeup (by device) ... now see what changed
- * in the tree that's rooted at this device.
- */
-static int finish_port_resume(struct usb_device *udev)
-{
-	int	status;
-	u16	devstatus;
-
-	/* caller owns udev->serialize */
-	dev_dbg(&udev->dev, "usb resume\n");
-	udev->dev.power.power_state = PM_SUSPEND_ON;
-
-	/* usb ch9 identifies four variants of SUSPENDED, based on what
-	 * state the device resumes to.  Linux currently won't see the
-	 * first two on the host side; they'd be inside hub_port_init()
-	 * during many timeouts, but khubd can't suspend until later.
-	 */
-	udev->state = udev->actconfig
-		? USB_STATE_CONFIGURED
-		: USB_STATE_ADDRESS;
-
- 	/* 10.5.4.5 says be sure devices in the tree are still there.
- 	 * For now let's assume the device didn't go crazy on resume,
-	 * and device drivers will know about any resume quirks.
-	 */
-	status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &devstatus);
-	if (status < 0)
-		dev_dbg(&udev->dev,
-			"gone after usb resume? status %d\n",
-			status);
-	else if (udev->actconfig) {
-		unsigned	i;
-
-		le16_to_cpus(&devstatus);
-		if (devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP)) {
-			status = usb_control_msg(udev,
-					usb_sndctrlpipe(udev, 0),
-					USB_REQ_CLEAR_FEATURE,
-						USB_RECIP_DEVICE,
-					USB_DEVICE_REMOTE_WAKEUP, 0,
-					NULL, 0,
-					USB_CTRL_SET_TIMEOUT);
-			if (status) {
-				dev_dbg(&udev->dev, "disable remote "
-					"wakeup, status %d\n", status);
-				status = 0;
-			}
+		if ((portchange & USB_PORT_STAT_C_CONNECTION)) {
+			clear_port_feature(hub, port+1, USB_PORT_FEAT_C_CONNECTION);
 		}
-
-		/* resume interface drivers; if this is a hub, it
-		 * resumes the child devices
-		 */
-		for (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {
-			struct usb_interface	*intf;
-			struct usb_driver	*driver;
-
-			intf = udev->actconfig->interface[i];
-			if (intf->dev.power.power_state == PM_SUSPEND_ON)
-				continue;
-			if (!intf->dev.driver) {
-				/* FIXME maybe force to alt 0 */
-				continue;
-			}
-			driver = to_usb_driver(intf->dev.driver);
-
-			/* bus_rescan_devices() may rebind drivers */
-			if (!driver->resume)
-				continue;
-
-			/* can we do better than just logging errors? */
-			status = driver->resume(intf);
-			if (intf->dev.power.power_state != PM_SUSPEND_ON
-					|| status)
-				dev_dbg(&intf->dev,
-					"resume fail, state %d code %d\n",
-					intf->dev.power.power_state, status);
-		}
-		status = 0;
-
-	} else if (udev->devnum <= 0) {
-		dev_dbg(&udev->dev, "bogus resume!\n");
-		status = -EINVAL;
 	}
-	return status;
-}
 
-static int
-hub_port_resume(struct usb_device *hdev, int port)
-{
-	int			status;
-	struct usb_device	*udev;
-
-	udev = hdev->children[port - 1];
-	// dev_dbg(hubdev(hdev), "resume port %d\n", port);
-
-	/* see 7.1.7.7; affects power usage, but not budgeting */
-	status = clear_port_feature(hdev, port, USB_PORT_FEAT_SUSPEND);
-	if (status) {
-		dev_dbg(&hdev->actconfig->interface[0]->dev,
-			"can't resume port %d, status %d\n",
-			port, status);
-	} else {
-		u16		devstatus;
-		u16		portchange;
-
-		/* drive resume for at least 20 msec */
-		dev_dbg(&udev->dev, "RESUME\n");
-		msleep(25);
-
-#define LIVE_FLAGS	( USB_PORT_STAT_POWER \
-			| USB_PORT_STAT_ENABLE \
-			| USB_PORT_STAT_CONNECTION)
-
-		/* Virtual root hubs can trigger on GET_PORT_STATUS to
-		 * stop resume signaling.  Then finish the resume
-		 * sequence.
-		 */
-		devstatus = portchange = 0;
-		status = hub_port_status(hdev, port - 1,
-				&devstatus, &portchange);
-		if (status < 0
-				|| (devstatus & LIVE_FLAGS) != LIVE_FLAGS
-				|| (devstatus & USB_PORT_STAT_SUSPEND) != 0
-				) {
-			dev_dbg(&hdev->actconfig->interface[0]->dev,
-				"port %d status %04x.%04x after resume, %d\n",
-				port, portchange, devstatus, status);
-		} else {
-			/* TRSMRCY = 10 msec */
-			msleep(10);
-			status = finish_port_resume(udev);
-		}
-	}
-	if (status < 0)
-		status = hub_port_disable(hdev, port);
+	dev_dbg (hubdev (hub),
+		"debounce: port %d: delay %dms stable %d status 0x%x\n",
+		port + 1, delay_time, stable_count, portstatus);
 
-	return status;
+	return ((portstatus&USB_PORT_STAT_CONNECTION)) ? 0 : 1;
 }
 
-static int hub_resume (struct usb_interface *intf);
-
-/**
- * usb_resume_device - re-activate a suspended usb device
- * @udev: device to re-activate
- * Context: must be able to sleep; device not locked
- *
- * This will re-activate the suspended device, increasing power usage
- * while letting drivers communicate again with its endpoints.
- * USB resume explicitly guarantees that the power session between
- * the host and the device is the same as it was when the device
- * suspended.
- *
- * Returns 0 on success, else negative errno.
- */
-int usb_resume_device(struct usb_device *udev)
+static void hub_port_connect_change(struct usb_hub *hubstate, int port,
+					u16 portstatus, u16 portchange)
 {
-	int			port, status;
-
-	port = locktree(udev);
-	if (port < 0)
-		return port;
-
-	/* "global resume" of the HC-to-USB interface (root hub), or
-	 * selective resume of one hub-to-device port
-	 */
-	if (!udev->parent) {
-		struct usb_bus	*bus = udev->bus;
-		if (bus && bus->op->hub_resume)
-			status = bus->op->hub_resume (bus);
-		else
-			status = -EOPNOTSUPP;
-		if (status == 0) {
-			/* TRSMRCY = 10 msec */
-			msleep(10);
-			status = hub_resume (bus->root_hub
-					->actconfig->interface[0]);
-		}
-	} else if (udev->state == USB_STATE_SUSPENDED) {
-		status = hub_port_resume(udev->parent, port + 1);
-	} else {
-		status = 0;
-		udev->dev.power.power_state = PM_SUSPEND_ON;
-	}
-	if (status < 0) {
-		dev_dbg(&udev->dev, "can't resume, status %d\n",
-			status);
-	}
-
-	up(&udev->serialize);
-
-	/* rebind drivers that had no suspend() */
-	bus_rescan_devices(&usb_bus_type);
-
-	return status;
-}
+	struct usb_device *hub = interface_to_usbdev(hubstate->intf);
+	struct usb_device *dev;
+	unsigned int delay = HUB_SHORT_RESET_TIME;
+	int i;
 
-static int remote_wakeup(struct usb_device *udev)
-{
-	int	status = 0;
+	dev_dbg (&hubstate->intf->dev,
+		"port %d, status %x, change %x, %s\n",
+		port + 1, portstatus, portchange, portspeed (portstatus));
 
-	/* don't repeat RESUME sequence if this device
-	 * was already woken up by some other task
-	 */
-	down(&udev->serialize);
-	if (udev->state == USB_STATE_SUSPENDED) {
-		dev_dbg(&udev->dev, "RESUME (wakeup)\n");
-		/* TRSMRCY = 10 msec */
-		msleep(10);
-		status = finish_port_resume(udev);
-	}
-	up(&udev->serialize);
-	return status;
-}
-
-static int hub_suspend(struct usb_interface *intf, u32 state)
-{
-	struct usb_hub		*hub = usb_get_intfdata (intf);
-	struct usb_device	*hdev = hub->hdev;
-	unsigned		port;
-	int			status;
-
-	/* stop khubd and related activity */
-	hub_quiesce(hub);
-
-	/* then suspend every port */
-	for (port = 0; port < hdev->maxchild; port++) {
-		struct usb_device	*udev;
-
-		udev = hdev->children [port];
-		if (!udev)
-			continue;
-		down(&udev->serialize);
-		status = __usb_suspend_device(udev, port, state);
-		if (status < 0)
-			dev_dbg(&intf->dev, "suspend port %d --> %d\n",
-				port, status);
-	}
+	/* Clear the connection change status */
+	clear_port_feature(hub, port + 1, USB_PORT_FEAT_C_CONNECTION);
 
-	intf->dev.power.power_state = state;
-	return 0;
-}
-
-static int hub_resume(struct usb_interface *intf)
-{
-	struct usb_device	*hdev = interface_to_usbdev(intf);
-	struct usb_hub		*hub = usb_get_intfdata (intf);
-	unsigned		port;
-	int			status;
-
-	for (port = 0; port < hdev->maxchild; port++) {
-		struct usb_device	*udev;
-		u16			portstat, portchange;
-
-		udev = hdev->children [port];
-		status = hub_port_status(hdev, port, &portstat, &portchange);
-		if (status == 0) {
-			if (portchange & USB_PORT_STAT_C_SUSPEND) {
-				clear_port_feature(hdev, port + 1,
-					USB_PORT_FEAT_C_SUSPEND);
-				portchange &= ~USB_PORT_STAT_C_SUSPEND;
-			}
+	/* Disconnect any existing devices under this port */
+	if (hub->children[port])
+		usb_disconnect(&hub->children[port]);
 
-			/* let khubd handle disconnects etc */
-			if (portchange)
-				continue;
-		}
+	/* Return now if nothing is connected */
+	if (!(portstatus & USB_PORT_STAT_CONNECTION)) {
+		if (portstatus & USB_PORT_STAT_ENABLE)
+			hub_port_disable(hub, port);
 
-		if (!udev)
-			continue;
-		down (&udev->serialize);
-		if (portstat & USB_PORT_STAT_SUSPEND)
-			status = hub_port_resume(hdev, port + 1);
-		else {
-			status = finish_port_resume(udev);
-			if (status < 0)
-				status = hub_port_disable(hdev, port);
-			if (status < 0)
-				dev_dbg(&intf->dev, "resume port %d --> %d\n",
-					port, status);
-		}
-		up(&udev->serialize);
+		return;
 	}
-	intf->dev.power.power_state = PM_SUSPEND_ON;
-
-	hub_reactivate(hub);
-	return 0;
-}
-
-#else	/* !CONFIG_USB_SUSPEND */
-
-int usb_suspend_device(struct usb_device *udev, u32 state)
-{
-	return 0;
-}
-
-int usb_resume_device(struct usb_device *udev)
-{
-	return 0;
-}
-
-#define	hub_suspend		NULL
-#define	hub_resume		NULL
-#define	remote_wakeup(x)	0
-
-#endif	/* CONFIG_USB_SUSPEND */
-
-EXPORT_SYMBOL(usb_suspend_device);
-EXPORT_SYMBOL(usb_resume_device);
-
-
-
-/* USB 2.0 spec, 7.1.7.3 / fig 7-29:
- *
- * Between connect detection and reset signaling there must be a delay
- * of 100ms at least for debounce and power-settling.  The corresponding
- * timer shall restart whenever the downstream port detects a disconnect.
- * 
- * Apparently there are some bluetooth and irda-dongles and a number of
- * low-speed devices for which this debounce period may last over a second.
- * Not covered by the spec - but easy to deal with.
- *
- * This implementation uses a 1500ms total debounce timeout; if the
- * connection isn't stable by then it returns -ETIMEDOUT.  It checks
- * every 25ms for transient disconnects.  When the port status has been
- * unchanged for 100ms it returns the port status.
- */
-
-#define HUB_DEBOUNCE_TIMEOUT	1500
-#define HUB_DEBOUNCE_STEP	  25
-#define HUB_DEBOUNCE_STABLE	 100
 
-static int hub_port_debounce(struct usb_device *hdev, int port)
-{
-	int ret;
-	int total_time, stable_time = 0;
-	u16 portchange, portstatus;
-	unsigned connection = 0xffff;
-
-	for (total_time = 0; ; total_time += HUB_DEBOUNCE_STEP) {
-		ret = hub_port_status(hdev, port, &portstatus, &portchange);
-		if (ret < 0)
-			return ret;
-
-		if (!(portchange & USB_PORT_STAT_C_CONNECTION) &&
-		     (portstatus & USB_PORT_STAT_CONNECTION) == connection) {
-			stable_time += HUB_DEBOUNCE_STEP;
-			if (stable_time >= HUB_DEBOUNCE_STABLE)
-				break;
-		} else {
-			stable_time = 0;
-			connection = portstatus & USB_PORT_STAT_CONNECTION;
-		}
-
-		if (portchange & USB_PORT_STAT_C_CONNECTION) {
-			clear_port_feature(hdev, port+1,
-					USB_PORT_FEAT_C_CONNECTION);
-		}
-
-		if (total_time >= HUB_DEBOUNCE_TIMEOUT)
-			break;
-		msleep(HUB_DEBOUNCE_STEP);
+	if (hub_port_debounce(hub, port)) {
+		dev_err (&hubstate->intf->dev,
+			"connect-debounce failed, port %d disabled\n",
+			port+1);
+		hub_port_disable(hub, port);
+		return;
 	}
 
-	dev_dbg (hubdev (hdev),
-		"debounce: port %d: total %dms stable %dms status 0x%x\n",
-		port + 1, total_time, stable_time, portstatus);
-
-	if (stable_time < HUB_DEBOUNCE_STABLE)
-		return -ETIMEDOUT;
-	return portstatus;
-}
-
-static int hub_set_address(struct usb_device *udev)
-{
-	int retval;
-
-	if (udev->devnum == 0)
-		return -EINVAL;
-	if (udev->state != USB_STATE_DEFAULT &&
-			udev->state != USB_STATE_ADDRESS)
-		return -EINVAL;
-	retval = usb_control_msg(udev, (PIPE_CONTROL << 30) /* Address 0 */,
-		USB_REQ_SET_ADDRESS, 0, udev->devnum, 0,
-		NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
-	if (retval == 0)
-		usb_set_device_state(udev, USB_STATE_ADDRESS);
-	return retval;
-}
-
-/* Reset device, (re)assign address, get device descriptor.
- * Device connection must be stable, no more debouncing needed.
- * Returns device in USB_STATE_ADDRESS, except on error.
- *
- * If this is called for an already-existing device (as part of
- * usb_reset_device), the caller must own the device lock.  For a
- * newly detected device that is not accessible through any global
- * pointers, it's not necessary to lock the device.
- */
-static int
-hub_port_init (struct usb_device *hdev, struct usb_device *udev, int port)
-{
-	static DECLARE_MUTEX(usb_address0_sem);
-
-	int			i, j, retval;
-	unsigned		delay = HUB_SHORT_RESET_TIME;
-	enum usb_device_speed	oldspeed = udev->speed;
-
 	/* root hub ports have a slightly longer reset period
 	 * (from USB 2.0 spec, section 7.1.7.5)
 	 */
-	if (!hdev->parent) {
+	if (!hub->parent)
 		delay = HUB_ROOT_RESET_TIME;
-		if (port + 1 == hdev->bus->otg_port)
-			hdev->bus->b_hnp_enable = 0;
-	}
-
-	retval = clear_port_feature(hdev, port, USB_PORT_FEAT_SUSPEND);
-	if (retval < 0 && retval != -EPIPE)
-		dev_dbg(&udev->dev, "can't clear suspend; %d\n", retval);
 
 	/* Some low speed devices have problems with the quick delay, so */
 	/*  be a bit pessimistic with those devices. RHbug #23670 */
-	if (oldspeed == USB_SPEED_LOW)
+	if (portstatus & USB_PORT_STAT_LOW_SPEED)
 		delay = HUB_LONG_RESET_TIME;
 
 	down(&usb_address0_sem);
 
-	/* Reset the device; full speed may morph to high speed */
-	retval = hub_port_reset(hdev, port, udev, delay);
-	if (retval < 0)		/* error or disconnect */
-		goto fail;
-				/* success, speed is known */
-	retval = -ENODEV;
+	for (i = 0; i < HUB_PROBE_TRIES; i++) {
 
-	if (oldspeed != USB_SPEED_UNKNOWN && oldspeed != udev->speed) {
-		dev_dbg(&udev->dev, "device reset changed speed!\n");
-		goto fail;
-	}
-  
-	/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...
-	 * it's fixed size except for full speed devices.
-	 */
-	switch (udev->speed) {
-	case USB_SPEED_HIGH:		/* fixed at 64 */
-		i = 64;
-		break;
-	case USB_SPEED_FULL:		/* 8, 16, 32, or 64 */
-		/* to determine the ep0 maxpacket size, read the first 8
-		 * bytes from the device descriptor to get bMaxPacketSize0;
-		 * then correct our initial (small) guess.
-		 */
-		// FALLTHROUGH
-	case USB_SPEED_LOW:		/* fixed at 8 */
-		i = 8;
-		break;
-	default:
-		goto fail;
-	}
-	udev->epmaxpacketin [0] = i;
-	udev->epmaxpacketout[0] = i;
- 
-	dev_info (&udev->dev,
-			"%s %s speed USB device using address %d\n",
-			(udev->config) ? "reset" : "new",
-			({ char *speed; switch (udev->speed) {
-			case USB_SPEED_LOW:	speed = "low";	break;
-			case USB_SPEED_FULL:	speed = "full";	break;
-			case USB_SPEED_HIGH:	speed = "high";	break;
-			default: 		speed = "?";	break;
-			}; speed;}),
-			udev->devnum);
-
-	/* Set up TT records, if needed  */
-	if (hdev->tt) {
-		udev->tt = hdev->tt;
-		udev->ttport = hdev->ttport;
-	} else if (udev->speed != USB_SPEED_HIGH
-			&& hdev->speed == USB_SPEED_HIGH) {
-		struct usb_hub *hub;
-
-		hub = usb_get_intfdata(hdev->actconfig->interface[0]);
-		udev->tt = &hub->tt;
-		udev->ttport = port + 1;
-	}
- 
-	/* Why interleave GET_DESCRIPTOR and SET_ADDRESS this way?
-	 * Because device hardware and firmware is sometimes buggy in
-	 * this area, and this is how Linux has done it for ages.
-	 * Change it cautiously.
-	 *
-	 * NOTE:  Windows gets the descriptor first, seemingly to help
-	 * work around device bugs like "can't use addresses with bit 3
-	 * set in certain configurations".  Yes, really.
-	 */
-	for (i = 0; i < GET_DESCRIPTOR_TRIES; ++i) {
-		for (j = 0; j < SET_ADDRESS_TRIES; ++j) {
-			retval = hub_set_address(udev);
-			if (retval >= 0)
-				break;
-			msleep(200);
-		}
-		if (retval < 0) {
-			dev_err(&udev->dev,
-				"device not accepting address %d, error %d\n",
-				udev->devnum, retval);
-			goto fail;
-		}
- 
-		/* cope with hardware quirkiness:
-		 *  - let SET_ADDRESS settle, some device hardware wants it
-		 *  - read ep0 maxpacket even for high and low speed,
-  		 */
-		msleep(10);
-		retval = usb_get_device_descriptor(udev, 8);
-		if (retval >= 8)
+		/* Allocate a new device struct */
+		dev = usb_alloc_dev(hub, hub->bus, port);
+		if (!dev) {
+			dev_err (&hubstate->intf->dev,
+				"couldn't allocate usb_device\n");
 			break;
-		msleep(100);
-	}
-	if (retval != 8) {
-		dev_err(&udev->dev, "device descriptor read/%s, error %d\n",
-				"8", retval);
-		if (retval >= 0)
-			retval = -EMSGSIZE;
-		goto fail;
-	}
-	if (udev->speed == USB_SPEED_FULL
-			&& (udev->epmaxpacketin [0]
-				!= udev->descriptor.bMaxPacketSize0)) {
-		usb_disable_endpoint(udev, 0 + USB_DIR_IN);
-		usb_disable_endpoint(udev, 0 + USB_DIR_OUT);
-		udev->epmaxpacketin [0] = udev->descriptor.bMaxPacketSize0;
-		udev->epmaxpacketout[0] = udev->descriptor.bMaxPacketSize0;
-	}
-  
-	retval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);
-	if (retval < (signed)sizeof(udev->descriptor)) {
-		dev_err(&udev->dev, "device descriptor read/%s, error %d\n",
-			"all", retval);
-		if (retval >= 0)
-			retval = -ENOMSG;
-		goto fail;
-	}
-
-	retval = 0;
-
-fail:
-	up(&usb_address0_sem);
-	return retval;
-}
-
-static void
-check_highspeed (struct usb_hub *hub, struct usb_device *udev, int port)
-{
-	struct usb_qualifier_descriptor	*qual;
-	int				status;
-
-	qual = kmalloc (sizeof *qual, SLAB_KERNEL);
-	if (qual == 0)
-		return;
-
-	status = usb_get_descriptor (udev, USB_DT_DEVICE_QUALIFIER, 0,
-			qual, sizeof *qual);
-	if (status == sizeof *qual) {
-		dev_info(&udev->dev, "not running at top speed; "
-			"connect to a high speed hub\n");
-		/* hub LEDs are probably harder to miss than syslog */
-		if (hub->has_indicators) {
-			hub->indicator[port] = INDICATOR_GREEN_BLINK;
-			schedule_work (&hub->leds);
 		}
-	}
-	kfree (qual);
-}
-
-static unsigned
-hub_power_remaining (struct usb_hub *hub)
-{
-	struct usb_device *hdev = hub->hdev;
-	int remaining;
-	unsigned i;
-
-	remaining = hub->power_budget;
-	if (!remaining)		/* self-powered */
-		return 0;
 
-	for (i = 0; i < hdev->maxchild; i++) {
-		struct usb_device	*udev = hdev->children[i];
-		int			delta, ceiling;
-
-		if (!udev)
-			continue;
-
-		/* 100mA per-port ceiling, or 8mA for OTG ports */
-		if (i != (udev->bus->otg_port - 1) || hdev->parent)
-			ceiling = 50;
-		else
-			ceiling = 4;
-
-		if (udev->actconfig)
-			delta = udev->actconfig->desc.bMaxPower;
-		else
-			delta = ceiling;
-		// dev_dbg(&udev->dev, "budgeted %dmA\n", 2 * delta);
-		if (delta > ceiling)
-			dev_warn(&udev->dev, "%dmA over %dmA budget!\n",
-				2 * (delta - ceiling), 2 * ceiling);
-		remaining -= delta;
-	}
-	if (remaining < 0) {
-		dev_warn(&hub->intf->dev,
-			"%dmA over power budget!\n",
-			-2 * remaining);
-		remaining = 0;
-	}
-	return remaining;
-}
-
-/* Handle physical or logical connection change events.
- * This routine is called when:
- * 	a port connection-change occurs;
- *	a port enable-change occurs (often caused by EMI);
- *	usb_reset_device() encounters changed descriptors (as from
- *		a firmware download)
- * caller already locked the hub
- */
-static void hub_port_connect_change(struct usb_hub *hub, int port,
-					u16 portstatus, u16 portchange)
-{
-	struct usb_device *hdev = hub->hdev;
-	struct device *hub_dev = &hub->intf->dev;
-	int status, i;
- 
-	dev_dbg (hub_dev,
-		"port %d, status %04x, change %04x, %s\n",
-		port + 1, portstatus, portchange, portspeed (portstatus));
-
-	if (hub->has_indicators) {
-		set_port_led(hdev, port + 1, HUB_LED_AUTO);
-		hub->indicator[port] = INDICATOR_AUTO;
-	}
- 
-	/* Disconnect any existing devices under this port */
-	if (hdev->children[port])
-		usb_disconnect(&hdev->children[port]);
-	clear_bit(port, hub->change_bits);
-
-#ifdef	CONFIG_USB_OTG
-	/* during HNP, don't repeat the debounce */
-	if (hdev->bus->is_b_host)
-		portchange &= ~USB_PORT_STAT_C_CONNECTION;
-#endif
+		dev->state = USB_STATE_POWERED;
 
-	if (portchange & USB_PORT_STAT_C_CONNECTION) {
-		status = hub_port_debounce(hdev, port);
-		if (status < 0) {
-			dev_err (hub_dev,
-				"connect-debounce failed, port %d disabled\n",
-				port+1);
-			goto done;
+		/* Reset the device, and detect its speed */
+		if (hub_port_reset(hub, port, dev, delay)) {
+			usb_put_dev(dev);
+			break;
 		}
-		portstatus = status;
-	}
-
-	/* Return now if nothing is connected */
-	if (!(portstatus & USB_PORT_STAT_CONNECTION)) {
-
-		/* maybe switch power back on (e.g. root hub was reset) */
-		if ((hub->descriptor->wHubCharacteristics
-					& HUB_CHAR_LPSM) < 2
-				&& !(portstatus & (1 << USB_PORT_FEAT_POWER)))
-			set_port_feature(hdev, port + 1, USB_PORT_FEAT_POWER);
- 
-		if (portstatus & USB_PORT_STAT_ENABLE)
-  			goto done;
-		return;
-	}
 
-	for (i = 0; i < SET_CONFIG_TRIES; i++) {
-		struct usb_device *udev;
-
-		/* reallocate for each attempt, since references
-		 * to the previous one can escape in various ways
-		 */
-		udev = usb_alloc_dev(hdev, hdev->bus, port);
-		if (!udev) {
-			dev_err (hub_dev,
-				"couldn't allocate port %d usb_device\n", port+1);
-			goto done;
-		}
+		/* Find a new address for it */
+		usb_choose_address(dev);
 
-		usb_set_device_state(udev, USB_STATE_POWERED);
-		udev->speed = USB_SPEED_UNKNOWN;
- 
-		/* set the address */
-		choose_address(udev);
-		if (udev->devnum <= 0) {
-			status = -ENOTCONN;	/* Don't retry */
-			goto loop;
+		/* Set up TT records, if needed  */
+		if (hub->tt) {
+			dev->tt = hub->tt;
+			dev->ttport = hub->ttport;
+		} else if (dev->speed != USB_SPEED_HIGH
+				&& hub->speed == USB_SPEED_HIGH) {
+			dev->tt = &hubstate->tt;
+			dev->ttport = port + 1;
 		}
 
-		/* reset and get descriptor */
-		status = hub_port_init(hdev, udev, port);
-		if (status < 0)
-			goto loop;
-
-		/* consecutive bus-powered hubs aren't reliable; they can
-		 * violate the voltage drop budget.  if the new child has
-		 * a "powered" LED, users should notice we didn't enable it
-		 * (without reading syslog), even without per-port LEDs
-		 * on the parent.
-		 */
-		if (udev->descriptor.bDeviceClass == USB_CLASS_HUB
-				&& hub->power_budget) {
-			u16	devstat;
-
-			status = usb_get_status(udev, USB_RECIP_DEVICE, 0,
-					&devstat);
-			if (status < 0) {
-				dev_dbg(&udev->dev, "get status %d ?\n", status);
-				goto loop;
-			}
-			cpu_to_le16s(&devstat);
-			if ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {
-				dev_err(&udev->dev,
-					"can't connect bus-powered hub "
-					"to this port\n");
-				if (hub->has_indicators) {
-					hub->indicator[port] =
-						INDICATOR_AMBER_BLINK;
-					schedule_work (&hub->leds);
-				}
-				status = -ENOTCONN;	/* Don't retry */
-				goto loop;
-			}
-		}
- 
-		/* check for devices running slower than they could */
-		if (udev->descriptor.bcdUSB >= 0x0200
-				&& udev->speed == USB_SPEED_FULL
-				&& highspeed_hubs != 0)
-			check_highspeed (hub, udev, port);
-
-		/* Store the parent's children[] pointer.  At this point
-		 * udev becomes globally accessible, although presumably
-		 * no one will look at it until hdev is unlocked.
-		 */
-		down (&udev->serialize);
-		status = 0;
-
-		/* We mustn't add new devices if the parent hub has
-		 * been disconnected; we would race with the
-		 * recursively_mark_NOTATTACHED() routine.
-		 */
-		spin_lock_irq(&device_state_lock);
-		if (hdev->state == USB_STATE_NOTATTACHED)
-			status = -ENOTCONN;
-		else
-			hdev->children[port] = udev;
-		spin_unlock_irq(&device_state_lock);
+		dev_info (&dev->dev,
+			"new %s speed USB device using address %d\n",
+			({ char *speed; switch (dev->speed) {
+			case USB_SPEED_LOW:	speed = "low";	break;
+			case USB_SPEED_FULL:	speed = "full";	break;
+			case USB_SPEED_HIGH:	speed = "high";	break;
+			default: 		speed = "?";	break;
+			}; speed;}),
+			dev->devnum);
 
 		/* Run it through the hoops (find a driver, etc) */
-		if (!status) {
-			status = usb_new_device(udev);
-			if (status) {
-				spin_lock_irq(&device_state_lock);
-				hdev->children[port] = NULL;
-				spin_unlock_irq(&device_state_lock);
-			}
+		if (usb_new_device(dev) == 0) {
+			hub->children[port] = dev;
+			goto done;
 		}
 
-		up (&udev->serialize);
-		if (status)
-			goto loop;
-
-		status = hub_power_remaining(hub);
-		if (status)
-			dev_dbg(hub_dev,
-				"%dmA power budget left\n",
-				2 * status);
-
-		return;
+		/* Free the configuration if there was an error */
+		usb_put_dev(dev);
 
-loop:
-		hub_port_disable(hdev, port);
-		usb_disable_endpoint(udev, 0 + USB_DIR_IN);
-		usb_disable_endpoint(udev, 0 + USB_DIR_OUT);
-		release_address(udev);
-		usb_put_dev(udev);
-		if (status == -ENOTCONN)
-			break;
+		/* Switch to a long reset time */
+		delay = HUB_LONG_RESET_TIME;
 	}
- 
+
+	hub_port_disable(hub, port);
 done:
-	hub_port_disable(hdev, port);
+	up(&usb_address0_sem);
 }
 
 static void hub_events(void)
 {
+	unsigned long flags;
 	struct list_head *tmp;
-	struct usb_device *hdev;
+	struct usb_device *dev;
 	struct usb_hub *hub;
-	struct device *hub_dev;
 	u16 hubstatus;
 	u16 hubchange;
 	u16 portstatus;
 	u16 portchange;
 	int i, ret;
-	int connect_change;
 
 	/*
 	 *  We restart the list every time to avoid a deadlock with
@@ -2411,74 +1012,53 @@
 	 * Not the most efficient, but avoids deadlocks.
 	 */
 	while (1) {
+		spin_lock_irqsave(&hub_event_lock, flags);
 
-		/* Grab the first entry at the beginning of the list */
-		spin_lock_irq(&hub_event_lock);
-		if (list_empty(&hub_event_list)) {
-			spin_unlock_irq(&hub_event_lock);
+		if (list_empty(&hub_event_list))
 			break;
-		}
 
+		/* Grab the next entry from the beginning of the list */
 		tmp = hub_event_list.next;
-		list_del_init(tmp);
 
 		hub = list_entry(tmp, struct usb_hub, event_list);
-		hdev = hub->hdev;
-		hub_dev = &hub->intf->dev;
+		dev = interface_to_usbdev(hub->intf);
 
-		usb_get_dev(hdev);
-		spin_unlock_irq(&hub_event_lock);
+		list_del_init(tmp);
 
-		/* Lock the device, then check to see if we were
-		 * disconnected while waiting for the lock to succeed. */
-		if (locktree(hdev) < 0)
-			break;
-		if (hdev->state != USB_STATE_CONFIGURED ||
-				!hdev->actconfig ||
-				hub != usb_get_intfdata(
-					hdev->actconfig->interface[0]))
-			goto loop;
+		if (unlikely(down_trylock(&hub->khubd_sem)))
+			BUG();	/* never blocks, we were on list */
+
+		spin_unlock_irqrestore(&hub_event_lock, flags);
 
 		if (hub->error) {
-			dev_dbg (hub_dev, "resetting for error %d\n",
+			dev_dbg (&hub->intf->dev, "resetting for error %d\n",
 				hub->error);
 
 			if (hub_reset(hub)) {
-				dev_dbg (hub_dev,
+				dev_dbg (&hub->intf->dev,
 					"can't reset; disconnecting\n");
-				hub_start_disconnect(hdev);
-				goto loop;
+				up(&hub->khubd_sem);
+				hub_start_disconnect(dev);
+				continue;
 			}
 
 			hub->nerrors = 0;
 			hub->error = 0;
 		}
 
-		/* deal with port status changes */
 		for (i = 0; i < hub->descriptor->bNbrPorts; i++) {
-			connect_change = test_bit(i, hub->change_bits);
-			if (!test_and_clear_bit(i+1, hub->event_bits) &&
-					!connect_change)
-				continue;
-
-			ret = hub_port_status(hdev, i,
-					&portstatus, &portchange);
-			if (ret < 0)
+			ret = hub_port_status(dev, i, &portstatus, &portchange);
+			if (ret < 0) {
 				continue;
-
-			if (portchange & USB_PORT_STAT_C_CONNECTION) {
-				clear_port_feature(hdev,
-					i + 1, USB_PORT_FEAT_C_CONNECTION);
-				connect_change = 1;
 			}
 
-			if (portchange & USB_PORT_STAT_C_ENABLE) {
-				if (!connect_change)
-					dev_dbg (hub_dev,
-						"port %d enable change, "
-						"status %08x\n",
-						i + 1, portstatus);
-				clear_port_feature(hdev,
+			if (portchange & USB_PORT_STAT_C_CONNECTION) {
+				hub_port_connect_change(hub, i, portstatus, portchange);
+			} else if (portchange & USB_PORT_STAT_C_ENABLE) {
+				dev_dbg (hubdev (dev),
+					"port %d enable change, status %x\n",
+					i + 1, portstatus);
+				clear_port_feature(dev,
 					i + 1, USB_PORT_FEAT_C_ENABLE);
 
 				/*
@@ -2488,79 +1068,66 @@
 				 * Works at least with mouse driver. 
 				 */
 				if (!(portstatus & USB_PORT_STAT_ENABLE)
-				    && !connect_change
-				    && hdev->children[i]) {
-					dev_err (hub_dev,
+				    && (portstatus & USB_PORT_STAT_CONNECTION)
+				    && (dev->children[i])) {
+					dev_err (&hub->intf->dev,
 					    "port %i "
 					    "disabled by hub (EMI?), "
-					    "re-enabling...\n",
+					    "re-enabling...",
 						i + 1);
-					connect_change = 1;
+					hub_port_connect_change(hub,
+						i, portstatus, portchange);
 				}
 			}
 
 			if (portchange & USB_PORT_STAT_C_SUSPEND) {
-				clear_port_feature(hdev, i + 1,
-					USB_PORT_FEAT_C_SUSPEND);
-				if (hdev->children[i])
-					ret = remote_wakeup(hdev->children[i]);
-				else
-					ret = -ENODEV;
-				dev_dbg (hub_dev,
-					"resume on port %d, status %d\n",
-					i + 1, ret);
-				if (ret < 0)
-					ret = hub_port_disable(hdev, i);
+				dev_dbg (&hub->intf->dev,
+					"suspend change on port %d\n",
+					i + 1);
+				clear_port_feature(dev,
+					i + 1,  USB_PORT_FEAT_C_SUSPEND);
 			}
 			
 			if (portchange & USB_PORT_STAT_C_OVERCURRENT) {
-				dev_err (hub_dev,
+				dev_err (&hub->intf->dev,
 					"over-current change on port %d\n",
 					i + 1);
-				clear_port_feature(hdev,
+				clear_port_feature(dev,
 					i + 1, USB_PORT_FEAT_C_OVER_CURRENT);
 				hub_power_on(hub);
 			}
 
 			if (portchange & USB_PORT_STAT_C_RESET) {
-				dev_dbg (hub_dev,
+				dev_dbg (&hub->intf->dev,
 					"reset change on port %d\n",
 					i + 1);
-				clear_port_feature(hdev,
+				clear_port_feature(dev,
 					i + 1, USB_PORT_FEAT_C_RESET);
 			}
-
-			if (connect_change)
-				hub_port_connect_change(hub, i,
-						portstatus, portchange);
 		} /* end for i */
 
 		/* deal with hub status changes */
-		if (test_and_clear_bit(0, hub->event_bits) == 0)
-			;	/* do nothing */
-		else if (hub_hub_status(hub, &hubstatus, &hubchange) < 0)
-			dev_err (hub_dev, "get_hub_status failed\n");
+		if (hub_hub_status(hub, &hubstatus, &hubchange) < 0)
+			dev_err (&hub->intf->dev, "get_hub_status failed\n");
 		else {
 			if (hubchange & HUB_CHANGE_LOCAL_POWER) {
-				dev_dbg (hub_dev, "power change\n");
-				clear_hub_feature(hdev, C_HUB_LOCAL_POWER);
+				dev_dbg (&hub->intf->dev, "power change\n");
+				clear_hub_feature(dev, C_HUB_LOCAL_POWER);
 			}
 			if (hubchange & HUB_CHANGE_OVERCURRENT) {
-				dev_dbg (hub_dev, "overcurrent change\n");
-				msleep(500);	/* Cool down */
-				clear_hub_feature(hdev, C_HUB_OVER_CURRENT);
+				dev_dbg (&hub->intf->dev, "overcurrent change\n");
+				wait_ms(500);	/* Cool down */
+				clear_hub_feature(dev, C_HUB_OVER_CURRENT);
                         	hub_power_on(hub);
 			}
 		}
-
-loop:
-		up(&hdev->serialize);
-		usb_put_dev(hdev);
-
+		up(&hub->khubd_sem);
         } /* end while (1) */
+
+	spin_unlock_irqrestore(&hub_event_lock, flags);
 }
 
-static int hub_thread(void *__unused)
+static int hub_thread(void *__hub)
 {
 	/*
 	 * This thread doesn't need any user-level access,
@@ -2578,7 +1145,7 @@
 			refrigerator(PF_FREEZE);
 	} while (!signal_pending(current));
 
-	pr_debug ("%s: khubd exiting\n", usbcore_name);
+	dbg("hub_thread exiting");
 	complete_and_exit(&khubd_exited, 0);
 }
 
@@ -2597,19 +1164,19 @@
 	.name =		"hub",
 	.probe =	hub_probe,
 	.disconnect =	hub_disconnect,
-	.suspend =	hub_suspend,
-	.resume =	hub_resume,
 	.ioctl =	hub_ioctl,
 	.id_table =	hub_id_table,
 };
 
+/*
+ * This should be a separate module.
+ */
 int usb_hub_init(void)
 {
 	pid_t pid;
 
 	if (usb_register(&hub_driver) < 0) {
-		printk(KERN_ERR "%s: can't register hub driver\n",
-			usbcore_name);
+		err("Unable to register USB hub driver");
 		return -1;
 	}
 
@@ -2622,7 +1189,7 @@
 
 	/* Fall through if kernel_thread failed */
 	usb_deregister(&hub_driver);
-	printk(KERN_ERR "%s: can't start khubd\n", usbcore_name);
+	err("failed to start hub_thread");
 
 	return -1;
 }
@@ -2646,177 +1213,163 @@
 	usb_deregister(&hub_driver);
 } /* usb_hub_cleanup() */
 
-
-static int config_descriptors_changed(struct usb_device *udev)
-{
-	unsigned			index;
-	unsigned			len = 0;
-	struct usb_config_descriptor	*buf;
-
-	for (index = 0; index < udev->descriptor.bNumConfigurations; index++) {
-		if (len < udev->config[index].desc.wTotalLength)
-			len = udev->config[index].desc.wTotalLength;
-	}
-	buf = kmalloc (len, SLAB_KERNEL);
-	if (buf == 0) {
-		dev_err(&udev->dev, "no mem to re-read configs after reset\n");
-		/* assume the worst */
-		return 1;
-	}
-	for (index = 0; index < udev->descriptor.bNumConfigurations; index++) {
-		int length;
-		int old_length = udev->config[index].desc.wTotalLength;
-
-		length = usb_get_descriptor(udev, USB_DT_CONFIG, index, buf,
-				old_length);
-		if (length < old_length) {
-			dev_dbg(&udev->dev, "config index %d, error %d\n",
-					index, length);
-			break;
-		}
-		if (memcmp (buf, udev->rawdescriptors[index], old_length)
-				!= 0) {
-			dev_dbg(&udev->dev, "config index %d changed (#%d)\n",
-				index, buf->bConfigurationValue);
-			break;
-		}
-	}
-	kfree(buf);
-	return index != udev->descriptor.bNumConfigurations;
-}
-
-/**
- * usb_reset_device - perform a USB port reset to reinitialize a device
- * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)
- *
- * WARNING - don't reset any device unless drivers for all of its
- * interfaces are expecting that reset!  Maybe some driver->reset()
- * method should eventually help ensure sufficient cooperation.
- *
- * Do a port reset, reassign the device's address, and establish its
- * former operating configuration.  If the reset fails, or the device's
- * descriptors change from their values before the reset, or the original
- * configuration and altsettings cannot be restored, a flag will be set
- * telling khubd to pretend the device has been disconnected and then
- * re-connected.  All drivers will be unbound, and the device will be
- * re-enumerated and probed all over again.
- *
- * Returns 0 if the reset succeeded, -ENODEV if the device has been
- * flagged for logical disconnection, or some other negative error code
- * if the reset wasn't even attempted.
- *
- * The caller must own the device lock.  For example, it's safe to use
- * this from a driver probe() routine after downloading new firmware.
+/*
+ * WARNING - If a driver calls usb_reset_device, you should simulate a
+ * disconnect() and probe() for other interfaces you doesn't claim. This
+ * is left up to the driver writer right now. This insures other drivers
+ * have a chance to re-setup their interface.
+ *
+ * Take a look at proc_resetdevice in devio.c for some sample code to
+ * do this.
+ * Use this only from within your probe function, otherwise use
+ * usb_reset_device() below, which ensure proper locking
  */
-int __usb_reset_device(struct usb_device *udev)
+int usb_physical_reset_device(struct usb_device *dev)
 {
-	struct usb_device *parent = udev->parent;
-	struct usb_device_descriptor descriptor = udev->descriptor;
+	struct usb_device *parent = dev->parent;
+	struct usb_device_descriptor *descriptor;
 	int i, ret, port = -1;
-	struct usb_hub *hub;
 
-	if (udev->state == USB_STATE_NOTATTACHED ||
-			udev->state == USB_STATE_SUSPENDED) {
-		dev_dbg(&udev->dev, "device reset not allowed in state %d\n",
-				udev->state);
+	if (!parent) {
+		err("attempting to reset root hub!");
 		return -EINVAL;
 	}
 
-	/* FIXME: This should be legal for regular hubs.  Root hubs may
-	 * have special requirements. */
-	if (udev->maxchild) {
-		/* this requires hub- or hcd-specific logic;
-		 * see hub_reset() and OHCI hc_restart()
-		 */
-		dev_dbg(&udev->dev, "%s for hub!\n", __FUNCTION__);
-		return -EISDIR;
-	}
-
 	for (i = 0; i < parent->maxchild; i++)
-		if (parent->children[i] == udev) {
+		if (parent->children[i] == dev) {
 			port = i;
 			break;
 		}
 
-	if (port < 0) {
-		/* If this ever happens, it's very bad */
-		dev_err(&udev->dev, "Can't locate device's port!\n");
+	if (port < 0)
 		return -ENOENT;
+
+	descriptor = kmalloc(sizeof *descriptor, GFP_NOIO);
+	if (!descriptor) {
+		return -ENOMEM;
 	}
 
-	ret = hub_port_init(parent, udev, port);
-	if (ret < 0)
-		goto re_enumerate;
- 
-	/* Device might have changed firmware (DFU or similar) */
-	if (memcmp(&udev->descriptor, &descriptor, sizeof descriptor)
-			|| config_descriptors_changed (udev)) {
-		dev_info(&udev->dev, "device firmware changed\n");
-		udev->descriptor = descriptor;	/* for disconnect() calls */
-		goto re_enumerate;
-  	}
-  
-	if (!udev->actconfig)
-		return 0;
+	down(&usb_address0_sem);
 
-	ret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+	/* Send a reset to the device */
+	if (hub_port_reset(parent, port, dev, HUB_SHORT_RESET_TIME)) {
+		hub_port_disable(parent, port);
+		up(&usb_address0_sem);
+		kfree(descriptor);
+		return(-ENODEV);
+	}
+
+	/* Reprogram the Address */
+	ret = usb_set_address(dev);
+	if (ret < 0) {
+		err("USB device not accepting new address (error=%d)", ret);
+		hub_port_disable(parent, port);
+		up(&usb_address0_sem);
+		kfree(descriptor);
+		return ret;
+	}
+
+	/* Let the SET_ADDRESS settle */
+	wait_ms(10);
+
+	up(&usb_address0_sem);
+
+	/*
+	 * Now we fetch the configuration descriptors for the device and
+	 * see if anything has changed. If it has, we dump the current
+	 * parsed descriptors and reparse from scratch. Then we leave
+	 * the device alone for the caller to finish setting up.
+	 *
+	 * If nothing changed, we reprogram the configuration and then
+	 * the alternate settings.
+	 */
+
+	ret = usb_get_descriptor(dev, USB_DT_DEVICE, 0, descriptor,
+			sizeof(*descriptor));
+	if (ret < 0) {
+		kfree(descriptor);
+		return ret;
+	}
+
+	le16_to_cpus(&descriptor->bcdUSB);
+	le16_to_cpus(&descriptor->idVendor);
+	le16_to_cpus(&descriptor->idProduct);
+	le16_to_cpus(&descriptor->bcdDevice);
+
+	if (memcmp(&dev->descriptor, descriptor, sizeof(*descriptor))) {
+		kfree(descriptor);
+		usb_destroy_configuration(dev);
+
+		ret = usb_get_device_descriptor(dev, sizeof(dev->descriptor));
+		if (ret != sizeof(dev->descriptor)) {
+			if (ret < 0)
+				err("unable to get device %s descriptor "
+					"(error=%d)", dev->devpath, ret);
+			else
+				err("USB device %s descriptor short read "
+					"(expected %Zi, got %i)",
+					dev->devpath,
+					sizeof(dev->descriptor), ret);
+
+			clear_bit(dev->devnum, dev->bus->devmap.devicemap);
+			dev->devnum = -1;
+			return -EIO;
+		}
+
+		ret = usb_get_configuration(dev);
+		if (ret < 0) {
+			err("unable to get configuration (error=%d)", ret);
+			usb_destroy_configuration(dev);
+			clear_bit(dev->devnum, dev->bus->devmap.devicemap);
+			dev->devnum = -1;
+			return 1;
+		}
+
+		usb_set_configuration(dev, dev->config[0].desc.bConfigurationValue);
+		return 1;
+	}
+
+	kfree(descriptor);
+
+	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			USB_REQ_SET_CONFIGURATION, 0,
-			udev->actconfig->desc.bConfigurationValue, 0,
+			dev->actconfig->desc.bConfigurationValue, 0,
 			NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
 	if (ret < 0) {
-		dev_err(&udev->dev,
-			"can't restore configuration #%d (error=%d)\n",
-			udev->actconfig->desc.bConfigurationValue, ret);
-		goto re_enumerate;
-  	}
-	usb_set_device_state(udev, USB_STATE_CONFIGURED);
+		err("failed to set dev %s active configuration (error=%d)",
+			dev->devpath, ret);
+		return ret;
+	}
+	dev->state = USB_STATE_CONFIGURED;
 
-	for (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {
-		struct usb_interface *intf = udev->actconfig->interface[i];
+	for (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {
+		struct usb_interface *intf = dev->actconfig->interface[i];
 		struct usb_interface_descriptor *desc;
 
-		/* set_interface resets host side toggle even
-		 * for altsetting zero.  the interface may have no driver.
-		 */
 		desc = &intf->cur_altsetting->desc;
-		ret = usb_set_interface(udev, desc->bInterfaceNumber,
+		ret = usb_set_interface(dev, desc->bInterfaceNumber,
 			desc->bAlternateSetting);
 		if (ret < 0) {
-			dev_err(&udev->dev, "failed to restore interface %d "
-				"altsetting %d (error=%d)\n",
-				desc->bInterfaceNumber,
-				desc->bAlternateSetting,
-				ret);
-			goto re_enumerate;
+			err("failed to set active alternate setting "
+				"for dev %s interface %d (error=%d)",
+				dev->devpath, desc->bInterfaceNumber, ret);
+			return ret;
 		}
 	}
 
 	return 0;
- 
-re_enumerate:
-	hub_port_disable(parent, port);
-
-	hub = usb_get_intfdata(parent->actconfig->interface[0]);
-	set_bit(port, hub->change_bits);
-
-	spin_lock_irq(&hub_event_lock);
-	if (list_empty(&hub->event_list)) {
-		list_add_tail(&hub->event_list, &hub_event_list);
-		wake_up(&khubd_wait);
-	}
-	spin_unlock_irq(&hub_event_lock);
-
-	return -ENODEV;
 }
-EXPORT_SYMBOL(__usb_reset_device);
 
 int usb_reset_device(struct usb_device *udev)
 {
+	struct device *gdev = &udev->dev;
 	int r;
 	
-	down(&udev->serialize);
-	r = __usb_reset_device(udev);
-	up(&udev->serialize);
+	down_read(&gdev->bus->subsys.rwsem);
+	r = usb_physical_reset_device(udev);
+	up_read(&gdev->bus->subsys.rwsem);
 
 	return r;
 }
+
+
diff -Naur linuxppc-2.6.9/drivers/usb/core/hub.h linuxppc-2.6.9-dream/drivers/usb/core/hub.h
--- linuxppc-2.6.9/drivers/usb/core/hub.h	2004-10-18 23:53:21.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/hub.h	2005-09-19 21:40:05.000000000 +0200
@@ -60,8 +60,8 @@
  * See USB 2.0 spec Table 11-19 and Table 11-20
  */
 struct usb_port_status {
-	__le16 wPortStatus;
-	__le16 wPortChange;	
+	__u16 wPortStatus;
+	__u16 wPortChange;	
 } __attribute__ ((packed));
 
 /* 
@@ -103,8 +103,8 @@
 #define HUB_CHAR_PORTIND        0x0080 /* D7       */
 
 struct usb_hub_status {
-	__le16 wHubStatus;
-	__le16 wHubChange;
+	__u16 wHubStatus;
+	__u16 wHubChange;
 } __attribute__ ((packed));
 
 /*
@@ -139,22 +139,6 @@
 	__u8  PortPwrCtrlMask[(USB_MAXCHILDREN + 1 + 7) / 8];
 } __attribute__ ((packed));
 
-
-/* port indicator status selectors, tables 11-7 and 11-25 */
-#define HUB_LED_AUTO	0
-#define HUB_LED_AMBER	1
-#define HUB_LED_GREEN	2
-#define HUB_LED_OFF	3
-
-enum hub_led_mode {
-	INDICATOR_AUTO = 0,
-	INDICATOR_CYCLE,
-	/* software blinks for attention:  software, hardware, reserved */
-	INDICATOR_GREEN_BLINK, INDICATOR_GREEN_BLINK_OFF,
-	INDICATOR_AMBER_BLINK, INDICATOR_AMBER_BLINK_OFF,
-	INDICATOR_ALT_BLINK, INDICATOR_ALT_BLINK_OFF
-} __attribute__ ((packed));
-
 struct usb_device;
 
 /*
@@ -187,11 +171,12 @@
 
 struct usb_hub {
 	struct usb_interface	*intf;		/* the "real" device */
-	struct usb_device	*hdev;
 	struct urb		*urb;		/* for interrupt polling pipe */
+	struct completion	*urb_complete;	/* wait for urb to end */
+	unsigned int		urb_active:1;
 
-	/* buffer for urb ... with extra space in case of babble */
-	char			(*buffer)[8];
+	/* buffer for urb ... 1 bit each for hub and children, rounded up */
+	char			(*buffer)[(USB_MAXCHILDREN + 1 + 7) / 8];
 	dma_addr_t		buffer_dma;	/* DMA address for buffer */
 	union {
 		struct usb_hub_status	hub;
@@ -201,35 +186,12 @@
 	int			error;		/* last reported error */
 	int			nerrors;	/* track consecutive errors */
 
+	struct list_head	hub_list;	/* all hubs */
 	struct list_head	event_list;	/* hubs w/data or errs ready */
-	unsigned long		event_bits[1];	/* status change bitmask */
-	unsigned long		change_bits[1];	/* ports with logical connect
-							status change */
-#if USB_MAXCHILDREN > 31 /* 8*sizeof(unsigned long) - 1 */
-#error event_bits[] is too short!
-#endif
 
 	struct usb_hub_descriptor *descriptor;	/* class descriptor */
+	struct semaphore	khubd_sem;
 	struct usb_tt		tt;		/* Transaction Translator */
-
-	u8			power_budget;	/* in 2mA units; or zero */
-
-	unsigned		quiescing:1;
-
-	unsigned		has_indicators:1;
-	enum hub_led_mode	indicator[USB_MAXCHILDREN];
-	struct work_struct	leds;
 };
 
-/* use this for low-powered root hubs */
-static inline void
-hub_set_power_budget (struct usb_device *hubdev, unsigned mA)
-{
-	struct usb_hub	*hub;
-
-	hub = (struct usb_hub *)
-		usb_get_intfdata (hubdev->actconfig->interface[0]);
-	hub->power_budget = min(mA,(unsigned)500)/2;
-}
-
 #endif /* __LINUX_HUB_H */
diff -Naur linuxppc-2.6.9/drivers/usb/core/inode.c linuxppc-2.6.9-dream/drivers/usb/core/inode.c
--- linuxppc-2.6.9/drivers/usb/core/inode.c	2004-10-18 23:53:11.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/inode.c	2005-09-19 21:40:05.000000000 +0200
@@ -48,7 +48,6 @@
 static struct vfsmount *usbfs_mount;
 static int usbdevfs_mount_count;	/* = 0 */
 static int usbfs_mount_count;	/* = 0 */
-static int ignore_mount = 0;
 
 static struct dentry *devices_usbdevfs_dentry;
 static struct dentry *devices_usbfs_dentry;
@@ -89,17 +88,6 @@
 	char *p;
 	int option;
 
-	/* (re)set to defaults. */
-	devuid = 0;
-	busuid = 0;
-	listuid = 0;
-	devgid = 0;
-	busgid = 0;
-	listgid = 0;
-	devmode = S_IWUSR | S_IRUGO;
-	busmode = S_IXUGO | S_IRUGO;
-	listmode = S_IRUGO;
-
 	while ((p = strsep(&data, ",")) != NULL) {
 		substring_t args[MAX_OPT_ARGS];
 		int token;
@@ -163,89 +151,6 @@
 	return 0;
 }
 
-static void update_special(struct dentry *special)
-{
-	special->d_inode->i_uid = listuid;
-	special->d_inode->i_gid = listgid;
-	special->d_inode->i_mode = S_IFREG | listmode;
-}
-
-static void update_dev(struct dentry *dev)
-{
-	dev->d_inode->i_uid = devuid;
-	dev->d_inode->i_gid = devgid;
-	dev->d_inode->i_mode = S_IFREG | devmode;
-}
-
-static void update_bus(struct dentry *bus)
-{
-	struct dentry *dev = NULL;
-
-	bus->d_inode->i_uid = busuid;
-	bus->d_inode->i_gid = busgid;
-	bus->d_inode->i_mode = S_IFDIR | busmode;
-
-	down(&bus->d_inode->i_sem);
-
-	list_for_each_entry(dev, &bus->d_subdirs, d_child)
-		if (dev->d_inode)
-			update_dev(dev);
-
-	up(&bus->d_inode->i_sem);
-}
-
-static void update_sb(struct super_block *sb)
-{
-	struct dentry *root = sb->s_root;
-	struct dentry *bus = NULL;
-
-	if (!root)
-		return;
-
-	down(&root->d_inode->i_sem);
-
-	list_for_each_entry(bus, &root->d_subdirs, d_child) {
-		if (bus->d_inode) {
-			switch (S_IFMT & bus->d_inode->i_mode) {
-			case S_IFDIR:
-				update_bus(bus);
-				break;
-			case S_IFREG:
-				update_special(bus);
-				break;
-			default:
-				warn("Unknown node %s mode %x found on remount!\n",bus->d_name.name,bus->d_inode->i_mode);
-				break;
-			}
-		}
-	}
-
-	up(&root->d_inode->i_sem);
-}
-
-static int remount(struct super_block *sb, int *flags, char *data)
-{
-	/* If this is not a real mount,
-	 * i.e. it's a simple_pin_fs from create_special_files,
-	 * then ignore it.
-	 */
-	if (ignore_mount)
-		return 0;
-
-	if (parse_options(sb, data)) {
-		warn("usbfs: mount parameter error:");
-		return -EINVAL;
-	}
-
-	if (usbfs_mount && usbfs_mount->mnt_sb)
-		update_sb(usbfs_mount->mnt_sb);
-
-	if (usbdevfs_mount && usbdevfs_mount->mnt_sb)
-		update_sb(usbdevfs_mount->mnt_sb);
-
-	return 0;
-}
-
 static struct inode *usbfs_get_inode (struct super_block *sb, int mode, dev_t dev)
 {
 	struct inode *inode = new_inode(sb);
@@ -345,13 +250,30 @@
 	return 0;
 }
 
+static void d_unhash(struct dentry *dentry)
+{
+	dget(dentry);
+	spin_lock(&dcache_lock);
+	switch (atomic_read(&dentry->d_count)) {
+	default:
+		spin_unlock(&dcache_lock);
+		shrink_dcache_parent(dentry);
+		spin_lock(&dcache_lock);
+		if (atomic_read(&dentry->d_count) != 2)
+			break;
+	case 2:
+		__d_drop(dentry);
+	}
+	spin_unlock(&dcache_lock);
+}
+
 static int usbfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = -ENOTEMPTY;
 	struct inode * inode = dentry->d_inode;
 
 	down(&inode->i_sem);
-	dentry_unhash(dentry);
+	d_unhash(dentry);
 	if (usbfs_empty(dentry)) {
 		dentry->d_inode->i_nlink -= 2;
 		dput(dentry);
@@ -427,7 +349,6 @@
 static struct super_operations usbfs_ops = {
 	.statfs =	simple_statfs,
 	.drop_inode =	generic_delete_inode,
-	.remount_fs =	remount,
 };
 
 static int usbfs_fill_super(struct super_block *sb, void *data, int silent)
@@ -435,6 +356,11 @@
 	struct inode *inode;
 	struct dentry *root;
 
+	if (parse_options(sb, data)) {
+		warn("usbfs: mount parameter error:");
+		return -EINVAL;
+	}
+
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	sb->s_magic = USBDEVICE_SUPER_MAGIC;
@@ -597,11 +523,6 @@
 	struct dentry *parent;
 	int retval;
 
-	/* the simple_pin_fs calls will call remount with no options
-	 * without this flag that would overwrite the real mount options (if any)
-	 */
-	ignore_mount = 1;
-
 	/* create the devices special file */
 	retval = simple_pin_fs("usbdevfs", &usbdevfs_mount, &usbdevfs_mount_count);
 	if (retval) {
@@ -615,8 +536,6 @@
 		goto error_clean_usbdevfs_mount;
 	}
 
-	ignore_mount = 0;
-
 	parent = usbfs_mount->mnt_sb->s_root;
 	devices_usbfs_dentry = fs_create_file ("devices",
 					       listmode | S_IFREG, parent,
@@ -798,6 +717,9 @@
 	while (!list_empty(&dev->filelist)) {
 		ds = list_entry(dev->filelist.next, struct dev_state, list);
 		list_del_init(&ds->list);
+		down_write(&ds->devsem);
+		ds->dev = NULL;
+		up_write(&ds->devsem);
 		if (ds->discsignr) {
 			sinfo.si_signo = SIGPIPE;
 			sinfo.si_errno = EPIPE;
@@ -844,7 +766,7 @@
 	return 0;
 }
 
-void usbfs_cleanup(void)
+void __exit usbfs_cleanup(void)
 {
 	usb_deregister(&usbdevfs_driver);
 	unregister_filesystem(&usb_fs_type);
diff -Naur linuxppc-2.6.9/drivers/usb/core/Kconfig linuxppc-2.6.9-dream/drivers/usb/core/Kconfig
--- linuxppc-2.6.9/drivers/usb/core/Kconfig	2004-10-18 23:55:21.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/Kconfig	2005-09-19 21:40:05.000000000 +0200
@@ -60,40 +60,3 @@
 
 	  If you are unsure about this, say N here.
 
-config USB_SUSPEND
-	bool "USB suspend/resume (EXPERIMENTAL)"
-	depends on USB && PM && EXPERIMENTAL
-	help
-	  If you say Y here, you can use driver calls or the sysfs
-	  "power/state" file to suspend or resume individual USB
-	  peripherals.  There are many related features, such as
-	  remote wakeup and driver-specific suspend processing, that
-	  may not yet work as expected.
-
-	  If you are unsure about this, say N here.
-
-
-config USB_OTG
-	bool
-	depends on USB && EXPERIMENTAL
-	select USB_SUSPEND
-	default n
-
-
-config USB_OTG_WHITELIST
-	bool "Rely on OTG Targeted Peripherals List"
-	depends on USB_OTG
-	default y
-	help
-	  If you say Y here, the "otg_whitelist.h" file will be used as a
-	  product whitelist, so USB peripherals not listed there will be
-	  rejected during enumeration.  This behavior is required by the
-	  USB OTG specification for all devices not on your product's
-	  "Targeted Peripherals List".
-
-	  Otherwise, peripherals not listed there will only generate a
-	  warning and enumeration will continue.  That's more like what
-	  normal Linux-USB hosts do (other than the warning), and is
-	  convenient for many stages of product development.
-
-
diff -Naur linuxppc-2.6.9/drivers/usb/core/Makefile linuxppc-2.6.9-dream/drivers/usb/core/Makefile
--- linuxppc-2.6.9/drivers/usb/core/Makefile	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/Makefile	2005-09-19 21:40:05.000000000 +0200
@@ -3,7 +3,7 @@
 #
 
 usbcore-objs	:= usb.o hub.o hcd.o urb.o message.o \
-			config.o file.o buffer.o sysfs.o
+			config.o file.o buffer.o driverfs.o
 
 ifeq ($(CONFIG_PCI),y)
 	usbcore-objs	+= hcd-pci.o
diff -Naur linuxppc-2.6.9/drivers/usb/core/message.c linuxppc-2.6.9-dream/drivers/usb/core/message.c
--- linuxppc-2.6.9/drivers/usb/core/message.c	2005-10-01 14:12:19.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/message.c	2005-09-19 21:40:05.000000000 +0200
@@ -91,8 +91,8 @@
 	if (!urb)
 		return -ENOMEM;
   
-	usb_fill_control_urb(urb, usb_dev, pipe, (unsigned char *)cmd, data,
-			     len, usb_api_blocking_completion, NULL);
+	usb_fill_control_urb(urb, usb_dev, pipe, (unsigned char*)cmd, data, len,
+		   usb_api_blocking_completion, 0);
 
 	retv = usb_start_wait_urb(urb, timeout, &length);
 	if (retv < 0)
@@ -190,7 +190,7 @@
 		return -ENOMEM;
 
 	usb_fill_bulk_urb(urb, usb_dev, pipe, data, len,
-			  usb_api_blocking_completion, NULL);
+		    usb_api_blocking_completion, 0);
 
 	return usb_start_wait_urb(urb,timeout,actual_length);
 }
@@ -203,11 +203,11 @@
 		while (io->entries--)
 			usb_free_urb (io->urbs [io->entries]);
 		kfree (io->urbs);
-		io->urbs = NULL;
+		io->urbs = 0;
 	}
 	if (io->dev->dev.dma_mask != 0)
 		usb_buffer_unmap_sg (io->dev, io->pipe, io->sg, io->nents);
-	io->dev = NULL;
+	io->dev = 0;
 }
 
 static void sg_complete (struct urb *urb, struct pt_regs *regs)
@@ -248,7 +248,7 @@
 		 * unlink pending urbs so they won't rx/tx bad data.
 		 */
 		for (i = 0, found = 0; i < io->entries; i++) {
-			if (!io->urbs [i] || !io->urbs [i]->dev)
+			if (!io->urbs [i])
 				continue;
 			if (found) {
 				status = usb_unlink_urb (io->urbs [i]);
@@ -260,7 +260,7 @@
 				found = 1;
 		}
 	}
-	urb->dev = NULL;
+	urb->dev = 0;
 
 	/* on the last completion, signal usb_sg_wait() */
 	io->bytes += urb->actual_length;
@@ -337,7 +337,7 @@
 	if (io->entries <= 0)
 		return io->entries;
 
-	io->count = io->entries;
+	io->count = 0;
 	io->urbs = kmalloc (io->entries * sizeof *io->urbs, mem_flags);
 	if (!io->urbs)
 		goto nomem;
@@ -347,7 +347,7 @@
 	if (usb_pipein (pipe))
 		urb_flags |= URB_SHORT_NOT_OK;
 
-	for (i = 0; i < io->entries; i++) {
+	for (i = 0; i < io->entries; i++, io->count = i) {
 		unsigned		len;
 
 		io->urbs [i] = usb_alloc_urb (0, mem_flags);
@@ -356,7 +356,7 @@
 			goto nomem;
 		}
 
-		io->urbs [i]->dev = NULL;
+		io->urbs [i]->dev = 0;
 		io->urbs [i]->pipe = pipe;
 		io->urbs [i]->interval = period;
 		io->urbs [i]->transfer_flags = urb_flags;
@@ -459,7 +459,7 @@
 		case -ENXIO:	// hc didn't queue this one
 		case -EAGAIN:
 		case -ENOMEM:
-			io->urbs[i]->dev = NULL;
+			io->urbs [i]->dev = 0;
 			retval = 0;
 			i--;
 			yield ();
@@ -477,19 +477,24 @@
 
 			/* fail any uncompleted urbs */
 		default:
-			io->urbs [i]->dev = NULL;
+			spin_lock_irq (&io->lock);
+			io->count -= entries - i;
+			if (io->status == -EINPROGRESS)
+				io->status = retval;
+			if (io->count == 0)
+				complete (&io->complete);
+			spin_unlock_irq (&io->lock);
+
+			io->urbs [i]->dev = 0;
 			io->urbs [i]->status = retval;
 			dev_dbg (&io->dev->dev, "%s, submit --> %d\n",
 				__FUNCTION__, retval);
 			usb_sg_cancel (io);
 		}
 		spin_lock_irq (&io->lock);
-		if (retval && (io->status == 0 || io->status == -ECONNRESET))
+		if (retval && io->status == -ECONNRESET)
 			io->status = retval;
 	}
-	io->count -= entries - i;
-	if (io->count == 0)
-		complete (&io->complete);
 	spin_unlock_irq (&io->lock);
 
 	/* OK, yes, this could be packaged as non-blocking.
@@ -561,24 +566,19 @@
  */
 int usb_get_descriptor(struct usb_device *dev, unsigned char type, unsigned char index, void *buf, int size)
 {
-	int i;
+	int i = 5;
 	int result;
 	
 	memset(buf,0,size);	// Make sure we parse really received data
 
-	for (i = 0; i < 3; ++i) {
-		/* retry on length 0 or stall; some devices are flakey */
-		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
-				USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
-				(type << 8) + index, 0, buf, size,
-				HZ * USB_CTRL_GET_TIMEOUT);
-		if (result == 0 || result == -EPIPE)
-			continue;
-		if (result > 1 && ((u8 *)buf)[1] != type) {
-			result = -EPROTO;
-			continue;
-		}
-		break;
+	while (i--) {
+		/* retries if the returned length was 0; flakey device */
+		if ((result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+				    USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+				    (type << 8) + index, 0, buf, size,
+				    HZ * USB_CTRL_GET_TIMEOUT)) > 0
+				|| result == -EPIPE)
+			break;
 	}
 	return result;
 }
@@ -605,128 +605,12 @@
  * Returns the number of bytes received on success, or else the status code
  * returned by the underlying usb_control_msg() call.
  */
-int usb_get_string(struct usb_device *dev, unsigned short langid,
-		unsigned char index, void *buf, int size)
-{
-	int i;
-	int result;
-
-	for (i = 0; i < 3; ++i) {
-		/* retry on length 0 or stall; some devices are flakey */
-		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
-			USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
-			(USB_DT_STRING << 8) + index, langid, buf, size,
-			HZ * USB_CTRL_GET_TIMEOUT);
-		if (!(result == 0 || result == -EPIPE))
-			break;
-	}
-	return result;
-}
-
-static int usb_string_sub(struct usb_device *dev, unsigned int langid,
-		unsigned int index, unsigned char *buf)
+int usb_get_string(struct usb_device *dev, unsigned short langid, unsigned char index, void *buf, int size)
 {
-	int rc;
-
-	/* Try to read the string descriptor by asking for the maximum
-	 * possible number of bytes */
-	rc = usb_get_string(dev, langid, index, buf, 255);
-
-	/* If that failed try to read the descriptor length, then
-	 * ask for just that many bytes */
-	if (rc < 0) {
-		rc = usb_get_string(dev, langid, index, buf, 2);
-		if (rc == 2)
-			rc = usb_get_string(dev, langid, index, buf, buf[0]);
-	}
-
-	if (rc >= 0) {
-		/* There might be extra junk at the end of the descriptor */
-		if (buf[0] < rc)
-			rc = buf[0];
-		if (rc < 2)
-			rc = -EINVAL;
-	}
-	return rc;
-}
-
-/**
- * usb_string - returns ISO 8859-1 version of a string descriptor
- * @dev: the device whose string descriptor is being retrieved
- * @index: the number of the descriptor
- * @buf: where to put the string
- * @size: how big is "buf"?
- * Context: !in_interrupt ()
- * 
- * This converts the UTF-16LE encoded strings returned by devices, from
- * usb_get_string_descriptor(), to null-terminated ISO-8859-1 encoded ones
- * that are more usable in most kernel contexts.  Note that all characters
- * in the chosen descriptor that can't be encoded using ISO-8859-1
- * are converted to the question mark ("?") character, and this function
- * chooses strings in the first language supported by the device.
- *
- * The ASCII (or, redundantly, "US-ASCII") character set is the seven-bit
- * subset of ISO 8859-1. ISO-8859-1 is the eight-bit subset of Unicode,
- * and is appropriate for use many uses of English and several other
- * Western European languages.  (But it doesn't include the "Euro" symbol.)
- *
- * This call is synchronous, and may not be used in an interrupt context.
- *
- * Returns length of the string (>= 0) or usb_control_msg status (< 0).
- */
-int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
-{
-	unsigned char *tbuf;
-	int err;
-	unsigned int u, idx;
-
-	if (size <= 0 || !buf || !index)
-		return -EINVAL;
-	buf[0] = 0;
-	tbuf = kmalloc(256, GFP_KERNEL);
-	if (!tbuf)
-		return -ENOMEM;
-
-	/* get langid for strings if it's not yet known */
-	if (!dev->have_langid) {
-		err = usb_string_sub(dev, 0, 0, tbuf);
-		if (err < 0) {
-			dev_err (&dev->dev,
-				"string descriptor 0 read error: %d\n",
-				err);
-			goto errout;
-		} else if (err < 4) {
-			dev_err (&dev->dev, "string descriptor 0 too short\n");
-			err = -EINVAL;
-			goto errout;
-		} else {
-			dev->have_langid = -1;
-			dev->string_langid = tbuf[2] | (tbuf[3]<< 8);
-				/* always use the first langid listed */
-			dev_dbg (&dev->dev, "default language 0x%04x\n",
-				dev->string_langid);
-		}
-	}
-	
-	err = usb_string_sub(dev, dev->string_langid, index, tbuf);
-	if (err < 0)
-		goto errout;
-
-	size--;		/* leave room for trailing NULL char in output buffer */
-	for (idx = 0, u = 2; u < err; u += 2) {
-		if (idx >= size)
-			break;
-		if (tbuf[u+1])			/* high byte */
-			buf[idx++] = '?';  /* non ISO-8859-1 character */
-		else
-			buf[idx++] = tbuf[u];
-	}
-	buf[idx] = 0;
-	err = idx;
-
- errout:
-	kfree(tbuf);
-	return err;
+	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+		USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+		(USB_DT_STRING << 8) + index, langid, buf, size,
+		HZ * USB_CTRL_GET_TIMEOUT);
 }
 
 /**
@@ -797,19 +681,9 @@
  */
 int usb_get_status(struct usb_device *dev, int type, int target, void *data)
 {
-	int ret;
-	u16 *status = kmalloc(sizeof(*status), GFP_KERNEL);
-
-	if (!status)
-		return -ENOMEM;
-
-	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
-		USB_REQ_GET_STATUS, USB_DIR_IN | type, 0, target, status,
-		sizeof(*status), HZ * USB_CTRL_GET_TIMEOUT);
-
-	*(u16 *)data = *status;
-	kfree(status);
-	return ret;
+	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+		USB_REQ_GET_STATUS, USB_DIR_IN | type, 0, target, data, 2,
+		HZ * USB_CTRL_GET_TIMEOUT);
 }
 
 /**
@@ -848,8 +722,7 @@
 	 * this request for iso endpoints, which can't halt!
 	 */
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
-		USB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT,
-		USB_ENDPOINT_HALT, endp, NULL, 0,
+		USB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT, 0, endp, NULL, 0,
 		HZ * USB_CTRL_SET_TIMEOUT);
 
 	/* don't un-halt or force to DATA0 except on success */
@@ -864,8 +737,9 @@
 	 * the copy in usb-storage, for as long as we need two copies.
 	 */
 
-	/* toggle was reset by the clear */
+	/* toggle was reset by the clear, then ep was reactivated */
 	usb_settoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe), 0);
+	usb_endpoint_running(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe));
 
 	return 0;
 }
@@ -879,8 +753,9 @@
  * Deallocates hcd/hardware state for this endpoint ... and nukes all
  * pending urbs.
  *
- * If the HCD hasn't registered a disable() function, this sets the
- * endpoint's maxpacket size to 0 to prevent further submissions.
+ * If the HCD hasn't registered a disable() function, this marks the
+ * endpoint as halted and sets its maxpacket size to 0 to prevent
+ * further submissions.
  */
 void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
 {
@@ -889,10 +764,13 @@
 	else {
 		unsigned int epnum = epaddr & USB_ENDPOINT_NUMBER_MASK;
 
-		if (usb_endpoint_out(epaddr))
+		if (usb_endpoint_out(epaddr)) {
+			usb_endpoint_halt(dev, epnum, 1);
 			dev->epmaxpacketout[epnum] = 0;
-		else
+		} else {
+			usb_endpoint_halt(dev, epnum, 0);
 			dev->epmaxpacketin[epnum] = 0;
+		}
 	}
 }
 
@@ -914,6 +792,10 @@
 	}
 }
 
+static void release_interface(struct device *dev)
+{
+}
+
 /*
  * usb_disable_device - Disable all the endpoints for a USB device
  * @dev: the device whose endpoints are being disabled
@@ -935,6 +817,7 @@
 		usb_disable_endpoint(dev, i + USB_DIR_IN);
 	}
 	dev->toggle[0] = dev->toggle[1] = 0;
+	dev->halted[0] = dev->halted[1] = 0;
 
 	/* getting rid of interfaces will disconnect
 	 * any drivers bound to them (a key side effect)
@@ -947,20 +830,11 @@
 			interface = dev->actconfig->interface[i];
 			dev_dbg (&dev->dev, "unregistering interface %s\n",
 				interface->dev.bus_id);
-			usb_remove_sysfs_intf_files(interface);
-			device_del (&interface->dev);
-		}
-
-		/* Now that the interfaces are unbound, nobody should
-		 * try to access them.
-		 */
-		for (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {
-			put_device (&dev->actconfig->interface[i]->dev);
-			dev->actconfig->interface[i] = NULL;
+			device_unregister (&interface->dev);
 		}
-		dev->actconfig = NULL;
+		dev->actconfig = 0;
 		if (dev->state == USB_STATE_CONFIGURED)
-			usb_set_device_state(dev, USB_STATE_ADDRESS);
+			dev->state = USB_STATE_ADDRESS;
 	}
 }
 
@@ -970,8 +844,9 @@
  * @dev: the device whose interface is being enabled
  * @epd: pointer to the endpoint descriptor
  *
- * Resets the endpoint toggle and stores its maxpacket value.
- * For control endpoints, both the input and output sides are handled.
+ * Marks the endpoint as running, resets its toggle, and stores
+ * its maxpacket value.  For control endpoints, both the input
+ * and output sides are handled.
  */
 void usb_enable_endpoint(struct usb_device *dev,
 		struct usb_endpoint_descriptor *epd)
@@ -983,10 +858,12 @@
 				USB_ENDPOINT_XFER_CONTROL);
 
 	if (usb_endpoint_out(epaddr) || is_control) {
+		usb_endpoint_running(dev, epnum, 1);
 		usb_settoggle(dev, epnum, 1, 0);
 		dev->epmaxpacketout[epnum] = maxsize;
 	}
 	if (!usb_endpoint_out(epaddr) || is_control) {
+		usb_endpoint_running(dev, epnum, 0);
 		usb_settoggle(dev, epnum, 0, 0);
 		dev->epmaxpacketin[epnum] = maxsize;
 	}
@@ -1049,13 +926,9 @@
 	int ret;
 	int manual = 0;
 
-	if (dev->state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
-
 	iface = usb_ifnum_to_if(dev, interface);
 	if (!iface) {
-		dev_dbg(&dev->dev, "selecting invalid interface %d\n",
-			interface);
+		warn("selecting invalid interface %d", interface);
 		return -EINVAL;
 	}
 
@@ -1073,9 +946,8 @@
 	 * request if the interface only has one alternate setting.
 	 */
 	if (ret == -EPIPE && iface->num_altsetting == 1) {
-		dev_dbg(&dev->dev,
-			"manual set_interface for iface %d, alt %d\n",
-			interface, alternate);
+		dbg("manual set_interface for dev %d, iface %d, alt %d",
+			dev->devnum, interface, alternate);
 		manual = 1;
 	} else if (ret < 0)
 		return ret;
@@ -1149,9 +1021,6 @@
 	int			i, retval;
 	struct usb_host_config	*config;
 
-	if (dev->state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
-
 	/* caller must own dev->serialize (config won't change)
 	 * and the usb bus readlock (so driver bindings are stable);
 	 * so calls during probe() are fine
@@ -1168,11 +1037,12 @@
 			config->desc.bConfigurationValue, 0,
 			NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
 	if (retval < 0) {
-		usb_set_device_state(dev, USB_STATE_ADDRESS);
+		dev->state = USB_STATE_ADDRESS;
 		return retval;
 	}
 
 	dev->toggle[0] = dev->toggle[1] = 0;
+	dev->halted[0] = dev->halted[1] = 0;
 
 	/* re-init hc/hcd interface/endpoint state */
 	for (i = 0; i < config->desc.bNumInterfaces; i++) {
@@ -1195,21 +1065,11 @@
 	return 0;
 }
 
-static void release_interface(struct device *dev)
-{
-	struct usb_interface *intf = to_usb_interface(dev);
-	struct usb_interface_cache *intfc =
-			altsetting_to_usb_interface_cache(intf->altsetting);
-
-	kref_put(&intfc->ref, usb_release_interface_cache);
-	kfree(intf);
-}
-
-/*
+/**
  * usb_set_configuration - Makes a particular device setting be current
  * @dev: the device whose configuration is being updated
  * @configuration: the configuration being chosen.
- * Context: !in_interrupt(), caller holds dev->serialize
+ * Context: !in_interrupt ()
  *
  * This is used to enable non-default device modes.  Not all devices
  * use this kind of configurability; many devices only have one
@@ -1243,19 +1103,20 @@
 {
 	int i, ret;
 	struct usb_host_config *cp = NULL;
-	struct usb_interface **new_interfaces = NULL;
-	int n, nintf;
-
+	
 	/* dev->serialize guards all config changes */
+	down(&dev->serialize);
 
-	for (i = 0; i < dev->descriptor.bNumConfigurations; i++) {
+	for (i=0; i<dev->descriptor.bNumConfigurations; i++) {
 		if (dev->config[i].desc.bConfigurationValue == configuration) {
 			cp = &dev->config[i];
 			break;
 		}
 	}
-	if ((!cp && configuration != 0))
-		return -EINVAL;
+	if ((!cp && configuration != 0)) {
+		ret = -EINVAL;
+		goto out;
+	}
 
 	/* The USB spec says configuration 0 means unconfigured.
 	 * But if a device includes a configuration numbered 0,
@@ -1264,37 +1125,6 @@
 	if (cp && configuration == 0)
 		dev_warn(&dev->dev, "config 0 descriptor??\n");
 
-	if (dev->state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
-
-	/* Allocate memory for new interfaces before doing anything else,
-	 * so that if we run out then nothing will have changed. */
-	n = nintf = 0;
-	if (cp) {
-		nintf = cp->desc.bNumInterfaces;
-		new_interfaces = kmalloc(nintf * sizeof(*new_interfaces),
-				GFP_KERNEL);
-		if (!new_interfaces) {
-			dev_err(&dev->dev, "Out of memory");
-			return -ENOMEM;
-		}
-
-		for (; n < nintf; ++n) {
-			new_interfaces[n] = kmalloc(
-					sizeof(struct usb_interface),
-					GFP_KERNEL);
-			if (!new_interfaces[n]) {
-				dev_err(&dev->dev, "Out of memory");
-				ret = -ENOMEM;
-free_interfaces:
-				while (--n >= 0)
-					kfree(new_interfaces[n]);
-				kfree(new_interfaces);
-				return ret;
-			}
-		}
-	}
-
 	/* if it's already configured, clear out old state first.
 	 * getting rid of old interfaces means unbinding their drivers.
 	 */
@@ -1304,29 +1134,22 @@
 	if ((ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			USB_REQ_SET_CONFIGURATION, 0, configuration, 0,
 			NULL, 0, HZ * USB_CTRL_SET_TIMEOUT)) < 0)
-		goto free_interfaces;
+		goto out;
 
 	dev->actconfig = cp;
 	if (!cp)
-		usb_set_device_state(dev, USB_STATE_ADDRESS);
+		dev->state = USB_STATE_ADDRESS;
 	else {
-		usb_set_device_state(dev, USB_STATE_CONFIGURED);
+		dev->state = USB_STATE_CONFIGURED;
 
-		/* Initialize the new interface structures and the
-		 * hc/hcd/usbcore interface/endpoint state.
+		/* re-initialize hc/hcd/usbcore interface/endpoint state.
+		 * this triggers binding of drivers to interfaces; and
+		 * maybe probe() calls will choose different altsettings.
 		 */
-		for (i = 0; i < nintf; ++i) {
-			struct usb_interface_cache *intfc;
-			struct usb_interface *intf;
+		for (i = 0; i < cp->desc.bNumInterfaces; ++i) {
+			struct usb_interface *intf = cp->interface[i];
 			struct usb_host_interface *alt;
 
-			cp->interface[i] = intf = new_interfaces[i];
-			memset(intf, 0, sizeof(*intf));
-			intfc = cp->intf_cache[i];
-			intf->altsetting = intfc->altsetting;
-			intf->num_altsetting = intfc->num_altsetting;
-			kref_get(&intfc->ref);
-
 			alt = usb_altnum_to_altsetting(intf, 0);
 
 			/* No altsetting 0?  We'll assume the first altsetting.
@@ -1344,44 +1167,110 @@
 			intf->dev.bus = &usb_bus_type;
 			intf->dev.dma_mask = dev->dev.dma_mask;
 			intf->dev.release = release_interface;
-			device_initialize (&intf->dev);
 			sprintf (&intf->dev.bus_id[0], "%d-%s:%d.%d",
 				 dev->bus->busnum, dev->devpath,
 				 configuration,
 				 alt->desc.bInterfaceNumber);
-		}
-		kfree(new_interfaces);
-
-		/* Now that all the interfaces are set up, register them
-		 * to trigger binding of drivers to interfaces.  probe()
-		 * routines may install different altsettings and may
-		 * claim() any interfaces not yet bound.  Many class drivers
-		 * need that: CDC, audio, video, etc.
-		 */
-		for (i = 0; i < nintf; ++i) {
-			struct usb_interface *intf = cp->interface[i];
-			struct usb_interface_descriptor *desc;
-
-			desc = &intf->altsetting [0].desc;
 			dev_dbg (&dev->dev,
-				"adding %s (config #%d, interface %d)\n",
+				"registering %s (config #%d, interface %d)\n",
 				intf->dev.bus_id, configuration,
-				desc->bInterfaceNumber);
-			ret = device_add (&intf->dev);
-			if (ret != 0) {
-				dev_err(&dev->dev,
-					"device_add(%s) --> %d\n",
-					intf->dev.bus_id,
-					ret);
-				continue;
-			}
-			usb_create_sysfs_intf_files (intf);
+				alt->desc.bInterfaceNumber);
+			device_register (&intf->dev);
+			usb_create_driverfs_intf_files (intf);
 		}
 	}
 
+out:
+	up(&dev->serialize);
 	return ret;
 }
 
+/**
+ * usb_string - returns ISO 8859-1 version of a string descriptor
+ * @dev: the device whose string descriptor is being retrieved
+ * @index: the number of the descriptor
+ * @buf: where to put the string
+ * @size: how big is "buf"?
+ * Context: !in_interrupt ()
+ * 
+ * This converts the UTF-16LE encoded strings returned by devices, from
+ * usb_get_string_descriptor(), to null-terminated ISO-8859-1 encoded ones
+ * that are more usable in most kernel contexts.  Note that all characters
+ * in the chosen descriptor that can't be encoded using ISO-8859-1
+ * are converted to the question mark ("?") character, and this function
+ * chooses strings in the first language supported by the device.
+ *
+ * The ASCII (or, redundantly, "US-ASCII") character set is the seven-bit
+ * subset of ISO 8859-1. ISO-8859-1 is the eight-bit subset of Unicode,
+ * and is appropriate for use many uses of English and several other
+ * Western European languages.  (But it doesn't include the "Euro" symbol.)
+ *
+ * This call is synchronous, and may not be used in an interrupt context.
+ *
+ * Returns length of the string (>= 0) or usb_control_msg status (< 0).
+ */
+int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
+{
+	unsigned char *tbuf;
+	int err, len;
+	unsigned int u, idx;
+
+	if (size <= 0 || !buf || !index)
+		return -EINVAL;
+	buf[0] = 0;
+	tbuf = kmalloc(256, GFP_KERNEL);
+	if (!tbuf)
+		return -ENOMEM;
+
+	/* get langid for strings if it's not yet known */
+	if (!dev->have_langid) {
+		err = usb_get_string(dev, 0, 0, tbuf, 4);
+		if (err < 0) {
+			err("error getting string descriptor 0 (error=%d)", err);
+			goto errout;
+		} else if (err < 4 || tbuf[0] < 4) {
+			err("string descriptor 0 too short");
+			err = -EINVAL;
+			goto errout;
+		} else {
+			dev->have_langid = -1;
+			dev->string_langid = tbuf[2] | (tbuf[3]<< 8);
+				/* always use the first langid listed */
+			dbg("USB device number %d default language ID 0x%x",
+				dev->devnum, dev->string_langid);
+		}
+	}
+
+	/*
+	 * ask for the length of the string 
+	 */
+
+	err = usb_get_string(dev, dev->string_langid, index, tbuf, 2);
+	if(err<2)
+		goto errout;
+	len=tbuf[0];	
+	
+	err = usb_get_string(dev, dev->string_langid, index, tbuf, len);
+	if (err < 0)
+		goto errout;
+
+	size--;		/* leave room for trailing NULL char in output buffer */
+	for (idx = 0, u = 2; u < err; u += 2) {
+		if (idx >= size)
+			break;
+		if (tbuf[u+1])			/* high byte */
+			buf[idx++] = '?';  /* non ISO-8859-1 character */
+		else
+			buf[idx++] = tbuf[u];
+	}
+	buf[idx] = 0;
+	err = idx;
+
+ errout:
+	kfree(tbuf);
+	return err;
+}
+
 // synchronous request completion model
 EXPORT_SYMBOL(usb_control_msg);
 EXPORT_SYMBOL(usb_bulk_msg);
@@ -1399,5 +1288,6 @@
 // synchronous calls that also maintain usbcore state
 EXPORT_SYMBOL(usb_clear_halt);
 EXPORT_SYMBOL(usb_reset_configuration);
+EXPORT_SYMBOL(usb_set_configuration);
 EXPORT_SYMBOL(usb_set_interface);
 
diff -Naur linuxppc-2.6.9/drivers/usb/core/otg_whitelist.h linuxppc-2.6.9-dream/drivers/usb/core/otg_whitelist.h
--- linuxppc-2.6.9/drivers/usb/core/otg_whitelist.h	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/otg_whitelist.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,112 +0,0 @@
-/*
- * drivers/usb/core/otg_whitelist.h
- *
- * Copyright (C) 2004 Texas Instruments
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-/*
- * This OTG Whitelist is the OTG "Targeted Peripheral List".  It should
- * mostly use of USB_DEVICE() or USB_DEVICE_VER() entries..
- *
- * YOU _SHOULD_ CHANGE THIS LIST TO MATCH YOUR PRODUCT AND ITS TESTING!
- */ 
-
-static struct usb_device_id whitelist_table [] = {
-
-/* hubs are optional in OTG, but very handy ... */
-{ USB_DEVICE_INFO(USB_CLASS_HUB, 0, 0), },
-{ USB_DEVICE_INFO(USB_CLASS_HUB, 0, 1), },
-
-#ifdef	CONFIG_USB_PRINTER		/* ignoring nonstatic linkage! */
-/* FIXME actually, printers are NOT supposed to use device classes;
- * they're supposed to use interface classes...
- */
-{ USB_DEVICE_INFO(7, 1, 1) },
-{ USB_DEVICE_INFO(7, 1, 2) },
-{ USB_DEVICE_INFO(7, 1, 3) },
-#endif
-
-#ifdef	CONFIG_USB_CDCETHER
-/* Linux-USB CDC Ethernet gadget */
-{ USB_DEVICE(0x0525, 0xa4a1), },
-/* Linux-USB CDC Ethernet + RNDIS gadget */
-{ USB_DEVICE(0x0525, 0xa4a2), },
-#endif
-
-#if	defined(CONFIG_USB_TEST) || defined(CONFIG_USB_TEST_MODULE)
-/* gadget zero, for testing */
-{ USB_DEVICE(0x0525, 0xa4a0), },
-#endif
-
-{ }	/* Terminating entry */
-};
-
-static int is_targeted(struct usb_device *dev)
-{
-	struct usb_device_id	*id = whitelist_table;
-
-	/* possible in developer configs only! */
-	if (!dev->bus->otg_port)
-		return 1;
-
-	/* HNP test device is _never_ targeted (see OTG spec 6.6.6) */
-	if (dev->descriptor.idVendor == 0x1a0a
-			&& dev->descriptor.idProduct == 0xbadd)
-		return 0;
-
-	/* NOTE: can't use usb_match_id() since interface caches
-	 * aren't set up yet. this is cut/paste from that code.
-	 */
-	for (id = whitelist_table; id->match_flags; id++) {
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_VENDOR) &&
-		    id->idVendor != dev->descriptor.idVendor)
-			continue;
-
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_PRODUCT) &&
-		    id->idProduct != dev->descriptor.idProduct)
-			continue;
-
-		/* No need to test id->bcdDevice_lo != 0, since 0 is never
-		   greater than any unsigned number. */
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_LO) &&
-		    (id->bcdDevice_lo > dev->descriptor.bcdDevice))
-			continue;
-
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_HI) &&
-		    (id->bcdDevice_hi < dev->descriptor.bcdDevice))
-			continue;
-
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_CLASS) &&
-		    (id->bDeviceClass != dev->descriptor.bDeviceClass))
-			continue;
-
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_SUBCLASS) &&
-		    (id->bDeviceSubClass!= dev->descriptor.bDeviceSubClass))
-			continue;
-
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_PROTOCOL) &&
-		    (id->bDeviceProtocol != dev->descriptor.bDeviceProtocol))
-			continue;
-
-		return 1;
-	}
-
-	/* add other match criteria here ... */
-
-
-	/* OTG MESSAGE: report errors here, customize to match your product */
-	dev_err(&dev->dev, "device v%04x p%04x is not supported\n",
-			dev->descriptor.idVendor,
-			dev->descriptor.idProduct);
-#ifdef	CONFIG_USB_OTG_WHITELIST
-	return 0;
-#else
-	return 1;
-#endif
-}
-
diff -Naur linuxppc-2.6.9/drivers/usb/core/sysfs.c linuxppc-2.6.9-dream/drivers/usb/core/sysfs.c
--- linuxppc-2.6.9/drivers/usb/core/sysfs.c	2004-10-18 23:53:45.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/sysfs.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,258 +0,0 @@
-/*
- * drivers/usb/core/sysfs.c
- *
- * (C) Copyright 2002 David Brownell
- * (C) Copyright 2002,2004 Greg Kroah-Hartman
- * (C) Copyright 2002,2004 IBM Corp.
- *
- * All of the sysfs file attributes for usb devices and interfaces.
- *
- */
-
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-
-#ifdef CONFIG_USB_DEBUG
-	#define DEBUG
-#else
-	#undef DEBUG
-#endif
-#include <linux/usb.h>
-
-#include "usb.h"
-
-/* Active configuration fields */
-#define usb_actconfig_show(field, multiplier, format_string)		\
-static ssize_t  show_##field (struct device *dev, char *buf)		\
-{									\
-	struct usb_device *udev;					\
-									\
-	udev = to_usb_device (dev);					\
-	if (udev->actconfig)						\
-		return sprintf (buf, format_string,			\
-				udev->actconfig->desc.field * multiplier);	\
-	else								\
-		return 0;						\
-}									\
-
-#define usb_actconfig_attr(field, multiplier, format_string)		\
-usb_actconfig_show(field, multiplier, format_string)			\
-static DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
-
-usb_actconfig_attr (bNumInterfaces, 1, "%2d\n")
-usb_actconfig_attr (bmAttributes, 1, "%2x\n")
-usb_actconfig_attr (bMaxPower, 2, "%3dmA\n")
-
-/* configuration value is always present, and r/w */
-usb_actconfig_show(bConfigurationValue, 1, "%u\n");
-
-static ssize_t
-set_bConfigurationValue (struct device *dev, const char *buf, size_t count)
-{
-	struct usb_device	*udev = udev = to_usb_device (dev);
-	int			config, value;
-
-	if (sscanf (buf, "%u", &config) != 1 || config > 255)
-		return -EINVAL;
-	down(&udev->serialize);
-	value = usb_set_configuration (udev, config);
-	up(&udev->serialize);
-	return (value < 0) ? value : count;
-}
-
-static DEVICE_ATTR(bConfigurationValue, S_IRUGO | S_IWUSR, 
-		show_bConfigurationValue, set_bConfigurationValue);
-
-/* String fields */
-#define usb_string_attr(name, field)		\
-static ssize_t  show_##name(struct device *dev, char *buf)		\
-{									\
-	struct usb_device *udev;					\
-	int len;							\
-									\
-	udev = to_usb_device (dev);					\
-	len = usb_string(udev, udev->descriptor.field, buf, PAGE_SIZE);	\
-	if (len < 0)							\
-		return 0;						\
-	buf[len] = '\n';						\
-	buf[len+1] = 0;							\
-	return len+1;							\
-}									\
-static DEVICE_ATTR(name, S_IRUGO, show_##name, NULL);
-
-usb_string_attr(product, iProduct);
-usb_string_attr(manufacturer, iManufacturer);
-usb_string_attr(serial, iSerialNumber);
-
-static ssize_t
-show_speed (struct device *dev, char *buf)
-{
-	struct usb_device *udev;
-	char *speed;
-
-	udev = to_usb_device (dev);
-
-	switch (udev->speed) {
-	case USB_SPEED_LOW:
-		speed = "1.5";
-		break;
-	case USB_SPEED_UNKNOWN:
-	case USB_SPEED_FULL:
-		speed = "12";
-		break;
-	case USB_SPEED_HIGH:
-		speed = "480";
-		break;
-	default:
-		speed = "unknown";
-	}
-	return sprintf (buf, "%s\n", speed);
-}
-static DEVICE_ATTR(speed, S_IRUGO, show_speed, NULL);
-
-static ssize_t
-show_devnum (struct device *dev, char *buf)
-{
-	struct usb_device *udev;
-
-	udev = to_usb_device (dev);
-	return sprintf (buf, "%d\n", udev->devnum);
-}
-static DEVICE_ATTR(devnum, S_IRUGO, show_devnum, NULL);
-
-static ssize_t
-show_version (struct device *dev, char *buf)
-{
-	struct usb_device *udev;
-
-	udev = to_usb_device (dev);
-	return sprintf (buf, "%2x.%02x\n", udev->descriptor.bcdUSB >> 8, 
-			udev->descriptor.bcdUSB & 0xff);
-}
-static DEVICE_ATTR(version, S_IRUGO, show_version, NULL);
-
-static ssize_t
-show_maxchild (struct device *dev, char *buf)
-{
-	struct usb_device *udev;
-
-	udev = to_usb_device (dev);
-	return sprintf (buf, "%d\n", udev->maxchild);
-}
-static DEVICE_ATTR(maxchild, S_IRUGO, show_maxchild, NULL);
-
-/* Descriptor fields */
-#define usb_descriptor_attr(field, format_string)			\
-static ssize_t								\
-show_##field (struct device *dev, char *buf)				\
-{									\
-	struct usb_device *udev;					\
-									\
-	udev = to_usb_device (dev);					\
-	return sprintf (buf, format_string, udev->descriptor.field);	\
-}									\
-static DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
-
-usb_descriptor_attr (idVendor, "%04x\n")
-usb_descriptor_attr (idProduct, "%04x\n")
-usb_descriptor_attr (bcdDevice, "%04x\n")
-usb_descriptor_attr (bDeviceClass, "%02x\n")
-usb_descriptor_attr (bDeviceSubClass, "%02x\n")
-usb_descriptor_attr (bDeviceProtocol, "%02x\n")
-usb_descriptor_attr (bNumConfigurations, "%d\n")
-
-static struct attribute *dev_attrs[] = {
-	/* current configuration's attributes */
-	&dev_attr_bNumInterfaces.attr,
-	&dev_attr_bConfigurationValue.attr,
-	&dev_attr_bmAttributes.attr,
-	&dev_attr_bMaxPower.attr,
-	/* device attributes */
-	&dev_attr_idVendor.attr,
-	&dev_attr_idProduct.attr,
-	&dev_attr_bcdDevice.attr,
-	&dev_attr_bDeviceClass.attr,
-	&dev_attr_bDeviceSubClass.attr,
-	&dev_attr_bDeviceProtocol.attr,
-	&dev_attr_bNumConfigurations.attr,
-	&dev_attr_speed.attr,
-	&dev_attr_devnum.attr,
-	&dev_attr_version.attr,
-	&dev_attr_maxchild.attr,
-	NULL,
-};
-static struct attribute_group dev_attr_grp = {
-	.attrs = dev_attrs,
-};
-
-void usb_create_sysfs_dev_files (struct usb_device *udev)
-{
-	struct device *dev = &udev->dev;
-
-	sysfs_create_group(&dev->kobj, &dev_attr_grp);
-
-	if (udev->descriptor.iManufacturer)
-		device_create_file (dev, &dev_attr_manufacturer);
-	if (udev->descriptor.iProduct)
-		device_create_file (dev, &dev_attr_product);
-	if (udev->descriptor.iSerialNumber)
-		device_create_file (dev, &dev_attr_serial);
-}
-
-void usb_remove_sysfs_dev_files (struct usb_device *udev)
-{
-	struct device *dev = &udev->dev;
-
-	sysfs_remove_group(&dev->kobj, &dev_attr_grp);
-
-	if (udev->descriptor.iManufacturer)
-		device_remove_file(dev, &dev_attr_manufacturer);
-	if (udev->descriptor.iProduct)
-		device_remove_file(dev, &dev_attr_product);
-	if (udev->descriptor.iSerialNumber)
-		device_remove_file(dev, &dev_attr_serial);
-}
-
-/* Interface fields */
-#define usb_intf_attr(field, format_string)				\
-static ssize_t								\
-show_##field (struct device *dev, char *buf)				\
-{									\
-	struct usb_interface *intf = to_usb_interface (dev);		\
-									\
-	return sprintf (buf, format_string, intf->cur_altsetting->desc.field); \
-}									\
-static DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
-
-usb_intf_attr (bInterfaceNumber, "%02x\n")
-usb_intf_attr (bAlternateSetting, "%2d\n")
-usb_intf_attr (bNumEndpoints, "%02x\n")
-usb_intf_attr (bInterfaceClass, "%02x\n")
-usb_intf_attr (bInterfaceSubClass, "%02x\n")
-usb_intf_attr (bInterfaceProtocol, "%02x\n")
-usb_intf_attr (iInterface, "%02x\n")
-
-static struct attribute *intf_attrs[] = {
-	&dev_attr_bInterfaceNumber.attr,
-	&dev_attr_bAlternateSetting.attr,
-	&dev_attr_bNumEndpoints.attr,
-	&dev_attr_bInterfaceClass.attr,
-	&dev_attr_bInterfaceSubClass.attr,
-	&dev_attr_bInterfaceProtocol.attr,
-	&dev_attr_iInterface.attr,
-	NULL,
-};
-static struct attribute_group intf_attr_grp = {
-	.attrs = intf_attrs,
-};
-
-void usb_create_sysfs_intf_files (struct usb_interface *intf)
-{
-	sysfs_create_group(&intf->dev.kobj, &intf_attr_grp);
-}
-
-void usb_remove_sysfs_intf_files (struct usb_interface *intf)
-{
-	sysfs_remove_group(&intf->dev.kobj, &intf_attr_grp);
-}
diff -Naur linuxppc-2.6.9/drivers/usb/core/urb.c linuxppc-2.6.9-dream/drivers/usb/core/urb.c
--- linuxppc-2.6.9/drivers/usb/core/urb.c	2004-10-18 23:54:32.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/urb.c	2005-09-19 21:40:05.000000000 +0200
@@ -13,14 +13,6 @@
 #include <linux/usb.h>
 #include "hcd.h"
 
-#define to_urb(d) container_of(d, struct urb, kref)
-
-static void urb_destroy(struct kref *kref)
-{
-	struct urb *urb = to_urb(kref);
-	kfree(urb);
-}
-
 /**
  * usb_init_urb - initializes a urb so that it can be used by a USB driver
  * @urb: pointer to the urb to initialize
@@ -39,7 +31,7 @@
 {
 	if (urb) {
 		memset(urb, 0, sizeof(*urb));
-		kref_init(&urb->kref);
+		urb->count = (atomic_t)ATOMIC_INIT(1);
 		spin_lock_init(&urb->lock);
 	}
 }
@@ -77,7 +69,7 @@
 
 /**
  * usb_free_urb - frees the memory used by a urb when all users of it are finished
- * @urb: pointer to the urb to free, may be NULL
+ * @urb: pointer to the urb to free
  *
  * Must be called when a user of a urb is finished with it.  When the last user
  * of the urb calls this function, the memory of the urb is freed.
@@ -88,12 +80,13 @@
 void usb_free_urb(struct urb *urb)
 {
 	if (urb)
-		kref_put(&urb->kref, urb_destroy);
+		if (atomic_dec_and_test(&urb->count))
+			kfree(urb);
 }
 
 /**
  * usb_get_urb - increments the reference count of the urb
- * @urb: pointer to the urb to modify, may be NULL
+ * @urb: pointer to the urb to modify
  *
  * This must be  called whenever a urb is transferred from a device driver to a
  * host controller driver.  This allows proper reference counting to happen
@@ -103,9 +96,11 @@
  */
 struct urb * usb_get_urb(struct urb *urb)
 {
-	if (urb)
-		kref_get(&urb->kref);
-	return urb;
+	if (urb) {
+		atomic_inc(&urb->count);
+		return urb;
+	} else
+		return NULL;
 }
 		
 		
@@ -237,8 +232,6 @@
 	    (dev->state < USB_STATE_DEFAULT) ||
 	    (!dev->bus) || (dev->devnum <= 0))
 		return -ENODEV;
-	if (dev->state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
 	if (!(op = dev->bus->op) || !op->submit_urb)
 		return -ENODEV;
 
@@ -256,6 +249,13 @@
 	if (!usb_pipecontrol (pipe) && dev->state < USB_STATE_CONFIGURED)
 		return -ENODEV;
 
+	/* (actually HCDs may need to duplicate this, endpoint might yet
+	 * stall due to queued bulk/intr transactions that complete after
+	 * we check)
+	 */
+	if (usb_endpoint_halted (dev, usb_pipeendpoint (pipe), is_out))
+		return -EPIPE;
+
 	/* FIXME there should be a sharable lock protecting us against
 	 * config/altsetting changes and disconnects, kicking in here.
 	 * (here == before maxpacket, and eventually endpoint type,
@@ -391,8 +391,7 @@
 
 /**
  * usb_unlink_urb - abort/cancel a transfer request for an endpoint
- * @urb: pointer to urb describing a previously submitted request,
- *	may be NULL
+ * @urb: pointer to urb describing a previously submitted request
  *
  * This routine cancels an in-progress request.  URBs complete only
  * once per submission, and may be canceled only once per submission.
@@ -401,25 +400,26 @@
  * canceled (rather than any other code) and will quickly be removed
  * from host controller data structures.
  *
- * In the past, clearing the URB_ASYNC_UNLINK transfer flag for the
- * URB indicated that the request was synchronous.  This usage is now
- * deprecated; if the flag is clear the call will be forwarded to
- * usb_kill_urb() and the return value will be 0.  In the future, drivers
- * should call usb_kill_urb() directly for synchronous unlinking.
+ * When the URB_ASYNC_UNLINK transfer flag for the URB is clear, this
+ * request is synchronous.  Success is indicated by returning zero,
+ * at which time the urb will have been unlinked and its completion
+ * handler will have been called with urb->status == -ENOENT.  Failure is
+ * indicated by any other return value.
+ *
+ * The synchronous cancelation mode may not be used
+ * when unlinking an urb from an interrupt context, such as a bottom
+ * half or a completion handler; or when holding a spinlock; or in
+ * other cases when the caller can't schedule().
  *
  * When the URB_ASYNC_UNLINK transfer flag for the URB is set, this
  * request is asynchronous.  Success is indicated by returning -EINPROGRESS,
- * at which time the URB will normally have been unlinked but not yet
- * given back to the device driver.  When it is called, the completion
- * function will see urb->status == -ECONNRESET.  Failure is indicated
- * by any other return value.  Unlinking will fail when the URB is not
- * currently "linked" (i.e., it was never submitted, or it was unlinked
- * before, or the hardware is already finished with it), even if the
- * completion handler has not yet run.
+ * at which time the urb will normally not have been unlinked.
+ * The completion function will see urb->status == -ECONNRESET.  Failure
+ * is indicated by any other return value.
  *
  * Unlinking and Endpoint Queues:
  *
- * Host Controller Drivers (HCDs) place all the URBs for a particular
+ * Host Controller Driver (HCDs) place all the URBs for a particular
  * endpoint in a queue.  Normally the queue advances as the controller
  * hardware processes each request.  But when an URB terminates with any
  * fault (such as an error, or being unlinked) its queue stops, at least
@@ -442,57 +442,16 @@
  * An unlinked URB may leave a gap in the stream of packets.  It is undefined
  * whether such gaps can be filled in.
  *
- * When a control URB terminates with an error, it is likely that the
+ * When control URBs terminates with an error, it is likely that the
  * status stage of the transfer will not take place, even if it is merely
  * a soft error resulting from a short-packet with URB_SHORT_NOT_OK set.
  */
 int usb_unlink_urb(struct urb *urb)
 {
-	if (!urb)
-		return -EINVAL;
-	if (!(urb->transfer_flags & URB_ASYNC_UNLINK)) {
-		usb_kill_urb(urb);
-		return 0;
-	}
-	if (!(urb->dev && urb->dev->bus && urb->dev->bus->op))
+	if (urb && urb->dev && urb->dev->bus && urb->dev->bus->op)
+		return urb->dev->bus->op->unlink_urb(urb);
+	else
 		return -ENODEV;
-	return urb->dev->bus->op->unlink_urb(urb, -ECONNRESET);
-}
-
-/**
- * usb_kill_urb - cancel a transfer request and wait for it to finish
- * @urb: pointer to URB describing a previously submitted request,
- *	may be NULL
- *
- * This routine cancels an in-progress request.  It is guaranteed that
- * upon return all completion handlers will have finished and the URB
- * will be totally idle and available for reuse.  These features make
- * this an ideal way to stop I/O in a disconnect() callback or close()
- * function.  If the request has not already finished or been unlinked
- * the completion handler will see urb->status == -ENOENT.
- *
- * While the routine is running, attempts to resubmit the URB will fail
- * with error -EPERM.  Thus even if the URB's completion handler always
- * tries to resubmit, it will not succeed and the URB will become idle.
- *
- * This routine may not be used in an interrupt context (such as a bottom
- * half or a completion handler), or when holding a spinlock, or in other
- * situations where the caller can't schedule().
- */
-void usb_kill_urb(struct urb *urb)
-{
-	if (!(urb && urb->dev && urb->dev->bus && urb->dev->bus->op))
-		return;
-	spin_lock_irq(&urb->lock);
-	++urb->reject;
-	spin_unlock_irq(&urb->lock);
-
-	urb->dev->bus->op->unlink_urb(urb, -ENOENT);
-	wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);
-
-	spin_lock_irq(&urb->lock);
-	--urb->reject;
-	spin_unlock_irq(&urb->lock);
 }
 
 EXPORT_SYMBOL(usb_init_urb);
@@ -501,5 +460,4 @@
 EXPORT_SYMBOL(usb_get_urb);
 EXPORT_SYMBOL(usb_submit_urb);
 EXPORT_SYMBOL(usb_unlink_urb);
-EXPORT_SYMBOL(usb_kill_urb);
 
diff -Naur linuxppc-2.6.9/drivers/usb/core/usb.c linuxppc-2.6.9-dream/drivers/usb/core/usb.c
--- linuxppc-2.6.9/drivers/usb/core/usb.c	2004-10-18 23:54:20.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/usb.c	2005-09-19 21:40:05.000000000 +0200
@@ -7,7 +7,8 @@
  * (C) Copyright Gregory P. Smith 1999
  * (C) Copyright Deti Fliegl 1999 (new USB architecture)
  * (C) Copyright Randy Dunlap 2000
- * (C) Copyright David Brownell 2000-2004
+ * (C) Copyright David Brownell 2000-2001 (kernel hotplug, usb_device_id,
+ 	more docs, etc)
  * (C) Copyright Yggdrasil Computing, Inc. 2000
  *     (usb_device_id matching changes by Adam J. Richter)
  * (C) Copyright Greg Kroah-Hartman 2002-2003
@@ -57,8 +58,6 @@
 extern void usb_host_cleanup(void);
 
 
-const char *usbcore_name = "usbcore";
-
 int nousb;		/* Disable USB when built into kernel image */
 			/* Not honored on modular build */
 
@@ -93,14 +92,18 @@
 
 	if (!driver->probe)
 		return error;
-	if (interface_to_usbdev(intf)->state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
+
+	/* driver claim() doesn't yet affect dev->driver... */
+	if (intf->driver)
+		return error;
 
 	id = usb_match_id (intf, driver->id_table);
 	if (id) {
 		dev_dbg (dev, "%s - got id\n", __FUNCTION__);
 		error = driver->probe (intf, id);
 	}
+	if (!error)
+		intf->driver = driver;
 
 	return error;
 }
@@ -109,7 +112,7 @@
 int usb_unbind_interface(struct device *dev)
 {
 	struct usb_interface *intf = to_usb_interface(dev);
-	struct usb_driver *driver = to_usb_driver(intf->dev.driver);
+	struct usb_driver *driver = intf->driver;
 
 	/* release all urbs for this interface */
 	usb_disable_interface(interface_to_usbdev(intf), intf);
@@ -122,6 +125,7 @@
 			intf->altsetting[0].desc.bInterfaceNumber,
 			0);
 	usb_set_intfdata(intf, NULL);
+	intf->driver = NULL;
 
 	return 0;
 }
@@ -154,12 +158,11 @@
 	retval = driver_register(&new_driver->driver);
 
 	if (!retval) {
-		pr_info("%s: registered new driver %s\n",
-			usbcore_name, new_driver->name);
+		info("registered new driver %s", new_driver->name);
 		usbfs_update_special();
 	} else {
-		printk(KERN_ERR "%s: error %d registering driver %s\n",
-			usbcore_name, retval, new_driver->name);
+		err("problem %d when registering driver %s",
+			retval, new_driver->name);
 	}
 
 	return retval;
@@ -178,7 +181,7 @@
  */
 void usb_deregister(struct usb_driver *driver)
 {
-	pr_info("%s: deregistering driver %s\n", usbcore_name, driver->name);
+	info("deregistering driver %s", driver->name);
 
 	driver_unregister (&driver->driver);
 
@@ -200,9 +203,6 @@
  * This routine helps device drivers avoid such mistakes.
  * However, you should make sure that you do the right thing with any
  * alternate settings available for this interfaces.
- *
- * Don't call this function unless you are bound to one of the interfaces
- * on this device or you own the dev->serialize semaphore!
  */
 struct usb_interface *usb_ifnum_to_if(struct usb_device *dev, unsigned ifnum)
 {
@@ -233,9 +233,6 @@
  * it would be incorrect to assume that the first altsetting entry in
  * the array corresponds to altsetting zero.  This routine helps device
  * drivers avoid such mistakes.
- *
- * Don't call this function unless you are bound to the intf interface
- * or you own the device's ->serialize semaphore!
  */
 struct usb_host_interface *usb_altnum_to_altsetting(struct usb_interface *intf,
 		unsigned int altnum)
@@ -290,8 +287,7 @@
 /**
  * usb_driver_claim_interface - bind a driver to an interface
  * @driver: the driver to be bound
- * @iface: the interface to which it will be bound; must be in the
- *	usb device's active configuration
+ * @iface: the interface to which it will be bound
  * @priv: driver data associated with that interface
  *
  * This is used by usb device drivers that need to claim more than one
@@ -309,52 +305,75 @@
  */
 int usb_driver_claim_interface(struct usb_driver *driver, struct usb_interface *iface, void* priv)
 {
-	struct device *dev = &iface->dev;
+	if (!iface || !driver)
+		return -EINVAL;
 
-	if (dev->driver)
+	if (iface->driver)
 		return -EBUSY;
 
-	dev->driver = &driver->driver;
+	/* FIXME should device_bind_driver() */
+	iface->driver = driver;
 	usb_set_intfdata(iface, priv);
-
-	/* if interface was already added, bind now; else let
-	 * the future device_add() bind it, bypassing probe()
-	 */
-	if (!list_empty (&dev->bus_list))
-		device_bind_driver(dev);
-
 	return 0;
 }
 
 /**
+ * usb_interface_claimed - returns true iff an interface is claimed
+ * @iface: the interface being checked
+ *
+ * This should be used by drivers to check other interfaces to see if
+ * they are available or not.  If another driver has claimed the interface,
+ * they may not claim it.  Otherwise it's OK to claim it using
+ * usb_driver_claim_interface().
+ *
+ * Returns true (nonzero) iff the interface is claimed, else false (zero).
+ */
+int usb_interface_claimed(struct usb_interface *iface)
+{
+	if (!iface)
+		return 0;
+
+	return (iface->driver != NULL);
+} /* usb_interface_claimed() */
+
+/**
  * usb_driver_release_interface - unbind a driver from an interface
  * @driver: the driver to be unbound
  * @iface: the interface from which it will be unbound
  *
+ * In addition to unbinding the driver, this re-initializes the interface
+ * by selecting altsetting 0, the default alternate setting.
+ * 
  * This can be used by drivers to release an interface without waiting
- * for their disconnect() methods to be called.  In typical cases this
- * also causes the driver disconnect() method to be called.
+ * for their disconnect() methods to be called.
+ *
+ * When the USB subsystem disconnect()s a driver from some interface,
+ * it automatically invokes this method for that interface.  That
+ * means that even drivers that used usb_driver_claim_interface()
+ * usually won't need to call this.
  *
  * This call is synchronous, and may not be used in an interrupt context.
- * Callers must own the usb_device serialize semaphore and the driver model's
- * usb bus writelock.  So driver disconnect() entries don't need extra locking,
- * but other call contexts may need to explicitly claim those locks.
+ * Callers must own the driver model's usb bus writelock.  So driver
+ * disconnect() entries don't need extra locking, but other call contexts
+ * may need to explicitly claim that lock.
  */
-void usb_driver_release_interface(struct usb_driver *driver,
-					struct usb_interface *iface)
+void usb_driver_release_interface(struct usb_driver *driver, struct usb_interface *iface)
 {
-	struct device *dev = &iface->dev;
-
 	/* this should never happen, don't release something that's not ours */
-	if (!dev->driver || dev->driver != &driver->driver)
+	if (!iface || !iface->driver || iface->driver != driver)
 		return;
 
-	/* don't disconnect from disconnect(), or before dev_add() */
-	if (!list_empty (&dev->driver_list) && !list_empty (&dev->bus_list))
-		device_release_driver(dev);
+	if (iface->dev.driver) {
+		/* FIXME should be the ONLY case here */
+		device_release_driver(&iface->dev);
+		return;
+	}
 
-	dev->driver = NULL;
+	usb_set_interface(interface_to_usbdev(iface),
+			iface->altsetting[0].desc.bInterfaceNumber,
+			0);
 	usb_set_intfdata(iface, NULL);
+	iface->driver = NULL;
 }
 
 /**
@@ -568,12 +587,11 @@
 	int i = 0;
 	int length = 0;
 
+	dbg ("%s", __FUNCTION__);
+
 	if (!dev)
 		return -ENODEV;
 
-	/* driver is often null here; dev_dbg() would oops */
-	pr_debug ("usb %s: hotplug\n", dev->bus_id);
-
 	/* Must check driver_data here, as on remove driver is always NULL */
 	if ((dev->driver == &usb_generic_driver) || 
 	    (dev->driver_data == &usb_generic_driver_data))
@@ -583,11 +601,11 @@
 	usb_dev = interface_to_usbdev (intf);
 	
 	if (usb_dev->devnum < 0) {
-		pr_debug ("usb %s: already deleted?\n", dev->bus_id);
+		dbg ("device already deleted ??");
 		return -ENODEV;
 	}
 	if (!usb_dev->bus) {
-		pr_debug ("usb %s: bus removed?\n", dev->bus_id);
+		dbg ("bus already removed?");
 		return -ENODEV;
 	}
 
@@ -651,7 +669,7 @@
 		scratch += length;
 
 	}
-	envp[i++] = NULL;
+	envp [i++] = 0;
 
 	return 0;
 }
@@ -776,11 +794,18 @@
  *
  * A pointer to the device with the incremented reference counter is returned.
  */
-struct usb_device *usb_get_dev(struct usb_device *dev)
+struct usb_device *usb_get_dev (struct usb_device *dev)
 {
-	if (dev)
-		get_device(&dev->dev);
-	return dev;
+	struct device *tmp;
+
+	if (!dev)
+		return NULL;
+
+	tmp = get_device(&dev->dev);
+	if (tmp)        
+		return to_usb_device(tmp);
+	else
+		return NULL;
 }
 
 /**
@@ -796,54 +821,20 @@
 		put_device(&dev->dev);
 }
 
-/**
- * usb_get_intf - increments the reference count of the usb interface structure
- * @intf: the interface being referenced
- *
- * Each live reference to a interface must be refcounted.
- *
- * Drivers for USB interfaces should normally record such references in
- * their probe() methods, when they bind to an interface, and release
- * them by calling usb_put_intf(), in their disconnect() methods.
- *
- * A pointer to the interface with the incremented reference counter is
- * returned.
- */
-struct usb_interface *usb_get_intf(struct usb_interface *intf)
-{
-	if (intf)
-		get_device(&intf->dev);
-	return intf;
-}
-
-/**
- * usb_put_intf - release a use of the usb interface structure
- * @intf: interface that's been decremented
- *
- * Must be called when a user of an interface is finished with it.  When the
- * last user of the interface calls this function, the memory of the interface
- * is freed.
- */
-void usb_put_intf(struct usb_interface *intf)
-{
-	if (intf)
-		put_device(&intf->dev);
-}
-
 static struct usb_device *match_device(struct usb_device *dev,
 				       u16 vendor_id, u16 product_id)
 {
 	struct usb_device *ret_dev = NULL;
 	int child;
 
-	dev_dbg(&dev->dev, "check for vendor %04x, product %04x ...\n",
+	dbg("looking at vendor %d, product %d",
 	    dev->descriptor.idVendor,
 	    dev->descriptor.idProduct);
 
 	/* see if this device matches */
 	if ((dev->descriptor.idVendor == vendor_id) &&
 	    (dev->descriptor.idProduct == product_id)) {
-		dev_dbg (&dev->dev, "matched this device!\n");
+		dbg ("found the device!");
 		ret_dev = usb_get_dev(dev);
 		goto exit;
 	}
@@ -885,8 +876,6 @@
 	     buslist != &usb_bus_list; 
 	     buslist = buslist->next) {
 		bus = container_of(buslist, struct usb_bus, bus_list);
-		if (!bus->root_hub)
-			continue;
 		dev = match_device(bus->root_hub, vendor_id, product_id);
 		if (dev)
 			goto exit;
@@ -920,8 +909,7 @@
  * extra field of the interface and endpoint descriptor structs.
  */
 
-int __usb_get_extra_descriptor(char *buffer, unsigned size,
-	unsigned char type, void **ptr)
+int __usb_get_extra_descriptor(char *buffer, unsigned size, unsigned char type, void **ptr)
 {
 	struct usb_descriptor_header *header;
 
@@ -929,11 +917,7 @@
 		header = (struct usb_descriptor_header *)buffer;
 
 		if (header->bLength < 2) {
-			printk(KERN_ERR
-				"%s: bogus descriptor, type %d length %d\n",
-				usbcore_name,
-				header->bDescriptorType, 
-				header->bLength);
+			err("invalid descriptor length of %d", header->bLength);
 			return -1;
 		}
 
@@ -949,6 +933,296 @@
 }
 
 /**
+ * usb_disconnect - disconnect a device (usbcore-internal)
+ * @pdev: pointer to device being disconnected
+ * Context: !in_interrupt ()
+ *
+ * Something got disconnected. Get rid of it, and all of its children.
+ *
+ * Only hub drivers (including virtual root hub drivers for host
+ * controllers) should ever call this.
+ *
+ * This call is synchronous, and may not be used in an interrupt context.
+ */
+void usb_disconnect(struct usb_device **pdev)
+{
+	struct usb_device	*dev = *pdev;
+	struct usb_bus		*bus;
+	struct usb_operations	*ops;
+	int			i;
+
+	might_sleep ();
+
+	if (!dev) {
+		pr_debug ("%s nodev\n", __FUNCTION__);
+		return;
+	}
+	bus = dev->bus;
+	if (!bus) {
+		pr_debug ("%s nobus\n", __FUNCTION__);
+		return;
+	}
+	ops = bus->op;
+
+	*pdev = NULL;
+
+	/* mark the device as inactive, so any further urb submissions for
+	 * this device will fail.
+	 */
+	dev->state = USB_STATE_NOTATTACHED;
+	down(&dev->serialize);
+
+	dev_info (&dev->dev, "USB disconnect, address %d\n", dev->devnum);
+
+	/* Free up all the children before we remove this device */
+	for (i = 0; i < USB_MAXCHILDREN; i++) {
+		struct usb_device **child = dev->children + i;
+		if (*child)
+			usb_disconnect(child);
+	}
+
+	/* deallocate hcd/hardware state ... nuking all pending urbs and
+	 * cleaning up all state associated with the current configuration
+	 */
+	usb_disable_device(dev, 0);
+
+	dev_dbg (&dev->dev, "unregistering device\n");
+	/* Free the device number and remove the /proc/bus/usb entry */
+	if (dev->devnum > 0) {
+		clear_bit(dev->devnum, dev->bus->devmap.devicemap);
+		usbfs_remove_device(dev);
+	}
+	up(&dev->serialize);
+	device_unregister(&dev->dev);
+}
+
+/**
+ * usb_choose_address - pick device address (usbcore-internal)
+ * @dev: newly detected device (in DEFAULT state)
+ *
+ * Picks a device address.  It's up to the hub (or root hub) driver
+ * to handle and manage enumeration, starting from the DEFAULT state.
+ * Only hub drivers (but not virtual root hub drivers for host
+ * controllers) should ever call this.
+ */
+void usb_choose_address(struct usb_device *dev)
+{
+	int devnum;
+	// FIXME needs locking for SMP!!
+	/* why? this is called only from the hub thread, 
+	 * which hopefully doesn't run on multiple CPU's simultaneously 8-)
+	 */
+
+	/* Try to allocate the next devnum beginning at bus->devnum_next. */
+	devnum = find_next_zero_bit(dev->bus->devmap.devicemap, 128, dev->bus->devnum_next);
+	if (devnum >= 128)
+		devnum = find_next_zero_bit(dev->bus->devmap.devicemap, 128, 1);
+
+	dev->bus->devnum_next = ( devnum >= 127 ? 1 : devnum + 1);
+
+	if (devnum < 128) {
+		set_bit(devnum, dev->bus->devmap.devicemap);
+		dev->devnum = devnum;
+	}
+}
+
+
+// hub-only!! ... and only exported for reset/reinit path.
+// otherwise used internally, for usb_new_device()
+int usb_set_address(struct usb_device *dev)
+{
+	int retval;
+
+	if (dev->devnum == 0)
+		return -EINVAL;
+	if (dev->state != USB_STATE_DEFAULT && dev->state != USB_STATE_ADDRESS)
+		return -EINVAL;
+	retval = usb_control_msg(dev, usb_snddefctrl(dev), USB_REQ_SET_ADDRESS,
+		0, dev->devnum, 0, NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
+	if (retval == 0)
+		dev->state = USB_STATE_ADDRESS;
+	return retval;
+}
+
+static inline void usb_show_string(struct usb_device *dev, char *id, int index)
+{
+	char *buf;
+
+	if (!index)
+		return;
+	if (!(buf = kmalloc(256, GFP_KERNEL)))
+		return;
+	if (usb_string(dev, index, buf, 256) > 0)
+		dev_printk(KERN_INFO, &dev->dev, "%s: %s\n", id, buf);
+	kfree(buf);
+}
+
+/*
+ * By the time we get here, we chose a new device address
+ * and is in the default state. We need to identify the thing and
+ * get the ball rolling..
+ *
+ * Returns 0 for success, != 0 for error.
+ *
+ * This call is synchronous, and may not be used in an interrupt context.
+ *
+ * Only the hub driver should ever call this; root hub registration
+ * uses it only indirectly.
+ */
+#define NEW_DEVICE_RETRYS	2
+#define SET_ADDRESS_RETRYS	2
+int usb_new_device(struct usb_device *dev)
+{
+	int err = -EINVAL;
+	int i;
+	int j;
+	int config;
+
+	/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...
+	 * it's fixed size except for full speed devices.
+	 */
+	switch (dev->speed) {
+	case USB_SPEED_HIGH:		/* fixed at 64 */
+		i = 64;
+		break;
+	case USB_SPEED_FULL:		/* 8, 16, 32, or 64 */
+		/* to determine the ep0 maxpacket size, read the first 8
+		 * bytes from the device descriptor to get bMaxPacketSize0;
+		 * then correct our initial (small) guess.
+		 */
+		// FALLTHROUGH
+	case USB_SPEED_LOW:		/* fixed at 8 */
+		i = 8;
+		break;
+	default:
+		goto fail;
+	}
+	dev->epmaxpacketin [0] = i;
+	dev->epmaxpacketout[0] = i;
+
+	for (i = 0; i < NEW_DEVICE_RETRYS; ++i) {
+
+		for (j = 0; j < SET_ADDRESS_RETRYS; ++j) {
+			err = usb_set_address(dev);
+			if (err >= 0)
+				break;
+			wait_ms(200);
+		}
+		if (err < 0) {
+			dev_err(&dev->dev,
+				"device not accepting address %d, error %d\n",
+				dev->devnum, err);
+			goto fail;
+		}
+
+		wait_ms(10);	/* Let the SET_ADDRESS settle */
+
+		/* high and low speed devices don't need this... */
+		err = usb_get_device_descriptor(dev, 8);
+		if (err >= 8)
+			break;
+		wait_ms(100);
+	}
+
+	if (err < 8) {
+		dev_err(&dev->dev, "device descriptor read/8, error %d\n", err);
+		goto fail;
+	}
+	if (dev->speed == USB_SPEED_FULL) {
+		usb_disable_endpoint(dev, 0);
+		usb_endpoint_running(dev, 0, 1);
+		usb_endpoint_running(dev, 0, 0);
+		dev->epmaxpacketin [0] = dev->descriptor.bMaxPacketSize0;
+		dev->epmaxpacketout[0] = dev->descriptor.bMaxPacketSize0;
+	}
+
+	/* USB device state == addressed ... still not usable */
+
+	err = usb_get_device_descriptor(dev, sizeof(dev->descriptor));
+	if (err != (signed)sizeof(dev->descriptor)) {
+		dev_err(&dev->dev, "device descriptor read/all, error %d\n", err);
+		goto fail;
+	}
+
+	err = usb_get_configuration(dev);
+	if (err < 0) {
+		dev_err(&dev->dev, "can't read configurations, error %d\n",
+			err);
+		goto fail;
+	}
+
+	/* Tell the world! */
+	dev_dbg(&dev->dev, "new device strings: Mfr=%d, Product=%d, SerialNumber=%d\n",
+		dev->descriptor.iManufacturer, dev->descriptor.iProduct, dev->descriptor.iSerialNumber);
+
+#ifdef DEBUG
+	if (dev->descriptor.iProduct)
+		usb_show_string(dev, "Product", dev->descriptor.iProduct);
+	if (dev->descriptor.iManufacturer)
+		usb_show_string(dev, "Manufacturer", dev->descriptor.iManufacturer);
+	if (dev->descriptor.iSerialNumber)
+		usb_show_string(dev, "SerialNumber", dev->descriptor.iSerialNumber);
+#endif
+
+	/* put device-specific files into sysfs */
+	err = device_add (&dev->dev);
+	if (err) {
+		dev_err(&dev->dev, "can't device_add, error %d\n", err);
+		goto fail;
+	}
+	usb_create_driverfs_dev_files (dev);
+
+	/* choose and set the configuration. that registers the interfaces
+	 * with the driver core, and lets usb device drivers bind to them.
+	 * NOTE:  should interact with hub power budgeting.
+	 */
+	config = dev->config[0].desc.bConfigurationValue;
+	if (dev->descriptor.bNumConfigurations != 1) {
+		for (i = 0; i < dev->descriptor.bNumConfigurations; i++) {
+			struct usb_interface_descriptor	*desc;
+
+			/* heuristic:  Linux is more likely to have class
+			 * drivers, so avoid vendor-specific interfaces.
+			 */
+			desc = &dev->config[i].interface[0]
+					->altsetting->desc;
+			if (desc->bInterfaceClass == USB_CLASS_VENDOR_SPEC)
+				continue;
+			/* COMM/2/all is CDC ACM, except 0xff is MSFT RNDIS */
+			if (desc->bInterfaceClass == USB_CLASS_COMM
+					&& desc->bInterfaceSubClass == 2
+					&& desc->bInterfaceProtocol == 0xff)
+				continue;
+			config = dev->config[i].desc.bConfigurationValue;
+			break;
+		}
+		dev_info(&dev->dev,
+			"configuration #%d chosen from %d choices\n",
+			config,
+			dev->descriptor.bNumConfigurations);
+	}
+	err = usb_set_configuration(dev, config);
+	if (err) {
+		dev_err(&dev->dev, "can't set config #%d, error %d\n",
+			config, err);
+		device_del(&dev->dev);
+		goto fail;
+	}
+
+	/* USB device state == configured ... usable */
+
+	/* add a /proc/bus/usb entry */
+	usbfs_add_device(dev);
+
+	return 0;
+fail:
+	dev->state = USB_STATE_DEFAULT;
+	clear_bit(dev->devnum, dev->bus->devmap.devicemap);
+	dev->devnum = -1;
+	return err;
+}
+
+/**
  * usb_buffer_alloc - allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP
  * @dev: device the buffer will be used with
  * @size: requested buffer size
@@ -977,7 +1251,7 @@
 )
 {
 	if (!dev || !dev->bus || !dev->bus->op || !dev->bus->op->buffer_alloc)
-		return NULL;
+		return 0;
 	return dev->bus->op->buffer_alloc (dev->bus, size, mem_flags, dma);
 }
 
@@ -1029,7 +1303,7 @@
 			|| !urb->dev
 			|| !(bus = urb->dev->bus)
 			|| !(controller = bus->controller))
-		return NULL;
+		return 0;
 
 	if (controller->dma_mask) {
 		urb->transfer_dma = dma_map_single (controller,
@@ -1223,15 +1497,13 @@
 			usb_pipein (pipe) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 }
 
-static int usb_generic_suspend(struct device *dev, u32 state)
+static int usb_device_suspend(struct device *dev, u32 state)
 {
 	struct usb_interface *intf;
 	struct usb_driver *driver;
 
-	if (dev->driver == &usb_generic_driver)
-		return usb_suspend_device (to_usb_device(dev), state);
-
 	if ((dev->driver == NULL) ||
+	    (dev->driver == &usb_generic_driver) ||
 	    (dev->driver_data == &usb_generic_driver_data))
 		return 0;
 
@@ -1243,16 +1515,13 @@
 	return 0;
 }
 
-static int usb_generic_resume(struct device *dev)
+static int usb_device_resume(struct device *dev)
 {
 	struct usb_interface *intf;
 	struct usb_driver *driver;
 
-	/* devices resume through their hub */
-	if (dev->driver == &usb_generic_driver)
-		return usb_resume_device (to_usb_device(dev));
-
 	if ((dev->driver == NULL) ||
+	    (dev->driver == &usb_generic_driver) ||
 	    (dev->driver_data == &usb_generic_driver_data))
 		return 0;
 
@@ -1268,8 +1537,8 @@
 	.name =		"usb",
 	.match =	usb_device_match,
 	.hotplug =	usb_hotplug,
-	.suspend =	usb_generic_suspend,
-	.resume =	usb_generic_resume,
+	.suspend =	usb_device_suspend,
+	.resume =	usb_device_resume,
 };
 
 #ifndef MODULE
@@ -1298,43 +1567,20 @@
  */
 static int __init usb_init(void)
 {
-	int retval;
 	if (nousb) {
-		pr_info ("%s: USB support disabled\n", usbcore_name);
+		info("USB support disabled\n");
 		return 0;
 	}
 
-	retval = bus_register(&usb_bus_type);
-	if (retval) 
-		goto out;
-	retval = usb_host_init();
-	if (retval)
-		goto host_init_failed;
-	retval = usb_major_init();
-	if (retval)
-		goto major_init_failed;
-	retval = usbfs_init();
-	if (retval)
-		goto fs_init_failed;
-	retval = usb_hub_init();
-	if (retval)
-		goto hub_init_failed;
-
-	retval = driver_register(&usb_generic_driver);
-	if (!retval)
-		goto out;
+	bus_register(&usb_bus_type);
+	usb_host_init();
+	usb_major_init();
+	usbfs_init();
+	usb_hub_init();
 
-	usb_hub_cleanup();
-hub_init_failed:
-	usbfs_cleanup();
-fs_init_failed:
-	usb_major_cleanup();	
-major_init_failed:
-	usb_host_cleanup();
-host_init_failed:
-	bus_unregister(&usb_bus_type);
-out:
-	return retval;
+	driver_register(&usb_generic_driver);
+
+	return 0;
 }
 
 /*
@@ -1374,6 +1620,7 @@
 EXPORT_SYMBOL(usb_hub_tt_clear_buffer);
 
 EXPORT_SYMBOL(usb_driver_claim_interface);
+EXPORT_SYMBOL(usb_interface_claimed);
 EXPORT_SYMBOL(usb_driver_release_interface);
 EXPORT_SYMBOL(usb_match_id);
 EXPORT_SYMBOL(usb_find_interface);
diff -Naur linuxppc-2.6.9/drivers/usb/core/usb.h linuxppc-2.6.9-dream/drivers/usb/core/usb.h
--- linuxppc-2.6.9/drivers/usb/core/usb.h	2004-10-18 23:53:43.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/core/usb.h	2005-09-19 21:40:05.000000000 +0200
@@ -1,16 +1,13 @@
 /* Functions local to drivers/usb/core/ */
 
-extern void usb_create_sysfs_dev_files (struct usb_device *dev);
-extern void usb_remove_sysfs_dev_files (struct usb_device *dev);
-extern void usb_create_sysfs_intf_files (struct usb_interface *intf);
-extern void usb_remove_sysfs_intf_files (struct usb_interface *intf);
+extern void usb_create_driverfs_dev_files (struct usb_device *dev);
+extern void usb_create_driverfs_intf_files (struct usb_interface *intf);
 extern int usb_probe_interface (struct device *dev);
 extern int usb_unbind_interface (struct device *dev);
 
 extern void usb_disable_endpoint (struct usb_device *dev, unsigned int epaddr);
 extern void usb_disable_interface (struct usb_device *dev,
 		struct usb_interface *intf);
-extern void usb_release_interface_cache(struct kref *ref);
 extern void usb_disable_device (struct usb_device *dev, int skip_ep0);
 
 extern void usb_enable_endpoint (struct usb_device *dev,
@@ -20,10 +17,3 @@
 
 extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);
-extern int usb_set_configuration(struct usb_device *dev, int configuration);
-
-extern void usb_set_device_state(struct usb_device *udev,
-		enum usb_device_state new_state);
-
-/* for labeling diagnostics */
-extern const char *usbcore_name;
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/dummy_hcd.c linuxppc-2.6.9-dream/drivers/usb/gadget/dummy_hcd.c
--- linuxppc-2.6.9/drivers/usb/gadget/dummy_hcd.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/dummy_hcd.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1793 +0,0 @@
-/*
- * dummy_hcd.c -- Dummy/Loopback USB host and device emulator driver.
- *
- * Maintainer: Alan Stern <stern@rowland.harvard.edu>
- *
- * Copyright (C) 2003 David Brownell
- * Copyright (C) 2003, 2004 Alan Stern
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-/*
- * This exposes a device side "USB gadget" API, driven by requests to a
- * Linux-USB host controller driver.  USB traffic is simulated; there's
- * no need for USB hardware.  Use this with two other drivers:
- *
- *  - Gadget driver, responding to requests (slave);
- *  - Host-side device driver, as already familiar in Linux.
- *
- * Having this all in one kernel can help some stages of development,
- * bypassing some hardware (and driver) issues.  UML could help too.
- */
-
-#define DEBUG
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/smp_lock.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/list.h>
-#include <linux/interrupt.h>
-#include <linux/version.h>
-
-#include <linux/usb.h>
-#include <linux/usb_gadget.h>
-
-#include <asm/byteorder.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/system.h>
-#include <asm/unaligned.h>
-
-
-#include "../core/hcd.h"
-
-
-#define DRIVER_DESC	"USB Host+Gadget Emulator"
-#define DRIVER_VERSION	"14 Mar 2004"
-
-static const char	driver_name [] = "dummy_hcd";
-static const char	driver_desc [] = "USB Host+Gadget Emulator";
-
-static const char	gadget_name [] = "dummy_udc";
-
-MODULE_DESCRIPTION (DRIVER_DESC);
-MODULE_AUTHOR ("David Brownell");
-MODULE_LICENSE ("GPL");
-
-/*-------------------------------------------------------------------------*/
-
-/* gadget side driver data structres */
-struct dummy_ep {
-	struct list_head		queue;
-	unsigned long			last_io;	/* jiffies timestamp */
-	struct usb_gadget		*gadget;
-	const struct usb_endpoint_descriptor *desc;
-	struct usb_ep			ep;
-	unsigned			halted : 1;
-	unsigned			already_seen : 1;
-	unsigned			setup_stage : 1;
-};
-
-struct dummy_request {
-	struct list_head		queue;		/* ep's requests */
-	struct usb_request		req;
-};
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * Every device has ep0 for control requests, plus up to 30 more endpoints,
- * in one of two types:
- *
- *   - Configurable:  direction (in/out), type (bulk, iso, etc), and endpoint
- *     number can be changed.  Names like "ep-a" are used for this type.
- *
- *   - Fixed Function:  in other cases.  some characteristics may be mutable;
- *     that'd be hardware-specific.  Names like "ep12out-bulk" are used.
- *
- * Gadget drivers are responsible for not setting up conflicting endpoint
- * configurations, illegal or unsupported packet lengths, and so on.
- */
-
-static const char ep0name [] = "ep0";
-
-static const char *const ep_name [] = {
-	ep0name,				/* everyone has ep0 */
-
-	/* act like a net2280: high speed, six configurable endpoints */
-	"ep-a", "ep-b", "ep-c", "ep-d", "ep-e", "ep-f",
-
-	/* or like pxa250: fifteen fixed function endpoints */
-	"ep1in-bulk", "ep2out-bulk", "ep3in-iso", "ep4out-iso", "ep5in-int",
-	"ep6in-bulk", "ep7out-bulk", "ep8in-iso", "ep9out-iso", "ep10in-int",
-	"ep11in-bulk", "ep12out-bulk", "ep13in-iso", "ep14out-iso",
-		"ep15in-int",
-
-	/* or like sa1100: two fixed function endpoints */
-	"ep1out-bulk", "ep2in-bulk",
-};
-#define DUMMY_ENDPOINTS	(sizeof(ep_name)/sizeof(char *))
-
-#define FIFO_SIZE		64
-
-struct dummy {
-	spinlock_t			lock;
-
-	/*
-	 * SLAVE/GADGET side support
-	 */
-	struct dummy_ep			ep [DUMMY_ENDPOINTS];
-	int				address;
-	struct usb_gadget		gadget;
-	struct usb_gadget_driver	*driver;
-	struct dummy_request		fifo_req;
-	u8				fifo_buf [FIFO_SIZE];
-	u16				devstatus;
-
-	/*
-	 * MASTER/HOST side support
-	 */
-	struct usb_hcd			hcd;
-	struct platform_device		pdev;
-	struct timer_list		timer;
-	u32				port_status;
-	int				started;
-	struct completion		released;
-	unsigned			resuming:1;
-	unsigned long			re_timeout;
-
-	struct usb_device		*udev;
-};
-
-static struct dummy	*the_controller;
-
-static inline struct dummy *ep_to_dummy (struct dummy_ep *ep)
-{
-	return container_of (ep->gadget, struct dummy, gadget);
-}
-
-static inline struct dummy *gadget_dev_to_dummy (struct device *dev)
-{
-	return container_of (dev, struct dummy, gadget.dev);
-}
-
-/*
- * This "hardware" may look a bit odd in diagnostics since it's got both
- * host and device sides; and it binds different drivers to each side.
- */
-#define hardware	(&the_controller->pdev.dev)
-
-/*-------------------------------------------------------------------------*/
-
-static struct device_driver dummy_driver = {
-	.name		= (char *) driver_name,
-	.bus		= &platform_bus_type,
-};
-
-/*-------------------------------------------------------------------------*/
-
-/* SLAVE/GADGET SIDE DRIVER
- *
- * This only tracks gadget state.  All the work is done when the host
- * side tries some (emulated) i/o operation.  Real device controller
- * drivers would do real i/o using dma, fifos, irqs, timers, etc.
- */
-
-#define is_enabled() \
-	(the_controller->port_status & USB_PORT_STAT_ENABLE)
-
-static int
-dummy_enable (struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
-{
-	struct dummy		*dum;
-	struct dummy_ep		*ep;
-	unsigned		max;
-	int			retval;
-
-	ep = container_of (_ep, struct dummy_ep, ep);
-	if (!_ep || !desc || ep->desc || _ep->name == ep0name
-			|| desc->bDescriptorType != USB_DT_ENDPOINT)
-	if (!the_controller->driver || !is_enabled ())
-		return -ESHUTDOWN;
-	max = desc->wMaxPacketSize & 0x3ff;
-
-	/* drivers must not request bad settings, since lower levels
-	 * (hardware or its drivers) may not check.  some endpoints
-	 * can't do iso, many have maxpacket limitations, etc.
-	 *
-	 * since this "hardware" driver is here to help debugging, we
-	 * have some extra sanity checks.  (there could be more though,
-	 * especially for "ep9out" style fixed function ones.)
-	 */
-	dum = container_of (ep->gadget, struct dummy, gadget);
-	retval = -EINVAL;
-	switch (desc->bmAttributes & 0x03) {
-	case USB_ENDPOINT_XFER_BULK:
-		if (strstr (ep->ep.name, "-iso")
-				|| strstr (ep->ep.name, "-int")) {
-			goto done;
-		}
-		switch (dum->gadget.speed) {
-		case USB_SPEED_HIGH:
-			if (max == 512)
-				break;
-			/* conserve return statements */
-		default:
-			switch (max) {
-			case 8: case 16: case 32: case 64:
-				/* we'll fake any legal size */
-				break;
-			default:
-		case USB_SPEED_LOW:
-				goto done;
-			}
-		}
-		break;
-	case USB_ENDPOINT_XFER_INT:
-		if (strstr (ep->ep.name, "-iso")) /* bulk is ok */
-			goto done;
-		/* real hardware might not handle all packet sizes */
-		switch (dum->gadget.speed) {
-		case USB_SPEED_HIGH:
-			if (max <= 1024)
-				break;
-			/* save a return statement */
-		case USB_SPEED_FULL:
-			if (max <= 64)
-				break;
-			/* save a return statement */
-		default:
-			if (max <= 8)
-				break;
-			goto done;
-		}
-		break;
-	case USB_ENDPOINT_XFER_ISOC:
-		if (strstr (ep->ep.name, "-bulk")
-				|| strstr (ep->ep.name, "-int"))
-			goto done;
-		/* real hardware might not handle all packet sizes */
-		switch (dum->gadget.speed) {
-		case USB_SPEED_HIGH:
-			if (max <= 1024)
-				break;
-			/* save a return statement */
-		case USB_SPEED_FULL:
-			if (max <= 1023)
-				break;
-			/* save a return statement */
-		default:
-			goto done;
-		}
-		break;
-	default:
-		/* few chips support control except on ep0 */
-		goto done;
-	}
-
-	_ep->maxpacket = max;
-	ep->desc = desc;
-
-	dev_dbg (hardware, "enabled %s (ep%d%s-%s) maxpacket %d\n",
-		_ep->name,
-		desc->bEndpointAddress & 0x0f,
-		(desc->bEndpointAddress & USB_DIR_IN) ? "in" : "out",
-		({ char *val;
-		 switch (desc->bmAttributes & 0x03) {
-		 case USB_ENDPOINT_XFER_BULK: val = "bulk"; break;
-		 case USB_ENDPOINT_XFER_ISOC: val = "iso"; break;
-		 case USB_ENDPOINT_XFER_INT: val = "intr"; break;
-		 default: val = "ctrl"; break;
-		 }; val; }),
-		max);
-
-	/* at this point real hardware should be NAKing transfers
-	 * to that endpoint, until a buffer is queued to it.
-	 */
-	retval = 0;
-done:
-	return retval;
-}
-
-/* called with spinlock held */
-static void nuke (struct dummy *dum, struct dummy_ep *ep)
-{
-	while (!list_empty (&ep->queue)) {
-		struct dummy_request	*req;
-
-		req = list_entry (ep->queue.next, struct dummy_request, queue);
-		list_del_init (&req->queue);
-		req->req.status = -ESHUTDOWN;
-
-		spin_unlock (&dum->lock);
-		req->req.complete (&ep->ep, &req->req);
-		spin_lock (&dum->lock);
-	}
-}
-
-static int dummy_disable (struct usb_ep *_ep)
-{
-	struct dummy_ep		*ep;
-	struct dummy		*dum;
-	unsigned long		flags;
-	int			retval;
-
-	ep = container_of (_ep, struct dummy_ep, ep);
-	if (!_ep || !ep->desc || _ep->name == ep0name)
-		return -EINVAL;
-	dum = ep_to_dummy (ep);
-
-	spin_lock_irqsave (&dum->lock, flags);
-	ep->desc = 0;
-	retval = 0;
-	nuke (dum, ep);
-	spin_unlock_irqrestore (&dum->lock, flags);
-
-	dev_dbg (hardware, "disabled %s\n", _ep->name);
-	return retval;
-}
-
-static struct usb_request *
-dummy_alloc_request (struct usb_ep *_ep, int mem_flags)
-{
-	struct dummy_ep		*ep;
-	struct dummy_request	*req;
-
-	ep = container_of (_ep, struct dummy_ep, ep);
-	if (!_ep)
-		return 0;
-
-	req = kmalloc (sizeof *req, mem_flags);
-	if (!req)
-		return 0;
-	memset (req, 0, sizeof *req);
-	INIT_LIST_HEAD (&req->queue);
-	return &req->req;
-}
-
-static void
-dummy_free_request (struct usb_ep *_ep, struct usb_request *_req)
-{
-	struct dummy_ep		*ep;
-	struct dummy_request	*req;
-
-	ep = container_of (_ep, struct dummy_ep, ep);
-	if (!ep || !_req || (!ep->desc && _ep->name != ep0name))
-		return;
-
-	req = container_of (_req, struct dummy_request, req);
-	WARN_ON (!list_empty (&req->queue));
-	kfree (req);
-}
-
-static void *
-dummy_alloc_buffer (
-	struct usb_ep *_ep,
-	unsigned bytes,
-	dma_addr_t *dma,
-	int mem_flags
-) {
-	char *retval;
-
-	if (!the_controller->driver)
-		return 0;
-	retval = kmalloc (bytes, mem_flags);
-	*dma = (dma_addr_t) retval;
-	return retval;
-}
-
-static void
-dummy_free_buffer (
-	struct usb_ep *_ep,
-	void *buf,
-	dma_addr_t dma,
-	unsigned bytes
-) {
-	if (bytes)
-		kfree (buf);
-}
-
-static void
-fifo_complete (struct usb_ep *ep, struct usb_request *req)
-{
-#if 0
-	dev_dbg (hardware, "fifo_complete: %d\n", req->status);
-#endif
-}
-
-static int
-dummy_queue (struct usb_ep *_ep, struct usb_request *_req, int mem_flags)
-{
-	struct dummy_ep		*ep;
-	struct dummy_request	*req;
-	struct dummy		*dum;
-	unsigned long		flags;
-
-	req = container_of (_req, struct dummy_request, req);
-	if (!_req || !list_empty (&req->queue) || !_req->complete)
-		return -EINVAL;
-
-	ep = container_of (_ep, struct dummy_ep, ep);
-	if (!_ep || (!ep->desc && _ep->name != ep0name))
-		return -EINVAL;
-
-	if (!the_controller->driver || !is_enabled ())
-		return -ESHUTDOWN;
-
-	dum = container_of (ep->gadget, struct dummy, gadget);
-
-#if 0
-	dev_dbg (hardware, "ep %p queue req %p to %s, len %d buf %p\n",
-			ep, _req, _ep->name, _req->length, _req->buf);
-#endif
-
-	_req->status = -EINPROGRESS;
-	_req->actual = 0;
-	spin_lock_irqsave (&dum->lock, flags);
-
-	/* implement an emulated single-request FIFO */
-	if (ep->desc && (ep->desc->bEndpointAddress & USB_DIR_IN) &&
-			list_empty (&dum->fifo_req.queue) &&
-			list_empty (&ep->queue) &&
-			_req->length <= FIFO_SIZE) {
-		req = &dum->fifo_req;
-		req->req = *_req;
-		req->req.buf = dum->fifo_buf;
-		memcpy (dum->fifo_buf, _req->buf, _req->length);
-		req->req.context = dum;
-		req->req.complete = fifo_complete;
-
-		spin_unlock (&dum->lock);
-		_req->actual = _req->length;
-		_req->status = 0;
-		_req->complete (_ep, _req);
-		spin_lock (&dum->lock);
-	}
-	list_add_tail (&req->queue, &ep->queue);
-	spin_unlock_irqrestore (&dum->lock, flags);
-
-	/* real hardware would likely enable transfers here, in case
-	 * it'd been left NAKing.
-	 */
-	return 0;
-}
-
-static int dummy_dequeue (struct usb_ep *_ep, struct usb_request *_req)
-{
-	struct dummy_ep		*ep;
-	struct dummy		*dum;
-	int			retval = -EINVAL;
-	unsigned long		flags;
-	struct dummy_request	*req = 0;
-
-	if (!the_controller->driver)
-		return -ESHUTDOWN;
-
-	if (!_ep || !_req)
-		return retval;
-	ep = container_of (_ep, struct dummy_ep, ep);
-	dum = container_of (ep->gadget, struct dummy, gadget);
-
-	spin_lock_irqsave (&dum->lock, flags);
-	list_for_each_entry (req, &ep->queue, queue) {
-		if (&req->req == _req) {
-			list_del_init (&req->queue);
-			_req->status = -ECONNRESET;
-			retval = 0;
-			break;
-		}
-	}
-	spin_unlock_irqrestore (&dum->lock, flags);
-
-	if (retval == 0) {
-		dev_dbg (hardware, "dequeued req %p from %s, len %d buf %p\n",
-				req, _ep->name, _req->length, _req->buf);
-
-		_req->complete (_ep, _req);
-	}
-	return retval;
-}
-
-static int
-dummy_set_halt (struct usb_ep *_ep, int value)
-{
-	struct dummy_ep		*ep;
-
-	if (!_ep)
-		return -EINVAL;
-	if (!the_controller->driver)
-		return -ESHUTDOWN;
-	ep = container_of (_ep, struct dummy_ep, ep);
-	if (!value)
-		ep->halted = 0;
-	else if (ep->desc && (ep->desc->bEndpointAddress & USB_DIR_IN) &&
-			!list_empty (&ep->queue))
-		return -EAGAIN;
-	else
-		ep->halted = 1;
-	/* FIXME clear emulated data toggle too */
-	return 0;
-}
-
-static const struct usb_ep_ops dummy_ep_ops = {
-	.enable		= dummy_enable,
-	.disable	= dummy_disable,
-
-	.alloc_request	= dummy_alloc_request,
-	.free_request	= dummy_free_request,
-
-	.alloc_buffer	= dummy_alloc_buffer,
-	.free_buffer	= dummy_free_buffer,
-	/* map, unmap, ... eventually hook the "generic" dma calls */
-
-	.queue		= dummy_queue,
-	.dequeue	= dummy_dequeue,
-
-	.set_halt	= dummy_set_halt,
-};
-
-/*-------------------------------------------------------------------------*/
-
-/* there are both host and device side versions of this call ... */
-static int dummy_g_get_frame (struct usb_gadget *_gadget)
-{
-	struct timeval	tv;
-
-	do_gettimeofday (&tv);
-	return tv.tv_usec / 1000;
-}
-
-static int dummy_wakeup (struct usb_gadget *_gadget)
-{
-	struct dummy	*dum;
-
-	dum = container_of (_gadget, struct dummy, gadget);
-	if ((dum->devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP)) == 0
-			|| !(dum->port_status & (1 << USB_PORT_FEAT_SUSPEND)))
-		return -EINVAL;
-
-	/* hub notices our request, issues downstream resume, etc */
-	dum->resuming = 1;
-	dum->port_status |= (1 << USB_PORT_FEAT_C_SUSPEND);
-	return 0;
-}
-
-static int dummy_set_selfpowered (struct usb_gadget *_gadget, int value)
-{
-	struct dummy	*dum;
-
-	dum = container_of (_gadget, struct dummy, gadget);
-	if (value)
-		dum->devstatus |= (1 << USB_DEVICE_SELF_POWERED);
-	else
-		dum->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);
-	return 0;
-}
-
-static const struct usb_gadget_ops dummy_ops = {
-	.get_frame	= dummy_g_get_frame,
-	.wakeup		= dummy_wakeup,
-	.set_selfpowered = dummy_set_selfpowered,
-};
-
-/*-------------------------------------------------------------------------*/
-
-/* "function" sysfs attribute */
-static ssize_t
-show_function (struct device *dev, char *buf)
-{
-	struct dummy	*dum = gadget_dev_to_dummy (dev);
-
-	if (!dum->driver || !dum->driver->function)
-		return 0;
-	return scnprintf (buf, PAGE_SIZE, "%s\n", dum->driver->function);
-}
-DEVICE_ATTR (function, S_IRUGO, show_function, NULL);
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * Driver registration/unregistration.
- *
- * This is basically hardware-specific; there's usually only one real USB
- * device (not host) controller since that's how USB devices are intended
- * to work.  So most implementations of these api calls will rely on the
- * fact that only one driver will ever bind to the hardware.  But curious
- * hardware can be built with discrete components, so the gadget API doesn't
- * require that assumption.
- *
- * For this emulator, it might be convenient to create a usb slave device
- * for each driver that registers:  just add to a big root hub.
- */
-
-static void
-dummy_udc_release (struct device *dev)
-{
-	struct dummy	*dum = gadget_dev_to_dummy (dev);
-
-	complete (&dum->released);
-}
-
-static void
-dummy_hc_release (struct device *dev)
-{
-	struct dummy	*dum = dev_get_drvdata (dev);
-
-	complete (&dum->released);
-}
-
-static int
-dummy_register_udc (struct dummy *dum)
-{
-	int		rc;
-
-	strcpy (dum->gadget.dev.bus_id, "udc");
-	dum->gadget.dev.parent = &dum->pdev.dev;
-	dum->gadget.dev.release = dummy_udc_release;
-
-	rc = device_register (&dum->gadget.dev);
-	if (rc == 0)
-		device_create_file (&dum->gadget.dev, &dev_attr_function);
-	return rc;
-}
-
-static void
-dummy_unregister_udc (struct dummy *dum)
-{
-	device_remove_file (&dum->gadget.dev, &dev_attr_function);
-	init_completion (&dum->released);
-	device_unregister (&dum->gadget.dev);
-	wait_for_completion (&dum->released);
-}
-
-int
-usb_gadget_register_driver (struct usb_gadget_driver *driver)
-{
-	struct dummy	*dum = the_controller;
-	int		retval, i;
-
-	if (!dum)
-		return -EINVAL;
-	if (dum->driver)
-		return -EBUSY;
-	if (!driver->bind || !driver->unbind || !driver->setup
-			|| driver->speed == USB_SPEED_UNKNOWN)
-		return -EINVAL;
-
-	/*
-	 * SLAVE side init ... the layer above hardware, which
-	 * can't enumerate without help from the driver we're binding.
-	 */
-	dum->gadget.name = gadget_name;
-	dum->gadget.ops = &dummy_ops;
-	dum->gadget.is_dualspeed = 1;
-
-	dum->devstatus = 0;
-	dum->resuming = 0;
-
-	INIT_LIST_HEAD (&dum->gadget.ep_list);
-	for (i = 0; i < DUMMY_ENDPOINTS; i++) {
-		struct dummy_ep	*ep = &dum->ep [i];
-
-		if (!ep_name [i])
-			break;
-		ep->ep.name = ep_name [i];
-		ep->ep.ops = &dummy_ep_ops;
-		list_add_tail (&ep->ep.ep_list, &dum->gadget.ep_list);
-		ep->halted = ep->already_seen = ep->setup_stage = 0;
-		ep->ep.maxpacket = ~0;
-		ep->last_io = jiffies;
-		ep->gadget = &dum->gadget;
-		ep->desc = 0;
-		INIT_LIST_HEAD (&ep->queue);
-	}
-
-	dum->gadget.ep0 = &dum->ep [0].ep;
-	dum->ep [0].ep.maxpacket = 64;
-	list_del_init (&dum->ep [0].ep.ep_list);
-	INIT_LIST_HEAD(&dum->fifo_req.queue);
-
-	dum->driver = driver;
-	dum->gadget.dev.driver = &driver->driver;
-	dev_dbg (hardware, "binding gadget driver '%s'\n", driver->driver.name);
-	if ((retval = driver->bind (&dum->gadget)) != 0) {
-		dum->driver = 0;
-		dum->gadget.dev.driver = 0;
-		return retval;
-	}
-
-	// FIXME: Check these calls for errors and re-order
-	driver->driver.bus = dum->pdev.dev.bus;
-	driver_register (&driver->driver);
-
-	device_bind_driver (&dum->gadget.dev);
-
-	/* khubd will enumerate this in a while */
-	dum->port_status |= USB_PORT_STAT_CONNECTION
-		| (1 << USB_PORT_FEAT_C_CONNECTION);
-	return 0;
-}
-EXPORT_SYMBOL (usb_gadget_register_driver);
-
-/* caller must hold lock */
-static void
-stop_activity (struct dummy *dum, struct usb_gadget_driver *driver)
-{
-	struct dummy_ep	*ep;
-
-	/* prevent any more requests */
-	dum->address = 0;
-
-	/* The timer is left running so that outstanding URBs can fail */
-
-	/* nuke any pending requests first, so driver i/o is quiesced */
-	list_for_each_entry (ep, &dum->gadget.ep_list, ep.ep_list)
-		nuke (dum, ep);
-
-	/* driver now does any non-usb quiescing necessary */
-	if (driver) {
-		spin_unlock (&dum->lock);
-		driver->disconnect (&dum->gadget);
-		spin_lock (&dum->lock);
-	}
-}
-
-int
-usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
-{
-	struct dummy	*dum = the_controller;
-	unsigned long	flags;
-
-	if (!dum)
-		return -ENODEV;
-	if (!driver || driver != dum->driver)
-		return -EINVAL;
-
-	dev_dbg (hardware, "unregister gadget driver '%s'\n",
-			driver->driver.name);
-
-	spin_lock_irqsave (&dum->lock, flags);
-	stop_activity (dum, driver);
-	dum->port_status &= ~USB_PORT_STAT_CONNECTION;
-	dum->port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
-	spin_unlock_irqrestore (&dum->lock, flags);
-
-	driver->unbind (&dum->gadget);
-	dum->driver = 0;
-
-	device_release_driver (&dum->gadget.dev);
-
-	driver_unregister (&driver->driver);
-
-	return 0;
-}
-EXPORT_SYMBOL (usb_gadget_unregister_driver);
-
-#undef is_enabled
-
-int net2280_set_fifo_mode (struct usb_gadget *gadget, int mode)
-{
-	return -ENOSYS;
-}
-EXPORT_SYMBOL (net2280_set_fifo_mode);
-
-/*-------------------------------------------------------------------------*/
-
-/* MASTER/HOST SIDE DRIVER
- *
- * this uses the hcd framework to hook up to host side drivers.
- * its root hub will only have one device, otherwise it acts like
- * a normal host controller.
- *
- * when urbs are queued, they're just stuck on a list that we
- * scan in a timer callback.  that callback connects writes from
- * the host with reads from the device, and so on, based on the
- * usb 2.0 rules.
- */
-
-static int dummy_urb_enqueue (
-	struct usb_hcd	*hcd,
-	struct urb	*urb,
-	int		mem_flags
-) {
-	struct dummy	*dum;
-	unsigned long	flags;
-
-	/* patch to usb_sg_init() is in 2.5.60 */
-	BUG_ON (!urb->transfer_buffer && urb->transfer_buffer_length);
-
-	dum = container_of (hcd, struct dummy, hcd);
-	spin_lock_irqsave (&dum->lock, flags);
-
-	if (!dum->udev) {
-		dum->udev = urb->dev;
-		usb_get_dev (dum->udev);
-	} else if (unlikely (dum->udev != urb->dev))
-		dev_err (hardware, "usb_device address has changed!\n");
-
-	urb->hcpriv = dum;
-	if (usb_pipetype (urb->pipe) == PIPE_CONTROL)
-		urb->error_count = 1;		/* mark as a new urb */
-
-	/* kick the scheduler, it'll do the rest */
-	if (!timer_pending (&dum->timer))
-		mod_timer (&dum->timer, jiffies + 1);
-
-	spin_unlock_irqrestore (&dum->lock, flags);
-	return 0;
-}
-
-static int dummy_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
-{
-	/* giveback happens automatically in timer callback */
-	return 0;
-}
-
-static void maybe_set_status (struct urb *urb, int status)
-{
-	spin_lock (&urb->lock);
-	if (urb->status == -EINPROGRESS)
-		urb->status = status;
-	spin_unlock (&urb->lock);
-}
-
-/* transfer up to a frame's worth; caller must own lock */
-static int
-transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
-{
-	struct dummy_request	*req;
-
-top:
-	/* if there's no request queued, the device is NAKing; return */
-	list_for_each_entry (req, &ep->queue, queue) {
-		unsigned	host_len, dev_len, len;
-		int		is_short, to_host;
-		int		rescan = 0;
-
-		/* 1..N packets of ep->ep.maxpacket each ... the last one
-		 * may be short (including zero length).
-		 *
-		 * writer can send a zlp explicitly (length 0) or implicitly
-		 * (length mod maxpacket zero, and 'zero' flag); they always
-		 * terminate reads.
-		 */
-		host_len = urb->transfer_buffer_length - urb->actual_length;
-		dev_len = req->req.length - req->req.actual;
-		len = min (host_len, dev_len);
-
-		/* FIXME update emulated data toggle too */
-
-		to_host = usb_pipein (urb->pipe);
-		if (unlikely (len == 0))
-			is_short = 1;
-		else {
-			char		*ubuf, *rbuf;
-
-			/* not enough bandwidth left? */
-			if (limit < ep->ep.maxpacket && limit < len)
-				break;
-			len = min (len, (unsigned) limit);
-			if (len == 0)
-				break;
-
-			/* use an extra pass for the final short packet */
-			if (len > ep->ep.maxpacket) {
-				rescan = 1;
-				len -= (len % ep->ep.maxpacket);
-			}
-			is_short = (len % ep->ep.maxpacket) != 0;
-
-			/* else transfer packet(s) */
-			ubuf = urb->transfer_buffer + urb->actual_length;
-			rbuf = req->req.buf + req->req.actual;
-			if (to_host)
-				memcpy (ubuf, rbuf, len);
-			else
-				memcpy (rbuf, ubuf, len);
-			ep->last_io = jiffies;
-
-			limit -= len;
-			urb->actual_length += len;
-			req->req.actual += len;
-		}
-
-		/* short packets terminate, maybe with overflow/underflow.
-		 * it's only really an error to write too much.
-		 *
-		 * partially filling a buffer optionally blocks queue advances
-		 * (so completion handlers can clean up the queue) but we don't
-		 * need to emulate such data-in-flight.  so we only show part
-		 * of the URB_SHORT_NOT_OK effect: completion status.
-		 */
-		if (is_short) {
-			if (host_len == dev_len) {
-				req->req.status = 0;
-				maybe_set_status (urb, 0);
-			} else if (to_host) {
-				req->req.status = 0;
-				if (dev_len > host_len)
-					maybe_set_status (urb, -EOVERFLOW);
-				else
-					maybe_set_status (urb,
-						(urb->transfer_flags
-							& URB_SHORT_NOT_OK)
-						? -EREMOTEIO : 0);
-			} else if (!to_host) {
-				maybe_set_status (urb, 0);
-				if (host_len > dev_len)
-					req->req.status = -EOVERFLOW;
-				else
-					req->req.status = 0;
-			}
-
-		/* many requests terminate without a short packet */
-		} else {
-			if (req->req.length == req->req.actual
-					&& !req->req.zero)
-				req->req.status = 0;
-			if (urb->transfer_buffer_length == urb->actual_length
-					&& !(urb->transfer_flags
-						& URB_ZERO_PACKET)) {
-				maybe_set_status (urb, 0);
-			}
-		}
-
-		/* device side completion --> continuable */
-		if (req->req.status != -EINPROGRESS) {
-			list_del_init (&req->queue);
-
-			spin_unlock (&dum->lock);
-			req->req.complete (&ep->ep, &req->req);
-			spin_lock (&dum->lock);
-
-			/* requests might have been unlinked... */
-			rescan = 1;
-		}
-
-		/* host side completion --> terminate */
-		if (urb->status != -EINPROGRESS)
-			break;
-
-		/* rescan to continue with any other queued i/o */
-		if (rescan)
-			goto top;
-	}
-	return limit;
-}
-
-static int periodic_bytes (struct dummy *dum, struct dummy_ep *ep)
-{
-	int	limit = ep->ep.maxpacket;
-
-	if (dum->gadget.speed == USB_SPEED_HIGH) {
-		int	tmp;
-
-		/* high bandwidth mode */
-		tmp = ep->desc->wMaxPacketSize;
-		tmp = le16_to_cpu (tmp);
-		tmp = (tmp >> 11) & 0x03;
-		tmp *= 8 /* applies to entire frame */;
-		limit += limit * tmp;
-	}
-	return limit;
-}
-
-#define is_active(dum)	((dum->port_status & \
-		(USB_PORT_STAT_CONNECTION | USB_PORT_STAT_ENABLE | \
-			USB_PORT_STAT_SUSPEND)) \
-		== (USB_PORT_STAT_CONNECTION | USB_PORT_STAT_ENABLE))
-
-static struct dummy_ep *find_endpoint (struct dummy *dum, u8 address)
-{
-	int		i;
-
-	if (!is_active (dum))
-		return NULL;
-	if ((address & ~USB_DIR_IN) == 0)
-		return &dum->ep [0];
-	for (i = 1; i < DUMMY_ENDPOINTS; i++) {
-		struct dummy_ep	*ep = &dum->ep [i];
-
-		if (!ep->desc)
-			continue;
-		if (ep->desc->bEndpointAddress == address)
-			return ep;
-	}
-	return NULL;
-}
-
-#undef is_active
-
-#define Dev_Request	(USB_TYPE_STANDARD | USB_RECIP_DEVICE)
-#define Dev_InRequest	(Dev_Request | USB_DIR_IN)
-#define Intf_Request	(USB_TYPE_STANDARD | USB_RECIP_INTERFACE)
-#define Intf_InRequest	(Intf_Request | USB_DIR_IN)
-#define Ep_Request	(USB_TYPE_STANDARD | USB_RECIP_ENDPOINT)
-#define Ep_InRequest	(Ep_Request | USB_DIR_IN)
-
-/* drive both sides of the transfers; looks like irq handlers to
- * both drivers except the callbacks aren't in_irq().
- */
-static void dummy_timer (unsigned long _dum)
-{
-	struct dummy		*dum = (struct dummy *) _dum;
-	struct hcd_dev		*hdev;
-	struct list_head	*entry, *tmp;
-	unsigned long		flags;
-	int			limit, total;
-	int			i;
-
-	/* simplistic model for one frame's bandwidth */
-	switch (dum->gadget.speed) {
-	case USB_SPEED_LOW:
-		total = 8/*bytes*/ * 12/*packets*/;
-		break;
-	case USB_SPEED_FULL:
-		total = 64/*bytes*/ * 19/*packets*/;
-		break;
-	case USB_SPEED_HIGH:
-		total = 512/*bytes*/ * 13/*packets*/ * 8/*uframes*/;
-		break;
-	default:
-		dev_err (hardware, "bogus device speed\n");
-		return;
-	}
-
-	/* FIXME if HZ != 1000 this will probably misbehave ... */
-
-	/* look at each urb queued by the host side driver */
-	spin_lock_irqsave (&dum->lock, flags);
-
-	if (!dum->udev) {
-		dev_err (hardware, "timer fired with no URBs pending?\n");
-		spin_unlock_irqrestore (&dum->lock, flags);
-		return;
-	}
-	hdev = dum->udev->hcpriv;
-
-	for (i = 0; i < DUMMY_ENDPOINTS; i++) {
-		if (!ep_name [i])
-			break;
-		dum->ep [i].already_seen = 0;
-	}
-
-restart:
-	list_for_each_safe (entry, tmp, &hdev->urb_list) {
-		struct urb		*urb;
-		struct dummy_request	*req;
-		u8			address;
-		struct dummy_ep		*ep = 0;
-		int			type;
-
-		urb = list_entry (entry, struct urb, urb_list);
-		if (urb->status != -EINPROGRESS) {
-			/* likely it was just unlinked */
-			goto return_urb;
-		}
-		type = usb_pipetype (urb->pipe);
-
-		/* used up this frame's non-periodic bandwidth?
-		 * FIXME there's infinite bandwidth for control and
-		 * periodic transfers ... unrealistic.
-		 */
-		if (total <= 0 && type == PIPE_BULK)
-			continue;
-
-		/* find the gadget's ep for this request (if configured) */
-		address = usb_pipeendpoint (urb->pipe);
-		if (usb_pipein (urb->pipe))
-			address |= USB_DIR_IN;
-		ep = find_endpoint(dum, address);
-		if (!ep) {
-			/* set_configuration() disagreement */
-			dev_err (hardware,
-				"no ep configured for urb %p\n",
-				urb);
-			maybe_set_status (urb, -ETIMEDOUT);
-			goto return_urb;
-		}
-
-		if (ep->already_seen)
-			continue;
-		ep->already_seen = 1;
-		if (ep == &dum->ep [0] && urb->error_count) {
-			ep->setup_stage = 1;	/* a new urb */
-			urb->error_count = 0;
-		}
-		if (ep->halted && !ep->setup_stage) {
-			/* NOTE: must not be iso! */
-			dev_dbg (hardware, "ep %s halted, urb %p\n",
-					ep->ep.name, urb);
-			maybe_set_status (urb, -EPIPE);
-			goto return_urb;
-		}
-		/* FIXME make sure both ends agree on maxpacket */
-
-		/* handle control requests */
-		if (ep == &dum->ep [0] && ep->setup_stage) {
-			struct usb_ctrlrequest		setup;
-			int				value = 1;
-			struct dummy_ep			*ep2;
-
-			setup = *(struct usb_ctrlrequest*) urb->setup_packet;
-			le16_to_cpus (&setup.wIndex);
-			le16_to_cpus (&setup.wValue);
-			le16_to_cpus (&setup.wLength);
-			if (setup.wLength != urb->transfer_buffer_length) {
-				maybe_set_status (urb, -EOVERFLOW);
-				goto return_urb;
-			}
-
-			/* paranoia, in case of stale queued data */
-			list_for_each_entry (req, &ep->queue, queue) {
-				list_del_init (&req->queue);
-				req->req.status = -EOVERFLOW;
-				dev_dbg (hardware, "stale req = %p\n", req);
-
-				spin_unlock (&dum->lock);
-				req->req.complete (&ep->ep, &req->req);
-				spin_lock (&dum->lock);
-				ep->already_seen = 0;
-				goto restart;
-			}
-
-			/* gadget driver never sees set_address or operations
-			 * on standard feature flags.  some hardware doesn't
-			 * even expose them.
-			 */
-			ep->last_io = jiffies;
-			ep->setup_stage = 0;
-			ep->halted = 0;
-			switch (setup.bRequest) {
-			case USB_REQ_SET_ADDRESS:
-				if (setup.bRequestType != Dev_Request)
-					break;
-				dum->address = setup.wValue;
-				maybe_set_status (urb, 0);
-				dev_dbg (hardware, "set_address = %d\n",
-						setup.wValue);
-				value = 0;
-				break;
-			case USB_REQ_SET_FEATURE:
-				if (setup.bRequestType == Dev_Request) {
-					value = 0;
-					switch (setup.wValue) {
-					case USB_DEVICE_REMOTE_WAKEUP:
-						break;
-					default:
-						value = -EOPNOTSUPP;
-					}
-					if (value == 0) {
-						dum->devstatus |=
-							(1 << setup.wValue);
-						maybe_set_status (urb, 0);
-					}
-
-				} else if (setup.bRequestType == Ep_Request) {
-					// endpoint halt
-					ep2 = find_endpoint (dum,
-							setup.wIndex);
-					if (!ep2) {
-						value = -EOPNOTSUPP;
-						break;
-					}
-					ep2->halted = 1;
-					value = 0;
-					maybe_set_status (urb, 0);
-				}
-				break;
-			case USB_REQ_CLEAR_FEATURE:
-				if (setup.bRequestType == Dev_Request) {
-					switch (setup.wValue) {
-					case USB_DEVICE_REMOTE_WAKEUP:
-						dum->devstatus &= ~(1 <<
-							USB_DEVICE_REMOTE_WAKEUP);
-						value = 0;
-						maybe_set_status (urb, 0);
-						break;
-					default:
-						value = -EOPNOTSUPP;
-						break;
-					}
-				} else if (setup.bRequestType == Ep_Request) {
-					// endpoint halt
-					ep2 = find_endpoint (dum,
-							setup.wIndex);
-					if (!ep2) {
-						value = -EOPNOTSUPP;
-						break;
-					}
-					ep2->halted = 0;
-					value = 0;
-					maybe_set_status (urb, 0);
-				}
-				break;
-			case USB_REQ_GET_STATUS:
-				if (setup.bRequestType == Dev_InRequest
-						|| setup.bRequestType
-							== Intf_InRequest
-						|| setup.bRequestType
-							== Ep_InRequest
-						) {
-					char *buf;
-
-					// device: remote wakeup, selfpowered
-					// interface: nothing
-					// endpoint: halt
-					buf = (char *)urb->transfer_buffer;
-					if (urb->transfer_buffer_length > 0) {
-						if (setup.bRequestType ==
-								Ep_InRequest) {
-	ep2 = find_endpoint (dum, setup.wIndex);
-	if (!ep2) {
-		value = -EOPNOTSUPP;
-		break;
-	}
-	buf [0] = ep2->halted;
-						} else if (setup.bRequestType ==
-								Dev_InRequest) {
-							buf [0] = (u8)
-								dum->devstatus;
-						} else
-							buf [0] = 0;
-					}
-					if (urb->transfer_buffer_length > 1)
-						buf [1] = 0;
-					urb->actual_length = min (2,
-						urb->transfer_buffer_length);
-					value = 0;
-					maybe_set_status (urb, 0);
-				}
-				break;
-			}
-
-			/* gadget driver handles all other requests.  block
-			 * until setup() returns; no reentrancy issues etc.
-			 */
-			if (value > 0) {
-				spin_unlock (&dum->lock);
-				value = dum->driver->setup (&dum->gadget,
-						&setup);
-				spin_lock (&dum->lock);
-
-				if (value >= 0) {
-					/* no delays (max 64KB data stage) */
-					limit = 64*1024;
-					goto treat_control_like_bulk;
-				}
-				/* error, see below */
-			}
-
-			if (value < 0) {
-				if (value != -EOPNOTSUPP)
-					dev_dbg (hardware,
-						"setup --> %d\n",
-						value);
-				maybe_set_status (urb, -EPIPE);
-				urb->actual_length = 0;
-			}
-
-			goto return_urb;
-		}
-
-		/* non-control requests */
-		limit = total;
-		switch (usb_pipetype (urb->pipe)) {
-		case PIPE_ISOCHRONOUS:
-			/* FIXME is it urb->interval since the last xfer?
-			 * use urb->iso_frame_desc[i].
-			 * complete whether or not ep has requests queued.
-			 * report random errors, to debug drivers.
-			 */
-			limit = max (limit, periodic_bytes (dum, ep));
-			maybe_set_status (urb, -ENOSYS);
-			break;
-
-		case PIPE_INTERRUPT:
-			/* FIXME is it urb->interval since the last xfer?
-			 * this almost certainly polls too fast.
-			 */
-			limit = max (limit, periodic_bytes (dum, ep));
-			/* FALLTHROUGH */
-
-		// case PIPE_BULK:  case PIPE_CONTROL:
-		default:
-		treat_control_like_bulk:
-			ep->last_io = jiffies;
-			total = transfer (dum, urb, ep, limit);
-			break;
-		}
-
-		/* incomplete transfer? */
-		if (urb->status == -EINPROGRESS)
-			continue;
-
-return_urb:
-		urb->hcpriv = 0;
-		if (ep)
-			ep->already_seen = ep->setup_stage = 0;
-
-		spin_unlock (&dum->lock);
-		usb_hcd_giveback_urb (&dum->hcd, urb, 0);
-		spin_lock (&dum->lock);
-
-		goto restart;
-	}
-
-	/* want a 1 msec delay here */
-	if (!list_empty (&hdev->urb_list))
-		mod_timer (&dum->timer, jiffies + msecs_to_jiffies(1));
-	else {
-		usb_put_dev (dum->udev);
-		dum->udev = NULL;
-	}
-
-	spin_unlock_irqrestore (&dum->lock, flags);
-}
-
-/*-------------------------------------------------------------------------*/
-
-#define PORT_C_MASK \
-	 ((1 << USB_PORT_FEAT_C_CONNECTION) \
-	| (1 << USB_PORT_FEAT_C_ENABLE) \
-	| (1 << USB_PORT_FEAT_C_SUSPEND) \
-	| (1 << USB_PORT_FEAT_C_OVER_CURRENT) \
-	| (1 << USB_PORT_FEAT_C_RESET))
-
-static int dummy_hub_status (struct usb_hcd *hcd, char *buf)
-{
-	struct dummy		*dum;
-	unsigned long		flags;
-	int			retval;
-
-	dum = container_of (hcd, struct dummy, hcd);
-
-	spin_lock_irqsave (&dum->lock, flags);
-	if (!(dum->port_status & PORT_C_MASK))
-		retval = 0;
-	else {
-		*buf = (1 << 1);
-		dev_dbg (hardware, "port status 0x%08x has changes\n",
-			dum->port_status);
-		retval = 1;
-	}
-	spin_unlock_irqrestore (&dum->lock, flags);
-	return retval;
-}
-
-static inline void
-hub_descriptor (struct usb_hub_descriptor *desc)
-{
-	memset (desc, 0, sizeof *desc);
-	desc->bDescriptorType = 0x29;
-	desc->bDescLength = 9;
-	desc->wHubCharacteristics = __constant_cpu_to_le16 (0x0001);
-	desc->bNbrPorts = 1;
-	desc->bitmap [0] = 0xff;
-	desc->bitmap [1] = 0xff;
-}
-
-static int dummy_hub_control (
-	struct usb_hcd	*hcd,
-	u16		typeReq,
-	u16		wValue,
-	u16		wIndex,
-	char		*buf,
-	u16		wLength
-) {
-	struct dummy	*dum;
-	int		retval = 0;
-	unsigned long	flags;
-
-	dum = container_of (hcd, struct dummy, hcd);
-	spin_lock_irqsave (&dum->lock, flags);
-	switch (typeReq) {
-	case ClearHubFeature:
-		break;
-	case ClearPortFeature:
-		switch (wValue) {
-		case USB_PORT_FEAT_SUSPEND:
-			/* 20msec resume signaling */
-			dum->resuming = 1;
-			dum->re_timeout = jiffies + ((HZ * 20)/1000);
-			break;
-		case USB_PORT_FEAT_POWER:
-			dum->port_status = 0;
-			dum->resuming = 0;
-			stop_activity(dum, dum->driver);
-			break;
-		default:
-			dum->port_status &= ~(1 << wValue);
-		}
-		break;
-	case GetHubDescriptor:
-		hub_descriptor ((struct usb_hub_descriptor *) buf);
-		break;
-	case GetHubStatus:
-		*(u32 *) buf = __constant_cpu_to_le32 (0);
-		break;
-	case GetPortStatus:
-		if (wIndex != 1)
-			retval = -EPIPE;
-
-		/* whoever resets or resumes must GetPortStatus to
-		 * complete it!!
-		 */
-		if (dum->resuming && time_after (jiffies, dum->re_timeout)) {
-			dum->port_status |= (1 << USB_PORT_FEAT_C_SUSPEND);
-			dum->port_status &= ~(1 << USB_PORT_FEAT_SUSPEND);
-			dum->resuming = 0;
-			dum->re_timeout = 0;
-			if (dum->driver->resume) {
-				spin_unlock (&dum->lock);
-				dum->driver->resume (&dum->gadget);
-				spin_lock (&dum->lock);
-			}
-		}
-		if ((dum->port_status & (1 << USB_PORT_FEAT_RESET)) != 0
-				&& time_after (jiffies, dum->re_timeout)) {
-			dum->port_status |= (1 << USB_PORT_FEAT_C_RESET);
-			dum->port_status &= ~(1 << USB_PORT_FEAT_RESET);
-			dum->re_timeout = 0;
-			if (dum->driver) {
-				dum->port_status |= USB_PORT_STAT_ENABLE;
-				/* give it the best speed we agree on */
-				dum->gadget.speed = dum->driver->speed;
-				dum->gadget.ep0->maxpacket = 64;
-				switch (dum->gadget.speed) {
-				case USB_SPEED_HIGH:
-					dum->port_status |=
-						USB_PORT_STAT_HIGH_SPEED;
-					break;
-				case USB_SPEED_LOW:
-					dum->gadget.ep0->maxpacket = 8;
-					dum->port_status |=
-						USB_PORT_STAT_LOW_SPEED;
-					break;
-				default:
-					dum->gadget.speed = USB_SPEED_FULL;
-					break;
-				}
-			}
-		}
-		((u16 *) buf)[0] = cpu_to_le16 (dum->port_status);
-		((u16 *) buf)[1] = cpu_to_le16 (dum->port_status >> 16);
-		break;
-	case SetHubFeature:
-		retval = -EPIPE;
-		break;
-	case SetPortFeature:
-		switch (wValue) {
-		case USB_PORT_FEAT_SUSPEND:
-			dum->port_status |= (1 << USB_PORT_FEAT_SUSPEND);
-			if (dum->driver->suspend) {
-				spin_unlock (&dum->lock);
-				dum->driver->suspend (&dum->gadget);
-				spin_lock (&dum->lock);
-			}
-			break;
-		case USB_PORT_FEAT_RESET:
-			/* if it's already running, disconnect first */
-			if (dum->port_status & USB_PORT_STAT_ENABLE) {
-				dum->port_status &= ~(USB_PORT_STAT_ENABLE
-						| USB_PORT_STAT_LOW_SPEED
-						| USB_PORT_STAT_HIGH_SPEED);
-				if (dum->driver) {
-					dev_dbg (hardware, "disconnect\n");
-					stop_activity (dum, dum->driver);
-				}
-
-				/* FIXME test that code path! */
-			}
-			/* 50msec reset signaling */
-			dum->re_timeout = jiffies + ((HZ * 50)/1000);
-			/* FALLTHROUGH */
-		default:
-			dum->port_status |= (1 << wValue);
-		}
-		break;
-
-	default:
-		dev_dbg (hardware,
-			"hub control req%04x v%04x i%04x l%d\n",
-			typeReq, wValue, wIndex, wLength);
-
-		/* "protocol stall" on error */
-		retval = -EPIPE;
-	}
-	spin_unlock_irqrestore (&dum->lock, flags);
-	return retval;
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-static struct usb_hcd *dummy_alloc (void)
-{
-	struct dummy		*dum;
-
-	dum = kmalloc (sizeof *dum, SLAB_KERNEL);
-	if (dum == NULL)
-		return 0;
-	memset (dum, 0, sizeof *dum);
-	return &dum->hcd;
-}
-
-static void dummy_free (struct usb_hcd *hcd)
-{
-	struct dummy		*dum;
-
-	dum = container_of (hcd, struct dummy, hcd);
-	WARN_ON (dum->driver != 0);
-	kfree (dum);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static inline ssize_t
-show_urb (char *buf, size_t size, struct urb *urb)
-{
-	int ep = usb_pipeendpoint (urb->pipe);
-
-	return snprintf (buf, size,
-		"urb/%p %s ep%d%s%s len %d/%d\n",
-		urb,
-		({ char *s;
-		 switch (urb->dev->speed) {
-		 case USB_SPEED_LOW:	s = "ls"; break;
-		 case USB_SPEED_FULL:	s = "fs"; break;
-		 case USB_SPEED_HIGH:	s = "hs"; break;
-		 default:		s = "?"; break;
-		 }; s; }),
-		ep, ep ? (usb_pipein (urb->pipe) ? "in" : "out") : "",
-		({ char *s; \
-		 switch (usb_pipetype (urb->pipe)) { \
-		 case PIPE_CONTROL:	s = ""; break; \
-		 case PIPE_BULK:	s = "-bulk"; break; \
-		 case PIPE_INTERRUPT:	s = "-int"; break; \
-		 default: 		s = "-iso"; break; \
-		}; s;}),
-		urb->actual_length, urb->transfer_buffer_length);
-}
-
-static ssize_t
-show_urbs (struct device *dev, char *buf)
-{
-	struct dummy		*dum = dev_get_drvdata(dev);
-	struct urb		*urb;
-	size_t			size = 0;
-	unsigned long		flags;
-	struct hcd_dev		*hdev;
-
-	spin_lock_irqsave (&dum->lock, flags);
-	if (dum->udev) {
-		hdev = dum->udev->hcpriv;
-		list_for_each_entry (urb, &hdev->urb_list, urb_list) {
-			size_t		temp;
-
-			temp = show_urb (buf, PAGE_SIZE - size, urb);
-			buf += temp;
-			size += temp;
-		}
-	}
-	spin_unlock_irqrestore (&dum->lock, flags);
-
-	return size;
-}
-static DEVICE_ATTR (urbs, S_IRUGO, show_urbs, NULL);
-
-
-static const struct hc_driver dummy_hcd;
-
-static int dummy_start (struct usb_hcd *hcd)
-{
-	struct dummy		*dum;
-	struct usb_bus		*bus;
-	struct usb_device	*root;
-	int			retval;
-
-	dum = container_of (hcd, struct dummy, hcd);
-
-	/*
-	 * MASTER side init ... we emulate a root hub that'll only ever
-	 * talk to one device (the slave side).  Also appears in sysfs,
-	 * just like more familiar pci-based HCDs.
-	 */
-	spin_lock_init (&dum->lock);
-
-	retval = driver_register (&dummy_driver);
-	if (retval < 0)
-		return retval;
-
-	dum->pdev.name = "hc";
-	dum->pdev.dev.driver = &dummy_driver;
-	dev_set_drvdata(&dum->pdev.dev, dum);
-	dum->pdev.dev.release = dummy_hc_release;
-	retval = platform_device_register (&dum->pdev);
-	if (retval < 0) {
-		driver_unregister (&dummy_driver);
-		return retval;
-	}
-	dev_info (&dum->pdev.dev, "%s, driver " DRIVER_VERSION "\n",
-			driver_desc);
-
-	hcd->self.controller = &dum->pdev.dev;
-
-	/* FIXME 'urbs' should be a per-device thing, maybe in usbcore */
-	device_create_file (hcd->self.controller, &dev_attr_urbs);
-
-	init_timer (&dum->timer);
-	dum->timer.function = dummy_timer;
-	dum->timer.data = (unsigned long) dum;
-
-	/* root hub will appear as another device */
-	dum->hcd.driver = (struct hc_driver *) &dummy_hcd;
-	dum->hcd.description = dummy_hcd.description;
-	dum->hcd.product_desc = "Dummy host controller";
-
-	bus = hcd_to_bus (&dum->hcd);
-	bus->bus_name = dum->pdev.dev.bus_id;
-	usb_bus_init (bus);
-	bus->op = &usb_hcd_operations;
-	bus->hcpriv = &dum->hcd;
-
-	/* FIXME don't require the pci-based buffer/alloc impls;
-	 * the "generic dma" implementation still requires them,
-	 * it's not very generic yet.
-	 */
-	if ((retval = hcd_buffer_create (&dum->hcd)) != 0) {
-clean0:
-		init_completion (&dum->released);
-		platform_device_unregister (&dum->pdev);
-		wait_for_completion (&dum->released);
-		driver_unregister (&dummy_driver);
-		return retval;
-	}
-
-	INIT_LIST_HEAD (&hcd->dev_list);
-	usb_register_bus (bus);
-
-	root = usb_alloc_dev (0, bus, 0);
-	if (!root) {
-		retval = -ENOMEM;
-clean1:
-		hcd_buffer_destroy (&dum->hcd);
-		usb_deregister_bus (bus);
-		goto clean0;
-	}
-
-	/* root hub enters addressed state... */
-	dum->hcd.state = USB_STATE_RUNNING;
-	root->speed = USB_SPEED_HIGH;
-
-	/* ...then configured, so khubd sees us. */
-	if ((retval = hcd_register_root (root, &dum->hcd)) != 0) {
-		usb_put_dev (root);
-clean2:
-		dum->hcd.state = USB_STATE_QUIESCING;
-		goto clean1;
-	}
-
-	/* only show a low-power port: just 8mA */
-	hub_set_power_budget (root, 8);
-
-	dum->started = 1;
-
-	if ((retval = dummy_register_udc (dum)) != 0) {
-		dum->started = 0;
-		usb_disconnect (&bus->root_hub);
-		goto clean2;
-	}
-	return 0;
-}
-
-static void dummy_stop (struct usb_hcd *hcd)
-{
-	struct dummy		*dum;
-	struct usb_bus		*bus;
-
-	dum = container_of (hcd, struct dummy, hcd);
-	if (!dum->started)
-		return;
-	dum->started = 0;
-
-	usb_gadget_unregister_driver (dum->driver);
-	dummy_unregister_udc (dum);
-
-	bus = hcd_to_bus (&dum->hcd);
-	hcd->state = USB_STATE_QUIESCING;
-	dev_dbg (hardware, "remove root hub\n");
-	usb_disconnect (&bus->root_hub);
-
-	hcd_buffer_destroy (&dum->hcd);
-	usb_deregister_bus (bus);
-
-	dev_info (hardware, "stopped\n");
-
-	device_remove_file (hcd->self.controller, &dev_attr_urbs);
-	init_completion (&dum->released);
-	platform_device_unregister (&dum->pdev);
-	wait_for_completion (&dum->released);
-
-	driver_unregister (&dummy_driver);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int dummy_h_get_frame (struct usb_hcd *hcd)
-{
-	return dummy_g_get_frame (0);
-}
-
-static const struct hc_driver dummy_hcd = {
-	.description =		(char *) driver_name,
-	.flags =		HCD_USB2,
-
-	.start =		dummy_start,
-	.stop =			dummy_stop,
-
-	.hcd_alloc = 		dummy_alloc,
-	.hcd_free = 		dummy_free,
-
-	.urb_enqueue = 		dummy_urb_enqueue,
-	.urb_dequeue = 		dummy_urb_dequeue,
-
-	.get_frame_number = 	dummy_h_get_frame,
-
-	.hub_status_data = 	dummy_hub_status,
-	.hub_control = 		dummy_hub_control,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int __init init (void)
-{
-	struct usb_hcd		*hcd;
-	int			value;
-
-	if (usb_disabled ())
-		return -ENODEV;
-	if ((hcd = dummy_alloc ()) == 0)
-		return -ENOMEM;
-
-	the_controller = container_of (hcd, struct dummy, hcd);
-	value = dummy_start (hcd);
-
-	if (value != 0) {
-		dummy_free (hcd);
-		the_controller = 0;
-	}
-	return value;
-}
-module_init (init);
-
-static void __exit cleanup (void)
-{
-	dummy_stop (&the_controller->hcd);
-	dummy_free (&the_controller->hcd);
-	the_controller = 0;
-}
-module_exit (cleanup);
-
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/epautoconf.c linuxppc-2.6.9-dream/drivers/usb/gadget/epautoconf.c
--- linuxppc-2.6.9/drivers/usb/gadget/epautoconf.c	2004-10-18 23:55:43.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/epautoconf.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,307 +0,0 @@
-/*
- * epautoconf.c -- endpoint autoconfiguration for usb gadget drivers
- *
- * Copyright (C) 2004 David Brownell
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/device.h>
-
-#include <linux/ctype.h>
-#include <linux/string.h>
-
-#include <linux/usb_ch9.h>
-#include <linux/usb_gadget.h>
-
-#include "gadget_chips.h"
-
-
-/* we must assign addresses for configurable endpoints (like net2280) */
-static __initdata unsigned epnum;
-
-// #define MANY_ENDPOINTS
-#ifdef MANY_ENDPOINTS
-/* more than 15 configurable endpoints */
-static __initdata unsigned in_epnum;
-#endif
-
-
-/*
- * This should work with endpoints from controller drivers sharing the
- * same endpoint naming convention.  By example:
- *
- *	- ep1, ep2, ... address is fixed, not direction or type
- *	- ep1in, ep2out, ... address and direction are fixed, not type
- *	- ep1-bulk, ep2-bulk, ... address and type are fixed, not direction
- *	- ep1in-bulk, ep2out-iso, ... all three are fixed
- *	- ep-* ... no functionality restrictions
- *
- * Type suffixes are "-bulk", "-iso", or "-int".  Numbers are decimal.
- * Less common restrictions are implied by gadget_is_*().
- */
-static int __init
-ep_matches (
-	struct usb_gadget		*gadget,
-	struct usb_ep			*ep,
-	struct usb_endpoint_descriptor	*desc
-)
-{
-	u8		type;
-	const char	*tmp;
-	u16		max;
-
-	/* endpoint already claimed? */
-	if (0 != ep->driver_data)
-		return 0;
-		
-	/* only support ep0 for portable CONTROL traffic */
-	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
-	if (USB_ENDPOINT_XFER_CONTROL == type)
-		return 0;
-
-	/* some other naming convention */
-	if ('e' != ep->name[0])
-		return 0;
-
-	/* type-restriction:  "-iso", "-bulk", or "-int".
-	 * direction-restriction:  "in", "out".
-	 */
-	if ('-' != ep->name[2]) {
-		tmp = strrchr (ep->name, '-');
-		if (tmp) {
-			switch (type) {
-			case USB_ENDPOINT_XFER_INT:
-				/* bulk endpoints handle interrupt transfers,
-				 * except the toggle-quirky iso-synch kind
-				 */
-				if ('s' == tmp[2])	// == "-iso"
-					return 0;
-				/* for now, avoid PXA "interrupt-in";
-				 * it's documented as never using DATA1.
-				 */
-				if (gadget_is_pxa (gadget)
-						&& 'i' == tmp [1])
-					return 0;
-				break;
-			case USB_ENDPOINT_XFER_BULK:
-				if ('b' != tmp[1])	// != "-bulk"
-					return 0;
-				break;
-			case USB_ENDPOINT_XFER_ISOC:
-				if ('s' != tmp[2])	// != "-iso"
-					return 0;
-			}
-		} else {
-			tmp = ep->name + strlen (ep->name);
-		}
-
-		/* direction-restriction:  "..in-..", "out-.." */
-		tmp--;
-		if (!isdigit (*tmp)) {
-			if (desc->bEndpointAddress & USB_DIR_IN) {
-				if ('n' != *tmp)
-					return 0;
-			} else {
-				if ('t' != *tmp)
-					return 0;
-			}
-		}
-	}
-
-	/* endpoint maxpacket size is an input parameter, except for bulk
-	 * where it's an output parameter representing the full speed limit.
-	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
-	 */
-	max = 0x7ff & le16_to_cpup (&desc->wMaxPacketSize);
-	switch (type) {
-	case USB_ENDPOINT_XFER_INT:
-		/* INT:  limit 64 bytes full speed, 1024 high speed */
-		if (!gadget->is_dualspeed && max > 64)
-			return 0;
-		/* FALLTHROUGH */
-
-	case USB_ENDPOINT_XFER_ISOC:
-		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
-		if (ep->maxpacket < max)
-			return 0;
-		if (!gadget->is_dualspeed && max > 1023)
-			return 0;
-
-		/* BOTH:  "high bandwidth" works only at high speed */
-		if ((desc->wMaxPacketSize & __constant_cpu_to_le16(3<<11))) {
-			if (!gadget->is_dualspeed)
-				return 0;
-			/* configure your hardware with enough buffering!! */
-		}
-		break;
-	}
-
-	/* MATCH!! */
-
-	/* report address */
-	if (isdigit (ep->name [2])) {
-		u8	num = simple_strtol (&ep->name [2], NULL, 10);
-		desc->bEndpointAddress |= num;
-#ifdef	MANY_ENDPOINTS
-	} else if (desc->bEndpointAddress & USB_DIR_IN) {
-		if (++in_epnum > 15)
-			return 0;
-		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
-#endif
-	} else {
-		if (++epnum > 15)
-			return 0;
-		desc->bEndpointAddress |= epnum;
-	}
-
-	/* report (variable) full speed bulk maxpacket */
-	if (USB_ENDPOINT_XFER_BULK == type) {
-		int size = ep->maxpacket;
-
-		/* min() doesn't work on bitfields with gcc-3.5 */
-		if (size > 64)
-			size = 64;
-		desc->wMaxPacketSize = cpu_to_le16(size);
-	}
-	return 1;
-}
-
-static struct usb_ep * __init
-find_ep (struct usb_gadget *gadget, const char *name)
-{
-	struct usb_ep	*ep;
-
-	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
-		if (0 == strcmp (ep->name, name))
-			return ep;
-	}
-	return NULL;
-}
-
-/**
- * usb_ep_autoconfig - choose an endpoint matching the descriptor
- * @gadget: The device to which the endpoint must belong.
- * @desc: Endpoint descriptor, with endpoint direction and transfer mode
- *	initialized.  For periodic transfers, the maximum packet
- *	size must also be initialized.  This is modified on success.
- *
- * By choosing an endpoint to use with the specified descriptor, this
- * routine simplifies writing gadget drivers that work with multiple
- * USB device controllers.  The endpoint would be passed later to
- * usb_ep_enable(), along with some descriptor.
- *
- * That second descriptor won't always be the same as the first one.
- * For example, isochronous endpoints can be autoconfigured for high
- * bandwidth, and then used in several lower bandwidth altsettings.
- * Also, high and full speed descriptors will be different.
- *
- * Be sure to examine and test the results of autoconfiguration on your
- * hardware.  This code may not make the best choices about how to use the
- * USB controller, and it can't know all the restrictions that may apply.
- * Some combinations of driver and hardware won't be able to autoconfigure.
- *
- * On success, this returns an un-claimed usb_ep, and modifies the endpoint
- * descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
- * is initialized as if the endpoint were used at full speed.  To prevent
- * the endpoint from being returned by a later autoconfig call, claim it
- * by assigning ep->driver_data to some non-null value.
- *
- * On failure, this returns a null endpoint descriptor.
- */
-struct usb_ep * __init usb_ep_autoconfig (
-	struct usb_gadget		*gadget,
-	struct usb_endpoint_descriptor	*desc
-)
-{
-	struct usb_ep	*ep;
-	u8		type;
-
-	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
-
-	/* First, apply chip-specific "best usage" knowledge.
-	 * This might make a good usb_gadget_ops hook ...
-	 */
-	if (gadget_is_net2280 (gadget) && type == USB_ENDPOINT_XFER_INT) {
-		/* ep-e, ep-f are PIO with only 64 byte fifos */
-		ep = find_ep (gadget, "ep-e");
-		if (ep && ep_matches (gadget, ep, desc))
-			return ep;
-		ep = find_ep (gadget, "ep-f");
-		if (ep && ep_matches (gadget, ep, desc))
-			return ep;
-
-	} else if (gadget_is_goku (gadget)) {
-		if (USB_ENDPOINT_XFER_INT == type) {
-			/* single buffering is enough */
-			ep = find_ep (gadget, "ep3-bulk");
-			if (ep && ep_matches (gadget, ep, desc))
-				return ep;
-		} else if (USB_ENDPOINT_XFER_BULK == type
-				&& (USB_DIR_IN & desc->bEndpointAddress)) {
-			/* DMA may be available */
-			ep = find_ep (gadget, "ep2-bulk");
-			if (ep && ep_matches (gadget, ep, desc))
-				return ep;
-		}
-
-	} else if (gadget_is_sh (gadget) && USB_ENDPOINT_XFER_INT == type) {
-		/* single buffering is enough; maybe 8 byte fifo is too */
-		ep = find_ep (gadget, "ep3in-bulk");
-		if (ep && ep_matches (gadget, ep, desc))
-			return ep;
-
-	} else if (gadget_is_mq11xx (gadget) && USB_ENDPOINT_XFER_INT == type) {
-		ep = find_ep (gadget, "ep1-bulk");
-		if (ep && ep_matches (gadget, ep, desc))
-			return ep;
-	}
-
-	/* Second, look at endpoints until an unclaimed one looks usable */ 
-	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
-		if (ep_matches (gadget, ep, desc))
-			return ep;
-	}
-
-	/* Fail */
-	return NULL;
-}
-
-/**
- * usb_ep_autoconfig_reset - reset endpoint autoconfig state
- * @gadget: device for which autoconfig state will be reset
- *
- * Use this for devices where one configuration may need to assign
- * endpoint resources very differently from the next one.  It clears
- * state such as ep->driver_data and the record of assigned endpoints
- * used by usb_ep_autoconfig().
- */
-void __init usb_ep_autoconfig_reset (struct usb_gadget *gadget)
-{
-	struct usb_ep	*ep;
-
-	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
-		ep->driver_data = NULL;
-	}
-#ifdef	MANY_ENDPOINTS
-	in_epnum = 0;
-#endif
-	epnum = 0;
-}
-
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/ether.c linuxppc-2.6.9-dream/drivers/usb/gadget/ether.c
--- linuxppc-2.6.9/drivers/usb/gadget/ether.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/ether.c	2005-09-19 21:40:05.000000000 +0200
@@ -1,8 +1,7 @@
 /*
  * ether.c -- Ethernet gadget driver, with CDC and non-CDC options
  *
- * Copyright (C) 2003-2004 David Brownell
- * Copyright (C) 2003-2004 Robert Schwebel, Benedikt Spranger
+ * Copyright (C) 2003 David Brownell
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -40,7 +39,6 @@
 #include <linux/version.h>
 #include <linux/device.h>
 #include <linux/moduleparam.h>
-#include <linux/ctype.h>
 
 #include <asm/byteorder.h>
 #include <asm/io.h>
@@ -57,46 +55,32 @@
 #include <linux/etherdevice.h>
 #include <linux/ethtool.h>
 
-#include "gadget_chips.h"
-
 /*-------------------------------------------------------------------------*/
 
 /*
  * Ethernet gadget driver -- with CDC and non-CDC options
- * Builds on hardware support for a full duplex link.
  *
  * CDC Ethernet is the standard USB solution for sending Ethernet frames
  * using USB.  Real hardware tends to use the same framing protocol but look
- * different for control features.  This driver strongly prefers to use
- * this USB-IF standard as its open-systems interoperability solution;
- * most host side USB stacks (except from Microsoft) support it.
+ * different for control features.  And Microsoft pushes their own approach
+ * (RNDIS) instead of the standard.
  *
  * There's some hardware that can't talk CDC.  We make that hardware
  * implement a "minimalist" vendor-agnostic CDC core:  same framing, but
  * link-level setup only requires activating the configuration.
- * Linux supports it, but other host operating systems may not.
- * (This is a subset of CDC Ethernet.)
- *
- * A third option is also in use.  Rather than CDC Ethernet, or something
- * simpler, Microsoft pushes their own approach: RNDIS.  The published
- * RNDIS specs are ambiguous and appear to be incomplete, and are also
- * needlessly complex.
  */
 
 #define DRIVER_DESC		"Ethernet Gadget"
-#define DRIVER_VERSION		"St Patrick's Day 2004"
+#define DRIVER_VERSION		"Bastille Day 2003"
 
 static const char shortname [] = "ether";
 static const char driver_desc [] = DRIVER_DESC;
 
+#define MIN_PACKET	sizeof(struct ethhdr)
+#define	MAX_PACKET	ETH_DATA_LEN	/* biggest packet we'll rx/tx */
 #define RX_EXTRA	20		/* guard against rx overflows */
 
-#ifdef	CONFIG_USB_ETH_RNDIS
-#include "rndis.h"
-#else
-#define rndis_init() 0
-#define rndis_exit() do{}while(0)
-#endif
+/* FIXME allow high speed jumbograms */
 
 /*-------------------------------------------------------------------------*/
 
@@ -116,146 +100,214 @@
 	atomic_t		tx_qlen;
 
 	struct work_struct	work;
-	unsigned		zlp:1;
-	unsigned		cdc:1;
-	unsigned		rndis:1;
-	unsigned		suspended:1;
-	u16			cdc_filter;
 	unsigned long		todo;
 #define	WORK_RX_MEMORY		0
-	int			rndis_config;
-	u8			host_mac [ETH_ALEN];
 };
 
-/* This version autoconfigures as much as possible at run-time.
- *
- * It also ASSUMES a self-powered device, without remote wakeup,
- * although remote wakeup support would make sense.
- */
-static const char *EP_IN_NAME;
-static const char *EP_OUT_NAME;
-static const char *EP_STATUS_NAME;
-
 /*-------------------------------------------------------------------------*/
 
-/* DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
- * Instead:  allocate your own, using normal USB-IF procedures.
- */
-
 /* Thanks to NetChip Technologies for donating this product ID.
- * It's for devices with only CDC Ethernet configurations.
- */
-#define CDC_VENDOR_NUM	0x0525		/* NetChip */
-#define CDC_PRODUCT_NUM	0xa4a1		/* Linux-USB Ethernet Gadget */
-
-/* For hardware that can't talk CDC, we use the same vendor ID that
- * ARM Linux has used for ethernet-over-usb, both with sa1100 and
- * with pxa250.  We're protocol-compatible, if the host-side drivers
- * use the endpoint descriptors.  bcdDevice (version) is nonzero, so
- * drivers that need to hard-wire endpoint numbers have a hook.
  *
- * The protocol is a minimal subset of CDC Ether, which works on any bulk
- * hardware that's not deeply broken ... even on hardware that can't talk
- * RNDIS (like SA-1100, with no interrupt endpoint, or anything that
- * doesn't handle control-OUT).
- */
-#define	SIMPLE_VENDOR_NUM	0x049f
-#define	SIMPLE_PRODUCT_NUM	0x505a
-
-/* For hardware that can talk RNDIS and either of the above protocols,
- * use this ID ... the windows INF files will know it.  Unless it's
- * used with CDC Ethernet, Linux 2.4 hosts will need updates to choose
- * the non-RNDIS configuration.
+ * DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
+ * Instead:  allocate your own, using normal USB-IF procedures.
  */
-#define RNDIS_VENDOR_NUM	0x0525	/* NetChip */
-#define RNDIS_PRODUCT_NUM	0xa4a2	/* Ethernet/RNDIS Gadget */
+#define DRIVER_VENDOR_NUM	0x0525		/* NetChip */
+#define DRIVER_PRODUCT_NUM	0xa4a1		/* Linux-USB Ethernet Gadget */
 
+/*-------------------------------------------------------------------------*/
 
-/* Some systems will want different product identifers published in the
- * device descriptor, either numbers or strings or both.  These string
- * parameters are in UTF-8 (superset of ASCII's 7 bit characters).
+/*
+ * hardware-specific configuration, controlled by which device
+ * controller driver was configured.
+ *
+ * CHIP ... hardware identifier
+ * DRIVER_VERSION_NUM ... alerts the host side driver to differences
+ * EP_*_NAME ... which endpoints do we use for which purpose?
+ * EP_*_NUM ... numbers for them (often limited by hardware)
+ * WAKEUP ... if hardware supports remote wakeup AND we will issue the
+ * 	usb_gadget_wakeup() call to initiate it, USB_CONFIG_ATT_WAKEUP
+ *
+ * hw_optimize(gadget) ... for any hardware tweaks we want to kick in
+ * 	before we enable our endpoints
+ *
+ * add other defines for other portability issues, like hardware that
+ * for some reason doesn't handle full speed bulk maxpacket of 64.
  */
 
-static ushort __initdata idVendor;
-module_param(idVendor, ushort, S_IRUGO);
-MODULE_PARM_DESC(idVendor, "USB Vendor ID");
-
-static ushort __initdata idProduct;
-module_param(idProduct, ushort, S_IRUGO);
-MODULE_PARM_DESC(idProduct, "USB Product ID");
-
-static ushort __initdata bcdDevice;
-module_param(bcdDevice, ushort, S_IRUGO);
-MODULE_PARM_DESC(bcdDevice, "USB Device version (BCD)");
+#define DEV_CONFIG_VALUE	3	/* some hardware cares */
 
-static char *__initdata iManufacturer;
-module_param(iManufacturer, charp, S_IRUGO);
-MODULE_PARM_DESC(iManufacturer, "USB Manufacturer string");
-
-static char *__initdata iProduct;
-module_param(iProduct, charp, S_IRUGO);
-MODULE_PARM_DESC(iProduct, "USB Product string");
+/* #undef on hardware that can't implement CDC */
+#define	DEV_CONFIG_CDC
 
-/* initial value, changed by "ifconfig usb0 hw ether xx:xx:xx:xx:xx:xx" */
-static char *__initdata dev_addr;
-module_param(dev_addr, charp, S_IRUGO);
-MODULE_PARM_DESC(iProduct, "Device Ethernet Address");
+/* undef on bus-powered hardware, and #define MAX_USB_POWER */
+#define SELFPOWER
 
-/* this address is invisible to ifconfig */
-static char *__initdata host_addr;
-module_param(host_addr, charp, S_IRUGO);
-MODULE_PARM_DESC(host_addr, "Host Ethernet Address");
+/*
+ * NetChip 2280, PCI based.
+ *
+ * use DMA with fat fifos for all data traffic, PIO for the status channel
+ * where its 64 byte maxpacket ceiling is no issue.
+ *
+ * performance note:  only PIO needs per-usb-packet IRQs (ep0, ep-e, ep-f)
+ * otherwise IRQs are per-Ethernet-packet unless TX_DELAY and chaining help.
+ */
+#ifdef	CONFIG_USB_GADGET_NET2280
+#define CHIP			"net2280"
+#define DEFAULT_QLEN		4		/* has dma chaining */
+#define DRIVER_VERSION_NUM	0x0101
+static const char EP_OUT_NAME [] = "ep-a";
+#define EP_OUT_NUM	1
+static const char EP_IN_NAME [] = "ep-b";
+#define EP_IN_NUM	2
+static const char EP_STATUS_NAME [] = "ep-f";
+#define EP_STATUS_NUM	3
+/* supports remote wakeup, but this driver doesn't */
 
+extern int net2280_set_fifo_mode (struct usb_gadget *gadget, int mode);
 
-/*-------------------------------------------------------------------------*/
+static inline void hw_optimize (struct usb_gadget *gadget)
+{
+	/* we can have bigger ep-a/ep-b fifos (2KB each, 4 USB packets
+	 * for highspeed bulk) because we're not using ep-c/ep-d.
+	 */
+	net2280_set_fifo_mode (gadget, 1);
+}
+#endif
 
-/* Include CDC support if we could run on CDC-capable hardware. */
+/*
+ * PXA-2xx UDC:  widely used in second gen Linux-capable ARM PDAs
+ * and other products.
+ *
+ * multiple interfaces (or altsettings) aren't usable.  so this hardware
+ * can't implement CDC, which needs both capabilities.
+ */
+#ifdef	CONFIG_USB_GADGET_PXA2XX
+#undef	DEV_CONFIG_CDC
+#define CHIP			"pxa2xx"
+#define DRIVER_VERSION_NUM	0x0103
+static const char EP_OUT_NAME [] = "ep2out-bulk";
+#define EP_OUT_NUM	2
+static const char EP_IN_NAME [] = "ep1in-bulk";
+#define EP_IN_NUM	1
+/* supports remote wakeup, but this driver doesn't */
 
-#ifdef CONFIG_USB_GADGET_NET2280
-#define	DEV_CONFIG_CDC
+/* no hw optimizations to apply */
+#define hw_optimize(g) do {} while (0)
 #endif
 
-#ifdef CONFIG_USB_GADGET_DUMMY_HCD
-#define	DEV_CONFIG_CDC
-#endif
+/*
+ * SA-1100 UDC:  widely used in first gen Linux-capable PDAs.
+ *
+ * can't have a notification endpoint, since there are only the two
+ * bulk-capable ones.  the CDC spec allows that.
+ */
+#ifdef	CONFIG_USB_GADGET_SA1100
+#define CHIP			"sa1100"
+#define DRIVER_VERSION_NUM	0x0105
+static const char EP_OUT_NAME [] = "ep1out-bulk";
+#define EP_OUT_NUM	1
+static const char EP_IN_NAME [] = "ep2in-bulk";
+#define EP_IN_NUM	2
+// EP_STATUS_NUM is undefined
+/* doesn't support remote wakeup? */
 
-#ifdef CONFIG_USB_GADGET_GOKU
-#define	DEV_CONFIG_CDC
+/* no hw optimizations to apply */
+#define hw_optimize(g) do {} while (0)
 #endif
 
-#ifdef CONFIG_USB_GADGET_MQ11XX
-#define	DEV_CONFIG_CDC
-#endif
+/*
+ * Toshiba TC86C001 ("Goku-S") UDC
+ *
+ * This has three semi-configurable full speed bulk/interrupt endpoints.
+ */
+#ifdef	CONFIG_USB_GADGET_GOKU
+#define CHIP			"goku"
+#define DRIVER_VERSION_NUM	0x0106
+static const char EP_OUT_NAME [] = "ep1-bulk";
+#define EP_OUT_NUM	1
+static const char EP_IN_NAME [] = "ep2-bulk";
+#define EP_IN_NUM	2
+static const char EP_STATUS_NAME [] = "ep3-bulk";
+#define EP_STATUS_NUM	3
+/* doesn't support remote wakeup */
 
-#ifdef CONFIG_USB_GADGET_OMAP
-#define	DEV_CONFIG_CDC
+#define hw_optimize(g) do {} while (0)
 #endif
 
-
-/* For CDC-incapable hardware, choose the simple cdc subset.
- * Anything that talks bulk (without notable bugs) can do this.
+/*
+ * SuperH UDC:  UDC built-in to some Renesas SH processors.
+ *
+ * This has three semi-configurable full speed bulk/interrupt endpoints.
+ *
+ * Only one configuration and interface is supported.  So this hardware
+ * can't implement CDC.
  */
-#ifdef CONFIG_USB_GADGET_PXA2XX
-#define	DEV_CONFIG_SUBSET
-#endif
+#ifdef	CONFIG_USB_GADGET_SUPERH
+#undef	DEV_CONFIG_CDC
+#define CHIP			"superh"
+#define DRIVER_VERSION_NUM	0x0107
+static const char EP_OUT_NAME[] = "ep1out-bulk";
+#define EP_OUT_NUM		1
+static const char EP_IN_NAME[] = "ep2in-bulk";
+#define EP_IN_NUM		2
 
-#ifdef CONFIG_USB_GADGET_SH
-#define	DEV_CONFIG_SUBSET
+#define hw_optimize(g) do {} while (0)
 #endif
 
-#ifdef CONFIG_USB_GADGET_LH7A40X
-#define DEV_CONFIG_CDC
+/*-------------------------------------------------------------------------*/
+
+#ifndef CHIP
+#	error Configure some USB peripheral controller driver!
 #endif
 
-#ifdef CONFIG_USB_GADGET_SA1100
-/* use non-CDC for backwards compatibility */
-#define	DEV_CONFIG_SUBSET
+/* We normally expect hardware that can talk CDC.  That involves
+ * using multiple interfaces and altsettings, and maybe a status
+ * interrupt.  Driver binding to be done according to USB-IF class,
+ * though you can use different VENDOR and PRODUCT numbers if you
+ * want (and they're officially assigned).
+ * 
+ * For hardware that can't talk CDC, we use the same vendor ID that
+ * ARM Linux has used for ethernet-over-usb, both with sa1100 and
+ * with pxa250.  We're protocol-compatible, if the host-side drivers
+ * use the endpoint descriptors.  DRIVER_VERSION_NUM is nonzero, so
+ * drivers that need to hard-wire endpoint numbers have a hook.
+ */
+#ifdef	DEV_CONFIG_CDC
+#define	DEV_CONFIG_CLASS	USB_CLASS_COMM
+#else	
+#define	DEV_CONFIG_CLASS	USB_CLASS_VENDOR_SPEC
+#undef	EP_STATUS_NUM
+#undef	DRIVER_VENDOR_NUM
+#undef	DRIVER_PRODUCT_NUM
+#define	DRIVER_VENDOR_NUM	0x049f
+#define	DRIVER_PRODUCT_NUM	0x505a
+#endif /* CONFIG_CDC_ETHER */
+
+/* power usage is config specific.
+ * hardware that supports remote wakeup defaults to disabling it.
+ */
+
+#ifndef	MAX_USB_POWER
+#ifdef	SELFPOWER
+/* some hosts are confused by 0mA  */
+#define MAX_USB_POWER	2	/* mA */
+#else
+/* bus powered */
+#error	Define your bus power consumption!
 #endif
+#endif	/* MAX_USB_POWER */
 
+#ifndef	WAKEUP
+/* default: this driver won't do remote wakeup */
+#define WAKEUP		0
+/* else value must be USB_CONFIG_ATT_WAKEUP */
+#endif
 
 /*-------------------------------------------------------------------------*/
 
+#ifndef DEFAULT_QLEN
 #define DEFAULT_QLEN	2	/* double buffering by default */
+#endif
 
 #ifdef CONFIG_USB_GADGET_DUALSPEED
 
@@ -268,14 +320,10 @@
 	(DEFAULT_QLEN*((gadget->speed == USB_SPEED_HIGH) ? qmult : 1))
 
 /* also defer IRQs on highspeed TX */
-#define TX_DELAY	qmult
-
-#define	BITRATE(g) ((g->speed == USB_SPEED_HIGH) ? 4800000 : 120000)
+#define TX_DELAY	DEFAULT_QLEN
 
 #else	/* full speed (low speed doesn't do bulk) */
 #define qlen(gadget) DEFAULT_QLEN
-
-#define	BITRATE(g)	(12000)
 #endif
 
 
@@ -316,13 +364,8 @@
 
 /*
  * DESCRIPTORS ... most are static, but strings and (full) configuration
- * descriptors are built on demand.  For now we do either full CDC, or
- * our simple subset, with RNDIS as an optional second configuration.
- *
- * RNDIS includes some CDC ACM descriptors ... like CDC Ethernet.  But
- * the class descriptors match a modem (they're ignored; it's really just
- * Ethernet functionality), they don't need the NOP altsetting, and the
- * status transfer endpoint isn't optional.
+ * descriptors are built on demand.  Notice how most of the cdc descriptors
+ * aren't needed in the "minimalist" mode.
  */
 
 #define STRING_MANUFACTURER		1
@@ -330,27 +373,12 @@
 #define STRING_ETHADDR			3
 #define STRING_DATA			4
 #define STRING_CONTROL			5
-#define STRING_RNDIS_CONTROL		6
-#define STRING_CDC			7
-#define STRING_SUBSET			8
-#define STRING_RNDIS			9
 
 #define USB_BUFSIZ	256		/* holds our biggest descriptor */
 
 /*
- * This device advertises one configuration, eth_config, unless RNDIS
- * is enabled (rndis_config) on hardware supporting at least two configs.
- *
- * NOTE:  Controllers like superh_udc should probably be able to use
- * an RNDIS-only configuration.
- *
- * FIXME define some higher-powered configurations to make it easier
- * to recharge batteries ...
+ * This device advertises one configuration.
  */
-
-#define DEV_CONFIG_VALUE	1	/* cdc or subset */
-#define DEV_RNDIS_CONFIG_VALUE	2	/* rndis; optional */
-
 static struct usb_device_descriptor
 device_desc = {
 	.bLength =		sizeof device_desc,
@@ -358,95 +386,62 @@
 
 	.bcdUSB =		__constant_cpu_to_le16 (0x0200),
 
-	.bDeviceClass =		USB_CLASS_COMM,
+	.bDeviceClass =		DEV_CONFIG_CLASS,
 	.bDeviceSubClass =	0,
 	.bDeviceProtocol =	0,
 
-	.idVendor =		__constant_cpu_to_le16 (CDC_VENDOR_NUM),
-	.idProduct =		__constant_cpu_to_le16 (CDC_PRODUCT_NUM),
+	.idVendor =		__constant_cpu_to_le16 (DRIVER_VENDOR_NUM),
+	.idProduct =		__constant_cpu_to_le16 (DRIVER_PRODUCT_NUM),
+	.bcdDevice =		__constant_cpu_to_le16 (DRIVER_VERSION_NUM),
 	.iManufacturer =	STRING_MANUFACTURER,
 	.iProduct =		STRING_PRODUCT,
 	.bNumConfigurations =	1,
 };
 
-static struct usb_otg_descriptor
-otg_descriptor = {
-	.bLength =		sizeof otg_descriptor,
-	.bDescriptorType =	USB_DT_OTG,
-
-	.bmAttributes =		USB_OTG_SRP,
-};
-
 static struct usb_config_descriptor
 eth_config = {
 	.bLength =		sizeof eth_config,
 	.bDescriptorType =	USB_DT_CONFIG,
 
 	/* compute wTotalLength on the fly */
+#ifdef	DEV_CONFIG_CDC
 	.bNumInterfaces =	2,
+#else
+	.bNumInterfaces =	1,
+#endif
 	.bConfigurationValue =	DEV_CONFIG_VALUE,
-	.iConfiguration =	STRING_CDC,
-	.bmAttributes =		USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
-	.bMaxPower =		1,
+	.iConfiguration =	STRING_PRODUCT,
+	.bmAttributes =		USB_CONFIG_ATT_ONE | WAKEUP,
+	.bMaxPower =		(MAX_USB_POWER + 1) / 2,
 };
 
-#ifdef	CONFIG_USB_ETH_RNDIS
-static struct usb_config_descriptor 
-rndis_config = {
-	.bLength =              sizeof rndis_config,
-	.bDescriptorType =      USB_DT_CONFIG,
-
-	/* compute wTotalLength on the fly */
-	.bNumInterfaces =       2,
-	.bConfigurationValue =  DEV_RNDIS_CONFIG_VALUE,
-	.iConfiguration =       STRING_RNDIS,
-	.bmAttributes =		USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
-	.bMaxPower =            1,
-};
-#endif
+#ifdef	DEV_CONFIG_CDC
 
 /*
- * Compared to the simple CDC subset, the full CDC Ethernet model adds
- * three class descriptors, two interface descriptors, optional status
+ * Compared to the "minimalist" non-CDC model, the CDC model adds
+ * three class descriptors, two interface descrioptors, and a status
  * endpoint.  Both have a "data" interface and two bulk endpoints.
  * There are also differences in how control requests are handled.
- *
- * RNDIS shares a lot with CDC-Ethernet, since it's a variant of
- * the CDC-ACM (modem) spec.
  */
 
-#ifdef	DEV_CONFIG_CDC
-static struct usb_interface_descriptor
+/* master comm interface optionally has a status notification endpoint */
+
+static const struct usb_interface_descriptor
 control_intf = {
 	.bLength =		sizeof control_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
 	.bInterfaceNumber =	0,
-	/* status endpoint is optional; this may be patched later */
+#ifdef	EP_STATUS_NUM
 	.bNumEndpoints =	1,
+#else
+	.bNumEndpoints =	0,
+#endif
 	.bInterfaceClass =	USB_CLASS_COMM,
 	.bInterfaceSubClass =	6,	/* ethernet control model */
 	.bInterfaceProtocol =	0,
 	.iInterface =		STRING_CONTROL,
 };
-#endif
-
-#ifdef	CONFIG_USB_ETH_RNDIS
-static const struct usb_interface_descriptor
-rndis_control_intf = {
-	.bLength =              sizeof rndis_control_intf,
-	.bDescriptorType =      USB_DT_INTERFACE,
-	  
-	.bInterfaceNumber =     0,
-	.bNumEndpoints =        1,
-	.bInterfaceClass =      USB_CLASS_COMM,
-	.bInterfaceSubClass =   2,	/* abstract control model */
-	.bInterfaceProtocol =   0xff,	/* vendor specific */
-	.iInterface =           STRING_RNDIS_CONTROL,
-};
-#endif
-
-#if defined(DEV_CONFIG_CDC) || defined(CONFIG_USB_ETH_RNDIS)
 
 /* "Header Functional Descriptor" from CDC spec  5.2.3.1 */
 struct header_desc {
@@ -459,13 +454,13 @@
 
 static const struct header_desc header_desc = {
 	.bLength =		sizeof header_desc,
-	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorType =	0x24,
 	.bDescriptorSubType =	0,
 
 	.bcdCDC =		__constant_cpu_to_le16 (0x0110),
 };
 
-/* "Union Functional Descriptor" from CDC spec 5.2.3.8 */
+/* "Union Functional Descriptor" from CDC spec 5.2.3.X */
 struct union_desc {
 	u8	bLength;
 	u8	bDescriptorType;
@@ -478,58 +473,13 @@
 
 static const struct union_desc union_desc = {
 	.bLength =		sizeof union_desc,
-	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorType =	0x24,
 	.bDescriptorSubType =	6,
 
 	.bMasterInterface0 =	0,	/* index of control interface */
 	.bSlaveInterface0 =	1,	/* index of DATA interface */
 };
 
-#endif	/* CDC || RNDIS */
-
-#ifdef	CONFIG_USB_ETH_RNDIS
-
-/* "Call Management Descriptor" from CDC spec  5.2.3.3 */
-struct call_mgmt_descriptor {
-	u8  bLength;
-	u8  bDescriptorType;
-	u8  bDescriptorSubType;
-
-	u8  bmCapabilities;
-	u8  bDataInterface;
-} __attribute__ ((packed));
-
-static const struct call_mgmt_descriptor call_mgmt_descriptor = {
-	.bLength =  		sizeof call_mgmt_descriptor,
-	.bDescriptorType = 	USB_DT_CS_INTERFACE,
-	.bDescriptorSubType = 	0x01,
-
-	.bmCapabilities = 	0x00,
-	.bDataInterface = 	0x01,
-};
-
-
-/* "Abstract Control Management Descriptor" from CDC spec  5.2.3.4 */
-struct acm_descriptor {
-	u8  bLength;
-	u8  bDescriptorType;
-	u8  bDescriptorSubType;
-
-	u8  bmCapabilities;
-} __attribute__ ((packed));
-
-static struct acm_descriptor acm_descriptor = {
-	.bLength =  		sizeof acm_descriptor,
-	.bDescriptorType = 	USB_DT_CS_INTERFACE,
-	.bDescriptorSubType = 	0x02,
-
-	.bmCapabilities = 	0X00,
-};
-
-#endif
-
-#ifdef	DEV_CONFIG_CDC
-
 /* "Ethernet Networking Functional Descriptor" from CDC spec 5.2.3.16 */
 struct ether_desc {
 	u8	bLength;
@@ -545,53 +495,41 @@
 
 static const struct ether_desc ether_desc = {
 	.bLength =		sizeof ether_desc,
-	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorType =	0x24,
 	.bDescriptorSubType =	0x0f,
 
 	/* this descriptor actually adds value, surprise! */
 	.iMACAddress =		STRING_ETHADDR,
 	.bmEthernetStatistics =	__constant_cpu_to_le32 (0), /* no statistics */
-	.wMaxSegmentSize =	__constant_cpu_to_le16 (ETH_FRAME_LEN),
+	.wMaxSegmentSize =	__constant_cpu_to_le16 (MAX_PACKET + ETH_HLEN),
 	.wNumberMCFilters =	__constant_cpu_to_le16 (0),
 	.bNumberPowerFilters =	0,
 };
 
-#endif
-
-#if defined(DEV_CONFIG_CDC) || defined(CONFIG_USB_ETH_RNDIS)
+#ifdef	EP_STATUS_NUM
 
-/* include the status endpoint if we can, even where it's optional.
- * use small wMaxPacketSize, since many "interrupt" endpoints have
- * very small fifos and it's no big deal if CDC_NOTIFY_SPEED_CHANGE
- * takes two packets.  also default to a big transfer interval, to
- * waste less bandwidth.
+/* include the status endpoint if we can, even though it's optional.
  *
- * some drivers (like Linux 2.4 cdc-ether!) "need" it to exist even
+ * some drivers (like current Linux cdc-ether!) "need" it to exist even
  * if they ignore the connect/disconnect notifications that real aether
  * can provide.  more advanced cdc configurations might want to support
  * encapsulated commands (vendor-specific, using control-OUT).
- *
- * RNDIS requires the status endpoint, since it uses that encapsulation
- * mechanism for its funky RPC scheme.
  */
  
-#define LOG2_STATUS_INTERVAL_MSEC	5	/* 1 << 5 == 32 msec */
-#define STATUS_BYTECOUNT		8	/* 8 byte header + data */
-
-static struct usb_endpoint_descriptor
+#define LOG2_STATUS_INTERVAL_MSEC	6
+#define STATUS_BYTECOUNT		16	/* 8 byte header + data */
+static const struct usb_endpoint_descriptor
 fs_status_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
-	.bEndpointAddress =	USB_DIR_IN,
+	.bEndpointAddress =	EP_STATUS_NUM | USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
 	.wMaxPacketSize =	__constant_cpu_to_le16 (STATUS_BYTECOUNT),
 	.bInterval =		1 << LOG2_STATUS_INTERVAL_MSEC,
 };
 #endif
 
-#ifdef	DEV_CONFIG_CDC
-
 /* the default data interface has no endpoints ... */
 
 static const struct usb_interface_descriptor
@@ -605,9 +543,10 @@
 	.bInterfaceClass =	USB_CLASS_CDC_DATA,
 	.bInterfaceSubClass =	0,
 	.bInterfaceProtocol =	0,
+	.iInterface =		STRING_DATA,
 };
 
-/* ... but the "real" data interface has two bulk endpoints */
+/* ... but the "real" data interface has two full speed bulk endpoints */
 
 static const struct usb_interface_descriptor
 data_intf = {
@@ -622,39 +561,16 @@
 	.bInterfaceProtocol =	0,
 	.iInterface =		STRING_DATA,
 };
-
-#endif
-
-#ifdef	CONFIG_USB_ETH_RNDIS
-
-/* RNDIS doesn't activate by changing to the "real" altsetting */
-
-static const struct usb_interface_descriptor
-rndis_data_intf = {
-	.bLength =		sizeof rndis_data_intf,
-	.bDescriptorType =	USB_DT_INTERFACE,
-
-	.bInterfaceNumber =	1,
-	.bAlternateSetting =	0,
-	.bNumEndpoints =	2,
-	.bInterfaceClass =	USB_CLASS_CDC_DATA,
-	.bInterfaceSubClass =	0,
-	.bInterfaceProtocol =	0,
-	.iInterface =		STRING_DATA,
-};
-
-#endif
-
-#ifdef DEV_CONFIG_SUBSET
+#else
 
 /*
- * "Simple" CDC-subset option is a simple vendor-neutral model that most
+ * "Minimalist" non-CDC option is a simple vendor-neutral model that most
  * full speed controllers can handle:  one interface, two bulk endpoints.
  */
 
 static const struct usb_interface_descriptor
-subset_data_intf = {
-	.bLength =		sizeof subset_data_intf,
+data_intf = {
+	.bLength =		sizeof data_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
 	.bInterfaceNumber =	0,
@@ -666,75 +582,47 @@
 	.iInterface =		STRING_DATA,
 };
 
-#endif	/* SUBSET */
+#endif	/* DEV_CONFIG_CDC */
 
 
-static struct usb_endpoint_descriptor
+static const struct usb_endpoint_descriptor
 fs_source_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
-	.bEndpointAddress =	USB_DIR_IN,
+	.bEndpointAddress =	EP_IN_NUM | USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16 (64),
 };
 
-static struct usb_endpoint_descriptor
+static const struct usb_endpoint_descriptor
 fs_sink_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
-	.bEndpointAddress =	USB_DIR_OUT,
+	.bEndpointAddress =	EP_OUT_NUM,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16 (64),
 };
 
-static const struct usb_descriptor_header *fs_eth_function [11] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
+static const struct usb_descriptor_header *fs_function [] = {
 #ifdef DEV_CONFIG_CDC
 	/* "cdc" mode descriptors */
 	(struct usb_descriptor_header *) &control_intf,
 	(struct usb_descriptor_header *) &header_desc,
 	(struct usb_descriptor_header *) &union_desc,
 	(struct usb_descriptor_header *) &ether_desc,
-	/* NOTE: status endpoint may need to be removed */
+#ifdef	EP_STATUS_NUM
 	(struct usb_descriptor_header *) &fs_status_desc,
-	/* data interface, with altsetting */
+#endif
 	(struct usb_descriptor_header *) &data_nop_intf,
-	(struct usb_descriptor_header *) &data_intf,
-	(struct usb_descriptor_header *) &fs_source_desc,
-	(struct usb_descriptor_header *) &fs_sink_desc,
-	NULL,
 #endif /* DEV_CONFIG_CDC */
-};
-
-static inline void __init fs_subset_descriptors(void)
-{
-#ifdef DEV_CONFIG_SUBSET
-	fs_eth_function[1] = (struct usb_descriptor_header *) &subset_data_intf;
-	fs_eth_function[2] = (struct usb_descriptor_header *) &fs_source_desc;
-	fs_eth_function[3] = (struct usb_descriptor_header *) &fs_sink_desc;
-	fs_eth_function[4] = NULL;
-#else
-	fs_eth_function[1] = NULL;
-#endif
-}
-
-#ifdef	CONFIG_USB_ETH_RNDIS
-static const struct usb_descriptor_header *fs_rndis_function [] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
-	/* control interface matches ACM, not Ethernet */
-	(struct usb_descriptor_header *) &rndis_control_intf,
-	(struct usb_descriptor_header *) &header_desc,
-	(struct usb_descriptor_header *) &call_mgmt_descriptor,
-	(struct usb_descriptor_header *) &acm_descriptor,
-	(struct usb_descriptor_header *) &union_desc,
-	(struct usb_descriptor_header *) &fs_status_desc,
-	/* data interface has no altsetting */
-	(struct usb_descriptor_header *) &rndis_data_intf,
+	/* minimalist core */
+	(struct usb_descriptor_header *) &data_intf,
 	(struct usb_descriptor_header *) &fs_source_desc,
 	(struct usb_descriptor_header *) &fs_sink_desc,
-	NULL,
+	0,
 };
-#endif
 
 #ifdef	CONFIG_USB_GADGET_DUALSPEED
 
@@ -743,34 +631,39 @@
  * descriptors, unless they only run at full speed.
  */
 
-#if defined(DEV_CONFIG_CDC) || defined(CONFIG_USB_ETH_RNDIS)
-static struct usb_endpoint_descriptor
+#ifdef	EP_STATUS_NUM
+static const struct usb_endpoint_descriptor
 hs_status_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
+	.bEndpointAddress =	EP_STATUS_NUM | USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
 	.wMaxPacketSize =	__constant_cpu_to_le16 (STATUS_BYTECOUNT),
-	.bInterval =		LOG2_STATUS_INTERVAL_MSEC + 4,
+	.bInterval =		LOG2_STATUS_INTERVAL_MSEC + 3,
 };
-#endif /* DEV_CONFIG_CDC */
+#endif
 
-static struct usb_endpoint_descriptor
+static const struct usb_endpoint_descriptor
 hs_source_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
+	.bEndpointAddress =	EP_IN_NUM | USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 	.wMaxPacketSize =	__constant_cpu_to_le16 (512),
+	.bInterval =		1,
 };
 
-static struct usb_endpoint_descriptor
+static const struct usb_endpoint_descriptor
 hs_sink_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
+	.bEndpointAddress =	EP_OUT_NUM,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 	.wMaxPacketSize =	__constant_cpu_to_le16 (512),
+	.bInterval =		1,
 };
 
 static struct usb_qualifier_descriptor
@@ -779,59 +672,29 @@
 	.bDescriptorType =	USB_DT_DEVICE_QUALIFIER,
 
 	.bcdUSB =		__constant_cpu_to_le16 (0x0200),
-	.bDeviceClass =		USB_CLASS_COMM,
+	.bDeviceClass =		DEV_CONFIG_CLASS,
 
 	.bNumConfigurations =	1,
 };
 
-static const struct usb_descriptor_header *hs_eth_function [11] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
+static const struct usb_descriptor_header *hs_function [] = {
 #ifdef DEV_CONFIG_CDC
 	/* "cdc" mode descriptors */
 	(struct usb_descriptor_header *) &control_intf,
 	(struct usb_descriptor_header *) &header_desc,
 	(struct usb_descriptor_header *) &union_desc,
 	(struct usb_descriptor_header *) &ether_desc,
-	/* NOTE: status endpoint may need to be removed */
+#ifdef	EP_STATUS_NUM
 	(struct usb_descriptor_header *) &hs_status_desc,
-	/* data interface, with altsetting */
+#endif
 	(struct usb_descriptor_header *) &data_nop_intf,
-	(struct usb_descriptor_header *) &data_intf,
-	(struct usb_descriptor_header *) &hs_source_desc,
-	(struct usb_descriptor_header *) &hs_sink_desc,
-	NULL,
 #endif /* DEV_CONFIG_CDC */
-};
-
-static inline void __init hs_subset_descriptors(void)
-{
-#ifdef DEV_CONFIG_SUBSET
-	hs_eth_function[1] = (struct usb_descriptor_header *) &subset_data_intf;
-	hs_eth_function[2] = (struct usb_descriptor_header *) &fs_source_desc;
-	hs_eth_function[3] = (struct usb_descriptor_header *) &fs_sink_desc;
-	hs_eth_function[4] = NULL;
-#else
-	hs_eth_function[1] = NULL;
-#endif
-}
-
-#ifdef	CONFIG_USB_ETH_RNDIS
-static const struct usb_descriptor_header *hs_rndis_function [] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
-	/* control interface matches ACM, not Ethernet */
-	(struct usb_descriptor_header *) &rndis_control_intf,
-	(struct usb_descriptor_header *) &header_desc,
-	(struct usb_descriptor_header *) &call_mgmt_descriptor,
-	(struct usb_descriptor_header *) &acm_descriptor,
-	(struct usb_descriptor_header *) &union_desc,
-	(struct usb_descriptor_header *) &hs_status_desc,
-	/* data interface has no altsetting */
-	(struct usb_descriptor_header *) &rndis_data_intf,
+	/* minimalist core */
+	(struct usb_descriptor_header *) &data_intf,
 	(struct usb_descriptor_header *) &hs_source_desc,
 	(struct usb_descriptor_header *) &hs_sink_desc,
-	NULL,
+	0,
 };
-#endif
 
 
 /* maxpacket and other transfer characteristics vary by speed. */
@@ -842,41 +705,26 @@
 /* if there's no high speed support, maxpacket doesn't change. */
 #define ep_desc(g,hs,fs) fs
 
-static inline void __init hs_subset_descriptors(void)
-{
-}
-
 #endif	/* !CONFIG_USB_GADGET_DUALSPEED */
 
 /*-------------------------------------------------------------------------*/
 
 /* descriptors that are built on-demand */
 
-static char				manufacturer [40];
-static char				product_desc [40] = DRIVER_DESC;
-
 #ifdef	DEV_CONFIG_CDC
 /* address that the host will use ... usually assigned at random */
 static char				ethaddr [2 * ETH_ALEN + 1];
 #endif
 
-/* static strings, in UTF-8 */
+/* static strings, in iso 8859/1 */
 static struct usb_string		strings [] = {
-	{ STRING_MANUFACTURER,	manufacturer, },
-	{ STRING_PRODUCT,	product_desc, },
-	{ STRING_DATA,		"Ethernet Data", },
+	{ STRING_MANUFACTURER,	UTS_SYSNAME " " UTS_RELEASE "/" CHIP, },
+	{ STRING_PRODUCT,	driver_desc, },
 #ifdef	DEV_CONFIG_CDC
-	{ STRING_CDC,		"CDC Ethernet", },
 	{ STRING_ETHADDR,	ethaddr, },
 	{ STRING_CONTROL,	"CDC Communications Control", },
 #endif
-#ifdef	DEV_CONFIG_SUBSET
-	{ STRING_SUBSET,	"CDC Ethernet Subset", },
-#endif
-#ifdef	CONFIG_USB_ETH_RNDIS
-	{ STRING_RNDIS,		"RNDIS", },
-	{ STRING_RNDIS_CONTROL,	"RNDIS Communications Control", },
-#endif
+	{ STRING_DATA,		"Ethernet Data", },
 	{  }		/* end of list */
 };
 
@@ -890,45 +738,23 @@
  * complications: class descriptors, and an altsetting.
  */
 static int
-config_buf (enum usb_device_speed speed,
-	u8 *buf, u8 type,
-	unsigned index, int is_otg)
-{
-	int					len;
-	const struct usb_config_descriptor	*config;
-	const struct usb_descriptor_header	**function;
+config_buf (enum usb_device_speed speed, u8 *buf, u8 type, unsigned index)
+{
+	int				len;
+	const struct usb_descriptor_header **function = fs_function;
 #ifdef CONFIG_USB_GADGET_DUALSPEED
 	int				hs = (speed == USB_SPEED_HIGH);
 
 	if (type == USB_DT_OTHER_SPEED_CONFIG)
 		hs = !hs;
-#define which_fn(t)	(hs ? hs_ ## t ## _function : fs_ ## t ## _function)
-#else
-#define	which_fn(t)	(fs_ ## t ## _function)
+	if (hs)
+		function = hs_function;
 #endif
 
-	if (index >= device_desc.bNumConfigurations)
+	/* a single configuration must always be index 0 */
+	if (index > 0)
 		return -EINVAL;
-
-#ifdef	CONFIG_USB_ETH_RNDIS
-	/* list the RNDIS config first, to make Microsoft's drivers
-	 * happy. DOCSIS 1.0 needs this too.
-	 */
-	if (device_desc.bNumConfigurations == 2 && index == 0) {
-		config = &rndis_config;
-		function = which_fn (rndis);
-	} else
-#endif
-	{
-		config = &eth_config;
-		function = which_fn (eth);
-	}
-
-	/* for now, don't advertise srp-only devices */
-	if (!is_otg)
-		function++;
-
-	len = usb_gadget_config_buf (config, buf, USB_BUFSIZ, function);
+	len = usb_gadget_config_buf (&eth_config, buf, USB_BUFSIZ, function);
 	if (len < 0)
 		return len;
 	((struct usb_config_descriptor *) buf)->bDescriptorType = type;
@@ -940,91 +766,6 @@
 static void eth_start (struct eth_dev *dev, int gfp_flags);
 static int alloc_requests (struct eth_dev *dev, unsigned n, int gfp_flags);
 
-#ifdef	DEV_CONFIG_CDC
-static inline int ether_alt_ep_setup (struct eth_dev *dev, struct usb_ep *ep)
-{
-	const struct usb_endpoint_descriptor	*d;
-
-	/* With CDC,  the host isn't allowed to use these two data
-	 * endpoints in the default altsetting for the interface.
-	 * so we don't activate them yet.  Reset from SET_INTERFACE.
-	 *
-	 * Strictly speaking RNDIS should work the same: activation is
-	 * a side effect of setting a packet filter.  Deactivation is
-	 * from REMOTE_NDIS_HALT_MSG, reset from REMOTE_NDIS_RESET_MSG.
-	 */
-
-	/* one endpoint writes data back IN to the host */
-	if (strcmp (ep->name, EP_IN_NAME) == 0) {
-		d = ep_desc (dev->gadget, &hs_source_desc, &fs_source_desc);
-		ep->driver_data = dev;
-		dev->in_ep = ep;
-		dev->in = d;
-
-	/* one endpoint just reads OUT packets */
-	} else if (strcmp (ep->name, EP_OUT_NAME) == 0) {
-		d = ep_desc (dev->gadget, &hs_sink_desc, &fs_sink_desc);
-		ep->driver_data = dev;
-		dev->out_ep = ep;
-		dev->out = d;
-
-	/* optional status/notification endpoint */
-	} else if (EP_STATUS_NAME &&
-			strcmp (ep->name, EP_STATUS_NAME) == 0) {
-		int			result;
-
-		d = ep_desc (dev->gadget, &hs_status_desc, &fs_status_desc);
-		result = usb_ep_enable (ep, d);
-		if (result < 0)
-			return result;
-
-		ep->driver_data = dev;
-		dev->status_ep = ep;
-		dev->status = d;
-	}
-	return 0;
-}
-#endif
-
-#if	defined(DEV_CONFIG_SUBSET) || defined(CONFIG_USB_ETH_RNDIS)
-static inline int ether_ep_setup (struct eth_dev *dev, struct usb_ep *ep)
-{
-	int					result;
-	const struct usb_endpoint_descriptor	*d;
-
-	/* CDC subset is simpler:  if the device is there,
-	 * it's live with rx and tx endpoints.
-	 *
-	 * Do this as a shortcut for RNDIS too.
-	 */
-
-	/* one endpoint writes data back IN to the host */
-	if (strcmp (ep->name, EP_IN_NAME) == 0) {
-		d = ep_desc (dev->gadget, &hs_source_desc, &fs_source_desc);
-		result = usb_ep_enable (ep, d);
-		if (result < 0)
-			return result;
-
-		ep->driver_data = dev;
-		dev->in_ep = ep;
-		dev->in = d;
-
-	/* one endpoint just reads OUT packets */
-	} else if (strcmp (ep->name, EP_OUT_NAME) == 0) {
-		d = ep_desc (dev->gadget, &hs_sink_desc, &fs_sink_desc);
-		result = usb_ep_enable (ep, d);
-		if (result < 0)
-			return result;
-
-		ep->driver_data = dev;
-		dev->out_ep = ep;
-		dev->out = d;
-	}
-
-	return 0;
-}
-#endif
-
 static int
 set_ether_config (struct eth_dev *dev, int gfp_flags)
 {
@@ -1033,17 +774,34 @@
 	struct usb_gadget	*gadget = dev->gadget;
 
 	gadget_for_each_ep (ep, gadget) {
+		const struct usb_endpoint_descriptor	*d;
+
 #ifdef	DEV_CONFIG_CDC
-		if (!dev->rndis && dev->cdc) {
-			result = ether_alt_ep_setup (dev, ep);
-			if (result == 0)
-				continue;
-		}
-#endif
+		/* With CDC,  the host isn't allowed to use these two data
+		 * endpoints in the default altsetting for the interface.
+		 * so we don't activate them yet.
+		 */
 
-#ifdef	CONFIG_USB_ETH_RNDIS
-		if (dev->rndis && strcmp (ep->name, EP_STATUS_NAME) == 0) {
-			const struct usb_endpoint_descriptor	*d;
+		/* one endpoint writes data back IN to the host */
+		if (strcmp (ep->name, EP_IN_NAME) == 0) {
+			d = ep_desc (gadget, &hs_source_desc, &fs_source_desc);
+			ep->driver_data = dev;
+			dev->in_ep = ep;
+			dev->in = d;
+			continue;
+
+		/* one endpoint just reads OUT packets */
+		} else if (strcmp (ep->name, EP_OUT_NAME) == 0) {
+			d = ep_desc (gadget, &hs_sink_desc, &fs_sink_desc);
+			ep->driver_data = dev;
+			dev->out_ep = ep;
+			dev->out = d;
+			continue;
+		}
+
+#ifdef	EP_STATUS_NUM
+		/* optional status/notification endpoint */
+		else if (strcmp (ep->name, EP_STATUS_NAME) == 0) {
 			d = ep_desc (gadget, &hs_status_desc, &fs_status_desc);
 			result = usb_ep_enable (ep, d);
 			if (result == 0) {
@@ -1052,17 +810,43 @@
 				dev->status = d;
 				continue;
 			}
-		} else
+		}
 #endif
 
-		{
-#if	defined(DEV_CONFIG_SUBSET) || defined(CONFIG_USB_ETH_RNDIS)
-			result = ether_ep_setup (dev, ep);
-			if (result == 0)
+#else	/* !CONFIG_CDC_ETHER */
+
+		/* non-CDC is simpler:  if the device is there,
+		 * it's live with rx and tx endpoints.
+		 */
+		/* one endpoint writes data back IN to the host */
+		if (strcmp (ep->name, EP_IN_NAME) == 0) {
+			d = ep_desc (gadget, &hs_source_desc, &fs_source_desc);
+			result = usb_ep_enable (ep, d);
+			if (result == 0) {
+				ep->driver_data = dev;
+				dev->in_ep = ep;
+				dev->in = d;
 				continue;
-#endif
+			}
+
+		/* one endpoint just reads OUT packets */
+		} else if (strcmp (ep->name, EP_OUT_NAME) == 0) {
+			d = ep_desc (gadget, &hs_sink_desc, &fs_sink_desc);
+			result = usb_ep_enable (ep, d);
+			if (result == 0) {
+				ep->driver_data = dev;
+				dev->out_ep = ep;
+				dev->out = d;
+				continue;
+			}
 		}
 
+#endif /* !CONFIG_CDC_ETHER */
+
+		/* ignore any other endpoints */
+		else
+			continue;
+
 		/* stop on error */
 		ERROR (dev, "can't enable %s, result %d\n", ep->name, result);
 		break;
@@ -1073,41 +857,23 @@
 	if (result == 0)
 		result = alloc_requests (dev, qlen (gadget), gfp_flags);
 
-	/* on error, disable any endpoints  */
-	if (result < 0) {
-#if defined(DEV_CONFIG_CDC) || defined(CONFIG_USB_ETH_RNDIS)
-		if (dev->status_ep)
-			(void) usb_ep_disable (dev->status_ep);
-#endif
-		dev->status_ep = NULL;
-		dev->status = NULL;
-#if defined(DEV_CONFIG_SUBSET) || defined(CONFIG_USB_ETH_RNDIS)
-		if (dev->rndis || !dev->cdc) {
-			if (dev->in_ep)
-				(void) usb_ep_disable (dev->in_ep);
-			if (dev->out_ep)
-				(void) usb_ep_disable (dev->out_ep);
-		}
-#endif
-		dev->in_ep = NULL;
-		dev->in = NULL;
-		dev->out_ep = NULL;
-		dev->out = NULL;
-	} else
-
-	/* activate non-CDC configs right away
-	 * this isn't strictly according to the RNDIS spec
-	 */
-#if defined(DEV_CONFIG_SUBSET) || defined(CONFIG_USB_ETH_RNDIS)
-	if (dev->rndis || !dev->cdc) {
+#ifndef	DEV_CONFIG_CDC
+	if (result == 0) {
 		netif_carrier_on (dev->net);
 		if (netif_running (dev->net)) {
 			spin_unlock (&dev->lock);
 			eth_start (dev, GFP_ATOMIC);
 			spin_lock (&dev->lock);
 		}
+	} else {
+		(void) usb_ep_disable (dev->in_ep);
+		dev->in_ep = 0;
+		dev->in = 0;
+		(void) usb_ep_disable (dev->out_ep);
+		dev->out_ep = 0;
+		dev->out = 0;
 	}
-#endif
+#endif /* !CONFIG_CDC_ETHER */
 
 	if (result == 0)
 		DEBUG (dev, "qlen %d\n", qlen (gadget));
@@ -1139,7 +905,7 @@
 			list_del (&req->list);
 			usb_ep_free_request (dev->in_ep, req);
 		}
-		dev->in_ep = NULL;
+		dev->in_ep = 0;
 	}
 	if (dev->out_ep) {
 		usb_ep_disable (dev->out_ep);
@@ -1149,13 +915,15 @@
 			list_del (&req->list);
 			usb_ep_free_request (dev->out_ep, req);
 		}
-		dev->out_ep = NULL;
+		dev->out_ep = 0;
 	}
 
+#ifdef	EP_STATUS_NUM
 	if (dev->status_ep) {
 		usb_ep_disable (dev->status_ep);
-		dev->status_ep = NULL;
+		dev->status_ep = 0;
 	}
+#endif
 	dev->config = 0;
 }
 
@@ -1171,29 +939,20 @@
 	if (number == dev->config)
 		return 0;
 
-	if (gadget_is_sa1100 (gadget)
-			&& dev->config
-			&& atomic_read (&dev->tx_qlen) != 0) {
+#ifdef CONFIG_USB_GADGET_SA1100
+	if (dev->config && atomic_read (&dev->tx_qlen) != 0) {
 		/* tx fifo is full, but we can't clear it...*/
 		INFO (dev, "can't change configurations\n");
 		return -ESPIPE;
 	}
+#endif
 	eth_reset_config (dev);
-
-	/* default:  pass all packets, no multicast filtering */
-	dev->cdc_filter = 0x000f;
+	hw_optimize (gadget);
 
 	switch (number) {
 	case DEV_CONFIG_VALUE:
-		dev->rndis = 0;
-		result = set_ether_config (dev, gfp_flags);
-		break;
-#ifdef	CONFIG_USB_ETH_RNDIS
-	case DEV_RNDIS_CONFIG_VALUE:
-		dev->rndis = 1;
 		result = set_ether_config (dev, gfp_flags);
 		break;
-#endif
 	default:
 		result = -EINVAL;
 		/* FALL THROUGH */
@@ -1215,29 +974,21 @@
 		}
 
 		dev->config = number;
-		INFO (dev, "%s speed config #%d: %s, using %s\n",
-				speed, number, driver_desc,
-				dev->rndis
-					? "RNDIS"
-					: (dev->cdc
-						? "CDC Ethernet"
-						: "CDC Ethernet Subset"));
+		INFO (dev, "%s speed config #%d: %s\n", speed, number,
+				driver_desc);
 	}
 	return result;
 }
 
 /*-------------------------------------------------------------------------*/
 
-/* section 3.8.2 table 11 of the CDC spec lists Ethernet notifications
- * section 3.6.2.1 table 5 specifies ACM notifications, accepted by RNDIS
- * and RNDIS also defines its own bit-incompatible notifications
- */
+#ifdef	EP_STATUS_NUM
+
+/* section 3.8.2 table 11 of the CDC spec lists Ethernet notifications */
 #define CDC_NOTIFY_NETWORK_CONNECTION	0x00	/* required; 6.3.1 */
 #define CDC_NOTIFY_RESPONSE_AVAILABLE	0x01	/* optional; 6.3.2 */
 #define CDC_NOTIFY_SPEED_CHANGE		0x2a	/* required; 6.3.8 */
 
-#ifdef	DEV_CONFIG_CDC
-
 struct cdc_notification {
 	u8	bmRequestType;
 	u8	bNotificationType;
@@ -1352,58 +1103,19 @@
 
 /* see section 3.8.2 table 10 of the CDC spec for more ethernet
  * requests, mostly for filters (multicast, pm) and statistics
- * section 3.6.2.1 table 4 has ACM requests; RNDIS requires the
- * encapsulated command mechanism.
  */
-#define CDC_SEND_ENCAPSULATED_COMMAND		0x00	/* optional */
-#define CDC_GET_ENCAPSULATED_RESPONSE		0x01	/* optional */
-#define CDC_SET_ETHERNET_MULTICAST_FILTERS	0x40	/* optional */
-#define CDC_SET_ETHERNET_PM_PATTERN_FILTER	0x41	/* optional */
-#define CDC_GET_ETHERNET_PM_PATTERN_FILTER	0x42	/* optional */
-#define CDC_SET_ETHERNET_PACKET_FILTER		0x43	/* required */
-#define CDC_GET_ETHERNET_STATISTIC		0x44	/* optional */
-
-/* table 62; bits in cdc_filter */
-#define	CDC_PACKET_TYPE_PROMISCUOUS		(1 << 0)
-#define	CDC_PACKET_TYPE_ALL_MULTICAST		(1 << 1) /* no filter */
-#define	CDC_PACKET_TYPE_DIRECTED		(1 << 2)
-#define	CDC_PACKET_TYPE_BROADCAST		(1 << 3)
-#define	CDC_PACKET_TYPE_MULTICAST		(1 << 4) /* filtered */
-
-#ifdef CONFIG_USB_ETH_RNDIS
-
-static void rndis_response_complete (struct usb_ep *ep, struct usb_request *req)
-{
-	if (req->status || req->actual != req->length)
-		DEBUG (dev, "rndis response complete --> %d, %d/%d\n",
-		       req->status, req->actual, req->length);
-
-	/* done sending after CDC_GET_ENCAPSULATED_RESPONSE */
-}
-
-static void rndis_command_complete (struct usb_ep *ep, struct usb_request *req)
-{
-	struct eth_dev          *dev = ep->driver_data;
-	int			status;
-	
-	/* received RNDIS command from CDC_SEND_ENCAPSULATED_COMMAND */
-	spin_lock(&dev->lock);
-	status = rndis_msg_parser (dev->rndis_config, (u8 *) req->buf);
-	if (status < 0)
-		ERROR(dev, "%s: rndis parse error %d\n", __FUNCTION__, status);
-	spin_unlock(&dev->lock);
-}
-
-#endif	/* RNDIS */
+#define CDC_SEND_ENCAPSULATED_REQUEST	0x00	/* optional */
+#define CDC_GET_ENCAPSULATED_RESPONSE	0x01	/* optional */
+#define CDC_SET_ETHERNET_PACKET_FILTER	0x43	/* required */
 
 /*
  * The setup() callback implements all the ep0 functionality that's not
  * handled lower down.  CDC has a number of less-common features:
  *
  *  - two interfaces:  control, and ethernet data
- *  - Ethernet data interface has two altsettings:  default, and active
+ *  - data interface has two altsettings:  default, and active
  *  - class-specific descriptors for the control interface
- *  - class-specific control requests
+ *  - a mandatory class-specific control request
  */
 static int
 eth_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
@@ -1415,7 +1127,6 @@
 	/* descriptors just go into the pre-allocated ep0 buffer,
 	 * while config change events may enable network traffic.
 	 */
-	req->complete = eth_setup_complete;
 	switch (ctrl->bRequest) {
 
 	case USB_REQ_GET_DESCRIPTOR:
@@ -1443,8 +1154,7 @@
 		case USB_DT_CONFIG:
 			value = config_buf (gadget->speed, req->buf,
 					ctrl->wValue >> 8,
-					ctrl->wValue & 0xff,
-					gadget->is_otg);
+					ctrl->wValue & 0xff);
 			if (value >= 0)
 				value = min (ctrl->wLength, (u16) value);
 			break;
@@ -1461,14 +1171,21 @@
 	case USB_REQ_SET_CONFIGURATION:
 		if (ctrl->bRequestType != 0)
 			break;
-		if (gadget->a_hnp_support)
-			DEBUG (dev, "HNP available\n");
-		else if (gadget->a_alt_hnp_support)
-			DEBUG (dev, "HNP needs a different root port\n");
 		spin_lock (&dev->lock);
 		value = eth_set_config (dev, ctrl->wValue, GFP_ATOMIC);
 		spin_unlock (&dev->lock);
 		break;
+#ifdef	CONFIG_USB_GADGET_PXA2XX
+	/* PXA UDC prevents us from using SET_INTERFACE in normal ways.
+	 * And it hides GET_CONFIGURATION and GET_INTERFACE too.
+	 */
+	case USB_REQ_SET_INTERFACE:
+		spin_lock (&dev->lock);
+		value = eth_set_config (dev, DEV_CONFIG_VALUE, GFP_ATOMIC);
+		spin_unlock (&dev->lock);
+		break;
+
+#else	/* hardware that that stays out of our way */
 	case USB_REQ_GET_CONFIGURATION:
 		if (ctrl->bRequestType != USB_DIR_IN)
 			break;
@@ -1481,28 +1198,17 @@
 				|| !dev->config
 				|| ctrl->wIndex > 1)
 			break;
-		if (!dev->cdc && ctrl->wIndex != 0)
-			break;
 		spin_lock (&dev->lock);
-
-		/* PXA hardware partially handles SET_INTERFACE;
-		 * we need to kluge around that interference.
-		 */
-		if (gadget_is_pxa (gadget)) {
-			value = eth_set_config (dev, DEV_CONFIG_VALUE,
-						GFP_ATOMIC);
-			goto done_set_intf;
-		}
-
-#ifdef DEV_CONFIG_CDC
 		switch (ctrl->wIndex) {
 		case 0:		/* control/master intf */
 			if (ctrl->wValue != 0)
 				break;
+#ifdef	EP_STATUS_NUM
 			if (dev->status_ep) {
 				usb_ep_disable (dev->status_ep);
 				usb_ep_enable (dev->status_ep, dev->status);
 			}
+#endif
 			value = 0;
 			break;
 		case 1:		/* data intf */
@@ -1519,8 +1225,9 @@
 				usb_ep_enable (dev->in_ep, dev->in);
 				usb_ep_enable (dev->out_ep, dev->out);
 				netif_carrier_on (dev->net);
-				if (dev->status_ep)
-					issue_start_status (dev);
+#ifdef	EP_STATUS_NUM
+				issue_start_status (dev);
+#endif
 				if (netif_running (dev->net)) {
 					spin_unlock (&dev->lock);
 					eth_start (dev, GFP_ATOMIC);
@@ -1533,14 +1240,6 @@
 			value = 0;
 			break;
 		}
-#else
-		/* FIXME this is wrong, as is the assumption that
-		 * all non-PXA hardware talks real CDC ...
-		 */
-		dev_warn (&gadget->dev, "set_interface ignored!\n");
-#endif /* DEV_CONFIG_CDC */
-
-done_set_intf:
 		spin_unlock (&dev->lock);
 		break;
 	case USB_REQ_GET_INTERFACE:
@@ -1548,16 +1247,15 @@
 				|| !dev->config
 				|| ctrl->wIndex > 1)
 			break;
-		if (!(dev->cdc || dev->rndis) && ctrl->wIndex != 0)
-			break;
 
-		/* for CDC, iff carrier is on, data interface is active. */
-		if (dev->rndis || ctrl->wIndex != 1)
-			*(u8 *)req->buf = 0;
-		else
-			*(u8 *)req->buf = netif_carrier_ok (dev->net) ? 1 : 0;
+		/* if carrier is on, data interface is active. */
+		*(u8 *)req->buf =
+			((ctrl->wIndex == 1) && netif_carrier_ok (dev->net))
+				? 1
+				: 0,
 		value = min (ctrl->wLength, (u16) 1);
 		break;
+#endif
 
 #ifdef DEV_CONFIG_CDC
 	case CDC_SET_ETHERNET_PACKET_FILTER:
@@ -1565,62 +1263,17 @@
 		 * wValue = packet filter bitmap
 		 */
 		if (ctrl->bRequestType != (USB_TYPE_CLASS|USB_RECIP_INTERFACE)
-				|| !dev->cdc
-				|| dev->rndis
 				|| ctrl->wLength != 0
 				|| ctrl->wIndex > 1)
-			break;
 		DEBUG (dev, "NOP packet filter %04x\n", ctrl->wValue);
 		/* NOTE: table 62 has 5 filter bits to reduce traffic,
 		 * and we "must" support multicast and promiscuous.
-		 * this NOP implements a bad filter (always promisc)
+		 * this NOP implements a bad filter...
 		 */
-		dev->cdc_filter = ctrl->wValue;
 		value = 0;
 		break;
 #endif /* DEV_CONFIG_CDC */
 
-#ifdef CONFIG_USB_ETH_RNDIS		
-	/* RNDIS uses the CDC command encapsulation mechanism to implement
-	 * an RPC scheme, with much getting/setting of attributes by OID.
-	 */
-	case CDC_SEND_ENCAPSULATED_COMMAND:
-		if (ctrl->bRequestType != (USB_TYPE_CLASS|USB_RECIP_INTERFACE)
-				|| !dev->rndis
-				|| ctrl->wLength > USB_BUFSIZ
-				|| ctrl->wValue
-				|| rndis_control_intf.bInterfaceNumber
-					!= ctrl->wIndex)
-			break;
-		/* read the request, then process it */
-		value = ctrl->wLength;
-		req->complete = rndis_command_complete;
-		/* later, rndis_control_ack () sends a notification */
-		break;
-		
-	case CDC_GET_ENCAPSULATED_RESPONSE:
-		if ((USB_DIR_IN|USB_TYPE_CLASS|USB_RECIP_INTERFACE)
-					== ctrl->bRequestType
-				&& dev->rndis
-				// && ctrl->wLength >= 0x0400
-				&& !ctrl->wValue
-				&& rndis_control_intf.bInterfaceNumber
-					== ctrl->wIndex) {
-			u8 *buf;
-
-			/* return the result */
-			buf = rndis_get_next_response (dev->rndis_config,
-						       &value);
-			if (buf) {
-				memcpy (req->buf, buf, value);
-				req->complete = rndis_response_complete;
-				rndis_free_response(dev->rndis_config, buf);
-			}
-			/* else stalls ... spec says to avoid that */
-		}
-		break;
-#endif	/* RNDIS */
-
 	default:
 		VDEBUG (dev,
 			"unknown control req%02x.%02x v%04x i%04x l%d\n",
@@ -1631,8 +1284,6 @@
 	/* respond with data transfer before status phase? */
 	if (value >= 0) {
 		req->length = value;
-		req->zero = value < ctrl->wLength
-				&& (value % gadget->ep0->maxpacket) == 0;
 		value = usb_ep_queue (gadget->ep0, req, GFP_ATOMIC);
 		if (value < 0) {
 			DEBUG (dev, "ep_queue --> %d\n", value);
@@ -1657,8 +1308,6 @@
 	eth_reset_config (dev);
 	spin_unlock_irqrestore (&dev->lock, flags);
 
-	/* FIXME RNDIS should enter RNDIS_UNINITIALIZED */
-
 	/* next we may get setup() calls to enumerate new connections;
 	 * or an unbind() during shutdown (including removing module).
 	 */
@@ -1672,9 +1321,7 @@
 {
 	struct eth_dev	*dev = (struct eth_dev *) net->priv;
 
-	// FIXME if rndis, don't change while link's live
-
-	if (new_mtu <= ETH_HLEN || new_mtu > ETH_FRAME_LEN)
+	if (new_mtu <= MIN_PACKET || new_mtu > MAX_PACKET)
 		return -ERANGE;
 	/* no zero-length packet read wanted after mtu-sized packets */
 	if (((new_mtu + sizeof (struct ethhdr)) % dev->in_ep->maxpacket) == 0)
@@ -1688,12 +1335,12 @@
 	return &((struct eth_dev *) net->priv)->stats;
 }
 
-static int eth_ethtool_ioctl (struct net_device *net, void __user *useraddr)
+static int eth_ethtool_ioctl (struct net_device *net, void *useraddr)
 {
 	struct eth_dev	*dev = (struct eth_dev *) net->priv;
 	u32		cmd;
 
-	if (get_user (cmd, (u32 __user *)useraddr))
+	if (get_user (cmd, (u32 *)useraddr))
 		return -EFAULT;
 	switch (cmd) {
 
@@ -1704,8 +1351,7 @@
 		info.cmd = ETHTOOL_GDRVINFO;
 		strlcpy (info.driver, shortname, sizeof info.driver);
 		strlcpy (info.version, DRIVER_VERSION, sizeof info.version);
-		strlcpy (info.fw_version, dev->gadget->name,
-			sizeof info.fw_version);
+		strlcpy (info.fw_version, CHIP, sizeof info.fw_version);
 		strlcpy (info.bus_info, dev->gadget->dev.bus_id,
 			sizeof info.bus_info);
 		if (copy_to_user (useraddr, &info, sizeof (info)))
@@ -1731,7 +1377,7 @@
 {
 	switch (cmd) {
 	case SIOCETHTOOL:
-		return eth_ethtool_ioctl(net, rq->ifr_data);
+		return eth_ethtool_ioctl (net, (void *)rq->ifr_data);
 	default:
 		return -EOPNOTSUPP;
 	}
@@ -1756,24 +1402,7 @@
 	int			retval = -ENOMEM;
 	size_t			size;
 
-	/* Padding up to RX_EXTRA handles minor disagreements with host.
-	 * Normally we use the USB "terminate on short read" convention;
-	 * so allow up to (N*maxpacket), since that memory is normally
-	 * already allocated.  Some hardware doesn't deal well with short
-	 * reads (e.g. DMA must be N*maxpacket), so for now don't trim a
-	 * byte off the end (to force hardware errors on overflow).
-	 *
-	 * RNDIS uses internal framing, and explicitly allows senders to
-	 * pad to end-of-packet.  That's potentially nice for speed,
-	 * but means receivers can't recover synch on their own.
-	 */
 	size = (sizeof (struct ethhdr) + dev->net->mtu + RX_EXTRA);
-	size += dev->out_ep->maxpacket - 1;
-#ifdef CONFIG_USB_ETH_RNDIS
-	if (dev->rndis)
-		size += sizeof (struct rndis_packet_msg_type);
-#endif	
-	size -= size % dev->out_ep->maxpacket;
 
 	if ((skb = alloc_skb (size, gfp_flags)) == 0) {
 		DEBUG (dev, "no rx skb\n");
@@ -1810,12 +1439,8 @@
 	/* normal completion */
 	case 0:
 		skb_put (skb, req->actual);
-#ifdef CONFIG_USB_ETH_RNDIS
-		/* we know MaxPacketsPerTransfer == 1 here */
-		if (dev->rndis)
-			rndis_rm_hdr (req->buf, &(skb->len));
-#endif
-		if (ETH_HLEN > skb->len || skb->len > ETH_FRAME_LEN) {
+		if (MIN_PACKET > skb->len
+				|| skb->len > (MAX_PACKET + ETH_HLEN)) {
 			dev->stats.rx_errors++;
 			dev->stats.rx_length_errors++;
 			DEBUG (dev, "rx length %d\n", skb->len);
@@ -1831,7 +1456,7 @@
 		 * use skb buffers.
 		 */
 		status = netif_rx (skb);
-		skb = NULL;
+		skb = 0;
 		break;
 
 	/* software-driven interface shutdown */
@@ -1865,7 +1490,7 @@
 clean:
 		/* nobody reading rx_reqs, so no dev->lock */
 		list_add (&req->list, &dev->rx_reqs);
-		req = NULL;
+		req = 0;
 	}
 	if (req)
 		rx_submit (dev, req, GFP_ATOMIC);
@@ -2000,14 +1625,9 @@
 	struct eth_dev		*dev = (struct eth_dev *) net->priv;
 	int			length = skb->len;
 	int			retval;
-	struct usb_request	*req = NULL;
+	struct usb_request	*req = 0;
 	unsigned long		flags;
 
-	/* FIXME check dev->cdc_filter to decide whether to send this,
-	 * instead of acting as if CDC_PACKET_TYPE_PROMISCUOUS were
-	 * always set.  RNDIS has the same kind of outgoing filter.
-	 */
-
 	spin_lock_irqsave (&dev->lock, flags);
 	req = container_of (dev->tx_reqs.next, struct usb_request, list);
 	list_del (&req->list);
@@ -2017,35 +1637,21 @@
 
 	/* no buffer copies needed, unless the network stack did it
 	 * or the hardware can't use skb buffers.
-	 * or there's not enough space for any RNDIS headers we need
 	 */
-#ifdef CONFIG_USB_ETH_RNDIS
-	if (dev->rndis) {
-		struct sk_buff	*skb_rndis;
-
-		skb_rndis = skb_realloc_headroom (skb,
-				sizeof (struct rndis_packet_msg_type));
-		if (!skb_rndis)
-			goto drop;
-	
-		dev_kfree_skb_any (skb);
-		skb = skb_rndis;
-		rndis_add_hdr (skb);
-		length = skb->len;
-	}
-#endif
 	req->buf = skb->data;
 	req->context = skb;
 	req->complete = tx_complete;
 
+#ifdef	CONFIG_USB_GADGET_SA1100
+	/* don't demand zlp (req->zero) support from all hardware */
+	if ((length % dev->in_ep->maxpacket) == 0)
+		length++;
+#else
 	/* use zlp framing on tx for strict CDC-Ether conformance,
 	 * though any robust network rx path ignores extra padding.
-	 * and some hardware doesn't like to write zlps.
 	 */
 	req->zero = 1;
-	if (!dev->zlp && (length % dev->in_ep->maxpacket) == 0)
-		length++;
-
+#endif
 	req->length = length;
 
 #ifdef	CONFIG_USB_GADGET_DUALSPEED
@@ -2066,9 +1672,6 @@
 	}
 
 	if (retval) {
-#ifdef CONFIG_USB_ETH_RNDIS
-drop:
-#endif
 		dev->stats.tx_dropped++;
 		dev_kfree_skb_any (skb);
 		spin_lock_irqsave (&dev->lock, flags);
@@ -2080,81 +1683,6 @@
 	return 0;
 }
 
-/*-------------------------------------------------------------------------*/
-
-#ifdef CONFIG_USB_ETH_RNDIS
-
-static void rndis_send_media_state (struct eth_dev *dev, int connect)
-{
-	if (!dev)
-		return;
-	
-	if (connect) {
-		if (rndis_signal_connect (dev->rndis_config))
-			return;
-	} else {
-		if (rndis_signal_disconnect (dev->rndis_config))
-			return;
-	}
-}
-
-static void rndis_control_ack_complete (struct usb_ep *ep, struct usb_request *req)
-{
-	if (req->status || req->actual != req->length)
-		DEBUG (dev, "rndis control ack complete --> %d, %d/%d\n",
-		       req->status, req->actual, req->length);
-
-	usb_ep_free_buffer(ep, req->buf, req->dma, 8);
-	usb_ep_free_request(ep, req);
-}
-
-static int rndis_control_ack (struct net_device *net)
-{
-	struct eth_dev          *dev = (struct eth_dev *) net->priv;
-	u32                     length;
-	struct usb_request      *resp;
-	
-	/* in case RNDIS calls this after disconnect */
-	if (!dev->status_ep) {
-		DEBUG (dev, "status ENODEV\n");
-		return -ENODEV;
-	}
-
-	/* Allocate memory for notification ie. ACK */
-	resp = usb_ep_alloc_request (dev->status_ep, GFP_ATOMIC);
-	if (!resp) {
-		DEBUG (dev, "status ENOMEM\n");
-		return -ENOMEM;
-	}
-	
-	resp->buf = usb_ep_alloc_buffer (dev->status_ep, 8,
-					 &resp->dma, GFP_ATOMIC);
-	if (!resp->buf) {
-		DEBUG (dev, "status buf ENOMEM\n");
-		usb_ep_free_request (dev->status_ep, resp);
-		return -ENOMEM;
-	}
-	
-	/* Send RNDIS RESPONSE_AVAILABLE notification;
-	 * CDC_NOTIFY_RESPONSE_AVAILABLE should work too
-	 */
-	resp->length = 8;
-	resp->complete = rndis_control_ack_complete;
-	
-	*((u32 *) resp->buf) = __constant_cpu_to_le32 (1);
-	*((u32 *) resp->buf + 1) = __constant_cpu_to_le32 (0);
-	
-	length = usb_ep_queue (dev->status_ep, resp, GFP_ATOMIC);
-	if (length < 0) {
-		resp->status = 0;
-		rndis_control_ack_complete (dev->status_ep, resp);
-	}
-	
-	return 0;
-}
-
-#endif	/* RNDIS */
-
 static void eth_start (struct eth_dev *dev, int gfp_flags)
 {
 	DEBUG (dev, "%s\n", __FUNCTION__);
@@ -2165,14 +1693,6 @@
 	/* and open the tx floodgates */ 
 	atomic_set (&dev->tx_qlen, 0);
 	netif_wake_queue (dev->net);
-#ifdef CONFIG_USB_ETH_RNDIS
-	if (dev->rndis) {
-		rndis_set_param_medium (dev->rndis_config,
-					NDIS_MEDIUM_802_3,
-					BITRATE(dev->gadget));
-		rndis_send_media_state (dev, 1);
-	}
-#endif	
 }
 
 static int eth_open (struct net_device *net)
@@ -2207,19 +1727,11 @@
 			usb_ep_enable (dev->in_ep, dev->in);
 			usb_ep_enable (dev->out_ep, dev->out);
 		}
-		if (dev->status_ep) {
-			usb_ep_disable (dev->status_ep);
-			usb_ep_enable (dev->status_ep, dev->status);
-		}
-	}
-	
-#ifdef	CONFIG_USB_ETH_RNDIS
-	if (dev->rndis) {
-		rndis_set_param_medium (dev->rndis_config,
-					NDIS_MEDIUM_802_3, 0);
-		rndis_send_media_state (dev, 0);
-	}
+#ifdef	EP_STATUS_NUM
+		usb_ep_disable (dev->status_ep);
+		usb_ep_enable (dev->status_ep, dev->status);
 #endif
+	}
 
 	return 0;
 }
@@ -2232,10 +1744,6 @@
 	struct eth_dev		*dev = get_gadget_data (gadget);
 
 	DEBUG (dev, "unbind\n");
-#ifdef CONFIG_USB_ETH_RNDIS
-	rndis_deregister (dev->rndis_config);
-	rndis_exit ();
-#endif
 
 	/* we've already been disconnected ... no i/o is active */
 	if (dev->req) {
@@ -2243,7 +1751,7 @@
 				dev->req->buf, dev->req->dma,
 				USB_BUFSIZ);
 		usb_ep_free_request (gadget->ep0, dev->req);
-		dev->req = NULL;
+		dev->req = 0;
 	}
 
 	unregister_netdev (dev->net);
@@ -2251,225 +1759,33 @@
 
 	/* assuming we used keventd, it must quiesce too */
 	flush_scheduled_work ();
-	set_gadget_data (gadget, NULL);
+	set_gadget_data (gadget, 0);
 }
 
-static u8 __init nibble (unsigned char c)
-{
-	if (likely (isdigit (c)))
-		return c - '0';
-	c = toupper (c);
-	if (likely (isxdigit (c)))
-		return 10 + c - 'A';
-	return 0;
-}
-
-static void __init get_ether_addr (const char *str, u8 *dev_addr)
-{
-	if (str) {
-		unsigned	i;
-
-		for (i = 0; i < 6; i++) {
-			unsigned char num;
-
-			if((*str == '.') || (*str == ':'))
-				str++;
-			num = nibble(*str++) << 4;
-			num |= (nibble(*str++));
-			dev_addr [i] = num;
-		}
-		if (is_valid_ether_addr (dev_addr))
-			return;
-	}
-	random_ether_addr(dev_addr);
-}
-
-static int __init
+static int
 eth_bind (struct usb_gadget *gadget)
 {
 	struct eth_dev		*dev;
 	struct net_device	*net;
-	u8			cdc = 1, zlp = 1, rndis = 1;
-	struct usb_ep		*ep;
 	int			status = -ENOMEM;
+#ifdef	DEV_CONFIG_CDC
+	u8			node_id [ETH_ALEN];
 
-	/* these flags are only ever cleared; compiler take note */
-#ifndef	DEV_CONFIG_CDC
-	cdc = 0;
-#endif
-#ifndef	CONFIG_USB_ETH_RNDIS
-	rndis = 0;
-#endif
-
-	/* Because most host side USB stacks handle CDC Ethernet, that
-	 * standard protocol is _strongly_ preferred for interop purposes.
-	 * (By everyone except Microsoft.)
-	 */
-	if (gadget_is_net2280 (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0201);
-	} else if (gadget_is_dummy (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0202);
-	} else if (gadget_is_pxa (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0203);
-		/* pxa doesn't support altsettings */
-		cdc = 0;
-	} else if (gadget_is_sh(gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0204);
-		/* sh doesn't support multiple interfaces or configs */
-		cdc = 0;
-		rndis = 0;
-	} else if (gadget_is_sa1100 (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0205);
-		/* hardware can't write zlps */
-		zlp = 0;
-		/* sa1100 CAN do CDC, without status endpoint ... we use
-		 * non-CDC to be compatible with ARM Linux-2.4 "usb-eth".
-		 */
-		cdc = 0;
-	} else if (gadget_is_goku (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0206);
-	} else if (gadget_is_mq11xx (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0207);
-	} else if (gadget_is_omap (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0208);
-	} else if (gadget_is_lh7a40x(gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0209);
-	} else {
-		/* can't assume CDC works.  don't want to default to
-		 * anything less functional on CDC-capable hardware,
-		 * so we fail in this case.
-		 */
-		dev_err (&gadget->dev,
-			"controller '%s' not recognized\n",
-			gadget->name);
-		return -ENODEV;
-	}
-	snprintf (manufacturer, sizeof manufacturer,
-		UTS_SYSNAME " " UTS_RELEASE "/%s",
-		gadget->name);
-
-	/* If there's an RNDIS configuration, that's what Windows wants to
-	 * be using ... so use these product IDs here and in the "linux.inf"
-	 * needed to install MSFT drivers.  Current Linux kernels will use
-	 * the second configuration if it's CDC Ethernet, and need some help
-	 * to choose the right configuration otherwise.
-	 */
-	if (rndis) {
-		device_desc.idVendor =
-			__constant_cpu_to_le16(RNDIS_VENDOR_NUM);
-		device_desc.idProduct =
-			__constant_cpu_to_le16(RNDIS_PRODUCT_NUM);
-		snprintf (product_desc, sizeof product_desc,
-			"RNDIS/%s", driver_desc);
-
-	/* CDC subset ... recognized by Linux since 2.4.10, but Windows
-	 * drivers aren't widely available.
-	 */
-	} else if (!cdc) {
-		device_desc.bDeviceClass = USB_CLASS_VENDOR_SPEC;
-		device_desc.idVendor =
-			__constant_cpu_to_le16(SIMPLE_VENDOR_NUM);
-		device_desc.idProduct =
-			__constant_cpu_to_le16(SIMPLE_PRODUCT_NUM);
-	}
-
-	/* support optional vendor/distro customization */
-	if (idVendor) {
-		if (!idProduct) {
-			dev_err (&gadget->dev, "idVendor needs idProduct!\n");
-			return -ENODEV;
-		}
-		device_desc.idVendor = cpu_to_le16(idVendor);
-		device_desc.idProduct = cpu_to_le16(idProduct);
-		if (bcdDevice)
-			device_desc.bcdDevice = cpu_to_le16(bcdDevice);
-	}
-	if (iManufacturer)
-		strlcpy (manufacturer, iManufacturer, sizeof manufacturer);
-	if (iProduct)
-		strlcpy (product_desc, iProduct, sizeof product_desc);
-
-	/* all we really need is bulk IN/OUT */
-	usb_ep_autoconfig_reset (gadget);
-	ep = usb_ep_autoconfig (gadget, &fs_source_desc);
-	if (!ep) {
-autoconf_fail:
-		dev_err (&gadget->dev,
-			"can't autoconfigure on %s\n",
-			gadget->name);
+	/* just one upstream link at a time */
+	if (ethaddr [0] != 0)
 		return -ENODEV;
-	}
-	EP_IN_NAME = ep->name;
-	ep->driver_data = ep;	/* claim */
-	
-	ep = usb_ep_autoconfig (gadget, &fs_sink_desc);
-	if (!ep)
-		goto autoconf_fail;
-	EP_OUT_NAME = ep->name;
-	ep->driver_data = ep;	/* claim */
-
-#if defined(DEV_CONFIG_CDC) || defined(CONFIG_USB_ETH_RNDIS)
-	/* CDC Ethernet control interface doesn't require a status endpoint.
-	 * Since some hosts expect one, try to allocate one anyway.
-	 */
-	if (cdc || rndis) {
-		ep = usb_ep_autoconfig (gadget, &fs_status_desc);
-		if (ep) {
-			EP_STATUS_NAME = ep->name;
-			ep->driver_data = ep;	/* claim */
-		} else if (rndis) {
-			dev_err (&gadget->dev,
-				"can't run RNDIS on %s\n",
-				gadget->name);
-			return -ENODEV;
-		} else if (cdc) {
-			control_intf.bNumEndpoints = 0;
-			/* FIXME remove endpoint from descriptor list */
-		}
-	}
 #endif
 
-	/* one config:  cdc, else minimal subset */
-	if (!cdc) {
-		eth_config.bNumInterfaces = 1;
-		eth_config.iConfiguration = STRING_SUBSET;
-		fs_subset_descriptors();
-		hs_subset_descriptors();
-	}
-
-	/* For now RNDIS is always a second config */
-	if (rndis)
-		device_desc.bNumConfigurations = 2;
-
+	device_desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
 #ifdef	CONFIG_USB_GADGET_DUALSPEED
-	if (rndis)
-		dev_qualifier.bNumConfigurations = 2;
-	else if (!cdc)
-		dev_qualifier.bDeviceClass = USB_CLASS_VENDOR_SPEC;
-
 	/* assumes ep0 uses the same value for both speeds ... */
 	dev_qualifier.bMaxPacketSize0 = device_desc.bMaxPacketSize0;
-
-	/* and that all endpoints are dual-speed */
-	hs_source_desc.bEndpointAddress = fs_source_desc.bEndpointAddress;
-	hs_sink_desc.bEndpointAddress = fs_sink_desc.bEndpointAddress;
-#if defined(DEV_CONFIG_CDC) || defined(CONFIG_USB_ETH_RNDIS)
-	if (EP_STATUS_NAME)
-		hs_status_desc.bEndpointAddress =
-				fs_status_desc.bEndpointAddress;
 #endif
-#endif	/* DUALSPEED */
 
-	device_desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
+#ifdef	SELFPOWERED
+	eth_config.bmAttributes |= USB_CONFIG_ATT_SELFPOWERED;
 	usb_gadget_set_selfpowered (gadget);
-
-	if (gadget->is_otg) {
-		otg_descriptor.bmAttributes |= USB_OTG_HNP,
-		eth_config.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-#ifdef	CONFIG_USB_ETH_RNDIS
-		rndis_config.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 #endif
-	}
 
  	net = alloc_etherdev (sizeof *dev);
  	if (!net)
@@ -2484,32 +1800,25 @@
 	dev->net = net;
 	SET_MODULE_OWNER (net);
 	strcpy (net->name, "usb%d");
-	dev->cdc = cdc;
-	dev->zlp = zlp;
 
-	/* Module params for these addresses should come from ID proms.
-	 * The host side address is used with CDC and RNDIS, and commonly
-	 * ends up in a persistent config database.
+	/* one random address for the gadget device ... both of these could
+	 * reasonably come from an id prom or a module parameter.
 	 */
-	get_ether_addr(dev_addr, net->dev_addr);
-	if (cdc || rndis) {
-		get_ether_addr(host_addr, dev->host_mac);
+	get_random_bytes (net->dev_addr, ETH_ALEN);
+	net->dev_addr [0] &= 0xfe;	// clear multicast bit
+	net->dev_addr [0] |= 0x02;	// set local assignment bit (IEEE802)
+
 #ifdef	DEV_CONFIG_CDC
-		snprintf (ethaddr, sizeof ethaddr, "%02X%02X%02X%02X%02X%02X",
-			dev->host_mac [0], dev->host_mac [1],
-			dev->host_mac [2], dev->host_mac [3],
-			dev->host_mac [4], dev->host_mac [5]);
+	/* ... another address for the host, on the other end of the
+	 * link, gets exported through CDC (see CDC spec table 41)
+	 */
+	get_random_bytes (node_id, sizeof node_id);
+	node_id [0] &= 0xfe;	// clear multicast bit
+	node_id [0] |= 0x02;    // set local assignment bit (IEEE802)
+	snprintf (ethaddr, sizeof ethaddr, "%02X%02X%02X%02X%02X%02X",
+		node_id [0], node_id [1], node_id [2],
+		node_id [3], node_id [4], node_id [5]);
 #endif
-	}
-
-	if (rndis) {
-		status = rndis_init();
-		if (status < 0) {
-			dev_err (&gadget->dev, "can't init RNDIS, %d\n",
-				status);
-			goto fail;
-		}
-	}
 
 	net->change_mtu = eth_change_mtu;
 	net->get_stats = eth_get_stats;
@@ -2546,59 +1855,15 @@
 
  	// SET_NETDEV_DEV (dev->net, &gadget->dev);
  	status = register_netdev (dev->net);
-	if (status < 0)
-		goto fail1;
+ 	if (status == 0) {
 
-	INFO (dev, "%s, version: " DRIVER_VERSION "\n", driver_desc);
-	INFO (dev, "using %s, OUT %s IN %s%s%s\n", gadget->name,
-		EP_OUT_NAME, EP_IN_NAME,
-		EP_STATUS_NAME ? " STATUS " : "",
-		EP_STATUS_NAME ? EP_STATUS_NAME : ""
-		);
-	INFO (dev, "MAC %02x:%02x:%02x:%02x:%02x:%02x\n",
-		net->dev_addr [0], net->dev_addr [1],
-		net->dev_addr [2], net->dev_addr [3],
-		net->dev_addr [4], net->dev_addr [5]);
-
-	if (cdc || rndis)
-		INFO (dev, "HOST MAC %02x:%02x:%02x:%02x:%02x:%02x\n",
-			dev->host_mac [0], dev->host_mac [1],
-			dev->host_mac [2], dev->host_mac [3],
-			dev->host_mac [4], dev->host_mac [5]);
-
-#ifdef	CONFIG_USB_ETH_RNDIS
-	if (rndis) {
-		u32	vendorID = 0;
-
-		/* FIXME RNDIS vendor id == "vendor NIC code" == ? */
-		
-		dev->rndis_config = rndis_register (rndis_control_ack);
-		if (dev->rndis_config < 0) {
-fail0:
-			unregister_netdev (dev->net);
-			status = -ENODEV;
-			goto fail;
-		}
-		
-		/* these set up a lot of the OIDs that RNDIS needs */
-		rndis_set_host_mac (dev->rndis_config, dev->host_mac);
-		if (rndis_set_param_dev (dev->rndis_config, dev->net,
-					 &dev->stats))
-			goto fail0;
-		if (rndis_set_param_vendor (dev->rndis_config, vendorID,
-					    manufacturer))
-			goto fail0;
-		if (rndis_set_param_medium (dev->rndis_config,
-					    NDIS_MEDIUM_802_3,
-					    0))
-			goto fail0;
-		INFO (dev, "RNDIS ready\n");
+		INFO (dev, "%s, " CHIP ", version: " DRIVER_VERSION "\n",
+				driver_desc);
+#ifdef	DEV_CONFIG_CDC
+		INFO (dev, "CDC host enet %s\n", ethaddr);
+#endif
+ 		return status;
 	}
-#endif	
-
-	return status;
-
-fail1:
 	dev_dbg(&gadget->dev, "register_netdev failed, %d\n", status);
 fail:
 	eth_unbind (gadget);
@@ -2607,26 +1872,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-static void
-eth_suspend (struct usb_gadget *gadget)
-{
-	struct eth_dev		*dev = get_gadget_data (gadget);
-
-	DEBUG (dev, "suspend\n");
-	dev->suspended = 1;
-}
-
-static void
-eth_resume (struct usb_gadget *gadget)
-{
-	struct eth_dev		*dev = get_gadget_data (gadget);
-
-	DEBUG (dev, "resume\n");
-	dev->suspended = 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
 static struct usb_gadget_driver eth_driver = {
 #ifdef CONFIG_USB_GADGET_DUALSPEED
 	.speed		= USB_SPEED_HIGH,
@@ -2640,9 +1885,6 @@
 	.setup		= eth_setup,
 	.disconnect	= eth_disconnect,
 
-	.suspend	= eth_suspend,
-	.resume		= eth_resume,
-
 	.driver 	= {
 		.name		= (char *) shortname,
 		// .shutdown = ...
@@ -2652,7 +1894,7 @@
 };
 
 MODULE_DESCRIPTION (DRIVER_DESC);
-MODULE_AUTHOR ("David Brownell, Benedikt Spanger");
+MODULE_AUTHOR ("David Brownell");
 MODULE_LICENSE ("GPL");
 
 
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/file_storage.c linuxppc-2.6.9-dream/drivers/usb/gadget/file_storage.c
--- linuxppc-2.6.9/drivers/usb/gadget/file_storage.c	2004-10-18 23:55:27.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/file_storage.c	2005-09-19 21:40:05.000000000 +0200
@@ -46,16 +46,17 @@
  *
  * Backing storage is provided by a regular file or a block device, specified
  * by the "file" module parameter.  Access can be limited to read-only by
- * setting the optional "ro" module parameter.  The gadget will indicate that
- * it has removable media if the optional "removable" module parameter is set.
+ * setting the optional "ro" module parameter.
  *
  * The gadget supports the Control-Bulk (CB), Control-Bulk-Interrupt (CBI),
  * and Bulk-Only (also known as Bulk-Bulk-Bulk or BBB) transports, selected
  * by the optional "transport" module parameter.  It also supports the
  * following protocols: RBC (0x01), ATAPI or SFF-8020i (0x02), QIC-157 (0c03),
  * UFI (0x04), SFF-8070i (0x05), and transparent SCSI (0x06), selected by
- * the optional "protocol" module parameter.  In addition, the default
- * Vendor ID, Product ID, and release number can be overridden.
+ * the optional "protocol" module parameter.  For testing purposes the
+ * gadget will indicate that it has removable media if the optional
+ * "removable" module parameter is set.  In addition, the default Vendor ID,
+ * Product ID, and release number can be overridden.
  *
  * There is support for multiple logical units (LUNs), each of which has
  * its own backing file.  The number of LUNs can be set using the optional
@@ -78,13 +79,13 @@
  *					the files or block devices used for
  *					backing storage
  *	ro=b[,b...]		Default false, booleans for read-only access
- *	removable		Default false, boolean for removable media
  *	luns=N			Default N = number of filenames, number of
  *					LUNs to support
  *	transport=XXX		Default BBB, transport name (CB, CBI, or BBB)
  *	protocol=YYY		Default SCSI, protocol name (RBC, 8020 or
  *					ATAPI, QIC, UFI, 8070, or SCSI;
  *					also 1 - 6)
+ *	removable		Default false, boolean for removable media
  *	vendor=0xVVVV		Default 0x0525 (NetChip), USB Vendor ID
  *	product=0xPPPP		Default 0xa4a5 (FSG), USB Product ID
  *	release=0xRRRR		Override the USB release number (bcdDevice)
@@ -96,16 +97,16 @@
  *					boolean to permit the driver to halt
  *					bulk endpoints
  *
- * If CONFIG_USB_FILE_STORAGE_TEST is not set, only the "file", "ro",
- * "removable", and "luns" options are available; default values are used
- * for everything else.
+ * If CONFIG_USB_FILE_STORAGE_TEST is not set, only the "file" and "ro"
+ * options are available; default values are used for everything else.
  *
  * The pathnames of the backing files and the ro settings are available in
  * the attribute files "file" and "ro" in the lun<n> subdirectory of the
- * gadget's sysfs directory.  If the "removable" option is set, writing to
- * these files will simulate ejecting/loading the medium (writing an empty
- * line means eject) and adjusting a write-enable tab.  Changes to the ro
- * setting are not allowed when the medium is loaded.
+ * gadget's sysfs directory.  If CONFIG_USB_FILE_STORAGE_TEST and the
+ * "removable" option are both set, writing to these files will simulate
+ * ejecting/loading the medium (writing an empty line means eject) and
+ * adjusting a write-enable tab.  Changes to the ro setting are not allowed
+ * when the medium is loaded.
  *
  * This gadget driver is heavily based on "Gadget Zero" by David Brownell.
  */
@@ -177,10 +178,7 @@
  * Bulk-only specification requires a stall.  In such cases the driver
  * will halt the endpoint and set a flag indicating that it should clear
  * the halt in software during the next device reset.  Hopefully this
- * will permit everything to work correctly.  Furthermore, although the
- * specification allows the bulk-out endpoint to halt when the host sends
- * too much data, implementing this would cause an unavoidable race.
- * The driver will always use the "no-stall" approach for OUT transfers.
+ * will permit everything to work correctly.
  *
  * One subtle point concerns sending status-stage responses for ep0
  * requests.  Some of these requests, such as device reset, can involve
@@ -241,14 +239,12 @@
 #include <linux/usb_ch9.h>
 #include <linux/usb_gadget.h>
 
-#include "gadget_chips.h"
-
 
 /*-------------------------------------------------------------------------*/
 
 #define DRIVER_DESC		"File-backed Storage Gadget"
 #define DRIVER_NAME		"g_file_storage"
-#define DRIVER_VERSION		"28 July 2004"
+#define DRIVER_VERSION		"26 January 2004"
 
 static const char longname[] = DRIVER_DESC;
 static const char shortname[] = DRIVER_NAME;
@@ -265,11 +261,165 @@
 #define DRIVER_PRODUCT_ID	0xa4a5	// Linux-USB File-backed Storage Gadget
 
 
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Hardware-specific configuration, controlled by which device
+ * controller driver was configured.
+ *
+ * CHIP ... hardware identifier
+ * DRIVER_VERSION_NUM ... alerts the host side driver to differences
+ * EP_*_NAME ... which endpoints do we use for which purpose?
+ * EP_*_NUM ... numbers for them (often limited by hardware)
+ * FS_BULK_IN_MAXPACKET ... maxpacket value for full-speed bulk-in ep
+ * FS_BULK_OUT_MAXPACKET ... maxpacket value for full-speed bulk-out ep
+ * HIGHSPEED ... define if ep0 and descriptors need high speed support
+ * MAX_USB_POWER ... define if we use other than 100 mA bus current
+ * SELFPOWER ... if we can run on bus power, zero
+ * NO_BULK_STALL ... bulk endpoint halts don't work well so avoid them
+ */
+
+
+/*
+ * NetChip 2280, PCI based.
+ *
+ * This has half a dozen configurable endpoints, four with dedicated
+ * DMA channels to manage their FIFOs.  It supports high speed.
+ * Those endpoints can be arranged in any desired configuration.
+ */
+#ifdef	CONFIG_USB_GADGET_NET2280
+#define CHIP			"net2280"
+#define DRIVER_VERSION_NUM	0x0201
+static const char EP_BULK_IN_NAME[] = "ep-a";
+#define EP_BULK_IN_NUM		1
+#define FS_BULK_IN_MAXPACKET	64
+static const char EP_BULK_OUT_NAME[] = "ep-b";
+#define EP_BULK_OUT_NUM		2
+#define FS_BULK_OUT_MAXPACKET	64
+static const char EP_INTR_IN_NAME[] = "ep-e";
+#define EP_INTR_IN_NUM		5
+#define HIGHSPEED
+#endif
+
+
 /*
- * This driver assumes self-powered hardware and has no way for users to
- * trigger remote wakeup.  It uses autoconfiguration to select endpoints
- * and endpoint addresses.
+ * Dummy_hcd, software-based loopback controller.
+ *
+ * This imitates the abilities of the NetChip 2280, so we will use
+ * the same configuration.
  */
+#ifdef	CONFIG_USB_GADGET_DUMMY_HCD
+#define CHIP			"dummy"
+#define DRIVER_VERSION_NUM	0x0202
+static const char EP_BULK_IN_NAME[] = "ep-a";
+#define EP_BULK_IN_NUM		1
+#define FS_BULK_IN_MAXPACKET	64
+static const char EP_BULK_OUT_NAME[] = "ep-b";
+#define EP_BULK_OUT_NUM		2
+#define FS_BULK_OUT_MAXPACKET	64
+static const char EP_INTR_IN_NAME[] = "ep-e";
+#define EP_INTR_IN_NUM		5
+#define HIGHSPEED
+#endif
+
+
+/*
+ * PXA-2xx UDC:  widely used in second gen Linux-capable PDAs.
+ *
+ * This has fifteen fixed-function full speed endpoints, and it
+ * can support all USB transfer types.
+ *
+ * These supports three or four configurations, with fixed numbers.
+ * The hardware interprets SET_INTERFACE, net effect is that you
+ * can't use altsettings or reset the interfaces independently.
+ * So stick to a single interface.
+ */
+#ifdef	CONFIG_USB_GADGET_PXA2XX
+#define CHIP			"pxa2xx"
+#define DRIVER_VERSION_NUM	0x0203
+static const char EP_BULK_IN_NAME[] = "ep1in-bulk";
+#define EP_BULK_IN_NUM		1
+#define FS_BULK_IN_MAXPACKET	64
+static const char EP_BULK_OUT_NAME[] = "ep2out-bulk";
+#define EP_BULK_OUT_NUM		2
+#define FS_BULK_OUT_MAXPACKET	64
+static const char EP_INTR_IN_NAME[] = "ep6in-bulk";
+#define EP_INTR_IN_NUM		6
+#endif
+
+
+/*
+ * SuperH UDC:  UDC built-in to some Renesas SH processors.
+ *
+ * This has three fixed-function full speed bulk/interrupt endpoints.
+ *
+ * Only one configuration and interface is supported (SET_CONFIGURATION
+ * and SET_INTERFACE are handled completely by the hardware).
+ */
+#ifdef	CONFIG_USB_GADGET_SUPERH
+#define CHIP			"superh"
+#define DRIVER_VERSION_NUM	0x0205
+static const char EP_BULK_IN_NAME[] = "ep2in-bulk";
+#define EP_BULK_IN_NUM		2
+#define FS_BULK_IN_MAXPACKET	64
+static const char EP_BULK_OUT_NAME[] = "ep1out-bulk";
+#define EP_BULK_OUT_NUM		1
+#define FS_BULK_OUT_MAXPACKET	64
+static const char EP_INTR_IN_NAME[] = "ep3in-bulk";
+#define EP_INTR_IN_NUM		3
+#define NO_BULK_STALL
+#endif
+
+
+/*
+ * Toshiba TC86C001 ("Goku-S") UDC
+ *
+ * This has three semi-configurable full speed bulk/interrupt endpoints.
+ */
+#ifdef	CONFIG_USB_GADGET_GOKU
+#define CHIP			"goku"
+#define DRIVER_VERSION_NUM	0x0206
+static const char EP_BULK_OUT_NAME [] = "ep1-bulk";
+#define EP_BULK_OUT_NUM		1
+#define FS_BULK_IN_MAXPACKET	64
+static const char EP_BULK_IN_NAME [] = "ep2-bulk";
+#define EP_BULK_IN_NUM		2
+#define FS_BULK_OUT_MAXPACKET	64
+static const char EP_INTR_IN_NAME [] = "ep3-bulk";
+#define EP_INTR_IN_NUM		3
+#endif
+
+
+/*-------------------------------------------------------------------------*/
+
+#ifndef CHIP
+#	error Configure some USB peripheral controller driver!
+#endif
+
+/* Power usage is config specific.
+ * Hardware that supports remote wakeup defaults to disabling it.
+ */
+#ifndef	SELFPOWER
+/* default: say we're self-powered */
+#define SELFPOWER USB_CONFIG_ATT_SELFPOWER
+/* else:
+ * - SELFPOWER value must be zero
+ * - MAX_USB_POWER may be nonzero.
+ */
+#endif
+
+#ifndef	MAX_USB_POWER
+/* Any hub supports this steady state bus power consumption */
+#define MAX_USB_POWER	100	/* mA */
+#endif
+
+/* We don't support remote wake-up */
+
+#ifdef NO_BULK_STALL
+#define CAN_STALL	0
+#else
+#define CAN_STALL	1
+#endif
 
 
 /*-------------------------------------------------------------------------*/
@@ -361,9 +511,9 @@
 	.removable		= 0,
 	.vendor			= DRIVER_VENDOR_ID,
 	.product		= DRIVER_PRODUCT_ID,
-	.release		= 0xffff,	// Use controller chip type
+	.release		= DRIVER_VERSION_NUM,
 	.buflen			= 16384,
-	.can_stall		= 1,
+	.can_stall		= CAN_STALL,
 	};
 
 
@@ -373,17 +523,14 @@
 module_param_array(ro, bool, mod_data.num_ros, S_IRUGO);
 MODULE_PARM_DESC(ro, "true to force read-only");
 
-module_param_named(luns, mod_data.nluns, uint, S_IRUGO);
-MODULE_PARM_DESC(luns, "number of LUNs");
-
-module_param_named(removable, mod_data.removable, bool, S_IRUGO);
-MODULE_PARM_DESC(removable, "true to simulate removable media");
-
 
-/* In the non-TEST version, only the module parameters listed above
+/* In the non-TEST version, only the file and ro module parameters
  * are available. */
 #ifdef CONFIG_USB_FILE_STORAGE_TEST
 
+module_param_named(luns, mod_data.nluns, uint, S_IRUGO);
+MODULE_PARM_DESC(luns, "number of LUNs");
+
 module_param_named(transport, mod_data.transport_parm, charp, S_IRUGO);
 MODULE_PARM_DESC(transport, "type of transport (BBB, CBI, or CB)");
 
@@ -391,6 +538,9 @@
 MODULE_PARM_DESC(protocol, "type of protocol (RBC, 8020, QIC, UFI, "
 		"8070, or SCSI)");
 
+module_param_named(removable, mod_data.removable, bool, S_IRUGO);
+MODULE_PARM_DESC(removable, "true to simulate removable media");
+
 module_param_named(vendor, mod_data.vendor, ushort, S_IRUGO);
 MODULE_PARM_DESC(vendor, "USB Vendor ID");
 
@@ -527,6 +677,11 @@
  * parts of the driver that aren't used in the non-TEST version.  Even gcc
  * can recognize when a test of a constant expression yields a dead code
  * path.
+ *
+ * Also, in the non-TEST version, open_backing_file() is only used during
+ * initialization and the sysfs attribute store_xxx routines aren't used
+ * at all.  We will define NORMALLY_INIT to mark them as __init so they
+ * don't occupy kernel code space unnecessarily.
  */
 
 #ifdef CONFIG_USB_FILE_STORAGE_TEST
@@ -534,12 +689,16 @@
 #define transport_is_bbb()	(mod_data.transport_type == USB_PR_BULK)
 #define transport_is_cbi()	(mod_data.transport_type == USB_PR_CBI)
 #define protocol_is_scsi()	(mod_data.protocol_type == USB_SC_SCSI)
+#define backing_file_is_open(curlun)	((curlun)->filp != NULL)
+#define NORMALLY_INIT
 
 #else
 
 #define transport_is_bbb()	1
 #define transport_is_cbi()	0
 #define protocol_is_scsi()	1
+#define backing_file_is_open(curlun)	1
+#define NORMALLY_INIT		__init
 
 #endif /* CONFIG_USB_FILE_STORAGE_TEST */
 
@@ -560,8 +719,6 @@
 	struct device	dev;
 };
 
-#define backing_file_is_open(curlun)	((curlun)->filp != NULL)
-
 static inline struct lun *dev_to_lun(struct device *dev)
 {
 	return container_of(dev, struct lun, dev);
@@ -654,7 +811,6 @@
 	unsigned long		atomic_bitflags;
 #define REGISTERED		0
 #define CLEAR_BULK_HALTS	1
-#define SUSPENDED		2
 
 	struct usb_ep		*bulk_in;
 	struct usb_ep		*bulk_out;
@@ -846,7 +1002,7 @@
 	/* The next three values can be overridden by module parameters */
 	.idVendor =		__constant_cpu_to_le16(DRIVER_VENDOR_ID),
 	.idProduct =		__constant_cpu_to_le16(DRIVER_PRODUCT_ID),
-	.bcdDevice =		__constant_cpu_to_le16(0xffff),
+	.bcdDevice =		__constant_cpu_to_le16(DRIVER_VERSION_NUM),
 
 	.iManufacturer =	STRING_MANUFACTURER,
 	.iProduct =		STRING_PRODUCT,
@@ -859,11 +1015,11 @@
 	.bLength =		sizeof config_desc,
 	.bDescriptorType =	USB_DT_CONFIG,
 
-	/* wTotalLength computed by usb_gadget_config_buf() */
+	/* wTotalLength adjusted during bind() */
 	.bNumInterfaces =	1,
 	.bConfigurationValue =	CONFIG_VALUE,
-	.bmAttributes =		USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
-	.bMaxPower =		1,	// self-powered
+	.bmAttributes =		USB_CONFIG_ATT_ONE | SELFPOWER,
+	.bMaxPower =		(MAX_USB_POWER + 1) / 2,
 };
 
 /* There is only one interface. */
@@ -873,56 +1029,47 @@
 	.bLength =		sizeof intf_desc,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
-	.bNumEndpoints =	2,		// Adjusted during fsg_bind()
+	.bNumEndpoints =	2,		// Adjusted during bind()
 	.bInterfaceClass =	USB_CLASS_MASS_STORAGE,
-	.bInterfaceSubClass =	USB_SC_SCSI,	// Adjusted during fsg_bind()
-	.bInterfaceProtocol =	USB_PR_BULK,	// Adjusted during fsg_bind()
+	.bInterfaceSubClass =	USB_SC_SCSI,	// Adjusted during bind()
+	.bInterfaceProtocol =	USB_PR_BULK,	// Adjusted during bind()
 };
 
 /* Three full-speed endpoint descriptors: bulk-in, bulk-out,
  * and interrupt-in. */
 
-static struct usb_endpoint_descriptor
+static const struct usb_endpoint_descriptor
 fs_bulk_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
-	.bEndpointAddress =	USB_DIR_IN,
+	.bEndpointAddress =	EP_BULK_IN_NUM | USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
-	/* wMaxPacketSize set by autoconfiguration */
+	.wMaxPacketSize =	__constant_cpu_to_le16(FS_BULK_IN_MAXPACKET),
 };
 
-static struct usb_endpoint_descriptor
+static const struct usb_endpoint_descriptor
 fs_bulk_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
-	.bEndpointAddress =	USB_DIR_OUT,
+	.bEndpointAddress =	EP_BULK_OUT_NUM,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
-	/* wMaxPacketSize set by autoconfiguration */
+	.wMaxPacketSize =	__constant_cpu_to_le16(FS_BULK_OUT_MAXPACKET),
 };
 
-static struct usb_endpoint_descriptor
+static const struct usb_endpoint_descriptor
 fs_intr_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
-	.bEndpointAddress =	USB_DIR_IN,
+	.bEndpointAddress =	EP_INTR_IN_NUM | USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
 	.wMaxPacketSize =	__constant_cpu_to_le16(2),
 	.bInterval =		32,	// frames -> 32 ms
 };
 
-static const struct usb_descriptor_header *fs_function[] = {
-	(struct usb_descriptor_header *) &intf_desc,
-	(struct usb_descriptor_header *) &fs_bulk_in_desc,
-	(struct usb_descriptor_header *) &fs_bulk_out_desc,
-	(struct usb_descriptor_header *) &fs_intr_in_desc,
-	NULL,
-};
-
-
-#ifdef	CONFIG_USB_GADGET_DUALSPEED
+#ifdef	HIGHSPEED
 
 /*
  * USB 2.0 devices need to expose both high speed and full speed
@@ -932,55 +1079,47 @@
  * and a "device qualifier" ... plus more construction options
  * for the config descriptor.
  */
-static struct usb_qualifier_descriptor
-dev_qualifier = {
-	.bLength =		sizeof dev_qualifier,
-	.bDescriptorType =	USB_DT_DEVICE_QUALIFIER,
-
-	.bcdUSB =		__constant_cpu_to_le16(0x0200),
-	.bDeviceClass =		USB_CLASS_PER_INTERFACE,
-
-	.bNumConfigurations =	1,
-};
-
-static struct usb_endpoint_descriptor
+static const struct usb_endpoint_descriptor
 hs_bulk_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
-	/* bEndpointAddress copied from fs_bulk_in_desc during fsg_bind() */
+	.bEndpointAddress =	EP_BULK_IN_NUM | USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 	.wMaxPacketSize =	__constant_cpu_to_le16(512),
 };
 
-static struct usb_endpoint_descriptor
+static const struct usb_endpoint_descriptor
 hs_bulk_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
-	/* bEndpointAddress copied from fs_bulk_out_desc during fsg_bind() */
+	.bEndpointAddress =	EP_BULK_OUT_NUM,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 	.wMaxPacketSize =	__constant_cpu_to_le16(512),
 	.bInterval =		1,	// NAK every 1 uframe
 };
 
-static struct usb_endpoint_descriptor
+static const struct usb_endpoint_descriptor
 hs_intr_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
-	/* bEndpointAddress copied from fs_intr_in_desc during fsg_bind() */
+	.bEndpointAddress =	EP_INTR_IN_NUM | USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
 	.wMaxPacketSize =	__constant_cpu_to_le16(2),
 	.bInterval =		9,	// 2**(9-1) = 256 uframes -> 32 ms
 };
 
-static const struct usb_descriptor_header *hs_function[] = {
-	(struct usb_descriptor_header *) &intf_desc,
-	(struct usb_descriptor_header *) &hs_bulk_in_desc,
-	(struct usb_descriptor_header *) &hs_bulk_out_desc,
-	(struct usb_descriptor_header *) &hs_intr_in_desc,
-	NULL,
+static struct usb_qualifier_descriptor
+dev_qualifier = {
+	.bLength =		sizeof dev_qualifier,
+	.bDescriptorType =	USB_DT_DEVICE_QUALIFIER,
+
+	.bcdUSB =		__constant_cpu_to_le16(0x0200),
+	.bDeviceClass =		USB_CLASS_PER_INTERFACE,
+
+	.bNumConfigurations =	1,
 };
 
 /* Maxpacket and other transfer characteristics vary by speed. */
@@ -988,23 +1127,22 @@
 
 #else
 
-/* If there's no high speed support, always use the full-speed descriptor. */
+/* If there's no high speed support, maxpacket doesn't change. */
 #define ep_desc(g,fs,hs)	fs
 
-#endif	/* !CONFIG_USB_GADGET_DUALSPEED */
+#endif	/* !HIGHSPEED */
 
 
 /* The CBI specification limits the serial string to 12 uppercase hexadecimal
  * characters. */
-static char				manufacturer[40];
 static char				serial[13];
 
-/* Static strings, in UTF-8 (for simplicity we use only ASCII characters) */
+/* Static strings, in ISO 8859/1 */
 static struct usb_string		strings[] = {
-	{STRING_MANUFACTURER,	manufacturer},
-	{STRING_PRODUCT,	longname},
-	{STRING_SERIAL,		serial},
-	{}
+	{ STRING_MANUFACTURER, UTS_SYSNAME " " UTS_RELEASE " with " CHIP, },
+	{ STRING_PRODUCT, longname, },
+	{ STRING_SERIAL, serial, },
+	{ }			// end of list
 };
 
 static struct usb_gadget_strings	stringtab = {
@@ -1014,31 +1152,61 @@
 
 
 /*
- * Config descriptors must agree with the code that sets configurations
- * and with code managing interfaces and their altsettings.  They must
- * also handle different speeds and other-speed requests.
+ * Config descriptors are handcrafted.  They must agree with the code
+ * that sets configurations and with code managing interfaces and their
+ * altsettings.  They must also handle different speeds and other-speed
+ * requests.
  */
 static int populate_config_buf(enum usb_device_speed speed,
-		u8 *buf, u8 type, unsigned index)
+		u8 *buf0, u8 type, unsigned index)
 {
-	int					len;
-	const struct usb_descriptor_header	**function;
+	u8	*buf = buf0;
+#ifdef HIGHSPEED
+	int	hs;
+#endif
 
 	if (index > 0)
 		return -EINVAL;
+	if (config_desc.wTotalLength  > EP0_BUFSIZE)
+		return -EDOM;
 
-#ifdef CONFIG_USB_GADGET_DUALSPEED
+	/* Config (or other speed config) */
+	memcpy(buf, &config_desc, USB_DT_CONFIG_SIZE);
+	buf[1] = type;
+	buf += USB_DT_CONFIG_SIZE;
+
+	/* Interface */
+	memcpy(buf, &intf_desc, USB_DT_INTERFACE_SIZE);
+	buf += USB_DT_INTERFACE_SIZE;
+
+	/* The endpoints in the interface (at that speed) */
+#ifdef HIGHSPEED
+	hs = (speed == USB_SPEED_HIGH);
 	if (type == USB_DT_OTHER_SPEED_CONFIG)
-		speed = (USB_SPEED_FULL + USB_SPEED_HIGH) - speed;
-	if (speed == USB_SPEED_HIGH)
-		function = hs_function;
-	else
+		hs = !hs;
+	if (hs) {
+		memcpy(buf, &hs_bulk_in_desc, USB_DT_ENDPOINT_SIZE);
+		buf += USB_DT_ENDPOINT_SIZE;
+		memcpy(buf, &hs_bulk_out_desc, USB_DT_ENDPOINT_SIZE);
+		buf += USB_DT_ENDPOINT_SIZE;
+		if (transport_is_cbi()) {
+			memcpy(buf, &hs_intr_in_desc, USB_DT_ENDPOINT_SIZE);
+			buf += USB_DT_ENDPOINT_SIZE;
+		}
+	} else
 #endif
-		function = fs_function;
+	{
+		memcpy(buf, &fs_bulk_in_desc, USB_DT_ENDPOINT_SIZE);
+		buf += USB_DT_ENDPOINT_SIZE;
+		memcpy(buf, &fs_bulk_out_desc, USB_DT_ENDPOINT_SIZE);
+		buf += USB_DT_ENDPOINT_SIZE;
+		if (transport_is_cbi()) {
+			memcpy(buf, &fs_intr_in_desc, USB_DT_ENDPOINT_SIZE);
+			buf += USB_DT_ENDPOINT_SIZE;
+		}
+	}
 
-	len = usb_gadget_config_buf(&config_desc, buf, EP0_BUFSIZE, function);
-	((struct usb_config_descriptor *) buf)->bDescriptorType = type;
-	return len;
+	return buf - buf0;
 }
 
 
@@ -1166,10 +1334,9 @@
 	wakeup_thread(fsg);
 }
 
-
-#ifdef CONFIG_USB_FILE_STORAGE_TEST
 static void intr_in_complete(struct usb_ep *ep, struct usb_request *req)
 {
+#ifdef CONFIG_USB_FILE_STORAGE_TEST
 	struct fsg_dev		*fsg = (struct fsg_dev *) ep->driver_data;
 	struct fsg_buffhd	*bh = (struct fsg_buffhd *) req->context;
 
@@ -1185,21 +1352,17 @@
 	bh->state = BUF_STATE_EMPTY;
 	spin_unlock(&fsg->lock);
 	wakeup_thread(fsg);
-}
-
-#else
-static void intr_in_complete(struct usb_ep *ep, struct usb_request *req)
-{}
 #endif /* CONFIG_USB_FILE_STORAGE_TEST */
+}
 
 
 /*-------------------------------------------------------------------------*/
 
 /* Ep0 class-specific handlers.  These always run in_irq. */
 
-#ifdef CONFIG_USB_FILE_STORAGE_TEST
 static void received_cbi_adsc(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 {
+#ifdef CONFIG_USB_FILE_STORAGE_TEST
 	struct usb_request	*req = fsg->ep0req;
 	static u8		cbi_reset_cmnd[6] = {
 			SC_SEND_DIAGNOSTIC, 4, 0xff, 0xff, 0xff, 0xff};
@@ -1237,12 +1400,8 @@
 
 	spin_unlock(&fsg->lock);
 	wakeup_thread(fsg);
-}
-
-#else
-static void received_cbi_adsc(struct fsg_dev *fsg, struct fsg_buffhd *bh)
-{}
 #endif /* CONFIG_USB_FILE_STORAGE_TEST */
+}
 
 
 static int class_setup_req(struct fsg_dev *fsg,
@@ -1346,26 +1505,22 @@
 			value = min(ctrl->wLength, (u16) sizeof device_desc);
 			memcpy(req->buf, &device_desc, value);
 			break;
-#ifdef CONFIG_USB_GADGET_DUALSPEED
+#ifdef HIGHSPEED
 		case USB_DT_DEVICE_QUALIFIER:
 			VDBG(fsg, "get device qualifier\n");
-			if (!fsg->gadget->is_dualspeed)
-				break;
 			value = min(ctrl->wLength, (u16) sizeof dev_qualifier);
 			memcpy(req->buf, &dev_qualifier, value);
 			break;
 
 		case USB_DT_OTHER_SPEED_CONFIG:
 			VDBG(fsg, "get other-speed config descriptor\n");
-			if (!fsg->gadget->is_dualspeed)
-				break;
 			goto get_config;
-#endif
+#endif /* HIGHSPEED */
 		case USB_DT_CONFIG:
 			VDBG(fsg, "get configuration descriptor\n");
-#ifdef CONFIG_USB_GADGET_DUALSPEED
+#ifdef HIGHSPEED
 		get_config:
-#endif
+#endif /* HIGHSPEED */
 			value = populate_config_buf(fsg->gadget->speed,
 					req->buf,
 					ctrl->wValue >> 8,
@@ -1468,8 +1623,6 @@
 	/* Respond with data/status or defer until later? */
 	if (rc >= 0 && rc != DELAYED_STATUS) {
 		fsg->ep0req->length = rc;
-		fsg->ep0req->zero = (rc < ctrl->wLength &&
-				(rc % gadget->ep0->maxpacket) == 0);
 		fsg->ep0req_name = (ctrl->bRequestType & USB_DIR_IN ?
 				"ep0-in" : "ep0-out");
 		rc = ep0_queue(fsg);
@@ -2011,7 +2164,7 @@
 	buf[4] = 31;		// Additional length
 				// No special options
 	sprintf(buf + 8, "%-8s%-16s%04x", vendor_id, product_id,
-			mod_data.release);
+			DRIVER_VERSION_NUM);
 	return 36;
 }
 
@@ -2059,7 +2212,7 @@
 	buf[0] = 0x80 | 0x70;			// Valid, current error
 	buf[2] = SK(sd);
 	put_be32(&buf[3], sdinfo);		// Sense information
-	buf[7] = 18 - 8;			// Additional sense length
+	buf[7] = 18 - 7;			// Additional sense length
 	buf[12] = ASC(sd);
 	buf[13] = ASCQ(sd);
 	return 18;
@@ -2446,19 +2599,14 @@
 			rc = -EINTR;
 		}
 
-		/* We haven't processed all the incoming data.  Even though
-		 * we may be allowed to stall, doing so would cause a race.
-		 * The controller may already have ACK'ed all the remaining
-		 * bulk-out packets, in which case the host wouldn't see a
-		 * STALL.  Not realizing the endpoint was halted, it wouldn't
-		 * clear the halt -- leading to problems later on. */
-#if 0
+		/* We haven't processed all the incoming data.  If we are
+		 * allowed to stall, halt the bulk-out endpoint and cancel
+		 * any outstanding requests. */
 		else if (mod_data.can_stall) {
 			fsg_set_halt(fsg, fsg->bulk_out);
 			raise_exception(fsg, FSG_STATE_ABORT_BULK_OUT);
 			rc = -EINTR;
 		}
-#endif
 
 		/* We can't stall.  Read in the excess data and throw it
 		 * all away. */
@@ -2511,7 +2659,7 @@
 		/* Store and send the Bulk-only CSW */
 		csw->Signature = __constant_cpu_to_le32(USB_BULK_CS_SIG);
 		csw->Tag = fsg->tag;
-		csw->Residue = cpu_to_le32(fsg->residue);
+		csw->Residue = fsg->residue;
 		csw->Status = status;
 
 		bh->inreq->length = USB_BULK_CS_WRAP_LEN;
@@ -2521,7 +2669,7 @@
 
 	} else if (mod_data.transport_type == USB_PR_CB) {
 
-		/* Control-Bulk transport has no status phase! */
+		/* Control-Bulk transport has no status stage! */
 		return 0;
 
 	} else {			// USB_PR_CBI
@@ -2611,10 +2759,8 @@
 	fsg->residue = fsg->usb_amount_left = fsg->data_size;
 
 	/* Conflicting data directions is a phase error */
-	if (fsg->data_dir != data_dir && fsg->data_size_from_cmnd > 0) {
-		fsg->phase_error = 1;
-		return -EINVAL;
-	}
+	if (fsg->data_dir != data_dir && fsg->data_size_from_cmnd > 0)
+		goto phase_error;
 
 	/* Verify the length of the command itself */
 	if (cmnd_size != fsg->cmnd_size) {
@@ -2623,10 +2769,8 @@
 		 * with cbw->Length == 12 (it should be 6). */
 		if (fsg->cmnd[0] == SC_REQUEST_SENSE && fsg->cmnd_size == 12)
 			cmnd_size = fsg->cmnd_size;
-		else {
-			fsg->phase_error = 1;
-			return -EINVAL;
-		}
+		else
+			goto phase_error;
 	}
 
 	/* Check that the LUN values are oonsistent */
@@ -2686,6 +2830,10 @@
 	}
 
 	return 0;
+
+phase_error:
+	fsg->phase_error = 1;
+	return -EINVAL;
 }
 
 
@@ -2957,7 +3105,7 @@
 		fsg->data_dir = DATA_DIR_TO_HOST;
 	else
 		fsg->data_dir = DATA_DIR_FROM_HOST;
-	fsg->data_size = le32_to_cpu(cbw->DataTransferLength);
+	fsg->data_size = cbw->DataTransferLength;
 	if (fsg->data_size == 0)
 		fsg->data_dir = DATA_DIR_NONE;
 	fsg->lun = cbw->Lun;
@@ -3110,7 +3258,6 @@
 	if ((rc = enable_endpoint(fsg, fsg->bulk_out, d)) != 0)
 		goto reset;
 	fsg->bulk_out_enabled = 1;
-	fsg->bulk_out_maxpacket = d->wMaxPacketSize;
 
 	if (transport_is_cbi()) {
 		d = ep_desc(fsg->gadget, &fs_intr_in_desc, &hs_intr_in_desc);
@@ -3432,7 +3579,8 @@
 /* If the next two routines are called while the gadget is registered,
  * the caller must own fsg->filesem for writing. */
 
-static int open_backing_file(struct lun *curlun, const char *filename)
+static int NORMALLY_INIT open_backing_file(struct lun *curlun,
+		const char *filename)
 {
 	int				ro;
 	struct file			*filp = NULL;
@@ -3557,7 +3705,8 @@
 }
 
 
-ssize_t store_ro(struct device *dev, const char *buf, size_t count)
+ssize_t NORMALLY_INIT store_ro(struct device *dev, const char *buf,
+		size_t count)
 {
 	ssize_t		rc = count;
 	struct lun	*curlun = dev_to_lun(dev);
@@ -3581,7 +3730,8 @@
 	return rc;
 }
 
-ssize_t store_file(struct device *dev, const char *buf, size_t count)
+ssize_t NORMALLY_INIT store_file(struct device *dev, const char *buf,
+		size_t count)
 {
 	struct lun	*curlun = dev_to_lun(dev);
 	struct fsg_dev	*fsg = (struct fsg_dev *) dev_get_drvdata(dev);
@@ -3678,7 +3828,7 @@
 		usb_ep_free_request(fsg->ep0, req);
 	}
 
-	set_gadget_data(gadget, NULL);
+	set_gadget_data(gadget, 0);
 }
 
 
@@ -3692,36 +3842,6 @@
 	mod_data.protocol_type = USB_SC_SCSI;
 	mod_data.protocol_name = "Transparent SCSI";
 
-	if (gadget_is_sh(fsg->gadget))
-		mod_data.can_stall = 0;
-
-	if (mod_data.release == 0xffff) {	// Parameter wasn't set
-		if (gadget_is_net2280(fsg->gadget))
-			mod_data.release = __constant_cpu_to_le16(0x0301);
-		else if (gadget_is_dummy(fsg->gadget))
-			mod_data.release = __constant_cpu_to_le16(0x0302);
-		else if (gadget_is_pxa(fsg->gadget))
-			mod_data.release = __constant_cpu_to_le16(0x0303);
-		else if (gadget_is_sh(fsg->gadget))
-			mod_data.release = __constant_cpu_to_le16(0x0304);
-
-		/* The sa1100 controller is not supported */
-
-		else if (gadget_is_goku(fsg->gadget))
-			mod_data.release = __constant_cpu_to_le16(0x0306);
-		else if (gadget_is_mq11xx(fsg->gadget))
-			mod_data.release = __constant_cpu_to_le16(0x0307);
-		else if (gadget_is_omap(fsg->gadget))
-			mod_data.release = __constant_cpu_to_le16(0x0308);
-		else if (gadget_is_lh7a40x(gadget))
-			mod_data.release = __constant_cpu_to_le16 (0x0309);
-		else {
-			WARN(fsg, "controller '%s' not recognized\n",
-				fsg->gadget->name);
-			mod_data.release = __constant_cpu_to_le16(0x0399);
-		}
-	}
-
 	prot = simple_strtol(mod_data.protocol_parm, NULL, 0);
 
 #ifdef CONFIG_USB_FILE_STORAGE_TEST
@@ -3734,7 +3854,7 @@
 		mod_data.transport_type = USB_PR_CBI;
 		mod_data.transport_name = "Control-Bulk-Interrupt";
 	} else {
-		ERROR(fsg, "invalid transport: %s\n", mod_data.transport_parm);
+		INFO(fsg, "invalid transport: %s\n", mod_data.transport_parm);
 		return -EINVAL;
 	}
 
@@ -3763,13 +3883,13 @@
 		mod_data.protocol_type = USB_SC_8070;
 		mod_data.protocol_name = "8070i";
 	} else {
-		ERROR(fsg, "invalid protocol: %s\n", mod_data.protocol_parm);
+		INFO(fsg, "invalid protocol: %s\n", mod_data.protocol_parm);
 		return -EINVAL;
 	}
 
 	mod_data.buflen &= PAGE_CACHE_MASK;
 	if (mod_data.buflen <= 0) {
-		ERROR(fsg, "invalid buflen\n");
+		INFO(fsg, "invalid buflen\n");
 		return -ETOOSMALL;
 	}
 #endif /* CONFIG_USB_FILE_STORAGE_TEST */
@@ -3807,13 +3927,14 @@
 	if (i == 0)
 		i = max(mod_data.num_filenames, 1);
 	if (i > MAX_LUNS) {
-		ERROR(fsg, "invalid number of LUNs: %d\n", i);
+		INFO(fsg, "invalid number of LUNs: %d\n", i);
 		rc = -EINVAL;
 		goto out;
 	}
 
-	/* Create the LUNs, open their backing files, and register the
-	 * LUN devices in sysfs. */
+	/* Create the LUNs and open their backing files.  We can't register
+	 * the LUN devices until the gadget itself is registered, which
+	 * doesn't happen until after fsg_bind() returns. */
 	fsg->luns = kmalloc(i * sizeof(struct lun), GFP_KERNEL);
 	if (!fsg->luns) {
 		rc = -ENOMEM;
@@ -3831,70 +3952,49 @@
 		snprintf(curlun->dev.bus_id, BUS_ID_SIZE,
 				"%s-lun%d", gadget->dev.bus_id, i);
 
-		if ((rc = device_register(&curlun->dev)) != 0)
-			INFO(fsg, "failed to register LUN%d: %d\n", i, rc);
-		else {
-			curlun->registered = 1;
-			curlun->dev.release = lun_release;
-			device_create_file(&curlun->dev, &dev_attr_ro);
-			device_create_file(&curlun->dev, &dev_attr_file);
-		}
-
 		if (file[i] && *file[i]) {
 			if ((rc = open_backing_file(curlun, file[i])) != 0)
 				goto out;
 		} else if (!mod_data.removable) {
-			ERROR(fsg, "no file given for LUN%d\n", i);
+			INFO(fsg, "no file given for LUN%d\n", i);
 			rc = -EINVAL;
 			goto out;
 		}
 	}
 
-	/* Find all the endpoints we will use */
-	usb_ep_autoconfig_reset(gadget);
-	ep = usb_ep_autoconfig(gadget, &fs_bulk_in_desc);
-	if (!ep)
-		goto autoconf_fail;
-	ep->driver_data = fsg;		// claim the endpoint
-	fsg->bulk_in = ep;
-
-	ep = usb_ep_autoconfig(gadget, &fs_bulk_out_desc);
-	if (!ep)
-		goto autoconf_fail;
-	ep->driver_data = fsg;		// claim the endpoint
-	fsg->bulk_out = ep;
-
-	if (transport_is_cbi()) {
-		ep = usb_ep_autoconfig(gadget, &fs_intr_in_desc);
-		if (!ep)
-			goto autoconf_fail;
-		ep->driver_data = fsg;		// claim the endpoint
-		fsg->intr_in = ep;
-	}
-
 	/* Fix up the descriptors */
 	device_desc.bMaxPacketSize0 = fsg->ep0->maxpacket;
+#ifdef HIGHSPEED
+	dev_qualifier.bMaxPacketSize0 = fsg->ep0->maxpacket;		// ???
+#endif
 	device_desc.idVendor = cpu_to_le16(mod_data.vendor);
 	device_desc.idProduct = cpu_to_le16(mod_data.product);
 	device_desc.bcdDevice = cpu_to_le16(mod_data.release);
 
 	i = (transport_is_cbi() ? 3 : 2);	// Number of endpoints
+	config_desc.wTotalLength = USB_DT_CONFIG_SIZE + USB_DT_INTERFACE_SIZE
+			+ USB_DT_ENDPOINT_SIZE * i;
 	intf_desc.bNumEndpoints = i;
 	intf_desc.bInterfaceSubClass = mod_data.protocol_type;
 	intf_desc.bInterfaceProtocol = mod_data.transport_type;
-	fs_function[i+1] = NULL;
 
-#ifdef CONFIG_USB_GADGET_DUALSPEED
-	hs_function[i+1] = NULL;
-
-	/* Assume ep0 uses the same maxpacket value for both speeds */
-	dev_qualifier.bMaxPacketSize0 = fsg->ep0->maxpacket;
-
-	/* Assume that all endpoint addresses are the same for both speeds */
-	hs_bulk_in_desc.bEndpointAddress = fs_bulk_in_desc.bEndpointAddress;
-	hs_bulk_out_desc.bEndpointAddress = fs_bulk_out_desc.bEndpointAddress;
-	hs_intr_in_desc.bEndpointAddress = fs_intr_in_desc.bEndpointAddress;
-#endif
+	/* Find all the endpoints we will use */
+	gadget_for_each_ep(ep, gadget) {
+		if (strcmp(ep->name, EP_BULK_IN_NAME) == 0)
+			fsg->bulk_in = ep;
+		else if (strcmp(ep->name, EP_BULK_OUT_NAME) == 0)
+			fsg->bulk_out = ep;
+		else if (strcmp(ep->name, EP_INTR_IN_NAME) == 0)
+			fsg->intr_in = ep;
+	}
+	if (!fsg->bulk_in || !fsg->bulk_out ||
+			(transport_is_cbi() && !fsg->intr_in)) {
+		DBG(fsg, "unable to find all endpoints\n");
+		rc = -ENOTSUPP;
+		goto out;
+	}
+	fsg->bulk_out_maxpacket = (gadget->speed == USB_SPEED_HIGH ? 512 :
+			FS_BULK_OUT_MAXPACKET);
 
 	rc = -ENOMEM;
 
@@ -3923,10 +4023,6 @@
 	/* This should reflect the actual gadget power source */
 	usb_gadget_set_selfpowered(gadget);
 
-	snprintf(manufacturer, sizeof manufacturer,
-			UTS_SYSNAME " " UTS_RELEASE " with %s",
-			gadget->name);
-
 	/* On a real device, serial[] would be loaded from permanent
 	 * storage.  We just encode it from the driver version string. */
 	for (i = 0; i < sizeof(serial) - 2; i += 2) {
@@ -3975,10 +4071,6 @@
 	DBG(fsg, "I/O thread pid: %d\n", fsg->thread_pid);
 	return 0;
 
-autoconf_fail:
-	ERROR(fsg, "unable to autoconfigure all endpoints\n");
-	rc = -ENOTSUPP;
-
 out:
 	fsg->state = FSG_STATE_TERMINATED;	// The thread is dead
 	fsg_unbind(gadget);
@@ -3989,27 +4081,8 @@
 
 /*-------------------------------------------------------------------------*/
 
-static void fsg_suspend(struct usb_gadget *gadget)
-{
-	struct fsg_dev		*fsg = get_gadget_data(gadget);
-
-	DBG(fsg, "suspend\n");
-	set_bit(SUSPENDED, &fsg->atomic_bitflags);
-}
-
-static void fsg_resume(struct usb_gadget *gadget)
-{
-	struct fsg_dev		*fsg = get_gadget_data(gadget);
-
-	DBG(fsg, "resume\n");
-	clear_bit(SUSPENDED, &fsg->atomic_bitflags);
-}
-
-
-/*-------------------------------------------------------------------------*/
-
 static struct usb_gadget_driver		fsg_driver = {
-#ifdef CONFIG_USB_GADGET_DUALSPEED
+#ifdef HIGHSPEED
 	.speed		= USB_SPEED_HIGH,
 #else
 	.speed		= USB_SPEED_FULL,
@@ -4019,8 +4092,6 @@
 	.unbind		= fsg_unbind,
 	.disconnect	= fsg_disconnect,
 	.setup		= fsg_setup,
-	.suspend	= fsg_suspend,
-	.resume		= fsg_resume,
 
 	.driver		= {
 		.name		= (char *) shortname,
@@ -4060,6 +4131,8 @@
 {
 	int		rc;
 	struct fsg_dev	*fsg;
+	int		i;
+	struct lun	*curlun;
 
 	if ((rc = fsg_alloc()) != 0)
 		return rc;
@@ -4070,6 +4143,19 @@
 	}
 	set_bit(REGISTERED, &fsg->atomic_bitflags);
 
+	/* Register the LUN devices and their attribute files */
+	for (i = 0; i < fsg->nluns; ++i) {
+		curlun = &fsg->luns[i];
+		if ((rc = device_register(&curlun->dev)) != 0)
+			INFO(fsg, "failed to register LUN%d: %d\n", i, rc);
+		else {
+			curlun->registered = 1;
+			curlun->dev.release = lun_release;
+			device_create_file(&curlun->dev, &dev_attr_ro);
+			device_create_file(&curlun->dev, &dev_attr_file);
+		}
+	}
+
 	/* Tell the thread to start working */
 	complete(&fsg->thread_notifier);
 	return 0;
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/gadget_chips.h linuxppc-2.6.9-dream/drivers/usb/gadget/gadget_chips.h
--- linuxppc-2.6.9/drivers/usb/gadget/gadget_chips.h	2004-10-18 23:53:05.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/gadget_chips.h	2005-09-19 21:40:05.000000000 +0200
@@ -14,13 +14,7 @@
 #define	gadget_is_net2280(g)	0
 #endif
 
-#ifdef CONFIG_USB_GADGET_DUMMY_HCD
-#define	gadget_is_dummy(g)	!strcmp("dummy_udc", (g)->name)
-#else
-#define	gadget_is_dummy(g)	0
-#endif
-
-#ifdef CONFIG_USB_GADGET_PXA2XX
+#ifdef CONFIG_USB_GADGET_PXA
 #define	gadget_is_pxa(g)	!strcmp("pxa2xx_udc", (g)->name)
 #else
 #define	gadget_is_pxa(g)	0
@@ -44,12 +38,6 @@
 #define	gadget_is_sa1100(g)	0
 #endif
 
-#ifdef CONFIG_USB_GADGET_LH7A40X
-#define	gadget_is_lh7a40x(g)	!strcmp("lh7a40x_udc", (g)->name)
-#else
-#define	gadget_is_lh7a40x(g)	0
-#endif
-
 #ifdef CONFIG_USB_GADGET_MQ11XX
 #define	gadget_is_mq11xx(g)	!strcmp("mq11xx_udc", (g)->name)
 #else
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/goku_udc.c linuxppc-2.6.9-dream/drivers/usb/gadget/goku_udc.c
--- linuxppc-2.6.9/drivers/usb/gadget/goku_udc.c	2004-10-18 23:53:21.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/goku_udc.c	2005-09-19 21:40:05.000000000 +0200
@@ -1562,7 +1562,8 @@
 					if (dev->ep[tmp].is_in)
 						goto stall;
 				}
-				if (ctrl.wValue != USB_ENDPOINT_HALT)
+				/* endpoint halt */
+				if (ctrl.wValue != 0)
 					goto stall;
 				if (tmp)
 					goku_clear_halt(&dev->ep[tmp]);
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/inode.c linuxppc-2.6.9-dream/drivers/usb/gadget/inode.c
--- linuxppc-2.6.9/drivers/usb/gadget/inode.c	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/inode.c	2005-09-19 21:40:05.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * inode.c -- user mode filesystem api for usb gadget controllers
  *
- * Copyright (C) 2003-2004 David Brownell
+ * Copyright (C) 2003 David Brownell
  * Copyright (C) 2003 Agilent Technologies
  *
  * This program is free software; you can redistribute it and/or modify
@@ -20,7 +20,7 @@
  */
 
 
-// #define	DEBUG 			/* data to help fault diagnosis */
+#define	DEBUG 1			/* data to help fault diagnosis */
 // #define	VERBOSE		/* extra debug messages (success too) */
 
 #include <linux/init.h>
@@ -44,8 +44,7 @@
  * The gadgetfs API maps each endpoint to a file descriptor so that you
  * can use standard synchronous read/write calls for I/O.  There's some
  * O_NONBLOCK and O_ASYNC/FASYNC style i/o support.  Example usermode
- * drivers show how this works in practice.  You can also use AIO to
- * eliminate I/O gaps between requests, to help when streaming data.
+ * drivers show how this works in practice.
  *
  * Key parts that must be USB-specific are protocols defining how the
  * read/write operations relate to the hardware state machines.  There
@@ -71,7 +70,7 @@
  */
 
 #define	DRIVER_DESC	"USB Gadget filesystem"
-#define	DRIVER_VERSION	"24 Aug 2004"
+#define	DRIVER_VERSION	"20 Aug 2003"
 
 static const char driver_desc [] = DRIVER_DESC;
 static const char shortname [] = "gadgetfs";
@@ -171,7 +170,7 @@
 
 	dev = kmalloc (sizeof *dev, GFP_KERNEL);
 	if (!dev)
-		return NULL;
+		return 0;
 	memset (dev, 0, sizeof *dev);
 	dev->state = STATE_DEV_DISABLED;
 	atomic_set (&dev->count, 1);
@@ -229,12 +228,33 @@
 /*----------------------------------------------------------------------*/
 
 /* most "how to use the hardware" policy choices are in userspace:
- * mapping endpoint roles (which the driver needs) to the capabilities
- * which the usb controller has.  most of those capabilities are exposed
- * implicitly, starting with the driver name and then endpoint names.
+ * mapping endpoint roles the driver needs to the capabilities that
+ * the usb controller exposes.
  */
 
-static const char *CHIP;
+#ifdef	CONFIG_USB_GADGET_DUMMY_HCD
+/* act (mostly) like a net2280 */
+#define CONFIG_USB_GADGET_NET2280
+#endif
+
+#ifdef	CONFIG_USB_GADGET_NET2280
+#define CHIP			"net2280"
+#define HIGHSPEED
+#endif
+
+#ifdef	CONFIG_USB_GADGET_PXA2XX
+#define CHIP			"pxa2xx_udc"
+/* earlier hardware doesn't have UDCCFR, races set_{config,interface} */
+#warning works best with pxa255 or newer
+#endif
+
+#ifdef	CONFIG_USB_GADGET_GOKU
+#define CHIP			"goku_udc"
+#endif
+
+#ifdef	CONFIG_USB_GADGET_SA1100
+#define CHIP			"sa1100"
+#endif
 
 /*----------------------------------------------------------------------*/
 
@@ -519,207 +539,16 @@
 	return status;
 }
 
-/*----------------------------------------------------------------------*/
-
-/* ASYNCHRONOUS ENDPOINT I/O OPERATIONS (bulk/intr/iso) */
-
-struct kiocb_priv {
-	struct usb_request	*req;
-	struct ep_data		*epdata;
-	void			*buf;
-	char __user		*ubuf;
-	unsigned		actual;
-};
-
-static int ep_aio_cancel(struct kiocb *iocb, struct io_event *e)
-{
-	struct kiocb_priv	*priv = iocb->private;
-	struct ep_data		*epdata;
-	int			value;
-
-	local_irq_disable();
-	epdata = priv->epdata;
-	// spin_lock(&epdata->dev->lock);
-	kiocbSetCancelled(iocb);
-	if (likely(epdata && epdata->ep && priv->req))
-		value = usb_ep_dequeue (epdata->ep, priv->req);
-	else
-		value = -EINVAL;
-	// spin_unlock(&epdata->dev->lock);
-	local_irq_enable();
-
-	aio_put_req(iocb);
-	return value;
-}
-
-static ssize_t ep_aio_read_retry(struct kiocb *iocb)
-{
-	struct kiocb_priv	*priv = iocb->private;
-	ssize_t			status = priv->actual;
-
-	/* we "retry" to get the right mm context for this: */
-	status = copy_to_user(priv->ubuf, priv->buf, priv->actual);
-	if (unlikely(0 != status))
-		status = -EFAULT;
-	else
-		status = priv->actual;
-	kfree(priv->buf);
-	kfree(priv);
-	aio_put_req(iocb);
-	return status;
-}
-
-static void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)
-{
-	struct kiocb		*iocb = req->context;
-	struct kiocb_priv	*priv = iocb->private;
-	struct ep_data		*epdata = priv->epdata;
-
-	/* lock against disconnect (and ideally, cancel) */
-	spin_lock(&epdata->dev->lock);
-	priv->req = NULL;
-	priv->epdata = NULL;
-	if (NULL == iocb->ki_retry
-			|| unlikely(0 == req->actual)
-			|| unlikely(kiocbIsCancelled(iocb))) {
-		kfree(req->buf);
-		kfree(priv);
-		iocb->private = NULL;
-		/* aio_complete() reports bytes-transferred _and_ faults */
-		if (unlikely(kiocbIsCancelled(iocb)))
-			aio_put_req(iocb);
-		else
-			aio_complete(iocb,
-				req->actual ? req->actual : req->status,
-				req->status);
-	} else {
-		/* retry() won't report both; so we hide some faults */
-		if (unlikely(0 != req->status))
-			DBG(epdata->dev, "%s fault %d len %d\n",
-				ep->name, req->status, req->actual);
-
-		priv->buf = req->buf;
-		priv->actual = req->actual;
-		kick_iocb(iocb);
-	}
-	spin_unlock(&epdata->dev->lock);
-
-	usb_ep_free_request(ep, req);
-	put_ep(epdata);
-}
-
-static ssize_t
-ep_aio_rwtail(
-	struct kiocb	*iocb,
-	char		*buf,
-	size_t		len,
-	struct ep_data	*epdata,
-	char __user	*ubuf
-)
-{
-	struct kiocb_priv	*priv = (void *) &iocb->private;
-	struct usb_request	*req;
-	ssize_t			value;
-
-	priv = kmalloc(sizeof *priv, GFP_KERNEL);
-	if (!priv) {
-		value = -ENOMEM;
-fail:
-		kfree(buf);
-		return value;
-	}
-	iocb->private = priv;
-	priv->ubuf = ubuf;
-
-	value = get_ready_ep(iocb->ki_filp->f_flags, epdata);
-	if (unlikely(value < 0)) {
-		kfree(priv);
-		goto fail;
-	}
-
-	iocb->ki_cancel = ep_aio_cancel;
-	get_ep(epdata);
-	priv->epdata = epdata;
-	priv->actual = 0;
-
-	/* each kiocb is coupled to one usb_request, but we can't
-	 * allocate or submit those if the host disconnected.
-	 */
-	spin_lock_irq(&epdata->dev->lock);
-	if (likely(epdata->ep)) {
-		req = usb_ep_alloc_request(epdata->ep, GFP_ATOMIC);
-		if (likely(req)) {
-			priv->req = req;
-			req->buf = buf;
-			req->length = len;
-			req->complete = ep_aio_complete;
-			req->context = iocb;
-			value = usb_ep_queue(epdata->ep, req, GFP_ATOMIC);
-			if (unlikely(0 != value))
-				usb_ep_free_request(epdata->ep, req);
-		} else
-			value = -EAGAIN;
-	} else
-		value = -ENODEV;
-	spin_unlock_irq(&epdata->dev->lock);
-
-	up(&epdata->lock);
-
-	if (unlikely(value)) {
-		kfree(priv);
-		put_ep(epdata);
-	} else
-		value = -EIOCBQUEUED;
-	return value;
-}
-
-static ssize_t
-ep_aio_read(struct kiocb *iocb, char __user *ubuf, size_t len, loff_t o)
-{
-	struct ep_data		*epdata = iocb->ki_filp->private_data;
-	char			*buf;
-
-	if (unlikely(epdata->desc.bEndpointAddress & USB_DIR_IN))
-		return -EINVAL;
-	buf = kmalloc(len, GFP_KERNEL);
-	if (unlikely(!buf))
-		return -ENOMEM;
-	iocb->ki_retry = ep_aio_read_retry;
-	return ep_aio_rwtail(iocb, buf, len, epdata, ubuf);
-}
-
-static ssize_t
-ep_aio_write(struct kiocb *iocb, const char __user *ubuf, size_t len, loff_t o)
-{
-	struct ep_data		*epdata = iocb->ki_filp->private_data;
-	char			*buf;
-
-	if (unlikely(!(epdata->desc.bEndpointAddress & USB_DIR_IN)))
-		return -EINVAL;
-	buf = kmalloc(len, GFP_KERNEL);
-	if (unlikely(!buf))
-		return -ENOMEM;
-	if (unlikely(copy_from_user(buf, ubuf, len) != 0)) {
-		kfree(buf);
-		return -EFAULT;
-	}
-	return ep_aio_rwtail(iocb, buf, len, epdata, NULL);
-}
-
-/*----------------------------------------------------------------------*/
-
 /* used after endpoint configuration */
 static struct file_operations ep_io_operations = {
 	.owner =	THIS_MODULE,
-	.llseek =	no_llseek,
-
 	.read =		ep_read,
 	.write =	ep_write,
 	.ioctl =	ep_ioctl,
 	.release =	ep_release,
 
-	.aio_read =	ep_aio_read,
-	.aio_write =	ep_aio_write,
+	// .aio_read =	ep_aio_read,
+	// .aio_write =	ep_aio_write,
 };
 
 /* ENDPOINT INITIALIZATION
@@ -736,7 +565,7 @@
  * speed descriptor, then optional high speed descriptor.
  */
 static ssize_t
-ep_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
+ep_config (struct file *fd, const char *buf, size_t len, loff_t *ptr)
 {
 	struct ep_data		*data = fd->private_data;
 	struct usb_ep		*ep;
@@ -869,8 +698,6 @@
 /* used before endpoint configuration */
 static struct file_operations ep_config_operations = {
 	.owner =	THIS_MODULE,
-	.llseek =	no_llseek,
-
 	.open =		ep_open,
 	.write =	ep_config,
 	.release =	ep_release,
@@ -945,7 +772,7 @@
 }
 
 static ssize_t
-ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)
+ep0_read (struct file *fd, char *buf, size_t len, loff_t *ptr)
 {
 	struct dev_data			*dev = fd->private_data;
 	ssize_t				retval;
@@ -977,18 +804,6 @@
 				retval = usb_ep_queue (ep, req, GFP_ATOMIC);
 			dev->state = STATE_CONNECTED;
 
-			/* assume that was SET_CONFIGURATION */
-			if (dev->current_config) {
-				unsigned power;
-#ifdef	HIGHSPEED
-				if (dev->gadget->speed == USB_SPEED_HIGH)
-					power = dev->hs_config->bMaxPower;
-				else
-#endif
-					power = dev->config->bMaxPower;
-				usb_gadget_vbus_draw(dev->gadget, 2 * power);
-			}
-
 		} else {			/* collect OUT data */
 			if ((fd->f_flags & O_NONBLOCK) != 0
 					&& !dev->setup_out_ready) {
@@ -1138,7 +953,7 @@
 }
 
 static ssize_t
-ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
+ep0_write (struct file *fd, const char *buf, size_t len, loff_t *ptr)
 {
 	struct dev_data		*dev = fd->private_data;
 	ssize_t			retval = -ESRCH;
@@ -1217,7 +1032,7 @@
 
 	fasync_helper (-1, fd, 0, &dev->fasync);
 	kfree (dev->buf);
-	dev->buf = NULL;
+	dev->buf = 0;
 	put_dev (dev);
 
 	/* other endpoints were all decoupled from this device */
@@ -1239,8 +1054,6 @@
 /* used after device configuration */
 static struct file_operations ep0_io_operations = {
 	.owner =	THIS_MODULE,
-	.llseek =	no_llseek,
-
 	.read =		ep0_read,
 	.write =	ep0_write,
 	.fasync =	ep0_fasync,
@@ -1371,7 +1184,7 @@
 
 	req->buf = dev->rbuf;
 	req->dma = DMA_ADDR_INVALID;
-	req->context = NULL;
+	req->context = 0;
 	value = -EOPNOTSUPP;
 	switch (ctrl->bRequest) {
 
@@ -1417,25 +1230,19 @@
 		if (0 == (u8) ctrl->wValue) {
 			value = 0;
 			dev->current_config = 0;
-			usb_gadget_vbus_draw(gadget, 8 /* mA */ );
 			// user mode expected to disable endpoints
 		} else {
-			u8	config, power;
+			u8	config;
 #ifdef	HIGHSPEED
-			if (gadget->speed == USB_SPEED_HIGH) {
+			if (gadget->speed == USB_SPEED_HIGH)
 				config = dev->hs_config->bConfigurationValue;
-				power = dev->hs_config->bMaxPower;
-			} else
+			else
 #endif
-			{
 				config = dev->config->bConfigurationValue;
-				power = dev->config->bMaxPower;
-			}
 
 			if (config == (u8) ctrl->wValue) {
 				value = 0;
 				dev->current_config = config;
-				usb_gadget_vbus_draw(gadget, 2 * power);
 			}
 		}
 
@@ -1513,8 +1320,6 @@
 	/* proceed with data transfer and status phases? */
 	if (value >= 0 && dev->state != STATE_SETUP) {
 		req->length = value;
-		req->zero = value < ctrl->wLength
-				&& (value % gadget->ep0->maxpacket) == 0;
 		value = usb_ep_queue (gadget->ep0, req, GFP_ATOMIC);
 		if (value < 0) {
 			DBG (dev, "ep_queue --> %d\n", value);
@@ -1545,7 +1350,7 @@
 		ep = list_entry (entry, struct ep_data, epfiles);
 		list_del_init (&ep->epfiles);
 		dentry = ep->dentry;
-		ep->dentry = NULL;
+		ep->dentry = 0;
 		parent = dentry->d_parent->d_inode;
 
 		/* break link to controller */
@@ -1553,7 +1358,7 @@
 			(void) usb_ep_disable (ep->ep);
 		ep->state = STATE_EP_UNBOUND;
 		usb_ep_free_request (ep->ep, ep->req);
-		ep->ep = NULL;
+		ep->ep = 0;
 		wake_up (&ep->wait);
 		put_ep (ep);
 
@@ -1633,8 +1438,8 @@
 	spin_unlock_irq (&dev->lock);
 
 	destroy_ep_files (dev);
-	gadget->ep0->driver_data = NULL;
-	set_gadget_data (gadget, NULL);
+	gadget->ep0->driver_data = 0;
+	set_gadget_data (gadget, 0);
 
 	/* we've already been disconnected ... no i/o is active */
 	if (dev->req)
@@ -1653,8 +1458,8 @@
 	if (!dev)
 		return -ESRCH;
 	if (0 != strcmp (CHIP, gadget->name)) {
-		printk (KERN_ERR "%s expected %s controller not %s\n",
-			shortname, CHIP, gadget->name);
+		printk (KERN_ERR "%s expected " CHIP " controller not %s\n",
+			shortname, gadget->name);
 		return -ENODEV;
 	}
 
@@ -1667,7 +1472,7 @@
 	dev->req = usb_ep_alloc_request (gadget->ep0, GFP_KERNEL);
 	if (!dev->req)
 		goto enomem;
-	dev->req->context = NULL;
+	dev->req->context = 0;
 	dev->req->complete = epio_complete;
 
 	if (activate_ep_files (dev) < 0)
@@ -1744,26 +1549,6 @@
 
 /*----------------------------------------------------------------------*/
 
-static void gadgetfs_nop(struct usb_gadget *arg) { }
-
-static int gadgetfs_probe (struct usb_gadget *gadget)
-{
-	CHIP = gadget->name;
-	return -EISNAM;
-}
-
-static struct usb_gadget_driver probe_driver = {
-	.speed		= USB_SPEED_HIGH,
-	.bind		= gadgetfs_probe,
-	.unbind		= gadgetfs_nop,
-	.setup		= (void *)gadgetfs_nop,
-	.disconnect	= gadgetfs_nop,
-	.driver 	= {
-		.name		= "nop",
-	},
-};
-
-
 /* DEVICE INITIALIZATION
  *
  *     fd = open ("/dev/gadget/$CHIP", O_RDWR)
@@ -1800,12 +1585,11 @@
 		&& config->bConfigurationValue != 0
 		&& (config->bmAttributes & USB_CONFIG_ATT_ONE) != 0
 		&& (config->bmAttributes & USB_CONFIG_ATT_WAKEUP) == 0;
-	/* FIXME if gadget->is_otg, _must_ include an otg descriptor */
 	/* FIXME check lengths: walk to end */
 }
 
 static ssize_t
-dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
+dev_config (struct file *fd, const char *buf, size_t len, loff_t *ptr)
 {
 	struct dev_data		*dev = fd->private_data;
 	ssize_t			value = len, length = len;
@@ -1877,7 +1661,7 @@
 	value = usb_gadget_register_driver (&gadgetfs_driver);
 	if (value != 0) {
 		kfree (dev->buf);
-		dev->buf = NULL;
+		dev->buf = 0;
 	} else {
 		/* at this point "good" hardware has for the first time
 		 * let the USB the host see us.  alternatively, if users
@@ -1897,7 +1681,7 @@
 	spin_unlock_irq (&dev->lock);
 	pr_debug ("%s: %s fail %Zd, %p\n", shortname, __FUNCTION__, value, dev);
 	kfree (dev->buf);
-	dev->buf = NULL;
+	dev->buf = 0;
 	return value;
 }
 
@@ -1919,8 +1703,6 @@
 
 static struct file_operations dev_init_operations = {
 	.owner =	THIS_MODULE,
-	.llseek =	no_llseek,
-
 	.open =		dev_open,
 	.write =	dev_config,
 	.fasync =	ep0_fasync,
@@ -1988,13 +1770,13 @@
 	qname.hash = full_name_hash (qname.name, qname.len);
 	dentry = d_alloc (sb->s_root, &qname);
 	if (!dentry)
-		return NULL;
+		return 0;
 
 	inode = gadgetfs_make_inode (sb, data, fops,
 			S_IFREG | (default_perm & S_IRWXUGO));
 	if (!inode) {
 		dput(dentry);
-		return NULL;
+		return 0;
 	}
 	d_add (dentry, inode);
 	*dentry_p = dentry;
@@ -2016,11 +1798,6 @@
 	if (the_device)
 		return -ESRCH;
 
-	/* fake probe to determine $CHIP */
-	(void) usb_gadget_register_driver (&probe_driver);
-	if (!CHIP)
-		return -ENODEV;
-
 	/* superblock */
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
@@ -2029,7 +1806,7 @@
 
 	/* root inode */
 	inode = gadgetfs_make_inode (sb,
-			NULL, &simple_dir_operations,
+			0, &simple_dir_operations,
 			S_IFDIR | S_IRUGO | S_IXUGO);
 	if (!inode)
 		return -ENOMEM;
@@ -2076,7 +1853,7 @@
 	kill_litter_super (sb);
 	if (the_device) {
 		put_dev (the_device);
-		the_device = NULL;
+		the_device = 0;
 	}
 }
 
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/Kconfig linuxppc-2.6.9-dream/drivers/usb/gadget/Kconfig
--- linuxppc-2.6.9/drivers/usb/gadget/Kconfig	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/Kconfig	2005-09-19 21:40:05.000000000 +0200
@@ -71,8 +71,8 @@
 	default USB_GADGET
 
 config USB_GADGET_PXA2XX
-	boolean "PXA 2xx or IXP 4xx"
-	depends on ARCH_PXA || ARCH_IXP4XX
+	boolean "PXA 2xx or IXP 42x"
+	depends on ARCH_PXA || ARCH_IXP425
 	help
 	   Intel's PXA 2xx series XScale ARM-5TE processors include
 	   an integrated full speed USB 1.1 device controller.  The
@@ -95,7 +95,6 @@
 config USB_PXA2XX_SMALL
 	depends on USB_GADGET_PXA2XX
 	bool
-	default n if USB_ETH_RNDIS
 	default y if USB_ZERO
 	default y if USB_ETH
 	default y if USB_G_SERIAL
@@ -135,81 +134,6 @@
 	depends on USB_GADGET_SA1100
 	default USB_GADGET
 
-config USB_GADGET_LH7A40X
-	boolean "LH7A40X"
-	depends on ARCH_LH7A40X
-	help
-    This driver provides USB Device Controller driver for LH7A40x
-
-config USB_LH7A40X
-	tristate
-	depends on USB_GADGET_LH7A40X
-	default USB_GADGET
-
-
-config USB_GADGET_DUMMY_HCD
-	boolean "Dummy HCD (DEVELOPMENT)"
-	depends on USB && EXPERIMENTAL
-	select USB_GADGET_DUALSPEED
-	help
-	  This host controller driver emulates USB, looping all data transfer
-	  requests back to a USB "gadget driver" in the same host.  The host
-	  side is the master; the gadget side is the slave.  Gadget drivers
-	  can be high, full, or low speed; and they have access to endpoints
-	  like those from NET2280, PXA2xx, or SA1100 hardware.
-	  
-	  This may help in some stages of creating a driver to embed in a
-	  Linux device, since it lets you debug several parts of the gadget
-	  driver without its hardware or drivers being involved.
-	  
-	  Since such a gadget side driver needs to interoperate with a host
-	  side Linux-USB device driver, this may help to debug both sides
-	  of a USB protocol stack.
-
-	  Say "y" to link the driver statically, or "m" to build a
-	  dynamically linked module called "dummy_hcd" and force all
-	  gadget drivers to also be dynamically linked.
-
-config USB_DUMMY_HCD
-	tristate
-	depends on USB_GADGET_DUMMY_HCD
-	default USB_GADGET
-
-config USB_GADGET_OMAP
-	boolean "OMAP USB Device Controller"
-	depends on ARCH_OMAP
-	select ISP1301_OMAP if MACH_OMAP_H2
-	help
-	   Many Texas Instruments OMAP processors have flexible full
-	   speed USB device controllers, with support for up to 30
-	   endpoints (plus endpoint zero).  This driver supports the
-	   controller in the OMAP 1611, and should work with controllers
-	   in other OMAP processors too, given minor tweaks.
-
-	   Say "y" to link the driver statically, or "m" to build a
-	   dynamically linked module called "omap_udc" and force all
-	   gadget drivers to also be dynamically linked.
-
-config USB_OMAP
-	tristate
-	depends on USB_GADGET_OMAP
-	default USB_GADGET
-
-config USB_OTG
-	boolean "OTG Support"
-	depends on USB_GADGET_OMAP && ARCH_OMAP_OTG && USB_OHCI_HCD
-	help
-	   The most notable feature of USB OTG is support for a
-	   "Dual-Role" device, which can act as either a device
-	   or a host.  The initial role choice can be changed
-	   later, when two dual-role devices talk to each other.
-
-	   Select this only if your OMAP board has a Mini-AB connector.
-
-config USB_OMAP_PROC
-	boolean "/proc/driver/udc file"
-	depends on USB_GADGET_OMAP
-
 endchoice
 
 config USB_GADGET_DUALSPEED
@@ -255,16 +179,6 @@
 	  Say "y" to link the driver statically, or "m" to build a
 	  dynamically linked module called "g_zero".
 
-config USB_ZERO_HNPTEST
-	boolean "HNP Test Device"
-	depends on USB_ZERO && USB_OTG
-	help
-	  You can configure this device to enumerate using the device
-	  identifiers of the USB-OTG test device.  That means that when
-	  this gadget connects to another OTG device, with this one using
-	  the "B-Peripheral" role, that device will use HNP to let this
-	  one serve as the USB host instead (in the "B-Host" role).
-
 config USB_ETH
 	tristate "Ethernet Gadget"
 	depends on NET
@@ -277,11 +191,9 @@
 	     favor of simpler vendor-specific hardware, but is widely
 	     supported by firmware for smart network devices.
 
-	   - On hardware can't implement that protocol, a simple CDC subset
+	   - On hardware can't implement that protocol, a simpler approach
 	     is used, placing fewer demands on USB.
 
-	  RNDIS support is a third option, more demanding than that subset.
-
 	  Within the USB device, this gadget driver exposes a network device
 	  "usbX", where X depends on what other networking devices you have.
 	  Treat it like a two-node Ethernet link:  host, and gadget.
@@ -295,19 +207,6 @@
 	  Say "y" to link the driver statically, or "m" to build a
 	  dynamically linked module called "g_ether".
 
-config USB_ETH_RNDIS
-	bool "RNDIS support (EXPERIMENTAL)"
-	depends on USB_ETH && EXPERIMENTAL
-	default y
-	help
-	   Microsoft Windows XP bundles the "Remote NDIS" (RNDIS) protocol,
-	   and Microsoft provides redistributable binary RNDIS drivers for
-	   older versions of Windows.
-
-	   If you say "y" here, the Ethernet gadget driver will try to provide
-	   a second device configuration, supporting RNDIS to talk to such
-	   Microsoft USB hosts.
-
 config USB_GADGETFS
 	tristate "Gadget Filesystem (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
@@ -322,7 +221,7 @@
 	  dynamically linked module called "gadgetfs".
 
 config USB_FILE_STORAGE
-	tristate "File-backed Storage Gadget"
+	tristate "File-backed Storage Gadget (DEVELOPMENT)"
 	# we don't support the SA1100 because of its limitations
 	depends on USB_GADGET_SA1100 = n
 	help
@@ -335,7 +234,7 @@
 	  dynamically linked module called "g_file_storage".
 
 config USB_FILE_STORAGE_TEST
-	bool "File-backed Storage Gadget testing version"
+	bool "File-backed Storage Gadget test version"
 	depends on USB_FILE_STORAGE
 	default n
 	help
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/lh7a40x_udc.c linuxppc-2.6.9-dream/drivers/usb/gadget/lh7a40x_udc.c
--- linuxppc-2.6.9/drivers/usb/gadget/lh7a40x_udc.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/lh7a40x_udc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2168 +0,0 @@
-/*
- * linux/drivers/usb/gadget/lh7a40x_udc.c
- * Sharp LH7A40x on-chip full speed USB device controllers
- *
- * Copyright (C) 2004 Mikko Lahteenmaki, Nordic ID
- * Copyright (C) 2004 Bo Henriksen, Nordic ID
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#include "lh7a40x_udc.h"
-
-//#define DEBUG printk
-//#define DEBUG_EP0 printk
-//#define DEBUG_SETUP printk
-
-#ifndef DEBUG_EP0
-# define DEBUG_EP0(fmt,args...)
-#endif
-#ifndef DEBUG_SETUP
-# define DEBUG_SETUP(fmt,args...)
-#endif
-#ifndef DEBUG
-# define NO_STATES
-# define DEBUG(fmt,args...)
-#endif
-
-#define	DRIVER_DESC			"LH7A40x USB Device Controller"
-#define	DRIVER_VERSION		__DATE__
-
-#ifndef _BIT			/* FIXME - what happended to _BIT in 2.6.7bk18? */
-#define _BIT(x) (1<<(x))
-#endif
-
-struct lh7a40x_udc *the_controller;
-
-static const char driver_name[] = "lh7a40x_udc";
-static const char driver_desc[] = DRIVER_DESC;
-static const char ep0name[] = "ep0-control";
-
-/*
-  Local definintions.
-*/
-#define UDC_PROC_FILE
-
-#ifndef NO_STATES
-static char *state_names[] = {
-	"WAIT_FOR_SETUP",
-	"DATA_STATE_XMIT",
-	"DATA_STATE_NEED_ZLP",
-	"WAIT_FOR_OUT_STATUS",
-	"DATA_STATE_RECV"
-};
-#endif
-
-/*
-  Local declarations.
-*/
-static int lh7a40x_ep_enable(struct usb_ep *ep,
-			     const struct usb_endpoint_descriptor *);
-static int lh7a40x_ep_disable(struct usb_ep *ep);
-static struct usb_request *lh7a40x_alloc_request(struct usb_ep *ep, int);
-static void lh7a40x_free_request(struct usb_ep *ep, struct usb_request *);
-static void *lh7a40x_alloc_buffer(struct usb_ep *ep, unsigned, dma_addr_t *,
-				  int);
-static void lh7a40x_free_buffer(struct usb_ep *ep, void *, dma_addr_t,
-				unsigned);
-static int lh7a40x_queue(struct usb_ep *ep, struct usb_request *, int);
-static int lh7a40x_dequeue(struct usb_ep *ep, struct usb_request *);
-static int lh7a40x_set_halt(struct usb_ep *ep, int);
-static int lh7a40x_fifo_status(struct usb_ep *ep);
-static int lh7a40x_fifo_status(struct usb_ep *ep);
-static void lh7a40x_fifo_flush(struct usb_ep *ep);
-static void lh7a40x_ep0_kick(struct lh7a40x_udc *dev, struct lh7a40x_ep *ep);
-static void lh7a40x_handle_ep0(struct lh7a40x_udc *dev, u32 intr);
-
-static void done(struct lh7a40x_ep *ep, struct lh7a40x_request *req,
-		 int status);
-static void pio_irq_enable(int bEndpointAddress);
-static void pio_irq_disable(int bEndpointAddress);
-static void stop_activity(struct lh7a40x_udc *dev,
-			  struct usb_gadget_driver *driver);
-static void flush(struct lh7a40x_ep *ep);
-static void udc_enable(struct lh7a40x_udc *dev);
-static void udc_set_address(struct lh7a40x_udc *dev, unsigned char address);
-
-static struct usb_ep_ops lh7a40x_ep_ops = {
-	.enable = lh7a40x_ep_enable,
-	.disable = lh7a40x_ep_disable,
-
-	.alloc_request = lh7a40x_alloc_request,
-	.free_request = lh7a40x_free_request,
-
-	.alloc_buffer = lh7a40x_alloc_buffer,
-	.free_buffer = lh7a40x_free_buffer,
-
-	.queue = lh7a40x_queue,
-	.dequeue = lh7a40x_dequeue,
-
-	.set_halt = lh7a40x_set_halt,
-	.fifo_status = lh7a40x_fifo_status,
-	.fifo_flush = lh7a40x_fifo_flush,
-};
-
-/* Inline code */
-
-static __inline__ int write_packet(struct lh7a40x_ep *ep,
-				   struct lh7a40x_request *req, int max)
-{
-	u8 *buf;
-	int length, count;
-	volatile u32 *fifo = (volatile u32 *)ep->fifo;
-
-	buf = req->req.buf + req->req.actual;
-	prefetch(buf);
-
-	length = req->req.length - req->req.actual;
-	length = min(length, max);
-	req->req.actual += length;
-
-	DEBUG("Write %d (max %d), fifo %p\n", length, max, fifo);
-
-	count = length;
-	while (count--) {
-		*fifo = *buf++;
-	}
-
-	return length;
-}
-
-static __inline__ void usb_set_index(u32 ep)
-{
-	*(volatile u32 *)io_p2v(USB_INDEX) = ep;
-}
-
-static __inline__ u32 usb_read(u32 port)
-{
-	return *(volatile u32 *)io_p2v(port);
-}
-
-static __inline__ void usb_write(u32 val, u32 port)
-{
-	*(volatile u32 *)io_p2v(port) = val;
-}
-
-static __inline__ void usb_set(u32 val, u32 port)
-{
-	volatile u32 *ioport = (volatile u32 *)io_p2v(port);
-	u32 after = (*ioport) | val;
-	*ioport = after;
-}
-
-static __inline__ void usb_clear(u32 val, u32 port)
-{
-	volatile u32 *ioport = (volatile u32 *)io_p2v(port);
-	u32 after = (*ioport) & ~val;
-	*ioport = after;
-}
-
-/*-------------------------------------------------------------------------*/
-
-#define GPIO_PORTC_DR 	(0x80000E08)
-#define GPIO_PORTC_DDR 	(0x80000E18)
-#define GPIO_PORTC_PDR 	(0x80000E70)
-
-/* get port C pin data register */
-#define get_portc_pdr(bit) 		((usb_read(GPIO_PORTC_PDR) & _BIT(bit)) != 0)
-/* get port C data direction register */
-#define get_portc_ddr(bit) 		((usb_read(GPIO_PORTC_DDR) & _BIT(bit)) != 0)
-/* set port C data register */
-#define set_portc_dr(bit, val) 	(val ? usb_set(_BIT(bit), GPIO_PORTC_DR) : usb_clear(_BIT(bit), GPIO_PORTC_DR))
-/* set port C data direction register */
-#define set_portc_ddr(bit, val) (val ? usb_set(_BIT(bit), GPIO_PORTC_DDR) : usb_clear(_BIT(bit), GPIO_PORTC_DDR))
-
-/*
- * LPD7A404 GPIO's:
- * Port C bit 1 = USB Port 1 Power Enable
- * Port C bit 2 = USB Port 1 Data Carrier Detect
- */
-#define is_usb_connected() 		get_portc_pdr(2)
-
-#ifdef UDC_PROC_FILE
-
-static const char proc_node_name[] = "driver/udc";
-
-static int
-udc_proc_read(char *page, char **start, off_t off, int count,
-	      int *eof, void *_dev)
-{
-	char *buf = page;
-	struct lh7a40x_udc *dev = _dev;
-	char *next = buf;
-	unsigned size = count;
-	unsigned long flags;
-	int t;
-
-	if (off != 0)
-		return 0;
-
-	local_irq_save(flags);
-
-	/* basic device status */
-	t = scnprintf(next, size,
-		      DRIVER_DESC "\n"
-		      "%s version: %s\n"
-		      "Gadget driver: %s\n"
-		      "Host: %s\n\n",
-		      driver_name, DRIVER_VERSION,
-		      dev->driver ? dev->driver->driver.name : "(none)",
-		      is_usb_connected()? "full speed" : "disconnected");
-	size -= t;
-	next += t;
-
-	t = scnprintf(next, size,
-		      "GPIO:\n"
-		      " Port C bit 1: %d, dir %d\n"
-		      " Port C bit 2: %d, dir %d\n\n",
-		      get_portc_pdr(1), get_portc_ddr(1),
-		      get_portc_pdr(2), get_portc_ddr(2)
-	    );
-	size -= t;
-	next += t;
-
-	t = scnprintf(next, size,
-		      "DCP pullup: %d\n\n",
-		      (usb_read(USB_PM) & PM_USB_DCP) != 0);
-	size -= t;
-	next += t;
-
-	local_irq_restore(flags);
-	*eof = 1;
-	return count - size;
-}
-
-#define create_proc_files() 	create_proc_read_entry(proc_node_name, 0, NULL, udc_proc_read, dev)
-#define remove_proc_files() 	remove_proc_entry(proc_node_name, NULL)
-
-#else				/* !UDC_PROC_FILE */
-
-#define create_proc_files() do {} while (0)
-#define remove_proc_files() do {} while (0)
-
-#endif				/* UDC_PROC_FILE */
-
-/*
- * 	udc_disable - disable USB device controller
- */
-static void udc_disable(struct lh7a40x_udc *dev)
-{
-	DEBUG("%s, %p\n", __FUNCTION__, dev);
-
-	udc_set_address(dev, 0);
-
-	/* Disable interrupts */
-	usb_write(0, USB_IN_INT_EN);
-	usb_write(0, USB_OUT_INT_EN);
-	usb_write(0, USB_INT_EN);
-
-	/* Disable the USB */
-	usb_write(0, USB_PM);
-
-#ifdef CONFIG_ARCH_LH7A404
-	/* Disable USB power */
-	set_portc_dr(1, 0);
-#endif
-
-	/* if hardware supports it, disconnect from usb */
-	/* make_usb_disappear(); */
-
-	dev->ep0state = WAIT_FOR_SETUP;
-	dev->gadget.speed = USB_SPEED_UNKNOWN;
-	dev->usb_address = 0;
-}
-
-/*
- * 	udc_reinit - initialize software state
- */
-static void udc_reinit(struct lh7a40x_udc *dev)
-{
-	u32 i;
-
-	DEBUG("%s, %p\n", __FUNCTION__, dev);
-
-	/* device/ep0 records init */
-	INIT_LIST_HEAD(&dev->gadget.ep_list);
-	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
-	dev->ep0state = WAIT_FOR_SETUP;
-
-	/* basic endpoint records init */
-	for (i = 0; i < UDC_MAX_ENDPOINTS; i++) {
-		struct lh7a40x_ep *ep = &dev->ep[i];
-
-		if (i != 0)
-			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
-
-		ep->desc = 0;
-		ep->stopped = 0;
-		INIT_LIST_HEAD(&ep->queue);
-		ep->pio_irqs = 0;
-	}
-
-	/* the rest was statically initialized, and is read-only */
-}
-
-#define BYTES2MAXP(x)	(x / 8)
-#define MAXP2BYTES(x)	(x * 8)
-
-/* until it's enabled, this UDC should be completely invisible
- * to any USB host.
- */
-static void udc_enable(struct lh7a40x_udc *dev)
-{
-	int ep;
-
-	DEBUG("%s, %p\n", __FUNCTION__, dev);
-
-	dev->gadget.speed = USB_SPEED_UNKNOWN;
-
-#ifdef CONFIG_ARCH_LH7A404
-	/* Set Port C bit 1 & 2 as output */
-	set_portc_ddr(1, 1);
-	set_portc_ddr(2, 1);
-
-	/* Enable USB power */
-	set_portc_dr(1, 0);
-#endif
-
-	/*
-	 * C.f Chapter 18.1.3.1 Initializing the USB
-	 */
-
-	/* Disable the USB */
-	usb_clear(PM_USB_ENABLE, USB_PM);
-
-	/* Reset APB & I/O sides of the USB */
-	usb_set(USB_RESET_APB | USB_RESET_IO, USB_RESET);
-	mdelay(5);
-	usb_clear(USB_RESET_APB | USB_RESET_IO, USB_RESET);
-
-	/* Set MAXP values for each */
-	for (ep = 0; ep < UDC_MAX_ENDPOINTS; ep++) {
-		struct lh7a40x_ep *ep_reg = &dev->ep[ep];
-		u32 csr;
-
-		usb_set_index(ep);
-
-		switch (ep_reg->ep_type) {
-		case ep_bulk_in:
-		case ep_interrupt:
-			usb_clear(USB_IN_CSR2_USB_DMA_EN | USB_IN_CSR2_AUTO_SET,
-				  ep_reg->csr2);
-			/* Fall through */
-		case ep_control:
-			usb_write(BYTES2MAXP(ep_maxpacket(ep_reg)),
-				  USB_IN_MAXP);
-			break;
-		case ep_bulk_out:
-			usb_clear(USB_OUT_CSR2_USB_DMA_EN |
-				  USB_OUT_CSR2_AUTO_CLR, ep_reg->csr2);
-			usb_write(BYTES2MAXP(ep_maxpacket(ep_reg)),
-				  USB_OUT_MAXP);
-			break;
-		}
-
-		/* Read & Write CSR1, just in case */
-		csr = usb_read(ep_reg->csr1);
-		usb_write(csr, ep_reg->csr1);
-
-		flush(ep_reg);
-	}
-
-	/* Disable interrupts */
-	usb_write(0, USB_IN_INT_EN);
-	usb_write(0, USB_OUT_INT_EN);
-	usb_write(0, USB_INT_EN);
-
-	/* Enable interrupts */
-	usb_set(USB_IN_INT_EP0, USB_IN_INT_EN);
-	usb_set(USB_INT_RESET_INT | USB_INT_RESUME_INT, USB_INT_EN);
-	/* Dont enable rest of the interrupts */
-	/* usb_set(USB_IN_INT_EP3 | USB_IN_INT_EP1 | USB_IN_INT_EP0, USB_IN_INT_EN);
-	   usb_set(USB_OUT_INT_EP2, USB_OUT_INT_EN); */
-
-	/* Enable SUSPEND */
-	usb_set(PM_ENABLE_SUSPEND, USB_PM);
-
-	/* Enable the USB */
-	usb_set(PM_USB_ENABLE, USB_PM);
-
-#ifdef CONFIG_ARCH_LH7A404
-	/* NOTE: DOES NOT WORK! */
-	/* Let host detect UDC:
-	 * Software must write a 0 to the PMR:DCP_CTRL bit to turn this
-	 * transistor on and pull the USBDP pin HIGH.
-	 */
-	/* usb_clear(PM_USB_DCP, USB_PM);
-	   usb_set(PM_USB_DCP, USB_PM); */
-#endif
-}
-
-/*
-  Register entry point for the peripheral controller driver.
-*/
-int usb_gadget_register_driver(struct usb_gadget_driver *driver)
-{
-	struct lh7a40x_udc *dev = the_controller;
-	int retval;
-
-	DEBUG("%s: %s\n", __FUNCTION__, driver->driver.name);
-
-	if (!driver
-	    || driver->speed != USB_SPEED_FULL
-	    || !driver->bind
-	    || !driver->unbind || !driver->disconnect || !driver->setup)
-		return -EINVAL;
-	if (!dev)
-		return -ENODEV;
-	if (dev->driver)
-		return -EBUSY;
-
-	/* first hook up the driver ... */
-	dev->driver = driver;
-	dev->gadget.dev.driver = &driver->driver;
-
-	device_add(&dev->gadget.dev);
-	retval = driver->bind(&dev->gadget);
-	if (retval) {
-		printk("%s: bind to driver %s --> error %d\n", dev->gadget.name,
-		       driver->driver.name, retval);
-		device_del(&dev->gadget.dev);
-
-		dev->driver = 0;
-		dev->gadget.dev.driver = 0;
-		return retval;
-	}
-
-	/* ... then enable host detection and ep0; and we're ready
-	 * for set_configuration as well as eventual disconnect.
-	 * NOTE:  this shouldn't power up until later.
-	 */
-	printk("%s: registered gadget driver '%s'\n", dev->gadget.name,
-	       driver->driver.name);
-
-	udc_enable(dev);
-
-	return 0;
-}
-
-EXPORT_SYMBOL(usb_gadget_register_driver);
-
-/*
-  Unregister entry point for the peripheral controller driver.
-*/
-int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
-{
-	struct lh7a40x_udc *dev = the_controller;
-	unsigned long flags;
-
-	if (!dev)
-		return -ENODEV;
-	if (!driver || driver != dev->driver)
-		return -EINVAL;
-
-	spin_lock_irqsave(&dev->lock, flags);
-	dev->driver = 0;
-	stop_activity(dev, driver);
-	spin_unlock_irqrestore(&dev->lock, flags);
-
-	driver->unbind(&dev->gadget);
-	device_del(&dev->gadget.dev);
-
-	udc_disable(dev);
-
-	DEBUG("unregistered gadget driver '%s'\n", driver->driver.name);
-	return 0;
-}
-
-EXPORT_SYMBOL(usb_gadget_unregister_driver);
-
-/*-------------------------------------------------------------------------*/
-
-/** Write request to FIFO (max write == maxp size)
- *  Return:  0 = still running, 1 = completed, negative = errno
- *  NOTE: INDEX register must be set for EP
- */
-static int write_fifo(struct lh7a40x_ep *ep, struct lh7a40x_request *req)
-{
-	u32 max;
-	u32 csr;
-
-	max = le16_to_cpu(ep->desc->wMaxPacketSize);
-
-	csr = usb_read(ep->csr1);
-	DEBUG("CSR: %x %d\n", csr, csr & USB_IN_CSR1_FIFO_NOT_EMPTY);
-
-	if (!(csr & USB_IN_CSR1_FIFO_NOT_EMPTY)) {
-		unsigned count;
-		int is_last, is_short;
-
-		count = write_packet(ep, req, max);
-		usb_set(USB_IN_CSR1_IN_PKT_RDY, ep->csr1);
-
-		/* last packet is usually short (or a zlp) */
-		if (unlikely(count != max))
-			is_last = is_short = 1;
-		else {
-			if (likely(req->req.length != req->req.actual)
-			    || req->req.zero)
-				is_last = 0;
-			else
-				is_last = 1;
-			/* interrupt/iso maxpacket may not fill the fifo */
-			is_short = unlikely(max < ep_maxpacket(ep));
-		}
-
-		DEBUG("%s: wrote %s %d bytes%s%s %d left %p\n", __FUNCTION__,
-		      ep->ep.name, count,
-		      is_last ? "/L" : "", is_short ? "/S" : "",
-		      req->req.length - req->req.actual, req);
-
-		/* requests complete when all IN data is in the FIFO */
-		if (is_last) {
-			done(ep, req, 0);
-			if (list_empty(&ep->queue)) {
-				pio_irq_disable(ep_index(ep));
-			}
-			return 1;
-		}
-	} else {
-		DEBUG("Hmm.. %d ep FIFO is not empty!\n", ep_index(ep));
-	}
-
-	return 0;
-}
-
-/** Read to request from FIFO (max read == bytes in fifo)
- *  Return:  0 = still running, 1 = completed, negative = errno
- *  NOTE: INDEX register must be set for EP
- */
-static int read_fifo(struct lh7a40x_ep *ep, struct lh7a40x_request *req)
-{
-	u32 csr;
-	u8 *buf;
-	unsigned bufferspace, count, is_short;
-	volatile u32 *fifo = (volatile u32 *)ep->fifo;
-
-	/* make sure there's a packet in the FIFO. */
-	csr = usb_read(ep->csr1);
-	if (!(csr & USB_OUT_CSR1_OUT_PKT_RDY)) {
-		DEBUG("%s: Packet NOT ready!\n", __FUNCTION__);
-		return -EINVAL;
-	}
-
-	buf = req->req.buf + req->req.actual;
-	prefetchw(buf);
-	bufferspace = req->req.length - req->req.actual;
-
-	/* read all bytes from this packet */
-	count = usb_read(USB_OUT_FIFO_WC1);
-	req->req.actual += min(count, bufferspace);
-
-	is_short = (count < ep->ep.maxpacket);
-	DEBUG("read %s %02x, %d bytes%s req %p %d/%d\n",
-	      ep->ep.name, csr, count,
-	      is_short ? "/S" : "", req, req->req.actual, req->req.length);
-
-	while (likely(count-- != 0)) {
-		u8 byte = (u8) (*fifo & 0xff);
-
-		if (unlikely(bufferspace == 0)) {
-			/* this happens when the driver's buffer
-			 * is smaller than what the host sent.
-			 * discard the extra data.
-			 */
-			if (req->req.status != -EOVERFLOW)
-				printk("%s overflow %d\n", ep->ep.name, count);
-			req->req.status = -EOVERFLOW;
-		} else {
-			*buf++ = byte;
-			bufferspace--;
-		}
-	}
-
-	usb_clear(USB_OUT_CSR1_OUT_PKT_RDY, ep->csr1);
-
-	/* completion */
-	if (is_short || req->req.actual == req->req.length) {
-		done(ep, req, 0);
-		usb_set(USB_OUT_CSR1_FIFO_FLUSH, ep->csr1);
-
-		if (list_empty(&ep->queue))
-			pio_irq_disable(ep_index(ep));
-		return 1;
-	}
-
-	/* finished that packet.  the next one may be waiting... */
-	return 0;
-}
-
-/*
- *	done - retire a request; caller blocked irqs
- *  INDEX register is preserved to keep same
- */
-static void done(struct lh7a40x_ep *ep, struct lh7a40x_request *req, int status)
-{
-	unsigned int stopped = ep->stopped;
-	u32 index;
-
-	DEBUG("%s, %p\n", __FUNCTION__, ep);
-	list_del_init(&req->queue);
-
-	if (likely(req->req.status == -EINPROGRESS))
-		req->req.status = status;
-	else
-		status = req->req.status;
-
-	if (status && status != -ESHUTDOWN)
-		DEBUG("complete %s req %p stat %d len %u/%u\n",
-		      ep->ep.name, &req->req, status,
-		      req->req.actual, req->req.length);
-
-	/* don't modify queue heads during completion callback */
-	ep->stopped = 1;
-	/* Read current index (completion may modify it) */
-	index = usb_read(USB_INDEX);
-
-	spin_unlock(&ep->dev->lock);
-	req->req.complete(&ep->ep, &req->req);
-	spin_lock(&ep->dev->lock);
-
-	/* Restore index */
-	usb_set_index(index);
-	ep->stopped = stopped;
-}
-
-/** Enable EP interrupt */
-static void pio_irq_enable(int ep)
-{
-	DEBUG("%s: %d\n", __FUNCTION__, ep);
-
-	switch (ep) {
-	case 1:
-		usb_set(USB_IN_INT_EP1, USB_IN_INT_EN);
-		break;
-	case 2:
-		usb_set(USB_OUT_INT_EP2, USB_OUT_INT_EN);
-		break;
-	case 3:
-		usb_set(USB_IN_INT_EP3, USB_IN_INT_EN);
-		break;
-	default:
-		DEBUG("Unknown endpoint: %d\n", ep);
-		break;
-	}
-}
-
-/** Disable EP interrupt */
-static void pio_irq_disable(int ep)
-{
-	DEBUG("%s: %d\n", __FUNCTION__, ep);
-
-	switch (ep) {
-	case 1:
-		usb_clear(USB_IN_INT_EP1, USB_IN_INT_EN);
-		break;
-	case 2:
-		usb_clear(USB_OUT_INT_EP2, USB_OUT_INT_EN);
-		break;
-	case 3:
-		usb_clear(USB_IN_INT_EP3, USB_IN_INT_EN);
-		break;
-	default:
-		DEBUG("Unknown endpoint: %d\n", ep);
-		break;
-	}
-}
-
-/*
- * 	nuke - dequeue ALL requests
- */
-void nuke(struct lh7a40x_ep *ep, int status)
-{
-	struct lh7a40x_request *req;
-
-	DEBUG("%s, %p\n", __FUNCTION__, ep);
-
-	/* Flush FIFO */
-	flush(ep);
-
-	/* called with irqs blocked */
-	while (!list_empty(&ep->queue)) {
-		req = list_entry(ep->queue.next, struct lh7a40x_request, queue);
-		done(ep, req, status);
-	}
-
-	/* Disable IRQ if EP is enabled (has decriptor) */
-	if (ep->desc)
-		pio_irq_disable(ep_index(ep));
-}
-
-/*
-void nuke_all(struct lh7a40x_udc *dev)
-{
-	int n;
-	for(n=0; n<UDC_MAX_ENDPOINTS; n++) {
-		struct lh7a40x_ep *ep = &dev->ep[n];
-		usb_set_index(n);
-		nuke(ep, 0);
-	}
-}*/
-
-/*
-static void flush_all(struct lh7a40x_udc *dev)
-{
-	int n;
-    for (n = 0; n < UDC_MAX_ENDPOINTS; n++)
-    {
-		struct lh7a40x_ep *ep = &dev->ep[n];
-		flush(ep);
-    }
-}
-*/
-
-/** Flush EP
- * NOTE: INDEX register must be set before this call
- */
-static void flush(struct lh7a40x_ep *ep)
-{
-	DEBUG("%s, %p\n", __FUNCTION__, ep);
-
-	switch (ep->ep_type) {
-	case ep_control:
-		/* check, by implication c.f. 15.1.2.11 */
-		break;
-
-	case ep_bulk_in:
-	case ep_interrupt:
-		/* if(csr & USB_IN_CSR1_IN_PKT_RDY) */
-		usb_set(USB_IN_CSR1_FIFO_FLUSH, ep->csr1);
-		break;
-
-	case ep_bulk_out:
-		/* if(csr & USB_OUT_CSR1_OUT_PKT_RDY) */
-		usb_set(USB_OUT_CSR1_FIFO_FLUSH, ep->csr1);
-		break;
-	}
-}
-
-/**
- * lh7a40x_in_epn - handle IN interrupt
- */
-static void lh7a40x_in_epn(struct lh7a40x_udc *dev, u32 ep_idx, u32 intr)
-{
-	u32 csr;
-	struct lh7a40x_ep *ep = &dev->ep[ep_idx];
-	struct lh7a40x_request *req;
-
-	usb_set_index(ep_idx);
-
-	csr = usb_read(ep->csr1);
-	DEBUG("%s: %d, csr %x\n", __FUNCTION__, ep_idx, csr);
-
-	if (csr & USB_IN_CSR1_SENT_STALL) {
-		DEBUG("USB_IN_CSR1_SENT_STALL\n");
-		usb_set(USB_IN_CSR1_SENT_STALL /*|USB_IN_CSR1_SEND_STALL */ ,
-			ep->csr1);
-		return;
-	}
-
-	if (!ep->desc) {
-		DEBUG("%s: NO EP DESC\n", __FUNCTION__);
-		return;
-	}
-
-	if (list_empty(&ep->queue))
-		req = 0;
-	else
-		req = list_entry(ep->queue.next, struct lh7a40x_request, queue);
-
-	DEBUG("req: %p\n", req);
-
-	if (!req)
-		return;
-
-	write_fifo(ep, req);
-}
-
-/* ********************************************************************************************* */
-/* Bulk OUT (recv)
- */
-
-static void lh7a40x_out_epn(struct lh7a40x_udc *dev, u32 ep_idx, u32 intr)
-{
-	struct lh7a40x_ep *ep = &dev->ep[ep_idx];
-	struct lh7a40x_request *req;
-
-	DEBUG("%s: %d\n", __FUNCTION__, ep_idx);
-
-	usb_set_index(ep_idx);
-
-	if (ep->desc) {
-		u32 csr;
-		csr = usb_read(ep->csr1);
-
-		while ((csr =
-			usb_read(ep->
-				 csr1)) & (USB_OUT_CSR1_OUT_PKT_RDY |
-					   USB_OUT_CSR1_SENT_STALL)) {
-			DEBUG("%s: %x\n", __FUNCTION__, csr);
-
-			if (csr & USB_OUT_CSR1_SENT_STALL) {
-				DEBUG("%s: stall sent, flush fifo\n",
-				      __FUNCTION__);
-				/* usb_set(USB_OUT_CSR1_FIFO_FLUSH, ep->csr1); */
-				flush(ep);
-			} else if (csr & USB_OUT_CSR1_OUT_PKT_RDY) {
-				if (list_empty(&ep->queue))
-					req = 0;
-				else
-					req =
-					    list_entry(ep->queue.next,
-						       struct lh7a40x_request,
-						       queue);
-
-				if (!req) {
-					printk("%s: NULL REQ %d\n",
-					       __FUNCTION__, ep_idx);
-					flush(ep);
-					break;
-				} else {
-					read_fifo(ep, req);
-				}
-			}
-
-		}
-
-	} else {
-		/* Throw packet away.. */
-		printk("%s: No descriptor?!?\n", __FUNCTION__);
-		flush(ep);
-	}
-}
-
-static void stop_activity(struct lh7a40x_udc *dev,
-			  struct usb_gadget_driver *driver)
-{
-	int i;
-
-	/* don't disconnect drivers more than once */
-	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
-		driver = 0;
-	dev->gadget.speed = USB_SPEED_UNKNOWN;
-
-	/* prevent new request submissions, kill any outstanding requests  */
-	for (i = 0; i < UDC_MAX_ENDPOINTS; i++) {
-		struct lh7a40x_ep *ep = &dev->ep[i];
-		ep->stopped = 1;
-
-		usb_set_index(i);
-		nuke(ep, -ESHUTDOWN);
-	}
-
-	/* report disconnect; the driver is already quiesced */
-	if (driver) {
-		spin_unlock(&dev->lock);
-		driver->disconnect(&dev->gadget);
-		spin_lock(&dev->lock);
-	}
-
-	/* re-init driver-visible data structures */
-	udc_reinit(dev);
-}
-
-/** Handle USB RESET interrupt
- */
-static void lh7a40x_reset_intr(struct lh7a40x_udc *dev)
-{
-#if 0				/* def CONFIG_ARCH_LH7A404 */
-	/* Does not work always... */
-
-	DEBUG("%s: %d\n", __FUNCTION__, dev->usb_address);
-
-	if (!dev->usb_address) {
-		/*usb_set(USB_RESET_IO, USB_RESET);
-		   mdelay(5);
-		   usb_clear(USB_RESET_IO, USB_RESET); */
-		return;
-	}
-	/* Put the USB controller into reset. */
-	usb_set(USB_RESET_IO, USB_RESET);
-
-	/* Set Device ID to 0 */
-	udc_set_address(dev, 0);
-
-	/* Let PLL2 settle down */
-	mdelay(5);
-
-	/* Release the USB controller from reset */
-	usb_clear(USB_RESET_IO, USB_RESET);
-
-	/* Re-enable UDC */
-	udc_enable(dev);
-
-#endif
-	dev->gadget.speed = USB_SPEED_FULL;
-}
-
-/*
- *	lh7a40x usb client interrupt handler.
- */
-static irqreturn_t lh7a40x_udc_irq(int irq, void *_dev, struct pt_regs *r)
-{
-	struct lh7a40x_udc *dev = _dev;
-
-	DEBUG("\n\n");
-
-	spin_lock(&dev->lock);
-
-	for (;;) {
-		u32 intr_in = usb_read(USB_IN_INT);
-		u32 intr_out = usb_read(USB_OUT_INT);
-		u32 intr_int = usb_read(USB_INT);
-
-		/* Test also against enable bits.. (lh7a40x errata).. Sigh.. */
-		u32 in_en = usb_read(USB_IN_INT_EN);
-		u32 out_en = usb_read(USB_OUT_INT_EN);
-
-		if (!intr_out && !intr_in && !intr_int)
-			break;
-
-		DEBUG("%s (on state %s)\n", __FUNCTION__,
-		      state_names[dev->ep0state]);
-		DEBUG("intr_out = %x\n", intr_out);
-		DEBUG("intr_in  = %x\n", intr_in);
-		DEBUG("intr_int = %x\n", intr_int);
-
-		if (intr_in) {
-			usb_write(intr_in, USB_IN_INT);
-
-			if ((intr_in & USB_IN_INT_EP1)
-			    && (in_en & USB_IN_INT_EP1)) {
-				DEBUG("USB_IN_INT_EP1\n");
-				lh7a40x_in_epn(dev, 1, intr_in);
-			}
-			if ((intr_in & USB_IN_INT_EP3)
-			    && (in_en & USB_IN_INT_EP3)) {
-				DEBUG("USB_IN_INT_EP3\n");
-				lh7a40x_in_epn(dev, 3, intr_in);
-			}
-			if (intr_in & USB_IN_INT_EP0) {
-				DEBUG("USB_IN_INT_EP0 (control)\n");
-				lh7a40x_handle_ep0(dev, intr_in);
-			}
-		}
-
-		if (intr_out) {
-			usb_write(intr_out, USB_OUT_INT);
-
-			if ((intr_out & USB_OUT_INT_EP2)
-			    && (out_en & USB_OUT_INT_EP2)) {
-				DEBUG("USB_OUT_INT_EP2\n");
-				lh7a40x_out_epn(dev, 2, intr_out);
-			}
-		}
-
-		if (intr_int) {
-			usb_write(intr_int, USB_INT);
-
-			if (intr_int & USB_INT_RESET_INT) {
-				lh7a40x_reset_intr(dev);
-			}
-
-			if (intr_int & USB_INT_RESUME_INT) {
-				DEBUG("USB resume\n");
-
-				if (dev->gadget.speed != USB_SPEED_UNKNOWN
-				    && dev->driver
-				    && dev->driver->resume
-				    && is_usb_connected()) {
-					dev->driver->resume(&dev->gadget);
-				}
-			}
-
-			if (intr_int & USB_INT_SUSPEND_INT) {
-				DEBUG("USB suspend%s\n",
-				      is_usb_connected()? "" : "+disconnect");
-				if (!is_usb_connected()) {
-					stop_activity(dev, dev->driver);
-				} else if (dev->gadget.speed !=
-					   USB_SPEED_UNKNOWN && dev->driver
-					   && dev->driver->suspend) {
-					dev->driver->suspend(&dev->gadget);
-				}
-			}
-
-		}
-	}
-
-	spin_unlock(&dev->lock);
-
-	return IRQ_HANDLED;
-}
-
-static int lh7a40x_ep_enable(struct usb_ep *_ep,
-			     const struct usb_endpoint_descriptor *desc)
-{
-	struct lh7a40x_ep *ep;
-	struct lh7a40x_udc *dev;
-	unsigned long flags;
-
-	DEBUG("%s, %p\n", __FUNCTION__, _ep);
-
-	ep = container_of(_ep, struct lh7a40x_ep, ep);
-	if (!_ep || !desc || ep->desc || _ep->name == ep0name
-	    || desc->bDescriptorType != USB_DT_ENDPOINT
-	    || ep->bEndpointAddress != desc->bEndpointAddress
-	    || ep_maxpacket(ep) < le16_to_cpu(desc->wMaxPacketSize)) {
-		DEBUG("%s, bad ep or descriptor\n", __FUNCTION__);
-		return -EINVAL;
-	}
-
-	/* xfer types must match, except that interrupt ~= bulk */
-	if (ep->bmAttributes != desc->bmAttributes
-	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
-	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
-		DEBUG("%s, %s type mismatch\n", __FUNCTION__, _ep->name);
-		return -EINVAL;
-	}
-
-	/* hardware _could_ do smaller, but driver doesn't */
-	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
-	     && le16_to_cpu(desc->wMaxPacketSize) != ep_maxpacket(ep))
-	    || !desc->wMaxPacketSize) {
-		DEBUG("%s, bad %s maxpacket\n", __FUNCTION__, _ep->name);
-		return -ERANGE;
-	}
-
-	dev = ep->dev;
-	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
-		DEBUG("%s, bogus device state\n", __FUNCTION__);
-		return -ESHUTDOWN;
-	}
-
-	spin_lock_irqsave(&ep->dev->lock, flags);
-
-	ep->stopped = 0;
-	ep->desc = desc;
-	ep->pio_irqs = 0;
-	ep->ep.maxpacket = le16_to_cpu(desc->wMaxPacketSize);
-
-	/* Reset halt state (does flush) */
-	lh7a40x_set_halt(_ep, 0);
-
-	spin_unlock_irqrestore(&ep->dev->lock, flags);
-
-	DEBUG("%s: enabled %s\n", __FUNCTION__, _ep->name);
-	return 0;
-}
-
-/** Disable EP
- *  NOTE: Sets INDEX register
- */
-static int lh7a40x_ep_disable(struct usb_ep *_ep)
-{
-	struct lh7a40x_ep *ep;
-	unsigned long flags;
-
-	DEBUG("%s, %p\n", __FUNCTION__, _ep);
-
-	ep = container_of(_ep, struct lh7a40x_ep, ep);
-	if (!_ep || !ep->desc) {
-		DEBUG("%s, %s not enabled\n", __FUNCTION__,
-		      _ep ? ep->ep.name : NULL);
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(&ep->dev->lock, flags);
-
-	usb_set_index(ep_index(ep));
-
-	/* Nuke all pending requests (does flush) */
-	nuke(ep, -ESHUTDOWN);
-
-	/* Disable ep IRQ */
-	pio_irq_disable(ep_index(ep));
-
-	ep->desc = 0;
-	ep->stopped = 1;
-
-	spin_unlock_irqrestore(&ep->dev->lock, flags);
-
-	DEBUG("%s: disabled %s\n", __FUNCTION__, _ep->name);
-	return 0;
-}
-
-static struct usb_request *lh7a40x_alloc_request(struct usb_ep *ep,
-						 int gfp_flags)
-{
-	struct lh7a40x_request *req;
-
-	DEBUG("%s, %p\n", __FUNCTION__, ep);
-
-	req = kmalloc(sizeof *req, gfp_flags);
-	if (!req)
-		return 0;
-
-	memset(req, 0, sizeof *req);
-	INIT_LIST_HEAD(&req->queue);
-
-	return &req->req;
-}
-
-static void lh7a40x_free_request(struct usb_ep *ep, struct usb_request *_req)
-{
-	struct lh7a40x_request *req;
-
-	DEBUG("%s, %p\n", __FUNCTION__, ep);
-
-	req = container_of(_req, struct lh7a40x_request, req);
-	WARN_ON(!list_empty(&req->queue));
-	kfree(req);
-}
-
-static void *lh7a40x_alloc_buffer(struct usb_ep *ep, unsigned bytes,
-				  dma_addr_t * dma, int gfp_flags)
-{
-	char *retval;
-
-	DEBUG("%s (%p, %d, %d)\n", __FUNCTION__, ep, bytes, gfp_flags);
-
-	retval = kmalloc(bytes, gfp_flags & ~(__GFP_DMA | __GFP_HIGHMEM));
-	if (retval)
-		*dma = virt_to_bus(retval);
-	return retval;
-}
-
-static void lh7a40x_free_buffer(struct usb_ep *ep, void *buf, dma_addr_t dma,
-				unsigned bytes)
-{
-	DEBUG("%s, %p\n", __FUNCTION__, ep);
-	kfree(buf);
-}
-
-/** Queue one request
- *  Kickstart transfer if needed
- *  NOTE: Sets INDEX register
- */
-static int lh7a40x_queue(struct usb_ep *_ep, struct usb_request *_req,
-			 int gfp_flags)
-{
-	struct lh7a40x_request *req;
-	struct lh7a40x_ep *ep;
-	struct lh7a40x_udc *dev;
-	unsigned long flags;
-
-	DEBUG("\n\n\n%s, %p\n", __FUNCTION__, _ep);
-
-	req = container_of(_req, struct lh7a40x_request, req);
-	if (unlikely
-	    (!_req || !_req->complete || !_req->buf
-	     || !list_empty(&req->queue))) {
-		DEBUG("%s, bad params\n", __FUNCTION__);
-		return -EINVAL;
-	}
-
-	ep = container_of(_ep, struct lh7a40x_ep, ep);
-	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
-		DEBUG("%s, bad ep\n", __FUNCTION__);
-		return -EINVAL;
-	}
-
-	dev = ep->dev;
-	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
-		DEBUG("%s, bogus device state %p\n", __FUNCTION__, dev->driver);
-		return -ESHUTDOWN;
-	}
-
-	DEBUG("%s queue req %p, len %d buf %p\n", _ep->name, _req, _req->length,
-	      _req->buf);
-
-	spin_lock_irqsave(&dev->lock, flags);
-
-	_req->status = -EINPROGRESS;
-	_req->actual = 0;
-
-	/* kickstart this i/o queue? */
-	DEBUG("Add to %d Q %d %d\n", ep_index(ep), list_empty(&ep->queue),
-	      ep->stopped);
-	if (list_empty(&ep->queue) && likely(!ep->stopped)) {
-		u32 csr;
-
-		if (unlikely(ep_index(ep) == 0)) {
-			/* EP0 */
-			list_add_tail(&req->queue, &ep->queue);
-			lh7a40x_ep0_kick(dev, ep);
-			req = 0;
-		} else if (ep_is_in(ep)) {
-			/* EP1 & EP3 */
-			usb_set_index(ep_index(ep));
-			csr = usb_read(ep->csr1);
-			pio_irq_enable(ep_index(ep));
-			if ((csr & USB_IN_CSR1_FIFO_NOT_EMPTY) == 0) {
-				if (write_fifo(ep, req) == 1)
-					req = 0;
-			}
-		} else {
-			/* EP2 */
-			usb_set_index(ep_index(ep));
-			csr = usb_read(ep->csr1);
-			pio_irq_enable(ep_index(ep));
-			if (!(csr & USB_OUT_CSR1_FIFO_FULL)) {
-				if (read_fifo(ep, req) == 1)
-					req = 0;
-			}
-		}
-	}
-
-	/* pio or dma irq handler advances the queue. */
-	if (likely(req != 0))
-		list_add_tail(&req->queue, &ep->queue);
-
-	spin_unlock_irqrestore(&dev->lock, flags);
-
-	return 0;
-}
-
-/* dequeue JUST ONE request */
-static int lh7a40x_dequeue(struct usb_ep *_ep, struct usb_request *_req)
-{
-	struct lh7a40x_ep *ep;
-	struct lh7a40x_request *req;
-	unsigned long flags;
-
-	DEBUG("%s, %p\n", __FUNCTION__, _ep);
-
-	ep = container_of(_ep, struct lh7a40x_ep, ep);
-	if (!_ep || ep->ep.name == ep0name)
-		return -EINVAL;
-
-	spin_lock_irqsave(&ep->dev->lock, flags);
-
-	/* make sure it's actually queued on this endpoint */
-	list_for_each_entry(req, &ep->queue, queue) {
-		if (&req->req == _req)
-			break;
-	}
-	if (&req->req != _req) {
-		spin_unlock_irqrestore(&ep->dev->lock, flags);
-		return -EINVAL;
-	}
-
-	done(ep, req, -ECONNRESET);
-
-	spin_unlock_irqrestore(&ep->dev->lock, flags);
-	return 0;
-}
-
-/** Halt specific EP
- *  Return 0 if success
- *  NOTE: Sets INDEX register to EP !
- */
-static int lh7a40x_set_halt(struct usb_ep *_ep, int value)
-{
-	struct lh7a40x_ep *ep;
-	unsigned long flags;
-
-	ep = container_of(_ep, struct lh7a40x_ep, ep);
-	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
-		DEBUG("%s, bad ep\n", __FUNCTION__);
-		return -EINVAL;
-	}
-
-	usb_set_index(ep_index(ep));
-
-	DEBUG("%s, ep %d, val %d\n", __FUNCTION__, ep_index(ep), value);
-
-	spin_lock_irqsave(&ep->dev->lock, flags);
-
-	if (ep_index(ep) == 0) {
-		/* EP0 */
-		usb_set(EP0_SEND_STALL, ep->csr1);
-	} else if (ep_is_in(ep)) {
-		u32 csr = usb_read(ep->csr1);
-		if (value && ((csr & USB_IN_CSR1_FIFO_NOT_EMPTY)
-			      || !list_empty(&ep->queue))) {
-			/*
-			 * Attempts to halt IN endpoints will fail (returning -EAGAIN)
-			 * if any transfer requests are still queued, or if the controller
-			 * FIFO still holds bytes that the host hasnt collected.
-			 */
-			spin_unlock_irqrestore(&ep->dev->lock, flags);
-			DEBUG
-			    ("Attempt to halt IN endpoint failed (returning -EAGAIN) %d %d\n",
-			     (csr & USB_IN_CSR1_FIFO_NOT_EMPTY),
-			     !list_empty(&ep->queue));
-			return -EAGAIN;
-		}
-		flush(ep);
-		if (value)
-			usb_set(USB_IN_CSR1_SEND_STALL, ep->csr1);
-		else {
-			usb_clear(USB_IN_CSR1_SEND_STALL, ep->csr1);
-			usb_set(USB_IN_CSR1_CLR_DATA_TOGGLE, ep->csr1);
-		}
-
-	} else {
-
-		flush(ep);
-		if (value)
-			usb_set(USB_OUT_CSR1_SEND_STALL, ep->csr1);
-		else {
-			usb_clear(USB_OUT_CSR1_SEND_STALL, ep->csr1);
-			usb_set(USB_OUT_CSR1_CLR_DATA_REG, ep->csr1);
-		}
-	}
-
-	if (value) {
-		ep->stopped = 1;
-	} else {
-		ep->stopped = 0;
-	}
-
-	spin_unlock_irqrestore(&ep->dev->lock, flags);
-
-	DEBUG("%s %s halted\n", _ep->name, value == 0 ? "NOT" : "IS");
-
-	return 0;
-}
-
-/** Return bytes in EP FIFO
- *  NOTE: Sets INDEX register to EP
- */
-static int lh7a40x_fifo_status(struct usb_ep *_ep)
-{
-	u32 csr;
-	int count = 0;
-	struct lh7a40x_ep *ep;
-
-	ep = container_of(_ep, struct lh7a40x_ep, ep);
-	if (!_ep) {
-		DEBUG("%s, bad ep\n", __FUNCTION__);
-		return -ENODEV;
-	}
-
-	DEBUG("%s, %d\n", __FUNCTION__, ep_index(ep));
-
-	/* LPD can't report unclaimed bytes from IN fifos */
-	if (ep_is_in(ep))
-		return -EOPNOTSUPP;
-
-	usb_set_index(ep_index(ep));
-
-	csr = usb_read(ep->csr1);
-	if (ep->dev->gadget.speed != USB_SPEED_UNKNOWN ||
-	    csr & USB_OUT_CSR1_OUT_PKT_RDY) {
-		count = usb_read(USB_OUT_FIFO_WC1);
-	}
-
-	return count;
-}
-
-/** Flush EP FIFO
- *  NOTE: Sets INDEX register to EP
- */
-static void lh7a40x_fifo_flush(struct usb_ep *_ep)
-{
-	struct lh7a40x_ep *ep;
-
-	ep = container_of(_ep, struct lh7a40x_ep, ep);
-	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
-		DEBUG("%s, bad ep\n", __FUNCTION__);
-		return;
-	}
-
-	usb_set_index(ep_index(ep));
-	flush(ep);
-}
-
-/****************************************************************/
-/* End Point 0 related functions                                */
-/****************************************************************/
-
-/* return:  0 = still running, 1 = completed, negative = errno */
-static int write_fifo_ep0(struct lh7a40x_ep *ep, struct lh7a40x_request *req)
-{
-	u32 max;
-	unsigned count;
-	int is_last;
-
-	max = ep_maxpacket(ep);
-
-	DEBUG_EP0("%s\n", __FUNCTION__);
-
-	count = write_packet(ep, req, max);
-
-	/* last packet is usually short (or a zlp) */
-	if (unlikely(count != max))
-		is_last = 1;
-	else {
-		if (likely(req->req.length != req->req.actual) || req->req.zero)
-			is_last = 0;
-		else
-			is_last = 1;
-	}
-
-	DEBUG_EP0("%s: wrote %s %d bytes%s %d left %p\n", __FUNCTION__,
-		  ep->ep.name, count,
-		  is_last ? "/L" : "", req->req.length - req->req.actual, req);
-
-	/* requests complete when all IN data is in the FIFO */
-	if (is_last) {
-		done(ep, req, 0);
-		return 1;
-	}
-
-	return 0;
-}
-
-static __inline__ int lh7a40x_fifo_read(struct lh7a40x_ep *ep,
-					unsigned char *cp, int max)
-{
-	int bytes;
-	int count = usb_read(USB_OUT_FIFO_WC1);
-	volatile u32 *fifo = (volatile u32 *)ep->fifo;
-
-	if (count > max)
-		count = max;
-	bytes = count;
-	while (count--)
-		*cp++ = *fifo & 0xFF;
-	return bytes;
-}
-
-static __inline__ void lh7a40x_fifo_write(struct lh7a40x_ep *ep,
-					  unsigned char *cp, int count)
-{
-	volatile u32 *fifo = (volatile u32 *)ep->fifo;
-	DEBUG_EP0("fifo_write: %d %d\n", ep_index(ep), count);
-	while (count--)
-		*fifo = *cp++;
-}
-
-static int read_fifo_ep0(struct lh7a40x_ep *ep, struct lh7a40x_request *req)
-{
-	u32 csr;
-	u8 *buf;
-	unsigned bufferspace, count, is_short;
-	volatile u32 *fifo = (volatile u32 *)ep->fifo;
-
-	DEBUG_EP0("%s\n", __FUNCTION__);
-
-	csr = usb_read(USB_EP0_CSR);
-	if (!(csr & USB_OUT_CSR1_OUT_PKT_RDY))
-		return 0;
-
-	buf = req->req.buf + req->req.actual;
-	prefetchw(buf);
-	bufferspace = req->req.length - req->req.actual;
-
-	/* read all bytes from this packet */
-	if (likely(csr & EP0_OUT_PKT_RDY)) {
-		count = usb_read(USB_OUT_FIFO_WC1);
-		req->req.actual += min(count, bufferspace);
-	} else			/* zlp */
-		count = 0;
-
-	is_short = (count < ep->ep.maxpacket);
-	DEBUG_EP0("read %s %02x, %d bytes%s req %p %d/%d\n",
-		  ep->ep.name, csr, count,
-		  is_short ? "/S" : "", req, req->req.actual, req->req.length);
-
-	while (likely(count-- != 0)) {
-		u8 byte = (u8) (*fifo & 0xff);
-
-		if (unlikely(bufferspace == 0)) {
-			/* this happens when the driver's buffer
-			 * is smaller than what the host sent.
-			 * discard the extra data.
-			 */
-			if (req->req.status != -EOVERFLOW)
-				DEBUG_EP0("%s overflow %d\n", ep->ep.name,
-					  count);
-			req->req.status = -EOVERFLOW;
-		} else {
-			*buf++ = byte;
-			bufferspace--;
-		}
-	}
-
-	/* completion */
-	if (is_short || req->req.actual == req->req.length) {
-		done(ep, req, 0);
-		return 1;
-	}
-
-	/* finished that packet.  the next one may be waiting... */
-	return 0;
-}
-
-/**
- * udc_set_address - set the USB address for this device
- * @address:
- *
- * Called from control endpoint function after it decodes a set address setup packet.
- */
-static void udc_set_address(struct lh7a40x_udc *dev, unsigned char address)
-{
-	DEBUG_EP0("%s: %d\n", __FUNCTION__, address);
-	/* c.f. 15.1.2.2 Table 15-4 address will be used after DATA_END is set */
-	dev->usb_address = address;
-	usb_set((address & USB_FA_FUNCTION_ADDR), USB_FA);
-	usb_set(USB_FA_ADDR_UPDATE | (address & USB_FA_FUNCTION_ADDR), USB_FA);
-	/* usb_read(USB_FA); */
-}
-
-/*
- * DATA_STATE_RECV (OUT_PKT_RDY)
- *      - if error
- *              set EP0_CLR_OUT | EP0_DATA_END | EP0_SEND_STALL bits
- *      - else
- *              set EP0_CLR_OUT bit
- 				if last set EP0_DATA_END bit
- */
-static void lh7a40x_ep0_out(struct lh7a40x_udc *dev, u32 csr)
-{
-	struct lh7a40x_request *req;
-	struct lh7a40x_ep *ep = &dev->ep[0];
-	int ret;
-
-	DEBUG_EP0("%s: %x\n", __FUNCTION__, csr);
-
-	if (list_empty(&ep->queue))
-		req = 0;
-	else
-		req = list_entry(ep->queue.next, struct lh7a40x_request, queue);
-
-	if (req) {
-
-		if (req->req.length == 0) {
-			DEBUG_EP0("ZERO LENGTH OUT!\n");
-			usb_set((EP0_CLR_OUT | EP0_DATA_END), USB_EP0_CSR);
-			dev->ep0state = WAIT_FOR_SETUP;
-			return;
-		}
-		ret = read_fifo_ep0(ep, req);
-		if (ret) {
-			/* Done! */
-			DEBUG_EP0("%s: finished, waiting for status\n",
-				  __FUNCTION__);
-
-			usb_set((EP0_CLR_OUT | EP0_DATA_END), USB_EP0_CSR);
-			dev->ep0state = WAIT_FOR_SETUP;
-		} else {
-			/* Not done yet.. */
-			DEBUG_EP0("%s: not finished\n", __FUNCTION__);
-			usb_set(EP0_CLR_OUT, USB_EP0_CSR);
-		}
-	} else {
-		DEBUG_EP0("NO REQ??!\n");
-	}
-}
-
-/*
- * DATA_STATE_XMIT
- */
-static int lh7a40x_ep0_in(struct lh7a40x_udc *dev, u32 csr)
-{
-	struct lh7a40x_request *req;
-	struct lh7a40x_ep *ep = &dev->ep[0];
-	int ret, need_zlp = 0;
-
-	DEBUG_EP0("%s: %x\n", __FUNCTION__, csr);
-
-	if (list_empty(&ep->queue))
-		req = 0;
-	else
-		req = list_entry(ep->queue.next, struct lh7a40x_request, queue);
-
-	if (!req) {
-		DEBUG_EP0("%s: NULL REQ\n", __FUNCTION__);
-		return 0;
-	}
-
-	if (req->req.length == 0) {
-
-		usb_set((EP0_IN_PKT_RDY | EP0_DATA_END), USB_EP0_CSR);
-		dev->ep0state = WAIT_FOR_SETUP;
-		return 1;
-	}
-
-	if (req->req.length - req->req.actual == EP0_PACKETSIZE) {
-		/* Next write will end with the packet size, */
-		/* so we need Zero-length-packet */
-		need_zlp = 1;
-	}
-
-	ret = write_fifo_ep0(ep, req);
-
-	if (ret == 1 && !need_zlp) {
-		/* Last packet */
-		DEBUG_EP0("%s: finished, waiting for status\n", __FUNCTION__);
-
-		usb_set((EP0_IN_PKT_RDY | EP0_DATA_END), USB_EP0_CSR);
-		dev->ep0state = WAIT_FOR_SETUP;
-	} else {
-		DEBUG_EP0("%s: not finished\n", __FUNCTION__);
-		usb_set(EP0_IN_PKT_RDY, USB_EP0_CSR);
-	}
-
-	if (need_zlp) {
-		DEBUG_EP0("%s: Need ZLP!\n", __FUNCTION__);
-		usb_set(EP0_IN_PKT_RDY, USB_EP0_CSR);
-		dev->ep0state = DATA_STATE_NEED_ZLP;
-	}
-
-	return 1;
-}
-
-static int lh7a40x_handle_get_status(struct lh7a40x_udc *dev,
-				     struct usb_ctrlrequest *ctrl)
-{
-	struct lh7a40x_ep *ep0 = &dev->ep[0];
-	struct lh7a40x_ep *qep;
-	int reqtype = (ctrl->bRequestType & USB_RECIP_MASK);
-	u16 val = 0;
-
-	if (reqtype == USB_RECIP_INTERFACE) {
-		/* This is not supported.
-		 * And according to the USB spec, this one does nothing..
-		 * Just return 0
-		 */
-		DEBUG_SETUP("GET_STATUS: USB_RECIP_INTERFACE\n");
-	} else if (reqtype == USB_RECIP_DEVICE) {
-		DEBUG_SETUP("GET_STATUS: USB_RECIP_DEVICE\n");
-		val |= (1 << 0);	/* Self powered */
-		/*val |= (1<<1); *//* Remote wakeup */
-	} else if (reqtype == USB_RECIP_ENDPOINT) {
-		int ep_num = (ctrl->wIndex & ~USB_DIR_IN);
-
-		DEBUG_SETUP
-		    ("GET_STATUS: USB_RECIP_ENDPOINT (%d), ctrl->wLength = %d\n",
-		     ep_num, ctrl->wLength);
-
-		if (ctrl->wLength > 2 || ep_num > 3)
-			return -EOPNOTSUPP;
-
-		qep = &dev->ep[ep_num];
-		if (ep_is_in(qep) != ((ctrl->wIndex & USB_DIR_IN) ? 1 : 0)
-		    && ep_index(qep) != 0) {
-			return -EOPNOTSUPP;
-		}
-
-		usb_set_index(ep_index(qep));
-
-		/* Return status on next IN token */
-		switch (qep->ep_type) {
-		case ep_control:
-			val =
-			    (usb_read(qep->csr1) & EP0_SEND_STALL) ==
-			    EP0_SEND_STALL;
-			break;
-		case ep_bulk_in:
-		case ep_interrupt:
-			val =
-			    (usb_read(qep->csr1) & USB_IN_CSR1_SEND_STALL) ==
-			    USB_IN_CSR1_SEND_STALL;
-			break;
-		case ep_bulk_out:
-			val =
-			    (usb_read(qep->csr1) & USB_OUT_CSR1_SEND_STALL) ==
-			    USB_OUT_CSR1_SEND_STALL;
-			break;
-		}
-
-		/* Back to EP0 index */
-		usb_set_index(0);
-
-		DEBUG_SETUP("GET_STATUS, ep: %d (%x), val = %d\n", ep_num,
-			    ctrl->wIndex, val);
-	} else {
-		DEBUG_SETUP("Unknown REQ TYPE: %d\n", reqtype);
-		return -EOPNOTSUPP;
-	}
-
-	/* Clear "out packet ready" */
-	usb_set((EP0_CLR_OUT), USB_EP0_CSR);
-	/* Put status to FIFO */
-	lh7a40x_fifo_write(ep0, (u8 *) & val, sizeof(val));
-	/* Issue "In packet ready" */
-	usb_set((EP0_IN_PKT_RDY | EP0_DATA_END), USB_EP0_CSR);
-
-	return 0;
-}
-
-/*
- * WAIT_FOR_SETUP (OUT_PKT_RDY)
- *      - read data packet from EP0 FIFO
- *      - decode command
- *      - if error
- *              set EP0_CLR_OUT | EP0_DATA_END | EP0_SEND_STALL bits
- *      - else
- *              set EP0_CLR_OUT | EP0_DATA_END bits
- */
-static void lh7a40x_ep0_setup(struct lh7a40x_udc *dev, u32 csr)
-{
-	struct lh7a40x_ep *ep = &dev->ep[0];
-	struct usb_ctrlrequest ctrl;
-	int i, bytes, is_in;
-
-	DEBUG_SETUP("%s: %x\n", __FUNCTION__, csr);
-
-	/* Nuke all previous transfers */
-	nuke(ep, -EPROTO);
-
-	/* read control req from fifo (8 bytes) */
-	bytes = lh7a40x_fifo_read(ep, (unsigned char *)&ctrl, 8);
-
-	DEBUG_SETUP("Read CTRL REQ %d bytes\n", bytes);
-	DEBUG_SETUP("CTRL.bRequestType = %d (is_in %d)\n", ctrl.bRequestType,
-		    ctrl.bRequestType == USB_DIR_IN);
-	DEBUG_SETUP("CTRL.bRequest = %d\n", ctrl.bRequest);
-	DEBUG_SETUP("CTRL.wLength = %d\n", ctrl.wLength);
-	DEBUG_SETUP("CTRL.wValue = %d (%d)\n", ctrl.wValue, ctrl.wValue >> 8);
-	DEBUG_SETUP("CTRL.wIndex = %d\n", ctrl.wIndex);
-
-	/* Set direction of EP0 */
-	if (likely(ctrl.bRequestType & USB_DIR_IN)) {
-		ep->bEndpointAddress |= USB_DIR_IN;
-		is_in = 1;
-	} else {
-		ep->bEndpointAddress &= ~USB_DIR_IN;
-		is_in = 0;
-	}
-
-	dev->req_pending = 1;
-
-	/* Handle some SETUP packets ourselves */
-	switch (ctrl.bRequest) {
-	case USB_REQ_SET_ADDRESS:
-		if (ctrl.bRequestType != (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
-			break;
-
-		DEBUG_SETUP("USB_REQ_SET_ADDRESS (%d)\n", ctrl.wValue);
-		udc_set_address(dev, ctrl.wValue);
-		usb_set((EP0_CLR_OUT | EP0_DATA_END), USB_EP0_CSR);
-		return;
-
-	case USB_REQ_GET_STATUS:{
-			if (lh7a40x_handle_get_status(dev, &ctrl) == 0)
-				return;
-
-	case USB_REQ_CLEAR_FEATURE:
-	case USB_REQ_SET_FEATURE:
-			if (ctrl.bRequestType == USB_RECIP_ENDPOINT) {
-				struct lh7a40x_ep *qep;
-				int ep_num = (ctrl.wIndex & 0x0f);
-
-				/* Support only HALT feature */
-				if (ctrl.wValue != 0 || ctrl.wLength != 0
-				    || ep_num > 3 || ep_num < 1)
-					break;
-
-				qep = &dev->ep[ep_num];
-				if (ctrl.bRequest == USB_REQ_SET_FEATURE) {
-					DEBUG_SETUP("SET_FEATURE (%d)\n",
-						    ep_num);
-					lh7a40x_set_halt(&qep->ep, 1);
-				} else {
-					DEBUG_SETUP("CLR_FEATURE (%d)\n",
-						    ep_num);
-					lh7a40x_set_halt(&qep->ep, 0);
-				}
-				usb_set_index(0);
-
-				/* Reply with a ZLP on next IN token */
-				usb_set((EP0_CLR_OUT | EP0_DATA_END),
-					USB_EP0_CSR);
-				return;
-			}
-			break;
-		}
-
-	default:
-		break;
-	}
-
-	if (likely(dev->driver)) {
-		/* device-2-host (IN) or no data setup command, process immediately */
-		spin_unlock(&dev->lock);
-		i = dev->driver->setup(&dev->gadget, &ctrl);
-		spin_lock(&dev->lock);
-
-		if (i < 0) {
-			/* setup processing failed, force stall */
-			DEBUG_SETUP
-			    ("  --> ERROR: gadget setup FAILED (stalling), setup returned %d\n",
-			     i);
-			usb_set_index(0);
-			usb_set((EP0_CLR_OUT | EP0_DATA_END | EP0_SEND_STALL),
-				USB_EP0_CSR);
-
-			/* ep->stopped = 1; */
-			dev->ep0state = WAIT_FOR_SETUP;
-		}
-	}
-}
-
-/*
- * DATA_STATE_NEED_ZLP
- */
-static void lh7a40x_ep0_in_zlp(struct lh7a40x_udc *dev, u32 csr)
-{
-	DEBUG_EP0("%s: %x\n", __FUNCTION__, csr);
-
-	/* c.f. Table 15-14 */
-	usb_set((EP0_IN_PKT_RDY | EP0_DATA_END), USB_EP0_CSR);
-	dev->ep0state = WAIT_FOR_SETUP;
-}
-
-/*
- * handle ep0 interrupt
- */
-static void lh7a40x_handle_ep0(struct lh7a40x_udc *dev, u32 intr)
-{
-	struct lh7a40x_ep *ep = &dev->ep[0];
-	u32 csr;
-
-	/* Set index 0 */
-	usb_set_index(0);
- 	csr = usb_read(USB_EP0_CSR);
-
-	DEBUG_EP0("%s: csr = %x\n", __FUNCTION__, csr);
-
-	/*
-	 * For overview of what we should be doing see c.f. Chapter 18.1.2.4
-	 * We will follow that outline here modified by our own global state
-	 * indication which provides hints as to what we think should be
-	 * happening..
-	 */
-
-	/*
-	 * if SENT_STALL is set
-	 *      - clear the SENT_STALL bit
-	 */
-	if (csr & EP0_SENT_STALL) {
-		DEBUG_EP0("%s: EP0_SENT_STALL is set: %x\n", __FUNCTION__, csr);
-		usb_clear((EP0_SENT_STALL | EP0_SEND_STALL), USB_EP0_CSR);
-		nuke(ep, -ECONNABORTED);
-		dev->ep0state = WAIT_FOR_SETUP;
-		return;
-	}
-
-	/*
-	 * if a transfer is in progress && IN_PKT_RDY and OUT_PKT_RDY are clear
-	 *      - fill EP0 FIFO
-	 *      - if last packet
-	 *      -       set IN_PKT_RDY | DATA_END
-	 *      - else
-	 *              set IN_PKT_RDY
-	 */
-	if (!(csr & (EP0_IN_PKT_RDY | EP0_OUT_PKT_RDY))) {
-		DEBUG_EP0("%s: IN_PKT_RDY and OUT_PKT_RDY are clear\n",
-			  __FUNCTION__);
-
-		switch (dev->ep0state) {
-		case DATA_STATE_XMIT:
-			DEBUG_EP0("continue with DATA_STATE_XMIT\n");
-			lh7a40x_ep0_in(dev, csr);
-			return;
-		case DATA_STATE_NEED_ZLP:
-			DEBUG_EP0("continue with DATA_STATE_NEED_ZLP\n");
-			lh7a40x_ep0_in_zlp(dev, csr);
-			return;
-		default:
-			/* Stall? */
-			DEBUG_EP0("Odd state!! state = %s\n",
-				  state_names[dev->ep0state]);
-			dev->ep0state = WAIT_FOR_SETUP;
-			/* nuke(ep, 0); */
-			/* usb_set(EP0_SEND_STALL, ep->csr1); */
-			break;
-		}
-	}
-
-	/*
-	 * if SETUP_END is set
-	 *      - abort the last transfer
-	 *      - set SERVICED_SETUP_END_BIT
-	 */
-	if (csr & EP0_SETUP_END) {
-		DEBUG_EP0("%s: EP0_SETUP_END is set: %x\n", __FUNCTION__, csr);
-
-		usb_set(EP0_CLR_SETUP_END, USB_EP0_CSR);
-
-		nuke(ep, 0);
-		dev->ep0state = WAIT_FOR_SETUP;
-	}
-
-	/*
-	 * if EP0_OUT_PKT_RDY is set
-	 *      - read data packet from EP0 FIFO
-	 *      - decode command
-	 *      - if error
-	 *              set SERVICED_OUT_PKT_RDY | DATA_END bits | SEND_STALL
-	 *      - else
-	 *              set SERVICED_OUT_PKT_RDY | DATA_END bits
-	 */
-	if (csr & EP0_OUT_PKT_RDY) {
-
-		DEBUG_EP0("%s: EP0_OUT_PKT_RDY is set: %x\n", __FUNCTION__,
-			  csr);
-
-		switch (dev->ep0state) {
-		case WAIT_FOR_SETUP:
-			DEBUG_EP0("WAIT_FOR_SETUP\n");
-			lh7a40x_ep0_setup(dev, csr);
-			break;
-
-		case DATA_STATE_RECV:
-			DEBUG_EP0("DATA_STATE_RECV\n");
-			lh7a40x_ep0_out(dev, csr);
-			break;
-
-		default:
-			/* send stall? */
-			DEBUG_EP0("strange state!! 2. send stall? state = %d\n",
-				  dev->ep0state);
-			break;
-		}
-	}
-}
-
-static void lh7a40x_ep0_kick(struct lh7a40x_udc *dev, struct lh7a40x_ep *ep)
-{
-	u32 csr;
-
-	usb_set_index(0);
-	csr = usb_read(USB_EP0_CSR);
-
-	DEBUG_EP0("%s: %x\n", __FUNCTION__, csr);
-
-	/* Clear "out packet ready" */
-	usb_set(EP0_CLR_OUT, USB_EP0_CSR);
-
-	if (ep_is_in(ep)) {
-		dev->ep0state = DATA_STATE_XMIT;
-		lh7a40x_ep0_in(dev, csr);
-	} else {
-		dev->ep0state = DATA_STATE_RECV;
-		lh7a40x_ep0_out(dev, csr);
-	}
-}
-
-/* ---------------------------------------------------------------------------
- * 	device-scoped parts of the api to the usb controller hardware
- * ---------------------------------------------------------------------------
- */
-
-static int lh7a40x_udc_get_frame(struct usb_gadget *_gadget)
-{
-	u32 frame1 = usb_read(USB_FRM_NUM1);	/* Least significant 8 bits */
-	u32 frame2 = usb_read(USB_FRM_NUM2);	/* Most significant 3 bits */
-	DEBUG("%s, %p\n", __FUNCTION__, _gadget);
-	return ((frame2 & 0x07) << 8) | (frame1 & 0xff);
-}
-
-static int lh7a40x_udc_wakeup(struct usb_gadget *_gadget)
-{
-	/* host may not have enabled remote wakeup */
-	/*if ((UDCCS0 & UDCCS0_DRWF) == 0)
-	   return -EHOSTUNREACH;
-	   udc_set_mask_UDCCR(UDCCR_RSM); */
-	return -ENOTSUPP;
-}
-
-static const struct usb_gadget_ops lh7a40x_udc_ops = {
-	.get_frame = lh7a40x_udc_get_frame,
-	.wakeup = lh7a40x_udc_wakeup,
-	/* current versions must always be self-powered */
-};
-
-static void nop_release(struct device *dev)
-{
-	DEBUG("%s %s\n", __FUNCTION__, dev->bus_id);
-}
-
-static struct lh7a40x_udc memory = {
-	.usb_address = 0,
-
-	.gadget = {
-		   .ops = &lh7a40x_udc_ops,
-		   .ep0 = &memory.ep[0].ep,
-		   .name = driver_name,
-		   .dev = {
-			   .bus_id = "gadget",
-			   .release = nop_release,
-			   },
-		   },
-
-	/* control endpoint */
-	.ep[0] = {
-		  .ep = {
-			 .name = ep0name,
-			 .ops = &lh7a40x_ep_ops,
-			 .maxpacket = EP0_PACKETSIZE,
-			 },
-		  .dev = &memory,
-
-		  .bEndpointAddress = 0,
-		  .bmAttributes = 0,
-
-		  .ep_type = ep_control,
-		  .fifo = io_p2v(USB_EP0_FIFO),
-		  .csr1 = USB_EP0_CSR,
-		  .csr2 = USB_EP0_CSR,
-		  },
-
-	/* first group of endpoints */
-	.ep[1] = {
-		  .ep = {
-			 .name = "ep1in-bulk",
-			 .ops = &lh7a40x_ep_ops,
-			 .maxpacket = 64,
-			 },
-		  .dev = &memory,
-
-		  .bEndpointAddress = USB_DIR_IN | 1,
-		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
-
-		  .ep_type = ep_bulk_in,
-		  .fifo = io_p2v(USB_EP1_FIFO),
-		  .csr1 = USB_IN_CSR1,
-		  .csr2 = USB_IN_CSR2,
-		  },
-
-	.ep[2] = {
-		  .ep = {
-			 .name = "ep2out-bulk",
-			 .ops = &lh7a40x_ep_ops,
-			 .maxpacket = 64,
-			 },
-		  .dev = &memory,
-
-		  .bEndpointAddress = 2,
-		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
-
-		  .ep_type = ep_bulk_out,
-		  .fifo = io_p2v(USB_EP2_FIFO),
-		  .csr1 = USB_OUT_CSR1,
-		  .csr2 = USB_OUT_CSR2,
-		  },
-
-	.ep[3] = {
-		  .ep = {
-			 .name = "ep3in-int",
-			 .ops = &lh7a40x_ep_ops,
-			 .maxpacket = 64,
-			 },
-		  .dev = &memory,
-
-		  .bEndpointAddress = USB_DIR_IN | 3,
-		  .bmAttributes = USB_ENDPOINT_XFER_INT,
-
-		  .ep_type = ep_interrupt,
-		  .fifo = io_p2v(USB_EP3_FIFO),
-		  .csr1 = USB_IN_CSR1,
-		  .csr2 = USB_IN_CSR2,
-		  },
-};
-
-/*
- * 	probe - binds to the platform device
- */
-static int lh7a40x_udc_probe(struct device *_dev)
-{
-	struct lh7a40x_udc *dev = &memory;
-	int retval;
-
-	DEBUG("%s: %p\n", __FUNCTION__, _dev);
-
-	spin_lock_init(&dev->lock);
-	dev->dev = _dev;
-
-	device_initialize(&dev->gadget.dev);
-	dev->gadget.dev.parent = _dev;
-
-	the_controller = dev;
-	dev_set_drvdata(_dev, dev);
-
-	udc_disable(dev);
-	udc_reinit(dev);
-
-	/* irq setup after old hardware state is cleaned up */
-	retval =
-	    request_irq(IRQ_USBINTR, lh7a40x_udc_irq, SA_INTERRUPT, driver_name,
-			dev);
-	if (retval != 0) {
-		DEBUG(KERN_ERR "%s: can't get irq %i, err %d\n", driver_name,
-		      IRQ_USBINTR, retval);
-		return -EBUSY;
-	}
-
-	create_proc_files();
-
-	return retval;
-}
-
-static int lh7a40x_udc_remove(struct device *_dev)
-{
-	struct lh7a40x_udc *dev = _dev->driver_data;
-
-	DEBUG("%s: %p\n", __FUNCTION__, dev);
-
-	udc_disable(dev);
-	remove_proc_files();
-	usb_gadget_unregister_driver(dev->driver);
-
-	free_irq(IRQ_USBINTR, dev);
-
-	dev_set_drvdata(_dev, 0);
-
-	the_controller = 0;
-
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static struct device_driver udc_driver = {
-	.name = (char *)driver_name,
-	.bus = &platform_bus_type,
-	.probe = lh7a40x_udc_probe,
-	.remove = lh7a40x_udc_remove
-	    /* FIXME power management support */
-	    /* .suspend = ... disable UDC */
-	    /* .resume = ... re-enable UDC */
-};
-
-static int __init udc_init(void)
-{
-	DEBUG("%s: %s version %s\n", __FUNCTION__, driver_name, DRIVER_VERSION);
-	return driver_register(&udc_driver);
-}
-
-static void __exit udc_exit(void)
-{
-	driver_unregister(&udc_driver);
-}
-
-module_init(udc_init);
-module_exit(udc_exit);
-
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_AUTHOR("Mikko Lahteenmaki, Bo Henriksen");
-MODULE_LICENSE("GPL");
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/lh7a40x_udc.h linuxppc-2.6.9-dream/drivers/usb/gadget/lh7a40x_udc.h
--- linuxppc-2.6.9/drivers/usb/gadget/lh7a40x_udc.h	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/lh7a40x_udc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,261 +0,0 @@
-/*
- * linux/drivers/usb/gadget/lh7a40x_udc.h
- * Sharp LH7A40x on-chip full speed USB device controllers
- *
- * Copyright (C) 2004 Mikko Lahteenmaki, Nordic ID
- * Copyright (C) 2004 Bo Henriksen, Nordic ID
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#ifndef __LH7A40X_H_
-#define __LH7A40X_H_
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <linux/types.h>
-#include <linux/version.h>
-#include <linux/errno.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/list.h>
-#include <linux/interrupt.h>
-#include <linux/proc_fs.h>
-#include <linux/mm.h>
-#include <linux/device.h>
-#include <linux/dma-mapping.h>
-
-#include <asm/byteorder.h>
-#include <asm/dma.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/system.h>
-#include <asm/unaligned.h>
-#include <asm/hardware.h>
-
-#include <linux/usb_ch9.h>
-#include <linux/usb_gadget.h>
-
-/*
- * Memory map
- */
-
-#define USB_FA					0x80000200	// function address register
-#define USB_PM					0x80000204	// power management register
-
-#define USB_IN_INT				0x80000208	// IN interrupt register bank (EP0-EP3)
-#define USB_OUT_INT				0x80000210	// OUT interrupt register bank (EP2)
-#define USB_INT					0x80000218	// interrupt register bank
-
-#define USB_IN_INT_EN			0x8000021C	// IN interrupt enable register bank
-#define USB_OUT_INT_EN			0x80000224	// OUT interrupt enable register bank
-#define USB_INT_EN				0x8000022C	// USB interrupt enable register bank
-
-#define USB_FRM_NUM1			0x80000230	// Frame number1 register
-#define USB_FRM_NUM2			0x80000234	// Frame number2 register
-#define USB_INDEX				0x80000238	// index register
-
-#define USB_IN_MAXP				0x80000240	// IN MAXP register
-#define USB_IN_CSR1				0x80000244	// IN CSR1 register/EP0 CSR register
-#define USB_EP0_CSR				0x80000244	// IN CSR1 register/EP0 CSR register
-#define USB_IN_CSR2				0x80000248	// IN CSR2 register
-#define USB_OUT_MAXP			0x8000024C	// OUT MAXP register
-
-#define USB_OUT_CSR1			0x80000250	// OUT CSR1 register
-#define USB_OUT_CSR2			0x80000254	// OUT CSR2 register
-#define USB_OUT_FIFO_WC1		0x80000258	// OUT FIFO write count1 register
-#define USB_OUT_FIFO_WC2		0x8000025C	// OUT FIFO write count2 register
-
-#define USB_RESET				0x8000044C	// USB reset register
-
-#define	USB_EP0_FIFO			0x80000280
-#define	USB_EP1_FIFO			0x80000284
-#define	USB_EP2_FIFO			0x80000288
-#define	USB_EP3_FIFO			0x8000028c
-
-/*
- * USB reset register
- */
-#define USB_RESET_APB			(1<<1)	//resets USB APB control side WRITE
-#define USB_RESET_IO			(1<<0)	//resets USB IO side WRITE
-
-/*
- * USB function address register
- */
-#define USB_FA_ADDR_UPDATE		(1<<7)
-#define USB_FA_FUNCTION_ADDR	(0x7F)
-
-/*
- * Power Management register
- */
-#define PM_USB_DCP				(1<<5)
-#define PM_USB_ENABLE			(1<<4)
-#define PM_USB_RESET			(1<<3)
-#define PM_UC_RESUME			(1<<2)
-#define PM_SUSPEND_MODE			(1<<1)
-#define PM_ENABLE_SUSPEND		(1<<0)
-
-/*
- * IN interrupt register
- */
-#define USB_IN_INT_EP3				(1<<3)
-#define USB_IN_INT_EP1				(1<<1)
-#define USB_IN_INT_EP0				(1<<0)
-
-/*
- * OUT interrupt register
- */
-#define USB_OUT_INT_EP2				(1<<2)
-
-/*
- * USB interrupt register
- */
-#define USB_INT_RESET_INT			(1<<2)
-#define USB_INT_RESUME_INT			(1<<1)
-#define USB_INT_SUSPEND_INT			(1<<0)
-
-/*
- * USB interrupt enable register
- */
-#define USB_INT_EN_USB_RESET_INTER		(1<<2)
-#define USB_INT_EN_RESUME_INTER			(1<<1)
-#define USB_INT_EN_SUSPEND_INTER		(1<<0)
-
-/*
- * INCSR1 register
- */
-#define USB_IN_CSR1_CLR_DATA_TOGGLE		(1<<6)
-#define USB_IN_CSR1_SENT_STALL			(1<<5)
-#define USB_IN_CSR1_SEND_STALL			(1<<4)
-#define USB_IN_CSR1_FIFO_FLUSH			(1<<3)
-#define USB_IN_CSR1_FIFO_NOT_EMPTY		(1<<1)
-#define USB_IN_CSR1_IN_PKT_RDY			(1<<0)
-
-/*
- * INCSR2 register
- */
-#define USB_IN_CSR2_AUTO_SET			(1<<7)
-#define USB_IN_CSR2_USB_DMA_EN			(1<<4)
-
-/*
- * OUT CSR1 register
- */
-#define USB_OUT_CSR1_CLR_DATA_REG		(1<<7)
-#define USB_OUT_CSR1_SENT_STALL			(1<<6)
-#define USB_OUT_CSR1_SEND_STALL			(1<<5)
-#define USB_OUT_CSR1_FIFO_FLUSH			(1<<4)
-#define USB_OUT_CSR1_FIFO_FULL			(1<<1)
-#define USB_OUT_CSR1_OUT_PKT_RDY		(1<<0)
-
-/*
- * OUT CSR2 register
- */
-#define USB_OUT_CSR2_AUTO_CLR			(1<<7)
-#define USB_OUT_CSR2_USB_DMA_EN			(1<<4)
-
-/*
- * EP0 CSR
- */
-#define EP0_CLR_SETUP_END		(1<<7)	/* Clear "Setup Ends" Bit (w) */
-#define EP0_CLR_OUT				(1<<6)	/* Clear "Out packet ready" Bit (w) */
-#define EP0_SEND_STALL			(1<<5)	/* Send STALL Handshake (rw) */
-#define EP0_SETUP_END			(1<<4)	/* Setup Ends (r) */
-
-#define EP0_DATA_END			(1<<3)	/* Data end (rw) */
-#define EP0_SENT_STALL			(1<<2)	/* Sent Stall Handshake (r) */
-#define EP0_IN_PKT_RDY			(1<<1)	/* In packet ready (rw) */
-#define EP0_OUT_PKT_RDY			(1<<0)	/* Out packet ready (r) */
-
-/* general CSR */
-#define OUT_PKT_RDY		(1<<0)
-#define IN_PKT_RDY		(1<<0)
-
-/*
- * IN/OUT MAXP register
- */
-#define USB_OUT_MAXP_MAXP			(0xF)
-#define USB_IN_MAXP_MAXP			(0xF)
-
-// Max packet size
-//#define EP0_PACKETSIZE        0x10
-#define EP0_PACKETSIZE  	0x8
-#define EP0_MAXPACKETSIZE  	0x10
-
-#define UDC_MAX_ENDPOINTS       4
-
-#define WAIT_FOR_SETUP          0
-#define DATA_STATE_XMIT         1
-#define DATA_STATE_NEED_ZLP     2
-#define WAIT_FOR_OUT_STATUS     3
-#define DATA_STATE_RECV         4
-
-/* ********************************************************************************************* */
-/* IO
- */
-
-typedef enum ep_type {
-	ep_control, ep_bulk_in, ep_bulk_out, ep_interrupt
-} ep_type_t;
-
-struct lh7a40x_ep {
-	struct usb_ep ep;
-	struct lh7a40x_udc *dev;
-
-	const struct usb_endpoint_descriptor *desc;
-	struct list_head queue;
-	unsigned long pio_irqs;
-
-	u8 stopped;
-	u8 bEndpointAddress;
-	u8 bmAttributes;
-
-	ep_type_t ep_type;
-	u32 fifo;
-	u32 csr1;
-	u32 csr2;
-};
-
-struct lh7a40x_request {
-	struct usb_request req;
-	struct list_head queue;
-};
-
-struct lh7a40x_udc {
-	struct usb_gadget gadget;
-	struct usb_gadget_driver *driver;
-	struct device *dev;
-	spinlock_t lock;
-
-	int ep0state;
-	struct lh7a40x_ep ep[UDC_MAX_ENDPOINTS];
-
-	unsigned char usb_address;
-
-	unsigned req_pending:1, req_std:1, req_config:1;
-};
-
-extern struct lh7a40x_udc *the_controller;
-
-#define ep_is_in(EP) 		(((EP)->bEndpointAddress&USB_DIR_IN)==USB_DIR_IN)
-#define ep_index(EP) 		((EP)->bEndpointAddress&0xF)
-#define ep_maxpacket(EP) 	((EP)->ep.maxpacket)
-
-#endif
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/Makefile linuxppc-2.6.9-dream/drivers/usb/gadget/Makefile
--- linuxppc-2.6.9/drivers/usb/gadget/Makefile	2004-10-18 23:53:13.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/Makefile	2005-09-19 21:40:05.000000000 +0200
@@ -1,26 +1,18 @@
 #
 # USB peripheral controller drivers
 #
-obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
 obj-$(CONFIG_USB_NET2280)	+= net2280.o
 obj-$(CONFIG_USB_PXA2XX)	+= pxa2xx_udc.o
 obj-$(CONFIG_USB_GOKU)		+= goku_udc.o
-obj-$(CONFIG_USB_OMAP)		+= omap_udc.o
-obj-$(CONFIG_USB_LH7A40X)	+= lh7a40x_udc.o
 
 #
 # USB gadget drivers
 #
-g_zero-objs			:= zero.o usbstring.o config.o epautoconf.o
-g_ether-objs			:= ether.o usbstring.o config.o epautoconf.o
-g_serial-objs			:= serial.o usbstring.o epautoconf.o
-gadgetfs-objs			:= inode.o
-g_file_storage-objs		:= file_storage.o usbstring.o config.o \
-					epautoconf.o
-
-ifeq ($(CONFIG_USB_ETH_RNDIS),y)
-	g_ether-objs		+= rndis.o
-endif
+g_zero-objs			:= zero.o usbstring.o config.o
+g_ether-objs			:= ether.o usbstring.o config.o
+g_serial-objs			:= serial.o usbstring.o
+gadgetfs-objs			:= inode.o usbstring.o
+g_file_storage-objs		:= file_storage.o usbstring.o
  
 obj-$(CONFIG_USB_ZERO)		+= g_zero.o
 obj-$(CONFIG_USB_ETH)		+= g_ether.o
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/ndis.h linuxppc-2.6.9-dream/drivers/usb/gadget/ndis.h
--- linuxppc-2.6.9/drivers/usb/gadget/ndis.h	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/ndis.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,217 +0,0 @@
-/*
- * ndis.h 
- * 
- * ntddndis.h modified by Benedikt Spranger <b.spranger@pengutronix.de>
- * 
- * Thanks to the cygwin development team, 
- * espacially to Casper S. Hornstrup <chorns@users.sourceforge.net>
- * 
- * THIS SOFTWARE IS NOT COPYRIGHTED
- *
- * This source code is offered for use in the public domain. You may
- * use, modify or distribute it freely.
- *
- * This code is distributed in the hope that it will be useful but
- * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
- * DISCLAIMED. This includes but is not limited to warranties of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *
- */
-
-#ifndef _LINUX_NDIS_H
-#define _LINUX_NDIS_H
-
-
-#define NDIS_STATUS_MULTICAST_FULL	  0xC0010009
-#define NDIS_STATUS_MULTICAST_EXISTS      0xC001000A
-#define NDIS_STATUS_MULTICAST_NOT_FOUND   0xC001000B
-
-enum NDIS_DEVICE_POWER_STATE {
-	NdisDeviceStateUnspecified = 0,
-	NdisDeviceStateD0,
-	NdisDeviceStateD1,
-	NdisDeviceStateD2,
-	NdisDeviceStateD3,
-	NdisDeviceStateMaximum
-};
-
-struct NDIS_PM_WAKE_UP_CAPABILITIES {
-	enum NDIS_DEVICE_POWER_STATE  MinMagicPacketWakeUp;
-	enum NDIS_DEVICE_POWER_STATE  MinPatternWakeUp;
-	enum NDIS_DEVICE_POWER_STATE  MinLinkChangeWakeUp;
-};
-
-/* NDIS_PNP_CAPABILITIES.Flags constants */
-#define NDIS_DEVICE_WAKE_UP_ENABLE                0x00000001
-#define NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE  0x00000002
-#define NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE   0x00000004
-
-struct NDIS_PNP_CAPABILITIES {
-	u32					Flags;
-	struct NDIS_PM_WAKE_UP_CAPABILITIES	WakeUpCapabilities;
-};
-
-struct NDIS_PM_PACKET_PATTERN {
-	u32	Priority;
-	u32	Reserved;
-	u32	MaskSize;
-	u32	PatternOffset;
-	u32	PatternSize;
-	u32	PatternFlags;
-};
-
-
-/* Required Object IDs (OIDs) */
-#define OID_GEN_SUPPORTED_LIST            0x00010101
-#define OID_GEN_HARDWARE_STATUS           0x00010102
-#define OID_GEN_MEDIA_SUPPORTED           0x00010103
-#define OID_GEN_MEDIA_IN_USE              0x00010104
-#define OID_GEN_MAXIMUM_LOOKAHEAD         0x00010105
-#define OID_GEN_MAXIMUM_FRAME_SIZE        0x00010106
-#define OID_GEN_LINK_SPEED                0x00010107
-#define OID_GEN_TRANSMIT_BUFFER_SPACE     0x00010108
-#define OID_GEN_RECEIVE_BUFFER_SPACE      0x00010109
-#define OID_GEN_TRANSMIT_BLOCK_SIZE       0x0001010A
-#define OID_GEN_RECEIVE_BLOCK_SIZE        0x0001010B
-#define OID_GEN_VENDOR_ID                 0x0001010C
-#define OID_GEN_VENDOR_DESCRIPTION        0x0001010D
-#define OID_GEN_CURRENT_PACKET_FILTER     0x0001010E
-#define OID_GEN_CURRENT_LOOKAHEAD         0x0001010F
-#define OID_GEN_DRIVER_VERSION            0x00010110
-#define OID_GEN_MAXIMUM_TOTAL_SIZE        0x00010111
-#define OID_GEN_PROTOCOL_OPTIONS          0x00010112
-#define OID_GEN_MAC_OPTIONS               0x00010113
-#define OID_GEN_MEDIA_CONNECT_STATUS      0x00010114
-#define OID_GEN_MAXIMUM_SEND_PACKETS      0x00010115
-#define OID_GEN_VENDOR_DRIVER_VERSION     0x00010116
-#define OID_GEN_SUPPORTED_GUIDS           0x00010117
-#define OID_GEN_NETWORK_LAYER_ADDRESSES   0x00010118
-#define OID_GEN_TRANSPORT_HEADER_OFFSET   0x00010119
-#define OID_GEN_MACHINE_NAME              0x0001021A
-#define OID_GEN_RNDIS_CONFIG_PARAMETER    0x0001021B
-#define OID_GEN_VLAN_ID                   0x0001021C
-
-/* Optional OIDs */
-#define OID_GEN_MEDIA_CAPABILITIES        0x00010201
-#define OID_GEN_PHYSICAL_MEDIUM           0x00010202
-
-/* Required statistics OIDs */
-#define OID_GEN_XMIT_OK                   0x00020101
-#define OID_GEN_RCV_OK                    0x00020102
-#define OID_GEN_XMIT_ERROR                0x00020103
-#define OID_GEN_RCV_ERROR                 0x00020104
-#define OID_GEN_RCV_NO_BUFFER             0x00020105
-
-/* Optional statistics OIDs */
-#define OID_GEN_DIRECTED_BYTES_XMIT       0x00020201
-#define OID_GEN_DIRECTED_FRAMES_XMIT      0x00020202
-#define OID_GEN_MULTICAST_BYTES_XMIT      0x00020203
-#define OID_GEN_MULTICAST_FRAMES_XMIT     0x00020204
-#define OID_GEN_BROADCAST_BYTES_XMIT      0x00020205
-#define OID_GEN_BROADCAST_FRAMES_XMIT     0x00020206
-#define OID_GEN_DIRECTED_BYTES_RCV        0x00020207
-#define OID_GEN_DIRECTED_FRAMES_RCV       0x00020208
-#define OID_GEN_MULTICAST_BYTES_RCV       0x00020209
-#define OID_GEN_MULTICAST_FRAMES_RCV      0x0002020A
-#define OID_GEN_BROADCAST_BYTES_RCV       0x0002020B
-#define OID_GEN_BROADCAST_FRAMES_RCV      0x0002020C
-#define OID_GEN_RCV_CRC_ERROR             0x0002020D
-#define OID_GEN_TRANSMIT_QUEUE_LENGTH     0x0002020E
-#define OID_GEN_GET_TIME_CAPS             0x0002020F
-#define OID_GEN_GET_NETCARD_TIME          0x00020210
-#define OID_GEN_NETCARD_LOAD              0x00020211
-#define OID_GEN_DEVICE_PROFILE            0x00020212
-#define OID_GEN_INIT_TIME_MS              0x00020213
-#define OID_GEN_RESET_COUNTS              0x00020214
-#define OID_GEN_MEDIA_SENSE_COUNTS        0x00020215
-#define OID_GEN_FRIENDLY_NAME             0x00020216
-#define OID_GEN_MINIPORT_INFO             0x00020217
-#define OID_GEN_RESET_VERIFY_PARAMETERS   0x00020218
-
-/* IEEE 802.3 (Ethernet) OIDs */
-#define NDIS_802_3_MAC_OPTION_PRIORITY    0x00000001
-
-#define OID_802_3_PERMANENT_ADDRESS       0x01010101
-#define OID_802_3_CURRENT_ADDRESS         0x01010102
-#define OID_802_3_MULTICAST_LIST          0x01010103
-#define OID_802_3_MAXIMUM_LIST_SIZE       0x01010104
-#define OID_802_3_MAC_OPTIONS             0x01010105
-#define OID_802_3_RCV_ERROR_ALIGNMENT     0x01020101
-#define OID_802_3_XMIT_ONE_COLLISION      0x01020102
-#define OID_802_3_XMIT_MORE_COLLISIONS    0x01020103
-#define OID_802_3_XMIT_DEFERRED           0x01020201
-#define OID_802_3_XMIT_MAX_COLLISIONS     0x01020202
-#define OID_802_3_RCV_OVERRUN             0x01020203
-#define OID_802_3_XMIT_UNDERRUN           0x01020204
-#define OID_802_3_XMIT_HEARTBEAT_FAILURE  0x01020205
-#define OID_802_3_XMIT_TIMES_CRS_LOST     0x01020206
-#define OID_802_3_XMIT_LATE_COLLISIONS    0x01020207
-
-/* OID_GEN_MINIPORT_INFO constants */
-#define NDIS_MINIPORT_BUS_MASTER                      0x00000001
-#define NDIS_MINIPORT_WDM_DRIVER                      0x00000002
-#define NDIS_MINIPORT_SG_LIST                         0x00000004
-#define NDIS_MINIPORT_SUPPORTS_MEDIA_QUERY            0x00000008
-#define NDIS_MINIPORT_INDICATES_PACKETS               0x00000010
-#define NDIS_MINIPORT_IGNORE_PACKET_QUEUE             0x00000020
-#define NDIS_MINIPORT_IGNORE_REQUEST_QUEUE            0x00000040
-#define NDIS_MINIPORT_IGNORE_TOKEN_RING_ERRORS        0x00000080
-#define NDIS_MINIPORT_INTERMEDIATE_DRIVER             0x00000100
-#define NDIS_MINIPORT_IS_NDIS_5                       0x00000200
-#define NDIS_MINIPORT_IS_CO                           0x00000400
-#define NDIS_MINIPORT_DESERIALIZE                     0x00000800
-#define NDIS_MINIPORT_REQUIRES_MEDIA_POLLING          0x00001000
-#define NDIS_MINIPORT_SUPPORTS_MEDIA_SENSE            0x00002000
-#define NDIS_MINIPORT_NETBOOT_CARD                    0x00004000
-#define NDIS_MINIPORT_PM_SUPPORTED                    0x00008000
-#define NDIS_MINIPORT_SUPPORTS_MAC_ADDRESS_OVERWRITE  0x00010000
-#define NDIS_MINIPORT_USES_SAFE_BUFFER_APIS           0x00020000
-#define NDIS_MINIPORT_HIDDEN                          0x00040000
-#define NDIS_MINIPORT_SWENUM                          0x00080000
-#define NDIS_MINIPORT_SURPRISE_REMOVE_OK              0x00100000
-#define NDIS_MINIPORT_NO_HALT_ON_SUSPEND              0x00200000
-#define NDIS_MINIPORT_HARDWARE_DEVICE                 0x00400000
-#define NDIS_MINIPORT_SUPPORTS_CANCEL_SEND_PACKETS    0x00800000
-#define NDIS_MINIPORT_64BITS_DMA                      0x01000000
-
-#define NDIS_MEDIUM_802_3		0x00000000
-#define NDIS_MEDIUM_802_5		0x00000001
-#define NDIS_MEDIUM_FDDI		0x00000002
-#define NDIS_MEDIUM_WAN			0x00000003
-#define NDIS_MEDIUM_LOCAL_TALK		0x00000004
-#define NDIS_MEDIUM_DIX			0x00000005
-#define NDIS_MEDIUM_ARCENT_RAW		0x00000006
-#define NDIS_MEDIUM_ARCENT_878_2	0x00000007
-#define NDIS_MEDIUM_ATM			0x00000008
-#define NDIS_MEDIUM_WIRELESS_LAN	0x00000009
-#define NDIS_MEDIUM_IRDA		0x0000000A
-#define NDIS_MEDIUM_BPC			0x0000000B
-#define NDIS_MEDIUM_CO_WAN		0x0000000C
-#define NDIS_MEDIUM_1394		0x0000000D
-
-#define NDIS_PACKET_TYPE_DIRECTED	0x00000001
-#define NDIS_PACKET_TYPE_MULTICAST	0x00000002
-#define NDIS_PACKET_TYPE_ALL_MULTICAST	0x00000004
-#define NDIS_PACKET_TYPE_BROADCAST	0x00000008
-#define NDIS_PACKET_TYPE_SOURCE_ROUTING	0x00000010
-#define NDIS_PACKET_TYPE_PROMISCUOUS	0x00000020
-#define NDIS_PACKET_TYPE_SMT		0x00000040
-#define NDIS_PACKET_TYPE_ALL_LOCAL	0x00000080
-#define NDIS_PACKET_TYPE_GROUP		0x00000100
-#define NDIS_PACKET_TYPE_ALL_FUNCTIONAL	0x00000200
-#define NDIS_PACKET_TYPE_FUNCTIONAL	0x00000400
-#define NDIS_PACKET_TYPE_MAC_FRAME	0x00000800
-
-#define NDIS_MEDIA_STATE_CONNECTED	0x00000000
-#define NDIS_MEDIA_STATE_DISCONNECTED	0x00000001
-
-#define NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA     0x00000001
-#define NDIS_MAC_OPTION_RECEIVE_SERIALIZED      0x00000002
-#define NDIS_MAC_OPTION_TRANSFERS_NOT_PEND      0x00000004
-#define NDIS_MAC_OPTION_NO_LOOPBACK             0x00000008
-#define NDIS_MAC_OPTION_FULL_DUPLEX             0x00000010
-#define NDIS_MAC_OPTION_EOTX_INDICATION         0x00000020
-#define NDIS_MAC_OPTION_8021P_PRIORITY          0x00000040
-#define NDIS_MAC_OPTION_RESERVED                0x80000000
-
-#endif /* _LINUX_NDIS_H */
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/net2280.c linuxppc-2.6.9-dream/drivers/usb/gadget/net2280.c
--- linuxppc-2.6.9/drivers/usb/gadget/net2280.c	2004-10-18 23:53:11.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/net2280.c	2005-09-19 21:40:05.000000000 +0200
@@ -7,9 +7,13 @@
  *
  * CODE STATUS HIGHLIGHTS
  *
- * This driver should work well with most "gadget" drivers, including
- * the File Storage, Serial, and Ethernet/RNDIS gadget drivers
- * as well as Gadget Zero and Gadgetfs.
+ * Used with a gadget driver like "zero.c" this enumerates fine to Windows
+ * or Linux hosts; handles disconnect, reconnect, and reset, for full or
+ * high speed operation; and passes USB-IF "chapter 9" tests.
+ *
+ * Handles standard stress loads from the Linux "usbtest" driver, with
+ * either DMA (default) or PIO (use_dma=n) used for ep-{a,b,c,d}.  Testing
+ * with "ttcp" (and the "ether.c" driver) behaves nicely too.
  *
  * DMA is enabled by default.  Drivers using transfer queues might use
  * DMA chaining to remove IRQ latencies between transfers.  (Except when
@@ -178,7 +182,7 @@
 	if (ep->dma && (max % 4) != 0 && use_dma_chaining) {
 		DEBUG (ep->dev, "%s, no dma for maxpacket %d\n",
 			ep->ep.name, ep->ep.maxpacket);
-		ep->dma = NULL;
+		ep->dma = 0;
 	}
 
 	/* set type, direction, address; reset fifo counters */
@@ -253,7 +257,7 @@
 	return 0;
 }
 
-static int handshake (u32 __iomem *ptr, u32 mask, u32 done, int usec)
+static int handshake (u32 *ptr, u32 mask, u32 done, int usec)
 {
 	u32	result;
 
@@ -272,11 +276,11 @@
 
 static struct usb_ep_ops net2280_ep_ops;
 
-static void ep_reset (struct net2280_regs __iomem *regs, struct net2280_ep *ep)
+static void ep_reset (struct net2280_regs *regs, struct net2280_ep *ep)
 {
 	u32		tmp;
 
-	ep->desc = NULL;
+	ep->desc = 0;
 	INIT_LIST_HEAD (&ep->queue);
 
 	ep->ep.maxpacket = ~0;
@@ -303,16 +307,14 @@
 	/* init to our chosen defaults, notably so that we NAK OUT
 	 * packets until the driver queues a read (+note erratum 0112)
 	 */
-	tmp = (1 << SET_NAK_OUT_PACKETS_MODE)
+	writel (  (1 << SET_NAK_OUT_PACKETS_MODE)
 		| (1 << SET_NAK_OUT_PACKETS)
 		| (1 << CLEAR_EP_HIDE_STATUS_PHASE)
-		| (1 << CLEAR_INTERRUPT_MODE);
-
-	if (ep->num != 0) {
-		tmp |= (1 << CLEAR_ENDPOINT_TOGGLE)
-			| (1 << CLEAR_ENDPOINT_HALT);
-	}
-	writel (tmp, &ep->regs->ep_rsp);
+		| (1 << CLEAR_INTERRUPT_MODE)
+		| (1 << CLEAR_CONTROL_STATUS_PHASE_HANDSHAKE)
+		| (1 << CLEAR_ENDPOINT_TOGGLE)
+		| (1 << CLEAR_ENDPOINT_HALT)
+		, &ep->regs->ep_rsp);
 
 	/* scrub most status bits, and flush any fifo state */
 	writel (  (1 << TIMEOUT)
@@ -372,12 +374,12 @@
 	struct net2280_request	*req;
 
 	if (!_ep)
-		return NULL;
+		return 0;
 	ep = container_of (_ep, struct net2280_ep, ep);
 
 	req = kmalloc (sizeof *req, gfp_flags);
 	if (!req)
-		return NULL;
+		return 0;
 
 	memset (req, 0, sizeof *req);
 	req->req.dma = DMA_ADDR_INVALID;
@@ -391,7 +393,7 @@
 				&req->td_dma);
 		if (!td) {
 			kfree (req);
-			return NULL;
+			return 0;
 		}
 		td->dmacount = 0;	/* not VALID */
 		td->dmaaddr = __constant_cpu_to_le32 (DMA_ADDR_INVALID);
@@ -461,7 +463,7 @@
 
 	ep = container_of (_ep, struct net2280_ep, ep);
 	if (!_ep)
-		return NULL;
+		return 0;
 	*dma = DMA_ADDR_INVALID;
 
 #if	defined(USE_KMALLOC)
@@ -515,7 +517,7 @@
 static void
 write_fifo (struct net2280_ep *ep, struct usb_request *req)
 {
-	struct net2280_ep_regs	__iomem *regs = ep->regs;
+	struct net2280_ep_regs	*regs = ep->regs;
 	u8			*buf;
 	u32			tmp;
 	unsigned		count, total;
@@ -528,7 +530,7 @@
 		total = req->length - req->actual;
 	} else {
 		total = 0;
-		buf = NULL;
+		buf = 0;
 	}
 
 	/* write just one packet at a time */
@@ -575,8 +577,7 @@
  */
 static void out_flush (struct net2280_ep *ep)
 {
-	u32	__iomem *statp;
-	u32	tmp;
+	u32	*statp, tmp;
 
 	ASSERT_OUT_NAKING (ep);
 
@@ -609,7 +610,7 @@
 static int
 read_fifo (struct net2280_ep *ep, struct net2280_request *req)
 {
-	struct net2280_ep_regs	__iomem *regs = ep->regs;
+	struct net2280_ep_regs	*regs = ep->regs;
 	u8			*buf = req->req.buf + req->req.actual;
 	unsigned		count, tmp, is_short;
 	unsigned		cleanup = 0, prevent = 0;
@@ -677,7 +678,7 @@
 	}
 	if (count) {
 		tmp = readl (&regs->ep_data);
-		/* LE conversion is implicit here: */
+		cpu_to_le32s (&tmp);
 		do {
 			*buf++ = (u8) tmp;
 			tmp >>= 8;
@@ -736,12 +737,12 @@
 		/* erratum 0116 workaround part 2 (no AUTOSTART) */
 		| (1 << DMA_ENABLE);
 
-static inline void spin_stop_dma (struct net2280_dma_regs __iomem *dma)
+static inline void spin_stop_dma (struct net2280_dma_regs *dma)
 {
 	handshake (&dma->dmactl, (1 << DMA_ENABLE), 0, 50);
 }
 
-static inline void stop_dma (struct net2280_dma_regs __iomem *dma)
+static inline void stop_dma (struct net2280_dma_regs *dma)
 {
 	writel (readl (&dma->dmactl) & ~(1 << DMA_ENABLE), &dma->dmactl);
 	spin_stop_dma (dma);
@@ -749,7 +750,7 @@
 
 static void start_queue (struct net2280_ep *ep, u32 dmactl, u32 td_dma)
 {
-	struct net2280_dma_regs	__iomem *dma = ep->dma;
+	struct net2280_dma_regs	*dma = ep->dma;
 
 	writel ((1 << VALID_BIT) | (ep->is_in << DMA_DIRECTION),
 			&dma->dmacount);
@@ -770,7 +771,7 @@
 static void start_dma (struct net2280_ep *ep, struct net2280_request *req)
 {
 	u32			tmp;
-	struct net2280_dma_regs	__iomem *dma = ep->dma;
+	struct net2280_dma_regs	*dma = ep->dma;
 
 	/* FIXME can't use DMA for ZLPs */
 
@@ -965,7 +966,7 @@
 						if (ep->num == 0)
 							allow_status (ep);
 						/* don't queue it */
-						req = NULL;
+						req = 0;
 					} else
 						s = readl (&ep->regs->ep_stat);
 				}
@@ -1094,7 +1095,7 @@
 	 *  OUT:  was "usb-short", we must restart.
 	 */
 	if (ep->is_in && !req->valid) {
-		struct net2280_request	*entry, *prev = NULL;
+		struct net2280_request	*entry, *prev = 0;
 		int			reqmode, done = 0;
 
 		DEBUG (ep->dev, "%s dma hiccup td %p\n", ep->ep.name, req->td);
@@ -1219,7 +1220,7 @@
 			DEBUG (ep->dev, "unlink (%s) pio\n", _ep->name);
 			done (ep, req, -ECONNRESET);
 		}
-		req = NULL;
+		req = 0;
 
 	/* patch up hardware chaining data */
 	} else if (ep->dma && use_dma_chaining) {
@@ -1418,34 +1419,10 @@
 	return 0;
 }
 
-static int net2280_pullup(struct usb_gadget *_gadget, int is_on)
-{
-	struct net2280  *dev;
-	u32             tmp;
-	unsigned long   flags;
-
-	if (!_gadget)
-		return -ENODEV;
-	dev = container_of (_gadget, struct net2280, gadget);
-
-	spin_lock_irqsave (&dev->lock, flags);
-	tmp = readl (&dev->usb->usbctl);
-	dev->softconnect = (is_on != 0);
-	if (is_on)
-		tmp |= (1 << USB_DETECT_ENABLE);
-	else
-		tmp &= ~(1 << USB_DETECT_ENABLE);
-	writel (tmp, &dev->usb->usbctl);
-	spin_unlock_irqrestore (&dev->lock, flags);
-
-	return 0;
-}
-
 static const struct usb_gadget_ops net2280_ops = {
 	.get_frame	= net2280_get_frame,
 	.wakeup		= net2280_wakeup,
 	.set_selfpowered = net2280_set_selfpowered,
-	.pullup		= net2280_pullup,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -1830,6 +1807,8 @@
 {
 	u32	tmp;
 
+	/* force immediate bus disconnect, and synch through pci */
+	writel (0, &dev->usb->usbctl);
 	dev->gadget.speed = USB_SPEED_UNKNOWN;
 	(void) readl (&dev->usb->usbctl);
 
@@ -1924,7 +1903,7 @@
 	writel (  (1 << USB_ROOT_PORT_WAKEUP_ENABLE)
 		| (1 << SELF_POWERED_USB_DEVICE)
 		| (1 << REMOTE_WAKEUP_SUPPORT)
-		| (dev->softconnect << USB_DETECT_ENABLE)
+		| (1 << USB_DETECT_ENABLE)
 		| (1 << SELF_POWERED_STATUS)
 		, &dev->usb->usbctl);
 
@@ -1938,7 +1917,6 @@
 		| (1 << PCI_RETRY_ABORT_INTERRUPT_ENABLE)
 		| (1 << VBUS_INTERRUPT_ENABLE)
 		| (1 << ROOT_PORT_RESET_INTERRUPT_ENABLE)
-		| (1 << SUSPEND_REQUEST_CHANGE_INTERRUPT_ENABLE)
 		, &dev->regs->pciirqenb1);
 
 	/* don't leave any writes posted */
@@ -1976,16 +1954,15 @@
 		dev->ep [i].irqs = 0;
 
 	/* hook up the driver ... */
-	dev->softconnect = 1;
-	driver->driver.bus = NULL;
+	driver->driver.bus = 0;
 	dev->driver = driver;
 	dev->gadget.dev.driver = &driver->driver;
 	retval = driver->bind (&dev->gadget);
 	if (retval) {
 		DEBUG (dev, "bind to driver %s --> %d\n",
 				driver->driver.name, retval);
-		dev->driver = NULL;
-		dev->gadget.dev.driver = NULL;
+		dev->driver = 0;
+		dev->gadget.dev.driver = 0;
 		return retval;
 	}
 
@@ -2015,7 +1992,7 @@
 
 	/* don't disconnect if it's not connected */
 	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
-		driver = NULL;
+		driver = 0;
 
 	/* stop hardware; prevent new request submissions;
 	 * and kill any outstanding requests.
@@ -2048,11 +2025,9 @@
 	stop_activity (dev, driver);
 	spin_unlock_irqrestore (&dev->lock, flags);
 
-	net2280_pullup (&dev->gadget, 0);
-
 	driver->unbind (&dev->gadget);
-	dev->gadget.dev.driver = NULL;
-	dev->driver = NULL;
+	dev->gadget.dev.driver = 0;
+	dev->driver = 0;
 
 	net2280_led_active (dev, 0);
 	device_remove_file (&dev->pdev->dev, &dev_attr_function);
@@ -2081,7 +2056,7 @@
 		req = list_entry (ep->queue.next,
 			struct net2280_request, queue);
 	else
-		req = NULL;
+		req = 0;
 
 	/* ack all, and handle what we care about */
 	t = readl (&ep->regs->ep_stat);
@@ -2120,7 +2095,7 @@
 					set_halt (ep);
 					mode = 2;
 				} else if (!req && ep->stopped)
-					write_fifo (ep, NULL);
+					write_fifo (ep, 0);
 			}
 		} else {
 			/* status; stop NAKing */
@@ -2140,7 +2115,7 @@
 				ep->stopped = 1;
 				if (req)
 					done (ep, req, -EOVERFLOW);
-				req = NULL;
+				req = 0;
 			}
 		}
 	}
@@ -2167,7 +2142,7 @@
 				scan_dma_completions (ep);
 				if (unlikely (list_empty (&ep->queue)
 						|| ep->out_overflow)) {
-					req = NULL;
+					req = 0;
 					break;
 				}
 				req = list_entry (ep->queue.next,
@@ -2181,7 +2156,7 @@
 					count &= DMA_BYTE_COUNT_MASK;
 					if (readl (&ep->dma->dmadesc)
 							!= req->td_dma)
-						req = NULL;
+						req = 0;
 					break;
 				}
 				udelay(1);
@@ -2234,7 +2209,7 @@
 			if (ep->num == 0) {
 				/* wait for control status */
 				if (mode != 2)
-					req = NULL;
+					req = 0;
 			} else if (!req->req.zero || len != ep->ep.maxpacket)
 				mode = 2;
 		}
@@ -2256,13 +2231,13 @@
 			 */
 			if (!ep->stopped)
 				allow_status (ep);
-			req = NULL;
+			req = 0;
 		} else {
 			if (!list_empty (&ep->queue) && !ep->stopped)
 				req = list_entry (ep->queue.next,
 					struct net2280_request, queue);
 			else
-				req = NULL;
+				req = 0;
 			if (req && !ep->is_in)
 				stop_out_naking (ep);
 		}
@@ -2297,7 +2272,7 @@
 		if ((wIndex & 0x0f) == (bEndpointAddress & 0x0f))
 			return ep;
 	}
-	return NULL;
+	return 0;
 }
 
 static void handle_stat0_irqs (struct net2280 *dev, u32 stat)
@@ -2426,7 +2401,7 @@
 			/* hw handles device features */
 			if (u.r.bRequestType != USB_RECIP_ENDPOINT)
 				goto delegate;
-			if (u.r.wValue != USB_ENDPOINT_HALT
+			if (u.r.wValue != 0 /* HALT feature */
 					|| u.r.wLength != 0)
 				goto do_stall;
 			if ((e = get_ep_by_addr (dev, u.r.wIndex)) == 0)
@@ -2443,7 +2418,7 @@
 			/* hw handles device features */
 			if (u.r.bRequestType != USB_RECIP_ENDPOINT)
 				goto delegate;
-			if (u.r.wValue != USB_ENDPOINT_HALT
+			if (u.r.wValue != 0 /* HALT feature */
 					|| u.r.wLength != 0)
 				goto do_stall;
 			if ((e = get_ep_by_addr (dev, u.r.wIndex)) == 0)
@@ -2514,23 +2489,15 @@
 static void handle_stat1_irqs (struct net2280 *dev, u32 stat)
 {
 	struct net2280_ep	*ep;
-	u32			tmp, num, mask, scratch;
+	u32			tmp, num, scratch;
 
 	/* after disconnect there's nothing else to do! */
 	tmp = (1 << VBUS_INTERRUPT) | (1 << ROOT_PORT_RESET_INTERRUPT);
-	mask = (1 << HIGH_SPEED) | (1 << FULL_SPEED);
-
-	/* VBUS disconnect is indicated by VBUS_PIN and VBUS_INTERRUPT set.
-	 * Root Port Reset is indicated by ROOT_PORT_RESET_INTERRRUPT set and
-	 * both HIGH_SPEED and FULL_SPEED clear (as ROOT_PORT_RESET_INTERRUPT 
-	 * only indicates a change in the reset state).
-	 */
 	if (stat & tmp) {
 		writel (tmp, &dev->regs->irqstat1);
-		if ((((stat & (1 << ROOT_PORT_RESET_INTERRUPT)) && 
-				((readl (&dev->usb->usbstat) & mask) == 0))
-				|| ((readl (&dev->usb->usbctl) & (1 << VBUS_PIN)) == 0) 
-			    ) && ( dev->gadget.speed != USB_SPEED_UNKNOWN)) {
+		if (((stat & (1 << ROOT_PORT_RESET_INTERRUPT)) != 0
+			|| (readl (&dev->usb->usbctl) & (1 << VBUS_PIN)) == 0
+			) && dev->gadget.speed != USB_SPEED_UNKNOWN) {
 			DEBUG (dev, "disconnect %s\n",
 					dev->driver->driver.name);
 			stop_activity (dev, dev->driver);
@@ -2546,22 +2513,19 @@
 			return;
 	}
 
-	/* NOTE: chip stays in PCI D0 state for now, but it could
-	 * enter D1 to save more power
+	/* NOTE: we don't actually suspend the hardware; that starts to
+	 * interact with PCI power management, and needs something like a
+	 * controller->suspend() call to clear SUSPEND_REQUEST_INTERRUPT.
+	 * we shouldn't see resume interrupts.
+	 * for rev 0100, this also avoids erratum 0102.
 	 */
 	tmp = (1 << SUSPEND_REQUEST_CHANGE_INTERRUPT);
 	if (stat & tmp) {
-		writel (tmp, &dev->regs->irqstat1);
-		if (stat & (1 << SUSPEND_REQUEST_INTERRUPT)) {
-			if (dev->driver->suspend)
-				dev->driver->suspend (&dev->gadget);
-		} else {
-			if (dev->driver->resume)
-				dev->driver->resume (&dev->gadget);
-			/* at high speed, note erratum 0133 */
-		}
+		if (dev->driver->suspend)
+			dev->driver->suspend (&dev->gadget);
 		stat &= ~tmp;
 	}
+	stat &= ~(1 << SUSPEND_REQUEST_INTERRUPT);
 
 	/* clear any other status/irqs */
 	if (stat)
@@ -2569,7 +2533,6 @@
 
 	/* some status we can just ignore */
 	stat &= ~((1 << CONTROL_STATUS_INTERRUPT)
-			| (1 << SUSPEND_REQUEST_INTERRUPT)
 			| (1 << RESUME_INTERRUPT)
 			| (1 << SOF_INTERRUPT));
 	if (!stat)
@@ -2581,7 +2544,7 @@
 	stat &= ~DMA_INTERRUPTS;
 	scratch >>= 9;
 	for (num = 0; scratch; num++) {
-		struct net2280_dma_regs	__iomem *dma;
+		struct net2280_dma_regs	*dma;
 
 		tmp = 1 << num;
 		if ((tmp & scratch) == 0)
@@ -2735,11 +2698,11 @@
 		pci_disable_device (pdev);
 	device_unregister (&dev->gadget.dev);
 	device_remove_file (&pdev->dev, &dev_attr_registers);
-	pci_set_drvdata (pdev, NULL);
+	pci_set_drvdata (pdev, 0);
 
 	INFO (dev, "unbind\n");
 
-	the_controller = NULL;
+	the_controller = 0;
 }
 
 /* wrap this driver around the specified device, but
@@ -2750,7 +2713,7 @@
 {
 	struct net2280		*dev;
 	unsigned long		resource, len;
-	void			__iomem *base = NULL;
+	void			*base = 0;
 	int			retval, i;
 	char			buf [8], *bufp;
 
@@ -2808,15 +2771,14 @@
 		retval = -EFAULT;
 		goto done;
 	}
-	dev->regs = (struct net2280_regs __iomem *) base;
-	dev->usb = (struct net2280_usb_regs __iomem *) (base + 0x0080);
-	dev->pci = (struct net2280_pci_regs __iomem *) (base + 0x0100);
-	dev->dma = (struct net2280_dma_regs __iomem *) (base + 0x0180);
-	dev->dep = (struct net2280_dep_regs __iomem *) (base + 0x0200);
-	dev->epregs = (struct net2280_ep_regs __iomem *) (base + 0x0300);
+	dev->regs = (struct net2280_regs *) base;
+	dev->usb = (struct net2280_usb_regs *) (base + 0x0080);
+	dev->pci = (struct net2280_pci_regs *) (base + 0x0100);
+	dev->dma = (struct net2280_dma_regs *) (base + 0x0180);
+	dev->dep = (struct net2280_dep_regs *) (base + 0x0200);
+	dev->epregs = (struct net2280_ep_regs *) (base + 0x0300);
 
 	/* put into initial config, link up all endpoints */
-	writel (0, &dev->usb->usbctl);
 	usb_reset (dev);
 	usb_reinit (dev);
 
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/net2280.h linuxppc-2.6.9-dream/drivers/usb/gadget/net2280.h
--- linuxppc-2.6.9/drivers/usb/gadget/net2280.h	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/net2280.h	2005-09-19 21:40:05.000000000 +0200
@@ -446,7 +446,7 @@
  */
 
 static inline u32
-get_idx_reg (struct net2280_regs __iomem *regs, u32 index)
+get_idx_reg (struct net2280_regs *regs, u32 index)
 {
 	writel (index, &regs->idxaddr);
 	/* NOTE:  synchs device/cpu memory views */
@@ -454,7 +454,7 @@
 }
 
 static inline void
-set_idx_reg (struct net2280_regs __iomem *regs, u32 index, u32 value)
+set_idx_reg (struct net2280_regs *regs, u32 index, u32 value)
 {
 	writel (index, &regs->idxaddr);
 	writel (value, &regs->idxdata);
@@ -507,8 +507,8 @@
 
 struct net2280_ep {
 	struct usb_ep				ep;
-	struct net2280_ep_regs			__iomem *regs;
-	struct net2280_dma_regs			__iomem *dma;
+	struct net2280_ep_regs			*regs;
+	struct net2280_dma_regs			*dma;
 	struct net2280_dma			*dummy;
 	dma_addr_t				td_dma;	/* of dummy */
 	struct net2280				*dev;
@@ -539,7 +539,7 @@
 /* count (<= 4) bytes in the next fifo write will be valid */
 static inline void set_fifo_bytecount (struct net2280_ep *ep, unsigned count)
 {
-	writeb (count, 2 + (u8 __iomem *) &ep->regs->ep_cfg);
+	writeb (count, 2 + (u8 *) &ep->regs->ep_cfg);
 }
 
 struct net2280_request {
@@ -559,19 +559,18 @@
 	struct usb_gadget_driver 	*driver;
 	unsigned			enabled : 1,
 					protocol_stall : 1,
-					softconnect : 1,
 					got_irq : 1,
 					region : 1;
 	u16				chiprev;
 
 	/* pci state used to access those endpoints */
 	struct pci_dev			*pdev;
-	struct net2280_regs		__iomem *regs;
-	struct net2280_usb_regs		__iomem *usb;
-	struct net2280_pci_regs		__iomem *pci;
-	struct net2280_dma_regs		__iomem *dma;
-	struct net2280_dep_regs		__iomem *dep;
-	struct net2280_ep_regs		__iomem *epregs;
+	struct net2280_regs		*regs;
+	struct net2280_usb_regs		*usb;
+	struct net2280_pci_regs		*pci;
+	struct net2280_dma_regs		*dma;
+	struct net2280_dep_regs		*dep;
+	struct net2280_ep_regs		*epregs;
 
 	struct pci_pool			*requests;
 	// statistics...
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/omap_udc.c linuxppc-2.6.9-dream/drivers/usb/gadget/omap_udc.c
--- linuxppc-2.6.9/drivers/usb/gadget/omap_udc.c	2004-10-18 23:53:43.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/omap_udc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2695 +0,0 @@
-/*
- * omap_udc.c -- for OMAP 1610 udc, with OTG support
- *
- * Copyright (C) 2004 Texas Instruments, Inc.
- * Copyright (C) 2004 David Brownell
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#undef	DEBUG
-#undef	VERBOSE
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/list.h>
-#include <linux/interrupt.h>
-#include <linux/proc_fs.h>
-#include <linux/mm.h>
-#include <linux/moduleparam.h>
-#include <linux/device.h>
-#include <linux/usb_ch9.h>
-#include <linux/usb_gadget.h>
-#include <linux/usb_otg.h>
-#include <linux/dma-mapping.h>
-
-#include <asm/byteorder.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/system.h>
-#include <asm/unaligned.h>
-#include <asm/mach-types.h>
-
-#include <asm/arch/dma.h>
-#include <asm/arch/mux.h>
-#include <asm/arch/usb.h>
-
-#include "omap_udc.h"
-
-#undef	USB_TRACE
-
-/* OUT-dma seems to be behaving */
-#define	USE_DMA
-
-/* ISO too */
-#define	USE_ISO
-
-
-#define	DRIVER_DESC	"OMAP UDC driver"
-#define	DRIVER_VERSION	"24 August 2004"
-
-#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
-
-
-/*
- * The OMAP UDC needs _very_ early endpoint setup:  before enabling the
- * D+ pullup to allow enumeration.  That's too early for the gadget
- * framework to use from usb_endpoint_enable(), which happens after
- * enumeration as part of activating an interface.  (But if we add an
- * optional new "UDC not yet running" state to the gadget driver model,
- * even just during driver binding, the endpoint autoconfig logic is the
- * natural spot to manufacture new endpoints.)
- *
- * So instead of using endpoint enable calls to control the hardware setup,
- * this driver defines a "fifo mode" parameter.  It's used during driver
- * initialization to choose among a set of pre-defined endpoint configs.
- * See omap_udc_setup() for available modes, or to add others.  That code
- * lives in an init section, so use this driver as a module if you need
- * to change the fifo mode after the kernel boots.
- *
- * Gadget drivers normally ignore endpoints they don't care about, and
- * won't include them in configuration descriptors.  That means only
- * misbehaving hosts would even notice they exist.
- */
-#ifdef	USE_ISO
-static unsigned fifo_mode = 3;
-#else
-static unsigned fifo_mode = 0;
-#endif
-
-/* "modprobe omap_udc fifo_mode=42", or else as a kernel
- * boot parameter "omap_udc:fifo_mode=42"
- */
-module_param (fifo_mode, uint, 0);
-MODULE_PARM_DESC (fifo_mode, "endpoint setup (0 == default)");
-
-
-#ifdef	USE_DMA
-static unsigned use_dma = 1;
-
-/* "modprobe omap_udc use_dma=y", or else as a kernel
- * boot parameter "omap_udc:use_dma=y"
- */
-module_param (use_dma, bool, 0);
-MODULE_PARM_DESC (use_dma, "enable/disable DMA");
-#else	/* !USE_DMA */
-
-/* save a bit of code */
-#define	use_dma		0
-#endif	/* !USE_DMA */
-
-
-static const char driver_name [] = "omap_udc";
-static const char driver_desc [] = DRIVER_DESC;
-
-/*-------------------------------------------------------------------------*/
-
-/* there's a notion of "current endpoint" for modifying endpoint
- * state, and PIO access to its FIFO.  
- */
-
-static void use_ep(struct omap_ep *ep, u16 select)
-{
-	u16	num = ep->bEndpointAddress & 0x0f;
-
-	if (ep->bEndpointAddress & USB_DIR_IN)
-		num |= UDC_EP_DIR;
-	UDC_EP_NUM_REG = num | select;
-	/* when select, MUST deselect later !! */
-}
-
-static inline void deselect_ep(void)
-{
-	UDC_EP_NUM_REG &= ~UDC_EP_SEL;
-	/* 6 wait states before TX will happen */
-}
-
-static void dma_channel_claim(struct omap_ep *ep, unsigned preferred);
-
-/*-------------------------------------------------------------------------*/
-
-static int omap_ep_enable(struct usb_ep *_ep,
-		const struct usb_endpoint_descriptor *desc)
-{
-	struct omap_ep	*ep = container_of(_ep, struct omap_ep, ep);
-	struct omap_udc	*udc;
-	unsigned long	flags;
-	u16		maxp;
-
-	/* catch various bogus parameters */
-	if (!_ep || !desc || ep->desc
-			|| desc->bDescriptorType != USB_DT_ENDPOINT
-			|| ep->bEndpointAddress != desc->bEndpointAddress
-			|| ep->maxpacket < le16_to_cpu
-						(desc->wMaxPacketSize)) {
-		DBG("%s, bad ep or descriptor\n", __FUNCTION__);
-		return -EINVAL;
-	}
-	maxp = le16_to_cpu (desc->wMaxPacketSize);
-	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
-				&& maxp != ep->maxpacket)
-			|| desc->wMaxPacketSize > ep->maxpacket
-			|| !desc->wMaxPacketSize) {
-		DBG("%s, bad %s maxpacket\n", __FUNCTION__, _ep->name);
-		return -ERANGE;
-	}
-
-#ifdef	USE_ISO
-	if ((desc->bmAttributes == USB_ENDPOINT_XFER_ISOC
-				&& desc->bInterval != 1)) {
-		/* hardware wants period = 1; USB allows 2^(Interval-1) */
-		DBG("%s, unsupported ISO period %dms\n", _ep->name,
-				1 << (desc->bInterval - 1));
-		return -EDOM;
-	}
-#else
-	if (desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {
-		DBG("%s, ISO nyet\n", _ep->name);
-		return -EDOM;
-	}
-#endif
-
-	/* xfer types must match, except that interrupt ~= bulk */
-	if (ep->bmAttributes != desc->bmAttributes
-			&& ep->bmAttributes != USB_ENDPOINT_XFER_BULK
-			&& desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
-		DBG("%s, %s type mismatch\n", __FUNCTION__, _ep->name);
-		return -EINVAL;
-	}
-
-	udc = ep->udc;
-	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {
-		DBG("%s, bogus device state\n", __FUNCTION__);
-		return -ESHUTDOWN;
-	}
-
-	spin_lock_irqsave(&udc->lock, flags);
-
-	ep->desc = desc;
-	ep->irqs = 0;
-	ep->stopped = 0;
-	ep->ep.maxpacket = maxp;
-
-	/* set endpoint to initial state */
-	ep->dma_channel = 0;
-	ep->has_dma = 0;
-	ep->lch = -1;
-	use_ep(ep, UDC_EP_SEL);
-	UDC_CTRL_REG = UDC_RESET_EP;
-	ep->ackwait = 0;
-	deselect_ep();
-
-	if (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC)
-		list_add(&ep->iso, &udc->iso);
-
-	/* maybe assign a DMA channel to this endpoint */
-	if (use_dma && desc->bmAttributes == USB_ENDPOINT_XFER_BULK
-			&& !(ep->bEndpointAddress & USB_DIR_IN))
-			/* FIXME ISO can dma, but prefers first channel.
-			 * IN can dma, but lacks debugging.
-			 */
-		dma_channel_claim(ep, 0);
-
-	/* PIO OUT may RX packets */
-	if (desc->bmAttributes != USB_ENDPOINT_XFER_ISOC
-			&& !ep->has_dma
-			&& !(ep->bEndpointAddress & USB_DIR_IN))
-		UDC_CTRL_REG = UDC_SET_FIFO_EN;
-
-	spin_unlock_irqrestore(&udc->lock, flags);
-	VDBG("%s enabled\n", _ep->name);
-	return 0;
-}
-
-static void nuke(struct omap_ep *, int status);
-
-static int omap_ep_disable(struct usb_ep *_ep)
-{
-	struct omap_ep	*ep = container_of(_ep, struct omap_ep, ep);
-	unsigned long	flags;
-
-	if (!_ep || !ep->desc) {
-		DBG("%s, %s not enabled\n", __FUNCTION__,
-			_ep ? ep->ep.name : NULL);
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(&ep->udc->lock, flags);
-	ep->desc = 0;
-	nuke (ep, -ESHUTDOWN);
-	ep->ep.maxpacket = ep->maxpacket;
-	ep->has_dma = 0;
-	UDC_CTRL_REG = UDC_SET_HALT;
-	list_del_init(&ep->iso);
-
-	spin_unlock_irqrestore(&ep->udc->lock, flags);
-
-	VDBG("%s disabled\n", _ep->name);
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static struct usb_request *
-omap_alloc_request(struct usb_ep *ep, int gfp_flags)
-{
-	struct omap_req	*req;
-
-	req = kmalloc(sizeof *req, gfp_flags);
-	if (req) {
-		memset (req, 0, sizeof *req);
-		req->req.dma = DMA_ADDR_INVALID;
-		INIT_LIST_HEAD (&req->queue);
-	}
-	return &req->req;
-}
-
-static void
-omap_free_request(struct usb_ep *ep, struct usb_request *_req)
-{
-	struct omap_req	*req = container_of(_req, struct omap_req, req);
-
-	if (_req)
-		kfree (req);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static void *
-omap_alloc_buffer(
-	struct usb_ep	*_ep,
-	unsigned	bytes,
-	dma_addr_t	*dma,
-	int		gfp_flags
-)
-{
-	void		*retval;
-	struct omap_ep	*ep;
-
-	ep = container_of(_ep, struct omap_ep, ep);
-	if (use_dma && ep->has_dma) {
-		static int	warned;
-		if (!warned && bytes < PAGE_SIZE) {
-			dev_warn(ep->udc->gadget.dev.parent,
-				"using dma_alloc_coherent for "
-				"small allocations wastes memory\n");
-			warned++;
-		}
-		return dma_alloc_coherent(ep->udc->gadget.dev.parent,
-				bytes, dma, gfp_flags);
-	}
-
-	retval = kmalloc(bytes, gfp_flags);
-	if (retval)
-		*dma = virt_to_phys(retval);
-	return retval;
-}
-
-static void omap_free_buffer(
-	struct usb_ep	*_ep,
-	void		*buf,
-	dma_addr_t	dma,
-	unsigned	bytes
-)
-{
-	struct omap_ep	*ep;
-
-	ep = container_of(_ep, struct omap_ep, ep);
-	if (use_dma && _ep && ep->has_dma)
-		dma_free_coherent(ep->udc->gadget.dev.parent, bytes, buf, dma);
-	else
-		kfree (buf);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static void
-done(struct omap_ep *ep, struct omap_req *req, int status)
-{
-	unsigned		stopped = ep->stopped;
-
-	list_del_init(&req->queue);
-
-	if (req->req.status == -EINPROGRESS)
-		req->req.status = status;
-	else
-		status = req->req.status;
-
-	if (use_dma && ep->has_dma) {
-		if (req->mapped) {
-			dma_unmap_single(ep->udc->gadget.dev.parent,
-				req->req.dma, req->req.length,
-				(ep->bEndpointAddress & USB_DIR_IN)
-					? DMA_TO_DEVICE
-					: DMA_FROM_DEVICE);
-			req->req.dma = DMA_ADDR_INVALID;
-			req->mapped = 0;
-		} else
-			dma_sync_single_for_cpu(ep->udc->gadget.dev.parent,
-				req->req.dma, req->req.length,
-				(ep->bEndpointAddress & USB_DIR_IN)
-					? DMA_TO_DEVICE
-					: DMA_FROM_DEVICE);
-	}
-
-#ifndef	USB_TRACE
-	if (status && status != -ESHUTDOWN)
-#endif
-		VDBG("complete %s req %p stat %d len %u/%u\n",
-			ep->ep.name, &req->req, status,
-			req->req.actual, req->req.length);
-
-	/* don't modify queue heads during completion callback */
-	ep->stopped = 1;
-	spin_unlock(&ep->udc->lock);
-	req->req.complete(&ep->ep, &req->req);
-	spin_lock(&ep->udc->lock);
-	ep->stopped = stopped;
-}
-
-/*-------------------------------------------------------------------------*/
-
-#define	FIFO_FULL	(UDC_NON_ISO_FIFO_FULL | UDC_ISO_FIFO_FULL)
-#define	FIFO_UNWRITABLE	(UDC_EP_HALTED | FIFO_FULL)
-
-#define FIFO_EMPTY	(UDC_NON_ISO_FIFO_EMPTY | UDC_ISO_FIFO_EMPTY)
-#define FIFO_UNREADABLE (UDC_EP_HALTED | FIFO_EMPTY)
-
-static inline int 
-write_packet(u8 *buf, struct omap_req *req, unsigned max)
-{
-	unsigned	len;
-	u16		*wp;
-
-	len = min(req->req.length - req->req.actual, max);
-	req->req.actual += len;
-
-	max = len;
-	if (likely((((int)buf) & 1) == 0)) {
-		wp = (u16 *)buf;
-		while (max >= 2) {
-			UDC_DATA_REG = *wp++;
-			max -= 2;
-		}
-		buf = (u8 *)wp;
-	}
-	while (max--)
-		*(volatile u8 *)&UDC_DATA_REG = *buf++;
-	return len;
-}
-
-// FIXME change r/w fifo calling convention
-
-
-// return:  0 = still running, 1 = completed, negative = errno
-static int write_fifo(struct omap_ep *ep, struct omap_req *req)
-{
-	u8		*buf;
-	unsigned	count;
-	int		is_last;
-	u16		ep_stat;
-
-	buf = req->req.buf + req->req.actual;
-	prefetch(buf);
-
-	/* PIO-IN isn't double buffered except for iso */
-	ep_stat = UDC_STAT_FLG_REG;
-	if (ep_stat & FIFO_UNWRITABLE)
-		return 0;
-
-	count = ep->ep.maxpacket;
-	count = write_packet(buf, req, count);
-	UDC_CTRL_REG = UDC_SET_FIFO_EN;
-	ep->ackwait = 1;
-
-	/* last packet is often short (sometimes a zlp) */
-	if (count != ep->ep.maxpacket)
-		is_last = 1;
-	else if (req->req.length == req->req.actual
-			&& !req->req.zero)
-		is_last = 1;
-	else
-		is_last = 0;
-
-	/* NOTE:  requests complete when all IN data is in a
-	 * FIFO (or sometimes later, if a zlp was needed).
-	 * Use usb_ep_fifo_status() where needed.
-	 */
-	if (is_last)
-		done(ep, req, 0);
-	return is_last;
-}
-
-static inline int 
-read_packet(u8 *buf, struct omap_req *req, unsigned avail)
-{
-	unsigned	len;
-	u16		*wp;
-
-	len = min(req->req.length - req->req.actual, avail);
-	req->req.actual += len;
-	avail = len;
-
-	if (likely((((int)buf) & 1) == 0)) {
-		wp = (u16 *)buf;
-		while (avail >= 2) {
-			*wp++ = UDC_DATA_REG;
-			avail -= 2;
-		}
-		buf = (u8 *)wp;
-	}
-	while (avail--)
-		*buf++ = *(volatile u8 *)&UDC_DATA_REG;
-	return len;
-}
-
-// return:  0 = still running, 1 = queue empty, negative = errno
-static int read_fifo(struct omap_ep *ep, struct omap_req *req)
-{
-	u8		*buf;
-	unsigned	count, avail;
-	int		is_last;
-
-	buf = req->req.buf + req->req.actual;
-	prefetchw(buf);
-
-	for (;;) {
-		u16	ep_stat = UDC_STAT_FLG_REG;
-
-		is_last = 0;
-		if (ep_stat & FIFO_UNREADABLE)
-			break;
-
-		if (ep_stat & (UDC_NON_ISO_FIFO_FULL|UDC_ISO_FIFO_FULL))
-			avail = ep->ep.maxpacket;
-		else 
-			avail = UDC_RXFSTAT_REG;
-		count = read_packet(buf, req, avail);
-
-		// FIXME double buffered PIO OUT wasn't behaving...
-
-		/* partial packet reads may not be errors */
-		if (count < ep->ep.maxpacket) {
-			is_last = 1;
-			/* overflowed this request?  flush extra data */
-			if (count != avail) {
-				req->req.status = -EOVERFLOW;
-				avail -= count;
-				while (avail--)
-					(void) *(volatile u8 *)&UDC_DATA_REG;
-			}
-		} else if (req->req.length == req->req.actual)
-			is_last = 1;
-		else
-			is_last = 0;
-
-		if (!ep->bEndpointAddress)
-			break;
-		if (!ep->double_buf) {
-			UDC_CTRL_REG = UDC_SET_FIFO_EN;
-			if (!is_last)
-				break;
-		}
-
-		if (is_last) {
-			done(ep, req, 0);
-			if (list_empty(&ep->queue) || !ep->double_buf)
-				break;
-			req = container_of(ep->queue.next,
-					struct omap_req, queue);
-			is_last = 0;
-		}
-	}
-	return is_last;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* Each USB transfer request using DMA maps to one or more DMA transfers.
- * When DMA completion isn't request completion, the UDC continues with
- * the next DMA transfer for that USB transfer.
- */
-
-static void next_in_dma(struct omap_ep *ep, struct omap_req *req)
-{
-	u16		txdma_ctrl;
-	unsigned	length = req->req.length - req->req.actual;
-
-	/* measure length in either bytes or packets */
-	if (length <= (UDC_TXN_TSC + 1)) {
-		txdma_ctrl = UDC_TXN_EOT | length;
-		omap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S8,
-				length, 1, OMAP_DMA_SYNC_ELEMENT);
-	} else {
-		length = max(length / ep->maxpacket,
-				(unsigned) UDC_TXN_TSC + 1);
- 		txdma_ctrl = length;
-		omap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S8,
-				ep->ep.maxpacket, length,
-				OMAP_DMA_SYNC_ELEMENT);
-		length *= ep->maxpacket;
-	}
-
-	omap_set_dma_src_params(ep->lch, OMAP_DMA_PORT_EMIFF,
-		OMAP_DMA_AMODE_POST_INC, req->req.dma + req->req.actual);
-
-	omap_start_dma(ep->lch);
-	UDC_DMA_IRQ_EN_REG |= UDC_TX_DONE_IE(ep->dma_channel);
-	UDC_TXDMA_REG(ep->dma_channel) = UDC_TXN_START | txdma_ctrl;
-	req->dma_bytes = length;
-}
-
-static void finish_in_dma(struct omap_ep *ep, struct omap_req *req, int status)
-{
-	if (status == 0) {
-		req->req.actual += req->dma_bytes;
-
-		/* return if this request needs to send data or zlp */
-		if (req->req.actual < req->req.length)
-			return;
-		if (req->req.zero
-				&& req->dma_bytes != 0
-				&& (req->req.actual % ep->maxpacket) == 0)
-			return;
-	} else {
-		u32	last;
-
-		// FIXME this surely isn't #bytes transferred
-		last = (omap_readw(OMAP_DMA_CSSA_U(ep->lch)) << 16)
-				| omap_readw(OMAP_DMA_CSSA_L(ep->lch));
-		req->req.actual = last - req->req.dma;
-	}
-
-	/* tx completion */
-	omap_stop_dma(ep->lch);
-	UDC_DMA_IRQ_EN_REG &= ~UDC_TX_DONE_IE(ep->dma_channel);
-	done(ep, req, status);
-}
-
-static void next_out_dma(struct omap_ep *ep, struct omap_req *req)
-{
-	unsigned packets;
-
-	/* NOTE:  we filtered out "short reads" before, so we know
-	 * the buffer has only whole numbers of packets.
-	 */
-
-	/* set up this DMA transfer, enable the fifo, start */
-	packets = (req->req.length - req->req.actual) / ep->ep.maxpacket;
-	packets = min(packets, (unsigned)UDC_RXN_TC + 1);
-	req->dma_bytes = packets * ep->ep.maxpacket;
-	omap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S8,
-			ep->ep.maxpacket, packets,
-			OMAP_DMA_SYNC_ELEMENT);
-	omap_set_dma_dest_params(ep->lch, OMAP_DMA_PORT_EMIFF,
-		OMAP_DMA_AMODE_POST_INC, req->req.dma + req->req.actual);
-
-	UDC_RXDMA_REG(ep->dma_channel) = UDC_RXN_STOP | (packets - 1);
-	UDC_DMA_IRQ_EN_REG |= UDC_RX_EOT_IE(ep->dma_channel);
-	UDC_EP_NUM_REG = (ep->bEndpointAddress & 0xf);
-	UDC_CTRL_REG = UDC_SET_FIFO_EN;
-
-	omap_start_dma(ep->lch);
-}
-
-static void
-finish_out_dma(struct omap_ep *ep, struct omap_req *req, int status)
-{
-	u16	count;
-
-	/* FIXME must be a better way to see how much dma
-	 * happened, even when it never got going...
-	 */
-	count = omap_readw(OMAP_DMA_CDAC(ep->lch));
-	count -= 0xffff & (req->req.dma + req->req.actual);
-	count += req->req.actual;
-	if (count <= req->req.length)
-		req->req.actual = count;
-	
-	if (count != req->dma_bytes || status)
-		omap_stop_dma(ep->lch);
-
-	/* if this wasn't short, request may need another transfer */
-	else if (req->req.actual < req->req.length)
-		return;
-
-	/* rx completion */
-	UDC_DMA_IRQ_EN_REG &= ~UDC_RX_EOT_IE(ep->dma_channel);
-	done(ep, req, status);
-}
-
-static void dma_irq(struct omap_udc *udc, u16 irq_src)
-{
-	u16		dman_stat = UDC_DMAN_STAT_REG;
-	struct omap_ep	*ep;
-	struct omap_req	*req;
-
-	/* IN dma: tx to host */
-	if (irq_src & UDC_TXN_DONE) {
-		ep = &udc->ep[16 + UDC_DMA_TX_SRC(dman_stat)];
-		ep->irqs++;
-		/* can see TXN_DONE after dma abort */
-		if (!list_empty(&ep->queue)) {
-			req = container_of(ep->queue.next,
-						struct omap_req, queue);
-			finish_in_dma(ep, req, 0);
-		}
-		UDC_IRQ_SRC_REG = UDC_TXN_DONE;
-
-		if (!list_empty (&ep->queue)) {
-			req = container_of(ep->queue.next,
-					struct omap_req, queue);
-			next_in_dma(ep, req);
-		}
-	}
-
-	/* OUT dma: rx from host */
-	if (irq_src & UDC_RXN_EOT) {
-		ep = &udc->ep[UDC_DMA_RX_SRC(dman_stat)];
-		ep->irqs++;
-		/* can see RXN_EOT after dma abort */
-		if (!list_empty(&ep->queue)) {
-			req = container_of(ep->queue.next,
-					struct omap_req, queue);
-			finish_out_dma(ep, req, 0);
-		}
-		UDC_IRQ_SRC_REG = UDC_RXN_EOT;
-
-		if (!list_empty (&ep->queue)) {
-			req = container_of(ep->queue.next,
-					struct omap_req, queue);
-			next_out_dma(ep, req);
-		}
-	}
-
-	if (irq_src & UDC_RXN_CNT) {
-		ep = &udc->ep[UDC_DMA_RX_SRC(dman_stat)];
-		DBG("%s, RX_CNT irq?\n", ep->ep.name);
-		UDC_IRQ_SRC_REG = UDC_RXN_CNT;
-	}
-}
-
-static void dma_error(int lch, u16 ch_status, void *data)
-{
-	struct omap_ep	*ep = data;
-
-	/* if ch_status & OMAP_DMA_DROP_IRQ ... */
-	/* if ch_status & OMAP_DMA_TOUT_IRQ ... */
-	ERR("%s dma error, lch %d status %02x\n", ep->ep.name, lch, ch_status);
-
-	/* complete current transfer ... */
-}
-
-static void dma_channel_claim(struct omap_ep *ep, unsigned channel)
-{
-	u16	reg;
-	int	status, restart, is_in;
-
-	is_in = ep->bEndpointAddress & USB_DIR_IN;
-	if (is_in)
-		reg = UDC_TXDMA_CFG_REG;
-	else
-		reg = UDC_RXDMA_CFG_REG;
-	reg |= 1 << 12;		/* "pulse" activated */
-
-	ep->dma_channel = 0;
-	ep->lch = -1;
-	if (channel == 0 || channel > 3) {
-		if ((reg & 0x0f00) == 0)
-			channel = 3;
-		else if ((reg & 0x00f0) == 0)
-			channel = 2;
-		else if ((reg & 0x000f) == 0)	/* preferred for ISO */
-			channel = 1;
-		else {
-			status = -EMLINK;
-			goto just_restart;
-		}
-	}
-	reg |= (0x0f & ep->bEndpointAddress) << (4 * (channel - 1));
-	ep->dma_channel = channel;
-
-	if (is_in) {
-		status = omap_request_dma(OMAP_DMA_USB_W2FC_TX0 - 1 + channel,
-			ep->ep.name, dma_error, ep, &ep->lch);
-		if (status == 0) {
-			UDC_TXDMA_CFG_REG = reg;
-			omap_set_dma_dest_params(ep->lch,
-				OMAP_DMA_PORT_TIPB,
-				OMAP_DMA_AMODE_CONSTANT,
-				(unsigned long) io_v2p((u32)&UDC_DATA_DMA_REG));
-		}
-	} else {
-		status = omap_request_dma(OMAP_DMA_USB_W2FC_RX0 - 1 + channel,
-			ep->ep.name, dma_error, ep, &ep->lch);
-		if (status == 0) {
-			UDC_RXDMA_CFG_REG = reg;
-			omap_set_dma_src_params(ep->lch,
-				OMAP_DMA_PORT_TIPB,
-				OMAP_DMA_AMODE_CONSTANT,
-				(unsigned long) io_v2p((u32)&UDC_DATA_DMA_REG));
-		}
-	}
-	if (status)
-		ep->dma_channel = 0;
-	else {
-		ep->has_dma = 1;
-		omap_disable_dma_irq(ep->lch, OMAP_DMA_BLOCK_IRQ);
-
-		/* channel type P: hw synch (fifo) */
-		omap_writew(2, OMAP_DMA_LCH_CTRL(ep->lch));
-	}
-
-just_restart:
-	/* restart any queue, even if the claim failed  */
-	restart = !ep->stopped && !list_empty(&ep->queue);
-
-	if (status)
-		DBG("%s no dma channel: %d%s\n", ep->ep.name, status,
-			restart ? " (restart)" : "");
-	else
-		DBG("%s claimed %cxdma%d lch %d%s\n", ep->ep.name,
-			is_in ? 't' : 'r',
-			ep->dma_channel - 1, ep->lch,
-			restart ? " (restart)" : "");
-
-	if (restart) {
-		struct omap_req	*req;
-		req = container_of(ep->queue.next, struct omap_req, queue);
-		if (ep->has_dma)
-			(is_in ? next_in_dma : next_out_dma)(ep, req);
-		else {
-			use_ep(ep, UDC_EP_SEL);
-			(is_in ? write_fifo : read_fifo)(ep, req);
-			deselect_ep();
-			/* IN: 6 wait states before it'll tx */
-		}
-	}
-}
-
-static void dma_channel_release(struct omap_ep *ep)
-{
-	int		shift = 4 * (ep->dma_channel - 1);
-	u16		mask = 0x0f << shift;
-	struct omap_req	*req;
-	int		active;
-
-	/* abort any active usb transfer request */
-	if (!list_empty(&ep->queue))
-		req = container_of(ep->queue.next, struct omap_req, queue);
-	else
-		req = 0;
-
-	active = ((1 << 7) & omap_readl(OMAP_DMA_CCR(ep->lch))) != 0;
-
-	DBG("%s release %s %cxdma%d %p\n", ep->ep.name,
-			active ? "active" : "idle",
-			(ep->bEndpointAddress & USB_DIR_IN) ? 't' : 'r',
-			ep->dma_channel - 1, req);
-
-	/* wait till current packet DMA finishes, and fifo empties */
-	if (ep->bEndpointAddress & USB_DIR_IN) {
-		UDC_TXDMA_CFG_REG &= ~mask;
-
-		if (req) {
-			if (active)
-				udelay(50);
-			finish_in_dma(ep, req, -ECONNRESET);
-			if (UDC_TXDMA_CFG_REG & mask)
-				WARN("%s, SPIN abort TX dma\n", ep->ep.name);
-		}
-
-		/* host may empty the fifo (or not...) */
-		while (UDC_TXDMA_CFG_REG & mask)
-			udelay(10);
-
-	} else {
-		UDC_RXDMA_CFG_REG &= ~mask;
-
-		/* dma empties the fifo */
-		while (active && (UDC_RXDMA_CFG_REG & mask))
-			udelay(10);
-		omap_stop_dma(ep->lch);
-		if (req)
-			finish_out_dma(ep, req, -ECONNRESET);
-	}
-	omap_free_dma(ep->lch);
-	ep->dma_channel = 0;
-	ep->lch = -1;
-	/* has_dma still set, till endpoint is fully quiesced */
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-static int
-omap_ep_queue(struct usb_ep *_ep, struct usb_request *_req, int gfp_flags)
-{
-	struct omap_ep	*ep = container_of(_ep, struct omap_ep, ep);
-	struct omap_req	*req = container_of(_req, struct omap_req, req);
-	struct omap_udc	*udc;
-	unsigned long	flags;
-	int		is_iso = 0;
-
-	/* catch various bogus parameters */
-	if (!_req || !req->req.complete || !req->req.buf
-			|| !list_empty(&req->queue)) {
-		DBG("%s, bad params\n", __FUNCTION__);
-		return -EINVAL;
-	}
-	if (!_ep || (!ep->desc && ep->bEndpointAddress)) {
-		DBG("%s, bad ep\n", __FUNCTION__);
-		return -EINVAL;
-	}
-	if (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC) {
-		if (req->req.length > ep->ep.maxpacket)
-			return -EMSGSIZE;
-		is_iso = 1;
-	}
-
-	/* this isn't bogus, but OMAP DMA isn't the only hardware to
-	 * have a hard time with partial packet reads...  reject it.
-	 */
-	if (use_dma
-			&& ep->has_dma
-			&& ep->bEndpointAddress != 0
-			&& (ep->bEndpointAddress & USB_DIR_IN) == 0
-			&& (req->req.length % ep->ep.maxpacket) != 0) {
-		DBG("%s, no partial packet OUT reads\n", __FUNCTION__);
-		return -EMSGSIZE;
-	}
-
-	udc = ep->udc;
-	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)
-		return -ESHUTDOWN;
-
-	if (use_dma && ep->has_dma) {
-		if (req->req.dma == DMA_ADDR_INVALID) {
-			req->req.dma = dma_map_single(
-				ep->udc->gadget.dev.parent,
-				req->req.buf,
-				req->req.length,
-				(ep->bEndpointAddress & USB_DIR_IN)
-					? DMA_TO_DEVICE
-					: DMA_FROM_DEVICE);
-			req->mapped = 1;
-		} else {
-			dma_sync_single_for_device(
-				ep->udc->gadget.dev.parent,
-				req->req.dma, req->req.length,
-				(ep->bEndpointAddress & USB_DIR_IN)
-					? DMA_TO_DEVICE
-					: DMA_FROM_DEVICE);
-			req->mapped = 0;
-		}
-	}
-
-	VDBG("%s queue req %p, len %d buf %p\n",
-		ep->ep.name, _req, _req->length, _req->buf);
-
-	spin_lock_irqsave(&udc->lock, flags);
-
-	req->req.status = -EINPROGRESS;
-	req->req.actual = 0;
-
-	/* maybe kickstart non-iso i/o queues */
-	if (is_iso)
-		UDC_IRQ_EN_REG |= UDC_SOF_IE;
-	else if (list_empty(&ep->queue) && !ep->stopped && !ep->ackwait) {
-		int	is_in;
-
-		if (ep->bEndpointAddress == 0) {
-			if (!udc->ep0_pending || !list_empty (&ep->queue)) {
-				spin_unlock_irqrestore(&udc->lock, flags);
-				return -EL2HLT;
-			}
-
-			/* empty DATA stage? */
-			is_in = udc->ep0_in;
-			if (!req->req.length) {
-
-				/* chip became CONFIGURED or ADDRESSED
-				 * earlier; drivers may already have queued
-				 * requests to non-control endpoints
-				 */
-				if (udc->ep0_set_config) {
-					u16	irq_en = UDC_IRQ_EN_REG;
-
-					irq_en |= UDC_DS_CHG_IE | UDC_EP0_IE;
-					if (!udc->ep0_reset_config)
-						irq_en |= UDC_EPN_RX_IE
-							| UDC_EPN_TX_IE;
-					UDC_IRQ_EN_REG = irq_en;
-				}
-
-				/* STATUS is reverse direction */
-				UDC_EP_NUM_REG = is_in
-						? UDC_EP_SEL
-						: (UDC_EP_SEL|UDC_EP_DIR);
-				UDC_CTRL_REG = UDC_CLR_EP;
-				UDC_CTRL_REG = UDC_SET_FIFO_EN;
-				UDC_EP_NUM_REG = udc->ep0_in ? 0 : UDC_EP_DIR;
-
-				/* cleanup */
-				udc->ep0_pending = 0;
-				done(ep, req, 0);
-				req = 0;
-
-			/* non-empty DATA stage */
-			} else if (is_in) {
-				UDC_EP_NUM_REG = UDC_EP_SEL|UDC_EP_DIR;
-			} else {
-				if (udc->ep0_setup)
-					goto irq_wait;
-				UDC_EP_NUM_REG = UDC_EP_SEL;
-			}
-		} else {
-			is_in = ep->bEndpointAddress & USB_DIR_IN;
-			if (!ep->has_dma)
-				use_ep(ep, UDC_EP_SEL);
-			/* if ISO: SOF IRQs must be enabled/disabled! */
-		}
-
-		if (ep->has_dma)
-			(is_in ? next_in_dma : next_out_dma)(ep, req);
-		else if (req) {
-			if ((is_in ? write_fifo : read_fifo)(ep, req) == 1)
-				req = 0;
-			deselect_ep();
-			/* IN: 6 wait states before it'll tx */
-		}
-	}
-
-irq_wait:
-	/* irq handler advances the queue */
-	if (req != 0)
-		list_add_tail(&req->queue, &ep->queue);
-	spin_unlock_irqrestore(&udc->lock, flags);
-
-	return 0;
-}
-
-static int omap_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
-{
-	struct omap_ep	*ep = container_of(_ep, struct omap_ep, ep);
-	struct omap_req	*req;
-	unsigned long	flags;
-
-	if (!_ep || !_req)
-		return -EINVAL;
-
-	spin_lock_irqsave(&ep->udc->lock, flags);
-
-	/* make sure it's actually queued on this endpoint */
-	list_for_each_entry (req, &ep->queue, queue) {
-		if (&req->req == _req)
-			break;
-	}
-	if (&req->req != _req) {
-		spin_unlock_irqrestore(&ep->udc->lock, flags);
-		return -EINVAL;
-	}
-
-	if (use_dma && ep->dma_channel && ep->queue.next == &req->queue) {
-		int channel = ep->dma_channel;
-
-		/* releasing the dma completion cancels the request,
-		 * reclaiming the channel restarts the queue
-		 */
-		dma_channel_release(ep);
-		dma_channel_claim(ep, channel);
-	} else 
-		done(ep, req, -ECONNRESET);
-	spin_unlock_irqrestore(&ep->udc->lock, flags);
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int omap_ep_set_halt(struct usb_ep *_ep, int value)
-{
-	struct omap_ep	*ep = container_of(_ep, struct omap_ep, ep);
-	unsigned long	flags;
-	int		status = -EOPNOTSUPP;
-
-	spin_lock_irqsave(&ep->udc->lock, flags);
-
-	/* just use protocol stalls for ep0; real halts are annoying */
-	if (ep->bEndpointAddress == 0) {
-		if (!ep->udc->ep0_pending)
-			status = -EINVAL;
-		else if (value) {
-			if (ep->udc->ep0_set_config) {
-				WARN("error changing config?\n");
-				UDC_SYSCON2_REG = UDC_CLR_CFG;
-			}
-			UDC_SYSCON2_REG = UDC_STALL_CMD;
-			ep->udc->ep0_pending = 0;
-			status = 0;
-		} else /* NOP */
-			status = 0;
-
-	/* otherwise, all active non-ISO endpoints can halt */
-	} else if (ep->bmAttributes != USB_ENDPOINT_XFER_ISOC && ep->desc) {
-
-		/* IN endpoints must already be idle */
-		if ((ep->bEndpointAddress & USB_DIR_IN)
-				&& !list_empty(&ep->queue)) { 
-			status = -EAGAIN;
-			goto done;
-		}
-
-		if (value) {
-			int	channel;
-
-			if (use_dma && ep->dma_channel
-					&& !list_empty(&ep->queue)) {
-				channel = ep->dma_channel;
-				dma_channel_release(ep);
-			} else
-				channel = 0;
-
-			use_ep(ep, UDC_EP_SEL);
-			if (UDC_STAT_FLG_REG & UDC_NON_ISO_FIFO_EMPTY) {
-				UDC_CTRL_REG = UDC_SET_HALT;
-				status = 0;
-			} else
-				status = -EAGAIN;
-			deselect_ep();
-
-			if (channel)
-				dma_channel_claim(ep, channel);
-		} else {
-			use_ep(ep, 0);
-			UDC_CTRL_REG = UDC_RESET_EP;
-			ep->ackwait = 0;
-			if (!(ep->bEndpointAddress & USB_DIR_IN))
-				UDC_CTRL_REG = UDC_SET_FIFO_EN;
-		}
-	}
-done:
-	VDBG("%s %s halt stat %d\n", ep->ep.name,
-		value ? "set" : "clear", status);
-
-	spin_unlock_irqrestore(&ep->udc->lock, flags);
-	return status;
-}
-
-static struct usb_ep_ops omap_ep_ops = {
-	.enable		= omap_ep_enable,
-	.disable	= omap_ep_disable,
-
-	.alloc_request	= omap_alloc_request,
-	.free_request	= omap_free_request,
-
-	.alloc_buffer	= omap_alloc_buffer,
-	.free_buffer	= omap_free_buffer,
-
-	.queue		= omap_ep_queue,
-	.dequeue	= omap_ep_dequeue,
-
-	.set_halt	= omap_ep_set_halt,
-	// fifo_status ... report bytes in fifo
-	// fifo_flush ... flush fifo
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int omap_get_frame(struct usb_gadget *gadget)
-{
-	u16	sof = UDC_SOF_REG;
-	return (sof & UDC_TS_OK) ? (sof & UDC_TS) : -EL2NSYNC;
-}
-
-static int omap_wakeup(struct usb_gadget *gadget)
-{
-	struct omap_udc	*udc;
-	unsigned long	flags;
-	int		retval = -EHOSTUNREACH;
-
-	udc = container_of(gadget, struct omap_udc, gadget);
-
-	spin_lock_irqsave(&udc->lock, flags);
-	if (udc->devstat & UDC_SUS) {
-		/* NOTE:  OTG spec erratum says that OTG devices may
-		 * issue wakeups without host enable.
-		 */
-		if (udc->devstat & (UDC_B_HNP_ENABLE|UDC_R_WK_OK)) {
-			DBG("remote wakeup...\n");
-			UDC_SYSCON2_REG = UDC_RMT_WKP;
-			retval = 0;
-		}
-
-	/* NOTE:  non-OTG systems may use SRP TOO... */
-	} else if (!(udc->devstat & UDC_ATT)) {
-		if (udc->transceiver)
-			retval = otg_start_srp(udc->transceiver);
-	}
-	spin_unlock_irqrestore(&udc->lock, flags);
-
-	return retval;
-}
-
-static int
-omap_set_selfpowered(struct usb_gadget *gadget, int is_selfpowered)
-{
-	struct omap_udc	*udc;
-	unsigned long	flags;
-	u16		syscon1;
-
-	udc = container_of(gadget, struct omap_udc, gadget);
-	spin_lock_irqsave(&udc->lock, flags);
-	syscon1 = UDC_SYSCON1_REG;
-	if (is_selfpowered)
-		syscon1 |= UDC_SELF_PWR;
-	else
-		syscon1 &= ~UDC_SELF_PWR;
-	UDC_SYSCON1_REG = syscon1;
-	spin_unlock_irqrestore(&udc->lock, flags);
-
-	return 0;
-}
-
-static int can_pullup(struct omap_udc *udc)
-{
-	return udc->driver && udc->softconnect && udc->vbus_active;
-}
-
-static void pullup_enable(struct omap_udc *udc)
-{
-	UDC_SYSCON1_REG |= UDC_PULLUP_EN;
-#ifndef CONFIG_USB_OTG
-	OTG_CTRL_REG |= OTG_BSESSVLD;
-#endif
-	UDC_IRQ_EN_REG = UDC_DS_CHG_IE;
-}
-
-static void pullup_disable(struct omap_udc *udc)
-{
-#ifndef CONFIG_USB_OTG
-	OTG_CTRL_REG &= ~OTG_BSESSVLD;
-#endif
-	UDC_IRQ_EN_REG = UDC_DS_CHG_IE;
-	UDC_SYSCON1_REG &= ~UDC_PULLUP_EN;
-}
-
-/*
- * Called by whatever detects VBUS sessions:  external transceiver
- * driver, or maybe GPIO0 VBUS IRQ.
- */
-static int omap_vbus_session(struct usb_gadget *gadget, int is_active)
-{
-	struct omap_udc	*udc;
-	unsigned long	flags;
-
-	udc = container_of(gadget, struct omap_udc, gadget);
-	spin_lock_irqsave(&udc->lock, flags);
-	VDBG("VBUS %s\n", is_active ? "on" : "off");
-	udc->vbus_active = (is_active != 0);
-	if (can_pullup(udc))
-		pullup_enable(udc);
-	else
-		pullup_disable(udc);
-	spin_unlock_irqrestore(&udc->lock, flags);
-	return 0;
-}
-
-static int omap_vbus_draw(struct usb_gadget *gadget, unsigned mA)
-{
-	struct omap_udc	*udc;
-
-	udc = container_of(gadget, struct omap_udc, gadget);
-	if (udc->transceiver)
-		return otg_set_power(udc->transceiver, mA);
-	return -EOPNOTSUPP;
-}
-
-static int omap_pullup(struct usb_gadget *gadget, int is_on)
-{
-	struct omap_udc	*udc;
-	unsigned long	flags;
-
-	udc = container_of(gadget, struct omap_udc, gadget);
-	spin_lock_irqsave(&udc->lock, flags);
-	udc->softconnect = (is_on != 0);
-	if (can_pullup(udc))
-		pullup_enable(udc);
-	else
-		pullup_disable(udc);
-	spin_unlock_irqrestore(&udc->lock, flags);
-	return 0;
-}
-
-static struct usb_gadget_ops omap_gadget_ops = {
-	.get_frame		= omap_get_frame,
-	.wakeup			= omap_wakeup,
-	.set_selfpowered	= omap_set_selfpowered,
-	.vbus_session		= omap_vbus_session,
-	.vbus_draw		= omap_vbus_draw,
-	.pullup			= omap_pullup,
-};
-
-/*-------------------------------------------------------------------------*/
-
-/* dequeue ALL requests; caller holds udc->lock */
-static void nuke(struct omap_ep *ep, int status)
-{
-	struct omap_req	*req;
-
-	ep->stopped = 1;
-
-	if (use_dma && ep->dma_channel)
-		dma_channel_release(ep);
-
-	use_ep(ep, 0);
-	UDC_CTRL_REG = UDC_CLR_EP;
-	if (ep->bEndpointAddress && ep->bmAttributes != USB_ENDPOINT_XFER_ISOC)
-		UDC_CTRL_REG = UDC_SET_HALT;
-
-	while (!list_empty(&ep->queue)) {
-		req = list_entry(ep->queue.next, struct omap_req, queue);
-		done(ep, req, status);
-	}
-}
-
-/* caller holds udc->lock */
-static void udc_quiesce(struct omap_udc *udc)
-{
-	struct omap_ep	*ep;
-
-	udc->gadget.speed = USB_SPEED_UNKNOWN;
-	nuke(&udc->ep[0], -ESHUTDOWN);
-	list_for_each_entry (ep, &udc->gadget.ep_list, ep.ep_list)
-		nuke(ep, -ESHUTDOWN);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static void update_otg(struct omap_udc *udc)
-{
-	u16	devstat;
-
-	if (!udc->gadget.is_otg)
-		return;
-
-	if (OTG_CTRL_REG & OTG_ID)
-		devstat = UDC_DEVSTAT_REG;
-	else
-		devstat = 0;
-
-	udc->gadget.b_hnp_enable = !!(devstat & UDC_B_HNP_ENABLE);
-	udc->gadget.a_hnp_support = !!(devstat & UDC_A_HNP_SUPPORT);
-	udc->gadget.a_alt_hnp_support = !!(devstat & UDC_A_ALT_HNP_SUPPORT);
-
-	/* Enable HNP early, avoiding races on suspend irq path.
-	 * ASSUMES OTG state machine B_BUS_REQ input is true.
-	 */
-	if (udc->gadget.b_hnp_enable)
-		OTG_CTRL_REG = (OTG_CTRL_REG | OTG_B_HNPEN | OTG_B_BUSREQ)
-				& ~OTG_PULLUP;
-}
-
-static void ep0_irq(struct omap_udc *udc, u16 irq_src)
-{
-	struct omap_ep	*ep0 = &udc->ep[0];
-	struct omap_req	*req = 0;
-
-	ep0->irqs++;
-
-	/* Clear any pending requests and then scrub any rx/tx state
-	 * before starting to handle the SETUP request.
-	 */
-	if (irq_src & UDC_SETUP)
-		nuke(ep0, 0);
-
-	/* IN/OUT packets mean we're in the DATA or STATUS stage.  
-	 * This driver uses only uses protocol stalls (ep0 never halts),
-	 * and if we got this far the gadget driver already had a
-	 * chance to stall.  Tries to be forgiving of host oddities.
-	 *
-	 * NOTE:  the last chance gadget drivers have to stall control
-	 * requests is during their request completion callback.
-	 */
-	if (!list_empty(&ep0->queue))
-		req = container_of(ep0->queue.next, struct omap_req, queue);
-
-	/* IN == TX to host */
-	if (irq_src & UDC_EP0_TX) {
-		int	stat;
-
-		UDC_IRQ_SRC_REG = UDC_EP0_TX;
-		UDC_EP_NUM_REG = UDC_EP_SEL|UDC_EP_DIR;
-		stat = UDC_STAT_FLG_REG;
-		if (stat & UDC_ACK) {
-			if (udc->ep0_in) {
-				/* write next IN packet from response,
-				 * or set up the status stage.
-				 */
-				if (req)
-					stat = write_fifo(ep0, req);
-				UDC_EP_NUM_REG = UDC_EP_DIR;
-				if (!req && udc->ep0_pending) {
-					UDC_EP_NUM_REG = UDC_EP_SEL;
-					UDC_CTRL_REG = UDC_CLR_EP;
-					UDC_CTRL_REG = UDC_SET_FIFO_EN;
-					UDC_EP_NUM_REG = 0;
-					udc->ep0_pending = 0;
-				} /* else:  6 wait states before it'll tx */
-			} else {
-				/* ack status stage of OUT transfer */
-				UDC_EP_NUM_REG = UDC_EP_DIR;
-				if (req)
-					done(ep0, req, 0);
-			}
-			req = 0;
-		} else if (stat & UDC_STALL) {
-			UDC_CTRL_REG = UDC_CLR_HALT;
-			UDC_EP_NUM_REG = UDC_EP_DIR;
-		} else {
-			UDC_EP_NUM_REG = UDC_EP_DIR;
-		}
-	}
-
-	/* OUT == RX from host */
-	if (irq_src & UDC_EP0_RX) {
-		int	stat;
-
-		UDC_IRQ_SRC_REG = UDC_EP0_RX;
-		UDC_EP_NUM_REG = UDC_EP_SEL;
-		stat = UDC_STAT_FLG_REG;
-		if (stat & UDC_ACK) {
-			if (!udc->ep0_in) {
-				stat = 0;
-				/* read next OUT packet of request, maybe
-				 * reactiviting the fifo; stall on errors.
-				 */
-				if (!req || (stat = read_fifo(ep0, req)) < 0) {
-					UDC_SYSCON2_REG = UDC_STALL_CMD;
-					udc->ep0_pending = 0;
-					stat = 0;
-				} else if (stat == 0)
-					UDC_CTRL_REG = UDC_SET_FIFO_EN;
-				UDC_EP_NUM_REG = 0;
-				
-				/* activate status stage */
-				if (stat == 1) {
-					done(ep0, req, 0);
-					/* that may have STALLed ep0... */
-					UDC_EP_NUM_REG = UDC_EP_SEL|UDC_EP_DIR;
-					UDC_CTRL_REG = UDC_CLR_EP;
-					UDC_CTRL_REG = UDC_SET_FIFO_EN;
-					UDC_EP_NUM_REG = UDC_EP_DIR;
-					udc->ep0_pending = 0;
-				}
-			} else {
-				/* ack status stage of IN transfer */
-				UDC_EP_NUM_REG = 0;
-				if (req)
-					done(ep0, req, 0);
-			}
-		} else if (stat & UDC_STALL) {
-			UDC_CTRL_REG = UDC_CLR_HALT;
-			UDC_EP_NUM_REG = 0;
-		} else {
-			UDC_EP_NUM_REG = 0;
-		}
-	}
-
-	/* SETUP starts all control transfers */
-	if (irq_src & UDC_SETUP) {
-		union u {
-			u16			word[4];
-			struct usb_ctrlrequest	r;
-		} u;
-		int			status = -EINVAL;
-		struct omap_ep		*ep;
-
-		/* read the (latest) SETUP message */
-		do {
-			UDC_EP_NUM_REG = UDC_SETUP_SEL;
-			/* two bytes at a time */
-			u.word[0] = UDC_DATA_REG;
-			u.word[1] = UDC_DATA_REG;
-			u.word[2] = UDC_DATA_REG;
-			u.word[3] = UDC_DATA_REG;
-			UDC_EP_NUM_REG = 0;
-		} while (UDC_IRQ_SRC_REG & UDC_SETUP);
-		le16_to_cpus (&u.r.wValue);
-		le16_to_cpus (&u.r.wIndex);
-		le16_to_cpus (&u.r.wLength);
-
-		/* Delegate almost all control requests to the gadget driver,
-		 * except for a handful of ch9 status/feature requests that
-		 * hardware doesn't autodecode _and_ the gadget API hides.
-		 */
-		udc->ep0_in = (u.r.bRequestType & USB_DIR_IN) != 0;
-		udc->ep0_set_config = 0;
-		udc->ep0_pending = 1;
-		ep0->stopped = 0;
-		ep0->ackwait = 0;
-		switch (u.r.bRequest) {
-		case USB_REQ_SET_CONFIGURATION:
-			/* udc needs to know when ep != 0 is valid */
-			if (u.r.bRequestType != USB_RECIP_DEVICE)
-				goto delegate;
-			if (u.r.wLength != 0)
-				goto do_stall;
-			udc->ep0_set_config = 1;
-			udc->ep0_reset_config = (u.r.wValue == 0);
-			VDBG("set config %d\n", u.r.wValue);
-
-			/* update udc NOW since gadget driver may start
-			 * queueing requests immediately; clear config
-			 * later if it fails the request.
-			 */
-			if (udc->ep0_reset_config)
-				UDC_SYSCON2_REG = UDC_CLR_CFG;
-			else
-				UDC_SYSCON2_REG = UDC_DEV_CFG;
-			update_otg(udc);
-			goto delegate;
-		case USB_REQ_CLEAR_FEATURE:
-			/* clear endpoint halt */
-			if (u.r.bRequestType != USB_RECIP_ENDPOINT)
-				goto delegate;
-			if (u.r.wValue != USB_ENDPOINT_HALT
-					|| u.r.wLength != 0)
-				goto do_stall;
-			ep = &udc->ep[u.r.wIndex & 0xf];
-			if (ep != ep0) {
-				if (u.r.wIndex & USB_DIR_IN)
-					ep += 16;
-				if (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC
-						|| !ep->desc)
-					goto do_stall;
-				use_ep(ep, 0);
-				UDC_CTRL_REG = UDC_RESET_EP;
-				ep->ackwait = 0;
-				if (!(ep->bEndpointAddress & USB_DIR_IN))
-					UDC_CTRL_REG = UDC_SET_FIFO_EN;
-			}
-			VDBG("%s halt cleared by host\n", ep->name);
-			goto ep0out_status_stage;
-		case USB_REQ_SET_FEATURE:
-			/* set endpoint halt */
-			if (u.r.bRequestType != USB_RECIP_ENDPOINT)
-				goto delegate;
-			if (u.r.wValue != USB_ENDPOINT_HALT
-					|| u.r.wLength != 0)
-				goto do_stall;
-			ep = &udc->ep[u.r.wIndex & 0xf];
-			if (u.r.wIndex & USB_DIR_IN)
-				ep += 16;
-			if (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC
-					|| ep == ep0 || !ep->desc)
-				goto do_stall;
-			if (use_dma && ep->has_dma) {
-				/* this has rude side-effects (aborts) and
-				 * can't really work if DMA-IN is active
-				 */
-				DBG("%s host set_halt, NYET \n", ep->name);
-				goto do_stall;
-			}
-			use_ep(ep, 0);
-			/* can't halt if fifo isn't empty... */
-			UDC_CTRL_REG = UDC_CLR_EP;
-			UDC_CTRL_REG = UDC_SET_HALT;
-			VDBG("%s halted by host\n", ep->name);
-ep0out_status_stage:
-			status = 0;
-			UDC_EP_NUM_REG = UDC_EP_SEL|UDC_EP_DIR;
-			UDC_CTRL_REG = UDC_CLR_EP;
-			UDC_CTRL_REG = UDC_SET_FIFO_EN;
-			UDC_EP_NUM_REG = UDC_EP_DIR;
-			udc->ep0_pending = 0;
-			break;
-		case USB_REQ_GET_STATUS:
-			/* return interface status.  if we were pedantic,
-			 * we'd detect non-existent interfaces, and stall.
-			 */
-			if (u.r.bRequestType
-					!= (USB_DIR_IN|USB_RECIP_INTERFACE))
-				goto delegate;
-			/* return two zero bytes */
-			UDC_EP_NUM_REG = UDC_EP_SEL|UDC_EP_DIR;
-			UDC_DATA_REG = 0;
-			UDC_CTRL_REG = UDC_SET_FIFO_EN;
-			UDC_EP_NUM_REG = UDC_EP_DIR;
-			status = 0;
-			VDBG("GET_STATUS, interface %d\n", u.r.wIndex);
-			/* next, status stage */
-			break;
-		default:
-delegate:
-			/* activate the ep0out fifo right away */
-			if (!udc->ep0_in && u.r.wLength) {
-				UDC_EP_NUM_REG = 0;
-				UDC_CTRL_REG = UDC_SET_FIFO_EN;
-			}
-
-			/* gadget drivers see class/vendor specific requests,
-			 * {SET,GET}_{INTERFACE,DESCRIPTOR,CONFIGURATION},
-			 * and more
-			 */
-			VDBG("SETUP %02x.%02x v%04x i%04x l%04x\n",
-				u.r.bRequestType, u.r.bRequest,
-				u.r.wValue, u.r.wIndex, u.r.wLength);
-
-			/* The gadget driver may return an error here,
-			 * causing an immediate protocol stall.
-			 *
-			 * Else it must issue a response, either queueing a
-			 * response buffer for the DATA stage, or halting ep0
-			 * (causing a protocol stall, not a real halt).  A
-			 * zero length buffer means no DATA stage.
-			 *
-			 * It's fine to issue that response after the setup()
-			 * call returns, and this IRQ was handled.
-			 */
-			udc->ep0_setup = 1;
-			spin_unlock(&udc->lock);
-			status = udc->driver->setup (&udc->gadget, &u.r);
-			spin_lock(&udc->lock);
-			udc->ep0_setup = 0;
-		}
-
-		if (status < 0) {
-do_stall:
-			VDBG("req %02x.%02x protocol STALL; stat %d\n",
-					u.r.bRequestType, u.r.bRequest, status);
-			if (udc->ep0_set_config) {
-				if (udc->ep0_reset_config)
-					WARN("error resetting config?\n");
-				else
-					UDC_SYSCON2_REG = UDC_CLR_CFG;
-			}
-			UDC_SYSCON2_REG = UDC_STALL_CMD;
-			udc->ep0_pending = 0;
-		}
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-
-#define OTG_FLAGS (UDC_B_HNP_ENABLE|UDC_A_HNP_SUPPORT|UDC_A_ALT_HNP_SUPPORT)
-
-static void devstate_irq(struct omap_udc *udc, u16 irq_src)
-{
-	u16	devstat, change;
-
-	devstat = UDC_DEVSTAT_REG;
-	change = devstat ^ udc->devstat;
-	udc->devstat = devstat;
-
-	if (change & (UDC_USB_RESET|UDC_ATT)) {
-		udc_quiesce(udc);
-
-		if (change & UDC_ATT) {
-			/* driver for any external transceiver will
-			 * have called omap_vbus_session() already
-			 */
-			if (devstat & UDC_ATT) {
-				udc->gadget.speed = USB_SPEED_FULL;
-				VDBG("connect\n");
-				if (!udc->transceiver)
-					pullup_enable(udc);
-				// if (driver->connect) call it
-			} else if (udc->gadget.speed != USB_SPEED_UNKNOWN) {
-				udc->gadget.speed = USB_SPEED_UNKNOWN;
-				if (!udc->transceiver)
-					pullup_disable(udc);
-				DBG("disconnect, gadget %s\n",
-					udc->driver->driver.name);
-				if (udc->driver->disconnect) {
-					spin_unlock(&udc->lock);
-					udc->driver->disconnect(&udc->gadget);
-					spin_lock(&udc->lock);
-				}
-			}
-			change &= ~UDC_ATT;
-		}
-
-		if (change & UDC_USB_RESET) {
-			if (devstat & UDC_USB_RESET) {
-				VDBG("RESET=1\n");
-			} else {
-				udc->gadget.speed = USB_SPEED_FULL;
-				INFO("USB reset done, gadget %s\n",
-					udc->driver->driver.name);
-				/* ep0 traffic is legal from now on */
-				UDC_IRQ_EN_REG = UDC_DS_CHG_IE | UDC_EP0_IE;
-			}
-			change &= ~UDC_USB_RESET;
-		}
-	}
-	if (change & UDC_SUS) {
-		if (udc->gadget.speed != USB_SPEED_UNKNOWN) {
-			// FIXME tell isp1301 to suspend/resume (?)
-			if (devstat & UDC_SUS) {
-				VDBG("suspend\n");
-				update_otg(udc);
-				/* HNP could be under way already */
-				if (udc->gadget.speed == USB_SPEED_FULL
-						&& udc->driver->suspend) {
-					spin_unlock(&udc->lock);
-					udc->driver->suspend(&udc->gadget);
-					spin_lock(&udc->lock);
-				}
-			} else {
-				VDBG("resume\n");
-				if (udc->gadget.speed == USB_SPEED_FULL
-						&& udc->driver->resume) {
-					spin_unlock(&udc->lock);
-					udc->driver->resume(&udc->gadget);
-					spin_lock(&udc->lock);
-				}
-			}
-		}
-		change &= ~UDC_SUS;
-	}
-	if (change & OTG_FLAGS) {
-		update_otg(udc);
-		change &= ~OTG_FLAGS;
-	}
-
-	change &= ~(UDC_CFG|UDC_DEF|UDC_ADD);
-	if (change)
-		VDBG("devstat %03x, ignore change %03x\n",
-			devstat,  change);
-
-	UDC_IRQ_SRC_REG = UDC_DS_CHG;
-}
-
-static irqreturn_t
-omap_udc_irq(int irq, void *_udc, struct pt_regs *r)
-{
-	struct omap_udc	*udc = _udc;
-	u16		irq_src;
-	irqreturn_t	status = IRQ_NONE;
-	unsigned long	flags;
-
-	spin_lock_irqsave(&udc->lock, flags);
-	irq_src = UDC_IRQ_SRC_REG;
-
-	/* Device state change (usb ch9 stuff) */
-	if (irq_src & UDC_DS_CHG) {
-		devstate_irq(_udc, irq_src);
-		status = IRQ_HANDLED;
-		irq_src &= ~UDC_DS_CHG;
-	}
-
-	/* EP0 control transfers */
-	if (irq_src & (UDC_EP0_RX|UDC_SETUP|UDC_EP0_TX)) {
-		ep0_irq(_udc, irq_src);
-		status = IRQ_HANDLED;
-		irq_src &= ~(UDC_EP0_RX|UDC_SETUP|UDC_EP0_TX);
-	}
-
-	/* DMA transfer completion */
-	if (use_dma && (irq_src & (UDC_TXN_DONE|UDC_RXN_CNT|UDC_RXN_EOT))) {
-		dma_irq(_udc, irq_src);
-		status = IRQ_HANDLED;
-		irq_src &= ~(UDC_TXN_DONE|UDC_RXN_CNT|UDC_RXN_EOT);
-	}
-
-	irq_src &= ~(UDC_SOF|UDC_EPN_TX|UDC_EPN_RX);
-	if (irq_src)
-		DBG("udc_irq, unhandled %03x\n", irq_src);
-	spin_unlock_irqrestore(&udc->lock, flags);
-
-	return status;
-}
-
-static irqreturn_t
-omap_udc_pio_irq(int irq, void *_dev, struct pt_regs *r)
-{
-	u16		epn_stat, irq_src;
-	irqreturn_t	status = IRQ_NONE;
-	struct omap_ep	*ep;
-	int		epnum;
-	struct omap_udc	*udc = _dev;
-	struct omap_req	*req;
-	unsigned long	flags;
-
-	spin_lock_irqsave(&udc->lock, flags);
-	epn_stat = UDC_EPN_STAT_REG;
-	irq_src = UDC_IRQ_SRC_REG;
-
-	/* handle OUT first, to avoid some wasteful NAKs */
-	if (irq_src & UDC_EPN_RX) {
-		epnum = (epn_stat >> 8) & 0x0f;
-		UDC_IRQ_SRC_REG = UDC_EPN_RX;
-		status = IRQ_HANDLED;
-		ep = &udc->ep[epnum];
-		ep->irqs++;
-
-		if (!list_empty(&ep->queue)) {
-			UDC_EP_NUM_REG = epnum | UDC_EP_SEL;
-			if ((UDC_STAT_FLG_REG & UDC_ACK)) {
-				int stat;
-				req = container_of(ep->queue.next,
-						struct omap_req, queue);
-				stat = read_fifo(ep, req);
-				// FIXME double buffered PIO OUT should work
-			}
-			UDC_EP_NUM_REG = epnum;
-		}
-	}
-
-	/* then IN transfers */
-	if (irq_src & UDC_EPN_TX) {
-		epnum = epn_stat & 0x0f;
-		UDC_IRQ_SRC_REG = UDC_EPN_TX;
-		status = IRQ_HANDLED;
-		ep = &udc->ep[16 + epnum];
-		ep->irqs++;
-		ep->ackwait = 0;
-
-		if (!list_empty(&ep->queue)) {
-			UDC_EP_NUM_REG = epnum | UDC_EP_DIR | UDC_EP_SEL;
-			if ((UDC_STAT_FLG_REG & UDC_ACK)) {
-				req = container_of(ep->queue.next,
-						struct omap_req, queue);
-				(void) write_fifo(ep, req);
-			}
-			UDC_EP_NUM_REG = epnum | UDC_EP_DIR;
-			/* 6 wait states before it'll tx */
-		}
-	}
-
-	spin_unlock_irqrestore(&udc->lock, flags);
-	return status;
-}
-
-#ifdef	USE_ISO
-static irqreturn_t
-omap_udc_iso_irq(int irq, void *_dev, struct pt_regs *r)
-{
-	struct omap_udc	*udc = _dev;
-	struct omap_ep	*ep;
-	int		pending = 0;
-	unsigned long	flags;
-
-	spin_lock_irqsave(&udc->lock, flags);
-
-	/* handle all non-DMA ISO transfers */
-	list_for_each_entry (ep, &udc->iso, iso) {
-		u16		stat;
-		struct omap_req	*req;
-
-		if (ep->has_dma || list_empty(&ep->queue))
-			continue;
-		req = list_entry(ep->queue.next, struct omap_req, queue);
-
-		use_ep(ep, UDC_EP_SEL);
-		stat = UDC_STAT_FLG_REG;
-
-		/* NOTE: like the other controller drivers, this isn't
-		 * currently reporting lost or damaged frames.
-		 */
-		if (ep->bEndpointAddress & USB_DIR_IN) {
-			if (stat & UDC_MISS_IN)
-				/* done(ep, req, -EPROTO) */;
-			else
-				write_fifo(ep, req);
-		} else {
-			int	status = 0;
-
-			if (stat & UDC_NO_RXPACKET)
-				status = -EREMOTEIO;
-			else if (stat & UDC_ISO_ERR)
-				status = -EILSEQ;
-			else if (stat & UDC_DATA_FLUSH)
-				status = -ENOSR;
-
-			if (status)
-				/* done(ep, req, status) */;
-			else
-				read_fifo(ep, req);
-		}
-		deselect_ep();
-		/* 6 wait states before next EP */
-
-		ep->irqs++;
-		if (!list_empty(&ep->queue))
-			pending = 1;
-	}
-	if (!pending)
-		UDC_IRQ_EN_REG &= ~UDC_SOF_IE;
-	UDC_IRQ_SRC_REG = UDC_SOF;
-
-	spin_unlock_irqrestore(&udc->lock, flags);
-	return IRQ_HANDLED;
-}
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-static struct omap_udc *udc;
-
-int usb_gadget_register_driver (struct usb_gadget_driver *driver)
-{
-	int		status = -ENODEV;
-	struct omap_ep	*ep;
-	unsigned long	flags;
-
-	/* basic sanity tests */
-	if (!udc)
-		return -ENODEV;
-	if (!driver
-			// FIXME if otg, check:  driver->is_otg
-			|| driver->speed < USB_SPEED_FULL
-			|| !driver->bind
-			|| !driver->unbind
-			|| !driver->setup)
-		return -EINVAL;
-
-	spin_lock_irqsave(&udc->lock, flags);
-	if (udc->driver) {
-		spin_unlock_irqrestore(&udc->lock, flags);
-		return -EBUSY;
-	}
-
-	/* reset state */
-	list_for_each_entry (ep, &udc->gadget.ep_list, ep.ep_list) {
-		ep->irqs = 0;
-		if (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC)
-			continue;
-		use_ep(ep, 0);
-		UDC_CTRL_REG = UDC_SET_HALT;
-	}
-	udc->ep0_pending = 0;
-	udc->ep[0].irqs = 0;
-	udc->softconnect = 1;
-
-	/* hook up the driver */
-	driver->driver.bus = 0;
-	udc->driver = driver;
-	udc->gadget.dev.driver = &driver->driver;
-	spin_unlock_irqrestore(&udc->lock, flags);
-
-	status = driver->bind (&udc->gadget);
-	if (status) {
-		DBG("bind to %s --> %d\n", driver->driver.name, status);
-		udc->gadget.dev.driver = 0;
-		udc->driver = 0;
-		goto done;
-	}
-	DBG("bound to driver %s\n", driver->driver.name);
-
-	UDC_IRQ_SRC_REG = UDC_IRQ_SRC_MASK;
-
-	/* connect to bus through transceiver */
-	if (udc->transceiver) {
-		status = otg_set_peripheral(udc->transceiver, &udc->gadget);
-		if (status < 0) {
-			ERR("can't bind to transceiver\n");
-			driver->unbind (&udc->gadget);
-			udc->gadget.dev.driver = 0;
-			udc->driver = 0;
-			goto done;
-		}
-	} else {
-		if (can_pullup(udc))
-			pullup_enable (udc);
-		else
-			pullup_disable (udc);
-	}
-
-done:
-	return status;
-}
-EXPORT_SYMBOL(usb_gadget_register_driver);
-
-int usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
-{
-	unsigned long	flags;
-	int		status = -ENODEV;
-
-	if (!udc)
-		return -ENODEV;
-	if (!driver || driver != udc->driver)
-		return -EINVAL;
-
-	if (udc->transceiver)
-		(void) otg_set_peripheral(udc->transceiver, 0);
-	else
-		pullup_disable(udc);
-
-	spin_lock_irqsave(&udc->lock, flags);
-	udc_quiesce(udc);
-	spin_unlock_irqrestore(&udc->lock, flags);
-
-	driver->unbind(&udc->gadget);
-	udc->gadget.dev.driver = 0;
-	udc->driver = 0;
-
-
-	DBG("unregistered driver '%s'\n", driver->driver.name);
-	return status;
-}
-EXPORT_SYMBOL(usb_gadget_unregister_driver);
-
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef CONFIG_USB_OMAP_PROC
-
-#include <linux/seq_file.h>
-
-static const char proc_filename[] = "driver/udc";
-
-#define FOURBITS "%s%s%s%s"
-#define EIGHTBITS FOURBITS FOURBITS
-
-static void proc_ep_show(struct seq_file *s, struct omap_ep *ep)
-{
-	u16		stat_flg;
-	struct omap_req	*req;
-	char		buf[20];
-
-	use_ep(ep, 0);
-
-	if (use_dma && ep->has_dma)
-		snprintf(buf, sizeof buf, "(%cxdma%d lch%d) ",
-			(ep->bEndpointAddress & USB_DIR_IN) ? 't' : 'r',
-			ep->dma_channel - 1, ep->lch);
-	else
-		buf[0] = 0;
-
-	stat_flg = UDC_STAT_FLG_REG;
-	seq_printf(s,
-		"\n%s %sirqs %ld stat %04x " EIGHTBITS FOURBITS "%s\n",
-		ep->name, buf, ep->irqs, stat_flg,
-		(stat_flg & UDC_NO_RXPACKET) ? "no_rxpacket " : "",
-		(stat_flg & UDC_MISS_IN) ? "miss_in " : "",
-		(stat_flg & UDC_DATA_FLUSH) ? "data_flush " : "",
-		(stat_flg & UDC_ISO_ERR) ? "iso_err " : "",
-		(stat_flg & UDC_ISO_FIFO_EMPTY) ? "iso_fifo_empty " : "",
-		(stat_flg & UDC_ISO_FIFO_FULL) ? "iso_fifo_full " : "",
-		(stat_flg & UDC_EP_HALTED) ? "HALT " : "",
-		(stat_flg & UDC_STALL) ? "STALL " : "",
-		(stat_flg & UDC_NAK) ? "NAK " : "",
-		(stat_flg & UDC_ACK) ? "ACK " : "",
-		(stat_flg & UDC_FIFO_EN) ? "fifo_en " : "",
-		(stat_flg & UDC_NON_ISO_FIFO_EMPTY) ? "fifo_empty " : "",
-		(stat_flg & UDC_NON_ISO_FIFO_FULL) ? "fifo_full " : "");
-
-	if (list_empty (&ep->queue))
-		seq_printf(s, "\t(queue empty)\n");
-	else
-		list_for_each_entry (req, &ep->queue, queue)
-			seq_printf(s, "\treq %p len %d/%d buf %p\n",
-					&req->req, req->req.actual,
-					req->req.length, req->req.buf);
-}
-
-static char *trx_mode(unsigned m)
-{
-	switch (m) {
-	case 3:
-	case 0:		return "6wire";
-	case 1:		return "4wire";
-	case 2:		return "3wire";
-	default:	return "unknown";
-	}
-}
-
-static int proc_udc_show(struct seq_file *s, void *_)
-{
-	u32		tmp;
-	struct omap_ep	*ep;
-	unsigned long	flags;
-
-	spin_lock_irqsave(&udc->lock, flags);
-
-	seq_printf(s, "%s, version: " DRIVER_VERSION
-#ifdef	USE_ISO
-		" (iso)"
-#endif
-		"%s\n",
-		driver_desc,
-		use_dma ?  " (dma)" : "");
-
-	tmp = UDC_REV_REG & 0xff; 
-	seq_printf(s,
-		"UDC rev %d.%d, OTG rev %d.%d, fifo mode %d, gadget %s\n"
-		"hmc %d, transceiver %08x %s\n",
-		tmp >> 4, tmp & 0xf,
-		OTG_REV_REG >> 4, OTG_REV_REG & 0xf,
-		fifo_mode,
-		udc->driver ? udc->driver->driver.name : "(none)",
-		HMC, USB_TRANSCEIVER_CTRL_REG,
-		udc->transceiver ? udc->transceiver->label : "");
-
-	/* OTG controller registers */
-	tmp = OTG_SYSCON_1_REG;
-	seq_printf(s, "otg_syscon1 %08x usb2 %s, usb1 %s, usb0 %s,"
-			FOURBITS "\n", tmp,
-		trx_mode(USB2_TRX_MODE(tmp)),
-		trx_mode(USB1_TRX_MODE(tmp)),
-		trx_mode(USB0_TRX_MODE(tmp)),
-		(tmp & OTG_IDLE_EN) ? " !otg" : "",
-		(tmp & HST_IDLE_EN) ? " !host" : "",
-		(tmp & DEV_IDLE_EN) ? " !dev" : "",
-		(tmp & OTG_RESET_DONE) ? " reset_done" : " reset_active");
-	tmp = OTG_SYSCON_2_REG;
-	seq_printf(s, "otg_syscon2 %08x%s" EIGHTBITS
-			" b_ase_brst=%d hmc=%d\n", tmp,
-		(tmp & OTG_EN) ? " otg_en" : "",
-		(tmp & USBX_SYNCHRO) ? " synchro" : "",
-		// much more SRP stuff
-		(tmp & SRP_DATA) ? " srp_data" : "",
-		(tmp & SRP_VBUS) ? " srp_vbus" : "",
-		(tmp & OTG_PADEN) ? " otg_paden" : "",
-		(tmp & HMC_PADEN) ? " hmc_paden" : "",
-		(tmp & UHOST_EN) ? " uhost_en" : "",
-		(tmp & HMC_TLLSPEED) ? " tllspeed" : "",
-		(tmp & HMC_TLLATTACH) ? " tllattach" : "",
-		B_ASE_BRST(tmp),
-		OTG_HMC(tmp));
-	tmp = OTG_CTRL_REG;
-	seq_printf(s, "otg_ctrl    %06x" EIGHTBITS EIGHTBITS "%s\n", tmp,
-		(tmp & OTG_ASESSVLD) ? " asess" : "",
-		(tmp & OTG_BSESSEND) ? " bsess_end" : "",
-		(tmp & OTG_BSESSVLD) ? " bsess" : "",
-		(tmp & OTG_VBUSVLD) ? " vbus" : "",
-		(tmp & OTG_ID) ? " id" : "",
-		(tmp & OTG_DRIVER_SEL) ? " DEVICE" : " HOST",
-		(tmp & OTG_A_SETB_HNPEN) ? " a_setb_hnpen" : "",
-		(tmp & OTG_A_BUSREQ) ? " a_bus" : "",
-		(tmp & OTG_B_HNPEN) ? " b_hnpen" : "",
-		(tmp & OTG_B_BUSREQ) ? " b_bus" : "",
-		(tmp & OTG_BUSDROP) ? " busdrop" : "",
-		(tmp & OTG_PULLDOWN) ? " down" : "",
-		(tmp & OTG_PULLUP) ? " up" : "",
-		(tmp & OTG_DRV_VBUS) ? " drv" : "",
-		(tmp & OTG_PD_VBUS) ? " pd_vb" : "",
-		(tmp & OTG_PU_VBUS) ? " pu_vb" : "",
-		(tmp & OTG_PU_ID) ? " pu_id" : ""
-		);
-	tmp = OTG_IRQ_EN_REG;
-	seq_printf(s, "otg_irq_en  %04x" "\n", tmp);
-	tmp = OTG_IRQ_SRC_REG;
-	seq_printf(s, "otg_irq_src %04x" "\n", tmp);
-	tmp = OTG_OUTCTRL_REG;
-	seq_printf(s, "otg_outctrl %04x" "\n", tmp);
-	tmp = OTG_TEST_REG;
-	seq_printf(s, "otg_test    %04x" "\n", tmp);
-
-	tmp = UDC_SYSCON1_REG;
-	seq_printf(s, "\nsyscon1     %04x" EIGHTBITS "\n", tmp,
-		(tmp & UDC_CFG_LOCK) ? " cfg_lock" : "",
-		(tmp & UDC_DATA_ENDIAN) ? " data_endian" : "",
-		(tmp & UDC_DMA_ENDIAN) ? " dma_endian" : "",
-		(tmp & UDC_NAK_EN) ? " nak" : "",
-		(tmp & UDC_AUTODECODE_DIS) ? " autodecode_dis" : "",
-		(tmp & UDC_SELF_PWR) ? " self_pwr" : "",
-		(tmp & UDC_SOFF_DIS) ? " soff_dis" : "",
-		(tmp & UDC_PULLUP_EN) ? " PULLUP" : "");
-	// syscon2 is write-only
-
-	/* UDC controller registers */
-	if (!(tmp & UDC_PULLUP_EN)) {
-		seq_printf(s, "(suspended)\n");
-		spin_unlock_irqrestore(&udc->lock, flags);
-		return 0;
-	}
-
-	tmp = UDC_DEVSTAT_REG;
-	seq_printf(s, "devstat     %04x" EIGHTBITS "%s%s\n", tmp,
-		(tmp & UDC_B_HNP_ENABLE) ? " b_hnp" : "",
-		(tmp & UDC_A_HNP_SUPPORT) ? " a_hnp" : "",
-		(tmp & UDC_A_ALT_HNP_SUPPORT) ? " a_alt_hnp" : "",
-		(tmp & UDC_R_WK_OK) ? " r_wk_ok" : "",
-		(tmp & UDC_USB_RESET) ? " usb_reset" : "",
-		(tmp & UDC_SUS) ? " SUS" : "",
-		(tmp & UDC_CFG) ? " CFG" : "",
-		(tmp & UDC_ADD) ? " ADD" : "",
-		(tmp & UDC_DEF) ? " DEF" : "",
-		(tmp & UDC_ATT) ? " ATT" : "");
-	seq_printf(s, "sof         %04x\n", UDC_SOF_REG);
-	tmp = UDC_IRQ_EN_REG;
-	seq_printf(s, "irq_en      %04x" FOURBITS "%s\n", tmp,
-		(tmp & UDC_SOF_IE) ? " sof" : "",
-		(tmp & UDC_EPN_RX_IE) ? " epn_rx" : "",
-		(tmp & UDC_EPN_TX_IE) ? " epn_tx" : "",
-		(tmp & UDC_DS_CHG_IE) ? " ds_chg" : "",
-		(tmp & UDC_EP0_IE) ? " ep0" : "");
-	tmp = UDC_IRQ_SRC_REG;
-	seq_printf(s, "irq_src     %04x" EIGHTBITS "%s%s\n", tmp,
-		(tmp & UDC_TXN_DONE) ? " txn_done" : "",
-		(tmp & UDC_RXN_CNT) ? " rxn_cnt" : "",
-		(tmp & UDC_RXN_EOT) ? " rxn_eot" : "",
-		(tmp & UDC_SOF) ? " sof" : "",
-		(tmp & UDC_EPN_RX) ? " epn_rx" : "",
-		(tmp & UDC_EPN_TX) ? " epn_tx" : "",
-		(tmp & UDC_DS_CHG) ? " ds_chg" : "",
-		(tmp & UDC_SETUP) ? " setup" : "",
-		(tmp & UDC_EP0_RX) ? " ep0out" : "",
-		(tmp & UDC_EP0_TX) ? " ep0in" : "");
-	if (use_dma) {
-		unsigned i;
-
-		tmp = UDC_DMA_IRQ_EN_REG;
-		seq_printf(s, "dma_irq_en  %04x%s" EIGHTBITS "\n", tmp,
-			(tmp & UDC_TX_DONE_IE(3)) ? " tx2_done" : "",
-			(tmp & UDC_RX_CNT_IE(3)) ? " rx2_cnt" : "",
-			(tmp & UDC_RX_EOT_IE(3)) ? " rx2_eot" : "",
-
-			(tmp & UDC_TX_DONE_IE(2)) ? " tx1_done" : "",
-			(tmp & UDC_RX_CNT_IE(2)) ? " rx1_cnt" : "",
-			(tmp & UDC_RX_EOT_IE(2)) ? " rx1_eot" : "",
-
-			(tmp & UDC_TX_DONE_IE(1)) ? " tx0_done" : "",
-			(tmp & UDC_RX_CNT_IE(1)) ? " rx0_cnt" : "",
-			(tmp & UDC_RX_EOT_IE(1)) ? " rx0_eot" : "");
-
-		tmp = UDC_RXDMA_CFG_REG;
-		seq_printf(s, "rxdma_cfg   %04x\n", tmp);
-		if (tmp) {
-			for (i = 0; i < 3; i++) {
-				if ((tmp & (0x0f << (i * 4))) == 0)
-					continue;
-				seq_printf(s, "rxdma[%d]    %04x\n", i,
-						UDC_RXDMA_REG(i + 1));
-			}
-		}
-		tmp = UDC_TXDMA_CFG_REG;
-		seq_printf(s, "txdma_cfg   %04x\n", tmp);
-		if (tmp) {
-			for (i = 0; i < 3; i++) {
-				if (!(tmp & (0x0f << (i * 4))))
-					continue;
-				seq_printf(s, "txdma[%d]    %04x\n", i,
-						UDC_TXDMA_REG(i + 1));
-			}
-		}
-	}
-
-	tmp = UDC_DEVSTAT_REG;
-	if (tmp & UDC_ATT) {
-		proc_ep_show(s, &udc->ep[0]);
-		if (tmp & UDC_ADD) {
-			list_for_each_entry (ep, &udc->gadget.ep_list,
-					ep.ep_list) {
-				if (ep->desc)
-					proc_ep_show(s, ep);
-			}
-		}
-	}
-	spin_unlock_irqrestore(&udc->lock, flags);
-	return 0;
-}
-
-static int proc_udc_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, proc_udc_show, 0);
-}
-
-static struct file_operations proc_ops = {
-	.open		= proc_udc_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static void create_proc_file(void)
-{
-	struct proc_dir_entry *pde;
-
-	pde = create_proc_entry (proc_filename, 0, NULL);
-	if (pde)
-		pde->proc_fops = &proc_ops;
-}
-
-static void remove_proc_file(void)
-{
-	remove_proc_entry(proc_filename, 0);
-}
-
-#else
-
-static inline void create_proc_file(void) {}
-static inline void remove_proc_file(void) {}
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-/* Before this controller can enumerate, we need to pick an endpoint
- * configuration, or "fifo_mode"  That involves allocating 2KB of packet
- * buffer space among the endpoints we'll be operating.
- */
-static unsigned __init
-omap_ep_setup(char *name, u8 addr, u8 type,
-		unsigned buf, unsigned maxp, int dbuf)
-{
-	struct omap_ep	*ep;
-	u16		epn_rxtx = 0;
-
-	/* OUT endpoints first, then IN */
-	ep = &udc->ep[addr & 0xf];
-	if (addr & USB_DIR_IN)
-		ep += 16;
-
-	/* in case of ep init table bugs */
-	BUG_ON(ep->name[0]);
-
-	/* chip setup ... bit values are same for IN, OUT */
-	if (type == USB_ENDPOINT_XFER_ISOC) {
-		switch (maxp) {
-		case 8:		epn_rxtx = 0 << 12; break;
-		case 16:	epn_rxtx = 1 << 12; break;
-		case 32:	epn_rxtx = 2 << 12; break;
-		case 64:	epn_rxtx = 3 << 12; break;
-		case 128:	epn_rxtx = 4 << 12; break;
-		case 256:	epn_rxtx = 5 << 12; break;
-		case 512:	epn_rxtx = 6 << 12; break;
-		default:	BUG();
-		}
-		epn_rxtx |= UDC_EPN_RX_ISO;
-		dbuf = 1;
-	} else {
-		/* pio-out could potentially double-buffer,
-		 * as can (should!) DMA-IN
-		 */
-		if (!use_dma || (addr & USB_DIR_IN))
-			dbuf = 0;
-
-		switch (maxp) {
-		case 8:		epn_rxtx = 0 << 12; break;
-		case 16:	epn_rxtx = 1 << 12; break;
-		case 32:	epn_rxtx = 2 << 12; break;
-		case 64:	epn_rxtx = 3 << 12; break;
-		default:	BUG();
-		}
-		if (dbuf && addr)
-			epn_rxtx |= UDC_EPN_RX_DB;
-	}
-	if (addr)
-		epn_rxtx |= UDC_EPN_RX_VALID;
-	BUG_ON(buf & 0x07);
-	epn_rxtx |= buf >> 3;
-
-	DBG("%s addr %02x rxtx %04x maxp %d%s buf %d\n",
-		name, addr, epn_rxtx, maxp, dbuf ? "x2" : "", buf);
-
-	if (addr & USB_DIR_IN)
-		UDC_EP_TX_REG(addr & 0xf) = epn_rxtx;
-	else
-		UDC_EP_RX_REG(addr) = epn_rxtx;
-
-	/* next endpoint's buffer starts after this one's */
-	buf += maxp;
-	if (dbuf)
-		buf += maxp;
-	BUG_ON(buf > 2048);
-
-	/* set up driver data structures */
-	BUG_ON(strlen(name) >= sizeof ep->name);
-	strlcpy(ep->name, name, sizeof ep->name);
-	INIT_LIST_HEAD(&ep->queue);
-	INIT_LIST_HEAD(&ep->iso);
-	ep->bEndpointAddress = addr;
-	ep->bmAttributes = type;
-	ep->double_buf = dbuf;
-	ep->udc = udc; 
-
-	ep->ep.name = ep->name;
-	ep->ep.ops = &omap_ep_ops;
-	ep->ep.maxpacket = ep->maxpacket = maxp;
-	list_add_tail (&ep->ep.ep_list, &udc->gadget.ep_list);
-
-	return buf;
-}
-
-static void omap_udc_release(struct device *dev)
-{
-	complete(udc->done);
-	kfree (udc);
-	udc = 0;
-}
-
-static int __init
-omap_udc_setup(struct platform_device *odev, struct otg_transceiver *xceiv)
-{
-	unsigned	tmp, buf;
-
-	/* abolish any previous hardware state */
-	UDC_SYSCON1_REG = 0;
-	UDC_IRQ_EN_REG = 0;
-	UDC_IRQ_SRC_REG = UDC_IRQ_SRC_MASK;
-	UDC_DMA_IRQ_EN_REG = 0;
-	UDC_RXDMA_CFG_REG = 0;
-	UDC_TXDMA_CFG_REG = 0;
-
-	/* UDC_PULLUP_EN gates the chip clock */
-	// OTG_SYSCON_1_REG |= DEV_IDLE_EN;
-
-	udc = kmalloc (sizeof *udc, SLAB_KERNEL);
-	if (!udc)
-		return -ENOMEM;
-
-	memset(udc, 0, sizeof *udc);
-	spin_lock_init (&udc->lock);
-
-	udc->gadget.ops = &omap_gadget_ops;
-	udc->gadget.ep0 = &udc->ep[0].ep;
-	INIT_LIST_HEAD(&udc->gadget.ep_list);
-	INIT_LIST_HEAD(&udc->iso);
-	udc->gadget.speed = USB_SPEED_UNKNOWN;
-	udc->gadget.name = driver_name;
-
-	device_initialize(&udc->gadget.dev);
-	strcpy (udc->gadget.dev.bus_id, "gadget");
-	udc->gadget.dev.release = omap_udc_release;
-	udc->gadget.dev.parent = &odev->dev;
-	if (use_dma)
-		udc->gadget.dev.dma_mask = odev->dev.dma_mask;
-
-	udc->transceiver = xceiv;
-
-	/* ep0 is special; put it right after the SETUP buffer */
-	buf = omap_ep_setup("ep0", 0, USB_ENDPOINT_XFER_CONTROL,
-			8 /* after SETUP */, 64 /* maxpacket */, 0);
-	list_del_init(&udc->ep[0].ep.ep_list);
-
-	/* initially disable all non-ep0 endpoints */
-	for (tmp = 1; tmp < 15; tmp++) {
-		UDC_EP_RX_REG(tmp) = 0;
-		UDC_EP_TX_REG(tmp) = 0;
-	}
-
-#define OMAP_BULK_EP(name,addr) \
-	buf = omap_ep_setup(name "-bulk", addr, \
-			USB_ENDPOINT_XFER_BULK, buf, 64, 1);
-#define OMAP_INT_EP(name,addr, maxp) \
-	buf = omap_ep_setup(name "-int", addr, \
-			USB_ENDPOINT_XFER_INT, buf, maxp, 0);
-#define OMAP_ISO_EP(name,addr, maxp) \
-	buf = omap_ep_setup(name "-iso", addr, \
-			USB_ENDPOINT_XFER_ISOC, buf, maxp, 1);
-
-	switch (fifo_mode) {
-	case 0:
-		OMAP_BULK_EP("ep1in",  USB_DIR_IN  | 1);
-		OMAP_BULK_EP("ep2out", USB_DIR_OUT | 2);
-		OMAP_INT_EP("ep3in",   USB_DIR_IN  | 3, 16);
-		break;
-	case 1:
-		OMAP_BULK_EP("ep1in",  USB_DIR_IN  | 1);
-		OMAP_BULK_EP("ep2out", USB_DIR_OUT | 2);
-		OMAP_BULK_EP("ep3in",  USB_DIR_IN  | 3);
-		OMAP_BULK_EP("ep4out", USB_DIR_OUT | 4);
-
-		OMAP_BULK_EP("ep5in",  USB_DIR_IN  | 5);
-		OMAP_BULK_EP("ep5out", USB_DIR_OUT | 5);
-		OMAP_BULK_EP("ep6in",  USB_DIR_IN  | 6);
-		OMAP_BULK_EP("ep6out", USB_DIR_OUT | 6);
-
-		OMAP_BULK_EP("ep7in",  USB_DIR_IN  | 7);
-		OMAP_BULK_EP("ep7out", USB_DIR_OUT | 7);
-		OMAP_BULK_EP("ep8in",  USB_DIR_IN  | 8);
-		OMAP_BULK_EP("ep8out", USB_DIR_OUT | 8);
-
-		OMAP_INT_EP("ep9in",   USB_DIR_IN  | 9, 16);
-		OMAP_INT_EP("ep10out", USB_DIR_IN  | 10, 16);
-		OMAP_INT_EP("ep11in",  USB_DIR_IN  | 9, 16);
-		OMAP_INT_EP("ep12out", USB_DIR_IN  | 10, 16);
-		break;
-
-#ifdef	USE_ISO
-	case 2:			/* mixed iso/bulk */
-		OMAP_ISO_EP("ep1in",   USB_DIR_IN  | 1, 256);
-		OMAP_ISO_EP("ep2out",  USB_DIR_OUT | 2, 256);
-		OMAP_ISO_EP("ep3in",   USB_DIR_IN  | 3, 128);
-		OMAP_ISO_EP("ep4out",  USB_DIR_OUT | 4, 128);
-
-		OMAP_INT_EP("ep5in",   USB_DIR_IN  | 5, 16);
-
-		OMAP_BULK_EP("ep6in",  USB_DIR_IN  | 6);
-		OMAP_BULK_EP("ep7out", USB_DIR_OUT | 7);
-		OMAP_INT_EP("ep8in",   USB_DIR_IN  | 8, 16);
-		break;
-	case 3:			/* mixed bulk/iso */
-		OMAP_BULK_EP("ep1in",  USB_DIR_IN  | 1);
-		OMAP_BULK_EP("ep2out", USB_DIR_OUT | 2);
-		OMAP_INT_EP("ep3in",   USB_DIR_IN  | 3, 16);
-
-		OMAP_BULK_EP("ep4in",  USB_DIR_IN  | 4);
-		OMAP_BULK_EP("ep5out", USB_DIR_OUT | 5);
-		OMAP_INT_EP("ep6in",   USB_DIR_IN  | 6, 16);
-
-		OMAP_ISO_EP("ep7in",   USB_DIR_IN  | 7, 256);
-		OMAP_ISO_EP("ep8out",  USB_DIR_OUT | 8, 256);
-		OMAP_INT_EP("ep9in",   USB_DIR_IN  | 9, 16);
-		break;
-#endif
-
-	/* add more modes as needed */
-
-	default:
-		ERR("unsupported fifo_mode #%d\n", fifo_mode);
-		return -ENODEV;
-	}
-	UDC_SYSCON1_REG = UDC_CFG_LOCK|UDC_SELF_PWR;
-	INFO("fifo mode %d, %d bytes not used\n", fifo_mode, 2048 - buf);
-	return 0;
-}
-
-static int __init omap_udc_probe(struct device *dev)
-{
-	struct platform_device	*odev = to_platform_device(dev);
-	int			status = -ENODEV;
-	int			hmc;
-	struct otg_transceiver	*xceiv = 0;
-	const char		*type = 0;
-	struct omap_usb_config	*config = dev->platform_data;
-
-	/* NOTE:  "knows" the order of the resources! */
-	if (!request_mem_region(odev->resource[0].start, 
-			odev->resource[0].end - odev->resource[0].start + 1,
-			driver_name)) {
-		DBG("request_mem_region failed\n");
-		return -EBUSY;
-	}
-
-	INFO("OMAP UDC rev %d.%d, OTG rev %d.%d, %s receptacle\n",
-		UDC_REV_REG >> 4, UDC_REV_REG & 0xf,
-		OTG_REV_REG >> 4, OTG_REV_REG & 0xf,
-		config->otg ? "Mini-AB" : "B/Mini-B");
-
-	/* use the mode given to us by board init code */
-	hmc = HMC;
-	switch (hmc) {
-	case 3:
-	case 11:
-	case 19:
-	case 25:
-		xceiv = otg_get_transceiver();
-		if (!xceiv) {
-			DBG("external transceiver not registered!\n");
-			goto cleanup0;
-		}
-		type = xceiv->label;
-		break;
-	case 0:			/* POWERUP DEFAULT == 0 */
-	case 4:
-	case 12:
-	case 20:
-		type = "INTEGRATED";
-		break;
-	case 21:			/* internal loopback */
-		type = "(loopback)";
-		break;
-	case 14:			/* transceiverless */
-		type = "(none)";
-		break;
-
-	default:
-		ERR("unrecognized UDC HMC mode %d\n", hmc);
-		return -ENODEV;
-	}
-	INFO("hmc mode %d, transceiver %s\n", hmc, type);
-
-	/* a "gadget" abstracts/virtualizes the controller */
-	status = omap_udc_setup(odev, xceiv);
-	if (status) {
-		goto cleanup0;
-	}
-	xceiv = 0;
-	// "udc" is now valid
-	pullup_disable(udc);
-	udc->gadget.is_otg = (config->otg != 0);
-
-	/* USB general purpose IRQ:  ep0, state changes, dma, etc */
-	status = request_irq(odev->resource[1].start, omap_udc_irq,
-			SA_SAMPLE_RANDOM, driver_name, udc);
-	if (status != 0) {
-		ERR( "can't get irq %ld, err %d\n",
-			odev->resource[1].start, status);
-		goto cleanup1;
-	}
-
-	/* USB "non-iso" IRQ (PIO for all but ep0) */
-	status = request_irq(odev->resource[2].start, omap_udc_pio_irq,
-			SA_SAMPLE_RANDOM, "omap_udc pio", udc);
-	if (status != 0) {
-		ERR( "can't get irq %ld, err %d\n",
-			odev->resource[2].start, status);
-		goto cleanup2;
-	}
-#ifdef	USE_ISO
-	status = request_irq(odev->resource[3].start, omap_udc_iso_irq,
-			SA_INTERRUPT, "omap_udc iso", udc);
-	if (status != 0) {
-		ERR("can't get irq %ld, err %d\n",
-			odev->resource[3].start, status);
-		goto cleanup3;
-	}
-#endif
-
-	create_proc_file();
-	device_add(&udc->gadget.dev);
-	return 0;
-
-#ifdef	USE_ISO
-cleanup3:
-	free_irq(odev->resource[2].start, udc);
-#endif
-
-cleanup2:
-	free_irq(odev->resource[1].start, udc);
-
-cleanup1:
-	kfree (udc);
-	udc = 0;
-
-cleanup0:
-	if (xceiv)
-		put_device(xceiv->dev);
-	release_mem_region(odev->resource[0].start,
-			odev->resource[0].end - odev->resource[0].start + 1);
-	return status;
-}
-
-static int __exit omap_udc_remove(struct device *dev)
-{
-	struct platform_device	*odev = to_platform_device(dev);
-	DECLARE_COMPLETION(done);
-
-	if (!udc)
-		return -ENODEV;
-
-	udc->done = &done;
-
-	pullup_disable(udc);
-	if (udc->transceiver) {
-		put_device(udc->transceiver->dev);
-		udc->transceiver = 0;
-	}
-	UDC_SYSCON1_REG = 0;
-
-	remove_proc_file();
-
-#ifdef	USE_ISO
-	free_irq(odev->resource[3].start, udc);
-#endif
-	free_irq(odev->resource[2].start, udc);
-	free_irq(odev->resource[1].start, udc);
-
-	release_mem_region(odev->resource[0].start,
-			odev->resource[0].end - odev->resource[0].start + 1);
-
-	device_unregister(&udc->gadget.dev);
-	wait_for_completion(&done);
-
-	return 0;
-}
-
-/* suspend/resume/wakeup from sysfs (echo > power/state) */
-
-static int omap_udc_suspend(struct device *dev, u32 state, u32 level)
-{
-	if (level != 0)
-		return 0;
-
-	DBG("suspend, state %d\n", state);
-	omap_pullup(&udc->gadget, 0);
-	udc->gadget.dev.power.power_state = 3;
-	udc->gadget.dev.parent->power.power_state = 3;
-	return 0;
-}
-
-static int omap_udc_resume(struct device *dev, u32 level)
-{
-	if (level != 0)
-		return 0;
-
-	DBG("resume + wakeup/SRP\n");
-	udc->gadget.dev.parent->power.power_state = 0;
-	udc->gadget.dev.power.power_state = 0;
-	omap_pullup(&udc->gadget, 1);
-
-	/* maybe the host would enumerate us if we nudged it */
-	msleep(100);
-	return omap_wakeup(&udc->gadget);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static struct device_driver udc_driver = {
-	.name		= (char *) driver_name,
-	.bus		= &platform_bus_type,
-	.probe		= omap_udc_probe,
-	.remove		= __exit_p(omap_udc_remove),
-	.suspend	= omap_udc_suspend,
-	.resume		= omap_udc_resume,
-};
-
-static int __init udc_init(void)
-{
-	/* should work on many OMAP systems with at most minor changes,
-	 * but the 1510 doesn't have an OTG controller.
-	 */
-	if (cpu_is_omap1510()) {
-		DBG("no OMAP1510 support yet\n");
-		return -ENODEV;
-	}
-	INFO("%s, version: " DRIVER_VERSION "%s\n", driver_desc,
-		use_dma ?  " (dma)" : "");
-	return driver_register(&udc_driver);
-}
-module_init(udc_init);
-
-static void __exit udc_exit(void)
-{
-	driver_unregister(&udc_driver);
-}
-module_exit(udc_exit);
-
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
-
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/omap_udc.h linuxppc-2.6.9-dream/drivers/usb/gadget/omap_udc.h
--- linuxppc-2.6.9/drivers/usb/gadget/omap_udc.h	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/omap_udc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,199 +0,0 @@
-/*
- * omap_udc.h -- for omap 3.2 udc, with OTG support
- *
- * 2004 (C) Texas Instruments, Inc.
- * 2004 (C) David Brownell
- */
-
-/*
- * USB device/endpoint management registers
- */
-#define UDC_REG(offset)              __REG16(UDC_BASE + (offset))
-
-#define	UDC_REV_REG			UDC_REG(0x0)	/* Revision */
-#define	UDC_EP_NUM_REG			UDC_REG(0x4)	/* Which endpoint */
-#	define	UDC_SETUP_SEL		(1 << 6)
-#	define	UDC_EP_SEL		(1 << 5)
-#	define	UDC_EP_DIR		(1 << 4)
-	/* low 4 bits for endpoint number */
-#define	UDC_DATA_REG			UDC_REG(0x08)	/* Endpoint FIFO */
-#define	UDC_CTRL_REG			UDC_REG(0x0C)	/* Endpoint control */
-#	define	UDC_CLR_HALT		(1 << 7)
-#	define	UDC_SET_HALT		(1 << 6)
-#	define	UDC_SET_FIFO_EN		(1 << 2)
-#	define	UDC_CLR_EP		(1 << 1)
-#	define	UDC_RESET_EP		(1 << 0)
-#define	UDC_STAT_FLG_REG		UDC_REG(0x10)	/* Endpoint status */
-#	define	UDC_NO_RXPACKET		(1 << 15)
-#	define	UDC_MISS_IN		(1 << 14)
-#	define	UDC_DATA_FLUSH		(1 << 13)
-#	define	UDC_ISO_ERR		(1 << 12)
-#	define	UDC_ISO_FIFO_EMPTY	(1 << 9)
-#	define	UDC_ISO_FIFO_FULL	(1 << 8)
-#	define	UDC_EP_HALTED		(1 << 6)
-#	define	UDC_STALL		(1 << 5)
-#	define	UDC_NAK			(1 << 4)
-#	define	UDC_ACK			(1 << 3)
-#	define	UDC_FIFO_EN		(1 << 2)
-#	define	UDC_NON_ISO_FIFO_EMPTY	(1 << 1)
-#	define	UDC_NON_ISO_FIFO_FULL	(1 << 0)
-#define	UDC_RXFSTAT_REG			UDC_REG(0x14)	/* OUT bytecount */
-#define	UDC_SYSCON1_REG			UDC_REG(0x18)	/* System config 1 */
-#	define	UDC_CFG_LOCK		(1 << 8)
-#	define	UDC_DATA_ENDIAN		(1 << 7)
-#	define	UDC_DMA_ENDIAN		(1 << 6)
-#	define	UDC_NAK_EN		(1 << 4)
-#	define	UDC_AUTODECODE_DIS	(1 << 3)
-#	define	UDC_SELF_PWR		(1 << 2)
-#	define	UDC_SOFF_DIS		(1 << 1)
-#	define	UDC_PULLUP_EN		(1 << 0)
-#define	UDC_SYSCON2_REG			UDC_REG(0x1C)	/* System config 2 */
-#	define	UDC_RMT_WKP		(1 << 6)
-#	define	UDC_STALL_CMD		(1 << 5)
-#	define	UDC_DEV_CFG		(1 << 3)
-#	define	UDC_CLR_CFG		(1 << 2)
-#define	UDC_DEVSTAT_REG			UDC_REG(0x20)	/* Device status */
-#	define	UDC_B_HNP_ENABLE	(1 << 9)
-#	define	UDC_A_HNP_SUPPORT	(1 << 8)
-#	define	UDC_A_ALT_HNP_SUPPORT	(1 << 7)
-#	define	UDC_R_WK_OK		(1 << 6)
-#	define	UDC_USB_RESET		(1 << 5)
-#	define	UDC_SUS			(1 << 4)
-#	define	UDC_CFG			(1 << 3)
-#	define	UDC_ADD			(1 << 2)
-#	define	UDC_DEF			(1 << 1)
-#	define	UDC_ATT			(1 << 0)
-#define	UDC_SOF_REG			UDC_REG(0x24)	/* Start of frame */
-#	define	UDC_FT_LOCK		(1 << 12)
-#	define	UDC_TS_OK		(1 << 11)
-#	define	UDC_TS			0x03ff
-#define	UDC_IRQ_EN_REG			UDC_REG(0x28)	/* Interrupt enable */
-#	define	UDC_SOF_IE		(1 << 7)
-#	define	UDC_EPN_RX_IE		(1 << 5)
-#	define	UDC_EPN_TX_IE		(1 << 4)
-#	define	UDC_DS_CHG_IE		(1 << 3)
-#	define	UDC_EP0_IE		(1 << 0)
-#define	UDC_DMA_IRQ_EN_REG		UDC_REG(0x2C)	/* DMA irq enable */
-	/* rx/tx dma channels numbered 1-3 not 0-2 */
-#	define	UDC_TX_DONE_IE(n)	(1 << (4 * (n) - 2))
-#	define	UDC_RX_CNT_IE(n)	(1 << (4 * (n) - 3))
-#	define	UDC_RX_EOT_IE(n)	(1 << (4 * (n) - 4))
-#define	UDC_IRQ_SRC_REG			UDC_REG(0x30)	/* Interrupt source */
-#	define	UDC_TXN_DONE		(1 << 10)
-#	define	UDC_RXN_CNT		(1 << 9)
-#	define	UDC_RXN_EOT		(1 << 8)
-#	define	UDC_SOF			(1 << 7)
-#	define	UDC_EPN_RX		(1 << 5)
-#	define	UDC_EPN_TX		(1 << 4)
-#	define	UDC_DS_CHG		(1 << 3)
-#	define	UDC_SETUP		(1 << 2)
-#	define	UDC_EP0_RX		(1 << 1)
-#	define	UDC_EP0_TX		(1 << 0)
-#	define	UDC_IRQ_SRC_MASK	0x7bf
-#define	UDC_EPN_STAT_REG		UDC_REG(0x34)	/* EP irq status */
-#define	UDC_DMAN_STAT_REG		UDC_REG(0x38)	/* DMA irq status */
-#	define	UDC_DMA_RX_SB		(1 << 12)
-#	define	UDC_DMA_RX_SRC(x)	(((x)>>8) & 0xf)
-#	define	UDC_DMA_TX_SRC(x)	(((x)>>0) & 0xf)
-
-
-/* DMA configuration registers:  up to three channels in each direction.  */
-#define	UDC_RXDMA_CFG_REG		UDC_REG(0x40)	/* 3 eps for RX DMA */
-#define	UDC_TXDMA_CFG_REG		UDC_REG(0x44)	/* 3 eps for TX DMA */
-#define	UDC_DATA_DMA_REG		UDC_REG(0x48)	/* rx/tx fifo addr */
-
-/* rx/tx dma control, numbering channels 1-3 not 0-2 */
-#define	UDC_TXDMA_REG(chan)		UDC_REG(0x50 - 4 + 4 * (chan))
-#	define UDC_TXN_EOT		(1 << 15)	/* bytes vs packets */
-#	define UDC_TXN_START		(1 << 14)	/* start transfer */
-#	define UDC_TXN_TSC		0x03ff		/* units in xfer */
-#define	UDC_RXDMA_REG(chan)		UDC_REG(0x60 - 4 + 4 * (chan))
-#	define UDC_RXN_STOP		(1 << 15)	/* enable EOT irq */
-#	define UDC_RXN_TC		0x00ff		/* packets in xfer */
-
-
-/*
- * Endpoint configuration registers (used before CFG_LOCK is set)
- * UDC_EP_TX_REG(0) is unused
- */
-#define	UDC_EP_RX_REG(endpoint)		UDC_REG(0x80 + (endpoint)*4)
-#	define	UDC_EPN_RX_VALID	(1 << 15)
-#	define	UDC_EPN_RX_DB		(1 << 14)
-	/* buffer size in bits 13, 12 */
-#	define	UDC_EPN_RX_ISO		(1 << 11)
-	/* buffer pointer in low 11 bits */
-#define	UDC_EP_TX_REG(endpoint)		UDC_REG(0xc0 + (endpoint)*4)
-	/* same bitfields as in RX_REG */
-
-/*-------------------------------------------------------------------------*/
-
-struct omap_req {
-	struct usb_request		req;
-	struct list_head		queue;
-	unsigned			dma_bytes;
-	unsigned			mapped:1;
-};
-
-struct omap_ep {
-	struct usb_ep			ep;
-	struct list_head		queue;
-	unsigned long			irqs;
-	struct list_head		iso;
-	const struct usb_endpoint_descriptor	*desc;
-	char				name[14];
-	u16				maxpacket;
-	u8				bEndpointAddress;
-	u8				bmAttributes;
-	unsigned			double_buf:1;
-	unsigned			stopped:1;
-	unsigned			ackwait:1;
-	unsigned			has_dma:1;
-	u8				dma_channel;
-	int				lch;
-	struct omap_udc			*udc;
-};
-
-struct omap_udc {
-	struct usb_gadget		gadget;
-	struct usb_gadget_driver	*driver;
-	spinlock_t			lock;
-	struct omap_ep			ep[32];
-	u16				devstat;
-	struct otg_transceiver		*transceiver;
-	struct list_head		iso;
-	unsigned			softconnect:1;
-	unsigned			vbus_active:1;
-	unsigned			ep0_pending:1;
-	unsigned			ep0_in:1;
-	unsigned			ep0_set_config:1;
-	unsigned			ep0_reset_config:1;
-	unsigned			ep0_setup:1;
-	unsigned			hmc:6;
-
-	struct completion		*done;
-};
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef DEBUG
-#define DBG(stuff...)		printk(KERN_DEBUG "udc: " stuff)
-#else
-#define DBG(stuff...)		do{}while(0)
-#endif
-
-#ifdef VERBOSE
-#    define VDBG		DBG
-#else
-#    define VDBG(stuff...)	do{}while(0)
-#endif
-
-#define ERR(stuff...)		printk(KERN_ERR "udc: " stuff)
-#define WARN(stuff...)		printk(KERN_WARNING "udc: " stuff)
-#define INFO(stuff...)		printk(KERN_INFO "udc: " stuff)
-
-/*-------------------------------------------------------------------------*/
-
-// #define	HMC_1510	((MOD_CONF_CTRL_0_REG >> 1) & 0x3f)
-#define	HMC_1610	(OTG_SYSCON_2_REG & 0x3f)
-#define	HMC		 HMC_1610
-
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/pxa2xx_udc.c linuxppc-2.6.9-dream/drivers/usb/gadget/pxa2xx_udc.c
--- linuxppc-2.6.9/drivers/usb/gadget/pxa2xx_udc.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/pxa2xx_udc.c	2005-09-19 21:40:05.000000000 +0200
@@ -51,10 +51,8 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/system.h>
-#include <asm/mach-types.h>
 #include <asm/unaligned.h>
 #include <asm/hardware.h>
-#include <asm/arch/pxa-regs.h>
 
 #include <linux/usb_ch9.h>
 #include <linux/usb_gadget.h>
@@ -96,7 +94,7 @@
 #define	UDC_PROC_FILE
 #endif
 
-#ifdef CONFIG_ARCH_IXP4XX
+#ifdef CONFIG_ARCH_IXP425
 #undef USE_DMA
 
 /* cpu-specific register addresses are compiled in to this code */
@@ -117,7 +115,7 @@
 
 #ifdef	USE_DMA
 static int use_dma = 1;
-module_param(use_dma, bool, 0);
+MODULE_PARM (use_dma, "i");
 MODULE_PARM_DESC (use_dma, "true to use dma");
 
 static void dma_nodesc_handler (int dmach, void *_ep, struct pt_regs *r);
@@ -147,7 +145,7 @@
  * ... so mode = 3 (or 7, 15, etc) does it for both
  */
 static ushort fifo_mode = 0;
-module_param(fifo_mode, ushort, 0);
+MODULE_PARM (fifo_mode, "h");
 MODULE_PARM_DESC (fifo_mode, "pxa2xx udc fifo mode");
 #endif
 
@@ -1407,7 +1405,7 @@
 
 #ifdef	CONFIG_ARCH_PXA
         /* Disable clock for USB device */
-	pxa_set_cken(CKEN11_USB, 0);
+        CKEN &= ~CKEN11_USB;
 #endif
 
 	ep0_idle (dev);
@@ -1453,7 +1451,7 @@
 
 #ifdef	CONFIG_ARCH_PXA
         /* Enable clock for USB device */
-	pxa_set_cken(CKEN11_USB, 1);
+        CKEN |= CKEN11_USB;
 #endif
 
 	/* try to clear these bits before we enable the udc */
@@ -1509,7 +1507,7 @@
 	/* caller must be able to sleep in order to cope
 	 * with startup transients.
 	 */
-	msleep(100);
+	schedule_timeout(HZ/10);
 
 	/* enable suspend/resume and reset irqs */
 	udc_clear_mask_UDCCR(UDCCR_SRM | UDCCR_REM);
@@ -2376,8 +2374,8 @@
 #if	defined(CONFIG_ARCH_PXA)
 #define CP15R0_XSCALE_VALUE	0x69052000	/* intel/arm/xscale */
 
-#elif	defined(CONFIG_ARCH_IXP4XX)
-#define CP15R0_XSCALE_VALUE	0x69054000	/* intel/arm/ixp4xx */
+#elif	defined(CONFIG_ARCH_IXP425)
+#define CP15R0_XSCALE_VALUE	0x69054000	/* intel/arm/ixp425 */
 
 #endif
 
@@ -2436,7 +2434,7 @@
 		/* fall through */
 	case PXA250_C0: case PXA210_C0:
 		break;
-#elif	defined(CONFIG_ARCH_IXP4XX)
+#elif	defined(CONFIG_ARCH_IXP425)
 	case IXP425_A0:
 		out_dma = 0;
 		break;
@@ -2540,7 +2538,7 @@
 /*-------------------------------------------------------------------------*/
 
 static struct device_driver udc_driver = {
-	.name		= "pxa2xx-udc",
+	.name		= (char *) driver_name,
 	.bus		= &platform_bus_type,
 	.probe		= pxa2xx_udc_probe,
 	.remove		= __exit_p(pxa2xx_udc_remove),
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/rndis.c linuxppc-2.6.9-dream/drivers/usb/gadget/rndis.c
--- linuxppc-2.6.9/drivers/usb/gadget/rndis.c	2004-10-18 23:53:10.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/rndis.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1428 +0,0 @@
-/* 
- * RNDIS MSG parser
- * 
- * Version:     $Id: rndis.c,v 1.19 2004/03/25 21:33:46 robert Exp $
- * 
- * Authors:	Benedikt Spranger, Pengutronix
- * 		Robert Schwebel, Pengutronix
- * 
- *              This program is free software; you can redistribute it and/or
- *              modify it under the terms of the GNU General Public License
- *              version 2, as published by the Free Software Foundation. 
- * 
- *		This software was originally developed in conformance with
- *		Microsoft's Remote NDIS Specification License Agreement.
- *              
- * 03/12/2004 Kai-Uwe Bloem <linux-development@auerswald.de>
- *		Fixed message length bug in init_response
- * 
- * 03/25/2004 Kai-Uwe Bloem <linux-development@auerswald.de>
- * 		Fixed rndis_rm_hdr length bug.
- *
- * Copyright (C) 2004 by David Brownell
- *		updates to merge with Linux 2.6, better match RNDIS spec
- */
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/version.h>
-#include <linux/init.h>
-#include <linux/list.h>
-#include <linux/proc_fs.h>
-#include <linux/netdevice.h>
-
-#include <asm/io.h>
-#include <asm/byteorder.h>
-#include <asm/system.h>
-
-
-#undef	RNDIS_PM
-#undef	VERBOSE
-
-#include "rndis.h"
-
-
-/* The driver for your USB chip needs to support ep0 OUT to work with
- * RNDIS, plus all three CDC Ethernet endpoints (interrupt not optional).
- *
- * Windows hosts need an INF file like Documentation/usb/linux.inf
- * and will be happier if you provide the host_addr module parameter.
- */
-
-#if 0
-#define DEBUG(str,args...) do { \
-	if (rndis_debug) \
-		printk(KERN_DEBUG str , ## args ); \
-	} while (0)
-static int rndis_debug = 0;
-
-module_param (rndis_debug, bool, 0);
-MODULE_PARM_DESC (rndis_debug, "enable debugging");
-
-#else
-
-#define rndis_debug		0
-#define DEBUG(str,args...)	do{}while(0)
-#endif
-
-#define RNDIS_MAX_CONFIGS	1
-
-static struct proc_dir_entry *rndis_connect_dir;
-static struct proc_dir_entry *rndis_connect_state [RNDIS_MAX_CONFIGS];
-
-static rndis_params rndis_per_dev_params [RNDIS_MAX_CONFIGS];
-
-/* Driver Version */
-static const u32 rndis_driver_version = __constant_cpu_to_le32 (1);
-
-/* Function Prototypes */
-static int rndis_init_response (int configNr, rndis_init_msg_type *buf);
-static int rndis_query_response (int configNr, rndis_query_msg_type *buf);
-static int rndis_set_response (int configNr, rndis_set_msg_type *buf);
-static int rndis_reset_response (int configNr, rndis_reset_msg_type *buf);
-static int rndis_keepalive_response (int configNr, 
-				     rndis_keepalive_msg_type *buf);
-
-static rndis_resp_t *rndis_add_response (int configNr, u32 length);
-
-
-/* NDIS Functions */
-static int gen_ndis_query_resp (int configNr, u32 OID, rndis_resp_t *r)
-{
-	int 			retval = -ENOTSUPP;
-	u32 			length = 0;
-	u32			*tmp;
-	int			i, count;
-	rndis_query_cmplt_type	*resp;
-
-	if (!r) return -ENOMEM;
-	resp = (rndis_query_cmplt_type *) r->buf;
-
-	if (!resp) return -ENOMEM;
-	
-	switch (OID) {
-
-	/* general oids (table 4-1) */
-
-	/* mandatory */
-	case OID_GEN_SUPPORTED_LIST:
-		DEBUG ("%s: OID_GEN_SUPPORTED_LIST\n", __FUNCTION__);
-		length = sizeof (oid_supported_list);
-		count  = length / sizeof (u32);
-		tmp = (u32 *) ((u8 *)resp + 24);
-		for (i = 0; i < count; i++)
-			tmp[i] = cpu_to_le32 (oid_supported_list[i]);
-		retval = 0;
-		break;
-		
-	/* mandatory */
-	case OID_GEN_HARDWARE_STATUS:
-		DEBUG("%s: OID_GEN_HARDWARE_STATUS\n", __FUNCTION__);
-		length = 4;
-		/* Bogus question! 
-		 * Hardware must be ready to recieve high level protocols.
-		 * BTW: 
-		 * reddite ergo quae sunt Caesaris Caesari
-		 * et quae sunt Dei Deo!
-		 */
-		*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-		retval = 0;
-		break;
-		
-	/* mandatory */
-	case OID_GEN_MEDIA_SUPPORTED:
-		DEBUG("%s: OID_GEN_MEDIA_SUPPORTED\n", __FUNCTION__);
-		length = 4;
-		*((u32 *) resp + 6) = cpu_to_le32 (
-					rndis_per_dev_params [configNr].medium);
-		retval = 0;
-		break;
-		
-	/* mandatory */
-	case OID_GEN_MEDIA_IN_USE:
-		DEBUG("%s: OID_GEN_MEDIA_IN_USE\n", __FUNCTION__);
-		length = 4;
-		/* one medium, one transport... (maybe you do it better) */
-		*((u32 *) resp + 6) = cpu_to_le32 (
-					rndis_per_dev_params [configNr].medium);
-		retval = 0;
-		break;
-		
-	/* mandatory */
-	case OID_GEN_MAXIMUM_FRAME_SIZE:
-		DEBUG("%s: OID_GEN_MAXIMUM_FRAME_SIZE\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].dev) {
-			length = 4;
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr].dev->mtu);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	/* mandatory */
-	case OID_GEN_LINK_SPEED:
-		DEBUG("%s: OID_GEN_LINK_SPEED\n", __FUNCTION__);
-		length = 4;
-		if (rndis_per_dev_params [configNr].media_state
-			== NDIS_MEDIA_STATE_DISCONNECTED)
-		    *((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-		else
-		    *((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr].speed);
-		retval = 0;
-		break;
-
-	/* mandatory */
-	case OID_GEN_TRANSMIT_BLOCK_SIZE:
-		DEBUG("%s: OID_GEN_TRANSMIT_BLOCK_SIZE\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].dev) {
-			length = 4;
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr].dev->mtu);
-			retval = 0;
-		}
-		break;
-		
-	/* mandatory */
-	case OID_GEN_RECEIVE_BLOCK_SIZE:
-		DEBUG("%s: OID_GEN_RECEIVE_BLOCK_SIZE\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].dev) {
-			length = 4;
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr].dev->mtu);
-			retval = 0;
-		}
-		break;
-		
-	/* mandatory */
-	case OID_GEN_VENDOR_ID:
-		DEBUG("%s: OID_GEN_VENDOR_ID\n", __FUNCTION__);
-		length = 4;
-		*((u32 *) resp + 6) = cpu_to_le32 (
-			rndis_per_dev_params [configNr].vendorID);
-		retval = 0;
-		break;
-		
-	/* mandatory */
-	case OID_GEN_VENDOR_DESCRIPTION:
-		DEBUG("%s: OID_GEN_VENDOR_DESCRIPTION\n", __FUNCTION__);
-		length = strlen (rndis_per_dev_params [configNr].vendorDescr);
-		memcpy ((u8 *) resp + 24, 
-			rndis_per_dev_params [configNr].vendorDescr, length);
-		retval = 0;
-		break;
-
-	case OID_GEN_VENDOR_DRIVER_VERSION:
-		DEBUG("%s: OID_GEN_VENDOR_DRIVER_VERSION\n", __FUNCTION__);
-		length = 4;
-		/* Created as LE */
-		*((u32 *) resp + 6) = rndis_driver_version;
-		retval = 0;
-		break;
-
-	/* mandatory */
-	case OID_GEN_CURRENT_PACKET_FILTER:
-		DEBUG("%s: OID_GEN_CURRENT_PACKET_FILTER\n", __FUNCTION__);
-		length = 4;
-		*((u32 *) resp + 6) = cpu_to_le32 (
-					rndis_per_dev_params[configNr].filter);
-		retval = 0;
-		break;
-
-	/* mandatory */
-	case OID_GEN_MAXIMUM_TOTAL_SIZE:
-		DEBUG("%s: OID_GEN_MAXIMUM_TOTAL_SIZE\n", __FUNCTION__);
-		length = 4;
-		*((u32 *) resp + 6) = __constant_cpu_to_le32(
-					RNDIS_MAX_TOTAL_SIZE);
-		retval = 0;
-		break;
-
-	/* mandatory */
-	case OID_GEN_MEDIA_CONNECT_STATUS:
-		DEBUG("%s: OID_GEN_MEDIA_CONNECT_STATUS\n", __FUNCTION__);
-		length = 4;
-		*((u32 *) resp + 6) = cpu_to_le32 (
-					rndis_per_dev_params [configNr]
-						.media_state);
-		retval = 0;
-		break;
-
-	case OID_GEN_PHYSICAL_MEDIUM:
-		DEBUG("%s: OID_GEN_PHYSICAL_MEDIUM\n", __FUNCTION__);
-		length = 4;
-		*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-		retval = 0;
-		break;
-
-	/* The RNDIS specification is incomplete/wrong.   Some versions
-	 * of MS-Windows expect OIDs that aren't specified there.  Other
-	 * versions emit undefined RNDIS messages. DOCUMENT ALL THESE!
-	 */
-	case OID_GEN_MAC_OPTIONS:		/* from WinME */
-		DEBUG("%s: OID_GEN_MAC_OPTIONS\n", __FUNCTION__);
-		length = 4;
-		*((u32 *) resp + 6) = __constant_cpu_to_le32(
-			  NDIS_MAC_OPTION_RECEIVE_SERIALIZED
-			| NDIS_MAC_OPTION_FULL_DUPLEX);
-		retval = 0;
-		break;
-
-	/* statistics OIDs (table 4-2) */
-
-	/* mandatory */
-	case OID_GEN_XMIT_OK:
-		DEBUG("%s: OID_GEN_XMIT_OK\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			length = 4;
-			*((u32 *) resp + 6) = cpu_to_le32 (
-			    rndis_per_dev_params [configNr].stats->tx_packets - 
-			    rndis_per_dev_params [configNr].stats->tx_errors -
-			    rndis_per_dev_params [configNr].stats->tx_dropped);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-
-	/* mandatory */
-	case OID_GEN_RCV_OK:
-		DEBUG("%s: OID_GEN_RCV_OK\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			length = 4;
-			*((u32 *) resp + 6) = cpu_to_le32 (
-			    rndis_per_dev_params [configNr].stats->rx_packets - 
-			    rndis_per_dev_params [configNr].stats->rx_errors -
-			    rndis_per_dev_params [configNr].stats->rx_dropped);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	/* mandatory */
-	case OID_GEN_XMIT_ERROR:
-		DEBUG("%s: OID_GEN_XMIT_ERROR\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			length = 4;
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->tx_errors);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	/* mandatory */
-	case OID_GEN_RCV_ERROR:
-		DEBUG("%s: OID_GEN_RCV_ERROR\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->rx_errors);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	/* mandatory */
-	case OID_GEN_RCV_NO_BUFFER:
-		DEBUG("%s: OID_GEN_RCV_NO_BUFFER\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->rx_dropped);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-
-#ifdef	RNDIS_OPTIONAL_STATS
-	case OID_GEN_DIRECTED_BYTES_XMIT:
-		DEBUG("%s: OID_GEN_DIRECTED_BYTES_XMIT\n", __FUNCTION__);
-		/* 
-		 * Aunt Tilly's size of shoes
-		 * minus antarctica count of penguins
-		 * divided by weight of Alpha Centauri
-		 */
-		if (rndis_per_dev_params [configNr].stats) {
-			length = 4;
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				(rndis_per_dev_params [configNr]
-					.stats->tx_packets - 
-				 rndis_per_dev_params [configNr]
-					 .stats->tx_errors -
-				 rndis_per_dev_params [configNr]
-					 .stats->tx_dropped)
-				* 123);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	case OID_GEN_DIRECTED_FRAMES_XMIT:
-		DEBUG("%s: OID_GEN_DIRECTED_FRAMES_XMIT\n", __FUNCTION__);
-		/* dito */
-		if (rndis_per_dev_params [configNr].stats) {
-			length = 4;
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				(rndis_per_dev_params [configNr]
-					.stats->tx_packets - 
-				 rndis_per_dev_params [configNr]
-					 .stats->tx_errors -
-				 rndis_per_dev_params [configNr]
-					 .stats->tx_dropped)
-				/ 123);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	case OID_GEN_MULTICAST_BYTES_XMIT:
-		DEBUG("%s: OID_GEN_MULTICAST_BYTES_XMIT\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->multicast*1234);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	case OID_GEN_MULTICAST_FRAMES_XMIT:
-		DEBUG("%s: OID_GEN_MULTICAST_FRAMES_XMIT\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->multicast);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	case OID_GEN_BROADCAST_BYTES_XMIT:
-		DEBUG("%s: OID_GEN_BROADCAST_BYTES_XMIT\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->tx_packets/42*255);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	case OID_GEN_BROADCAST_FRAMES_XMIT:
-		DEBUG("%s: OID_GEN_BROADCAST_FRAMES_XMIT\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->tx_packets/42);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	case OID_GEN_DIRECTED_BYTES_RCV:
-		DEBUG("%s: OID_GEN_DIRECTED_BYTES_RCV\n", __FUNCTION__);
-		*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-		retval = 0;
-		break;
-		
-	case OID_GEN_DIRECTED_FRAMES_RCV:
-		DEBUG("%s: OID_GEN_DIRECTED_FRAMES_RCV\n", __FUNCTION__);
-		*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-		retval = 0;
-		break;
-		
-	case OID_GEN_MULTICAST_BYTES_RCV:
-		DEBUG("%s: OID_GEN_MULTICAST_BYTES_RCV\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->multicast * 1111);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	case OID_GEN_MULTICAST_FRAMES_RCV:
-		DEBUG("%s: OID_GEN_MULTICAST_FRAMES_RCV\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->multicast);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	case OID_GEN_BROADCAST_BYTES_RCV:
-		DEBUG("%s: OID_GEN_BROADCAST_BYTES_RCV\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->rx_packets/42*255);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	case OID_GEN_BROADCAST_FRAMES_RCV:
-		DEBUG("%s: OID_GEN_BROADCAST_FRAMES_RCV\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->rx_packets/42);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	case OID_GEN_RCV_CRC_ERROR:
-		DEBUG("%s: OID_GEN_RCV_CRC_ERROR\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats) {
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->rx_crc_errors);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	case OID_GEN_TRANSMIT_QUEUE_LENGTH:
-		DEBUG("%s: OID_GEN_TRANSMIT_QUEUE_LENGTH\n", __FUNCTION__);
-		*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-		retval = 0;
-		break;
-#endif	/* RNDIS_OPTIONAL_STATS */
-
-	/* ieee802.3 OIDs (table 4-3) */
-
-	/* mandatory */
-	case OID_802_3_PERMANENT_ADDRESS:
-		DEBUG("%s: OID_802_3_PERMANENT_ADDRESS\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].dev) {
-			length = ETH_ALEN;
-			memcpy ((u8 *) resp + 24,
-				rndis_per_dev_params [configNr].host_mac,
-				length);
-			retval = 0;
-		} else {
-			*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-			retval = 0;
-		}
-		break;
-		
-	/* mandatory */
-	case OID_802_3_CURRENT_ADDRESS:
-		DEBUG("%s: OID_802_3_CURRENT_ADDRESS\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].dev) {
-			length = ETH_ALEN;
-			memcpy ((u8 *) resp + 24,
-				rndis_per_dev_params [configNr].host_mac,
-				length);
-			retval = 0;
-		}
-		break;
-		
-	/* mandatory */
-	case OID_802_3_MULTICAST_LIST:
-		DEBUG("%s: OID_802_3_MULTICAST_LIST\n", __FUNCTION__);
-		length = 4;
-		/* Multicast base address only */
-		*((u32 *) resp + 6) = __constant_cpu_to_le32 (0xE0000000);
-		retval = 0;
-		break;
-		
-	/* mandatory */
-	case OID_802_3_MAXIMUM_LIST_SIZE:
-		DEBUG("%s: OID_802_3_MAXIMUM_LIST_SIZE\n", __FUNCTION__);
-		 length = 4;
-		/* Multicast base address only */
-		*((u32 *) resp + 6) = __constant_cpu_to_le32 (1);
-		retval = 0;
-		break;
-		
-	case OID_802_3_MAC_OPTIONS:
-		DEBUG("%s: OID_802_3_MAC_OPTIONS\n", __FUNCTION__);
-		break;
-
-	/* ieee802.3 statistics OIDs (table 4-4) */
-
-	/* mandatory */
-	case OID_802_3_RCV_ERROR_ALIGNMENT:
-		DEBUG("%s: OID_802_3_RCV_ERROR_ALIGNMENT\n", __FUNCTION__);
-		if (rndis_per_dev_params [configNr].stats)
-		{
-			length = 4;
-			*((u32 *) resp + 6) = cpu_to_le32 (
-				rndis_per_dev_params [configNr]
-					.stats->rx_frame_errors);
-			retval = 0;
-		}
-		break;
-		
-	/* mandatory */
-	case OID_802_3_XMIT_ONE_COLLISION:
-		DEBUG("%s: OID_802_3_XMIT_ONE_COLLISION\n", __FUNCTION__);
-		length = 4;
-		*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-		retval = 0;
-		break;
-		
-	/* mandatory */
-	case OID_802_3_XMIT_MORE_COLLISIONS:
-		DEBUG("%s: OID_802_3_XMIT_MORE_COLLISIONS\n", __FUNCTION__);
-		length = 4;
-		*((u32 *) resp + 6) = __constant_cpu_to_le32 (0);
-		retval = 0;
-		break;
-		
-#ifdef	RNDIS_OPTIONAL_STATS
-	case OID_802_3_XMIT_DEFERRED:
-		DEBUG("%s: OID_802_3_XMIT_DEFERRED\n", __FUNCTION__);
-		/* TODO */
-		break;
-		
-	case OID_802_3_XMIT_MAX_COLLISIONS:
-		DEBUG("%s: OID_802_3_XMIT_MAX_COLLISIONS\n", __FUNCTION__);
-		/* TODO */
-		break;
-		
-	case OID_802_3_RCV_OVERRUN:
-		DEBUG("%s: OID_802_3_RCV_OVERRUN\n", __FUNCTION__);
-		/* TODO */
-		break;
-		
-	case OID_802_3_XMIT_UNDERRUN:
-		DEBUG("%s: OID_802_3_XMIT_UNDERRUN\n", __FUNCTION__);
-		/* TODO */
-		break;
-		
-	case OID_802_3_XMIT_HEARTBEAT_FAILURE:
-		DEBUG("%s: OID_802_3_XMIT_HEARTBEAT_FAILURE\n", __FUNCTION__);
-		/* TODO */
-		break;
-		
-	case OID_802_3_XMIT_TIMES_CRS_LOST:
-		DEBUG("%s: OID_802_3_XMIT_TIMES_CRS_LOST\n", __FUNCTION__);
-		/* TODO */
-		break;
-		
-	case OID_802_3_XMIT_LATE_COLLISIONS:
-		DEBUG("%s: OID_802_3_XMIT_LATE_COLLISIONS\n", __FUNCTION__);
-		/* TODO */
-		break;		
-#endif	/* RNDIS_OPTIONAL_STATS */
-
-#ifdef	RNDIS_PM
-	/* power management OIDs (table 4-5) */
-	case OID_PNP_CAPABILITIES:
-		DEBUG("%s: OID_PNP_CAPABILITIES\n", __FUNCTION__);
-
-		/* just PM, and remote wakeup on link status change
-		 * (not magic packet or pattern match)
-		 */
-		length = sizeof (struct NDIS_PNP_CAPABILITIES);
-		memset (resp, 0, length);
-		{
-			struct NDIS_PNP_CAPABILITIES *caps = (void *) resp;
-
-			caps->Flags = NDIS_DEVICE_WAKE_UP_ENABLE;
-			caps->WakeUpCapabilities.MinLinkChangeWakeUp 
-				 = NdisDeviceStateD3;
-
-			/* FIXME then use usb_gadget_wakeup(), and
-			 * set USB_CONFIG_ATT_WAKEUP in config desc
-			 */
-		}
-		retval = 0;
-		break;
-	case OID_PNP_QUERY_POWER:
-		DEBUG("%s: OID_PNP_QUERY_POWER\n", __FUNCTION__);
-		/* sure, handle any power state that maps to USB suspend */
-		retval = 0;
-		break;
-#endif
-
-	default:
-		printk (KERN_WARNING "%s: query unknown OID 0x%08X\n", 
-			 __FUNCTION__, OID);
-	}
-	
-	resp->InformationBufferOffset = __constant_cpu_to_le32 (16);
-	resp->InformationBufferLength = cpu_to_le32 (length);
-	resp->MessageLength = cpu_to_le32 (24 + length);
-	r->length = 24 + length;
-	return retval;
-}
-
-static int gen_ndis_set_resp (u8 configNr, u32 OID, u8 *buf, u32 buf_len, 
-			      rndis_resp_t *r)
-{
-	rndis_set_cmplt_type		*resp;
-	int 				i, retval = -ENOTSUPP;
-	struct rndis_params		*params;
-
-	if (!r)
-		return -ENOMEM;
-	resp = (rndis_set_cmplt_type *) r->buf;
-	if (!resp)
-		return -ENOMEM;
-
-	DEBUG("set OID %08x value, len %d:\n", OID, buf_len);
-	for (i = 0; i < buf_len; i += 16) {
-		DEBUG ("%03d: "
-			" %02x %02x %02x %02x"
-			" %02x %02x %02x %02x"
-			" %02x %02x %02x %02x"
-			" %02x %02x %02x %02x"
-			"\n",
-			i,
-			buf[i], buf [i+1],
-				buf[i+2], buf[i+3],
-			buf[i+4], buf [i+5],
-				buf[i+6], buf[i+7],
-			buf[i+8], buf [i+9],
-				buf[i+10], buf[i+11],
-			buf[i+12], buf [i+13],
-				buf[i+14], buf[i+15]);
-	}
-
-	switch (OID) {
-	case OID_GEN_CURRENT_PACKET_FILTER:
-		params = &rndis_per_dev_params [configNr];
-		retval = 0;
-
-		/* FIXME use these NDIS_PACKET_TYPE_* bitflags to
-		 * filter packets in hard_start_xmit()
-		 * NDIS_PACKET_TYPE_x == CDC_PACKET_TYPE_x for x in:
-		 *	PROMISCUOUS, DIRECTED,
-		 *	MULTICAST, ALL_MULTICAST, BROADCAST
-		 */
-		params->filter = cpu_to_le32p((u32 *)buf);
-		DEBUG("%s: OID_GEN_CURRENT_PACKET_FILTER %08x\n",
-			__FUNCTION__, params->filter);
-
-		/* this call has a significant side effect:  it's
-		 * what makes the packet flow start and stop, like
-		 * activating the CDC Ethernet altsetting.
-		 */
-		if (params->filter) {
-			params->state = RNDIS_DATA_INITIALIZED;
-			netif_carrier_on(params->dev);
-			if (netif_running(params->dev))
-				netif_wake_queue (params->dev);
-		} else {
-			params->state = RNDIS_INITIALIZED;
-			netif_carrier_off (params->dev);
-			netif_stop_queue (params->dev);
-		}
-		break;
-		
-	case OID_802_3_MULTICAST_LIST:
-		/* I think we can ignore this */		
-		DEBUG("%s: OID_802_3_MULTICAST_LIST\n", __FUNCTION__);
-		retval = 0;
-		break;
-#if 0
-	case OID_GEN_RNDIS_CONFIG_PARAMETER:
-		{
-		struct rndis_config_parameter	*param;
-		param = (struct rndis_config_parameter *) buf;
-		DEBUG("%s: OID_GEN_RNDIS_CONFIG_PARAMETER '%*s'\n",
-			__FUNCTION__,
-			min(cpu_to_le32(param->ParameterNameLength),80),
-			buf + param->ParameterNameOffset);
-		retval = 0;
-		}
-		break;
-#endif
-
-#ifdef	RNDIS_PM
-	case OID_PNP_SET_POWER:
-		DEBUG ("OID_PNP_SET_POWER\n");
-		/* sure, handle any power state that maps to USB suspend */
-		retval = 0;
-		break;
-
-	case OID_PNP_ENABLE_WAKE_UP:
-		/* always-connected ... */
-		DEBUG ("OID_PNP_ENABLE_WAKE_UP\n");
-		retval = 0;
-		break;
-
-	// no PM resume patterns supported (specified where?)
-	// so OID_PNP_{ADD,REMOVE}_WAKE_UP_PATTERN always fails
-#endif
-
-	default:
-		printk (KERN_WARNING "%s: set unknown OID 0x%08X, size %d\n", 
-			 __FUNCTION__, OID, buf_len);
-	}
-	
-	return retval;
-}
-
-/* 
- * Response Functions 
- */
-
-static int rndis_init_response (int configNr, rndis_init_msg_type *buf)
-{
-	rndis_init_cmplt_type	*resp; 
-	rndis_resp_t            *r;
-	
-	if (!rndis_per_dev_params [configNr].dev) return -ENOTSUPP;
-	
-	r = rndis_add_response (configNr, sizeof (rndis_init_cmplt_type));
-	
-	if (!r) return -ENOMEM;
-	
-	resp = (rndis_init_cmplt_type *) r->buf;
-	
-	if (!resp) return -ENOMEM;
-	
-	resp->MessageType = __constant_cpu_to_le32 (
-			REMOTE_NDIS_INITIALIZE_CMPLT);
-	resp->MessageLength = __constant_cpu_to_le32 (52);
-	resp->RequestID = buf->RequestID; /* Still LE in msg buffer */
-	resp->Status = __constant_cpu_to_le32 (RNDIS_STATUS_SUCCESS);
-	resp->MajorVersion = __constant_cpu_to_le32 (RNDIS_MAJOR_VERSION);
-	resp->MinorVersion = __constant_cpu_to_le32 (RNDIS_MINOR_VERSION);
-	resp->DeviceFlags = __constant_cpu_to_le32 (RNDIS_DF_CONNECTIONLESS);
-	resp->Medium = __constant_cpu_to_le32 (RNDIS_MEDIUM_802_3);
-	resp->MaxPacketsPerTransfer = __constant_cpu_to_le32 (1);
-	resp->MaxTransferSize = cpu_to_le32 (
-		  rndis_per_dev_params [configNr].dev->mtu
-		+ sizeof (struct ethhdr)
-		+ sizeof (struct rndis_packet_msg_type)
-		+ 22);
-	resp->PacketAlignmentFactor = __constant_cpu_to_le32 (0);
-	resp->AFListOffset = __constant_cpu_to_le32 (0);
-	resp->AFListSize = __constant_cpu_to_le32 (0);
-	
-	if (rndis_per_dev_params [configNr].ack)
-	    rndis_per_dev_params [configNr].ack (
-	    		rndis_per_dev_params [configNr].dev);
-	
-	return 0;
-}
-
-static int rndis_query_response (int configNr, rndis_query_msg_type *buf)
-{
-	rndis_query_cmplt_type *resp;
-	rndis_resp_t            *r;
-	
-	// DEBUG("%s: OID = %08X\n", __FUNCTION__, cpu_to_le32(buf->OID));
-	if (!rndis_per_dev_params [configNr].dev) return -ENOTSUPP;
-	
-	/* 
-	 * we need more memory: 
-	 * oid_supported_list is the largest answer 
-	 */
-	r = rndis_add_response (configNr, sizeof (oid_supported_list));
-	
-	if (!r) return -ENOMEM;
-	resp = (rndis_query_cmplt_type *) r->buf;
-	
-	if (!resp) return -ENOMEM;
-	
-	resp->MessageType = __constant_cpu_to_le32 (REMOTE_NDIS_QUERY_CMPLT);
-	resp->MessageLength = __constant_cpu_to_le32 (24);
-	resp->RequestID = buf->RequestID; /* Still LE in msg buffer */
-	
-	if (gen_ndis_query_resp (configNr, cpu_to_le32 (buf->OID), r)) {
-		/* OID not supported */
-		resp->Status = __constant_cpu_to_le32 (
-				RNDIS_STATUS_NOT_SUPPORTED);
-		resp->InformationBufferLength = __constant_cpu_to_le32 (0);
-		resp->InformationBufferOffset = __constant_cpu_to_le32 (0);
-	} else
-		resp->Status = __constant_cpu_to_le32 (RNDIS_STATUS_SUCCESS);
-	
-	if (rndis_per_dev_params [configNr].ack)
-	    rndis_per_dev_params [configNr].ack (
-	    		rndis_per_dev_params [configNr].dev);
-	return 0;
-}
-
-static int rndis_set_response (int configNr, rndis_set_msg_type *buf)
-{
-	u32			BufLength, BufOffset;
-	rndis_set_cmplt_type	*resp;
-	rndis_resp_t		*r;
-	
-	r = rndis_add_response (configNr, sizeof (rndis_set_cmplt_type));
-	
-	if (!r) return -ENOMEM;
-	resp = (rndis_set_cmplt_type *) r->buf;
-	if (!resp) return -ENOMEM;
-
-	BufLength = cpu_to_le32 (buf->InformationBufferLength);
-	BufOffset = cpu_to_le32 (buf->InformationBufferOffset);
-
-#ifdef	VERBOSE
-	DEBUG("%s: Length: %d\n", __FUNCTION__, BufLength);
-	DEBUG("%s: Offset: %d\n", __FUNCTION__, BufOffset);
-	DEBUG("%s: InfoBuffer: ", __FUNCTION__);
-	
-	for (i = 0; i < BufLength; i++) {
-		DEBUG ("%02x ", *(((u8 *) buf) + i + 8 + BufOffset));
-	}
-	
-	DEBUG ("\n");
-#endif
-	
-	resp->MessageType = __constant_cpu_to_le32 (REMOTE_NDIS_SET_CMPLT);
-	resp->MessageLength = __constant_cpu_to_le32 (16);
-	resp->RequestID = buf->RequestID; /* Still LE in msg buffer */
-	if (gen_ndis_set_resp (configNr, cpu_to_le32 (buf->OID), 
-			       ((u8 *) buf) + 8 + BufOffset, BufLength, r))
-	    resp->Status = __constant_cpu_to_le32 (RNDIS_STATUS_NOT_SUPPORTED);
-	else resp->Status = __constant_cpu_to_le32 (RNDIS_STATUS_SUCCESS);
-	
-	if (rndis_per_dev_params [configNr].ack)
-	    rndis_per_dev_params [configNr].ack (
-	    		rndis_per_dev_params [configNr].dev);
-	
-	return 0;
-}
-
-static int rndis_reset_response (int configNr, rndis_reset_msg_type *buf)
-{
-	rndis_reset_cmplt_type	*resp;
-	rndis_resp_t		*r;
-	
-	r = rndis_add_response (configNr, sizeof (rndis_reset_cmplt_type));
-	
-	if (!r) return -ENOMEM;
-	resp = (rndis_reset_cmplt_type *) r->buf;
-	if (!resp) return -ENOMEM;
-	
-	resp->MessageType = __constant_cpu_to_le32 (REMOTE_NDIS_RESET_CMPLT);
-	resp->MessageLength = __constant_cpu_to_le32 (16);
-	resp->Status = __constant_cpu_to_le32 (RNDIS_STATUS_SUCCESS);
-	/* resent information */
-	resp->AddressingReset = __constant_cpu_to_le32 (1);
-	
-	if (rndis_per_dev_params [configNr].ack)
-	    rndis_per_dev_params [configNr].ack (
-	    		rndis_per_dev_params [configNr].dev);
-
-	return 0;
-}
-
-static int rndis_keepalive_response (int configNr,
-				     rndis_keepalive_msg_type *buf)
-{
-	rndis_keepalive_cmplt_type	*resp;
-	rndis_resp_t			*r;
-
-	/* host "should" check only in RNDIS_DATA_INITIALIZED state */
-
-	r = rndis_add_response (configNr, sizeof (rndis_keepalive_cmplt_type));
-	resp = (rndis_keepalive_cmplt_type *) r->buf;
-	if (!resp) return -ENOMEM;
-		
-	resp->MessageType = __constant_cpu_to_le32 (
-			REMOTE_NDIS_KEEPALIVE_CMPLT);
-	resp->MessageLength = __constant_cpu_to_le32 (16);
-	resp->RequestID = buf->RequestID; /* Still LE in msg buffer */
-	resp->Status = __constant_cpu_to_le32 (RNDIS_STATUS_SUCCESS);
-	
-	if (rndis_per_dev_params [configNr].ack)
-	    rndis_per_dev_params [configNr].ack (
-	    		rndis_per_dev_params [configNr].dev);
-	
-	return 0;
-}
-
-
-/* 
- * Device to Host Comunication 
- */
-static int rndis_indicate_status_msg (int configNr, u32 status)
-{
-	rndis_indicate_status_msg_type	*resp;	
-	rndis_resp_t			*r;
-	
-	if (rndis_per_dev_params [configNr].state == RNDIS_UNINITIALIZED)
-	    return -ENOTSUPP;
-	
-	r = rndis_add_response (configNr, 
-				sizeof (rndis_indicate_status_msg_type));
-	if (!r) return -ENOMEM;
-	
-	resp = (rndis_indicate_status_msg_type *) r->buf;
-	if (!resp) return -ENOMEM;
-	
-	resp->MessageType = __constant_cpu_to_le32 (
-			REMOTE_NDIS_INDICATE_STATUS_MSG);
-	resp->MessageLength = __constant_cpu_to_le32 (20);
-	resp->Status = cpu_to_le32 (status);
-	resp->StatusBufferLength = __constant_cpu_to_le32 (0);
-	resp->StatusBufferOffset = __constant_cpu_to_le32 (0);
-	
-	if (rndis_per_dev_params [configNr].ack) 
-	    rndis_per_dev_params [configNr].ack (
-	    		rndis_per_dev_params [configNr].dev);
-	return 0;
-}
-
-int rndis_signal_connect (int configNr)
-{
-	rndis_per_dev_params [configNr].media_state
-			= NDIS_MEDIA_STATE_CONNECTED;
-	return rndis_indicate_status_msg (configNr, 
-					  RNDIS_STATUS_MEDIA_CONNECT);
-}
-
-int rndis_signal_disconnect (int configNr)
-{
-	rndis_per_dev_params [configNr].media_state
-			= NDIS_MEDIA_STATE_DISCONNECTED;
-	return rndis_indicate_status_msg (configNr,
-					  RNDIS_STATUS_MEDIA_DISCONNECT);
-}
-
-void rndis_set_host_mac (int configNr, const u8 *addr)
-{
-	rndis_per_dev_params [configNr].host_mac = addr;
-}
-
-/* 
- * Message Parser 
- */
-int rndis_msg_parser (u8 configNr, u8 *buf)
-{
-	u32 MsgType, MsgLength, *tmp;
-	struct rndis_params		*params;
-	
-	if (!buf)
-		return -ENOMEM;
-	
-	tmp = (u32 *) buf; 
-	MsgType   = cpu_to_le32p(tmp++);
-	MsgLength = cpu_to_le32p(tmp++);
-	
-	if (configNr >= RNDIS_MAX_CONFIGS)
-		return -ENOTSUPP;
-	params = &rndis_per_dev_params [configNr];
-	
-	/* For USB: responses may take up to 10 seconds */
-	switch (MsgType)
-	{
-	case REMOTE_NDIS_INITIALIZE_MSG:
-		DEBUG("%s: REMOTE_NDIS_INITIALIZE_MSG\n", 
-			__FUNCTION__ );
-		params->state = RNDIS_INITIALIZED;
-		return  rndis_init_response (configNr,
-					     (rndis_init_msg_type *) buf);
-		
-	case REMOTE_NDIS_HALT_MSG:
-		DEBUG("%s: REMOTE_NDIS_HALT_MSG\n",
-			__FUNCTION__ );
-		params->state = RNDIS_UNINITIALIZED;
-		if (params->dev) {
-			netif_carrier_off (params->dev);
-			netif_stop_queue (params->dev);
-		}
-		return 0;
-		
-	case REMOTE_NDIS_QUERY_MSG:
-		return rndis_query_response (configNr, 
-					     (rndis_query_msg_type *) buf);
-		
-	case REMOTE_NDIS_SET_MSG:
-		return rndis_set_response (configNr, 
-					   (rndis_set_msg_type *) buf);
-		
-	case REMOTE_NDIS_RESET_MSG:
-		DEBUG("%s: REMOTE_NDIS_RESET_MSG\n", 
-			__FUNCTION__ );
-		return rndis_reset_response (configNr,
-					     (rndis_reset_msg_type *) buf);
-
-	case REMOTE_NDIS_KEEPALIVE_MSG:
-		/* For USB: host does this every 5 seconds */
-#ifdef	VERBOSE
-		DEBUG("%s: REMOTE_NDIS_KEEPALIVE_MSG\n", 
-			__FUNCTION__ );
-#endif
-		return rndis_keepalive_response (configNr,
-						 (rndis_keepalive_msg_type *) 
-						 buf);
-		
-	default: 
-		/* At least Windows XP emits some undefined RNDIS messages.
-		 * In one case those messages seemed to relate to the host
-		 * suspending itself.
-		 */
-		printk (KERN_WARNING
-			"%s: unknown RNDIS message 0x%08X len %d\n", 
-			__FUNCTION__ , MsgType, MsgLength);
-		{
-			unsigned i;
-			for (i = 0; i < MsgLength; i += 16) {
-				DEBUG ("%03d: "
-					" %02x %02x %02x %02x"
-					" %02x %02x %02x %02x"
-					" %02x %02x %02x %02x"
-					" %02x %02x %02x %02x"
-					"\n",
-					i,
-					buf[i], buf [i+1],
-						buf[i+2], buf[i+3],
-					buf[i+4], buf [i+5],
-						buf[i+6], buf[i+7],
-					buf[i+8], buf [i+9],
-						buf[i+10], buf[i+11],
-					buf[i+12], buf [i+13],
-						buf[i+14], buf[i+15]);
-			}
-		}
-		break;
-	}
-	
-	return -ENOTSUPP;
-}
-
-int rndis_register (int (* rndis_control_ack) (struct net_device *))
-{
-	u8 i;
-	
-	for (i = 0; i < RNDIS_MAX_CONFIGS; i++) {
-		if (!rndis_per_dev_params [i].used) {
-			rndis_per_dev_params [i].used = 1;
-			rndis_per_dev_params [i].ack = rndis_control_ack;
-			DEBUG("%s: configNr = %d\n", __FUNCTION__, i);
-			return i;
-		}
-	}
-	DEBUG("failed\n");
-	
-	return -1;
-}
-
-void rndis_deregister (int configNr)
-{
-	DEBUG("%s: \n", __FUNCTION__ );
-	
-	if (configNr >= RNDIS_MAX_CONFIGS) return;
-	rndis_per_dev_params [configNr].used = 0;
-	
-	return;
-}
-
-int rndis_set_param_dev (u8 configNr, struct net_device *dev, 
-			 struct net_device_stats *stats)
-{
-	DEBUG("%s:\n", __FUNCTION__ );
-	if (!dev || !stats) return -1;
-	if (configNr >= RNDIS_MAX_CONFIGS) return -1;
-	
-	rndis_per_dev_params [configNr].dev = dev;
-	rndis_per_dev_params [configNr].stats = stats;
-	
-	return 0;
-}
-
-int rndis_set_param_vendor (u8 configNr, u32 vendorID, const char *vendorDescr)
-{
-	DEBUG("%s:\n", __FUNCTION__ );
-	if (!vendorDescr) return -1;
-	if (configNr >= RNDIS_MAX_CONFIGS) return -1;
-	
-	rndis_per_dev_params [configNr].vendorID = vendorID;
-	rndis_per_dev_params [configNr].vendorDescr = vendorDescr;
-	
-	return 0;
-}
-
-int rndis_set_param_medium (u8 configNr, u32 medium, u32 speed)
-{
-	DEBUG("%s:\n", __FUNCTION__ );
-	if (configNr >= RNDIS_MAX_CONFIGS) return -1;
-	
-	rndis_per_dev_params [configNr].medium = medium;
-	rndis_per_dev_params [configNr].speed = speed;
-	
-	return 0;
-}
-
-void rndis_add_hdr (struct sk_buff *skb)
-{
-	if (!skb) return;
-	skb_push (skb, sizeof (struct rndis_packet_msg_type));
-	memset (skb->data, 0, sizeof (struct rndis_packet_msg_type));
-	*((u32 *) skb->data) = __constant_cpu_to_le32 (1);
-	*((u32 *) skb->data + 1) = cpu_to_le32(skb->len);
-	*((u32 *) skb->data + 2) = __constant_cpu_to_le32 (36);
-	*((u32 *) skb->data + 3) = cpu_to_le32(skb->len - 44);
-	
-	return;
-}
-
-void rndis_free_response (int configNr, u8 *buf)
-{
-	rndis_resp_t		*r;
-	struct list_head	*act, *tmp;
-	
-	list_for_each_safe (act, tmp, 
-			    &(rndis_per_dev_params [configNr].resp_queue))
-	{
-		r = list_entry (act, rndis_resp_t, list);
-		if (r && r->buf == buf) {
-			list_del (&r->list);
-			kfree (r);
-		}
-	}
-}
-
-u8 *rndis_get_next_response (int configNr, u32 *length)
-{
-	rndis_resp_t		*r;
-	struct list_head 	*act, *tmp;
-	
-	if (!length) return NULL;
-	
-	list_for_each_safe (act, tmp, 
-			    &(rndis_per_dev_params [configNr].resp_queue))
-	{
-		r = list_entry (act, rndis_resp_t, list);
-		if (!r->send) {
-			r->send = 1;
-			*length = r->length;
-			return r->buf;
-		}
-	}
-	
-	return NULL;
-}
-
-static rndis_resp_t *rndis_add_response (int configNr, u32 length)
-{
-	rndis_resp_t	*r;
-	
-	r = kmalloc (sizeof (rndis_resp_t) + length, GFP_ATOMIC);
-	if (!r) return NULL;
-	
-	r->buf = (u8 *) (r + 1);
-	r->length = length;
-	r->send = 0;
-	
-	list_add_tail (&r->list, 
-		       &(rndis_per_dev_params [configNr].resp_queue));
-	return r;
-}
-
-int rndis_rm_hdr (u8 *buf, u32 *length)
-{
-	u32 i, messageLen, dataOffset, *tmp;
-	
-	tmp = (u32 *) buf; 
-
-	if (!buf || !length) return -1;
-	if (cpu_to_le32p(tmp++) != 1) return -1;
-	
-	messageLen = cpu_to_le32p(tmp++);
-	dataOffset = cpu_to_le32p(tmp++) + 8;
-
-	if (messageLen < dataOffset || messageLen > *length) return -1;
-	
-	for (i = dataOffset; i < messageLen; i++)
-		buf [i - dataOffset] = buf [i];
-		
-	*length = messageLen - dataOffset;
-	
-	return 0;
-}
-
-int rndis_proc_read (char *page, char **start, off_t off, int count, int *eof, 
-		     void *data)
-{
-	char *out = page;
-	int len;
-	rndis_params *param = (rndis_params *) data;
-	
-	out += snprintf (out, count, 
-			 "Config Nr. %d\n"
-			 "used      : %s\n"
-			 "state     : %s\n"
-			 "medium    : 0x%08X\n"
-			 "speed     : %d\n"
-			 "cable     : %s\n"
-			 "vendor ID : 0x%08X\n"
-			 "vendor    : %s\n", 
-			 param->confignr, (param->used) ? "y" : "n", 
-			 ({ char *s = "?";
-			 switch (param->state) {
-			 case RNDIS_UNINITIALIZED:
-				s = "RNDIS_UNINITIALIZED"; break;
-			 case RNDIS_INITIALIZED:
-				s = "RNDIS_INITIALIZED"; break;
-			 case RNDIS_DATA_INITIALIZED:
-				s = "RNDIS_DATA_INITIALIZED"; break;
-			}; s; }),
-			 param->medium, 
-			 (param->media_state) ? 0 : param->speed*100, 
-			 (param->media_state) ? "disconnected" : "connected",
-			 param->vendorID, param->vendorDescr);      
-	
-	len = out - page;
-	len -= off;
-	
-	if (len < count) {
-		*eof = 1;
-		if (len <= 0)
-			return 0;
-	} else
-		len = count;
-	
-	*start = page + off;
-	return len;
-}
-
-int rndis_proc_write (struct file *file, const char __user *buffer, 
-		      unsigned long count, void *data)
-{
-	rndis_params *p = data;
-	u32 speed = 0;
-	int i, fl_speed = 0;
-	
-	for (i = 0; i < count; i++) {
-		char c;
-		if (get_user(c, buffer))
-			return -EFAULT;
-		switch (c) {
-		case '0':
-		case '1':
-		case '2':
-		case '3':
-		case '4':
-		case '5':
-		case '6':
-		case '7':
-		case '8':
-		case '9':
-			fl_speed = 1;
-			speed = speed*10 + c - '0';
-			break;
-		case 'C':
-		case 'c':
-			rndis_signal_connect (p->confignr);
-			break;
-		case 'D':
-		case 'd':
-			rndis_signal_disconnect(p->confignr);
-			break;
-		default: 
-			if (fl_speed) p->speed = speed;
-			else DEBUG ("%c is not valid\n", c);
-			break;
-		}
-		
-		buffer++;
-	}
-	
-	return count;
-}
-
-int __init rndis_init (void)
-{
-	u8 i;
-	char name [4];
-
-	/* FIXME this should probably be /proc/driver/rndis,
-	 * and only if debugging is enabled
-	 */
-	
-	if (!(rndis_connect_dir =  proc_mkdir ("rndis", NULL))) {
-		printk (KERN_ERR "%s: couldn't create /proc/rndis entry", 
-			__FUNCTION__);
-		return -EIO;
-	}
-	
-	for (i = 0; i < RNDIS_MAX_CONFIGS; i++) {
-		sprintf (name, "%03d", i);
-		if (!(rndis_connect_state [i]
-				= create_proc_entry (name, 0660,
-						rndis_connect_dir))) 
-		{
-			DEBUG ("%s :remove entries", __FUNCTION__);
-			for (i--; i > 0; i--) {
-				sprintf (name, "%03d", i);
-				remove_proc_entry (name, rndis_connect_dir);
-			}
-			DEBUG ("\n");
-			
-			remove_proc_entry ("000", rndis_connect_dir);
-			remove_proc_entry ("rndis", NULL);
-			return -EIO;
-		}
-		rndis_connect_state [i]->nlink = 1;
-		rndis_connect_state [i]->write_proc = rndis_proc_write;
-		rndis_connect_state [i]->read_proc = rndis_proc_read;
-		rndis_connect_state [i]->data = (void *)
-				(rndis_per_dev_params + i);
-		rndis_per_dev_params [i].confignr = i;
-		rndis_per_dev_params [i].used = 0;
-		rndis_per_dev_params [i].state = RNDIS_UNINITIALIZED;
-		rndis_per_dev_params [i].media_state
-				= NDIS_MEDIA_STATE_DISCONNECTED;
-		INIT_LIST_HEAD (&(rndis_per_dev_params [i].resp_queue));
-	}
-	
-	return 0;
-}
-
-void rndis_exit (void)
-{
-	u8 i;
-	char name [4];
-	
-	for (i = 0; i < RNDIS_MAX_CONFIGS; i++) {
-		sprintf (name, "%03d", i);
-		remove_proc_entry (name, rndis_connect_dir);
-	}
-	remove_proc_entry ("rndis", NULL);
-	return;
-}
-
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/rndis.h linuxppc-2.6.9-dream/drivers/usb/gadget/rndis.h
--- linuxppc-2.6.9/drivers/usb/gadget/rndis.h	2004-10-18 23:53:43.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/rndis.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,348 +0,0 @@
-/* 
- * RNDIS	Definitions for Remote NDIS
- * 
- * Version:	$Id: rndis.h,v 1.15 2004/03/25 21:33:46 robert Exp $
- * 
- * Authors:	Benedikt Spranger, Pengutronix
- * 		Robert Schwebel, Pengutronix
- * 
- * 		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		version 2, as published by the Free Software Foundation. 
- * 
- *		This software was originally developed in conformance with
- *		Microsoft's Remote NDIS Specification License Agreement.
- */
-
-#ifndef _LINUX_RNDIS_H
-#define _LINUX_RNDIS_H
-
-#include "ndis.h"
-
-#define RNDIS_MAXIMUM_FRAME_SIZE	1518
-#define RNDIS_MAX_TOTAL_SIZE		1558
-
-/* Remote NDIS Versions */
-#define RNDIS_MAJOR_VERSION		1
-#define RNDIS_MINOR_VERSION		0
-
-/* Status Values */
-#define RNDIS_STATUS_SUCCESS		0x00000000U	/* Success           */
-#define RNDIS_STATUS_FAILURE		0xC0000001U	/* Unspecified error */
-#define RNDIS_STATUS_INVALID_DATA	0xC0010015U	/* Invalid data      */
-#define RNDIS_STATUS_NOT_SUPPORTED	0xC00000BBU	/* Unsupported request */
-#define RNDIS_STATUS_MEDIA_CONNECT	0x4001000BU	/* Device connected  */
-#define RNDIS_STATUS_MEDIA_DISCONNECT	0x4001000CU	/* Device disconnected */
-/* For all not specified status messages:
- * RNDIS_STATUS_Xxx -> NDIS_STATUS_Xxx 
- */
-
-/* Message Set for Connectionless (802.3) Devices */
-#define REMOTE_NDIS_INITIALIZE_MSG	0x00000002U	/* Initialize device */
-#define REMOTE_NDIS_HALT_MSG		0x00000003U
-#define REMOTE_NDIS_QUERY_MSG		0x00000004U
-#define REMOTE_NDIS_SET_MSG		0x00000005U
-#define REMOTE_NDIS_RESET_MSG		0x00000006U
-#define REMOTE_NDIS_INDICATE_STATUS_MSG	0x00000007U
-#define REMOTE_NDIS_KEEPALIVE_MSG	0x00000008U
-
-/* Message completion */
-#define REMOTE_NDIS_INITIALIZE_CMPLT	0x80000002U
-#define REMOTE_NDIS_QUERY_CMPLT		0x80000004U
-#define REMOTE_NDIS_SET_CMPLT		0x80000005U
-#define REMOTE_NDIS_RESET_CMPLT		0x80000006U
-#define REMOTE_NDIS_KEEPALIVE_CMPLT	0x80000008U
-
-/* Device Flags */
-#define RNDIS_DF_CONNECTIONLESS		0x00000001U
-#define RNDIS_DF_CONNECTION_ORIENTED	0x00000002U
-
-#define RNDIS_MEDIUM_802_3		0x00000000U
-
-/* from drivers/net/sk98lin/h/skgepnmi.h */
-#define OID_PNP_CAPABILITIES			0xFD010100
-#define OID_PNP_SET_POWER			0xFD010101
-#define OID_PNP_QUERY_POWER			0xFD010102
-#define OID_PNP_ADD_WAKE_UP_PATTERN		0xFD010103
-#define OID_PNP_REMOVE_WAKE_UP_PATTERN		0xFD010104
-#define OID_PNP_ENABLE_WAKE_UP			0xFD010106
-
-
-/* supported OIDs */
-static const u32 oid_supported_list [] = 
-{
-	/* the general stuff */
-	OID_GEN_SUPPORTED_LIST,
-	OID_GEN_HARDWARE_STATUS,
-	OID_GEN_MEDIA_SUPPORTED,
-	OID_GEN_MEDIA_IN_USE,
-	OID_GEN_MAXIMUM_FRAME_SIZE,
-	OID_GEN_LINK_SPEED,
-	OID_GEN_TRANSMIT_BLOCK_SIZE,
-	OID_GEN_RECEIVE_BLOCK_SIZE,
-	OID_GEN_VENDOR_ID,
-	OID_GEN_VENDOR_DESCRIPTION,
-	OID_GEN_VENDOR_DRIVER_VERSION,
-	OID_GEN_CURRENT_PACKET_FILTER,
-	OID_GEN_MAXIMUM_TOTAL_SIZE,
-	OID_GEN_MEDIA_CONNECT_STATUS,
-	OID_GEN_PHYSICAL_MEDIUM,
-#if 0
-	OID_GEN_RNDIS_CONFIG_PARAMETER,
-#endif
-	
-	/* the statistical stuff */
-	OID_GEN_XMIT_OK,
-	OID_GEN_RCV_OK,
-	OID_GEN_XMIT_ERROR,
-	OID_GEN_RCV_ERROR,
-	OID_GEN_RCV_NO_BUFFER,
-#ifdef	RNDIS_OPTIONAL_STATS
-	OID_GEN_DIRECTED_BYTES_XMIT,
-	OID_GEN_DIRECTED_FRAMES_XMIT,
-	OID_GEN_MULTICAST_BYTES_XMIT,
-	OID_GEN_MULTICAST_FRAMES_XMIT,
-	OID_GEN_BROADCAST_BYTES_XMIT,
-	OID_GEN_BROADCAST_FRAMES_XMIT,
-	OID_GEN_DIRECTED_BYTES_RCV,
-	OID_GEN_DIRECTED_FRAMES_RCV,
-	OID_GEN_MULTICAST_BYTES_RCV,
-	OID_GEN_MULTICAST_FRAMES_RCV,
-	OID_GEN_BROADCAST_BYTES_RCV,
-	OID_GEN_BROADCAST_FRAMES_RCV,
-	OID_GEN_RCV_CRC_ERROR,
-	OID_GEN_TRANSMIT_QUEUE_LENGTH,
-#endif	/* RNDIS_OPTIONAL_STATS */
-
-    	/* mandatory 802.3 */
-	/* the general stuff */
-	OID_802_3_PERMANENT_ADDRESS,
-	OID_802_3_CURRENT_ADDRESS,
-	OID_802_3_MULTICAST_LIST,
-	OID_802_3_MAC_OPTIONS,
-	OID_802_3_MAXIMUM_LIST_SIZE,
-	
-	/* the statistical stuff */
-	OID_802_3_RCV_ERROR_ALIGNMENT,
-	OID_802_3_XMIT_ONE_COLLISION,
-	OID_802_3_XMIT_MORE_COLLISIONS,
-#ifdef	RNDIS_OPTIONAL_STATS
-	OID_802_3_XMIT_DEFERRED,
-	OID_802_3_XMIT_MAX_COLLISIONS,
-	OID_802_3_RCV_OVERRUN,
-	OID_802_3_XMIT_UNDERRUN,
-	OID_802_3_XMIT_HEARTBEAT_FAILURE,
-	OID_802_3_XMIT_TIMES_CRS_LOST,
-	OID_802_3_XMIT_LATE_COLLISIONS,
-#endif	/* RNDIS_OPTIONAL_STATS */
-
-#ifdef	RNDIS_PM
-	/* PM and wakeup are mandatory for USB: */
-
-	/* power management */
-	OID_PNP_CAPABILITIES,
-	OID_PNP_QUERY_POWER,
-	OID_PNP_SET_POWER,
-
-	/* wake up host */
-	OID_PNP_ENABLE_WAKE_UP,
-	OID_PNP_ADD_WAKE_UP_PATTERN,
-	OID_PNP_REMOVE_WAKE_UP_PATTERN,
-#endif
-};
-
-
-typedef struct rndis_init_msg_type 
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	RequestID;
-	u32	MajorVersion;
-	u32	MinorVersion;
-	u32	MaxTransferSize;
-} rndis_init_msg_type;
-
-typedef struct rndis_init_cmplt_type
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	RequestID;
-	u32	Status;
-	u32	MajorVersion;
-	u32	MinorVersion;
-	u32	DeviceFlags;
-	u32	Medium;
-	u32	MaxPacketsPerTransfer;
-	u32	MaxTransferSize;
-	u32	PacketAlignmentFactor;
-	u32	AFListOffset;
-	u32	AFListSize;
-} rndis_init_cmplt_type;
-
-typedef struct rndis_halt_msg_type
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	RequestID;
-} rndis_halt_msg_type;
-
-typedef struct rndis_query_msg_type
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	RequestID;
-	u32	OID;
-	u32	InformationBufferLength;
-	u32	InformationBufferOffset;
-	u32	DeviceVcHandle;
-} rndis_query_msg_type;
-
-typedef struct rndis_query_cmplt_type
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	RequestID;
-	u32	Status;
-	u32	InformationBufferLength;
-	u32	InformationBufferOffset;
-} rndis_query_cmplt_type;
-
-typedef struct rndis_set_msg_type
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	RequestID;
-	u32	OID;
-	u32	InformationBufferLength;
-	u32	InformationBufferOffset;
-	u32	DeviceVcHandle;
-} rndis_set_msg_type;
-
-typedef struct rndis_set_cmplt_type
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	RequestID;
-	u32	Status;
-} rndis_set_cmplt_type;
-
-typedef struct rndis_reset_msg_type
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	Reserved;
-} rndis_reset_msg_type;
-
-typedef struct rndis_reset_cmplt_type
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	Status;
-	u32	AddressingReset;
-} rndis_reset_cmplt_type;
-
-typedef struct rndis_indicate_status_msg_type
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	Status;
-	u32	StatusBufferLength;
-	u32	StatusBufferOffset;
-} rndis_indicate_status_msg_type;
-
-typedef struct rndis_keepalive_msg_type
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	RequestID;
-} rndis_keepalive_msg_type;
-
-typedef struct rndis_keepalive_cmplt_type
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	RequestID;
-	u32	Status;
-} rndis_keepalive_cmplt_type;
-
-struct rndis_packet_msg_type
-{
-	u32	MessageType;
-	u32	MessageLength;
-	u32	DataOffset;
-	u32	DataLength;
-	u32	OOBDataOffset;
-	u32	OOBDataLength;
-	u32	NumOOBDataElements;
-	u32	PerPacketInfoOffset;
-	u32	PerPacketInfoLength;
-	u32	VcHandle;
-	u32	Reserved;
-};
-
-struct rndis_config_parameter
-{
-	u32	ParameterNameOffset;
-	u32	ParameterNameLength;
-	u32	ParameterType;
-	u32	ParameterValueOffset;
-	u32	ParameterValueLength;
-};
-
-/* implementation specific */
-enum rndis_state
-{
-	RNDIS_UNINITIALIZED,
-	RNDIS_INITIALIZED,
-	RNDIS_DATA_INITIALIZED,
-};
-
-typedef struct rndis_resp_t
-{
-	struct list_head	list;
-	u8			*buf;
-	u32			length;
-	int			send;
-} rndis_resp_t;
-
-typedef struct rndis_params
-{
-	u8			confignr;
-	int			used;
-	enum rndis_state	state;
-	u32			filter;
-	u32			medium;
-	u32			speed;
-	u32			media_state;
-	const u8		*host_mac;
-	struct net_device 	*dev;
-	struct net_device_stats *stats;
-	u32			vendorID;
-	const char		*vendorDescr;
-	int 			(*ack) (struct net_device *);
-	struct list_head	resp_queue;
-} rndis_params;
-
-/* RNDIS Message parser and other useless functions */
-int  rndis_msg_parser (u8 configNr, u8 *buf);
-int  rndis_register (int (*rndis_control_ack) (struct net_device *));
-void rndis_deregister (int configNr);
-int  rndis_set_param_dev (u8 configNr, struct net_device *dev,
-			 struct net_device_stats *stats);
-int  rndis_set_param_vendor (u8 configNr, u32 vendorID, 
-			    const char *vendorDescr);
-int  rndis_set_param_medium (u8 configNr, u32 medium, u32 speed);
-void rndis_add_hdr (struct sk_buff *skb);
-int  rndis_rm_hdr (u8 *buf, u32 *length);
-u8   *rndis_get_next_response (int configNr, u32 *length);
-void rndis_free_response (int configNr, u8 *buf);
-
-int  rndis_signal_connect (int configNr);
-int  rndis_signal_disconnect (int configNr);
-int  rndis_state (int configNr);
-extern void rndis_set_host_mac (int configNr, const u8 *addr);
-
-int __init rndis_init (void);
-void rndis_exit (void);
-
-#endif  /* _LINUX_RNDIS_H */
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/serial.c linuxppc-2.6.9-dream/drivers/usb/gadget/serial.c
--- linuxppc-2.6.9/drivers/usb/gadget/serial.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/serial.c	2005-09-19 21:40:05.000000000 +0200
@@ -33,6 +33,7 @@
 #include <linux/uts.h>
 #include <linux/version.h>
 #include <linux/wait.h>
+#include <linux/list.h>
 #include <linux/proc_fs.h>
 #include <linux/device.h>
 #include <linux/tty.h>
@@ -48,8 +49,6 @@
 #include <linux/usb_ch9.h>
 #include <linux/usb_gadget.h>
 
-#include "gadget_chips.h"
-
 
 /* Wait Cond */
 
@@ -125,8 +124,8 @@
 
 /* Defines */
 
-#define GS_VERSION_STR			"v1.0"
-#define GS_VERSION_NUM			0x0100
+#define GS_VERSION_STR			"v0.1"
+#define GS_VERSION_NUM			0x0001
 
 #define GS_LONG_NAME			"Gadget Serial"
 #define GS_SHORT_NAME			"g_serial"
@@ -156,8 +155,9 @@
 
 #define GS_CLOSE_TIMEOUT		15
 
-/* debug settings */
+/* debug macro */
 #if G_SERIAL_DEBUG
+
 static int debug = G_SERIAL_DEBUG;
 
 #define gs_debug(format, arg...) \
@@ -175,6 +175,129 @@
 #endif /* G_SERIAL_DEBUG */
 
 
+/* USB Controllers */
+
+/*
+ * NetChip 2280, PCI based.
+ *
+ * This has half a dozen configurable endpoints, four with dedicated
+ * DMA channels to manage their FIFOs.  It supports high speed.
+ * Those endpoints can be arranged in any desired configuration.
+ */
+#ifdef	CONFIG_USB_GADGET_NET2280
+#define CHIP				"net2280"
+#define EP0_MAXPACKET			64
+static const char EP_OUT_NAME[] =	"ep-a";
+#define EP_OUT_NUM			2
+static const char EP_IN_NAME[] =	"ep-b";
+#define EP_IN_NUM			2
+#define HIGHSPEED
+#define SELFPOWER			USB_CONFIG_ATT_SELFPOWER
+
+extern int net2280_set_fifo_mode(struct usb_gadget *gadget, int mode);
+
+static inline void hw_optimize(struct usb_gadget *gadget)
+{
+	/* we can have bigger ep-a/ep-b fifos (2KB each, 4 packets
+	 * for highspeed bulk) because we're not using ep-c/ep-d.
+	 */
+	net2280_set_fifo_mode (gadget, 1);
+}
+#endif
+
+
+/*
+ * PXA-2xx UDC:  widely used in second gen Linux-capable PDAs.
+ *
+ * This has fifteen fixed-function full speed endpoints, and it
+ * can support all USB transfer types.
+ *
+ * These supports three or four configurations, with fixed numbers.
+ * The hardware interprets SET_INTERFACE, net effect is that you
+ * can't use altsettings or reset the interfaces independently.
+ * So stick to a single interface.
+ */
+#ifdef	CONFIG_USB_GADGET_PXA2XX
+#define CHIP				"pxa2xx"
+#define EP0_MAXPACKET			16
+static const char EP_OUT_NAME[] =	"ep2out-bulk";
+#define EP_OUT_NUM			2
+static const char EP_IN_NAME[] =	"ep1in-bulk";
+#define EP_IN_NUM			1
+#define SELFPOWER 			USB_CONFIG_ATT_SELFPOWER
+
+/* no hw optimizations to apply */
+#define hw_optimize(g)			do {} while (0)
+#endif
+
+
+/*
+ * SA-1100 UDC:  widely used in first gen Linux-capable PDAs.
+ *
+ * This has only two fixed function endpoints, which can only
+ * be used for bulk (or interrupt) transfers.  (Plus control.)
+ *
+ * Since it can't flush its TX fifos without disabling the UDC,
+ * the current configuration or altsettings can't change except
+ * in special situations.  So this is a case of "choose it right
+ * during enumeration" ...
+ */
+#ifdef	CONFIG_USB_GADGET_SA1100
+#define CHIP				"sa1100"
+#define EP0_MAXPACKET			8
+static const char EP_OUT_NAME[] =	"ep1out-bulk";
+#define EP_OUT_NUM			1
+static const char EP_IN_NAME [] =	"ep2in-bulk";
+#define EP_IN_NUM			2
+#define SELFPOWER			USB_CONFIG_ATT_SELFPOWER
+
+/* no hw optimizations to apply */
+#define hw_optimize(g)			do {} while (0)
+#endif
+
+
+/*
+ * Toshiba TC86C001 ("Goku-S") UDC
+ *
+ * This has three semi-configurable full speed bulk/interrupt endpoints.
+ */
+#ifdef	CONFIG_USB_GADGET_GOKU
+#define CHIP				"goku"
+#define DRIVER_VERSION_NUM		0x0116
+#define EP0_MAXPACKET			8
+static const char EP_OUT_NAME [] =	"ep1-bulk";
+#define EP_OUT_NUM			1
+static const char EP_IN_NAME [] =	"ep2-bulk";
+#define EP_IN_NUM			2
+#define SELFPOWER			USB_CONFIG_ATT_SELFPOWER
+
+/* no hw optimizations to apply */
+#define hw_optimize(g)			do {} while (0)
+#endif
+
+/*
+ * USB Controller Defaults
+ */
+#ifndef EP0_MAXPACKET
+#error Configure some USB peripheral controller for g_serial!
+#endif
+
+#ifndef SELFPOWER
+/* default: say we rely on bus power */
+#define SELFPOWER   			0
+/* else value must be USB_CONFIG_ATT_SELFPOWER */
+#endif
+
+#ifndef	MAX_USB_POWER
+/* any hub supports this steady state bus power consumption */
+#define MAX_USB_POWER			100	/* mA */
+#endif
+
+#ifndef	WAKEUP
+/* default: this driver won't do remote wakeup */
+#define WAKEUP				0
+/* else value must be USB_CONFIG_ATT_WAKEUP */
+#endif
 
 /* Thanks to NetChip Technologies for donating this product ID.
  *
@@ -293,17 +416,11 @@
 static unsigned int gs_buf_get(struct gs_buf *gb, char *buf,
 	unsigned int count);
 
-/* external functions */
-extern int net2280_set_fifo_mode(struct usb_gadget *gadget, int mode);
-
 
 /* Globals */
 
 static struct gs_dev *gs_device;
 
-static const char *EP_IN_NAME;
-static const char *EP_OUT_NAME;
-
 static struct semaphore	gs_open_close_sem[GS_NUM_PORTS];
 
 static unsigned int read_q_size = GS_DEFAULT_READ_Q_SIZE;
@@ -333,7 +450,7 @@
 
 /* gadget driver struct */
 static struct usb_gadget_driver gs_gadget_driver = {
-#ifdef CONFIG_USB_GADGET_DUALSPEED
+#ifdef HIGHSPEED
 	.speed =		USB_SPEED_HIGH,
 #else
 	.speed =		USB_SPEED_FULL,
@@ -360,9 +477,8 @@
 #define GS_CONFIG_STR_ID	4
 
 /* static strings, in iso 8859/1 */
-static char manufacturer[40];
 static struct usb_string gs_strings[] = {
-	{ GS_MANUFACTURER_STR_ID, manufacturer },
+	{ GS_MANUFACTURER_STR_ID, UTS_SYSNAME " " UTS_RELEASE " with " CHIP },
 	{ GS_PRODUCT_STR_ID, GS_LONG_NAME },
 	{ GS_SERIAL_STR_ID, "0" },
 	{ GS_CONFIG_STR_ID, "Bulk" },
@@ -374,13 +490,15 @@
 	.strings =		gs_strings,
 };
 
-static struct usb_device_descriptor gs_device_desc = {
+static const struct usb_device_descriptor gs_device_desc = {
 	.bLength =		USB_DT_DEVICE_SIZE,
 	.bDescriptorType =	USB_DT_DEVICE,
 	.bcdUSB =		__constant_cpu_to_le16(0x0200),
 	.bDeviceClass =		USB_CLASS_VENDOR_SPEC,
+	.bMaxPacketSize0 =	EP0_MAXPACKET,
 	.idVendor =		__constant_cpu_to_le16(GS_VENDOR_ID),
 	.idProduct =		__constant_cpu_to_le16(GS_PRODUCT_ID),
+	.bcdDevice =		__constant_cpu_to_le16(GS_VERSION_NUM),
 	.iManufacturer =	GS_MANUFACTURER_STR_ID,
 	.iProduct =		GS_PRODUCT_STR_ID,
 	.iSerialNumber =	GS_SERIAL_STR_ID,
@@ -394,8 +512,8 @@
 	.bNumInterfaces =	GS_NUM_INTERFACES,
 	.bConfigurationValue =	GS_BULK_CONFIG_ID,
 	.iConfiguration =	GS_CONFIG_STR_ID,
-	.bmAttributes =		USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
-	.bMaxPower =		1,
+	.bmAttributes =		USB_CONFIG_ATT_ONE | SELFPOWER | WAKEUP,
+	.bMaxPower =		(MAX_USB_POWER + 1) / 2,
 };
 
 static const struct usb_interface_descriptor gs_interface_desc = {
@@ -406,41 +524,46 @@
 	.iInterface =		GS_CONFIG_STR_ID,
 };
 
-static struct usb_endpoint_descriptor gs_fullspeed_in_desc = {
+static const struct usb_endpoint_descriptor gs_fullspeed_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
-	.bEndpointAddress =	USB_DIR_IN,
+	.bEndpointAddress =	EP_IN_NUM | USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16(64),
 };
 
-static struct usb_endpoint_descriptor gs_fullspeed_out_desc = {
+static const struct usb_endpoint_descriptor gs_fullspeed_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
-	.bEndpointAddress =	USB_DIR_OUT,
+	.bEndpointAddress =	EP_OUT_NUM | USB_DIR_OUT,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16(64),
 };
 
-static struct usb_endpoint_descriptor gs_highspeed_in_desc = {
+static const struct usb_endpoint_descriptor gs_highspeed_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	EP_IN_NUM | USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 	.wMaxPacketSize =	__constant_cpu_to_le16(512),
 };
 
-static struct usb_endpoint_descriptor gs_highspeed_out_desc = {
+static const struct usb_endpoint_descriptor gs_highspeed_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	EP_OUT_NUM | USB_DIR_OUT,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 	.wMaxPacketSize =	__constant_cpu_to_le16(512),
 };
 
-#ifdef CONFIG_USB_GADGET_DUALSPEED
-static struct usb_qualifier_descriptor gs_qualifier_desc = {
+#ifdef HIGHSPEED
+static const struct usb_qualifier_descriptor gs_qualifier_desc = {
 	.bLength =		sizeof(struct usb_qualifier_descriptor),
 	.bDescriptorType =	USB_DT_DEVICE_QUALIFIER,
 	.bcdUSB =		__constant_cpu_to_le16 (0x0200),
 	.bDeviceClass =		USB_CLASS_VENDOR_SPEC,
 	/* assumes ep0 uses the same value for both speeds ... */
+	.bMaxPacketSize0 =	EP0_MAXPACKET,
 	.bNumConfigurations =	GS_NUM_CONFIGS,
 };
 #endif
@@ -451,18 +574,16 @@
 MODULE_AUTHOR("Al Borchers");
 MODULE_LICENSE("GPL");
 
-#if G_SERIAL_DEBUG
-module_param(debug, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(debug, "Enable debugging, 0=off, 1=on, larger values for more messages");
-#endif
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, "Enable debugging, 0=off, 1=on");
 
-module_param(read_q_size, int, 0);
+MODULE_PARM(read_q_size, "i");
 MODULE_PARM_DESC(read_q_size, "Read request queue size, default=32");
 
-module_param(write_q_size, int, 0);
+MODULE_PARM(write_q_size, "i");
 MODULE_PARM_DESC(write_q_size, "Write request queue size, default=32");
 
-module_param(write_buf_size, int, 0);
+MODULE_PARM(write_buf_size, "i");
 MODULE_PARM_DESC(write_buf_size, "Write buffer size, default=8192");
 
 module_init(gs_module_init);
@@ -1260,81 +1381,18 @@
 static int gs_bind(struct usb_gadget *gadget)
 {
 	int ret;
-	struct usb_ep *ep;
 	struct gs_dev *dev;
 
-	usb_ep_autoconfig_reset(gadget);
-
-	ep = usb_ep_autoconfig(gadget, &gs_fullspeed_in_desc);
-	if (!ep)
-		goto autoconf_fail;
-	EP_IN_NAME = ep->name;
-	ep->driver_data = ep;	/* claim the endpoint */
-
-	ep = usb_ep_autoconfig(gadget, &gs_fullspeed_out_desc);
-	if (!ep)
-		goto autoconf_fail;
-	EP_OUT_NAME = ep->name;
-	ep->driver_data = ep;	/* claim the endpoint */
-
-	/* device specific bcdDevice value in device descriptor */
-	if (gadget_is_net2280(gadget)) {
-		gs_device_desc.bcdDevice =
-			__constant_cpu_to_le16(GS_VERSION_NUM|0x0001);
-	} else if (gadget_is_pxa(gadget)) {
-		gs_device_desc.bcdDevice =
-			__constant_cpu_to_le16(GS_VERSION_NUM|0x0002);
-	} else if (gadget_is_sh(gadget)) {
-		gs_device_desc.bcdDevice =
-			__constant_cpu_to_le16(GS_VERSION_NUM|0x0003);
-	} else if (gadget_is_sa1100(gadget)) {
-		gs_device_desc.bcdDevice =
-			__constant_cpu_to_le16(GS_VERSION_NUM|0x0004);
-	} else if (gadget_is_goku(gadget)) {
-		gs_device_desc.bcdDevice =
-			__constant_cpu_to_le16(GS_VERSION_NUM|0x0005);
-	} else if (gadget_is_mq11xx(gadget)) {
-		gs_device_desc.bcdDevice =
-			__constant_cpu_to_le16(GS_VERSION_NUM|0x0006);
-	} else if (gadget_is_omap(gadget)) {
-		gs_device_desc.bcdDevice =
-			__constant_cpu_to_le16(GS_VERSION_NUM|0x0007);
-	} else if (gadget_is_lh7a40x(gadget)) {
-		gs_device_desc.bcdDevice =
-			__constant_cpu_to_le16(GS_VERSION_NUM|0x0008);
-	} else {
-		printk(KERN_WARNING "gs_bind: controller '%s' not recognized\n",
-			gadget->name);
-		/* unrecognized, but safe unless bulk is REALLY quirky */
-		gs_device_desc.bcdDevice =
-			__constant_cpu_to_le16(GS_VERSION_NUM|0x0099);
-	}
-
-	gs_device_desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
-#ifdef CONFIG_USB_GADGET_DUALSPEED
-	/* assume ep0 uses the same packet size for both speeds */
-	gs_qualifier_desc.bMaxPacketSize0 = gs_device_desc.bMaxPacketSize0;
-	/* assume endpoints are dual-speed */
-	gs_highspeed_in_desc.bEndpointAddress =
-		gs_fullspeed_in_desc.bEndpointAddress;
-	gs_highspeed_out_desc.bEndpointAddress =
-		gs_fullspeed_out_desc.bEndpointAddress;
-#endif /* CONFIG_USB_GADGET_DUALSPEED */
-
-	usb_gadget_set_selfpowered(gadget);
-
 	gs_device = dev = kmalloc(sizeof(struct gs_dev), GFP_KERNEL);
 	if (dev == NULL)
 		return -ENOMEM;
 
-	snprintf (manufacturer, sizeof(manufacturer),
-		UTS_SYSNAME " " UTS_RELEASE " with %s", gadget->name);
+	set_gadget_data(gadget, dev);
 
 	memset(dev, 0, sizeof(struct gs_dev));
 	dev->dev_gadget = gadget;
 	spin_lock_init(&dev->dev_lock);
 	INIT_LIST_HEAD(&dev->dev_req_list);
-	set_gadget_data(gadget, dev);
 
 	if ((ret=gs_alloc_ports(dev, GFP_KERNEL)) != 0) {
 		printk(KERN_ERR "gs_bind: cannot allocate ports\n");
@@ -1357,10 +1415,6 @@
 		GS_LONG_NAME, GS_VERSION_STR);
 
 	return 0;
-
-autoconf_fail:
-	printk(KERN_ERR "gs_bind: cannot autoconfigure on %s\n", gadget->name);
-	return -ENODEV;
 }
 
 /*
@@ -1416,17 +1470,15 @@
 			memcpy(req->buf, &gs_device_desc, ret);
 			break;
 
-#ifdef CONFIG_USB_GADGET_DUALSPEED
+#ifdef HIGHSPEED
 		case USB_DT_DEVICE_QUALIFIER:
-			if (!gadget->is_dualspeed)
-				break;
 			ret = min(ctrl->wLength,
 				(u16)sizeof(struct usb_qualifier_descriptor));
 			memcpy(req->buf, &gs_qualifier_desc, ret);
 			break;
 
 		case USB_DT_OTHER_SPEED_CONFIG:
-#endif /* CONFIG_USB_GADGET_DUALSPEED */
+#endif /* HIGHSPEED */
 		case USB_DT_CONFIG:
 			ret = gs_build_config_desc(req->buf, gadget->speed,
 				ctrl->wValue >> 8, ctrl->wValue & 0xff);
@@ -1500,8 +1552,6 @@
 	/* respond with data transfer before status phase? */
 	if (ret >= 0) {
 		req->length = ret;
-		req->zero = ret < ctrl->wLength
-				&& (ret % gadget->ep0->maxpacket) == 0;
 		ret = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);
 		if (ret < 0) {
 			printk(KERN_ERR
@@ -1590,9 +1640,7 @@
 	if (config != GS_BULK_CONFIG_ID)
 		return -EINVAL;
 
-	/* device specific optimizations */
-	if (gadget_is_net2280(gadget))
-		net2280_set_fifo_mode(gadget, 1);
+	hw_optimize(gadget);
 
 	gadget_for_each_ep(ep, gadget) {
 
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/usbstring.c linuxppc-2.6.9-dream/drivers/usb/gadget/usbstring.c
--- linuxppc-2.6.9/drivers/usb/gadget/usbstring.c	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/usbstring.c	2005-09-19 21:40:05.000000000 +0200
@@ -12,7 +12,6 @@
 #include <linux/list.h>
 #include <linux/string.h>
 #include <linux/device.h>
-#include <linux/init.h>
 
 #include <linux/usb_ch9.h>
 #include <linux/usb_gadget.h>
diff -Naur linuxppc-2.6.9/drivers/usb/gadget/zero.c linuxppc-2.6.9-dream/drivers/usb/gadget/zero.c
--- linuxppc-2.6.9/drivers/usb/gadget/zero.c	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/gadget/zero.c	2005-09-19 21:40:05.000000000 +0200
@@ -89,12 +89,10 @@
 #include <linux/usb_ch9.h>
 #include <linux/usb_gadget.h>
 
-#include "gadget_chips.h"
-
 
 /*-------------------------------------------------------------------------*/
 
-#define DRIVER_VERSION		"St Patrick's Day 2004"
+#define DRIVER_VERSION		"Bastille Day 2003"
 
 static const char shortname [] = "zero";
 static const char longname [] = "Gadget Zero";
@@ -107,12 +105,100 @@
 /*
  * driver assumes self-powered hardware, and
  * has no way for users to trigger remote wakeup.
+ */
+
+/*
+ * hardware-specific configuration, controlled by which device
+ * controller driver was configured.
+ *
+ * CHIP ... hardware identifier
+ * DRIVER_VERSION_NUM ... alerts the host side driver to differences
+ * EP_*_NAME ... which endpoints do we use for which purpose?
+ * EP_*_NUM ... numbers for them (often limited by hardware)
+ *
+ * add other defines for other portability issues, like hardware that
+ * for some reason doesn't handle full speed bulk maxpacket of 64.
+ */
+
+/*
+ * DRIVER_VERSION_NUM 0x0000 (?):  Martin Diehl's ezusb an21/fx code
+ */
+
+/*
+ * NetChip 2280, PCI based.
+ *
+ * This has half a dozen configurable endpoints, four with dedicated
+ * DMA channels to manage their FIFOs.  It supports high speed.
+ * Those endpoints can be arranged in any desired configuration.
+ */
+#if defined(CONFIG_USB_GADGET_NET2280) || defined(CONFIG_USB_GADGET_DUMMY_HCD)
+#define CHIP			"net2280"
+#define DRIVER_VERSION_NUM	0x0101
+static const char EP_OUT_NAME [] = "ep-a";
+#define EP_OUT_NUM	2
+static const char EP_IN_NAME [] = "ep-b";
+#define EP_IN_NUM	2
+#endif
+
+/*
+ * PXA-2xx UDC:  widely used in second gen Linux-capable PDAs.
+ *
+ * This has fifteen fixed-function full speed endpoints, and it
+ * can support all USB transfer types.
+ *
+ * These supports three or four configurations, with fixed numbers.
+ * The hardware interprets SET_INTERFACE, net effect is that you
+ * can't use altsettings or reset the interfaces independently.
+ * So stick to a single interface.
+ */
+#ifdef	CONFIG_USB_GADGET_PXA2XX
+#define CHIP			"pxa2xx"
+#define DRIVER_VERSION_NUM	0x0103
+static const char EP_OUT_NAME [] = "ep12out-bulk";
+#define EP_OUT_NUM	12
+static const char EP_IN_NAME [] = "ep11in-bulk";
+#define EP_IN_NUM	11
+#endif
+
+/*
+ * SA-1100 UDC:  widely used in first gen Linux-capable PDAs.
+ *
+ * This has only two fixed function endpoints, which can only
+ * be used for bulk (or interrupt) transfers.  (Plus control.)
  *
- * this version autoconfigures as much as possible,
- * which is reasonable for most "bulk-only" drivers.
+ * Since it can't flush its TX fifos without disabling the UDC,
+ * the current configuration or altsettings can't change except
+ * in special situations.  So this is a case of "choose it right
+ * during enumeration" ...
  */
-static const char *EP_IN_NAME;		/* source */
-static const char *EP_OUT_NAME;		/* sink */
+#ifdef	CONFIG_USB_GADGET_SA1100
+#define CHIP			"sa1100"
+#define DRIVER_VERSION_NUM	0x0105
+static const char EP_OUT_NAME [] = "ep1out-bulk";
+#define EP_OUT_NUM	1
+static const char EP_IN_NAME [] = "ep2in-bulk";
+#define EP_IN_NUM	2
+#endif
+
+/*
+ * Toshiba TC86C001 ("Goku-S") UDC
+ *
+ * This has three semi-configurable full speed bulk/interrupt endpoints.
+ */
+#ifdef	CONFIG_USB_GADGET_GOKU
+#define CHIP			"goku"
+#define DRIVER_VERSION_NUM	0x0106
+static const char EP_OUT_NAME [] = "ep1-bulk";
+#define EP_OUT_NUM	1
+static const char EP_IN_NAME [] = "ep2-bulk";
+#define EP_IN_NUM	2
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+#ifndef EP_OUT_NUM
+#	error Configure some USB peripheral controller driver!
+#endif
 
 /*-------------------------------------------------------------------------*/
 
@@ -130,28 +216,26 @@
 	 */
 	u8			config;
 	struct usb_ep		*in_ep, *out_ep;
-
-	/* autoresume timer */
-	struct timer_list	resume;
 };
 
 #define xprintk(d,level,fmt,args...) \
 	dev_printk(level , &(d)->gadget->dev , fmt , ## args)
 
 #ifdef DEBUG
-#define DBG(dev,fmt,args...) \
+#undef DEBUG
+#define DEBUG(dev,fmt,args...) \
 	xprintk(dev , KERN_DEBUG , fmt , ## args)
 #else
-#define DBG(dev,fmt,args...) \
+#define DEBUG(dev,fmt,args...) \
 	do { } while (0)
 #endif /* DEBUG */
 
 #ifdef VERBOSE
-#define VDBG	DBG
+#define VDEBUG	DEBUG
 #else
-#define VDBG(dev,fmt,args...) \
+#define VDEBUG(dev,fmt,args...) \
 	do { } while (0)
-#endif /* VERBOSE */
+#endif /* DEBUG */
 
 #define ERROR(dev,fmt,args...) \
 	xprintk(dev , KERN_ERR , fmt , ## args)
@@ -170,12 +254,6 @@
 module_param (qlen, uint, S_IRUGO|S_IWUSR);
 module_param (pattern, uint, S_IRUGO|S_IWUSR);
 
-/*
- * if it's nonzero, autoresume says how many seconds to wait
- * before trying to wake up the host after suspend.
- */
-static unsigned autoresume = 0;
-module_param (autoresume, uint, 0);
 
 /*
  * Normally the "loopback" configuration is second (index 1) so
@@ -194,13 +272,8 @@
  * DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
  * Instead:  allocate your own, using normal USB-IF procedures.
  */
-#ifndef	CONFIG_USB_ZERO_HNPTEST
 #define DRIVER_VENDOR_NUM	0x0525		/* NetChip */
 #define DRIVER_PRODUCT_NUM	0xa4a0		/* Linux-USB "Gadget Zero" */
-#else
-#define DRIVER_VENDOR_NUM	0x1a0a		/* OTG test device IDs */
-#define DRIVER_PRODUCT_NUM	0xbadd
-#endif
 
 /*-------------------------------------------------------------------------*/
 
@@ -232,13 +305,14 @@
 
 	.idVendor =		__constant_cpu_to_le16 (DRIVER_VENDOR_NUM),
 	.idProduct =		__constant_cpu_to_le16 (DRIVER_PRODUCT_NUM),
+	.bcdDevice =		__constant_cpu_to_le16 (DRIVER_VERSION_NUM),
 	.iManufacturer =	STRING_MANUFACTURER,
 	.iProduct =		STRING_PRODUCT,
 	.iSerialNumber =	STRING_SERIAL,
 	.bNumConfigurations =	2,
 };
 
-static struct usb_config_descriptor
+static const struct usb_config_descriptor
 source_sink_config = {
 	.bLength =		sizeof source_sink_config,
 	.bDescriptorType =	USB_DT_CONFIG,
@@ -251,7 +325,7 @@
 	.bMaxPower =		1,	/* self-powered */
 };
 
-static struct usb_config_descriptor
+static const struct usb_config_descriptor
 loopback_config = {
 	.bLength =		sizeof loopback_config,
 	.bDescriptorType =	USB_DT_CONFIG,
@@ -264,14 +338,6 @@
 	.bMaxPower =		1,	/* self-powered */
 };
 
-static struct usb_otg_descriptor
-otg_descriptor = {
-	.bLength =		sizeof otg_descriptor,
-	.bDescriptorType =	USB_DT_OTG,
-
-	.bmAttributes =		USB_OTG_SRP,
-};
-
 /* one interface in each configuration */
 
 static const struct usb_interface_descriptor
@@ -296,38 +362,38 @@
 
 /* two full speed bulk endpoints; their use is config-dependent */
 
-static struct usb_endpoint_descriptor
+static const struct usb_endpoint_descriptor
 fs_source_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
-	.bEndpointAddress =	USB_DIR_IN,
+	.bEndpointAddress =	EP_IN_NUM | USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16 (64),
 };
 
-static struct usb_endpoint_descriptor
+static const struct usb_endpoint_descriptor
 fs_sink_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
-	.bEndpointAddress =	USB_DIR_OUT,
+	.bEndpointAddress =	EP_OUT_NUM,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16 (64),
 };
 
 static const struct usb_descriptor_header *fs_source_sink_function [] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
 	(struct usb_descriptor_header *) &source_sink_intf,
 	(struct usb_descriptor_header *) &fs_sink_desc,
 	(struct usb_descriptor_header *) &fs_source_desc,
-	NULL,
+	0,
 };
 
 static const struct usb_descriptor_header *fs_loopback_function [] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
 	(struct usb_descriptor_header *) &loopback_intf,
 	(struct usb_descriptor_header *) &fs_sink_desc,
 	(struct usb_descriptor_header *) &fs_source_desc,
-	NULL,
+	0,
 };
 
 #ifdef	CONFIG_USB_GADGET_DUALSPEED
@@ -371,19 +437,17 @@
 };
 
 static const struct usb_descriptor_header *hs_source_sink_function [] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
 	(struct usb_descriptor_header *) &source_sink_intf,
 	(struct usb_descriptor_header *) &hs_source_desc,
 	(struct usb_descriptor_header *) &hs_sink_desc,
-	NULL,
+	0,
 };
 
 static const struct usb_descriptor_header *hs_loopback_function [] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
 	(struct usb_descriptor_header *) &loopback_intf,
 	(struct usb_descriptor_header *) &hs_source_desc,
 	(struct usb_descriptor_header *) &hs_sink_desc,
-	NULL,
+	0,
 };
 
 /* maxpacket and other transfer characteristics vary by speed. */
@@ -399,7 +463,7 @@
 static char				manufacturer [40];
 static char				serial [40];
 
-/* static strings, in UTF-8 */
+/* static strings, in iso 8859/1 */
 static struct usb_string		strings [] = {
 	{ STRING_MANUFACTURER, manufacturer, },
 	{ STRING_PRODUCT, longname, },
@@ -461,10 +525,6 @@
 			? fs_source_sink_function
 			: fs_loopback_function;
 
-	/* for now, don't advertise srp-only devices */
-	if (!gadget->is_otg)
-		function++;
-
 	len = usb_gadget_config_buf (is_source_sink
 					? &source_sink_config
 					: &loopback_config,
@@ -489,7 +549,7 @@
 				&req->dma, GFP_ATOMIC);
 		if (!req->buf) {
 			usb_ep_free_request (ep, req);
-			req = NULL;
+			req = 0;
 		}
 	}
 	return req;
@@ -506,7 +566,7 @@
 
 /* optionally require specific source/sink data patterns  */
 
-static int
+static inline int
 check_read_data (
 	struct zero_dev		*dev,
 	struct usb_ep		*ep,
@@ -540,7 +600,7 @@
 	return 0;
 }
 
-static void
+static inline void
 reinit_write_data (
 	struct zero_dev		*dev,
 	struct usb_ep		*ep,
@@ -583,7 +643,7 @@
 	case -ECONNABORTED: 		/* hardware forced ep reset */
 	case -ECONNRESET:		/* request dequeued */
 	case -ESHUTDOWN:		/* disconnect from host */
-		VDBG (dev, "%s gone (%d), %d/%d\n", ep->name, status,
+		VDEBUG (dev, "%s gone (%d), %d/%d\n", ep->name, status,
 				req->actual, req->length);
 		if (ep == dev->out_ep)
 			check_read_data (dev, ep, req);
@@ -596,7 +656,7 @@
 					 */
 	default:
 #if 1
-		DBG (dev, "%s complete --> %d, %d/%d\n", ep->name,
+		DEBUG (dev, "%s complete --> %d, %d/%d\n", ep->name,
 				status, req->actual, req->length);
 #endif
 	case -EREMOTEIO:		/* short read */
@@ -620,7 +680,7 @@
 
 	req = alloc_ep_req (ep, buflen);
 	if (!req)
-		return NULL;
+		return 0;
 
 	memset (req->buf, 0, req->length);
 	req->complete = source_sink_complete;
@@ -634,7 +694,7 @@
 
 		ERROR (dev, "start %s --> %d\n", ep->name, status);
 		free_ep_req (ep, req);
-		req = NULL;
+		req = 0;
 	}
 
 	return req;
@@ -687,7 +747,7 @@
 		break;
 	}
 	if (result == 0)
-		DBG (dev, "buflen %d\n", buflen);
+		DEBUG (dev, "buflen %d\n", buflen);
 
 	/* caller is responsible for cleanup on error */
 	return result;
@@ -798,14 +858,14 @@
 				req->complete = loopback_complete;
 				result = usb_ep_queue (ep, req, GFP_ATOMIC);
 				if (result)
-					DBG (dev, "%s queue req --> %d\n",
+					DEBUG (dev, "%s queue req --> %d\n",
 							ep->name, result);
 			} else
 				result = -ENOMEM;
 		}
 	}
 	if (result == 0)
-		DBG (dev, "qlen %d, buflen %d\n", qlen, buflen);
+		DEBUG (dev, "qlen %d, buflen %d\n", qlen, buflen);
 
 	/* caller is responsible for cleanup on error */
 	return result;
@@ -818,21 +878,20 @@
 	if (dev->config == 0)
 		return;
 
-	DBG (dev, "reset config\n");
+	DEBUG (dev, "reset config\n");
 
 	/* just disable endpoints, forcing completion of pending i/o.
 	 * all our completion handlers free their requests in this case.
 	 */
 	if (dev->in_ep) {
 		usb_ep_disable (dev->in_ep);
-		dev->in_ep = NULL;
+		dev->in_ep = 0;
 	}
 	if (dev->out_ep) {
 		usb_ep_disable (dev->out_ep);
-		dev->out_ep = NULL;
+		dev->out_ep = 0;
 	}
 	dev->config = 0;
-	del_timer (&dev->resume);
 }
 
 /* change our operational config.  this code must agree with the code
@@ -854,11 +913,13 @@
 	if (number == dev->config)
 		return 0;
 
-	if (gadget_is_sa1100 (gadget) && dev->config) {
+#ifdef CONFIG_USB_GADGET_SA1100
+	if (dev->config) {
 		/* tx fifo is full, but we can't clear it...*/
 		INFO (dev, "can't change configurations\n");
 		return -ESPIPE;
 	}
+#endif
 	zero_reset_config (dev);
 
 	switch (number) {
@@ -902,7 +963,7 @@
 static void zero_setup_complete (struct usb_ep *ep, struct usb_request *req)
 {
 	if (req->status || req->actual != req->length)
-		DBG ((struct zero_dev *) ep->driver_data,
+		DEBUG ((struct zero_dev *) ep->driver_data,
 				"setup complete --> %d, %d/%d\n",
 				req->status, req->actual, req->length);
 }
@@ -924,7 +985,6 @@
 	/* usually this stores reply data in the pre-allocated ep0 buffer,
 	 * but config change events will reconfigure hardware.
 	 */
-	req->zero = 0;
 	switch (ctrl->bRequest) {
 
 	case USB_REQ_GET_DESCRIPTOR:
@@ -960,8 +1020,7 @@
 		case USB_DT_STRING:
 			/* wIndex == language code.
 			 * this driver only handles one language, you can
-			 * add string tables for other languages, using
-			 * any UTF-8 characters
+			 * add others even if they don't use iso8859/1
 			 */
 			value = usb_gadget_get_string (&stringtab,
 					ctrl->wValue & 0xff, req->buf);
@@ -975,12 +1034,6 @@
 	case USB_REQ_SET_CONFIGURATION:
 		if (ctrl->bRequestType != 0)
 			goto unknown;
-		if (gadget->a_hnp_support)
-			DBG (dev, "HNP available\n");
-		else if (gadget->a_alt_hnp_support)
-			DBG (dev, "HNP needs a different root port\n");
-		else
-			VDBG (dev, "HNP inactive\n");
 		spin_lock (&dev->lock);
 		value = zero_set_config (dev, ctrl->wValue, GFP_ATOMIC);
 		spin_unlock (&dev->lock);
@@ -1058,7 +1111,7 @@
 
 	default:
 unknown:
-		VDBG (dev,
+		VDEBUG (dev,
 			"unknown control req%02x.%02x v%04x i%04x l%d\n",
 			ctrl->bRequestType, ctrl->bRequest,
 			ctrl->wValue, ctrl->wIndex, ctrl->wLength);
@@ -1067,11 +1120,9 @@
 	/* respond with data transfer before status phase? */
 	if (value >= 0) {
 		req->length = value;
-		req->zero = value < ctrl->wLength
-				&& (value % gadget->ep0->maxpacket) == 0;
 		value = usb_ep_queue (gadget->ep0, req, GFP_ATOMIC);
 		if (value < 0) {
-			DBG (dev, "ep_queue --> %d\n", value);
+			DEBUG (dev, "ep_queue --> %d\n", value);
 			req->status = 0;
 			zero_setup_complete (gadget->ep0, req);
 		}
@@ -1101,21 +1152,6 @@
 	 */
 }
 
-static void
-zero_autoresume (unsigned long _dev)
-{
-	struct zero_dev	*dev = (struct zero_dev *) _dev;
-	int		status;
-
-	/* normally the host would be woken up for something
-	 * more significant than just a timer firing...
-	 */
-	if (dev->gadget->speed != USB_SPEED_UNKNOWN) {
-		status = usb_gadget_wakeup (dev->gadget);
-		DBG (dev, "wakeup --> %d\n", status);
-	}
-}
-
 /*-------------------------------------------------------------------------*/
 
 static void
@@ -1123,86 +1159,20 @@
 {
 	struct zero_dev		*dev = get_gadget_data (gadget);
 
-	DBG (dev, "unbind\n");
+	DEBUG (dev, "unbind\n");
 
 	/* we've already been disconnected ... no i/o is active */
 	if (dev->req)
 		free_ep_req (gadget->ep0, dev->req);
-	del_timer_sync (&dev->resume);
 	kfree (dev);
-	set_gadget_data (gadget, NULL);
+	set_gadget_data (gadget, 0);
 }
 
 static int
 zero_bind (struct usb_gadget *gadget)
 {
 	struct zero_dev		*dev;
-	struct usb_ep		*ep;
-
-	/* Bulk-only drivers like this one SHOULD be able to
-	 * autoconfigure on any sane usb controller driver,
-	 * but there may also be important quirks to address.
-	 */
-	usb_ep_autoconfig_reset (gadget);
-	ep = usb_ep_autoconfig (gadget, &fs_source_desc);
-	if (!ep) {
-autoconf_fail:
-		printk (KERN_ERR "%s: can't autoconfigure on %s\n",
-			shortname, gadget->name);
-		return -ENODEV;
-	}
-	EP_IN_NAME = ep->name;
-	ep->driver_data = ep;	/* claim */
-	
-	ep = usb_ep_autoconfig (gadget, &fs_sink_desc);
-	if (!ep)
-		goto autoconf_fail;
-	EP_OUT_NAME = ep->name;
-	ep->driver_data = ep;	/* claim */
-
-
-	/*
-	 * DRIVER POLICY CHOICE:  you may want to do this differently.
-	 * One thing to avoid is reusing a bcdDevice revision code
-	 * with different host-visible configurations or behavior
-	 * restrictions -- using ep1in/ep2out vs ep1out/ep3in, etc
-	 */
-	if (gadget_is_net2280 (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0201);
-	} else if (gadget_is_pxa (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0203);
-#if 0
-	} else if (gadget_is_sh(gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0204);
-		/* SH has only one configuration; see "loopdefault" */
-		device_desc.bNumConfigurations = 1;
-		/* FIXME make 1 == default.bConfigurationValue */
-#endif
-	} else if (gadget_is_sa1100 (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0205);
-	} else if (gadget_is_goku (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0206);
-	} else if (gadget_is_mq11xx (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0207);
-	} else if (gadget_is_omap (gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0208);
-	} else if (gadget_is_lh7a40x(gadget)) {
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0209);
-	} else {
-		/* gadget zero is so simple (for now, no altsettings) that
-		 * it SHOULD NOT have problems with bulk-capable hardware.
-		 * so warn about unrcognized controllers, don't panic.
-		 *
-		 * things like configuration and altsetting numbering
-		 * can need hardware-specific attention though.
-		 */
-		printk (KERN_WARNING "%s: controller '%s' not recognized\n",
-			shortname, gadget->name);
-		device_desc.bcdDevice = __constant_cpu_to_le16 (0x9999);
-	}
 
-
-	/* ok, we made sense of the hardware ... */
 	dev = kmalloc (sizeof *dev, SLAB_KERNEL);
 	if (!dev)
 		return -ENOMEM;
@@ -1233,28 +1203,6 @@
 	hs_sink_desc.bEndpointAddress = fs_sink_desc.bEndpointAddress;
 #endif
 
-	if (gadget->is_otg) {
-		otg_descriptor.bmAttributes |= USB_OTG_HNP,
-		source_sink_config.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-		loopback_config.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-	}
-
-	if (gadget->is_otg) {
-		otg_descriptor.bmAttributes |= USB_OTG_HNP,
-		source_sink_config.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-		loopback_config.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-	}
-
-	usb_gadget_set_selfpowered (gadget);
-
-	init_timer (&dev->resume);
-	dev->resume.function = zero_autoresume;
-	dev->resume.data = (unsigned long) dev;
-	if (autoresume) {
-		source_sink_config.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-		loopback_config.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-	}
-
 	gadget->ep0->driver_data = dev;
 
 	INFO (dev, "%s, version: " DRIVER_VERSION "\n", longname);
@@ -1274,33 +1222,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-static void
-zero_suspend (struct usb_gadget *gadget)
-{
-	struct zero_dev		*dev = get_gadget_data (gadget);
-
-	if (gadget->speed == USB_SPEED_UNKNOWN)
-		return;
-
-	if (autoresume) {
-		mod_timer (&dev->resume, jiffies + (HZ * autoresume));
-		DBG (dev, "suspend, wakeup in %d seconds\n", autoresume);
-	} else
-		DBG (dev, "suspend\n");
-}
-
-static void
-zero_resume (struct usb_gadget *gadget)
-{
-	struct zero_dev		*dev = get_gadget_data (gadget);
-
-	DBG (dev, "resume\n");
-	del_timer (&dev->resume);
-}
-
-
-/*-------------------------------------------------------------------------*/
-
 static struct usb_gadget_driver zero_driver = {
 #ifdef CONFIG_USB_GADGET_DUALSPEED
 	.speed		= USB_SPEED_HIGH,
@@ -1314,9 +1235,6 @@
 	.setup		= zero_setup,
 	.disconnect	= zero_disconnect,
 
-	.suspend	= zero_suspend,
-	.resume		= zero_resume,
-
 	.driver 	= {
 		.name		= (char *) shortname,
 		// .shutdown = ...
diff -Naur linuxppc-2.6.9/drivers/usb/host/ehci-dbg.c linuxppc-2.6.9-dream/drivers/usb/host/ehci-dbg.c
--- linuxppc-2.6.9/drivers/usb/host/ehci-dbg.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ehci-dbg.c	2005-09-19 21:40:05.000000000 +0200
@@ -119,16 +119,16 @@
 dbg_qtd (const char *label, struct ehci_hcd *ehci, struct ehci_qtd *qtd)
 {
 	ehci_dbg (ehci, "%s td %p n%08x %08x t%08x p0=%08x\n", label, qtd,
-		le32_to_cpup (&qtd->hw_next),
-		le32_to_cpup (&qtd->hw_alt_next),
-		le32_to_cpup (&qtd->hw_token),
-		le32_to_cpup (&qtd->hw_buf [0]));
+		cpu_to_le32p (&qtd->hw_next),
+		cpu_to_le32p (&qtd->hw_alt_next),
+		cpu_to_le32p (&qtd->hw_token),
+		cpu_to_le32p (&qtd->hw_buf [0]));
 	if (qtd->hw_buf [1])
 		ehci_dbg (ehci, "  p1=%08x p2=%08x p3=%08x p4=%08x\n",
-			le32_to_cpup (&qtd->hw_buf [1]),
-			le32_to_cpup (&qtd->hw_buf [2]),
-			le32_to_cpup (&qtd->hw_buf [3]),
-			le32_to_cpup (&qtd->hw_buf [4]));
+			cpu_to_le32p (&qtd->hw_buf [1]),
+			cpu_to_le32p (&qtd->hw_buf [2]),
+			cpu_to_le32p (&qtd->hw_buf [3]),
+			cpu_to_le32p (&qtd->hw_buf [4]));
 }
 
 static void __attribute__((__unused__))
@@ -170,20 +170,6 @@
 		itd->index[6], itd->index[7]);
 }
 
-static void __attribute__((__unused__))
-dbg_sitd (const char *label, struct ehci_hcd *ehci, struct ehci_sitd *sitd) 
-{
-	ehci_dbg (ehci, "%s [%d] sitd %p, next %08x, urb %p\n",
-		label, sitd->frame, sitd, le32_to_cpu(sitd->hw_next), sitd->urb);
-	ehci_dbg (ehci,
-		"  addr %08x sched %04x result %08x buf %08x %08x\n", 
-		le32_to_cpu(sitd->hw_fullspeed_ep),
-		le32_to_cpu(sitd->hw_uframe),
-		le32_to_cpu(sitd->hw_results),
-		le32_to_cpu(sitd->hw_buf [0]),
-		le32_to_cpu(sitd->hw_buf [1]));
-}
-
 static int __attribute__((__unused__))
 dbg_status_buf (char *buf, unsigned len, char *label, u32 status)
 {
@@ -331,14 +317,14 @@
 		default: tmp = '?'; break; \
 		}; tmp; })
 
-static inline char token_mark (__le32 token)
+static inline char token_mark (u32 token)
 {
-	__u32 v = le32_to_cpu (token);
-	if (v & QTD_STS_ACTIVE)
+	token = le32_to_cpu (token);
+	if (token & QTD_STS_ACTIVE)
 		return '*';
-	if (v & QTD_STS_HALT)
+	if (token & QTD_STS_HALT)
 		return '-';
-	if (!IS_SHORT_READ (v))
+	if (!IS_SHORT_READ (token))
 		return ' ';
 	/* tries to advance through hw_alt_next */
 	return '/';
@@ -371,25 +357,25 @@
 			mark = '.';	/* use hw_qtd_next */
 		/* else alt_next points to some other qtd */
 	}
-	scratch = le32_to_cpup (&qh->hw_info1);
-	hw_curr = (mark == '*') ? le32_to_cpup (&qh->hw_current) : 0;
+	scratch = cpu_to_le32p (&qh->hw_info1);
+	hw_curr = (mark == '*') ? cpu_to_le32p (&qh->hw_current) : 0;
 	temp = scnprintf (next, size,
 			"qh/%p dev%d %cs ep%d %08x %08x (%08x%c %s nak%d)",
 			qh, scratch & 0x007f,
 			speed_char (scratch),
 			(scratch >> 8) & 0x000f,
-			scratch, le32_to_cpup (&qh->hw_info2),
-			le32_to_cpup (&qh->hw_token), mark,
+			scratch, cpu_to_le32p (&qh->hw_info2),
+			cpu_to_le32p (&qh->hw_token), mark,
 			(__constant_cpu_to_le32 (QTD_TOGGLE) & qh->hw_token)
 				? "data1" : "data0",
-			(le32_to_cpup (&qh->hw_alt_next) >> 1) & 0x0f);
+			(cpu_to_le32p (&qh->hw_alt_next) >> 1) & 0x0f);
 	size -= temp;
 	next += temp;
 
 	/* hc may be modifying the list as we read it ... */
 	list_for_each (entry, &qh->qtd_list) {
 		td = list_entry (entry, struct ehci_qtd, qtd_list);
-		scratch = le32_to_cpup (&td->hw_token);
+		scratch = cpu_to_le32p (&td->hw_token);
 		mark = ' ';
 		if (hw_curr == td->qtd_dma)
 			mark = '*';
@@ -488,8 +474,7 @@
 	union ehci_shadow	p, *seen;
 	unsigned		temp, size, seen_count;
 	char			*next;
-	unsigned		i;
-	__le32			tag;
+	unsigned		i, tag;
 
 	if (!(seen = kmalloc (DBG_SCHED_LIMIT * sizeof *seen, SLAB_ATOMIC)))
 		return 0;
@@ -537,12 +522,12 @@
 					if (p.qh->qh_next.ptr)
 						temp = scnprintf (next, size,
 							" ...");
-					p.ptr = NULL;
+					p.ptr = 0;
 					break;
 				}
 				/* show more info the first time around */
 				if (temp == seen_count && p.ptr) {
-					u32	scratch = le32_to_cpup (
+					u32	scratch = cpu_to_le32p (
 							&p.qh->hw_info1);
 					struct ehci_qtd	*qtd;
 					char		*type = "";
@@ -640,22 +625,11 @@
 
 	spin_lock_irqsave (&ehci->lock, flags);
 
-	if (bus->controller->power.power_state) {
-		size = scnprintf (next, size,
-			"bus %s, device %s (driver " DRIVER_VERSION ")\n"
-			"SUSPENDED (no register access)\n",
-			hcd->self.controller->bus->name,
-			hcd->self.controller->bus_id);
-		goto done;
-	}
-
 	/* Capability Registers */
 	i = HC_VERSION(readl (&ehci->caps->hc_capbase));
 	temp = scnprintf (next, size,
-		"bus %s, device %s (driver " DRIVER_VERSION ")\n"
-		"EHCI %x.%02x, hcd state %d\n",
-		hcd->self.controller->bus->name,
-		hcd->self.controller->bus_id,
+		"PCI device %s\nEHCI %x.%02x, hcd state %d (driver " DRIVER_VERSION ")\n",
+		pci_name(to_pci_dev(hcd->self.controller)),
 		i >> 8, i & 0x0ff, ehci->hcd.state);
 	size -= temp;
 	next += temp;
@@ -696,7 +670,7 @@
 	next += temp;
 
 	for (i = 0; i < HCS_N_PORTS (ehci->hcs_params); i++) {
-		temp = dbg_port_buf (scratch, sizeof scratch, label, i + 1,
+		temp = dbg_port_buf (scratch, sizeof scratch, label, i,
 				readl (&ehci->regs->port_status [i]));
 		temp = scnprintf (next, size, fmt, temp, scratch);
 		size -= temp;
@@ -725,7 +699,6 @@
 	next += temp;
 #endif
 
-done:
 	spin_unlock_irqrestore (&ehci->lock, flags);
 
 	return PAGE_SIZE - size;
diff -Naur linuxppc-2.6.9/drivers/usb/host/ehci.h linuxppc-2.6.9-dream/drivers/usb/host/ehci.h
--- linuxppc-2.6.9/drivers/usb/host/ehci.h	2004-10-18 23:55:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ehci.h	2005-09-19 21:40:05.000000000 +0200
@@ -52,13 +52,12 @@
 	/* async schedule support */
 	struct ehci_qh		*async;
 	struct ehci_qh		*reclaim;
-	unsigned		reclaim_ready : 1;
-	unsigned		scanning : 1;
+	int			reclaim_ready : 1;
 
 	/* periodic schedule support */
 #define	DEFAULT_I_TDPS		1024		/* some HCs can do less */
 	unsigned		periodic_size;
-	__le32			*periodic;	/* hw periodic table */
+	u32			*periodic;	/* hw periodic table */
 	dma_addr_t		periodic_dma;
 	unsigned		i_thresh;	/* uframes HC might cache */
 
@@ -71,9 +70,9 @@
 
 	/* glue to PCI and HCD framework */
 	struct usb_hcd		hcd;
-	struct ehci_caps __iomem *caps;
-	struct ehci_regs __iomem *regs;
-	__u32			hcs_params;	/* cached register copy */
+	struct ehci_caps	*caps;
+	struct ehci_regs	*regs;
+	u32			hcs_params;	/* cached register copy */
 
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */
@@ -85,10 +84,6 @@
 	struct notifier_block	reboot_notifier;
 	unsigned long		actions;
 	unsigned		stamp;
-	unsigned long		next_statechange;
-	u32			command;
-
-	unsigned		is_arc_rh_tt:1;	/* ARC roothub with TT */
 
 	/* irq statistics */
 #ifdef EHCI_STATS
@@ -102,6 +97,8 @@
 /* unwrap an HCD pointer to get an EHCI_HCD pointer */ 
 #define hcd_to_ehci(hcd_ptr) container_of(hcd_ptr, struct ehci_hcd, hcd)
 
+/* NOTE:  urb->transfer_flags expected to not use this bit !!! */
+#define EHCI_STATE_UNLINK	0x8000		/* urb being unlinked */
 
 enum ehci_timer_action {
 	TIMER_IO_WATCHDOG,
@@ -222,7 +219,7 @@
 	u32		segment; 	/* address bits 63:32 if needed */
 	/* PERIODICLISTBASE: offset 0x14 */
 	u32		frame_list; 	/* points to periodic list */
-	/* ASYNCLISTADDR: offset 0x18 */
+	/* ASYNCICLISTADDR: offset 0x18 */
 	u32		async_next;	/* address of next async queue head */
 
 	u32		reserved [9];
@@ -238,10 +235,7 @@
 #define PORT_WKDISC_E	(1<<21)		/* wake on disconnect (enable) */
 #define PORT_WKCONN_E	(1<<20)		/* wake on connect (enable) */
 /* 19:16 for port testing */
-#define PORT_LED_OFF	(0<<14)
-#define PORT_LED_AMBER	(1<<14)
-#define PORT_LED_GREEN	(2<<14)
-#define PORT_LED_MASK	(3<<14)
+/* 15:14 for using port indicator leds (if HCS_INDICATOR allows) */
 #define PORT_OWNER	(1<<13)		/* true: companion hc owns this port */
 #define PORT_POWER	(1<<12)		/* true: has power (see PPC) */
 #define PORT_USB11(x) (((x)&(3<<10))==(1<<10))	/* USB 1.1 device */
@@ -273,9 +267,9 @@
  */
 struct ehci_qtd {
 	/* first part defined by EHCI spec */
-	__le32			hw_next;	  /* see EHCI 3.5.1 */
-	__le32			hw_alt_next;      /* see EHCI 3.5.2 */
-	__le32			hw_token;         /* see EHCI 3.5.3 */       
+	u32			hw_next;	  /* see EHCI 3.5.1 */
+	u32			hw_alt_next;      /* see EHCI 3.5.2 */
+	u32			hw_token;         /* see EHCI 3.5.3 */       
 #define	QTD_TOGGLE	(1 << 31)	/* data toggle */
 #define	QTD_LENGTH(tok)	(((tok)>>16) & 0x7fff)
 #define	QTD_IOC		(1 << 15)	/* interrupt on complete */
@@ -289,8 +283,8 @@
 #define	QTD_STS_MMF	(1 << 2)	/* incomplete split transaction */
 #define	QTD_STS_STS	(1 << 1)	/* split transaction state */
 #define	QTD_STS_PING	(1 << 0)	/* issue PING? */
-	__le32			hw_buf [5];        /* see EHCI 3.5.4 */
-	__le32			hw_buf_hi [5];        /* Appendix B */
+	u32			hw_buf [5];        /* see EHCI 3.5.4 */
+	u32			hw_buf_hi [5];        /* Appendix B */
 
 	/* the rest is HCD-private */
 	dma_addr_t		qtd_dma;		/* qtd address */
@@ -350,18 +344,18 @@
 
 struct ehci_qh {
 	/* first part defined by EHCI spec */
-	__le32			hw_next;	 /* see EHCI 3.6.1 */
-	__le32			hw_info1;        /* see EHCI 3.6.2 */
+	u32			hw_next;	 /* see EHCI 3.6.1 */
+	u32			hw_info1;        /* see EHCI 3.6.2 */
 #define	QH_HEAD		0x00008000
-	__le32			hw_info2;        /* see EHCI 3.6.2 */
-	__le32			hw_current;	 /* qtd list - see EHCI 3.6.4 */
+	u32			hw_info2;        /* see EHCI 3.6.2 */
+	u32			hw_current;	 /* qtd list - see EHCI 3.6.4 */
 	
 	/* qtd overlay (hardware parts of a struct ehci_qtd) */
-	__le32			hw_qtd_next;
-	__le32			hw_alt_next;
-	__le32			hw_token;
-	__le32			hw_buf [5];
-	__le32			hw_buf_hi [5];
+	u32			hw_qtd_next;
+	u32			hw_alt_next;
+	u32			hw_token;
+	u32			hw_buf [5];
+	u32			hw_buf_hi [5];
 
 	/* the rest is HCD-private */
 	dma_addr_t		qh_dma;		/* address of qh */
@@ -370,8 +364,7 @@
 	struct ehci_qtd		*dummy;
 	struct ehci_qh		*reclaim;	/* next to reclaim */
 
-	struct ehci_hcd		*ehci;
-	struct kref		kref;
+	atomic_t		refcount;
 	unsigned		stamp;
 
 	u8			qh_state;
@@ -397,7 +390,7 @@
 struct ehci_iso_packet {
 	/* These will be copied to iTD when scheduling */
 	u64			bufp;		/* itd->hw_bufp{,_hi}[pg] |= */
-	__le32			transaction;	/* itd->hw_transaction[i] |= */
+	u32			transaction;	/* itd->hw_transaction[i] |= */
 	u8			cross;		/* buf crosses pages */
 	/* for full speed OUT splits */
 	u16			buf1;
@@ -419,8 +412,8 @@
  */
 struct ehci_iso_stream {
 	/* first two fields match QH, but info1 == 0 */
-	__le32			hw_next;
-	__le32			hw_info1;
+	u32			hw_next;
+	u32			hw_info1;
 
 	u32			refcount;
 	u8			bEndpointAddress;
@@ -434,7 +427,7 @@
 	unsigned long		start;		/* jiffies */
 	unsigned long		rescheduled;
 	int			next_uframe;
-	__le32			splits;
+	u32			splits;
 
 	/* the rest is derived from the endpoint descriptor,
 	 * trusting urb->interval == f(epdesc->bInterval) and
@@ -447,12 +440,12 @@
 	unsigned		bandwidth;
 
 	/* This is used to initialize iTD's hw_bufp fields */
-	__le32			buf0;		
-	__le32			buf1;		
-	__le32			buf2;
+	u32			buf0;		
+	u32			buf1;		
+	u32			buf2;
 
 	/* this is used to initialize sITD's tt info */
-	__le32			address;
+	u32			address;
 };
 
 /*-------------------------------------------------------------------------*/
@@ -465,8 +458,8 @@
  */
 struct ehci_itd {
 	/* first part defined by EHCI spec */
-	__le32			hw_next;           /* see EHCI 3.3.1 */
-	__le32			hw_transaction [8]; /* see EHCI 3.3.2 */
+	u32			hw_next;           /* see EHCI 3.3.1 */
+	u32			hw_transaction [8]; /* see EHCI 3.3.2 */
 #define EHCI_ISOC_ACTIVE        (1<<31)        /* activate transfer this slot */
 #define EHCI_ISOC_BUF_ERR       (1<<30)        /* Data buffer error */
 #define EHCI_ISOC_BABBLE        (1<<29)        /* babble detected */
@@ -476,8 +469,8 @@
 
 #define ITD_ACTIVE	__constant_cpu_to_le32(EHCI_ISOC_ACTIVE)
 
-	__le32			hw_bufp [7];	/* see EHCI 3.3.3 */ 
-	__le32			hw_bufp_hi [7];	/* Appendix B */
+	u32			hw_bufp [7];	/* see EHCI 3.3.3 */ 
+	u32			hw_bufp_hi [7];	/* Appendix B */
 
 	/* the rest is HCD-private */
 	dma_addr_t		itd_dma;	/* for this itd */
@@ -504,11 +497,11 @@
  */
 struct ehci_sitd {
 	/* first part defined by EHCI spec */
-	__le32			hw_next;
+	u32			hw_next;
 /* uses bit field macros above - see EHCI 0.95 Table 3-8 */
-	__le32			hw_fullspeed_ep;	/* EHCI table 3-9 */
-	__le32			hw_uframe;		/* EHCI table 3-10 */
-	__le32			hw_results;		/* EHCI table 3-11 */
+	u32			hw_fullspeed_ep;	/* EHCI table 3-9 */
+	u32			hw_uframe;		/* EHCI table 3-10 */
+	u32			hw_results;		/* EHCI table 3-11 */
 #define	SITD_IOC	(1 << 31)	/* interrupt on completion */
 #define	SITD_PAGE	(1 << 30)	/* buffer 0/1 */
 #define	SITD_LENGTH(x)	(0x3ff & ((x)>>16))
@@ -522,9 +515,9 @@
 
 #define SITD_ACTIVE	__constant_cpu_to_le32(SITD_STS_ACTIVE)
 
-	__le32			hw_buf [2];		/* EHCI table 3-12 */
-	__le32			hw_backpointer;		/* EHCI table 3-13 */
-	__le32			hw_buf_hi [2];		/* Appendix B */
+	u32			hw_buf [2];		/* EHCI table 3-12 */
+	u32			hw_backpointer;		/* EHCI table 3-13 */
+	u32			hw_buf_hi [2];		/* Appendix B */
 
 	/* the rest is HCD-private */
 	dma_addr_t		sitd_dma;
@@ -549,8 +542,8 @@
  * it hits a "restore" FSTN; then it returns to finish other uframe 0/1 work.
  */
 struct ehci_fstn {
-	__le32			hw_next;	/* any periodic q entry */
-	__le32			hw_prev;	/* qh or EHCI_LIST_END */
+	u32			hw_next;	/* any periodic q entry */
+	u32			hw_prev;	/* qh or EHCI_LIST_END */
 
 	/* the rest is HCD-private */
 	dma_addr_t		fstn_dma;
@@ -559,44 +552,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-#ifdef CONFIG_USB_EHCI_ROOT_HUB_TT
-
-/*
- * Some EHCI controllers have a Transaction Translator built into the
- * root hub. This is a non-standard feature.  Each controller will need
- * to add code to the following inline functions, and call them as
- * needed (mostly in root hub code).
- */
-
-#define	ehci_is_ARC(e)			((e)->is_arc_rh_tt)
-
-/* Returns the speed of a device attached to a port on the root hub. */
-static inline unsigned int
-ehci_port_speed(struct ehci_hcd *ehci, unsigned int portsc)
-{
-	if (ehci_is_ARC(ehci)) {
-		switch ((portsc>>26)&3) {
-		case 0:
-			return 0;
-		case 1:
-			return (1<<USB_PORT_FEAT_LOWSPEED);
-		case 2:
-		default:
-			return (1<<USB_PORT_FEAT_HIGHSPEED);
-		}
-	}
-	return (1<<USB_PORT_FEAT_HIGHSPEED);
-}
-
-#else
-
-#define	ehci_is_ARC(e)			(0)
-
-#define	ehci_port_speed(ehci, portsc)	(1<<USB_PORT_FEAT_HIGHSPEED)
-#endif
-
-/*-------------------------------------------------------------------------*/
-
 #ifndef DEBUG
 #define STUB_DEBUG_FILES
 #endif	/* DEBUG */
diff -Naur linuxppc-2.6.9/drivers/usb/host/ehci-hcd.c linuxppc-2.6.9-dream/drivers/usb/host/ehci-hcd.c
--- linuxppc-2.6.9/drivers/usb/host/ehci-hcd.c	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ehci-hcd.c	2005-09-19 21:40:05.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000-2004 by David Brownell
+ * Copyright (c) 2000-2002 by David Brownell
  * 
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -69,7 +69,6 @@
  *
  * HISTORY:
  *
- * 2004-05-10 Root hub and PCI suspend/resume support; remote wakeup. (db)
  * 2004-02-24 Replace pci_* with generic dma_* API calls (dsaxena@plexity.net)
  * 2003-12-29 Rewritten high speed iso transfer support (by Michal Sojka,
  *	<sojkam@centrum.cz>, updates by DB).
@@ -97,7 +96,7 @@
  * 2001-June	Works with usb-storage and NEC EHCI on 2.4
  */
 
-#define DRIVER_VERSION "2004-May-10"
+#define DRIVER_VERSION "2003-Dec-29"
 #define DRIVER_AUTHOR "David Brownell"
 #define DRIVER_DESC "USB 2.0 'Enhanced' Host Controller (EHCI) Driver"
 
@@ -129,7 +128,7 @@
 module_param (log2_irq_thresh, int, S_IRUGO);
 MODULE_PARM_DESC (log2_irq_thresh, "log2 IRQ latency, 1-64 microframes");
 
-#define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
+#define	INTR_MASK (STS_IAA | STS_FATAL | STS_ERR | STS_INT)
 
 /*-------------------------------------------------------------------------*/
 
@@ -155,7 +154,7 @@
  * before driver shutdown. But it also seems to be caused by bugs in cardbus
  * bridge shutdown:  shutting down the bridge before the devices using it.
  */
-static int handshake (u32 __iomem *ptr, u32 mask, u32 done, int usec)
+static int handshake (u32 *ptr, u32 mask, u32 done, int usec)
 {
 	u32	result;
 
@@ -202,7 +201,6 @@
 	dbg_cmd (ehci, "reset", command);
 	writel (command, &ehci->regs->command);
 	ehci->hcd.state = USB_STATE_HALT;
-	ehci->next_statechange = jiffies;
 	return handshake (&ehci->regs->command, CMD_RESET, 0, 250 * 1000);
 }
 
@@ -243,8 +241,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-static void ehci_work(struct ehci_hcd *ehci, struct pt_regs *regs);
-
 #include "ehci-hub.c"
 #include "ehci-mem.c"
 #include "ehci-q.c"
@@ -252,6 +248,8 @@
 
 /*-------------------------------------------------------------------------*/
 
+static void ehci_work(struct ehci_hcd *ehci, struct pt_regs *regs);
+
 static void ehci_watchdog (unsigned long param)
 {
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
@@ -281,42 +279,34 @@
 	spin_unlock_irqrestore (&ehci->lock, flags);
 }
 
-#ifdef	CONFIG_PCI
-
 /* EHCI 0.96 (and later) section 5.1 says how to kick BIOS/SMM/...
  * off the controller (maybe it can boot from highspeed USB disks).
  */
 static int bios_handoff (struct ehci_hcd *ehci, int where, u32 cap)
 {
 	if (cap & (1 << 16)) {
-		int msec = 5000;
-		struct pci_dev *pdev = to_pci_dev(ehci->hcd.self.controller);
+		int msec = 500;
 
 		/* request handoff to OS */
-		cap |= 1 << 24;
-		pci_write_config_dword(pdev, where, cap);
+		cap &= 1 << 24;
+		pci_write_config_dword (to_pci_dev(ehci->hcd.self.controller), where, cap);
 
 		/* and wait a while for it to happen */
 		do {
-			msleep(10);
+			wait_ms (10);
 			msec -= 10;
-			pci_read_config_dword(pdev, where, &cap);
+			pci_read_config_dword (to_pci_dev(ehci->hcd.self.controller), where, &cap);
 		} while ((cap & (1 << 16)) && msec);
 		if (cap & (1 << 16)) {
 			ehci_err (ehci, "BIOS handoff failed (%d, %04x)\n",
 				where, cap);
-			// some BIOS versions seem buggy...
-			// return 1;
-			ehci_warn (ehci, "continuing after BIOS bug...\n");
-			return 0;
+			return 1;
 		} 
 		ehci_dbg (ehci, "BIOS handoff succeeded\n");
 	}
 	return 0;
 }
 
-#endif
-
 static int
 ehci_reboot (struct notifier_block *self, unsigned long code, void *null)
 {
@@ -336,37 +326,27 @@
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			temp;
-	unsigned		count = 256/4;
 
 	spin_lock_init (&ehci->lock);
 
-	ehci->caps = hcd->regs;
-	ehci->regs = (hcd->regs + 
+	ehci->caps = (struct ehci_caps *) hcd->regs;
+	ehci->regs = (struct ehci_regs *) (hcd->regs + 
 				HC_LENGTH (readl (&ehci->caps->hc_capbase)));
 	dbg_hcs_params (ehci, "reset");
 	dbg_hcc_params (ehci, "reset");
 
-#ifdef	CONFIG_PCI
 	/* EHCI 0.96 and later may have "extended capabilities" */
-	if (hcd->self.controller->bus == &pci_bus_type)
-		temp = HCC_EXT_CAPS (readl (&ehci->caps->hcc_params));
-	else
-		temp = 0;
-	while (temp && count--) {
+	temp = HCC_EXT_CAPS (readl (&ehci->caps->hcc_params));
+	while (temp) {
 		u32		cap;
 
-		pci_read_config_dword (to_pci_dev(ehci->hcd.self.controller),
-				temp, &cap);
+		pci_read_config_dword (to_pci_dev(ehci->hcd.self.controller), temp, &cap);
 		ehci_dbg (ehci, "capability %04x at %02x\n", cap, temp);
 		switch (cap & 0xff) {
 		case 1:			/* BIOS/SMM/... handoff */
 			if (bios_handoff (ehci, temp, cap) != 0)
 				return -EOPNOTSUPP;
 			break;
-		case 0x0a:		/* appendix C */
-			ehci_dbg (ehci, "debug registers, BAR %d offset %d\n",
-				(cap >> 29) & 0x07, (cap >> 16) & 0x0fff);
-			break;
 		case 0:			/* illegal reserved capability */
 			ehci_warn (ehci, "illegal capability!\n");
 			cap = 0;
@@ -376,11 +356,6 @@
 		}
 		temp = (cap >> 8) & 0xff;
 	}
-	if (!count) {
-		ehci_err (ehci, "bogus capabilities ... PCI problems!\n");
-		return -EIO;
-	}
-#endif
 
 	/* cache this readonly data; minimize PCI reads */
 	ehci->hcs_params = readl (&ehci->caps->hcs_params);
@@ -397,11 +372,7 @@
 	struct usb_bus		*bus;
 	int			retval;
 	u32			hcc_params;
-	u8                      sbrn = 0;
-
-	init_timer (&ehci->watchdog);
-	ehci->watchdog.function = ehci_watchdog;
-	ehci->watchdog.data = (unsigned long) ehci;
+	u8                      tempbyte;
 
 	/*
 	 * hw default: 1K periodic list heads, one per frame.
@@ -418,7 +389,7 @@
 	else					// N microframes cached
 		ehci->i_thresh = 2 + HCC_ISOC_THRES (hcc_params);
 
-	ehci->reclaim = NULL;
+	ehci->reclaim = 0;
 	ehci->next_uframe = -1;
 
 	/* controller state:  unknown --> reset */
@@ -428,36 +399,9 @@
 		ehci_mem_cleanup (ehci);
 		return retval;
 	}
+	writel (INTR_MASK, &ehci->regs->intr_enable);
 	writel (ehci->periodic_dma, &ehci->regs->frame_list);
 
-#ifdef	CONFIG_PCI
-	if (hcd->self.controller->bus == &pci_bus_type) {
-		struct pci_dev		*pdev;
-		u16			port_wake;
-
-		pdev = to_pci_dev(hcd->self.controller);
-
-		/* Serial Bus Release Number is at PCI 0x60 offset */
-		pci_read_config_byte(pdev, 0x60, &sbrn);
-
-		/* port wake capability, reported by boot firmware */
-		pci_read_config_word(pdev, 0x62, &port_wake);
-		hcd->can_wakeup = (port_wake & 1) != 0;
-
-		/* help hc dma work well with cachelines */
-		pci_set_mwi (pdev);
-
-		/* chip-specific init */
-		switch (pdev->vendor) {
-		case PCI_VENDOR_ID_ARC:
-			if (pdev->device == PCI_DEVICE_ID_ARC_EHCI)
-				ehci->is_arc_rh_tt = 1;
-			break;
-		}
-
-	}
-#endif
-
 	/*
 	 * dedicate a qh for the async ring head, since we couldn't unlink
 	 * a 'real' qh without stopping the async schedule [4.8].  use it
@@ -465,7 +409,7 @@
 	 * its dummy is used in hw_alt_next of many tds, to prevent the qh
 	 * from automatically advancing to the next td after short reads.
 	 */
-	ehci->async->qh_next.qh = NULL;
+	ehci->async->qh_next.qh = 0;
 	ehci->async->hw_next = QH_NEXT (ehci->async->qh_dma);
 	ehci->async->hw_info1 = cpu_to_le32 (QH_HEAD);
 	ehci->async->hw_token = cpu_to_le32 (QTD_STS_HALT);
@@ -495,6 +439,9 @@
 #endif
 	}
 
+	/* help hc dma work well with cachelines */
+	pci_set_mwi (to_pci_dev(ehci->hcd.self.controller));
+
 	/* clear interrupt enables, set irq latency */
 	temp = readl (&ehci->regs->command) & 0x0fff;
 	if (log2_irq_thresh < 0 || log2_irq_thresh > 6)
@@ -521,9 +468,13 @@
 
 	/* set async sleep time = 10 us ... ? */
 
+	init_timer (&ehci->watchdog);
+	ehci->watchdog.function = ehci_watchdog;
+	ehci->watchdog.data = (unsigned long) ehci;
+
 	/* wire up the root hub */
 	bus = hcd_to_bus (hcd);
-	udev = usb_alloc_dev (NULL, bus, 0);
+	bus->root_hub = udev = usb_alloc_dev (NULL, bus, 0);
 	if (!udev) {
 done2:
 		ehci_mem_cleanup (ehci);
@@ -533,8 +484,7 @@
 	/*
 	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices
 	 * are explicitly handed to companion controller(s), so no TT is
-	 * involved with the root hub.  (Except where one is integrated,
-	 * and there's no companion controller unless maybe for USB OTG.)
+	 * involved with the root hub.
 	 */
 	ehci->reboot_notifier.notifier_call = ehci_reboot;
 	register_reboot_notifier (&ehci->reboot_notifier);
@@ -543,10 +493,12 @@
 	writel (FLAG_CF, &ehci->regs->configured_flag);
 	readl (&ehci->regs->command);	/* unblock posted write */
 
+        /* PCI Serial Bus Release Number is at 0x60 offset */
+	pci_read_config_byte(to_pci_dev(hcd->self.controller), 0x60, &tempbyte);
 	temp = HC_VERSION(readl (&ehci->caps->hc_capbase));
 	ehci_info (ehci,
 		"USB %x.%x enabled, EHCI %x.%02x, driver %s\n",
-		((sbrn & 0xf0)>>4), (sbrn & 0x0f),
+		((tempbyte & 0xf0)>>4), (tempbyte & 0x0f),
 		temp >> 8, temp & 0xff, DRIVER_VERSION);
 
 	/*
@@ -557,17 +509,16 @@
 	 * and device drivers may start it running.
 	 */
 	udev->speed = USB_SPEED_HIGH;
-	if (hcd_register_root (udev, hcd) != 0) {
+	if (hcd_register_root (hcd) != 0) {
 		if (hcd->state == USB_STATE_RUNNING)
 			ehci_ready (ehci);
 		ehci_reset (ehci);
+		bus->root_hub = 0;
 		usb_put_dev (udev); 
 		retval = -ENODEV;
 		goto done2;
 	}
 
-	writel (INTR_MASK, &ehci->regs->intr_enable); /* Turn On Interrupts */
-
 	create_debug_files (ehci);
 
 	return 0;
@@ -578,7 +529,6 @@
 static void ehci_stop (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	u8			rh_ports, port;
 
 	ehci_dbg (ehci, "stop\n");
 
@@ -590,16 +540,7 @@
 		return;
 	}
 	del_timer_sync (&ehci->watchdog);
-
-	/* Turn off port power on all root hub ports. */
-	rh_ports = HCS_N_PORTS (ehci->hcs_params);
-	for (port = 1; port <= rh_ports; port++) {
-		ehci_hub_control(hcd, ClearPortFeature, USB_PORT_FEAT_POWER,
-			port, NULL, 0);
-	}
-
 	ehci_reset (ehci);
-	writel (0, &ehci->regs->intr_enable);
 
 	/* let companion controllers work when we aren't */
 	writel (0, &ehci->regs->configured_flag);
@@ -609,8 +550,7 @@
 
 	/* root hub is shut down separately (first, when possible) */
 	spin_lock_irq (&ehci->lock);
-	if (ehci->async)
-		ehci_work (ehci, NULL);
+	ehci_work (ehci, NULL);
 	spin_unlock_irq (&ehci->lock);
 	ehci_mem_cleanup (ehci);
 
@@ -637,26 +577,41 @@
 
 /* suspend/resume, section 4.3 */
 
-/* These routines rely on PCI to handle powerdown and wakeup, and
- * transceivers that don't need any software attention to set up
- * the right sort of wakeup.  
- */
-
 static int ehci_suspend (struct usb_hcd *hcd, u32 state)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	int			ports;
+	int			i;
 
-	while (time_before (jiffies, ehci->next_statechange))
-		msleep (100);
+	ehci_dbg (ehci, "suspend to %d\n", state);
 
-#ifdef	CONFIG_USB_SUSPEND
-	(void) usb_suspend_device (hcd->self.root_hub, state);
-#else
-	/* FIXME lock root hub */
-	(void) ehci_hub_suspend (hcd);
-#endif
+	ports = HCS_N_PORTS (ehci->hcs_params);
+
+	// FIXME:  This assumes what's probably a D3 level suspend...
+
+	// FIXME:  usb wakeup events on this bus should resume the machine.
+	// pci config register PORTWAKECAP controls which ports can do it;
+	// bios may have initted the register...
+
+	/* suspend each port, then stop the hc */
+	for (i = 0; i < ports; i++) {
+		int	temp = readl (&ehci->regs->port_status [i]);
+
+		if ((temp & PORT_PE) == 0
+				|| (temp & PORT_OWNER) != 0)
+			continue;
+		ehci_dbg (ehci, "suspend port %d", i);
+		temp |= PORT_SUSPEND;
+		writel (temp, &ehci->regs->port_status [i]);
+	}
+
+	if (hcd->state == USB_STATE_RUNNING)
+		ehci_ready (ehci);
+	writel (readl (&ehci->regs->command) & ~CMD_RUN, &ehci->regs->command);
 
-	// save (PCI) FLADJ in case of Vaux power loss
+// save pci FLADJ value
+
+	/* who tells PCI to reduce power consumption? */
 
 	return 0;
 }
@@ -664,22 +619,40 @@
 static int ehci_resume (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	int			retval;
+	int			ports;
+	int			i;
 
-	// maybe restore (PCI) FLADJ
+	ehci_dbg (ehci, "resume\n");
 
-	while (time_before (jiffies, ehci->next_statechange))
-		msleep (100);
+	ports = HCS_N_PORTS (ehci->hcs_params);
 
-#ifdef	CONFIG_USB_SUSPEND
-	retval = usb_resume_device (hcd->self.root_hub);
-#else
-	/* FIXME lock root hub */
-	retval = ehci_hub_resume (hcd);
-#endif
-	if (retval == 0)
-		hcd->self.controller->power.power_state = 0;
-	return retval;
+	// FIXME:  if controller didn't retain state,
+	// return and let generic code clean it up
+	// test configured_flag ?
+
+	/* resume HC and each port */
+// restore pci FLADJ value
+	// khubd and drivers will set HC running, if needed;
+	hcd->state = USB_STATE_RUNNING;
+	// FIXME Philips/Intel/... etc don't really have a "READY"
+	// state ... turn on CMD_RUN too
+	for (i = 0; i < ports; i++) {
+		int	temp = readl (&ehci->regs->port_status [i]);
+
+		if ((temp & PORT_PE) == 0
+				|| (temp & PORT_SUSPEND) != 0)
+			continue;
+		ehci_dbg (ehci, "resume port %d", i);
+		temp |= PORT_RESUME;
+		writel (temp, &ehci->regs->port_status [i]);
+		readl (&ehci->regs->command);	/* unblock posted writes */
+
+		wait_ms (20);
+		temp &= ~PORT_RESUME;
+		writel (temp, &ehci->regs->port_status [i]);
+	}
+	readl (&ehci->regs->command);	/* unblock posted writes */
+	return 0;
 }
 
 #endif
@@ -695,18 +668,9 @@
 	timer_action_done (ehci, TIMER_IO_WATCHDOG);
 	if (ehci->reclaim_ready)
 		end_unlink_async (ehci, regs);
-
-	/* another CPU may drop ehci->lock during a schedule scan while
-	 * it reports urb completions.  this flag guards against bogus
-	 * attempts at re-entrant schedule scanning.
-	 */
-	if (ehci->scanning)
-		return;
-	ehci->scanning = 1;
 	scan_async (ehci, regs);
 	if (ehci->next_uframe != -1)
 		scan_periodic (ehci, regs);
-	ehci->scanning = 0;
 
 	/* the IO watchdog guards against hardware or driver bugs that
 	 * misplace IRQs, and should let us run completely without IRQs.
@@ -728,6 +692,12 @@
 
 	status = readl (&ehci->regs->status);
 
+	/* shared irq */
+	if (status == 0) {
+		spin_unlock (&ehci->lock);
+		return IRQ_NONE;
+	}
+
 	/* e.g. cardbus physical eject */
 	if (status == ~(u32) 0) {
 		ehci_dbg (ehci, "device removed\n");
@@ -735,10 +705,8 @@
 	}
 
 	status &= INTR_MASK;
-	if (!status) {			/* irq sharing? */
-		spin_unlock(&ehci->lock);
-		return IRQ_NONE;
-	}
+	if (!status)			/* irq sharing? */
+		goto done;
 
 	/* clear (just) interrupts */
 	writel (status, &ehci->regs->status);
@@ -746,7 +714,7 @@
 	bh = 0;
 
 #ifdef	EHCI_VERBOSE_DEBUG
-	/* unrequested/ignored: Frame List Rollover */
+	/* unrequested/ignored: Port Change Detect, Frame List Rollover */
 	dbg_status (ehci, "irq", status);
 #endif
 
@@ -768,34 +736,6 @@
 		bh = 1;
 	}
 
-	/* remote wakeup [4.3.1] */
-	if ((status & STS_PCD) && ehci->hcd.remote_wakeup) {
-		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
-
-		/* resume root hub? */
-		status = readl (&ehci->regs->command);
-		if (!(status & CMD_RUN))
-			writel (status | CMD_RUN, &ehci->regs->command);
-
-		while (i--) {
-			status = readl (&ehci->regs->port_status [i]);
-			if (status & PORT_OWNER)
-				continue;
-			if (!(status & PORT_RESUME)
-					|| ehci->reset_done [i] != 0)
-				continue;
-
-			/* start 20 msec resume signaling from this port,
-			 * and make khubd collect PORT_STAT_C_SUSPEND to
-			 * stop that signaling.
-			 */
-			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
-			mod_timer (&ehci->hcd.rh_timer,
-					ehci->reset_done [i] + 1);
-			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
-		}
-	}
-
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status & STS_FATAL) != 0)) {
 		ehci_err (ehci, "fatal error\n");
@@ -809,6 +749,7 @@
 
 	if (bh)
 		ehci_work (ehci, regs);
+done:
 	spin_unlock (&ehci->lock);
 	return IRQ_HANDLED;
 }
@@ -835,6 +776,7 @@
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	struct list_head	qtd_list;
 
+	urb->transfer_flags &= ~EHCI_STATE_UNLINK;
 	INIT_LIST_HEAD (&qtd_list);
 
 	switch (usb_pipetype (urb->pipe)) {
@@ -934,6 +876,7 @@
 
 		// wait till next completion, do it then.
 		// completion irqs can wait up to 1024 msec,
+		urb->transfer_flags |= EHCI_STATE_UNLINK;
 		break;
 	}
 	spin_unlock_irqrestore (&ehci->lock, flags);
@@ -984,7 +927,7 @@
 		goto rescan;
 	case QH_STATE_IDLE:		/* fully unlinked */
 		if (list_empty (&qh->qtd_list)) {
-			qh_put (qh);
+			qh_put (ehci, qh);
 			break;
 		}
 		/* else FALL THROUGH */
@@ -997,7 +940,7 @@
 			list_empty (&qh->qtd_list) ? "" : "(has tds)");
 		break;
 	}
-	dev->ep[epnum] = NULL;
+	dev->ep [epnum] = 0;
 done:
 	spin_unlock_irqrestore (&ehci->lock, flags);
 	return;
@@ -1048,15 +991,11 @@
 	 */
 	.hub_status_data =	ehci_hub_status_data,
 	.hub_control =		ehci_hub_control,
-	.hub_suspend =		ehci_hub_suspend,
-	.hub_resume =		ehci_hub_resume,
 };
 
 /*-------------------------------------------------------------------------*/
 
-/* EHCI 1.0 doesn't require PCI */
-
-#ifdef	CONFIG_PCI
+/* EHCI spec says PCI is required. */
 
 /* PCI driver selection metadata; PCI hotplugging uses this */
 static const struct pci_device_id pci_ids [] = { {
@@ -1082,9 +1021,6 @@
 #endif
 };
 
-#endif	/* PCI */
-
-
 #define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
 
 MODULE_DESCRIPTION (DRIVER_INFO);
diff -Naur linuxppc-2.6.9/drivers/usb/host/ehci-hub.c linuxppc-2.6.9-dream/drivers/usb/host/ehci-hub.c
--- linuxppc-2.6.9/drivers/usb/host/ehci-hub.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ehci-hub.c	2005-09-19 21:40:05.000000000 +0200
@@ -28,131 +28,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-#ifdef	CONFIG_PM
-
-static int ehci_hub_suspend (struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	struct usb_device	*root = hcd_to_bus (&ehci->hcd)->root_hub;
-	int			port;
-	int			status = 0;
-
-	if (root->dev.power.power_state != 0)
-		return 0;
-	if (time_before (jiffies, ehci->next_statechange))
-		return -EAGAIN;
-
-	port = HCS_N_PORTS (ehci->hcs_params);
-	spin_lock_irq (&ehci->lock);
-
-	/* suspend any active/unsuspended ports, maybe allow wakeup */
-	while (port--) {
-		u32	t1 = readl (&ehci->regs->port_status [port]);
-		u32	t2 = t1;
-
-		if ((t1 & PORT_PE) && !(t1 & PORT_OWNER))
-			t2 |= PORT_SUSPEND;
-		if (ehci->hcd.remote_wakeup)
-			t2 |= PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E;
-		else
-			t2 &= ~(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E);
-
-		if (t1 != t2) {
-			ehci_vdbg (ehci, "port %d, %08x -> %08x\n",
-				port + 1, t1, t2);
-			writel (t2, &ehci->regs->port_status [port]);
-		}
-	}
-
-	/* stop schedules, then turn off HC and clean any completed work */
-	if (hcd->state == USB_STATE_RUNNING)
-		ehci_ready (ehci);
-	ehci->command = readl (&ehci->regs->command);
-	writel (ehci->command & ~CMD_RUN, &ehci->regs->command);
-	if (ehci->reclaim)
-		ehci->reclaim_ready = 1;
-	ehci_work(ehci, NULL);
-	(void) handshake (&ehci->regs->status, STS_HALT, STS_HALT, 2000);
-
-	root->dev.power.power_state = 3;
-	ehci->next_statechange = jiffies + msecs_to_jiffies(10);
-	spin_unlock_irq (&ehci->lock);
-	return status;
-}
-
-
-/* caller owns root->serialize, and should reset/reinit on error */
-static int ehci_hub_resume (struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	struct usb_device	*root = hcd_to_bus (&ehci->hcd)->root_hub;
-	u32			temp;
-	int			i;
-
-	if (!root->dev.power.power_state)
-		return 0;
-	if (time_before (jiffies, ehci->next_statechange))
-		return -EAGAIN;
-
-	/* re-init operational registers in case we lost power */
-	if (readl (&ehci->regs->intr_enable) == 0) {
-		writel (INTR_MASK, &ehci->regs->intr_enable);
-		writel (0, &ehci->regs->segment);
-		writel (ehci->periodic_dma, &ehci->regs->frame_list);
-		writel ((u32)ehci->async->qh_dma, &ehci->regs->async_next);
-		/* FIXME will this work even (pci) vAUX was lost? */
-	}
-
-	/* restore CMD_RUN, framelist size, and irq threshold */
-	writel (ehci->command, &ehci->regs->command);
-
-	/* take ports out of suspend */
-	i = HCS_N_PORTS (ehci->hcs_params);
-	while (i--) {
-		temp = readl (&ehci->regs->port_status [i]);
-		temp &= ~(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E);
-		if (temp & PORT_SUSPEND) {
-			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
-			temp |= PORT_RESUME;
-		}
-		writel (temp, &ehci->regs->port_status [i]);
-	}
-	i = HCS_N_PORTS (ehci->hcs_params);
-	msleep (20);
-	while (i--) {
-		temp = readl (&ehci->regs->port_status [i]);
-		if ((temp & PORT_SUSPEND) == 0)
-			continue;
-		temp &= ~PORT_RESUME;
-		writel (temp, &ehci->regs->port_status [i]);
-		ehci_vdbg (ehci, "resumed port %d\n", i + 1);
-	}
-	(void) readl (&ehci->regs->command);
-
-	/* maybe re-activate the schedule(s) */
-	temp = 0;
-	if (ehci->async->qh_next.qh)
-		temp |= CMD_ASE;
-	if (ehci->periodic_sched)
-		temp |= CMD_PSE;
-	if (temp)
-		writel (ehci->command | temp, &ehci->regs->command);
-
-	root->dev.power.power_state = 0;
-	ehci->next_statechange = jiffies + msecs_to_jiffies(5);
-	ehci->hcd.state = USB_STATE_RUNNING;
-	return 0;
-}
-
-#else
-
-#define ehci_hub_suspend	NULL
-#define ehci_hub_resume		NULL
-
-#endif	/* CONFIG_PM */
-
-/*-------------------------------------------------------------------------*/
-
 static int check_reset_complete (
 	struct ehci_hcd	*ehci,
 	int		index,
@@ -165,15 +40,6 @@
 
 	/* if reset finished and it's still not enabled -- handoff */
 	if (!(port_status & PORT_PE)) {
-
-		/* with integrated TT, there's nobody to hand it to! */
-		if (ehci_is_ARC(ehci)) {
-			ehci_dbg (ehci,
-				"Failed to enable port %d on root hub TT\n",
-				index+1);
-			return port_status;
-		}
-
 		ehci_dbg (ehci, "port %d full speed --> companion\n",
 			index + 1);
 
@@ -224,11 +90,7 @@
 		}
 		if (!(temp & PORT_CONNECT))
 			ehci->reset_done [i] = 0;
-		if ((temp & (PORT_CSC | PORT_PEC | PORT_OCC)) != 0
-				// PORT_STAT_C_SUSPEND?
-				|| ((temp & PORT_RESUME) != 0
-					&& time_after (jiffies,
-						ehci->reset_done [i]))) {
+		if ((temp & (PORT_CSC | PORT_PEC | PORT_OCC)) != 0) {
 			if (i < 7)
 			    buf [0] |= 1 << (i + 1);
 			else
@@ -272,8 +134,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-#define	PORT_WAKE_BITS 	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
-
 static int ehci_hub_control (
 	struct usb_hcd	*hcd,
 	u16		typeReq,
@@ -325,20 +185,8 @@
 				&ehci->regs->port_status [wIndex]);
 			break;
 		case USB_PORT_FEAT_SUSPEND:
-			if (temp & PORT_RESET)
-				goto error;
-			if (temp & PORT_SUSPEND) {
-				if ((temp & PORT_PE) == 0)
-					goto error;
-				/* resume signaling for 20 msec */
-				writel ((temp & ~PORT_WAKE_BITS) | PORT_RESUME,
-					&ehci->regs->port_status [wIndex]);
-				ehci->reset_done [wIndex] = jiffies
-						+ msecs_to_jiffies (20);
-			}
-			break;
 		case USB_PORT_FEAT_C_SUSPEND:
-			/* we auto-clear this feature */
+			/* ? */
 			break;
 		case USB_PORT_FEAT_POWER:
 			if (HCS_PPC (ehci->hcs_params))
@@ -382,65 +230,38 @@
 			status |= 1 << USB_PORT_FEAT_C_CONNECTION;
 		if (temp & PORT_PEC)
 			status |= 1 << USB_PORT_FEAT_C_ENABLE;
+		// USB_PORT_FEAT_C_SUSPEND
 		if (temp & PORT_OCC)
 			status |= 1 << USB_PORT_FEAT_C_OVER_CURRENT;
 
-		/* whoever resumes must GetPortStatus to complete it!! */
-		if ((temp & PORT_RESUME)
-				&& time_after (jiffies,
-					ehci->reset_done [wIndex])) {
-			status |= 1 << USB_PORT_FEAT_C_SUSPEND;
-			ehci->reset_done [wIndex] = 0;
-
-			/* stop resume signaling */
-			temp = readl (&ehci->regs->port_status [wIndex]);
-			writel (temp & ~PORT_RESUME,
-				&ehci->regs->port_status [wIndex]);
-			retval = handshake (
-					&ehci->regs->port_status [wIndex],
-					PORT_RESUME, 0, 2000 /* 2msec */);
-			if (retval != 0) {
-				ehci_err (ehci, "port %d resume error %d\n",
-					wIndex + 1, retval);
-				goto error;
-			}
-			temp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));
-		}
-
 		/* whoever resets must GetPortStatus to complete it!! */
 		if ((temp & PORT_RESET)
 				&& time_after (jiffies,
 					ehci->reset_done [wIndex])) {
 			status |= 1 << USB_PORT_FEAT_C_RESET;
-			ehci->reset_done [wIndex] = 0;
 
 			/* force reset to complete */
 			writel (temp & ~PORT_RESET,
 					&ehci->regs->port_status [wIndex]);
-			retval = handshake (
-					&ehci->regs->port_status [wIndex],
-					PORT_RESET, 0, 500);
-			if (retval != 0) {
-				ehci_err (ehci, "port %d reset error %d\n",
-					wIndex + 1, retval);
-				goto error;
-			}
+			do {
+				temp = readl (
+					&ehci->regs->port_status [wIndex]);
+				udelay (10);
+			} while (temp & PORT_RESET);
 
 			/* see what we found out */
-			temp = check_reset_complete (ehci, wIndex,
-				readl (&ehci->regs->port_status [wIndex]));
+			temp = check_reset_complete (ehci, wIndex, temp);
 		}
 
 		// don't show wPortStatus if it's owned by a companion hc
 		if (!(temp & PORT_OWNER)) {
 			if (temp & PORT_CONNECT) {
 				status |= 1 << USB_PORT_FEAT_CONNECTION;
-				// status may be from integrated TT
-				status |= ehci_port_speed(ehci, temp);
+				status |= 1 << USB_PORT_FEAT_HIGHSPEED;
 			}
 			if (temp & PORT_PE)
 				status |= 1 << USB_PORT_FEAT_ENABLE;
-			if (temp & (PORT_SUSPEND|PORT_RESUME))
+			if (temp & PORT_SUSPEND)
 				status |= 1 << USB_PORT_FEAT_SUSPEND;
 			if (temp & PORT_OC)
 				status |= 1 << USB_PORT_FEAT_OVER_CURRENT;
@@ -455,7 +276,7 @@
 #endif
 		dbg_port (ehci, "GetStatus", wIndex + 1, temp);
 		// we "know" this alignment is good, caller used kmalloc()...
-		*((__le32 *) buf) = cpu_to_le32 (status);
+		*((u32 *) buf) = cpu_to_le32 (status);
 		break;
 	case SetHubFeature:
 		switch (wValue) {
@@ -477,11 +298,6 @@
 
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
-			if ((temp & PORT_PE) == 0
-					|| (temp & PORT_RESET) != 0)
-				goto error;
-			if (ehci->hcd.remote_wakeup)
-				temp |= PORT_WAKE_BITS;
 			writel (temp | PORT_SUSPEND,
 				&ehci->regs->port_status [wIndex]);
 			break;
@@ -491,14 +307,8 @@
 					&ehci->regs->port_status [wIndex]);
 			break;
 		case USB_PORT_FEAT_RESET:
-			if (temp & PORT_RESUME)
-				goto error;
-			/* line status bits may report this as low speed,
-			 * which can be fine if this root hub has a
-			 * transaction translator built in.
-			 */
+			/* line status bits may report this as low speed */
 			if ((temp & (PORT_PE|PORT_CONNECT)) == PORT_CONNECT
-					&& !ehci_is_ARC(ehci)
 					&& PORT_USB11 (temp)) {
 				ehci_dbg (ehci,
 					"port %d low speed --> companion\n",
@@ -514,7 +324,7 @@
 				 * usb 2.0 spec says 50 ms resets on root
 				 */
 				ehci->reset_done [wIndex] = jiffies
-						+ msecs_to_jiffies (50);
+				    	+ ((50 /* msec */ * HZ) / 1000);
 			}
 			writel (temp, &ehci->regs->port_status [wIndex]);
 			break;
diff -Naur linuxppc-2.6.9/drivers/usb/host/ehci-mem.c linuxppc-2.6.9-dream/drivers/usb/host/ehci-mem.c
--- linuxppc-2.6.9/drivers/usb/host/ehci-mem.c	2004-10-18 23:55:21.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ehci-mem.c	2005-09-19 21:40:05.000000000 +0200
@@ -47,7 +47,7 @@
 		ehci->hcd.product_desc = "EHCI Host Controller";
 		return &ehci->hcd;
 	}
-	return NULL;
+	return 0;
 }
 
 static void ehci_hcd_free (struct usb_hcd *hcd)
@@ -87,22 +87,6 @@
 }
 
 
-static void qh_destroy (struct kref *kref)
-{
-	struct ehci_qh *qh = container_of(kref, struct ehci_qh, kref);
-	struct ehci_hcd *ehci = qh->ehci;
-
-	/* clean qtds first, and know this is not linked */
-	if (!list_empty (&qh->qtd_list) || qh->qh_next.ptr) {
-		ehci_dbg (ehci, "unused qh not empty!\n");
-		BUG ();
-	}
-	if (qh->dummy)
-		ehci_qtd_free (ehci, qh->dummy);
-	usb_put_dev (qh->dev);
-	dma_pool_free (ehci->qh_pool, qh, qh->qh_dma);
-}
-
 static struct ehci_qh *ehci_qh_alloc (struct ehci_hcd *ehci, int flags)
 {
 	struct ehci_qh		*qh;
@@ -114,8 +98,7 @@
 		return qh;
 
 	memset (qh, 0, sizeof *qh);
-	kref_init(&qh->kref);
-	qh->ehci = ehci;
+	atomic_set (&qh->refcount, 1);
 	qh->qh_dma = dma;
 	// INIT_LIST_HEAD (&qh->qh_list);
 	INIT_LIST_HEAD (&qh->qtd_list);
@@ -125,21 +108,31 @@
 	if (qh->dummy == 0) {
 		ehci_dbg (ehci, "no dummy td\n");
 		dma_pool_free (ehci->qh_pool, qh, qh->qh_dma);
-		qh = NULL;
+		qh = 0;
 	}
 	return qh;
 }
 
 /* to share a qh (cpu threads, or hc) */
-static inline struct ehci_qh *qh_get (struct ehci_qh *qh)
+static inline struct ehci_qh *qh_get (/* ehci, */ struct ehci_qh *qh)
 {
-	kref_get(&qh->kref);
+	atomic_inc (&qh->refcount);
 	return qh;
 }
 
-static inline void qh_put (struct ehci_qh *qh)
+static void qh_put (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	kref_put(&qh->kref, qh_destroy);
+	if (!atomic_dec_and_test (&qh->refcount))
+		return;
+	/* clean qtds first, and know this is not linked */
+	if (!list_empty (&qh->qtd_list) || qh->qh_next.ptr) {
+		ehci_dbg (ehci, "unused qh not empty!\n");
+		BUG ();
+	}
+	if (qh->dummy)
+		ehci_qtd_free (ehci, qh->dummy);
+	usb_put_dev (qh->dev);
+	dma_pool_free (ehci->qh_pool, qh, qh->qh_dma);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -152,37 +145,37 @@
 static void ehci_mem_cleanup (struct ehci_hcd *ehci)
 {
 	if (ehci->async)
-		qh_put (ehci->async);
-	ehci->async = NULL;
+		qh_put (ehci, ehci->async);
+	ehci->async = 0;
 
 	/* DMA consistent memory and pools */
 	if (ehci->qtd_pool)
 		dma_pool_destroy (ehci->qtd_pool);
-	ehci->qtd_pool = NULL;
+	ehci->qtd_pool = 0;
 
 	if (ehci->qh_pool) {
 		dma_pool_destroy (ehci->qh_pool);
-		ehci->qh_pool = NULL;
+		ehci->qh_pool = 0;
 	}
 
 	if (ehci->itd_pool)
 		dma_pool_destroy (ehci->itd_pool);
-	ehci->itd_pool = NULL;
+	ehci->itd_pool = 0;
 
 	if (ehci->sitd_pool)
 		dma_pool_destroy (ehci->sitd_pool);
-	ehci->sitd_pool = NULL;
+	ehci->sitd_pool = 0;
 
 	if (ehci->periodic)
 		dma_free_coherent (ehci->hcd.self.controller,
 			ehci->periodic_size * sizeof (u32),
 			ehci->periodic, ehci->periodic_dma);
-	ehci->periodic = NULL;
+	ehci->periodic = 0;
 
 	/* shadow periodic table */
 	if (ehci->pshadow)
 		kfree (ehci->pshadow);
-	ehci->pshadow = NULL;
+	ehci->pshadow = 0;
 }
 
 /* remember to add cleanup code (above) if you add anything here */
@@ -235,9 +228,9 @@
 	}
 
 	/* Hardware periodic table */
-	ehci->periodic = (__le32 *)
+	ehci->periodic = (u32 *)
 		dma_alloc_coherent (ehci->hcd.self.controller,
-			ehci->periodic_size * sizeof(__le32),
+			ehci->periodic_size * sizeof (u32),
 			&ehci->periodic_dma, 0);
 	if (ehci->periodic == 0) {
 		goto fail;
diff -Naur linuxppc-2.6.9/drivers/usb/host/ehci-q.c linuxppc-2.6.9-dream/drivers/usb/host/ehci-q.c
--- linuxppc-2.6.9/drivers/usb/host/ehci-q.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ehci-q.c	2005-09-19 21:40:05.000000000 +0200
@@ -153,14 +153,19 @@
 			usb_pipein (urb->pipe) ? "in" : "out",
 			token, urb->status);
 
+		/* stall indicates some recovery action is needed */
+		if (urb->status == -EPIPE) {
+			int	pipe = urb->pipe;
+
+			if (!usb_pipecontrol (pipe))
+				usb_endpoint_halt (urb->dev,
+					usb_pipeendpoint (pipe),
+					usb_pipeout (pipe));
+
 		/* if async CSPLIT failed, try cleaning out the TT buffer */
-		if (urb->status != -EPIPE
-				&& urb->dev->tt && !usb_pipeint (urb->pipe)
+		} else if (urb->dev->tt && !usb_pipeint (urb->pipe)
 				&& ((token & QTD_STS_MMF) != 0
-					|| QTD_CERR(token) == 0)
-				&& (!ehci_is_ARC(ehci)
-                	                || urb->dev->tt->hub !=
-						ehci->hcd.self.root_hub)) {
+					|| QTD_CERR(token) == 0)) {
 #ifdef DEBUG
 			struct usb_device *tt = urb->dev->tt->hub;
 			dev_dbg (&tt->dev,
@@ -185,11 +190,11 @@
 			/* ... update hc-wide periodic stats (for usbfs) */
 			hcd_to_bus (&ehci->hcd)->bandwidth_int_reqs--;
 		}
-		qh_put (qh);
+		qh_put (ehci, qh);
 	}
 
 	spin_lock (&urb->lock);
-	urb->hcpriv = NULL;
+	urb->hcpriv = 0;
 	switch (urb->status) {
 	case -EINPROGRESS:		/* success */
 		urb->status = 0;
@@ -234,7 +239,7 @@
 static unsigned
 qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh, struct pt_regs *regs)
 {
-	struct ehci_qtd		*last = NULL, *end = qh->dummy;
+	struct ehci_qtd		*last = 0, *end = qh->dummy;
 	struct list_head	*entry, *tmp;
 	int			stopped;
 	unsigned		count = 0;
@@ -274,7 +279,7 @@
 				count++;
 			}
 			ehci_qtd_free (ehci, last);
-			last = NULL;
+			last = 0;
 		}
 
 		/* ignore urbs submitted during completions we reported */
@@ -375,7 +380,7 @@
 					struct ehci_qtd, qtd_list);
 			/* first qtd may already be partially processed */
 			if (cpu_to_le32 (end->qtd_dma) == qh->hw_current)
-				end = NULL;
+				end = 0;
 		}
 		if (end)
 			qh_update (ehci, qh, end);
@@ -432,7 +437,7 @@
 	 */
 	qtd = ehci_qtd_alloc (ehci, flags);
 	if (unlikely (!qtd))
-		return NULL;
+		return 0;
 	list_add_tail (&qtd->qtd_list, head);
 	qtd->urb = urb;
 
@@ -547,7 +552,7 @@
 
 cleanup:
 	qtd_list_free (ehci, urb, head);
-	return NULL;
+	return 0;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -571,7 +576,7 @@
 // when each interface/altsetting is established.  Unlink
 // any previous qh and cancel its urbs first; endpoints are
 // implicitly reset then (data toggle too).
-// That'd mean updating how usbcore talks to HCDs. (2.7?)
+// That'd mean updating how usbcore talks to HCDs. (2.5?)
 
 
 /*
@@ -669,13 +674,7 @@
 
 		info2 |= (EHCI_TUNE_MULT_TT << 30);
 		info2 |= urb->dev->ttport << 23;
-
-		/* set the address of the TT; for ARC's integrated
-		 * root hub tt, leave it zeroed.
-		 */
-		if (!ehci_is_ARC(ehci)
-				|| urb->dev->tt->hub != ehci->hcd.self.root_hub)
-			info2 |= urb->dev->tt->hub->devnum << 16;
+		info2 |= urb->dev->tt->hub->devnum << 16;
 
 		/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets c-mask } */
 
@@ -700,8 +699,8 @@
 	default:
  		dbg ("bogus dev %p speed %d", urb->dev, urb->dev->speed);
 done:
-		qh_put (qh);
-		return NULL;
+		qh_put (ehci, qh);
+		return 0;
 	}
 
 	/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets s-mask } */
@@ -721,7 +720,7 @@
 
 static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	__le32		dma = QH_NEXT (qh->qh_dma);
+	u32		dma = QH_NEXT (qh->qh_dma);
 	struct ehci_qh	*head;
 
 	/* (re)start the async schedule? */
@@ -756,7 +755,7 @@
 
 /*-------------------------------------------------------------------------*/
 
-#define	QH_ADDR_MASK	__constant_cpu_to_le32(0x7f)
+#define	QH_ADDR_MASK	__constant_le32_to_cpu(0x7f)
 
 /*
  * For control/bulk/interrupt, return QH with these TDs appended.
@@ -772,19 +771,19 @@
 	void			**ptr
 )
 {
-	struct ehci_qh		*qh = NULL;
+	struct ehci_qh		*qh = 0;
 
 	qh = (struct ehci_qh *) *ptr;
-	if (unlikely (qh == NULL)) {
+	if (unlikely (qh == 0)) {
 		/* can't sleep here, we have ehci->lock... */
 		qh = qh_make (ehci, urb, GFP_ATOMIC);
 		*ptr = qh;
 	}
-	if (likely (qh != NULL)) {
+	if (likely (qh != 0)) {
 		struct ehci_qtd	*qtd;
 
 		if (unlikely (list_empty (qtd_list)))
-			qtd = NULL;
+			qtd = 0;
 		else
 			qtd = list_entry (qtd_list->next, struct ehci_qtd,
 					qtd_list);
@@ -840,7 +839,7 @@
 		if (likely (qtd != 0)) {
 			struct ehci_qtd		*dummy;
 			dma_addr_t		dma;
-			__le32			token;
+			u32			token;
 
 			/* to avoid racing the HC, use the dummy td instead of
 			 * the first td of our list (becomes new dummy).  both
@@ -892,7 +891,7 @@
 	struct hcd_dev		*dev;
 	int			epnum;
 	unsigned long		flags;
-	struct ehci_qh		*qh = NULL;
+	struct ehci_qh		*qh = 0;
 
 	qtd = list_entry (qtd_list->next, struct ehci_qtd, qtd_list);
 	dev = (struct hcd_dev *)urb->dev->hcpriv;
@@ -942,14 +941,14 @@
 
 	// qh->hw_next = cpu_to_le32 (qh->qh_dma);
 	qh->qh_state = QH_STATE_IDLE;
-	qh->qh_next.qh = NULL;
-	qh_put (qh);			// refcount from reclaim 
+	qh->qh_next.qh = 0;
+	qh_put (ehci, qh);			// refcount from reclaim 
 
 	/* other unlink(s) may be pending (in QH_STATE_UNLINK_WAIT) */
 	next = qh->reclaim;
 	ehci->reclaim = next;
 	ehci->reclaim_ready = 0;
-	qh->reclaim = NULL;
+	qh->reclaim = 0;
 
 	qh_completions (ehci, qh, regs);
 
@@ -957,7 +956,7 @@
 			&& HCD_IS_RUNNING (ehci->hcd.state))
 		qh_link_async (ehci, qh);
 	else {
-		qh_put (qh);		// refcount from async list
+		qh_put (ehci, qh);		// refcount from async list
 
 		/* it's not free to turn the async schedule on/off; leave it
 		 * active but idle for a while once it empties.
@@ -968,7 +967,7 @@
 	}
 
 	if (next) {
-		ehci->reclaim = NULL;
+		ehci->reclaim = 0;
 		start_unlink_async (ehci, next);
 	}
 }
@@ -1059,7 +1058,7 @@
 				qh = qh_get (qh);
 				qh->stamp = ehci->stamp;
 				temp = qh_completions (ehci, qh, regs);
-				qh_put (qh);
+				qh_put (ehci, qh);
 				if (temp != 0) {
 					goto rescan;
 				}
diff -Naur linuxppc-2.6.9/drivers/usb/host/ehci-sched.c linuxppc-2.6.9-dream/drivers/usb/host/ehci-sched.c
--- linuxppc-2.6.9/drivers/usb/host/ehci-sched.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ehci-sched.c	2005-09-19 21:40:05.000000000 +0200
@@ -44,7 +44,7 @@
  * @tag: hardware tag for type of this record
  */
 static union ehci_shadow *
-periodic_next_shadow (union ehci_shadow *periodic, __le32 tag)
+periodic_next_shadow (union ehci_shadow *periodic, int tag)
 {
 	switch (tag) {
 	case Q_TYPE_QH:
@@ -64,7 +64,7 @@
 static int periodic_unlink (struct ehci_hcd *ehci, unsigned frame, void *ptr)
 {
 	union ehci_shadow	*prev_p = &ehci->pshadow [frame];
-	__le32			*hw_p = &ehci->periodic [frame];
+	u32			*hw_p = &ehci->periodic [frame];
 	union ehci_shadow	here = *prev_p;
 	union ehci_shadow	*next_p;
 
@@ -89,7 +89,7 @@
 
 	/* unlink from shadow list; HCD won't see old structure again */
 	*prev_p = *next_p;
-	next_p->ptr = NULL;
+	next_p->ptr = 0;
 
 	return 1;
 }
@@ -98,7 +98,7 @@
 static unsigned short
 periodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)
 {
-	__le32			*hw_p = &ehci->periodic [frame];
+	u32			*hw_p = &ehci->periodic [frame];
 	union ehci_shadow	*q = &ehci->pshadow [frame];
 	unsigned		usecs = 0;
 
@@ -196,7 +196,7 @@
 	 */
 	for (; frame < ehci->periodic_size; frame += period) {
 		union ehci_shadow	here;
-		__le32			type;
+		u32			type;
 
 		here = ehci->pshadow [frame];
 		type = Q_NEXT_TYPE (ehci->periodic [frame]);
@@ -312,12 +312,12 @@
 
 	do {
 		periodic_unlink (ehci, frame, qh);
-		qh_put (qh);
+		qh_put (ehci, qh);
 		frame += qh->period;
 	} while (frame < ehci->periodic_size);
 
 	qh->qh_state = QH_STATE_UNLINK;
-	qh->qh_next.ptr = NULL;
+	qh->qh_next.ptr = 0;
 	ehci->periodic_sched--;
 
 	/* maybe turn off periodic schedule */
@@ -355,7 +355,7 @@
 
 	dbg ("descheduled qh %p, period = %d frame = %d count = %d, urbs = %d",
 		qh, qh->period, frame,
-		atomic_read (&qh->kref.refcount), ehci->periodic_sched);
+		atomic_read (&qh->refcount), ehci->periodic_sched);
 }
 
 static int check_period (
@@ -403,7 +403,7 @@
 	unsigned		frame,
 	unsigned		uframe,
 	const struct ehci_qh	*qh,
-	__le32			*c_maskp
+	u32			*c_maskp
 )
 {
     	int		retval = -ENOSPC;
@@ -412,7 +412,7 @@
 		goto done;
 	if (!qh->c_usecs) {
 		retval = 0;
-		*c_maskp = 0;
+		*c_maskp = cpu_to_le32 (0);
 		goto done;
 	}
 
@@ -447,7 +447,7 @@
 {
 	int 		status;
 	unsigned	uframe;
-	__le32		c_mask;
+	u32		c_mask;
 	unsigned	frame;		/* 0..(qh->period - 1), or NO_FRAME */
 
 	qh->hw_next = EHCI_LIST_END;
@@ -483,7 +483,7 @@
 		qh->start = frame;
 
 		/* reset S-frame and (maybe) C-frame masks */
-		qh->hw_info2 &= ~__constant_cpu_to_le32(0xffff);
+		qh->hw_info2 &= ~0xffff;
 		qh->hw_info2 |= cpu_to_le32 (1 << uframe) | c_mask;
 	} else
 		dbg ("reused previous qh %p schedule", qh);
@@ -718,7 +718,7 @@
 
 		is_in = (stream->bEndpointAddress & USB_DIR_IN) ? 0x10 : 0;
 		stream->bEndpointAddress &= 0x0f;
-		dev->ep[is_in + stream->bEndpointAddress] = NULL;
+		dev->ep [is_in + stream->bEndpointAddress] = 0;
 
 		if (stream->rescheduled) {
 			ehci_info (ehci, "ep%d%s-iso rescheduled "
@@ -772,7 +772,7 @@
 		ehci_dbg (ehci, "dev %s ep%d%s, not iso??\n",
 			urb->dev->devpath, epnum & 0x0f,
 			(epnum & 0x10) ? "in" : "out");
-		stream = NULL;
+		stream = 0;
 	}
 
 	/* caller guarantees an eventual matching iso_stream_put */
@@ -896,7 +896,7 @@
 			list_del (&itd->itd_list);
 			itd_dma = itd->itd_dma;
 		} else
-			itd = NULL;
+			itd = 0;
 
 		if (!itd) {
 			spin_unlock_irqrestore (&ehci->lock, flags);
@@ -1008,7 +1008,8 @@
 		uframe += period_uframes;
 	} while (uframe < mod);
 
-	stream->splits = cpu_to_le32(stream->raw_mask << (uframe & 7));
+	stream->splits = stream->raw_mask << (uframe & 7);
+	cpu_to_le32s (&stream->splits);
 	return 1;
 }
 
@@ -1115,7 +1116,7 @@
 
 fail:
 	iso_sched_free (stream, sched);
-	urb->hcpriv = NULL;
+	urb->hcpriv = 0;
 	return status;
 
 ready:
@@ -1214,8 +1215,8 @@
 	hcd_to_bus (&ehci->hcd)->bandwidth_isoc_reqs++;
 
 	/* fill iTDs uframe by uframe */
-	for (packet = 0, itd = NULL; packet < urb->number_of_packets; ) {
-		if (itd == NULL) {
+	for (packet = 0, itd = 0; packet < urb->number_of_packets; ) {
+		if (itd == 0) {
 			/* ASSERT:  we have all necessary itds */
 			// BUG_ON (list_empty (&iso_sched->td_list));
 
@@ -1246,14 +1247,14 @@
 		if (((next_uframe >> 3) != frame)
 				|| packet == urb->number_of_packets) {
 			itd_link (ehci, frame % ehci->periodic_size, itd);
-			itd = NULL;
+			itd = 0;
 		}
 	}
 	stream->next_uframe = next_uframe;
 
 	/* don't need that schedule data any more */
 	iso_sched_free (stream, iso_sched);
-	urb->hcpriv = NULL;
+	urb->hcpriv = 0;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
 	if (unlikely (!ehci->periodic_sched++))
@@ -1310,8 +1311,8 @@
 	}
 
 	usb_put_urb (urb);
-	itd->urb = NULL;
-	itd->stream = NULL;
+	itd->urb = 0;
+	itd->stream = 0;
 	list_move (&itd->itd_list, &stream->free_list);
 	iso_stream_put (ehci, stream);
 
@@ -1327,7 +1328,7 @@
 	/* give urb back to the driver ... can be out-of-order */
 	dev = usb_get_dev (urb->dev);
 	ehci_urb_done (ehci, urb, regs);
-	urb = NULL;
+	urb = 0;
 
 	/* defer stopping schedule; completion can submit */
 	ehci->periodic_sched--;
@@ -1498,7 +1499,7 @@
 			list_del (&sitd->sitd_list);
 			sitd_dma = sitd->sitd_dma;
 		} else
-			sitd = NULL;
+			sitd = 0;
 
 		if (!sitd) {
 			spin_unlock_irqrestore (&ehci->lock, flags);
@@ -1599,7 +1600,7 @@
 	hcd_to_bus (&ehci->hcd)->bandwidth_isoc_reqs++;
 
 	/* fill sITDs frame by frame */
-	for (packet = 0, sitd = NULL;
+	for (packet = 0, sitd = 0;
 			packet < urb->number_of_packets;
 			packet++) {
 
@@ -1625,7 +1626,7 @@
 
 	/* don't need that schedule data any more */
 	iso_sched_free (stream, sched);
-	urb->hcpriv = NULL;
+	urb->hcpriv = 0;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
 	if (!ehci->periodic_sched++)
@@ -1672,8 +1673,8 @@
 	}
 
 	usb_put_urb (urb);
-	sitd->urb = NULL;
-	sitd->stream = NULL;
+	sitd->urb = 0;
+	sitd->stream = 0;
 	list_move (&sitd->sitd_list, &stream->free_list);
 	stream->depth -= stream->interval << 3;
 	iso_stream_put (ehci, stream);
@@ -1690,7 +1691,7 @@
 	/* give urb back to the driver */
 	dev = usb_get_dev (urb->dev);
 	ehci_urb_done (ehci, urb, regs);
-	urb = NULL;
+	urb = 0;
 
 	/* defer stopping schedule; completion can submit */
 	ehci->periodic_sched--;
@@ -1811,7 +1812,7 @@
 
 	for (;;) {
 		union ehci_shadow	q, *q_p;
-		__le32			type, *hw_p;
+		u32			type, *hw_p;
 		unsigned		uframes;
 
 		/* don't scan past the live uframe */
@@ -1845,7 +1846,7 @@
 				modified = qh_completions (ehci, temp.qh, regs);
 				if (unlikely (list_empty (&temp.qh->qtd_list)))
 					intr_deschedule (ehci, temp.qh, 0);
-				qh_put (temp.qh);
+				qh_put (ehci, temp.qh);
 				break;
 			case Q_TYPE_FSTN:
 				/* for "save place" FSTNs, look at QH entries
@@ -1902,7 +1903,7 @@
 				dbg ("corrupt type %d frame %d shadow %p",
 					type, frame, q.ptr);
 				// BUG ();
-				q.ptr = NULL;
+				q.ptr = 0;
 			}
 
 			/* assume completion callbacks modify the queue */
diff -Naur linuxppc-2.6.9/drivers/usb/host/hc_simple.c linuxppc-2.6.9-dream/drivers/usb/host/hc_simple.c
--- linuxppc-2.6.9/drivers/usb/host/hc_simple.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/hc_simple.c	2005-09-19 21:40:05.000000000 +0200
@@ -146,6 +146,11 @@
 	if (!urb->dev || !urb->dev->bus || urb->hcpriv)
 		return -EINVAL;
 
+	if (usb_endpoint_halted
+	    (urb->dev, usb_pipeendpoint (pipe), usb_pipeout (pipe))) {
+		printk ("hci_submit_urb: endpoint_halted\n");
+		return -EPIPE;
+	}
 	hci = (hci_t *) urb->dev->bus->hcpriv;
 
 	/* a request to the virtual root hub */
@@ -184,7 +189,7 @@
  *
  * Return: 0 if success or error code 
  **************************************************************************/
-static int hci_unlink_urb (struct urb * urb, int status)
+static int hci_unlink_urb (struct urb * urb)
 {
 	unsigned long flags;
 	hci_t *hci;
@@ -214,21 +219,45 @@
 	if (!list_empty (&urb->urb_list) && urb->status == -EINPROGRESS) {
 		/* URB active? */
 
-		/* asynchronous with callback */
-		/* relink the urb to the del list */
-		list_move (&urb->urb_list, &hci->del_list);
-		urb->status = status;
-		spin_unlock_irqrestore (&usb_urb_lock, flags);
+		if (urb->transfer_flags & URB_ASYNC_UNLINK) {
+			/* asynchronous with callback */
+			/* relink the urb to the del list */
+			list_move (&urb->urb_list, &hci->del_list);
+			spin_unlock_irqrestore (&usb_urb_lock, flags);
+		} else {
+			/* synchronous without callback */
+
+			add_wait_queue (&hci->waitq, &wait);
+
+			set_current_state (TASK_UNINTERRUPTIBLE);
+			comp = urb->complete;
+			urb->complete = NULL;
+
+			/* relink the urb to the del list */
+			list_move(&urb->urb_list, &hci->del_list);
+
+			spin_unlock_irqrestore (&usb_urb_lock, flags);
+
+			schedule_timeout (HZ / 50);
+
+			if (!list_empty (&urb->urb_list))
+				list_del (&urb->urb_list);
+
+			urb->complete = comp;
+			urb->hcpriv = NULL;
+			remove_wait_queue (&hci->waitq, &wait);
+		}
 	} else {
 		/* hcd does not own URB but we keep the driver happy anyway */
 		spin_unlock_irqrestore (&usb_urb_lock, flags);
 
-		if (urb->complete) {
-			urb->status = status;
+		if (urb->complete && (urb->transfer_flags & URB_ASYNC_UNLINK)) {
+			urb->status = -ENOENT;
 			urb->actual_length = 0;
 			urb->complete (urb, NULL);
-			if (urb->reject)
-				wake_up (&usb_kill_urb_queue);
+			urb->status = 0;
+		} else {
+			urb->status = -ENOENT;
 		}
 	}
 
diff -Naur linuxppc-2.6.9/drivers/usb/host/hc_sl811.c linuxppc-2.6.9-dream/drivers/usb/host/hc_sl811.c
--- linuxppc-2.6.9/drivers/usb/host/hc_sl811.c	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/hc_sl811.c	2005-09-19 21:40:05.000000000 +0200
@@ -106,14 +106,14 @@
 
 static int sofWaitCnt = 0;
 
-module_param(urb_debug, int, 0);
+MODULE_PARM (urb_debug, "i");
 MODULE_PARM_DESC (urb_debug, "debug urb messages, default is 0 (no)");
 
-module_param(base_addr, int, 0);
+MODULE_PARM (base_addr, "i");
 MODULE_PARM_DESC (base_addr, "sl811 base address 0xd3800000");
-module_param(data_reg_addr, int, 0);
+MODULE_PARM (data_reg_addr, "i");
 MODULE_PARM_DESC (data_reg_addr, "sl811 data register address 0xd3810000");
-module_param(irq, int, 0);
+MODULE_PARM (irq, "i");
 MODULE_PARM_DESC (irq, "IRQ 34 (default)");
 
 static int hc_reset (hci_t * hci);
diff -Naur linuxppc-2.6.9/drivers/usb/host/hc_sl811_rh.c linuxppc-2.6.9-dream/drivers/usb/host/hc_sl811_rh.c
--- linuxppc-2.6.9/drivers/usb/host/hc_sl811_rh.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/hc_sl811_rh.c	2005-09-19 21:40:05.000000000 +0200
@@ -557,24 +557,18 @@
 static int rh_connect_rh (hci_t * hci)
 {
 	struct usb_device *usb_dev;
-	int retval;
 
 	hci->rh.devnum = 0;
 	usb_dev = usb_alloc_dev (NULL, hci->bus, 0);
 	if (!usb_dev)
 		return -ENOMEM;
 
+	hci->bus->root_hub = usb_dev;
 	usb_dev->devnum = 1;
 	usb_dev->bus->devnum_next = usb_dev->devnum + 1;
 	set_bit (usb_dev->devnum, usb_dev->bus->devmap.devicemap);
 
-	down (&usb_bus_list_lock);
-	hci->bus->root_hub = usb_dev;
-	retval = usb_new_device (usb_dev);
-	if (retval != 0)
-		hci->bus->root_hub = NULL;
-	up (&usb_bus_list_lock);
-	if (retval != 0) {
+	if (usb_new_device (usb_dev) != 0) {
 		usb_put_dev (usb_dev);
 		return -ENODEV;
 	}
diff -Naur linuxppc-2.6.9/drivers/usb/host/Kconfig linuxppc-2.6.9-dream/drivers/usb/host/Kconfig
--- linuxppc-2.6.9/drivers/usb/host/Kconfig	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/Kconfig	2005-09-19 21:40:05.000000000 +0200
@@ -38,21 +38,9 @@
 	  EHCI or USB 2.0 transaction translator implementations.
 	  It should work for ISO-OUT transfers, like audio.
 
-config USB_EHCI_ROOT_HUB_TT
-	bool "Root Hub Transaction Translators (EXPERIMENTAL)"
-	depends on USB_EHCI_HCD && EXPERIMENTAL
-	---help---
-	  Some EHCI chips have vendor-specific extensions to integrate
-	  transaction translators, so that no OHCI or UHCI companion
-	  controller is needed.  It's safe to say "y" even if your
-	  controller doesn't support this feature.
-
-	  This supports the EHCI implementation from ARC International.
-
 config USB_OHCI_HCD
 	tristate "OHCI HCD support"
 	depends on USB
-	select ISP1301_OMAP if MACH_OMAP_H2
 	---help---
 	  The Open Host Controller Interface (OHCI) is a standard for accessing
 	  USB 1.1 host controller hardware.  It does more in hardware than Intel's
diff -Naur linuxppc-2.6.9/drivers/usb/host/ohci-dbg.c linuxppc-2.6.9-dream/drivers/usb/host/ohci-dbg.c
--- linuxppc-2.6.9/drivers/usb/host/ohci-dbg.c	2004-10-18 23:55:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ohci-dbg.c	2005-09-19 21:40:05.000000000 +0200
@@ -131,16 +131,16 @@
 static void
 ohci_dump_status (struct ohci_hcd *controller, char **next, unsigned *size)
 {
-	struct ohci_regs __iomem *regs = controller->regs;
+	struct ohci_regs	*regs = controller->regs;
 	u32			temp;
 
-	temp = ohci_readl (&regs->revision) & 0xff;
+	temp = readl (&regs->revision) & 0xff;
 	ohci_dbg_sw (controller, next, size,
 		"OHCI %d.%d, %s legacy support registers\n",
 		0x03 & (temp >> 4), (temp & 0x0f),
 		(temp & 0x10) ? "with" : "NO");
 
-	temp = ohci_readl (&regs->control);
+	temp = readl (&regs->control);
 	ohci_dbg_sw (controller, next, size,
 		"control 0x%03x%s%s%s HCFS=%s%s%s%s%s CBSR=%d\n",
 		temp,
@@ -155,7 +155,7 @@
 		temp & OHCI_CTRL_CBSR
 		);
 
-	temp = ohci_readl (&regs->cmdstatus);
+	temp = readl (&regs->cmdstatus);
 	ohci_dbg_sw (controller, next, size,
 		"cmdstatus 0x%05x SOC=%d%s%s%s%s\n", temp,
 		(temp & OHCI_SOC) >> 16,
@@ -166,26 +166,26 @@
 		);
 
 	ohci_dump_intr_mask (controller, "intrstatus",
-			ohci_readl (&regs->intrstatus), next, size);
+			readl (&regs->intrstatus), next, size);
 	ohci_dump_intr_mask (controller, "intrenable",
-			ohci_readl (&regs->intrenable), next, size);
+			readl (&regs->intrenable), next, size);
 	// intrdisable always same as intrenable
 
 	maybe_print_eds (controller, "ed_periodcurrent",
-			ohci_readl (&regs->ed_periodcurrent), next, size);
+			readl (&regs->ed_periodcurrent), next, size);
 
 	maybe_print_eds (controller, "ed_controlhead",
-			ohci_readl (&regs->ed_controlhead), next, size);
+			readl (&regs->ed_controlhead), next, size);
 	maybe_print_eds (controller, "ed_controlcurrent",
-			ohci_readl (&regs->ed_controlcurrent), next, size);
+			readl (&regs->ed_controlcurrent), next, size);
 
 	maybe_print_eds (controller, "ed_bulkhead",
-			ohci_readl (&regs->ed_bulkhead), next, size);
+			readl (&regs->ed_bulkhead), next, size);
 	maybe_print_eds (controller, "ed_bulkcurrent",
-			ohci_readl (&regs->ed_bulkcurrent), next, size);
+			readl (&regs->ed_bulkcurrent), next, size);
 
 	maybe_print_eds (controller, "donehead",
-			ohci_readl (&regs->donehead), next, size);
+			readl (&regs->donehead), next, size);
 }
 
 #define dbg_port_sw(hc,num,value,next,size) \
@@ -266,11 +266,11 @@
 	ohci_dbg (controller, "OHCI controller state\n");
 
 	// dumps some of the state we know about
-	ohci_dump_status (controller, NULL, NULL);
+	ohci_dump_status (controller, NULL, 0);
 	if (controller->hcca)
 		ohci_dbg (controller,
 			"hcca frame #%04x\n", OHCI_FRAME_NO(controller->hcca));
-	ohci_dump_roothub (controller, 1, NULL, NULL);
+	ohci_dump_roothub (controller, 1, NULL, 0);
 }
 
 static const char data0 [] = "DATA0";
@@ -336,7 +336,7 @@
 ohci_dump_ed (const struct ohci_hcd *ohci, const char *label,
 		const struct ed *ed, int verbose)
 {
-	__le32	tmp = ed->hwINFO;
+	u32	tmp = ed->hwINFO;
 	char	*type = "";
 
 	ohci_dbg (ohci, "%s, ed %p state 0x%x type %s; next ed %08x\n",
@@ -359,7 +359,7 @@
 		type,
 		0x007f & le32_to_cpu (tmp));
 	ohci_dbg (ohci, "  tds: head %08x %s%s tail %08x%s\n",
-		le32_to_cpup (&ed->hwHeadP),
+		tmp = le32_to_cpup (&ed->hwHeadP),
 		(ed->hwHeadP & ED_C) ? data1 : data0,
 		(ed->hwHeadP & ED_H) ? " HALT" : "",
 		le32_to_cpup (&ed->hwTailP),
@@ -415,8 +415,8 @@
 
 	/* dump a snapshot of the bulk or control schedule */
 	while (ed) {
-		__le32			info = ed->hwINFO;
-		u32			scratch = le32_to_cpup (&ed->hwINFO);
+		u32			info = ed->hwINFO;
+		u32			scratch = cpu_to_le32p (&ed->hwINFO);
 		struct list_head	*entry;
 		struct td		*td;
 
@@ -439,7 +439,7 @@
 			u32		cbp, be;
 
 			td = list_entry (entry, struct td, td_list);
-			scratch = le32_to_cpup (&td->hwINFO);
+			scratch = cpu_to_le32p (&td->hwINFO);
 			cbp = le32_to_cpup (&td->hwCBP);
 			be = le32_to_cpup (&td->hwBE);
 			temp = scnprintf (buf, size,
@@ -541,8 +541,8 @@
 
 			/* show more info the first time around */
 			if (temp == seen_count) {
-				__le32	info = ed->hwINFO;
-				u32	scratch = le32_to_cpup (&ed->hwINFO);
+				u32	info = ed->hwINFO;
+				u32	scratch = cpu_to_le32p (&ed->hwINFO);
 				struct list_head	*entry;
 				unsigned		qlen = 0;
 
@@ -574,7 +574,7 @@
 			} else {
 				/* we've seen it and what's after */
 				temp = 0;
-				ed = NULL;
+				ed = 0;
 			}
 
 		} while (ed);
@@ -599,7 +599,7 @@
 	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
 	struct ohci_hcd		*ohci;
-	struct ohci_regs __iomem *regs;
+	struct ohci_regs	*regs;
 	unsigned long		flags;
 	unsigned		temp, size;
 	char			*next;
@@ -617,17 +617,7 @@
 	/* dump driver info, then registers in spec order */
 
 	ohci_dbg_sw (ohci, &next, &size,
-		"bus %s, device %s\n"
-		"%s version " DRIVER_VERSION "\n",
-		hcd->self.controller->bus->name,
-		hcd->self.controller->bus_id,
-		hcd_name);
-
-	if (bus->controller->power.power_state) {
-		size -= scnprintf (next, size,
-			"SUSPENDED (no register access)\n");
-		goto done;
-	}
+		"%s version " DRIVER_VERSION "\n", hcd_name);
 
 	ohci_dump_status(ohci, &next, &size);
 
@@ -637,7 +627,7 @@
 			"hcca frame 0x%04x\n", OHCI_FRAME_NO(ohci->hcca));
 
 	/* other registers mostly affect frame timings */
-	rdata = ohci_readl (&regs->fminterval);
+	rdata = readl (&regs->fminterval);
 	temp = scnprintf (next, size,
 			"fmintvl 0x%08x %sFSMPS=0x%04x FI=0x%04x\n",
 			rdata, (rdata >> 31) ? " FIT" : "",
@@ -645,20 +635,20 @@
 	size -= temp;
 	next += temp;
 
-	rdata = ohci_readl (&regs->fmremaining);
+	rdata = readl (&regs->fmremaining);
 	temp = scnprintf (next, size, "fmremaining 0x%08x %sFR=0x%04x\n",
 			rdata, (rdata >> 31) ? " FRT" : "",
 			rdata & 0x3fff);
 	size -= temp;
 	next += temp;
 
-	rdata = ohci_readl (&regs->periodicstart);
+	rdata = readl (&regs->periodicstart);
 	temp = scnprintf (next, size, "periodicstart 0x%04x\n",
 			rdata & 0x3fff);
 	size -= temp;
 	next += temp;
 
-	rdata = ohci_readl (&regs->lsthresh);
+	rdata = readl (&regs->lsthresh);
 	temp = scnprintf (next, size, "lsthresh 0x%04x\n",
 			rdata & 0x3fff);
 	size -= temp;
@@ -667,8 +657,8 @@
 	/* roothub */
 	ohci_dump_roothub (ohci, 1, &next, &size);
 
-done:
 	spin_unlock_irqrestore (&ohci->lock, flags);
+
 	return PAGE_SIZE - size;
 }
 static CLASS_DEVICE_ATTR (registers, S_IRUGO, show_registers, NULL);
diff -Naur linuxppc-2.6.9/drivers/usb/host/ohci.h linuxppc-2.6.9-dream/drivers/usb/host/ohci.h
--- linuxppc-2.6.9/drivers/usb/host/ohci.h	2004-10-18 23:55:35.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ohci.h	2005-09-19 21:40:05.000000000 +0200
@@ -16,7 +16,7 @@
  */
 struct ed {
 	/* first fields are hardware-specified, le32 */
-	__le32			hwINFO;       	/* endpoint config bitmap */
+	__u32			hwINFO;       	/* endpoint config bitmap */
 	/* info bits defined by hcd */
 #define ED_DEQUEUE	__constant_cpu_to_le32(1 << 27)
 	/* info bits defined by the hardware */
@@ -25,11 +25,11 @@
 #define ED_LOWSPEED	__constant_cpu_to_le32(1 << 13)
 #define ED_OUT		__constant_cpu_to_le32(0x01 << 11)
 #define ED_IN		__constant_cpu_to_le32(0x02 << 11)
-	__le32			hwTailP;	/* tail of TD list */
-	__le32			hwHeadP;	/* head of TD list (hc r/w) */
+	__u32			hwTailP;	/* tail of TD list */
+	__u32			hwHeadP;	/* head of TD list (hc r/w) */
 #define ED_C		__constant_cpu_to_le32(0x02)	/* toggle carry */
 #define ED_H		__constant_cpu_to_le32(0x01)	/* halted */
-	__le32			hwNextED;	/* next ED in list */
+	__u32			hwNextED;	/* next ED in list */
 
 	/* rest are purely for the driver's use */
 	dma_addr_t		dma;		/* addr of ED */
@@ -71,7 +71,7 @@
  */
 struct td {
 	/* first fields are hardware-specified, le32 */
-	__le32		hwINFO;		/* transfer info bitmask */
+	__u32		hwINFO;		/* transfer info bitmask */
 
 	/* hwINFO bits for both general and iso tds: */
 #define TD_CC       0xf0000000			/* condition code */
@@ -100,13 +100,13 @@
 
 	/* (no hwINFO #defines yet for iso tds) */
 
-  	__le32		hwCBP;		/* Current Buffer Pointer (or 0) */
-  	__le32		hwNextTD;	/* Next TD Pointer */
-  	__le32		hwBE;		/* Memory Buffer End Pointer */
+  	__u32		hwCBP;		/* Current Buffer Pointer (or 0) */
+  	__u32		hwNextTD;	/* Next TD Pointer */
+  	__u32		hwBE;		/* Memory Buffer End Pointer */
 
 	/* PSW is only for ISO */
 #define MAXPSW 1		/* hardware allows 8 */
-  	__le16		hwPSW [MAXPSW];
+  	__u16		hwPSW [MAXPSW];
 
 	/* rest are purely for the driver's use */
   	__u8		index;
@@ -171,16 +171,16 @@
  */
 struct ohci_hcca {
 #define NUM_INTS 32
-	__le32	int_table [NUM_INTS];	/* periodic schedule */
+	__u32	int_table [NUM_INTS];	/* periodic schedule */
 
 	/* 
 	 * OHCI defines u16 frame_no, followed by u16 zero pad.
 	 * Since some processors can't do 16 bit bus accesses,
 	 * portable access must be a 32 bit byteswapped access.
 	 */
-	__le32	frame_no;		/* current frame number */
-#define OHCI_FRAME_NO(hccap) ((u16)le32_to_cpup(&(hccap)->frame_no))
-	__le32	done_head;		/* info returned for an interrupt */
+	u32	frame_no;		/* current frame number */
+#define OHCI_FRAME_NO(hccap) le16_to_cpu(((u16)le32_to_cpup(&(hccap)->frame_no)))
+	__u32	done_head;		/* info returned for an interrupt */
 	u8	reserved_for_hc [116];
 	u8	what [4];		/* spec only identifies 252 bytes :) */
 } __attribute__ ((aligned(256)));
@@ -318,9 +318,8 @@
 /* hcd-private per-urb state */
 typedef struct urb_priv {
 	struct ed		*ed;
-	u16			length;		// # tds in this request
-	u16			td_cnt;		// tds already serviced
-	struct list_head	pending;
+	__u16			length;		// # tds in this request
+	__u16			td_cnt;		// tds already serviced
 	struct td		*td [0];	// all TDs in this request
 
 } urb_priv_t;
@@ -343,7 +342,7 @@
 	/*
 	 * I/O memory used to communicate with the HC (dma-consistent)
 	 */
-	struct ohci_regs __iomem *regs;
+	struct ohci_regs	*regs;
 
 	/*
 	 * main memory used to communicate with the HC (dma-consistent).
@@ -360,29 +359,17 @@
  	struct ed		*periodic [NUM_INTS];	/* shadow int_table */
 
 	/*
-	 * OTG controllers and transceivers need software interaction;
-	 * other external transceivers should be software-transparent 
-	 */
-	struct otg_transceiver	*transceiver;
-	unsigned		power_budget;
-
-	/*
 	 * memory management for queue data structures
 	 */
 	struct dma_pool		*td_cache;
 	struct dma_pool		*ed_cache;
 	struct td		*td_hash [TD_HASH_SIZE];
-	struct list_head	pending;
 
 	/*
 	 * driver state
 	 */
 	int			load [NUM_INTS];
 	u32 			hc_control;	/* copy of hc control reg */
-	unsigned long		next_statechange;	/* suspend/resume */
-	u32			fminterval;		/* saved register */
-
-	struct work_struct	rh_resume;
 
 	unsigned long		flags;		/* for HC bugs */
 #define	OHCI_QUIRK_AMD756	0x01			/* erratum #4 */
@@ -399,24 +386,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-static inline void disable (struct ohci_hcd *ohci)
-{
-	ohci->hcd.state = USB_STATE_HALT;
-}
-
-#define	FI			0x2edf		/* 12000 bits per frame (-1) */
-#define	DEFAULT_FMINTERVAL 	((((6 * (FI - 210)) / 7) << 16) | FI)
-#define LSTHRESH		0x628		/* lowspeed bit threshold */
-
-static inline void periodic_reinit (struct ohci_hcd *ohci)
-{
-	writel (ohci->fminterval, &ohci->regs->fminterval);
-	writel (((9 * FI) / 10) & 0x3fff, &ohci->regs->periodicstart);
-	writel (LSTHRESH, &ohci->regs->lsthresh);
-}
-
-/*-------------------------------------------------------------------------*/
-
 #ifndef DEBUG
 #define STUB_DEBUG_FILES
 #endif	/* DEBUG */
@@ -436,22 +405,3 @@
 #	define ohci_vdbg(ohci, fmt, args...) do { } while (0)
 #endif
 
-#ifdef CONFIG_ARCH_LH7A404
-	/* Marc Singer: at the time this code was written, the LH7A404
-	 * had a problem reading the USB host registers.  This
-	 * implementation of the ohci_readl function performs the read
-	 * twice as a work-around.
-	 */
-static inline unsigned int ohci_readl (void* regs)
-{
-	*(volatile unsigned int*) regs;
-	return *(volatile unsigned int*) regs;
-}
-#else
-	/* Standard version of ohci_readl uses standard, platform
-	 * specific implementation. */
-static inline unsigned int ohci_readl (void __iomem * regs)
-{
-	return readl (regs);
-}
-#endif
diff -Naur linuxppc-2.6.9/drivers/usb/host/ohci-hcd.c linuxppc-2.6.9-dream/drivers/usb/host/ohci-hcd.c
--- linuxppc-2.6.9/drivers/usb/host/ohci-hcd.c	2004-10-18 23:53:12.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ohci-hcd.c	2005-09-19 21:40:05.000000000 +0200
@@ -17,7 +17,6 @@
  *
  * History:
  * 
- * 2004/03/24 LH7A404 support (Durgesh Pattamatta & Marc Singer)
  * 2004/02/04 use generic dma_* functions instead of pci_* (dsaxena@plexity.net)
  * 2003/02/24 show registers in sysfs (Kevin Brosius)
  *
@@ -97,7 +96,6 @@
 #include <linux/list.h>
 #include <linux/interrupt.h>  /* for in_interrupt () */
 #include <linux/usb.h>
-#include <linux/usb_otg.h>
 #include "../core/hcd.h"
 #include <linux/dma-mapping.h> 
 #include <linux/dmapool.h>    /* needed by ohci-mem.c when no PCI */
@@ -108,6 +106,24 @@
 #include <asm/unaligned.h>
 #include <asm/byteorder.h>
 
+#define STB
+#ifdef STB
+#undef readl
+#undef writel
+#define readl __raw_readl
+#define writel __raw_writel
+#define ohci_le32_to_cpup __raw_readl
+#define ohci_le32_to_cpu 
+#define ohci_cpu_to_le32p __raw_readl
+#define ohci_cpu_to_le32 
+#define ohci_le16_to_cpup __raw_reads
+#define ohci_le16_to_cpu 
+#define ohci_cpu_to_le16p __raw_reads
+#define ohci_cpu_to_le16 
+#define __constant_cpu_to_le32 
+#endif
+
+
 
 #define DRIVER_VERSION "2004 Feb 02"
 #define DRIVER_AUTHOR "Roman Weissgaerber, David Brownell"
@@ -119,8 +135,8 @@
 
 /* For initializing controller (mask in an HCFS mode too) */
 #define	OHCI_CONTROL_INIT 	OHCI_CTRL_CBSR
-#define	OHCI_INTR_INIT \
-	(OHCI_INTR_MIE | OHCI_INTR_UE | OHCI_INTR_RD | OHCI_INTR_WDH)
+
+#define OHCI_UNLINK_TIMEOUT	 (HZ / 10)
 
 /*-------------------------------------------------------------------------*/
 
@@ -128,6 +144,11 @@
 
 #include "ohci.h"
 
+static inline void disable (struct ohci_hcd *ohci)
+{
+	ohci->hcd.state = USB_STATE_HALT;
+}
+
 #include "ohci-hub.c"
 #include "ohci-dbg.c"
 #include "ohci-mem.c"
@@ -203,7 +224,8 @@
 	if (!urb_priv)
 		return -ENOMEM;
 	memset (urb_priv, 0, sizeof (urb_priv_t) + size * sizeof (struct td *));
-	INIT_LIST_HEAD (&urb_priv->pending);
+	
+	/* fill the private part of the URB */
 	urb_priv->length = size;
 	urb_priv->ed = ed;	
 
@@ -229,8 +251,8 @@
 	spin_lock (&urb->lock);
 	if (urb->status != -EINPROGRESS) {
 		spin_unlock (&urb->lock);
-		urb->hcpriv = urb_priv;
-		finish_urb (ohci, urb, NULL);
+
+		finish_urb (ohci, urb, 0);
 		retval = 0;
 		goto fail;
 	}
@@ -340,19 +362,12 @@
 	if (!ed)
 		goto done;
 
-	if (!HCD_IS_RUNNING (ohci->hcd.state)) {
-sanitize:
+	if (!HCD_IS_RUNNING (ohci->hcd.state))
 		ed->state = ED_IDLE;
-		finish_unlinks (ohci, 0, NULL);
-	}
-
 	switch (ed->state) {
 	case ED_UNLINK:		/* wait for hw to finish? */
 		/* major IRQ delivery trouble loses INTR_SF too... */
-		if (limit-- == 0) {
-			ohci_warn (ohci, "IRQ INTR_SF lossage\n");
-			goto sanitize;
-		}
+		WARN_ON (limit-- == 0);
 		spin_unlock_irqrestore (&ohci->lock, flags);
 		set_current_state (TASK_UNINTERRUPTIBLE);
 		schedule_timeout (1);
@@ -374,7 +389,7 @@
 		td_free (ohci, ed->dummy);
 		break;
 	}
-	dev->ep [epnum] = NULL;
+	dev->ep [epnum] = 0;
 done:
 	spin_unlock_irqrestore (&ohci->lock, flags);
 	return;
@@ -397,21 +412,11 @@
 {
 	u32 temp;
 
-	/* boot firmware should have set this up (5.1.1.3.1) */
-	if (!ohci->fminterval) {
-		temp = ohci_readl (&ohci->regs->fminterval);
-		if (temp & 0x3fff0000)
-			ohci->fminterval = temp;
-		else
-			ohci->fminterval = DEFAULT_FMINTERVAL;
-		/* also: power/overcurrent flags in roothub.a */
-	}
-
 	/* SMM owns the HC?  not for long!
 	 * On PA-RISC, PDC can leave IR set incorrectly; ignore it there.
 	 */
 #ifndef __hppa__
-	if (ohci_readl (&ohci->regs->control) & OHCI_CTRL_IR) {
+	if (readl (&ohci->regs->control) & OHCI_CTRL_IR) {
 		ohci_dbg (ohci, "USB HC TakeOver from BIOS/SMM\n");
 
 		/* this timeout is arbitrary.  we make it long, so systems
@@ -422,8 +427,8 @@
 
 		writel (OHCI_INTR_OC, &ohci->regs->intrenable);
 		writel (OHCI_OCR, &ohci->regs->cmdstatus);
-		while (ohci_readl (&ohci->regs->control) & OHCI_CTRL_IR) {
-			msleep (10);
+		while (readl (&ohci->regs->control) & OHCI_CTRL_IR) {
+			wait_ms (10);
 			if (--temp == 0) {
 				ohci_err (ohci, "USB HC TakeOver failed!\n");
 				return -1;
@@ -436,16 +441,13 @@
 	writel (OHCI_INTR_MIE, &ohci->regs->intrdisable);
 
 	ohci_dbg (ohci, "reset, control = 0x%x\n",
-		  ohci_readl (&ohci->regs->control));
+		readl (&ohci->regs->control));
 
   	/* Reset USB (needed by some controllers); RemoteWakeupConnected
 	 * saved if boot firmware (BIOS/SMM/...) told us it's connected
-	 * (for OHCI integrated on mainboard, it normally is)
 	 */
-	ohci->hc_control = ohci_readl (&ohci->regs->control);
+	ohci->hc_control = readl (&ohci->regs->control);
 	ohci->hc_control &= OHCI_CTRL_RWC;	/* hcfs 0 = RESET */
-	if (ohci->hc_control)
-		ohci->hcd.can_wakeup = 1;
 	writel (ohci->hc_control, &ohci->regs->control);
 	if (power_switching) {
 		unsigned ports = roothub_a (ohci) & RH_A_NDP; 
@@ -456,13 +458,13 @@
 				&ohci->regs->roothub.portstatus [temp]);
 	}
 	// flush those pci writes
-	(void) ohci_readl (&ohci->regs->control);
-	msleep (50);
+	(void) readl (&ohci->regs->control);
+	wait_ms (50);
 
 	/* HC Reset requires max 10 us delay */
 	writel (OHCI_HCR,  &ohci->regs->cmdstatus);
 	temp = 30;	/* ... allow extra time */
-	while ((ohci_readl (&ohci->regs->cmdstatus) & OHCI_HCR) != 0) {
+	while ((readl (&ohci->regs->cmdstatus) & OHCI_HCR) != 0) {
 		if (--temp == 0) {
 			ohci_err (ohci, "USB HC reset timed out!\n");
 			return -1;
@@ -479,13 +481,16 @@
 	 */
 	writel (ohci->hc_control, &ohci->regs->control);
 	// flush those pci writes
-	(void) ohci_readl (&ohci->regs->control);
+	(void) readl (&ohci->regs->control);
 
 	return 0;
 }
 
 /*-------------------------------------------------------------------------*/
 
+#define	FI		0x2edf		/* 12000 bits per frame (-1) */
+#define LSTHRESH	0x628		/* lowspeed bit threshold */
+
 /* Start an OHCI controller, set the BUS operational
  * enable interrupts 
  * connect the virtual root hub
@@ -496,6 +501,7 @@
   	struct usb_device	*udev;
   	struct usb_bus		*bus;
 
+	spin_lock_init (&ohci->lock);
 	disable (ohci);
 
 	/* Tell the controller where the control and bulk lists are
@@ -506,13 +512,18 @@
 	/* a reset clears this */
 	writel ((u32) ohci->hcca_dma, &ohci->regs->hcca);
 
-	periodic_reinit (ohci);
+	/* force default fmInterval (we won't adjust it); init thresholds
+	 * for last FS and LS packets, reserve 90% for periodic.
+	 */
+	writel ((((6 * (FI - 210)) / 7) << 16) | FI, &ohci->regs->fminterval);
+	writel (((9 * FI) / 10) & 0x3fff, &ohci->regs->periodicstart);
+	writel (LSTHRESH, &ohci->regs->lsthresh);
 
 	/* some OHCI implementations are finicky about how they init.
 	 * bogus values here mean not even enumeration could work.
 	 */
-	if ((ohci_readl (&ohci->regs->fminterval) & 0x3fff0000) == 0
-			|| !ohci_readl (&ohci->regs->periodicstart)) {
+	if ((readl (&ohci->regs->fminterval) & 0x3fff0000) == 0
+			|| !readl (&ohci->regs->periodicstart)) {
 		ohci_err (ohci, "init err\n");
 		return -EOVERFLOW;
 	}
@@ -523,11 +534,8 @@
  	writel (ohci->hc_control, &ohci->regs->control);
 	ohci->hcd.state = USB_STATE_RUNNING;
 
-	/* wake on ConnectStatusChange, matching external hubs */
-	writel (RH_HS_DRWE, &ohci->regs->roothub.status);
-
 	/* Choose the interrupts we care about now, others later on demand */
-	mask = OHCI_INTR_INIT;
+	mask = OHCI_INTR_MIE | OHCI_INTR_UE | OHCI_INTR_WDH;
 	writel (mask, &ohci->regs->intrstatus);
 	writel (mask, &ohci->regs->intrenable);
 
@@ -554,19 +562,14 @@
 	writel (RH_HS_LPSC, &ohci->regs->roothub.status);
 	writel (power_switching ? RH_B_PPCM : 0, &ohci->regs->roothub.b);
 	// flush those pci writes
-	(void) ohci_readl (&ohci->regs->control);
+	(void) readl (&ohci->regs->control);
 
 	// POTPGT delay is bits 24-31, in 2 ms units.
 	mdelay ((roothub_a (ohci) >> 23) & 0x1fe);
-	bus = hcd_to_bus (&ohci->hcd);
-
-	if (bus->root_hub) {
-		ohci->hcd.state = USB_STATE_RUNNING;
-		return 0;
-	}
  
 	/* connect the virtual root hub */
-	udev = usb_alloc_dev (NULL, bus, 0);
+	bus = hcd_to_bus (&ohci->hcd);
+	bus->root_hub = udev = usb_alloc_dev (NULL, bus, 0);
 	ohci->hcd.state = USB_STATE_RUNNING;
 	if (!udev) {
 		disable (ohci);
@@ -576,8 +579,9 @@
 	}
 
 	udev->speed = USB_SPEED_FULL;
-	if (hcd_register_root (udev, &ohci->hcd) != 0) {
+	if (hcd_register_root (&ohci->hcd) != 0) {
 		usb_put_dev (udev);
+		bus->root_hub = NULL;
 		disable (ohci);
 		ohci->hc_control &= ~OHCI_CTRL_HCFS;
 		writel (ohci->hc_control, &ohci->regs->control);
@@ -594,23 +598,22 @@
 static irqreturn_t ohci_irq (struct usb_hcd *hcd, struct pt_regs *ptregs)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-	struct ohci_regs __iomem *regs = ohci->regs;
+	struct ohci_regs	*regs = ohci->regs;
  	int			ints; 
 
-	/* we can eliminate a (slow) ohci_readl()
-	   if _only_ WDH caused this irq */
+	/* we can eliminate a (slow) readl() if _only_ WDH caused this irq */
 	if ((ohci->hcca->done_head != 0)
 			&& ! (le32_to_cpup (&ohci->hcca->done_head) & 0x01)) {
 		ints =  OHCI_INTR_WDH;
 
 	/* cardbus/... hardware gone before remove() */
-	} else if ((ints = ohci_readl (&regs->intrstatus)) == ~(u32)0) {
+	} else if ((ints = readl (&regs->intrstatus)) == ~(u32)0) {
 		disable (ohci);
 		ohci_dbg (ohci, "device removed!\n");
 		return IRQ_HANDLED;
 
 	/* interrupt for some other device? */
-	} else if ((ints &= ohci_readl (&regs->intrenable)) == 0) {
+	} else if ((ints &= readl (&regs->intrenable)) == 0) {
 		return IRQ_NONE;
 	} 
 
@@ -622,18 +625,11 @@
 		ohci_dump (ohci, 1);
 		hc_reset (ohci);
 	}
-
-	if (ints & OHCI_INTR_RD) {
-		ohci_vdbg (ohci, "resume detect\n");
-		schedule_work(&ohci->rh_resume);
-	}
-
+  
 	if (ints & OHCI_INTR_WDH) {
 		if (HCD_IS_RUNNING(hcd->state))
 			writel (OHCI_INTR_WDH, &regs->intrdisable);	
-		spin_lock (&ohci->lock);
-		dl_done_list (ohci, ptregs);
-		spin_unlock (&ohci->lock);
+		dl_done_list (ohci, dl_reverse_done_list (ohci), ptregs);
 		if (HCD_IS_RUNNING(hcd->state))
 			writel (OHCI_INTR_WDH, &regs->intrenable); 
 	}
@@ -656,7 +652,7 @@
 		writel (ints, &regs->intrstatus);
 		writel (OHCI_INTR_MIE, &regs->intrenable);	
 		// flush those pci writes
-		(void) ohci_readl (&ohci->regs->control);
+		(void) readl (&ohci->regs->control);
 	}
 
 	return IRQ_HANDLED;
@@ -673,11 +669,8 @@
 		ohci->hcd.state);
 	ohci_dump (ohci, 1);
 
-	flush_scheduled_work();
 	if (HCD_IS_RUNNING(ohci->hcd.state))
 		hc_reset (ohci);
-	else
-		writel (OHCI_INTR_MIE, &ohci->regs->intrdisable);
 	
 	remove_debug_files (ohci);
 	ohci_mem_cleanup (ohci);
@@ -692,68 +685,22 @@
 
 /*-------------------------------------------------------------------------*/
 
-/* must not be called from interrupt context */
+// FIXME:  this restart logic should be generic,
+// and handle full hcd state cleanup
 
-#if	defined(CONFIG_USB_SUSPEND) || defined(CONFIG_PM)
-
-static void mark_children_gone (struct usb_device *dev)
-{
-	unsigned i;
-
-	for (i = 0; i < dev->maxchild; i++) {
-		if (dev->children [i] == 0)
-			continue;
-		dev->children [i]->state = USB_STATE_NOTATTACHED;
-		mark_children_gone (dev->children [i]);
-	}
-}
+/* controller died; cleanup debris, then restart */
+/* must not be called from interrupt context */
 
+#ifdef CONFIG_PM
 static int hc_restart (struct ohci_hcd *ohci)
 {
 	int temp;
 	int i;
-	struct urb_priv *priv;
 
-	/* mark any devices gone, so they do nothing till khubd disconnects.
-	 * recycle any "live" eds/tds (and urbs) right away.
-	 * later, khubd disconnect processing will recycle the other state,
-	 * (either as disconnect/reconnect, or maybe someday as a reset).
-	 */ 
-	spin_lock_irq(&ohci->lock);
 	disable (ohci);
-	mark_children_gone (ohci->hcd.self.root_hub);
-	if (!list_empty (&ohci->pending))
-		ohci_dbg(ohci, "abort schedule...\n");
-	list_for_each_entry (priv, &ohci->pending, pending) {
-		struct urb	*urb = priv->td[0]->urb;
-		struct ed	*ed = priv->ed;
-
-		switch (ed->state) {
-		case ED_OPER:
-			ed->state = ED_UNLINK;
-			ed->hwINFO |= ED_DEQUEUE;
-			ed_deschedule (ohci, ed);
-
-			ed->ed_next = ohci->ed_rm_list;
-			ed->ed_prev = NULL;
-			ohci->ed_rm_list = ed;
-			/* FALLTHROUGH */
-		case ED_UNLINK:
-			break;
-		default:
-			ohci_dbg(ohci, "bogus ed %p state %d\n",
-					ed, ed->state);
-		}
-
-		spin_lock (&urb->lock);
-		urb->status = -ESHUTDOWN;
-		spin_unlock (&urb->lock);
-	}
-	finish_unlinks (ohci, 0, NULL);
-	spin_unlock_irq(&ohci->lock);
-
-	/* paranoia, in case that didn't work: */
-
+	if (hcd_to_bus (&ohci->hcd)->root_hub)
+		usb_disconnect (&hcd_to_bus (&ohci->hcd)->root_hub);
+	
 	/* empty the interrupt branches */
 	for (i = 0; i < NUM_INTS; i++) ohci->load [i] = 0;
 	for (i = 0; i < NUM_INTS; i++) ohci->hcca->int_table [i] = 0;
@@ -768,20 +715,8 @@
 	if ((temp = hc_reset (ohci)) < 0 || (temp = hc_start (ohci)) < 0) {
 		ohci_err (ohci, "can't restart, %d\n", temp);
 		return temp;
-	} else {
-		/* here we "know" root ports should always stay powered,
-		 * and that if we try to turn them back on the root hub
-		 * will respond to CSC processing.
-		 */
-		i = roothub_a (ohci) & RH_A_NDP;
-		while (i--)
-			writel (RH_PS_PSS,
-				&ohci->regs->roothub.portstatus [temp]);
-		ohci->hcd.self.root_hub->dev.power.power_state = 0;
-		ohci->hcd.state = USB_STATE_RUNNING;
+	} else
 		ohci_dbg (ohci, "restart complete\n");
-		ohci_dump (ohci, 1);
-	}
 	return 0;
 }
 #endif
@@ -802,18 +737,14 @@
 #include "ohci-sa1111.c"
 #endif
 
-#ifdef CONFIG_ARCH_OMAP
-#include "ohci-omap.c"
+#ifdef CONFIG_OCP
+#include "ohci-ocp.c"
 #endif
 
-#ifdef CONFIG_ARCH_LH7A404
-#include "ohci-lh7a404.c"
+#ifdef CONFIG_ARCH_OMAP
+#include "ohci-omap.c"
 #endif
 
-#if !(defined(CONFIG_PCI) \
-      || defined(CONFIG_SA1111) \
-      || defined(CONFIG_ARCH_OMAP) \
-      || defined (CONFIG_ARCH_LH7A404) \
-	)
+#if !(defined(CONFIG_PCI) || defined(CONFIG_SA1111) || defined(CONFIG_ARCH_OMAP) || defined(CONFIG_OCP))
 #error "missing bus glue for ohci-hcd"
 #endif
diff -Naur linuxppc-2.6.9/drivers/usb/host/ohci-hub.c linuxppc-2.6.9-dream/drivers/usb/host/ohci-hub.c
--- linuxppc-2.6.9/drivers/usb/host/ohci-hub.c	2004-10-18 23:53:21.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ohci-hub.c	2005-09-19 21:40:05.000000000 +0200
@@ -20,20 +20,20 @@
  * till some bits (mostly reserved) are clear; ok for all revs.
  */
 #define read_roothub(hc, register, mask) ({ \
-	u32 temp = ohci_readl (&hc->regs->roothub.register); \
+	u32 temp = readl (&hc->regs->roothub.register); \
 	if (temp == -1) \
 		disable (hc); \
 	else if (hc->flags & OHCI_QUIRK_AMD756) \
 		while (temp & mask) \
-			temp = ohci_readl (&hc->regs->roothub.register); \
+			temp = readl (&hc->regs->roothub.register); \
 	temp; })
 
 static u32 roothub_a (struct ohci_hcd *hc)
 	{ return read_roothub (hc, a, 0xfc0fe000); }
 static inline u32 roothub_b (struct ohci_hcd *hc)
-	{ return ohci_readl (&hc->regs->roothub.b); }
+	{ return readl (&hc->regs->roothub.b); }
 static inline u32 roothub_status (struct ohci_hcd *hc)
-	{ return ohci_readl (&hc->regs->roothub.status); }
+	{ return readl (&hc->regs->roothub.status); }
 static u32 roothub_portstatus (struct ohci_hcd *hc, int i)
 	{ return read_roothub (hc, portstatus [i], 0xffe0fce0); }
 
@@ -60,261 +60,6 @@
 		(temp & RH_PS_CCS) ? " CCS" : "" \
 		);
 
-/*-------------------------------------------------------------------------*/
-
-#if	defined(CONFIG_USB_SUSPEND) || defined(CONFIG_PM)
-
-#define OHCI_SCHED_ENABLES \
-	(OHCI_CTRL_CLE|OHCI_CTRL_BLE|OHCI_CTRL_PLE|OHCI_CTRL_IE)
-
-static void dl_done_list (struct ohci_hcd *, struct pt_regs *);
-static void finish_unlinks (struct ohci_hcd *, u16 , struct pt_regs *);
-
-static int ohci_hub_suspend (struct usb_hcd *hcd)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-	struct usb_device	*root = hcd_to_bus (&ohci->hcd)->root_hub;
-	int			status = 0;
-
-	if (root->dev.power.power_state != 0)
-		return 0;
-	if (time_before (jiffies, ohci->next_statechange))
-		return -EAGAIN;
-
-	spin_lock_irq (&ohci->lock);
-
-	ohci->hc_control = ohci_readl (&ohci->regs->control);
-	switch (ohci->hc_control & OHCI_CTRL_HCFS) {
-	case OHCI_USB_RESUME:
-		ohci_dbg (ohci, "resume/suspend?\n");
-		ohci->hc_control &= ~OHCI_CTRL_HCFS;
-		ohci->hc_control |= OHCI_USB_RESET;
-		writel (ohci->hc_control, &ohci->regs->control);
-		(void) ohci_readl (&ohci->regs->control);
-		/* FALL THROUGH */
-	case OHCI_USB_RESET:
-		status = -EBUSY;
-		ohci_dbg (ohci, "needs reinit!\n");
-		goto done;
-	case OHCI_USB_SUSPEND:
-		ohci_dbg (ohci, "already suspended?\n");
-		goto succeed;
-	}
-	ohci_dbg (ohci, "suspend root hub\n");
-
-	/* First stop any processing */
-	ohci->hcd.state = USB_STATE_QUIESCING;
-	if (ohci->hc_control & OHCI_SCHED_ENABLES) {
-		int		limit;
-
-		ohci->hc_control &= ~OHCI_SCHED_ENABLES;
-		writel (ohci->hc_control, &ohci->regs->control);
-		ohci->hc_control = ohci_readl (&ohci->regs->control);
-		writel (OHCI_INTR_SF, &ohci->regs->intrstatus);
-
-		/* sched disables take effect on the next frame,
-		 * then the last WDH could take 6+ msec
-		 */
-		ohci_dbg (ohci, "stopping schedules ...\n");
-		limit = 2000;
-		while (limit > 0) {
-			udelay (250);
-			limit =- 250;
-			if (ohci_readl (&ohci->regs->intrstatus) & OHCI_INTR_SF)
-				break;
-		}
-		dl_done_list (ohci, NULL);
-		mdelay (7);
-	}
-	dl_done_list (ohci, NULL);
-	finish_unlinks (ohci, OHCI_FRAME_NO(ohci->hcca), NULL);
-	writel (ohci_readl (&ohci->regs->intrstatus), &ohci->regs->intrstatus);
-
-	/* maybe resume can wake root hub */
-	if (ohci->hcd.remote_wakeup)
-		ohci->hc_control |= OHCI_CTRL_RWE;
-	else
-		ohci->hc_control &= ~OHCI_CTRL_RWE;
-
-	/* Suspend hub */
-	ohci->hc_control &= ~OHCI_CTRL_HCFS;
-	ohci->hc_control |= OHCI_USB_SUSPEND;
-	writel (ohci->hc_control, &ohci->regs->control);
-	(void) ohci_readl (&ohci->regs->control);
-
-	/* no resumes until devices finish suspending */
-	ohci->next_statechange = jiffies + msecs_to_jiffies (5);
-
-succeed:
-	/* it's not USB_STATE_SUSPENDED unless access to this
-	 * hub from the non-usb side (PCI, SOC, etc) stopped 
-	 */
-	root->dev.power.power_state = 3;
-done:
-	spin_unlock_irq (&ohci->lock);
-	return status;
-}
-
-static inline struct ed *find_head (struct ed *ed)
-{
-	/* for bulk and control lists */
-	while (ed->ed_prev)
-		ed = ed->ed_prev;
-	return ed;
-}
-
-static int hc_restart (struct ohci_hcd *ohci);
-
-/* caller owns root->serialize */
-static int ohci_hub_resume (struct usb_hcd *hcd)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-	struct usb_device	*root = hcd_to_bus (&ohci->hcd)->root_hub;
-	u32			temp, enables;
-	int			status = -EINPROGRESS;
-
-	if (!root->dev.power.power_state)
-		return 0;
-	if (time_before (jiffies, ohci->next_statechange))
-		return -EAGAIN;
-
-	spin_lock_irq (&ohci->lock);
-	ohci->hc_control = ohci_readl (&ohci->regs->control);
-	switch (ohci->hc_control & OHCI_CTRL_HCFS) {
-	case OHCI_USB_SUSPEND:
-		ohci->hc_control &= ~(OHCI_CTRL_HCFS|OHCI_SCHED_ENABLES);
-		ohci->hc_control |= OHCI_USB_RESUME;
-		writel (ohci->hc_control, &ohci->regs->control);
-		(void) ohci_readl (&ohci->regs->control);
-		ohci_dbg (ohci, "resume root hub\n");
-		break;
-	case OHCI_USB_RESUME:
-		/* HCFS changes sometime after INTR_RD */
-		ohci_info (ohci, "wakeup\n");
-		break;
-	case OHCI_USB_OPER:
-		ohci_dbg (ohci, "odd resume\n");
-		root->dev.power.power_state = 0;
-		status = 0;
-		break;
-	default:		/* RESET, we lost power */
-		ohci_dbg (ohci, "root hub hardware reset\n");
-		status = -EBUSY;
-	}
-	spin_unlock_irq (&ohci->lock);
-	if (status == -EBUSY)
-		return hc_restart (ohci);
-	if (status != -EINPROGRESS)
-		return status;
-
-	temp = roothub_a (ohci) & RH_A_NDP;
-	enables = 0;
-	while (temp--) {
-		u32 stat = ohci_readl (&ohci->regs->roothub.portstatus [temp]);
-
-		/* force global, not selective, resume */
-		if (!(stat & RH_PS_PSS))
-			continue;
-		writel (RH_PS_POCI, &ohci->regs->roothub.portstatus [temp]);
-	}
-
-	/* Some controllers (lucent) need extra-long delays */
-	ohci->hcd.state = USB_STATE_RESUMING;
-	mdelay (20 /* usb 11.5.1.10 */ + 15);
-
-	temp = ohci_readl (&ohci->regs->control);
-	temp &= OHCI_CTRL_HCFS;
-	if (temp != OHCI_USB_RESUME) {
-		ohci_err (ohci, "controller won't resume\n");
-		return -EBUSY;
-	}
-
-	/* disable old schedule state, reinit from scratch */
-	writel (0, &ohci->regs->ed_controlhead);
-	writel (0, &ohci->regs->ed_controlcurrent);
-	writel (0, &ohci->regs->ed_bulkhead);
-	writel (0, &ohci->regs->ed_bulkcurrent);
-	writel (0, &ohci->regs->ed_periodcurrent);
-	writel ((u32) ohci->hcca_dma, &ohci->regs->hcca);
-
-	periodic_reinit (ohci);
-
-	/* interrupts might have been disabled */
-	writel (OHCI_INTR_INIT, &ohci->regs->intrenable);
-	if (ohci->ed_rm_list)
-		writel (OHCI_INTR_SF, &ohci->regs->intrenable);
-	writel (ohci_readl (&ohci->regs->intrstatus), &ohci->regs->intrstatus);
-
-	/* Then re-enable operations */
-	writel (OHCI_USB_OPER, &ohci->regs->control);
-	(void) ohci_readl (&ohci->regs->control);
-	msleep (3);
-
-	temp = OHCI_CONTROL_INIT | OHCI_USB_OPER;
-	if (ohci->hcd.can_wakeup)
-		temp |= OHCI_CTRL_RWC;
-	ohci->hc_control = temp;
-	writel (temp, &ohci->regs->control);
-	(void) ohci_readl (&ohci->regs->control);
-
-	/* TRSMRCY */
-	msleep (10);
-	root->dev.power.power_state = 0;
-
-	/* keep it alive for ~5x suspend + resume costs */
-	ohci->next_statechange = jiffies + msecs_to_jiffies (250);
-
-	/* maybe turn schedules back on */
-	enables = 0;
-	temp = 0;
-	if (!ohci->ed_rm_list) {
-		if (ohci->ed_controltail) {
-			writel (find_head (ohci->ed_controltail)->dma,
-				&ohci->regs->ed_controlhead);
-			enables |= OHCI_CTRL_CLE;
-			temp |= OHCI_CLF;
-		}
-		if (ohci->ed_bulktail) {
-			writel (find_head (ohci->ed_bulktail)->dma,
-				&ohci->regs->ed_bulkhead);
-			enables |= OHCI_CTRL_BLE;
-			temp |= OHCI_BLF;
-		}
-	}
-	if (hcd_to_bus (&ohci->hcd)->bandwidth_isoc_reqs
-			|| hcd_to_bus (&ohci->hcd)->bandwidth_int_reqs)
-		enables |= OHCI_CTRL_PLE|OHCI_CTRL_IE;
-	if (enables) {
-		ohci_dbg (ohci, "restarting schedules ... %08x\n", enables);
-		ohci->hc_control |= enables;
-		writel (ohci->hc_control, &ohci->regs->control);
-		if (temp)
-			writel (status, &ohci->regs->cmdstatus);
-		(void) ohci_readl (&ohci->regs->control);
-	}
-
-	ohci->hcd.state = USB_STATE_RUNNING;
-	return 0;
-}
-
-static void ohci_rh_resume (void *_hcd)
-{
-	struct usb_hcd	*hcd = _hcd;
-
-	down (&hcd->self.root_hub->serialize);
-	(void) ohci_hub_resume (hcd);
-	up (&hcd->self.root_hub->serialize);
-}
-
-#else
-
-static void ohci_rh_resume (void *_hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (_hcd);
-	ohci_dbg(ohci, "rh_resume ??\n");
-}
-
-#endif	/* CONFIG_USB_SUSPEND || CONFIG_PM */
 
 /*-------------------------------------------------------------------------*/
 
@@ -325,14 +70,13 @@
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		ports, i, changed = 0, length = 1;
-	int		can_suspend = 1;
 
 	ports = roothub_a (ohci) & RH_A_NDP; 
 	if (ports > MAX_ROOT_PORTS) {
 		if (!HCD_IS_RUNNING(ohci->hcd.state))
 			return -ESHUTDOWN;
 		ohci_err (ohci, "bogus NDP=%d, rereads as NDP=%d\n",
-			ports, ohci_readl (&ohci->regs->roothub.a) & RH_A_NDP);
+			ports, readl (&ohci->regs->roothub.a) & RH_A_NDP);
 		/* retry later; "should not happen" */
 		return 0;
 	}
@@ -351,45 +95,16 @@
 	for (i = 0; i < ports; i++) {
 		u32	status = roothub_portstatus (ohci, i);
 
-		if (status & (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC
-				| RH_PS_OCIC | RH_PS_PRSC)) {
+		status &= RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC
+				| RH_PS_OCIC | RH_PS_PRSC;
+		if (status) {
 			changed = 1;
 			if (i < 7)
 			    buf [0] |= 1 << (i + 1);
 			else
 			    buf [1] |= 1 << (i - 7);
-			continue;
 		}
-
-		/* can suspend if no ports are enabled; or if all all
-		 * enabled ports are suspended AND remote wakeup is on.
-		 */
-		if (!(status & RH_PS_CCS))
-			continue;
-		if ((status & RH_PS_PSS) && ohci->hcd.remote_wakeup)
-			continue;
-		can_suspend = 0;
 	}
-
-#ifdef CONFIG_PM
-	/* save power by suspending idle root hubs;
-	 * INTR_RD wakes us when there's work
-	 */
-	if (can_suspend
-			&& !changed
-			&& !ohci->ed_rm_list
-			&& ((OHCI_CTRL_HCFS | OHCI_SCHED_ENABLES)
-					& ohci->hc_control)
-				== OHCI_USB_OPER
-			&& down_trylock (&hcd->self.root_hub->serialize) == 0
-			) {
-		ohci_vdbg (ohci, "autosuspend\n");
-		(void) ohci_hub_suspend (&ohci->hcd);
-		ohci->hcd.state = USB_STATE_RUNNING;
-		up (&hcd->self.root_hub->serialize);
-	}
-#endif
-
 	return changed ? length : 0;
 }
 
@@ -435,89 +150,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-#ifdef	CONFIG_USB_OTG
-
-static int ohci_start_port_reset (struct usb_hcd *hcd, unsigned port)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	u32			status;
-
-	if (!port)
-		return -EINVAL;
-	port--;
-
-	/* start port reset before HNP protocol times out */
-	status = ohci_readl(&ohci->regs->roothub.portstatus [port]);
-	if (!(status & RH_PS_CCS))
-		return -ENODEV;
-
-	/* khubd will finish the reset later */
-	writel(RH_PS_PRS, &ohci->regs->roothub.portstatus [port]);
-	return 0;
-}
-
-static void start_hnp(struct ohci_hcd *ohci);
-
-#else
-
-#define	ohci_start_port_reset		NULL
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-
-/* See usb 7.1.7.5:  root hubs must issue at least 50 msec reset signaling,
- * not necessarily continuous ... to guard against resume signaling.
- * The short timeout is safe for non-root hubs, and is backward-compatible
- * with earlier Linux hosts.
- */
-#ifdef	CONFIG_USB_SUSPEND
-#define	PORT_RESET_MSEC		50
-#else
-#define	PORT_RESET_MSEC		10
-#endif
-
-/* this timer value might be vendor-specific ... */
-#define	PORT_RESET_HW_MSEC	10
-
-/* wrap-aware logic stolen from <linux/jiffies.h> */
-#define tick_before(t1,t2) ((((s16)(t1))-((s16)(t2))) < 0)
-
-/* called from some task, normally khubd */
-static inline void root_port_reset (struct ohci_hcd *ohci, unsigned port)
-{
-	u32 __iomem *portstat = &ohci->regs->roothub.portstatus [port];
-	u32	temp;
-	u16	now = readl(&ohci->regs->fmnumber);
-	u16	reset_done = now + PORT_RESET_MSEC;
-
-	/* build a "continuous enough" reset signal, with up to
-	 * 3msec gap between pulses.  scheduler HZ==100 must work;
-	 * this might need to be deadline-scheduled.
-	 */
-	do {
-		/* spin until any current reset finishes */
-		for (;;) {
-			temp = ohci_readl (portstat);
-			if (!(temp & RH_PS_PRS))
-				break;
-			udelay (500);
-		} 
-
-		if (!(temp & RH_PS_CCS))
-			break;
-		if (temp & RH_PS_PRSC)
-			writel (RH_PS_PRSC, portstat);
-
-		/* start the next reset, sleep till it's probably done */
-		writel (RH_PS_PRS, portstat);
-		msleep(PORT_RESET_HW_MSEC);
-		now = readl(&ohci->regs->fmnumber);
-	} while (tick_before(now, reset_done));
-	/* caller synchronizes using PRSC */
-}
-
 static int ohci_hub_control (
 	struct usb_hcd	*hcd,
 	u16		typeReq,
@@ -556,9 +188,6 @@
 			break;
 		case USB_PORT_FEAT_SUSPEND:
 			temp = RH_PS_POCI;
-			if ((ohci->hc_control & OHCI_CTRL_HCFS)
-					!= OHCI_USB_OPER)
-				schedule_work (&ohci->rh_resume);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			temp = RH_PS_PSSC;
@@ -579,26 +208,26 @@
 			goto error;
 		}
 		writel (temp, &ohci->regs->roothub.portstatus [wIndex]);
-		// ohci_readl (&ohci->regs->roothub.portstatus [wIndex]);
+		// readl (&ohci->regs->roothub.portstatus [wIndex]);
 		break;
 	case GetHubDescriptor:
 		ohci_hub_descriptor (ohci, (struct usb_hub_descriptor *) buf);
 		break;
 	case GetHubStatus:
 		temp = roothub_status (ohci) & ~(RH_HS_CRWE | RH_HS_DRWE);
-		*(__le32 *) buf = cpu_to_le32 (temp);
+		*(u32 *) buf = cpu_to_le32 (temp);
 		break;
 	case GetPortStatus:
 		if (!wIndex || wIndex > ports)
 			goto error;
 		wIndex--;
 		temp = roothub_portstatus (ohci, wIndex);
-		*(__le32 *) buf = cpu_to_le32 (temp);
+		*(u32 *) buf = cpu_to_le32 (temp);
 
 #ifndef	OHCI_VERBOSE_DEBUG
 	if (*(u16*)(buf+2))	/* only if wPortChange is interesting */
 #endif
-		dbg_port (ohci, "GetStatus", wIndex, temp);
+		dbg_port (ohci, "GetStatus", wIndex + 1, temp);
 		break;
 	case SetHubFeature:
 		switch (wValue) {
@@ -616,12 +245,6 @@
 		wIndex--;
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
-#ifdef	CONFIG_USB_OTG
-			if (ohci->hcd.self.otg_port == (wIndex + 1)
-					&& ohci->hcd.self.b_hnp_enable)
-				start_hnp(ohci);
-			else
-#endif
 			writel (RH_PS_PSS,
 				&ohci->regs->roothub.portstatus [wIndex]);
 			break;
@@ -630,7 +253,10 @@
 				&ohci->regs->roothub.portstatus [wIndex]);
 			break;
 		case USB_PORT_FEAT_RESET:
-			root_port_reset (ohci, wIndex);
+			temp = readl (&ohci->regs->roothub.portstatus [wIndex]);
+			if (temp & RH_PS_CCS)
+				writel (RH_PS_PRS,
+				    &ohci->regs->roothub.portstatus [wIndex]);
 			break;
 		default:
 			goto error;
diff -Naur linuxppc-2.6.9/drivers/usb/host/ohci-lh7a404.c linuxppc-2.6.9-dream/drivers/usb/host/ohci-lh7a404.c
--- linuxppc-2.6.9/drivers/usb/host/ohci-lh7a404.c	2004-10-18 23:55:18.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ohci-lh7a404.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,385 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- * (C) Copyright 2002 Hewlett-Packard Company
- *
- * Bus Glue for Sharp LH7A404
- *
- * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Rusell King et al.
- *
- * Modified for LH7A404 from ohci-sa1111.c
- *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
- *
- * This file is licenced under the GPL.
- */
-
-#include <asm/hardware.h>
-#include <asm/mach-types.h>
-#include <asm/arch/hardware.h>
-
-
-extern int usb_disabled(void);
-
-/*-------------------------------------------------------------------------*/
-
-static void lh7a404_start_hc(struct platform_device *dev)
-{
-	printk(KERN_DEBUG __FILE__
-	       ": starting LH7A404 OHCI USB Controller\n");
-
-	/*
-	 * Now, carefully enable the USB clock, and take
-	 * the USB host controller out of reset.
-	 */
-	CSC_PWRCNT |= CSC_PWRCNT_USBH_EN; /* Enable clock */
-	udelay(1000);
-	USBH_CMDSTATUS = OHCI_HCR;
-	
-	printk(KERN_DEBUG __FILE__
-		   ": Clock to USB host has been enabled \n");
-}
-
-static void lh7a404_stop_hc(struct platform_device *dev)
-{
-	printk(KERN_DEBUG __FILE__
-	       ": stopping LH7A404 OHCI USB Controller\n");
-
-	CSC_PWRCNT &= ~CSC_PWRCNT_USBH_EN; /* Disable clock */
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-
-static irqreturn_t usb_hcd_lh7a404_hcim_irq (int irq, void *__hcd,
-					     struct pt_regs * r)
-{
-	struct usb_hcd *hcd = __hcd;
-
-	return usb_hcd_irq(irq, hcd, r);
-}
-
-/*-------------------------------------------------------------------------*/
-
-void usb_hcd_lh7a404_remove (struct usb_hcd *, struct platform_device *);
-
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
-
-
-/**
- * usb_hcd_lh7a404_probe - initialize LH7A404-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-int usb_hcd_lh7a404_probe (const struct hc_driver *driver,
-			  struct usb_hcd **hcd_out,
-			  struct platform_device *dev)
-{
-	int retval;
-	struct usb_hcd *hcd = 0;
-
-	unsigned int *addr = NULL;
-
-	if (!request_mem_region(dev->resource[0].start,
-				dev->resource[0].end
-				- dev->resource[0].start + 1, hcd_name)) {
-		pr_debug("request_mem_region failed");
-		return -EBUSY;
-	}
-	
-	
-	lh7a404_start_hc(dev);
-	
-	addr = ioremap(dev->resource[0].start,
-		       dev->resource[0].end
-		       - dev->resource[0].start + 1);
-	if (!addr) {
-		pr_debug("ioremap failed");
-		retval = -ENOMEM;
-		goto err1;
-	}
-	
-
-	hcd = driver->hcd_alloc ();
-	if (hcd == NULL){
-		pr_debug ("hcd_alloc failed");
-		retval = -ENOMEM;
-		goto err1;
-	}
-
-	if(dev->resource[1].flags != IORESOURCE_IRQ){
-		pr_debug ("resource[1] is not IORESOURCE_IRQ");
-		retval = -ENOMEM;
-		goto err1;
-	}
-
-	hcd->driver = (struct hc_driver *) driver;
-	hcd->description = driver->description;
-	hcd->irq = dev->resource[1].start;
-	hcd->regs = addr;
-	hcd->self.controller = &dev->dev;
-
-	retval = hcd_buffer_create (hcd);
-	if (retval != 0) {
-		pr_debug ("pool alloc fail");
-		goto err1;
-	}
-
-	retval = request_irq (hcd->irq, usb_hcd_lh7a404_hcim_irq, SA_INTERRUPT,
-			      hcd->description, hcd);
-	if (retval != 0) {
-		pr_debug("request_irq failed");
-		retval = -EBUSY;
-		goto err2;
-	}
-
-	pr_debug ("%s (LH7A404) at 0x%p, irq %d",
-	     hcd->description, hcd->regs, hcd->irq);
-
-	usb_bus_init (&hcd->self);
-	hcd->self.op = &usb_hcd_operations;
-	hcd->self.hcpriv = (void *) hcd;
-	hcd->self.bus_name = "lh7a404";
-	hcd->product_desc = "LH7A404 OHCI";
-
-	INIT_LIST_HEAD (&hcd->dev_list);
-
-	usb_register_bus (&hcd->self);
-
-	if ((retval = driver->start (hcd)) < 0)
-	{
-		usb_hcd_lh7a404_remove(hcd, dev);
-		return retval;
-	}
-
-	*hcd_out = hcd;
-	return 0;
-
- err2:
-	hcd_buffer_destroy (hcd);
-	if (hcd)
-		driver->hcd_free(hcd);
- err1:
-	lh7a404_stop_hc(dev);
-	release_mem_region(dev->resource[0].start,
-				dev->resource[0].end
-			   - dev->resource[0].start + 1);
-	return retval;
-}
-
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_hcd_lh7a404_remove - shutdown processing for LH7A404-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_lh7a404_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-void usb_hcd_lh7a404_remove (struct usb_hcd *hcd, struct platform_device *dev)
-{
-	void *base;
-
-	pr_debug ("remove: %s, state %x", hcd->self.bus_name, hcd->state);
-
-	if (in_interrupt ())
-		BUG ();
-
-	hcd->state = USB_STATE_QUIESCING;
-
-	pr_debug ("%s: roothub graceful disconnect", hcd->self.bus_name);
-	usb_disconnect (&hcd->self.root_hub);
-
-	hcd->driver->stop (hcd);
-	hcd->state = USB_STATE_HALT;
-
-	free_irq (hcd->irq, hcd);
-	hcd_buffer_destroy (hcd);
-
-	usb_deregister_bus (&hcd->self);
-
-	base = hcd->regs;
-	hcd->driver->hcd_free (hcd);
-
-	lh7a404_stop_hc(dev);
-	release_mem_region(dev->resource[0].start,
-			   dev->resource[0].end
-			   - dev->resource[0].start + 1);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int __devinit
-ohci_lh7a404_start (struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ret;
-
-	ohci_dbg (ohci, "ohci_lh7a404_start, ohci:%p", ohci);
-			
-	ohci->hcca = dma_alloc_coherent (hcd->self.controller,
-			sizeof *ohci->hcca, &ohci->hcca_dma, 0);
-	if (!ohci->hcca)
-		return -ENOMEM;
-
-	ohci_dbg (ohci, "ohci_lh7a404_start, ohci->hcca:%p",
-			ohci->hcca);
-
-	memset (ohci->hcca, 0, sizeof (struct ohci_hcca));
-
-	if ((ret = ohci_mem_init (ohci)) < 0) {
-		ohci_stop (hcd);
-		return ret;
-	}
-	ohci->regs = hcd->regs;
-
-	if (hc_reset (ohci) < 0) {
-		ohci_stop (hcd);
-		return -ENODEV;
-	}
-
-	if (hc_start (ohci) < 0) {
-		err ("can't start %s", ohci->hcd.self.bus_name);
-		ohci_stop (hcd);
-		return -EBUSY;
-	}
-	create_debug_files (ohci);
-
-#ifdef	DEBUG
-	ohci_dump (ohci, 1);
-#endif /*DEBUG*/
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ohci_lh7a404_hc_driver = {
-	.description =		hcd_name,
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_USB11,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.start =		ohci_lh7a404_start,
-#ifdef	CONFIG_PM
-	/* suspend:		ohci_lh7a404_suspend,  -- tbd */
-	/* resume:		ohci_lh7a404_resume,   -- tbd */
-#endif /*CONFIG_PM*/
-	.stop =			ohci_stop,
-
-	/*
-	 * memory lifecycle (except per-request)
-	 */
-	.hcd_alloc =		ohci_hcd_alloc,
-	.hcd_free =		ohci_hcd_free,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int ohci_hcd_lh7a404_drv_probe(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct usb_hcd *hcd = NULL;
-	int ret;
-
-	pr_debug ("In ohci_hcd_lh7a404_drv_probe");
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	ret = usb_hcd_lh7a404_probe(&ohci_lh7a404_hc_driver, &hcd, pdev);
-
-	if (ret == 0)
-		dev_set_drvdata(dev, hcd);
-
-	return ret;
-}
-
-static int ohci_hcd_lh7a404_drv_remove(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
-
-	usb_hcd_lh7a404_remove(hcd, pdev);
-	dev_set_drvdata(dev, NULL);
-	return 0;
-}
-	/*TBD*/
-/*static int ohci_hcd_lh7a404_drv_suspend(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
-
-	return 0;
-}
-static int ohci_hcd_lh7a404_drv_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
-
-
-	return 0;
-}
-*/
-
-static struct device_driver ohci_hcd_lh7a404_driver = {
-	.name		= "lh7a404-ohci",
-	.bus		= &platform_bus_type,
-	.probe		= ohci_hcd_lh7a404_drv_probe,
-	.remove		= ohci_hcd_lh7a404_drv_remove,
-	/*.suspend	= ohci_hcd_lh7a404_drv_suspend, */
-	/*.resume	= ohci_hcd_lh7a404_drv_resume, */
-};
-
-static int __init ohci_hcd_lh7a404_init (void)
-{
-	pr_debug (DRIVER_INFO " (LH7A404)");
-	pr_debug ("block sizes: ed %d td %d\n",
-		sizeof (struct ed), sizeof (struct td));
-
-	return driver_register(&ohci_hcd_lh7a404_driver);
-}
-
-static void __exit ohci_hcd_lh7a404_cleanup (void)
-{
-	driver_unregister(&ohci_hcd_lh7a404_driver);
-}
-
-module_init (ohci_hcd_lh7a404_init);
-module_exit (ohci_hcd_lh7a404_cleanup);
diff -Naur linuxppc-2.6.9/drivers/usb/host/ohci-mem.c linuxppc-2.6.9-dream/drivers/usb/host/ohci-mem.c
--- linuxppc-2.6.9/drivers/usb/host/ohci-mem.c	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ohci-mem.c	2005-09-19 21:40:05.000000000 +0200
@@ -31,13 +31,9 @@
 	if (ohci != 0) {
 		memset (ohci, 0, sizeof (struct ohci_hcd));
 		ohci->hcd.product_desc = "OHCI Host Controller";
-		ohci->next_statechange = jiffies;
-		spin_lock_init (&ohci->lock);
-		INIT_LIST_HEAD (&ohci->pending);
-		INIT_WORK (&ohci->rh_resume, ohci_rh_resume, &ohci->hcd);
 		return &ohci->hcd;
 	}
-	return NULL;
+	return 0;
 }
 
 static void ohci_hcd_free (struct usb_hcd *hcd)
@@ -70,11 +66,11 @@
 {
 	if (ohci->td_cache) {
 		dma_pool_destroy (ohci->td_cache);
-		ohci->td_cache = NULL;
+		ohci->td_cache = 0;
 	}
 	if (ohci->ed_cache) {
 		dma_pool_destroy (ohci->ed_cache);
-		ohci->ed_cache = NULL;
+		ohci->ed_cache = 0;
 	}
 }
 
@@ -104,7 +100,7 @@
 	if (td) {
 		/* in case hc fetches it, make it look dead */
 		memset (td, 0, sizeof *td);
-		td->hwNextTD = cpu_to_le32 (dma);
+		td->hwNextTD = ohci_cpu_to_le32 (dma);
 		td->td_dma = dma;
 		/* hashed in td_fill */
 	}
diff -Naur linuxppc-2.6.9/drivers/usb/host/ohci-ocp.c linuxppc-2.6.9-dream/drivers/usb/host/ohci-ocp.c
--- linuxppc-2.6.9/drivers/usb/host/ohci-ocp.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/host/ohci-ocp.c	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,356 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Hewlett-Packard Company
+ * 
+ * OCP Bus Glue
+ *
+ * Written by Christopher Hoover <ch@hpl.hp.com>
+ * Based on fragments of previous driver by Rusell King et al.
+ *
+ * This file is licenced under the GPL.
+ */
+ 
+#include <asm/ocp.h>  
+#include <asm/dma-mapping.h>
+
+#ifndef CONFIG_OCP
+#error "This file is OCP bus glue.  CONFIG_OCP must be defined."
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+static void ocp_start_hc(struct ocp_device *dev)
+{
+	printk(KERN_DEBUG __FILE__ 
+	       ": starting OCP OHCI USB Controller\n");
+}
+
+static void ocp_stop_hc(struct ocp_device *dev)
+{
+	printk(KERN_DEBUG __FILE__ 
+	       ": stopping OCP OHCI USB Controller\n");
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static irqreturn_t usb_hcd_ocp_hcim_irq (int irq, void *__hcd, struct pt_regs * r)
+{
+	usb_hcd_irq(irq, __hcd, r);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+void usb_hcd_ocp_remove (struct usb_hcd *, struct ocp_device *);
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+
+/**
+ * usb_hcd_ocp_probe - initialize OCP HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ * Store this function in the HCD's struct pci_driver as probe().
+ */
+int usb_hcd_ocp_probe (const struct hc_driver *driver,
+			  struct usb_hcd **hcd_out,
+			  struct ocp_device *dev)
+{
+	int retval;
+	struct usb_hcd *hcd = 0;
+
+	ocp_start_hc(dev);
+
+	hcd = driver->hcd_alloc ();
+	if (hcd == NULL){
+		dbg ("hcd_alloc failed");
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	hcd->driver = (struct hc_driver *) driver;
+	hcd->description = driver->description;
+	hcd->irq = dev->def->irq;
+
+	hcd->regs = dev->def->paddr; // ioremap_nocache(/* dev->paddr */ 0x40010000, USB0_EXTENT);
+	hcd->self.controller = &dev->dev;
+
+	static u64 dma_mask = 0xffffffffUL;
+	dev->dev.dma_mask = &dma_mask;
+	
+//	printk("USB #%d at 0x%lx\n", dev->num, (unsigned long) hcd->regs);
+
+	retval = hcd_buffer_create (hcd);
+	if (retval != 0) {
+		dbg ("pool alloc fail");
+		goto err1;
+	}
+
+	hcd->irq=18;
+
+	retval = request_irq (hcd->irq, usb_hcd_ocp_hcim_irq, SA_SHIRQ,
+			      hcd->description, hcd);
+	if (retval != 0) {
+		dbg("request_irq failed");
+		retval = -EBUSY;
+		goto err2;
+	}
+
+#if 0
+	{
+		int uicdcr;
+		/* We should probably have UIC functions to set external
+		 * interrupt level/edge.
+		 */
+		uicdcr = mfdcr(DCRN_UIC_PR(UIC0));
+		uicdcr |= (0x80000000 >> hcd->irq);
+		mtdcr(DCRN_UIC_PR(UIC0), uicdcr);
+	
+		uicdcr=mfdcr(DCRN_UIC_TR(UIC0));
+		uicdcr |= (0x80000000 >> hcd->irq);
+		mtdcr(DCRN_UIC_TR(UIC0), uicdcr);
+	}
+#endif
+
+	info ("%s (OCP) at 0x%p, irq %d\n",
+	      hcd->description, hcd->regs, hcd->irq);
+
+	usb_bus_init (&hcd->self);
+	hcd->self.op = &usb_hcd_operations;
+	hcd->self.hcpriv = (void *) hcd;
+	hcd->self.bus_name = "ocp";
+	hcd->product_desc = "OCP OHCI";
+
+	INIT_LIST_HEAD (&hcd->dev_list);
+
+	usb_register_bus (&hcd->self);
+
+	if ((retval = driver->start (hcd)) < 0) 
+	{
+		usb_hcd_ocp_remove(hcd, dev);
+		return retval;
+	}
+	
+	ohci_irq(hcd, 0);
+	
+	*hcd_out = hcd;
+	return 0;
+
+ err2:
+	hcd_buffer_destroy (hcd);
+	if (hcd) driver->hcd_free(hcd);
+ err1:
+	ocp_stop_hc(dev);
+	return retval;
+}
+
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_ocp_remove - shutdown processing for OCP HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_ocp_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+void usb_hcd_ocp_remove (struct usb_hcd *hcd, struct ocp_device *dev)
+{
+	struct usb_device	*hub;
+	void *base;
+
+	info ("remove: %s, state %x", hcd->self.bus_name, hcd->state);
+
+	if (in_interrupt ()) BUG ();
+
+	hub = hcd->self.root_hub;
+	hcd->state = USB_STATE_QUIESCING;
+
+	dbg ("%s: roothub graceful disconnect", hcd->self.bus_name);
+	usb_disconnect (&hub);
+
+	hcd->driver->stop (hcd);
+	hcd->state = USB_STATE_HALT;
+
+	free_irq (hcd->irq, hcd);
+	hcd_buffer_destroy (hcd);
+
+	usb_deregister_bus (&hcd->self);
+
+	base = hcd->regs;
+	hcd->driver->hcd_free (hcd);
+
+	ocp_stop_hc(dev);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int __devinit
+ohci_ocp_start (struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	int		ret;
+	
+	
+	ohci->hcca = dma_alloc_coherent (hcd->self.controller,
+				sizeof *ohci->hcca, &ohci->hcca_dma, GFP_DMA);
+	if (!ohci->hcca)
+		return -ENOMEM;
+	 
+	memset (ohci->hcca, 0, sizeof (struct ohci_hcca));
+	if ((ret = ohci_mem_init (ohci)) < 0) {
+		ohci_stop (hcd);
+		return ret;
+	}
+	ohci->regs = hcd->regs;
+
+	if (hc_reset (ohci) < 0) {
+		ohci_stop (hcd);
+		return -ENODEV;
+	}
+	
+	if (hc_start (ohci) < 0) {
+		err ("can't start %s", ohci->hcd.self.bus_name);
+		ohci_stop (hcd);
+		return -EBUSY;
+	}
+	create_debug_files (ohci);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ohci_ocp_hc_driver = {
+	.description =		hcd_name,
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_ocp_start,
+#ifdef	CONFIG_PM
+	/* suspend:		ohci_ocp_suspend,  -- tbd */
+	/* resume:		ohci_ocp_resume,   -- tbd */
+#endif
+	.stop =			ohci_stop,
+
+	/*
+	 * memory lifecycle (except per-request)
+	 */
+	.hcd_alloc =		ohci_hcd_alloc,
+	.hcd_free =		ohci_hcd_free,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable = ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+};
+
+/*-------------------------------------------------------------------------*/
+
+#if defined(CONFIG_PM)
+static int ocp_usb_suspend(struct ocp_device *pdev, u32 state)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) | ocp_get_pm(pdev->device, pdev->num));
+	return 0;
+}
+static int ocp_usb_resume(struct ocp_device *pdev)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) & ~ocp_get_pm(pdev->device, pdev->num));
+	return 0;
+}
+#endif
+
+static int __devinit ocp_usb_probe(struct ocp_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	int ret;
+//	dbg("Vendor:%x Device:%x.%d @%lx irq:%d\n",pdev->vendor, pdev->device,pdev->num,(unsigned long) pdev->paddr,pdev->irq);
+
+	ret = usb_hcd_ocp_probe(&ohci_ocp_hc_driver, &hcd, pdev);
+
+#if defined (CONFIG_PM)
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) & ~ocp_get_pm(pdev->device, pdev->num));
+#endif
+
+	if (ret == 0)
+		pdev->dev.driver_data = hcd;
+	return ret;
+}
+
+static void __devexit ocp_usb_remove (struct ocp_device *pdev)
+{
+#if defined (CONFIG_PM)
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) | ocp_get_pm(pdev->device, pdev->num));
+#endif
+	struct usb_hcd *hcd = pdev->dev.driver_data;
+
+	usb_hcd_ocp_remove(hcd, pdev);
+
+	pdev->dev.driver_data = NULL;
+}
+
+static struct ocp_device_id ocp_usb_id_tbl[] __devinitdata = {
+	{OCP_VENDOR_IBM, OCP_FUNC_USB},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(ocp,ocp_usb_id_tbl );
+
+static struct ocp_driver ocp_usb_driver = {
+	.name		= "ocp_usb",
+	.id_table	= ocp_usb_id_tbl,
+	.probe		= ocp_usb_probe,
+	.remove		= ocp_usb_remove,
+#if defined(CONFIG_PM)
+	.suspend	= ocp_usb_suspend,
+	.resume		= ocp_usb_resume,
+#endif /* CONFIG_PM */
+};
+
+static int __init
+ocp_usb_init(void)
+{
+	return ocp_register_driver(&ocp_usb_driver);
+}
+
+void __exit
+ocp_usb_fini(void)
+{
+	ocp_unregister_driver(&ocp_usb_driver);
+}
+
+module_init(ocp_usb_init);
+module_exit(ocp_usb_fini);
diff -Naur linuxppc-2.6.9/drivers/usb/host/ohci-omap.c linuxppc-2.6.9-dream/drivers/usb/host/ohci-omap.c
--- linuxppc-2.6.9/drivers/usb/host/ohci-omap.c	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ohci-omap.c	2005-09-19 21:40:05.000000000 +0200
@@ -2,30 +2,28 @@
  * OHCI HCD (Host Controller Driver) for USB.
  *
  * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2004 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
  * (C) Copyright 2002 Hewlett-Packard Company
  * 
  * OMAP Bus Glue
  *
  * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Russell King et al.
+ * Based on fragments of previous driver by Rusell King et al.
  *
  * Modified for OMAP from ohci-sa1111.c by Tony Lindgren <tony@atomide.com>
  * Based on the 2.4 OMAP OHCI driver originally done by MontaVista Software Inc.
  *
  * This file is licenced under the GPL.
  */
-
+ 
 #include <asm/hardware.h>
-#include <asm/io.h>
 #include <asm/mach-types.h>
+#include <asm/io.h>
 
+#include <asm/arch/bus.h>
 #include <asm/arch/hardware.h>
 #include <asm/arch/mux.h>
 #include <asm/arch/irqs.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch/fpga.h>
-#include <asm/arch/usb.h>
 
 #include "ohci-omap.h"
 
@@ -37,53 +35,122 @@
 extern int ocpi_enable(void);
 
 /*
+ * Use the first port only by default. Override with hmc_mode option.
+ *
+ * NOTE: Many OMAP-1510 Innovators supposedly have bad wiring for the USB ports
+ *       1 & 2, so only port 0 will work. To use the OHCI on the first port, use 
+ *       the Innovator USB client cable with a client-to-client connector and modify
+ *       either the cable or the hub to feed 5V VBUS back to Innovator. VBUS should
+ *       be the red lead in the cable.
+ *
+ *       To mount USB hard disk as root, see the patch for do_mounts.c that tries 
+ *       remounting the root, and use root=0801 if your root is on sda1. Does not 
+ *       work with devfs.
+ */
+static int default_hmc_mode = 16;
+static int hmc_mode = 1234;
+
+/*
+ * Set the USB host pin multiplexing and the selected HMC mode
+ */
+static int omap_usb_set_hmc_mode(int hmc_mode)
+{
+	unsigned int val;
+
+	switch (hmc_mode) {
+	case 0:
+		/* 0: function, 1: disabled, 2: disabled */
+		omap_cfg_reg(W4_USB_PUEN);
+		omap_cfg_reg(R18_1510_USB_GPIO0);
+		break;
+	case 4:
+		/* 0: function 1: host 2: host */
+		omap_cfg_reg(usb1_speed);
+		omap_cfg_reg(usb1_susp);
+		omap_cfg_reg(usb1_seo);
+		omap_cfg_reg(usb1_txen);
+		omap_cfg_reg(usb1_txd);
+		omap_cfg_reg(usb1_vp);
+		omap_cfg_reg(usb1_vm);
+		omap_cfg_reg(usb1_rcv);
+		omap_cfg_reg(usb2_susp);
+		omap_cfg_reg(usb2_seo);
+		omap_cfg_reg(usb2_txen);
+		omap_cfg_reg(usb2_txd);
+		omap_cfg_reg(usb2_vp);
+		omap_cfg_reg(usb2_vm);
+		omap_cfg_reg(usb2_rcv);
+		break;
+	case 16:
+		/* 0: host, 1: disabled, 2: disabled */
+		omap_cfg_reg(W9_USB0_TXEN);
+		omap_cfg_reg(AA9_USB0_VP);
+		omap_cfg_reg(Y5_USB0_RCV);
+		omap_cfg_reg(R9_USB0_VM);
+		omap_cfg_reg(V6_USB0_TXD);
+		omap_cfg_reg(W5_USB0_SE0);
+		break;
+	default:
+		printk("Unknown USB host configuration: %i\n", hmc_mode);
+		return -ENODEV;
+	}
+
+	/* Write the selected HMC mode */
+	val = readl(MOD_CONF_CTRL_0) & ~HMC_CLEAR;
+	val |= (hmc_mode << 1);
+	writel(val, MOD_CONF_CTRL_0);
+
+	return 0;
+}
+
+/*
  * OHCI clock initialization for OMAP-1510 and 1610
  */
 static int omap_ohci_clock_power(int on)
 {
 	if (on) {
-		if (cpu_is_omap1510()) {
+		if (cpu_is_omap_1510()) {
 			/* Use DPLL, not APLL */
-			omap_writel(omap_readl(ULPD_APLL_CTRL) & ~APLL_NDPLL_SWITCH,
-			       ULPD_APLL_CTRL);
+			writel(readl(ULPD_APLL_CTRL_REG) & ~APLL_NDPLL_SWITCH,
+			       ULPD_APLL_CTRL_REG);
 
 			/* Enable DPLL */
-			omap_writel(omap_readl(ULPD_DPLL_CTRL) | DPLL_PLL_ENABLE,
-			       ULPD_DPLL_CTRL);
+			writel(readl(ULPD_DPLL_CTRL_REG) | DPLL_PLL_ENABLE,
+			       ULPD_DPLL_CTRL_REG);
 
 			/* Software request for USB 48MHz clock */
-			omap_writel(omap_readl(ULPD_SOFT_REQ) | SOFT_REQ_REG_REQ,
-			       ULPD_SOFT_REQ);
+			writel(readl(ULPD_SOFT_REQ_REG) | SOFT_REQ_REG_REQ,
+			       ULPD_SOFT_REQ_REG);
 
-			while (!(omap_readl(ULPD_DPLL_CTRL) & DPLL_LOCK));
+			while (!(readl(ULPD_DPLL_CTRL_REG) & DPLL_LOCK));
 		}
 
-		if (cpu_is_omap16xx()) {
+		if (cpu_is_omap_1610()) {
 			/* Enable OHCI */
-			omap_writel(omap_readl(ULPD_SOFT_REQ) | SOFT_USB_OTG_REQ,
-				ULPD_SOFT_REQ);
+			writel(readl(ULPD_SOFT_REQ_REG) | SOFT_USB_OTG_REQ,
+				ULPD_SOFT_REQ_REG);
 
 			/* USB host clock request if not using OTG */
-			omap_writel(omap_readl(ULPD_SOFT_REQ) | SOFT_USB_REQ,
-				ULPD_SOFT_REQ);
+			writel(readl(ULPD_SOFT_REQ_REG) | SOFT_USB_REQ,
+				ULPD_SOFT_REQ_REG);
 
-			omap_writel(omap_readl(ULPD_STATUS_REQ) | USB_HOST_DPLL_REQ,
-			     ULPD_STATUS_REQ);
+			writel(readl(ULPD_STATUS_REQ_REG) | USB_HOST_DPLL_REQ,
+			     ULPD_STATUS_REQ_REG);
 		}
 
 		/* Enable 48MHz clock to USB */
-		omap_writel(omap_readl(ULPD_CLOCK_CTRL) | USB_MCLK_EN,
-		       ULPD_CLOCK_CTRL);
+		writel(readl(ULPD_CLOCK_CTRL_REG) | USB_MCLK_EN,
+		       ULPD_CLOCK_CTRL_REG);
 
-		omap_writel(omap_readl(ARM_IDLECT2) | (1 << EN_LBFREECK) | (1 << EN_LBCK),
+		writel(readl(ARM_IDLECT2) | (1 << EN_LBFREECK) | (1 << EN_LBCK),
 		       ARM_IDLECT2);
 
-		omap_writel(omap_readl(MOD_CONF_CTRL_0) | USB_HOST_HHC_UHOST_EN,
+		writel(readl(MOD_CONF_CTRL_0) | USB_HOST_HHC_UHOST_EN,
 		       MOD_CONF_CTRL_0);
 	} else {
 		/* Disable 48MHz clock to USB */
-		omap_writel(omap_readl(ULPD_CLOCK_CTRL) & ~USB_MCLK_EN,
-		       ULPD_CLOCK_CTRL);
+		writel(readl(ULPD_CLOCK_CTRL_REG) & ~USB_MCLK_EN,
+		       ULPD_CLOCK_CTRL_REG);
 
 		/* FIXME: The DPLL stays on for now */
 	}
@@ -97,19 +164,13 @@
 static int omap_ohci_transceiver_power(int on)
 {
 	if (on) {
-		if (machine_is_omap_innovator() && cpu_is_omap1510())
-			fpga_write(fpga_read(INNOVATOR_FPGA_CAM_USB_CONTROL) | 0x20, 
-			       INNOVATOR_FPGA_CAM_USB_CONTROL);
-		else if (machine_is_omap_osk()) {
-			/* FIXME: GPIO1 -> 1 on the TPS65010 I2C chip */
-		}
+		if (omap_is_innovator())
+			writel(readl(OMAP1510_FPGA_HOST_CTRL) | 0x20, 
+			       OMAP1510_FPGA_HOST_CTRL);
 	} else {
-		if (machine_is_omap_innovator() && cpu_is_omap1510())
-			fpga_write(fpga_read(INNOVATOR_FPGA_CAM_USB_CONTROL) & ~0x20, 
-			       INNOVATOR_FPGA_CAM_USB_CONTROL);
-		else if (machine_is_omap_osk()) {
-			/* FIXME: GPIO1 -> 0 on the TPS65010 I2C chip */
-		}
+		if (omap_is_innovator())
+			writel(readl(OMAP1510_FPGA_HOST_CTRL) & ~0x20, 
+			       OMAP1510_FPGA_HOST_CTRL);
 	}
 
 	return 0;
@@ -121,10 +182,10 @@
 static int omap_1510_local_bus_power(int on)
 {
 	if (on) {
-		omap_writel((1 << 1) | (1 << 0), OMAP1510_LB_MMU_CTL);
+		writel((1 << 1) | (1 << 0), OMAP1510_LB_MMU_CTL);
 		udelay(200);
 	} else {
-		omap_writel(0, OMAP1510_LB_MMU_CTL);
+		writel(0, OMAP1510_LB_MMU_CTL);
 	}
 
 	return 0;
@@ -133,8 +194,8 @@
 /*
  * OMAP-1510 specific Local Bus initialization
  * NOTE: This assumes 32MB memory size in OMAP1510LB_MEMSIZE.
- *       See also arch/mach-omap/memory.h for __virt_to_dma() and 
- *       __dma_to_virt() which need to match with the physical 
+ *       See also arch/mach-omap/memory.h for __virt_to_bus() and 
+ *       __bus_to_virt() which need to match with the physical 
  *       Local Bus address below.
  */
 static int omap_1510_local_bus_init(void)
@@ -142,115 +203,125 @@
 	unsigned int tlb;
 	unsigned long lbaddr, physaddr;
 
-	omap_writel((omap_readl(OMAP1510_LB_CLOCK_DIV) & 0xfffffff8) | 0x4, 
+	writel((readl(OMAP1510_LB_CLOCK_DIV) & 0xfffffff8) | 0x4, 
 	       OMAP1510_LB_CLOCK_DIV);
 
 	/* Configure the Local Bus MMU table */
 	for (tlb = 0; tlb < OMAP1510_LB_MEMSIZE; tlb++) {
 		lbaddr = tlb * 0x00100000 + OMAP1510_LB_OFFSET;
 		physaddr = tlb * 0x00100000 + PHYS_OFFSET;
-		omap_writel((lbaddr & 0x0fffffff) >> 22, OMAP1510_LB_MMU_CAM_H);
-		omap_writel(((lbaddr & 0x003ffc00) >> 6) | 0xc, 
+		writel((lbaddr & 0x0fffffff) >> 22, OMAP1510_LB_MMU_CAM_H);
+		writel(((lbaddr & 0x003ffc00) >> 6) | 0xc, 
 		       OMAP1510_LB_MMU_CAM_L);
-		omap_writel(physaddr >> 16, OMAP1510_LB_MMU_RAM_H);
-		omap_writel((physaddr & 0x0000fc00) | 0x300, OMAP1510_LB_MMU_RAM_L);
-		omap_writel(tlb << 4, OMAP1510_LB_MMU_LCK);
-		omap_writel(0x1, OMAP1510_LB_MMU_LD_TLB);
+		writel(physaddr >> 16, OMAP1510_LB_MMU_RAM_H);
+		writel((physaddr & 0x0000fc00) | 0x300, OMAP1510_LB_MMU_RAM_L);
+		writel(tlb << 4, OMAP1510_LB_MMU_LCK);
+		writel(0x1, OMAP1510_LB_MMU_LD_TLB);
 	}
 
 	/* Enable the walking table */
-	omap_writel(omap_readl(OMAP1510_LB_MMU_CTL) | (1 << 3), OMAP1510_LB_MMU_CTL);
+	writel(readl(OMAP1510_LB_MMU_CTL) | (1 << 3), OMAP1510_LB_MMU_CTL);
 	udelay(200);
 
 	return 0;
 }
 
-#ifdef	CONFIG_USB_OTG
-
-static void start_hnp(struct ohci_hcd *ohci)
+/*
+ * OMAP-1610 specific hardware initialization
+ *
+ * Intended to configure OMAP-1610 USB host and OTG ports depending on 
+ * the HMC mode selected.
+ *
+ * FIXME: Currently only supports alternate ping group 2 mode, should
+ *        be easy to modify for other configurations once there is some
+ *        hardware to test with.
+ */
+static int omap_1610_usb_init(int mode)
 {
-	const unsigned	port = ohci->hcd.self.otg_port - 1;
-	unsigned long	flags;
+	u_int val = 0;
 
-	otg_start_hnp(ohci->transceiver);
+	/* Configure the OMAP transceiver settings */
+	val |= (1 << 8); /* CONF_USB2_UNI TRM p 15-205*/
+	val |= (4 << 4); /* TRM p 5-59, p 15-157 (1224) */
+
+	//val |= (1 << 3); /* Isolate integrated transceiver from port 0 */
+	val |= (1 << 2); /* Disable pulldown on integrated transceiver DM */
+	val |= (1 << 1); /* Disable pulldown on integraded transceiver DP */
+
+	writel(val, USB_TRANSCEIVER_CTRL);
+
+	/* Set the USB0_TRX_MODE */
+	val = 0;
+	val &= ~OTG_IDLE_EN;
+	val &= ~DEV_IDLE_EN;
+	val &= ~(7 << 16);	/* Clear USB0_TRX_MODE */
+	val |= (3 << 16);	/* 0 or 3, 6-wire DAT/SE0, TRM p 15-159 */
+	writel(val, OTG_SYSCON_1);
 
-	local_irq_save(flags);
-	ohci->transceiver->state = OTG_STATE_A_SUSPEND;
-	writel (RH_PS_PSS, &ohci->regs->roothub.portstatus [port]);
-	OTG_CTRL_REG &= ~OTG_A_BUSREQ;
-	local_irq_restore(flags);
-}
+	/* 
+	 * Control via OTG, see TRM p 15-163
+	 */
+	val = 0;
+	//val |= 1;		/* REVISIT: Enable OTG = 1 */
 
-#endif
+	/* Control via OTG */
+	val &= ~HMC_PADEN;
+	val &= ~OTG_PADEN;
+	val |= UHOST_EN;	
+
+	val &= ~0x3f;		/* Clear HMC mode */
+	val |= mode;		/* Set HMC mode */
+	val &= ~(7 << 16);	/* Clear ASE0_BRST */
+	val |= (4 << 16);	/* Must be 4 */
+	val |= USBX_SYNCHRO;	/* Must be set */
+	val |= SRP_VBUS;
+	writel(val, OTG_SYSCON_2);
 
-/*-------------------------------------------------------------------------*/
+	/* Enable OTG idle */
+	//writel(readl(OTG_SYSCON_1) | OTG_IDLE_EN, OTG_SYSCON_1);
 
-static int omap_start_hc(struct ohci_hcd *ohci, struct platform_device *pdev)
-{
-	struct omap_usb_config	*config = pdev->dev.platform_data;
-	int			need_transceiver = (config->otg != 0);
+	return 0;
+}
 
-	dev_dbg(&pdev->dev, "starting USB Controller\n");
+/*-------------------------------------------------------------------------*/
 
-	if (config->otg) {
-		ohci->hcd.self.otg_port = config->otg;
-		/* default/minimum OTG power budget:  8 mA */
-		ohci->power_budget = 8;
-	}
+static void omap_start_hc(struct omap_dev *dev)
+{
+	printk(KERN_DEBUG __FILE__ 
+	       ": starting OMAP OHCI USB Controller\n");
 
-	/* boards can use OTG transceivers in non-OTG modes */
-	need_transceiver = need_transceiver
-			|| machine_is_omap_h2();
+	/* 
+	 * Set the HMC mode for the USB ports
+	 */
+#if 0
+	/* See note about the Innovator wiring above */
+	if (omap_is_innovator())
+		hmc_mode = 4;	/* 0: function 1: host 2: host */
+#endif
 
-	if (cpu_is_omap16xx())
+	if (cpu_is_omap_1610())
 		ocpi_enable();
 
-#ifdef	CONFIG_ARCH_OMAP_OTG
-	if (need_transceiver) {
-		ohci->transceiver = otg_get_transceiver();
-		if (ohci->transceiver) {
-			int	status = otg_set_host(ohci->transceiver,
-						&ohci->hcd.self);
-			dev_dbg(&pdev->dev, "init %s transceiver, status %d\n",
-					ohci->transceiver->label, status);
-			if (status) {
-				if (ohci->transceiver)
-					put_device(ohci->transceiver->dev);
-				return status;
-			}
-		} else {
-			dev_err(&pdev->dev, "can't find transceiver\n");
-			return -ENODEV;
-		}
-	}
-#endif
-
-	if (machine_is_omap_osk()) {
-		omap_request_gpio(9);
-		omap_set_gpio_direction(9, 1);
-		omap_set_gpio_dataout(9, 1);
-	}
+	omap_usb_set_hmc_mode(hmc_mode);
 
 	omap_ohci_clock_power(1);
-
 	omap_ohci_transceiver_power(1);
 
-	if (cpu_is_omap1510()) {
+	if (cpu_is_omap_1510()) {
 		omap_1510_local_bus_power(1);
 		omap_1510_local_bus_init();
 	}
 
-	/* board init will have already handled HMC and mux setup.
-	 * any external transceiver should already be initialized
-	 * too, so all configured ports use the right signaling now.
-	 */
+	if (cpu_is_omap_1610())
+		omap_1610_usb_init(hmc_mode);
 
-	return 0;
+	//omap_enable_device(dev);
 }
 
-static void omap_stop_hc(struct platform_device *pdev)
+static void omap_stop_hc(struct omap_dev *dev)
 {
-	dev_dbg(&pdev->dev, "stopping USB Controller\n");
+	printk(KERN_DEBUG __FILE__ 
+	       ": stopping OMAP OHCI USB Controller\n");
 
 	/*
 	 * FIXME: Put the USB host controller into reset.
@@ -266,7 +337,16 @@
 
 /*-------------------------------------------------------------------------*/
 
-void usb_hcd_omap_remove (struct usb_hcd *, struct platform_device *);
+static irqreturn_t usb_hcd_omap_hcim_irq (int irq, void *__hcd, struct pt_regs * r)
+{
+	struct usb_hcd *hcd = __hcd;
+
+	return usb_hcd_irq(irq, hcd, r);
+}
+
+/*-------------------------------------------------------------------------*/
+
+void usb_hcd_omap_remove (struct usb_hcd *, struct omap_dev *);
 
 /* configure so an HC device and id are always provided */
 /* always called with process context; sleeping is OK */
@@ -279,71 +359,59 @@
  * Allocates basic resources for this USB host controller, and
  * then invokes the start() method for the HCD associated with it
  * through the hotplug entry's driver_data.
+ *
+ * Store this function in the HCD's struct pci_driver as probe().
  */
 int usb_hcd_omap_probe (const struct hc_driver *driver,
-			  struct platform_device *pdev)
+			  struct usb_hcd **hcd_out,
+			  struct omap_dev *dev)
 {
 	int retval;
 	struct usb_hcd *hcd = 0;
-	struct ohci_hcd *ohci;
 
-	if (pdev->num_resources != 2) {
-		printk(KERN_ERR "hcd probe: invalid num_resources: %i\n", 
-		       pdev->num_resources);
-		return -ENODEV;
-	}
-
-	if (pdev->resource[0].flags != IORESOURCE_MEM 
-	    || pdev->resource[1].flags != IORESOURCE_IRQ) {
-		printk(KERN_ERR "hcd probe: invalid resource type\n");
-		return -ENODEV;
-	}
-
-	if (!request_mem_region(pdev->resource[0].start, 
-				pdev->resource[0].end - pdev->resource[0].start + 1, hcd_name)) {
-		dev_dbg(&pdev->dev, "request_mem_region failed\n");
+	if (!request_mem_region(dev->res.start, 
+				dev->res.end - dev->res.start + 1, hcd_name)) {
+		dbg("request_mem_region failed");
 		return -EBUSY;
 	}
 
+	omap_start_hc(dev);
+
 	hcd = driver->hcd_alloc ();
 	if (hcd == NULL){
-		dev_dbg(&pdev->dev, "hcd_alloc failed\n");
+		dbg ("hcd_alloc failed");
 		retval = -ENOMEM;
 		goto err1;
 	}
-	dev_set_drvdata(&pdev->dev, hcd);
-	ohci = hcd_to_ohci(hcd);
 
 	hcd->driver = (struct hc_driver *) driver;
 	hcd->description = driver->description;
-	hcd->irq = pdev->resource[1].start;
-	hcd->regs = (void *)pdev->resource[0].start;
-	hcd->self.controller = &pdev->dev;
-
-	retval = omap_start_hc(ohci, pdev);
-	if (retval < 0)
-		goto err2;
+	hcd->irq = dev->irq[0];
+	hcd->regs = dev->mapbase;
+	hcd->self.controller = &dev->dev;
 
 	retval = hcd_buffer_create (hcd);
 	if (retval != 0) {
-		dev_dbg(&pdev->dev, "pool alloc fail\n");
+		dbg ("pool alloc fail");
 		goto err1;
 	}
 
-	retval = request_irq (hcd->irq, usb_hcd_irq, 
+	retval = request_irq (hcd->irq, 
+			      usb_hcd_omap_hcim_irq, 
 			      SA_INTERRUPT, hcd->description, hcd);
 	if (retval != 0) {
-		dev_dbg(&pdev->dev, "request_irq failed\n");
+		dbg("request_irq failed");
 		retval = -EBUSY;
 		goto err2;
 	}
 
-	dev_info(&pdev->dev, "at 0x%p, irq %d\n", hcd->regs, hcd->irq);
+	info ("%s (OMAP) at 0x%p, irq %d\n",
+	      hcd->description, hcd->regs, hcd->irq);
 
 	usb_bus_init (&hcd->self);
 	hcd->self.op = &usb_hcd_operations;
 	hcd->self.hcpriv = (void *) hcd;
-	hcd->self.bus_name = pdev->dev.bus_id;
+	hcd->self.bus_name = "omap";
 	hcd->product_desc = "OMAP OHCI";
 
 	INIT_LIST_HEAD (&hcd->dev_list);
@@ -351,10 +419,11 @@
 
 	if ((retval = driver->start (hcd)) < 0) 
 	{
-		usb_hcd_omap_remove(hcd, pdev);
+		usb_hcd_omap_remove(hcd, dev);
 		return retval;
 	}
 
+	*hcd_out = hcd;
 	return 0;
 
  err2:
@@ -362,12 +431,10 @@
 	if (hcd)
 		driver->hcd_free(hcd);
  err1:
-	omap_stop_hc(pdev);
+	omap_stop_hc(dev);
 
-	release_mem_region(pdev->resource[0].start, 
-			   pdev->resource[0].end - pdev->resource[0].start + 1);
+	release_mem_region(dev->res.start, dev->res.end - dev->res.start + 1);
 
-	dev_set_drvdata(&pdev->dev, 0);
 	return retval;
 }
 
@@ -385,27 +452,26 @@
  * context, normally "rmmod", "apmd", or something similar.
  *
  */
-void usb_hcd_omap_remove (struct usb_hcd *hcd, struct platform_device *pdev)
+void usb_hcd_omap_remove (struct usb_hcd *hcd, struct omap_dev *dev)
 {
+	struct usb_device	*hub;
 	void *base;
 
-	dev_info(&pdev->dev, "remove: state %x\n", hcd->state);
+	info ("remove: %s, state %x", hcd->self.bus_name, hcd->state);
 
 	if (in_interrupt ())
 		BUG ();
 
+	hub = hcd->self.root_hub;
 	hcd->state = USB_STATE_QUIESCING;
 
-	dev_dbg(&pdev->dev, "roothub graceful disconnect\n");
-	usb_disconnect (&hcd->self.root_hub);
+	dbg ("%s: roothub graceful disconnect", hcd->self.bus_name);
+	usb_disconnect (&hub);
 
 	hcd->driver->stop (hcd);
 	hcd_buffer_destroy (hcd);
 	hcd->state = USB_STATE_HALT;
 
-	if (machine_is_omap_osk())
-		omap_free_gpio(9);
-
 	free_irq (hcd->irq, hcd);
 
 	usb_deregister_bus (&hcd->self);
@@ -413,10 +479,9 @@
 	base = hcd->regs;
 	hcd->driver->hcd_free (hcd);
 
-	omap_stop_hc(pdev);
+	omap_stop_hc(dev);
 
-	release_mem_region(pdev->resource[0].start, 
-			   pdev->resource[0].end - pdev->resource[0].start + 1);
+	release_mem_region(dev->res.start, dev->res.end - dev->res.start + 1);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -424,13 +489,11 @@
 static int __devinit
 ohci_omap_start (struct usb_hcd *hcd)
 {
-	struct omap_usb_config *config;
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		ret;
 
-	config = hcd->self.controller->platform_data;
-	ohci->hcca = dma_alloc_coherent (hcd->self.controller,
-			sizeof *ohci->hcca, &ohci->hcca_dma, 0);
+	ohci->hcca = dma_alloc_consistent (hcd->self.controller,
+			sizeof *ohci->hcca, &ohci->hcca_dma);
 	if (!ohci->hcca)
 		return -ENOMEM;
 
@@ -440,10 +503,6 @@
 		return ret;
 	}
 	ohci->regs = hcd->regs;
-
-	if (config->otg || config->rwc)
-		writel(OHCI_CTRL_RWC, &ohci->regs->control);
-
 	if (hc_reset (ohci) < 0) {
 		ohci_stop (hcd);
 		return -ENODEV;
@@ -454,9 +513,6 @@
 		ohci_stop (hcd);
 		return -EBUSY;
 	}
-	if (ohci->power_budget)
-		hub_set_power_budget(ohci->hcd.self.root_hub,
-					ohci->power_budget);
 	create_debug_files (ohci);
 
 #ifdef	DEBUG
@@ -480,6 +536,10 @@
 	 * basic lifecycle operations
 	 */
 	.start =		ohci_omap_start,
+#ifdef	CONFIG_PM
+	/* suspend:		ohci_omap_suspend,  -- tbd */
+	/* resume:		ohci_omap_resume,   -- tbd */
+#endif
 	.stop =			ohci_stop,
 
 	/*
@@ -505,134 +565,104 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-#ifdef	CONFIG_USB_SUSPEND
-	.hub_suspend =		ohci_hub_suspend,
-	.hub_resume =		ohci_hub_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
 };
 
 /*-------------------------------------------------------------------------*/
 
-static int ohci_hcd_omap_drv_probe(struct device *dev)
+static int ohci_hcd_omap_drv_probe(struct omap_dev *dev)
 {
-	return usb_hcd_omap_probe(&ohci_omap_hc_driver,
-				to_platform_device(dev));
-}
+	struct usb_hcd *hcd = NULL;
+	int ret;
 
-static int ohci_hcd_omap_drv_remove(struct device *dev)
-{
-	struct platform_device	*pdev = to_platform_device(dev);
-	struct usb_hcd		*hcd = dev_get_drvdata(dev);
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-
-	usb_hcd_omap_remove(hcd, pdev);
-	if (ohci->transceiver) {
-		(void) otg_set_host(ohci->transceiver, 0);
-		put_device(ohci->transceiver->dev);
-	}
-	dev_set_drvdata(dev, NULL);
-
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-#if	defined(CONFIG_USB_SUSPEND) || defined(CONFIG_PM)
-
-/* states match PCI usage, always suspending the root hub except that
- * 4 ~= D3cold (ACPI D3) with clock off (resume sees reset).
- */
+	if (usb_disabled())
+		return -ENODEV;
 
-static int ohci_omap_suspend(struct device *dev, u32 state, u32 level)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci(dev_get_drvdata(dev));
-	int		status = -EINVAL;
+	ret = usb_hcd_omap_probe(&ohci_omap_hc_driver, &hcd, dev);
 
-	if (state <= dev->power.power_state)
-		return 0;
+	if (ret == 0)
+		omap_set_drvdata(dev, hcd);
 
-	dev_dbg(dev, "suspend to %d\n", state);
-	down(&ohci->hcd.self.root_hub->serialize);
-	status = ohci_hub_suspend(&ohci->hcd);
-	if (status == 0) {
-		if (state >= 4) {
-			/* power off + reset */
-			OTG_SYSCON_2_REG &= ~UHOST_EN;
-			ohci->hcd.self.root_hub->state = USB_STATE_SUSPENDED;
-			state = 4;
-		}
-		ohci->hcd.state = HCD_STATE_SUSPENDED;
-		dev->power.power_state = state;
-	}
-	up(&ohci->hcd.self.root_hub->serialize);
-	return status;
+	return ret;
 }
 
-static int ohci_omap_resume(struct device *dev, u32 level)
+static int ohci_hcd_omap_drv_remove(struct omap_dev *dev)
 {
-	struct ohci_hcd	*ohci = hcd_to_ohci(dev_get_drvdata(dev));
-	int		status = 0;
+	struct usb_hcd *hcd = omap_get_drvdata(dev);
 
-	switch (dev->power.power_state) {
-	case 0:
-		break;
-	case 4:
-		if (time_before(jiffies, ohci->next_statechange))
-			msleep(5);
-		ohci->next_statechange = jiffies;
-		OTG_SYSCON_2_REG |= UHOST_EN;
-		/* FALLTHROUGH */
-	default:
-		dev_dbg(dev, "resume from %d\n", dev->power.power_state);
-#ifdef	CONFIG_USB_SUSPEND
-		/* get extra cleanup even if remote wakeup isn't in use */
-		status = usb_resume_device(ohci->hcd.self.root_hub);
-#else
-		down(&ohci->hcd.self.root_hub->serialize);
-		status = ohci_hub_resume(&ohci->hcd);
-		up(&ohci->hcd.self.root_hub->serialize);
-#endif
-		if (status == 0)
-			dev->power.power_state = 0;
-		break;
-	}
-	return status;
-}
+	usb_hcd_omap_remove(hcd, dev);
 
-#endif
+	omap_set_drvdata(dev, NULL);
 
-/*-------------------------------------------------------------------------*/
+	return 0;
+}
 
 /*
  * Driver definition to register with the OMAP bus
  */
-static struct device_driver ohci_hcd_omap_driver = {
-	.name		= "ohci",
-	.bus		= &platform_bus_type,
+static struct omap_driver ohci_hcd_omap_driver = {
+	.drv = {
+		.name	= OMAP_OHCI_NAME,
+	},
+	.devid		= OMAP_OCP_DEVID_USB,
+	.busid		= OMAP_BUS_OCP,
+	.clocks		= 0,
 	.probe		= ohci_hcd_omap_drv_probe,
 	.remove		= ohci_hcd_omap_drv_remove,
-#if	defined(CONFIG_USB_SUSPEND) || defined(CONFIG_PM)
-	.suspend	= ohci_omap_suspend,
-	.resume		= ohci_omap_resume,
-#endif
+};
+
+/* Any dma_mask must be set for OHCI to work */
+static u64 omap_dmamask = 0xffffffffUL;	
+
+/*
+ * Device definition to match the driver above
+ */
+static struct omap_dev ohci_hcd_omap_device = {
+	.name		= OMAP_OHCI_NAME,
+	.devid		= OMAP_OCP_DEVID_USB,
+	.busid		= OMAP_BUS_OCP,
+	.mapbase	= (void *)OMAP_OHCI_BASE,
+	.dma_mask	= &omap_dmamask,	/* Needed only for OHCI */
+	.res = {
+		.start	= OMAP_OHCI_BASE,
+		.end	= OMAP_OHCI_BASE + OMAP_OHCI_SIZE,
+	},
+	.irq = {
+		INT_USB_HHC_1,
+	},
 };
 
 static int __init ohci_hcd_omap_init (void)
 {
-	printk (KERN_DEBUG "%s: " DRIVER_INFO " (OMAP)\n", hcd_name);
-	if (usb_disabled())
-		return -ENODEV;
+	int ret;
 
-	pr_debug("%s: block sizes: ed %Zd td %Zd\n", hcd_name,
+	dbg (DRIVER_INFO " (OMAP)");
+	dbg ("block sizes: ed %d td %d\n",
 		sizeof (struct ed), sizeof (struct td));
 
-	return driver_register(&ohci_hcd_omap_driver);
+	if (hmc_mode < 0 || hmc_mode > 25)
+		hmc_mode = default_hmc_mode;
+
+	/* Register the driver with OMAP bus */
+	ret = omap_driver_register(&ohci_hcd_omap_driver);
+	if (ret != 0)
+		return -ENODEV;
+
+	/* Register the device with OMAP bus */
+	ret = omap_device_register(&ohci_hcd_omap_device);
+	if (ret != 0) {
+		omap_driver_unregister(&ohci_hcd_omap_driver);
+		return -ENODEV;
+	}
+
+	return ret;
 }
 
+MODULE_PARM(hmc_mode, "hmc_mode");
+
 static void __exit ohci_hcd_omap_cleanup (void)
 {
-	driver_unregister(&ohci_hcd_omap_driver);
+	omap_device_unregister(&ohci_hcd_omap_device);
+	omap_driver_unregister(&ohci_hcd_omap_driver);
 }
 
 module_init (ohci_hcd_omap_init);
diff -Naur linuxppc-2.6.9/drivers/usb/host/ohci-omap.h linuxppc-2.6.9-dream/drivers/usb/host/ohci-omap.h
--- linuxppc-2.6.9/drivers/usb/host/ohci-omap.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/host/ohci-omap.h	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,57 @@
+/*
+ * linux/drivers/usb/host/ohci-omap.h
+ *
+ * OMAP OHCI USB controller specific defines
+ */
+
+/* OMAP USB OHCI common defines */
+#define OMAP_OHCI_NAME		"omap-ohci"
+#define OMAP_OHCI_BASE		0xfffba000
+#define OMAP_OHCI_SIZE		4096
+
+#define HMC_CLEAR		(0x3f << 1)
+#define APLL_NDPLL_SWITCH	0x0001
+#define DPLL_PLL_ENABLE		0x0010
+#define DPLL_LOCK		0x0001
+#define SOFT_REQ_REG_REQ	0x0001
+#define USB_MCLK_EN		0x0010
+#define USB_HOST_HHC_UHOST_EN	0x00000200
+#define SOFT_USB_OTG_REQ	(1 << 8)
+#define SOFT_USB_REQ		(1 << 3)
+#define STATUS_REQ_REG		0xfffe0840
+#define USB_HOST_DPLL_REQ	(1 << 8)
+#define SOFT_DPLL_REQ		(1 << 0)
+
+/* OMAP-1510 USB OHCI defines */
+#define OMAP1510_LB_MEMSIZE	32		/* Should be same as SDRAM size */
+#define OMAP1510_LB_CLOCK_DIV	0xfffec10c
+#define OMAP1510_LB_MMU_CTL	0xfffec208	
+#define OMAP1510_LB_MMU_LCK	0xfffec224
+#define OMAP1510_LB_MMU_LD_TLB	0xfffec228
+#define OMAP1510_LB_MMU_CAM_H	0xfffec22c
+#define OMAP1510_LB_MMU_CAM_L	0xfffec230
+#define OMAP1510_LB_MMU_RAM_H	0xfffec234
+#define OMAP1510_LB_MMU_RAM_L	0xfffec238
+
+/* OMAP-1610 USB OHCI defines */
+#define USB_TRANSCEIVER_CTRL	0xfffe1064
+#define OTG_REV			0xfffb0400
+
+#define OTG_SYSCON_1		0xfffb0404
+#define OTG_IDLE_EN		(1 << 15)
+#define DEV_IDLE_EN		(1 << 13)
+
+#define OTG_SYSCON_2		0xfffb0408
+#define OTG_CTRL		0xfffb040c
+#define OTG_IRQ_EN		0xfffb0410
+#define OTG_IRQ_SRC		0xfffb0414
+
+#define OTG_EN			(1 << 31)
+#define USBX_SYNCHRO		(1 << 30)
+#define SRP_VBUS		(1 << 12)
+#define OTG_PADEN		(1 << 10)
+#define HMC_PADEN		(1 << 9)
+#define UHOST_EN		(1 << 8)
+
+/* Hardware specific defines */
+#define OMAP1510_FPGA_HOST_CTRL	0xe800020c
diff -Naur linuxppc-2.6.9/drivers/usb/host/ohci-pci.c linuxppc-2.6.9-dream/drivers/usb/host/ohci-pci.c
--- linuxppc-2.6.9/drivers/usb/host/ohci-pci.c	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ohci-pci.c	2005-09-19 21:40:05.000000000 +0200
@@ -36,7 +36,6 @@
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 
 	ohci->regs = hcd->regs;
-	ohci->next_statechange = jiffies;
 	return hc_reset (ohci);
 }
 
@@ -119,26 +118,74 @@
 static int ohci_pci_suspend (struct usb_hcd *hcd, u32 state)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	u16			cmd;
+	u32			tmp;
 
-	/* suspend root hub, hoping it keeps power during suspend */
-	while (time_before (jiffies, ohci->next_statechange))
-		msleep (100);
-
-#ifdef	CONFIG_USB_SUSPEND
-	(void) usb_suspend_device (hcd->self.root_hub, state);
-#else
-	down (&hcd->self.root_hub->serialize);
-	(void) ohci_hub_suspend (hcd);
-	up (&hcd->self.root_hub->serialize);
-#endif
+	if ((ohci->hc_control & OHCI_CTRL_HCFS) != OHCI_USB_OPER) {
+		ohci_dbg (ohci, "can't suspend (state is %s)\n",
+			hcfs2string (ohci->hc_control & OHCI_CTRL_HCFS));
+		return -EIO;
+	}
 
-	/* let things settle down a bit */
-	msleep (100);
+	/* act as if usb suspend can always be used */
+	ohci_dbg (ohci, "suspend to %d\n", state);
 	
+	/* First stop processing */
+  	spin_lock_irq (&ohci->lock);
+	ohci->hc_control &=
+		~(OHCI_CTRL_PLE|OHCI_CTRL_CLE|OHCI_CTRL_BLE|OHCI_CTRL_IE);
+	writel (ohci->hc_control, &ohci->regs->control);
+	writel (OHCI_INTR_SF, &ohci->regs->intrstatus);
+	(void) readl (&ohci->regs->intrstatus);
+  	spin_unlock_irq (&ohci->lock);
+
+	/* Wait a frame or two */
+	mdelay (1);
+	if (!readl (&ohci->regs->intrstatus) & OHCI_INTR_SF)
+		mdelay (1);
+		
 #ifdef CONFIG_PMAC_PBOOK
 	if (_machine == _MACH_Pmac)
 		disable_irq ((to_pci_dev(hcd->self.controller))->irq);
+ 	/* else, 2.4 assumes shared irqs -- don't disable */
+#endif
+
+	/* Enable remote wakeup */
+	writel (readl (&ohci->regs->intrenable) | OHCI_INTR_RD,
+		&ohci->regs->intrenable);
+
+	/* Suspend chip and let things settle down a bit */
+  	spin_lock_irq (&ohci->lock);
+ 	ohci->hc_control = OHCI_USB_SUSPEND;
+ 	writel (ohci->hc_control, &ohci->regs->control);
+	(void) readl (&ohci->regs->control);
+  	spin_unlock_irq (&ohci->lock);
+
+	set_current_state (TASK_UNINTERRUPTIBLE);
+	schedule_timeout (HZ/2);
+
+	tmp = readl (&ohci->regs->control) | OHCI_CTRL_HCFS;
+	switch (tmp) {
+		case OHCI_USB_RESET:
+		case OHCI_USB_RESUME:
+		case OHCI_USB_OPER:
+			ohci_err (ohci, "can't suspend; hcfs %d\n", tmp);
+			break;
+		case OHCI_USB_SUSPEND:
+			ohci_dbg (ohci, "suspended\n");
+			break;
+	}
 
+	/* In some rare situations, Apple's OHCI have happily trashed
+	 * memory during sleep. We disable its bus master bit during
+	 * suspend
+	 */
+	pci_read_config_word (to_pci_dev(hcd->self.controller), PCI_COMMAND, 
+				&cmd);
+	cmd &= ~PCI_COMMAND_MASTER;
+	pci_write_config_word (to_pci_dev(hcd->self.controller), PCI_COMMAND, 
+				cmd);
+#ifdef CONFIG_PMAC_PBOOK
 	{
 	   	struct device_node	*of_node;
  
@@ -155,6 +202,7 @@
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	int			temp;
 	int			retval = 0;
 
 #ifdef CONFIG_PMAC_PBOOK
@@ -167,25 +215,90 @@
 			pmac_call_feature (PMAC_FTR_USB_ENABLE, of_node, 0, 1);
 	}
 #endif
-
-	/* resume root hub */
-	while (time_before (jiffies, ohci->next_statechange))
-		msleep (100);
-#ifdef	CONFIG_USB_SUSPEND
-	/* get extra cleanup even if remote wakeup isn't in use */
-	retval = usb_resume_device (hcd->self.root_hub);
-#else
-	down (&hcd->self.root_hub->serialize);
-	retval = ohci_hub_resume (hcd);
-	up (&hcd->self.root_hub->serialize);
+	/* did we suspend, or were we powered off? */
+	ohci->hc_control = readl (&ohci->regs->control);
+	temp = ohci->hc_control & OHCI_CTRL_HCFS;
+
+#ifdef DEBUG
+	/* the registers may look crazy here */
+	ohci_dump_status (ohci, 0, 0);
 #endif
 
-	if (retval == 0) {
-		hcd->self.controller->power.power_state = 0;
+	/* Re-enable bus mastering */
+	pci_set_master (to_pci_dev(ohci->hcd.self.controller));
+	
+	switch (temp) {
+
+	case OHCI_USB_RESET:	// lost power
+restart:
+		ohci_info (ohci, "USB restart\n");
+		retval = hc_restart (ohci);
+		break;
+
+	case OHCI_USB_SUSPEND:	// host wakeup
+	case OHCI_USB_RESUME:	// remote wakeup
+		ohci_info (ohci, "USB continue from %s wakeup\n",
+			 (temp == OHCI_USB_SUSPEND)
+				? "host" : "remote");
+
+		/* we "should" only need RESUME if we're SUSPENDed ... */
+		ohci->hc_control = OHCI_USB_RESUME;
+		writel (ohci->hc_control, &ohci->regs->control);
+		(void) readl (&ohci->regs->control);
+		/* Some controllers (lucent) need extra-long delays */
+		mdelay (35); /* no schedule here ! */
+
+		temp = readl (&ohci->regs->control);
+		temp = ohci->hc_control & OHCI_CTRL_HCFS;
+		if (temp != OHCI_USB_RESUME) {
+			ohci_err (ohci, "controller won't resume\n");
+			/* maybe we can reset */
+			goto restart;
+		}
+
+		/* Then re-enable operations */
+		writel (OHCI_USB_OPER, &ohci->regs->control);
+		(void) readl (&ohci->regs->control);
+		mdelay (3);
+
+		spin_lock_irq (&ohci->lock);
+		ohci->hc_control = OHCI_CONTROL_INIT | OHCI_USB_OPER;
+		if (!ohci->ed_rm_list) {
+			if (ohci->ed_controltail)
+				ohci->hc_control |= OHCI_CTRL_CLE;
+			if (ohci->ed_bulktail)
+				ohci->hc_control |= OHCI_CTRL_BLE;
+		}
+		if (hcd_to_bus (&ohci->hcd)->bandwidth_isoc_reqs
+				|| hcd_to_bus (&ohci->hcd)->bandwidth_int_reqs)
+			ohci->hc_control |= OHCI_CTRL_PLE|OHCI_CTRL_IE;
+		hcd->state = USB_STATE_RUNNING;
+		writel (ohci->hc_control, &ohci->regs->control);
+
+		/* trigger a start-frame interrupt (why?) */
+		writel (OHCI_INTR_SF, &ohci->regs->intrstatus);
+		writel (OHCI_INTR_SF, &ohci->regs->intrenable);
+
+		writel (OHCI_INTR_WDH, &ohci->regs->intrdisable);	
+		(void) readl (&ohci->regs->intrdisable);
+		spin_unlock_irq (&ohci->lock);
+
 #ifdef CONFIG_PMAC_PBOOK
 		if (_machine == _MACH_Pmac)
 			enable_irq (to_pci_dev(hcd->self.controller)->irq);
 #endif
+
+		/* Check for a pending done list */
+		if (ohci->hcca->done_head)
+			dl_done_list (ohci, dl_reverse_done_list (ohci), NULL);
+		writel (OHCI_INTR_WDH, &ohci->regs->intrenable); 
+
+		/* assume there are TDs on the bulk and control lists */
+		writel (OHCI_BLF | OHCI_CLF, &ohci->regs->cmdstatus);
+		break;
+
+	default:
+		ohci_warn (ohci, "odd PCI resume\n");
 	}
 	return retval;
 }
@@ -238,11 +351,6 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-#ifdef	CONFIG_USB_SUSPEND
-	.hub_suspend =		ohci_hub_suspend,
-	.hub_resume =		ohci_hub_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -277,7 +385,7 @@
 	if (usb_disabled())
 		return -ENODEV;
 
-	pr_debug ("%s: block sizes: ed %Zd td %Zd\n", hcd_name,
+	printk (KERN_DEBUG "%s: block sizes: ed %Zd td %Zd\n", hcd_name,
 		sizeof (struct ed), sizeof (struct td));
 	return pci_module_init (&ohci_pci_driver);
 }
diff -Naur linuxppc-2.6.9/drivers/usb/host/ohci-q.c linuxppc-2.6.9-dream/drivers/usb/host/ohci-q.c
--- linuxppc-2.6.9/drivers/usb/host/ohci-q.c	2004-10-18 23:55:24.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ohci-q.c	2005-09-19 21:40:05.000000000 +0200
@@ -22,7 +22,6 @@
 		}
 	}
 
-	list_del (&urb_priv->pending);
 	kfree (urb_priv);
 }
 
@@ -136,7 +135,7 @@
 
 	for (i = ed->branch; i < NUM_INTS; i += ed->interval) {
 		struct ed	**prev = &ohci->periodic [i];
-		__le32		*prev_p = &ohci->hcca->int_table [i];
+		u32		*prev_p = &ohci->hcca->int_table [i];
 		struct ed	*here = *prev;
 
 		/* sorting each branch by period (slow before fast)
@@ -156,8 +155,7 @@
 				ed->hwNextED = *prev_p;
 			wmb ();
 			*prev = ed;
-			*prev_p = cpu_to_le32(ed->dma);
-			wmb();
+			*prev_p = ohci_cpu_to_le32p (&ed->dma);
 		}
 		ohci->load [i] += ed->load;
 	}
@@ -170,12 +168,9 @@
 {	 
 	int	branch;
 
-	if (ohci->hcd.state == USB_STATE_QUIESCING)
-		return -EAGAIN;
-
 	ed->state = ED_OPER;
-	ed->ed_prev = NULL;
-	ed->ed_next = NULL;
+	ed->ed_prev = 0;
+	ed->ed_next = 0;
 	ed->hwNextED = 0;
 	wmb ();
 
@@ -196,11 +191,10 @@
 			writel (ed->dma, &ohci->regs->ed_controlhead);
 		} else {
 			ohci->ed_controltail->ed_next = ed;
-			ohci->ed_controltail->hwNextED = cpu_to_le32 (ed->dma);
+			ohci->ed_controltail->hwNextED = ohci_cpu_to_le32 (ed->dma);
 		}
 		ed->ed_prev = ohci->ed_controltail;
 		if (!ohci->ed_controltail && !ohci->ed_rm_list) {
-			wmb();
 			ohci->hc_control |= OHCI_CTRL_CLE;
 			writel (0, &ohci->regs->ed_controlcurrent);
 			writel (ohci->hc_control, &ohci->regs->control);
@@ -214,11 +208,10 @@
 			writel (ed->dma, &ohci->regs->ed_bulkhead);
 		} else {
 			ohci->ed_bulktail->ed_next = ed;
-			ohci->ed_bulktail->hwNextED = cpu_to_le32 (ed->dma);
+			ohci->ed_bulktail->hwNextED = ohci_cpu_to_le32 (ed->dma);
 		}
 		ed->ed_prev = ohci->ed_bulktail;
 		if (!ohci->ed_bulktail && !ohci->ed_rm_list) {
-			wmb();
 			ohci->hc_control |= OHCI_CTRL_BLE;
 			writel (0, &ohci->regs->ed_bulkcurrent);
 			writel (ohci->hc_control, &ohci->regs->control);
@@ -257,7 +250,7 @@
 	for (i = ed->branch; i < NUM_INTS; i += ed->interval) {
 		struct ed	*temp;
 		struct ed	**prev = &ohci->periodic [i];
-		__le32		*prev_p = &ohci->hcca->int_table [i];
+		u32		*prev_p = &ohci->hcca->int_table [i];
 
 		while (*prev && (temp = *prev) != ed) {
 			prev_p = &temp->hwNextED;
@@ -321,9 +314,9 @@
 			if (!ed->hwNextED) {
 				ohci->hc_control &= ~OHCI_CTRL_CLE;
 				writel (ohci->hc_control, &ohci->regs->control);
-				// a ohci_readl() later syncs CLE with the HC
+				// a readl() later syncs CLE with the HC
 			} else
-				writel (le32_to_cpup (&ed->hwNextED),
+				writel (ohci_le32_to_cpup (&ed->hwNextED),
 					&ohci->regs->ed_controlhead);
 		} else {
 			ed->ed_prev->ed_next = ed->ed_next;
@@ -333,7 +326,7 @@
 		if (ohci->ed_controltail == ed) {
 			ohci->ed_controltail = ed->ed_prev;
 			if (ohci->ed_controltail)
-				ohci->ed_controltail->ed_next = NULL;
+				ohci->ed_controltail->ed_next = 0;
 		} else if (ed->ed_next) {
 			ed->ed_next->ed_prev = ed->ed_prev;
 		}
@@ -345,9 +338,9 @@
 			if (!ed->hwNextED) {
 				ohci->hc_control &= ~OHCI_CTRL_BLE;
 				writel (ohci->hc_control, &ohci->regs->control);
-				// a ohci_readl() later syncs BLE with the HC
+				// a readl() later syncs BLE with the HC
 			} else
-				writel (le32_to_cpup (&ed->hwNextED),
+				writel (ohci_le32_to_cpup (&ed->hwNextED),
 					&ohci->regs->ed_bulkhead);
 		} else {
 			ed->ed_prev->ed_next = ed->ed_next;
@@ -357,7 +350,7 @@
 		if (ohci->ed_bulktail == ed) {
 			ohci->ed_bulktail = ed->ed_prev;
 			if (ohci->ed_bulktail)
-				ohci->ed_bulktail->ed_next = NULL;
+				ohci->ed_bulktail->ed_next = 0;
 		} else if (ed->ed_next) {
 			ed->ed_next->ed_prev = ed->ed_prev;
 		}
@@ -412,36 +405,35 @@
  		if (!td) {
 			/* out of memory */
 			ed_free (ohci, ed);
-			ed = NULL;
+			ed = 0;
 			goto done;
 		}
 		ed->dummy = td;
-		ed->hwTailP = cpu_to_le32 (td->td_dma);
+		ed->hwTailP = ohci_cpu_to_le32 (td->td_dma);
 		ed->hwHeadP = ed->hwTailP;	/* ED_C, ED_H zeroed */
 		ed->state = ED_IDLE;
 		ed->type = type;
 	}
 
 	/* NOTE: only ep0 currently needs this "re"init logic, during
-	 * enumeration (after set_address).
+	 * enumeration (after set_address, or if ep0 maxpacket >8).
 	 */
   	if (ed->state == ED_IDLE) {
 		u32	info;
-		__le32	hw_info;
 
 		info = usb_pipedevice (pipe);
 		info |= (ep >> 1) << 7;
 		info |= usb_maxpacket (udev, pipe, is_out) << 16;
-		hw_info = cpu_to_le32 (info);
+		info = ohci_cpu_to_le32 (info);
 		if (udev->speed == USB_SPEED_LOW)
-			hw_info |= ED_LOWSPEED;
+			info |= ED_LOWSPEED;
 		/* only control transfers store pids in tds */
 		if (type != PIPE_CONTROL) {
-			hw_info |= is_out ? ED_OUT : ED_IN;
+			info |= is_out ? ED_OUT : ED_IN;
 			if (type != PIPE_BULK) {
 				/* periodic transfers... */
 				if (type == PIPE_ISOCHRONOUS)
-					hw_info |= ED_ISO;
+					info |= ED_ISO;
 				else if (interval > 32)	/* iso can be bigger */
 					interval = 32;
 				ed->interval = interval;
@@ -452,7 +444,7 @@
 						/ 1000;
 			}
 		}
-		ed->hwINFO = hw_info;
+		ed->hwINFO = info;
 	}
 
 done:
@@ -475,14 +467,14 @@
 
 	/* rm_list is just singly linked, for simplicity */
 	ed->ed_next = ohci->ed_rm_list;
-	ed->ed_prev = NULL;
+	ed->ed_prev = 0;
 	ohci->ed_rm_list = ed;
 
 	/* enable SOF interrupt */
 	writel (OHCI_INTR_SF, &ohci->regs->intrstatus);
 	writel (OHCI_INTR_SF, &ohci->regs->intrenable);
 	// flush those writes, and get latest HCCA contents
-	(void) ohci_readl (&ohci->regs->control);
+	(void) readl (&ohci->regs->control);
 
 	/* SF interrupt might get delayed; record the frame counter value that
 	 * indicates when the HC isn't looking at it, so concurrent unlinks
@@ -541,19 +533,20 @@
 	if (!len)
 		data = 0;
 
-	td->hwINFO = cpu_to_le32 (info);
+	td->hwINFO = ohci_cpu_to_le32 (info);
+	
 	if (is_iso) {
-		td->hwCBP = cpu_to_le32 (data & 0xFFFFF000);
-		td->hwPSW [0] = cpu_to_le16 ((data & 0x0FFF) | 0xE000);
+		td->hwCBP = ohci_cpu_to_le32 (data & 0xFFFFF000);
+		td->hwPSW [0] = ohci_cpu_to_le16 ((data & 0x0FFF) | 0xE000);
 		td->ed->last_iso = info & 0xffff;
 	} else {
-		td->hwCBP = cpu_to_le32 (data); 
+		td->hwCBP = ohci_cpu_to_le32 (data); 
 	}			
 	if (data)
-		td->hwBE = cpu_to_le32 (data + len - 1);
+		td->hwBE = ohci_cpu_to_le32 (data + len - 1);
 	else
 		td->hwBE = 0;
-	td->hwNextTD = cpu_to_le32 (td_pt->td_dma);
+	td->hwNextTD = ohci_cpu_to_le32 (td_pt->td_dma);
 
 	/* append to queue */
 	list_add_tail (&td->td_list, &td->ed->td_list);
@@ -598,12 +591,13 @@
 	}
 
 	urb_priv->td_cnt = 0;
-	list_add (&urb_priv->pending, &ohci->pending);
 
 	if (data_len)
 		data = urb->transfer_dma;
 	else
 		data = 0;
+		
+	flush_dcache_all();   /* evil workaround :( */
 
 	/* NOTE:  TD_CC is set so we can tell which TDs the HC processed by
 	 * using TD_CC_GET, as well as by seeing them on the done list.
@@ -709,14 +703,14 @@
  */
 static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 {
-	u32	tdINFO = le32_to_cpup (&td->hwINFO);
+	u32	tdINFO = ohci_le32_to_cpup (&td->hwINFO);
 	int	cc = 0;
 
 	list_del (&td->td_list);
 
 	/* ISO ... drivers see per-TD length/status */
   	if (tdINFO & TD_ISO) {
- 		u16	tdPSW = le16_to_cpu (td->hwPSW [0]);
+ 		u16	tdPSW = ohci_le16_to_cpu (td->hwPSW [0]);
 		int	dlen = 0;
 
 		/* NOTE:  assumes FC in tdINFO == 0 (and MAXPSW == 1) */
@@ -748,10 +742,16 @@
 	 */
 	} else {
 		int	type = usb_pipetype (urb->pipe);
-		u32	tdBE = le32_to_cpup (&td->hwBE);
+		u32	tdBE = ohci_le32_to_cpup (&td->hwBE);
 
   		cc = TD_CC_GET (tdINFO);
 
+		/* control endpoints only have soft stalls */
+  		if (type != PIPE_CONTROL && cc == TD_CC_STALL)
+			usb_endpoint_halt (urb->dev,
+				usb_pipeendpoint (urb->pipe),
+				usb_pipeout (urb->pipe));
+
 		/* update packet status if needed (short is normally ok) */
 		if (cc == TD_DATAUNDERRUN
 				&& !(urb->transfer_flags & URB_SHORT_NOT_OK))
@@ -769,7 +769,7 @@
 				urb->actual_length += tdBE - td->data_dma + 1;
 			else
 				urb->actual_length +=
-					  le32_to_cpup (&td->hwCBP)
+					  ohci_le32_to_cpup (&td->hwCBP)
 					- td->data_dma;
 		}
 
@@ -790,7 +790,7 @@
   	struct urb		*urb = td->urb;
 	struct ed		*ed = td->ed;
 	struct list_head	*tmp = td->td_list.next;
-	__le32			toggle = ed->hwHeadP & ED_C;
+	u32			toggle = ed->hwHeadP & ED_C;
 
 	/* clear ed halt; this is the td that caused it, but keep it inactive
 	 * until its urb->complete() has a chance to clean up.
@@ -805,7 +805,7 @@
 	 */
 	while (tmp != &ed->td_list) {
 		struct td	*next;
-		__le32		info;
+		u32		info;
 
 		next = list_entry (tmp, struct td, td_list);
 		tmp = next->td_list.next;
@@ -821,13 +821,13 @@
 		 * and clear ED_SKIP.
 		 */
 		info = next->hwINFO;
-		info |= cpu_to_le32 (TD_DONE);
-		info &= ~cpu_to_le32 (TD_CC);
+		info |= ohci_cpu_to_le32 (TD_DONE);
+		info &= ~ohci_cpu_to_le32 (TD_CC);
 		next->hwINFO = info;
 
 		next->next_dl_td = rev;	
 		rev = next;
-
+		
 		ed->hwHeadP = next->hwNextTD | toggle;
 	}
 
@@ -850,7 +850,7 @@
 			urb, urb->dev->devpath,
 			usb_pipeendpoint (urb->pipe),
 			usb_pipein (urb->pipe) ? "in" : "out",
-			le32_to_cpu (td->hwINFO),
+			ohci_le32_to_cpu (td->hwINFO),
 			cc, cc_to_error [cc]);
 	}
 
@@ -865,10 +865,12 @@
 	u32		td_dma;
 	struct td	*td_rev = NULL;
 	struct td	*td = NULL;
+  	unsigned long	flags;
 
-	td_dma = le32_to_cpup (&ohci->hcca->done_head);
+  	spin_lock_irqsave (&ohci->lock, flags);
+  	
+	td_dma = ohci_le32_to_cpup (&ohci->hcca->done_head);
 	ohci->hcca->done_head = 0;
-	wmb();
 
 	/* get TD from hc's singly linked list, and
 	 * prepend to ours.  ed->td_list changes later.
@@ -882,8 +884,8 @@
 			break;
 		}
 
-		td->hwINFO |= cpu_to_le32 (TD_DONE);
-		cc = TD_CC_GET (le32_to_cpup (&td->hwINFO));
+		td->hwINFO |= ohci_cpu_to_le32 (TD_DONE);
+		cc = TD_CC_GET (ohci_le32_to_cpup (&td->hwINFO));
 
 		/* Non-iso endpoints can halt on error; un-halt,
 		 * and dequeue any other TDs from this urb.
@@ -894,13 +896,17 @@
 
 		td->next_dl_td = td_rev;	
 		td_rev = td;
-		td_dma = le32_to_cpup (&td->hwNextTD);
+		td_dma = ohci_le32_to_cpup (&td->hwNextTD);
 	}	
+	spin_unlock_irqrestore (&ohci->lock, flags);
 	return td_rev;
 }
 
 /*-------------------------------------------------------------------------*/
 
+/* wrap-aware logic stolen from <linux/jiffies.h> */
+#define tick_before(t1,t2) ((((s16)(t1))-((s16)(t2))) < 0)
+
 /* there are some urbs/eds to unlink; called in_irq(), with HCD locked */
 static void
 finish_unlinks (struct ohci_hcd *ohci, u16 tick, struct pt_regs *regs)
@@ -911,12 +917,12 @@
 	for (last = &ohci->ed_rm_list, ed = *last; ed != NULL; ed = *last) {
 		struct list_head	*entry, *tmp;
 		int			completed, modified;
-		__le32			*prev;
+		u32			*prev;
 
 		/* only take off EDs that the HC isn't using, accounting for
 		 * frame counter wraps and EDs with partially retired TDs
 		 */
-		if (likely (regs && HCD_IS_RUNNING(ohci->hcd.state))) {
+		if (likely (HCD_IS_RUNNING(ohci->hcd.state))) {
 			if (tick_before (tick, ed->tick)) {
 skip_ed:
 				last = &ed->ed_next;
@@ -929,7 +935,7 @@
 
 				td = list_entry (ed->td_list.next, struct td,
 							td_list);
-				head = le32_to_cpu (ed->hwHeadP) & TD_MASK;
+				head = ohci_cpu_to_le32 (ed->hwHeadP) & TD_MASK;
 
 				/* INTR_WDH may need to clean up first */
 				if (td->td_dma != head)
@@ -942,7 +948,7 @@
 		 * entries (which we'd ignore), but paranoia won't hurt.
 		 */
 		*last = ed->ed_next;
-		ed->ed_next = NULL;
+		ed->ed_next = 0;
 		modified = 0;
 
 		/* unlink urbs as requested, but rescan the list after
@@ -960,7 +966,7 @@
 			struct td	*td;
 			struct urb	*urb;
 			urb_priv_t	*urb_priv;
-			__le32		savebits;
+			u32		savebits;
 
 			td = list_entry (entry, struct td, td_list);
 			urb = td->urb;
@@ -972,7 +978,7 @@
 			}
 
 			/* patch pointer hc uses */
-			savebits = *prev & ~cpu_to_le32 (TD_MASK);
+			savebits = *prev & ~ohci_cpu_to_le32 (TD_MASK);
 			*prev = td->hwNextTD | savebits;
 
 			/* HC may have partly processed this TD */
@@ -1006,9 +1012,7 @@
    	}
 
 	/* maybe reenable control and bulk lists */ 
-	if (HCD_IS_RUNNING(ohci->hcd.state)
-			&& ohci->hcd.state != USB_STATE_QUIESCING
-			&& !ohci->ed_rm_list) {
+	if (HCD_IS_RUNNING(ohci->hcd.state) && !ohci->ed_rm_list) {
 		u32	command = 0, control = 0;
 
 		if (ohci->ed_controltail) {
@@ -1048,10 +1052,11 @@
  * scanning the (re-reversed) donelist as this does.
  */
 static void
-dl_done_list (struct ohci_hcd *ohci, struct pt_regs *regs)
+dl_done_list (struct ohci_hcd *ohci, struct td *td, struct pt_regs *regs)
 {
-	struct td	*td = dl_reverse_done_list (ohci);
+	unsigned long	flags;
 
+  	spin_lock_irqsave (&ohci->lock, flags);
   	while (td) {
 		struct td	*td_next = td->next_dl_td;
 		struct urb	*urb = td->urb;
@@ -1067,12 +1072,10 @@
   			finish_urb (ohci, urb, regs);
 
 		/* clean schedule:  unlink EDs that are no longer busy */
-		if (list_empty (&ed->td_list)) {
-			if (ed->state == ED_OPER)
-				start_ed_unlink (ohci, ed);
-
+		if (list_empty (&ed->td_list) && ed->state == ED_OPER)
+			start_ed_unlink (ohci, ed);
 		/* ... reenabling halted EDs only after fault cleanup */
-		} else if ((ed->hwINFO & (ED_SKIP | ED_DEQUEUE)) == ED_SKIP) {
+		else if ((ed->hwINFO & (ED_SKIP | ED_DEQUEUE)) == ED_SKIP) {
 			td = list_entry (ed->td_list.next, struct td, td_list);
 			if (!(td->hwINFO & TD_DONE)) {
 				ed->hwINFO &= ~ED_SKIP;
@@ -1092,4 +1095,5 @@
 
     		td = td_next;
   	}  
+	spin_unlock_irqrestore (&ohci->lock, flags);
 }
diff -Naur linuxppc-2.6.9/drivers/usb/host/ohci-sa1111.c linuxppc-2.6.9-dream/drivers/usb/host/ohci-sa1111.c
--- linuxppc-2.6.9/drivers/usb/host/ohci-sa1111.c	2004-10-18 23:54:27.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/ohci-sa1111.c	2005-09-19 21:40:05.000000000 +0200
@@ -237,6 +237,7 @@
  */
 void usb_hcd_sa1111_remove (struct usb_hcd *hcd, struct sa1111_dev *dev)
 {
+	struct usb_device	*hub;
 	void *base;
 
 	info ("remove: %s, state %x", hcd->self.bus_name, hcd->state);
@@ -244,10 +245,11 @@
 	if (in_interrupt ())
 		BUG ();
 
+	hub = hcd->self.root_hub;
 	hcd->state = USB_STATE_QUIESCING;
 
 	dbg ("%s: roothub graceful disconnect", hcd->self.bus_name);
-	usb_disconnect (&hcd->self.root_hub);
+	usb_disconnect (&hub);
 
 	hcd->driver->stop (hcd);
 	hcd->state = USB_STATE_HALT;
@@ -346,10 +348,6 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-#ifdef	CONFIG_USB_SUSPEND
-	.hub_suspend =		ohci_hub_suspend,
-	.hub_resume =		ohci_hub_resume,
-#endif
 };
 
 /*-------------------------------------------------------------------------*/
diff -Naur linuxppc-2.6.9/drivers/usb/host/uhci-debug.c linuxppc-2.6.9-dream/drivers/usb/host/uhci-debug.c
--- linuxppc-2.6.9/drivers/usb/host/uhci-debug.c	2004-10-18 23:53:22.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/uhci-debug.c	2005-09-19 21:40:05.000000000 +0200
@@ -27,7 +27,7 @@
 		p = strchr(buf, '\n');
 		if (p)
 			*p = 0;
-		printk(KERN_DEBUG "%s\n", buf);
+		printk("%s\n", buf);
 		buf = p;
 		if (buf)
 			buf++;
@@ -210,7 +210,7 @@
   "skel_int32_qh", "skel_int16_qh",
   "skel_int8_qh", "skel_int4_qh",
   "skel_int2_qh", "skel_int1_qh",
-  "skel_ls_control_qh", "skel_fs_control_qh",
+  "skel_ls_control_qh", "skel_hs_control_qh",
   "skel_bulk_qh", "skel_term_qh"
 };
 
@@ -248,7 +248,7 @@
 static int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)
 {
 	char *out = buf;
-	unsigned long io_addr = uhci->io_addr;
+	unsigned int io_addr = uhci->io_addr;
 	unsigned short usbcmd, usbstat, usbint, usbfrnum;
 	unsigned int flbaseadd;
 	unsigned char sof;
@@ -328,17 +328,21 @@
 	//out += sprintf(out, "Inserttime=%lx ",urbp->inserttime);
 	//out += sprintf(out, "FSBRtime=%lx ",urbp->fsbrtime);
 
+	spin_lock(&urbp->urb->lock);
 	count = 0;
 	list_for_each(tmp, &urbp->td_list)
 		count++;
+	spin_unlock(&urbp->urb->lock);
 	out += sprintf(out, "TDs=%d ",count);
 
 	if (urbp->queued)
 		out += sprintf(out, "queued\n");
 	else {
+		spin_lock(&uhci->frame_list_lock);
 		count = 0;
 		list_for_each(tmp, &urbp->queue_list)
 			count++;
+		spin_unlock(&uhci->frame_list_lock);
 		out += sprintf(out, "queued URBs=%d\n", count);
 	}
 
@@ -348,10 +352,12 @@
 static int uhci_show_lists(struct uhci_hcd *uhci, char *buf, int len)
 {
 	char *out = buf;
+	unsigned long flags;
 	struct list_head *head, *tmp;
 	int count;
 
 	out += sprintf(out, "Main list URBs:");
+	spin_lock_irqsave(&uhci->urb_list_lock, flags);
 	if (list_empty(&uhci->urb_list))
 		out += sprintf(out, " Empty\n");
 	else {
@@ -367,8 +373,10 @@
 			tmp = tmp->next;
 		}
 	}
+	spin_unlock_irqrestore(&uhci->urb_list_lock, flags);
 
 	out += sprintf(out, "Remove list URBs:");
+	spin_lock_irqsave(&uhci->urb_remove_list_lock, flags);
 	if (list_empty(&uhci->urb_remove_list))
 		out += sprintf(out, " Empty\n");
 	else {
@@ -384,8 +392,10 @@
 			tmp = tmp->next;
 		}
 	}
+	spin_unlock_irqrestore(&uhci->urb_remove_list_lock, flags);
 
 	out += sprintf(out, "Complete list URBs:");
+	spin_lock_irqsave(&uhci->complete_list_lock, flags);
 	if (list_empty(&uhci->complete_list))
 		out += sprintf(out, " Empty\n");
 	else {
@@ -401,6 +411,7 @@
 			tmp = tmp->next;
 		}
 	}
+	spin_unlock_irqrestore(&uhci->complete_list_lock, flags);
 
 	return out - buf;
 }
@@ -414,7 +425,7 @@
 	struct uhci_td *td;
 	struct list_head *tmp, *head;
 
-	spin_lock_irqsave(&uhci->schedule_lock, flags);
+	spin_lock_irqsave(&uhci->frame_list_lock, flags);
 
 	out += sprintf(out, "HC status\n");
 	out += uhci_show_status(uhci, out, len - (out - buf));
@@ -497,11 +508,11 @@
 		}
 	}
 
+	spin_unlock_irqrestore(&uhci->frame_list_lock, flags);
+
 	if (debug > 2)
 		out += uhci_show_lists(uhci, out, len - (out - buf));
 
-	spin_unlock_irqrestore(&uhci->schedule_lock, flags);
-
 	return out - buf;
 }
 
@@ -567,11 +578,31 @@
 	return (file->f_pos = new);
 }
 
-static ssize_t uhci_proc_read(struct file *file, char __user *buf,
-				size_t nbytes, loff_t *ppos)
+static ssize_t uhci_proc_read(struct file *file, char *buf, size_t nbytes,
+			loff_t *ppos)
 {
 	struct uhci_proc *up = file->private_data;
-	return simple_read_from_buffer(buf, nbytes, ppos, up->data, up->size);
+	unsigned int pos;
+	unsigned int size;
+
+	pos = *ppos;
+	size = up->size;
+	if (pos >= size)
+		return 0;
+	if (nbytes >= size)
+		nbytes = size;
+	if (pos + nbytes > size)
+		nbytes = size - pos;
+
+	if (!access_ok(VERIFY_WRITE, buf, nbytes))
+		return -EINVAL;
+
+	if (copy_to_user(buf, up->data + pos, nbytes))
+		return -EFAULT;
+
+	*ppos += nbytes;
+
+	return nbytes;
 }
 
 static int uhci_proc_release(struct inode *inode, struct file *file)
@@ -592,3 +623,4 @@
 	.release =	uhci_proc_release,
 };
 #endif
+
diff -Naur linuxppc-2.6.9/drivers/usb/host/uhci-hcd.c linuxppc-2.6.9-dream/drivers/usb/host/uhci-hcd.c
--- linuxppc-2.6.9/drivers/usb/host/uhci-hcd.c	2004-10-18 23:55:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/uhci-hcd.c	2005-09-19 21:40:05.000000000 +0200
@@ -82,7 +82,7 @@
 #else
 static int debug = 0;
 #endif
-module_param(debug, int, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug level");
 static char *errbuf;
 #define ERRBUF_LEN    (32 * 1024)
@@ -95,16 +95,12 @@
 static int uhci_get_current_frame_number(struct uhci_hcd *uhci);
 static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb);
 static void uhci_unlink_generic(struct uhci_hcd *uhci, struct urb *urb);
-static void uhci_remove_pending_urbps(struct uhci_hcd *uhci);
-static void uhci_finish_completion(struct usb_hcd *hcd, struct pt_regs *regs);
-static void uhci_free_pending_qhs(struct uhci_hcd *uhci);
-static void uhci_free_pending_tds(struct uhci_hcd *uhci);
 
 static void hc_state_transitions(struct uhci_hcd *uhci);
 
 /* If a transfer is still active after this much time, turn off FSBR */
-#define IDLE_TIMEOUT	msecs_to_jiffies(50)
-#define FSBR_DELAY	msecs_to_jiffies(50)
+#define IDLE_TIMEOUT	(HZ / 20)	/* 50 ms */
+#define FSBR_DELAY	(HZ / 20)	/* 50 ms */
 
 /* When we timeout an idle transfer for FSBR, we'll switch it over to */
 /* depth first traversal. We'll do it in groups of this number of TD's */
@@ -121,18 +117,26 @@
  */
 static inline void uhci_set_next_interrupt(struct uhci_hcd *uhci)
 {
+	unsigned long flags;
+
+	spin_lock_irqsave(&uhci->frame_list_lock, flags);
 	uhci->term_td->status |= cpu_to_le32(TD_CTRL_IOC); 
+	spin_unlock_irqrestore(&uhci->frame_list_lock, flags);
 }
 
 static inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)
 {
+	spin_lock(&uhci->frame_list_lock);
 	uhci->term_td->status &= ~cpu_to_le32(TD_CTRL_IOC);
+	spin_unlock(&uhci->frame_list_lock);
 }
 
 static inline void uhci_moveto_complete(struct uhci_hcd *uhci, 
 					struct urb_priv *urbp)
 {
+	spin_lock(&uhci->complete_list_lock);
 	list_move_tail(&urbp->urb_list, &uhci->complete_list);
+	spin_unlock(&uhci->complete_list_lock);
 }
 
 static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci, struct usb_device *dev)
@@ -161,8 +165,8 @@
 	return td;
 }
 
-static inline void uhci_fill_td(struct uhci_td *td, u32 status,
-		u32 token, u32 buffer)
+static inline void uhci_fill_td(struct uhci_td *td, __u32 status,
+		__u32 token, __u32 buffer)
 {
 	td->status = cpu_to_le32(status);
 	td->token = cpu_to_le32(token);
@@ -174,8 +178,12 @@
  */
 static void uhci_insert_td_frame_list(struct uhci_hcd *uhci, struct uhci_td *td, unsigned framenum)
 {
+	unsigned long flags;
+
 	framenum %= UHCI_NUMFRAMES;
 
+	spin_lock_irqsave(&uhci->frame_list_lock, flags);
+
 	td->frame = framenum;
 
 	/* Is there a TD already mapped there? */
@@ -188,21 +196,26 @@
 		list_add_tail(&td->fl_list, &ftd->fl_list);
 
 		td->link = ltd->link;
-		wmb();
+		mb();
 		ltd->link = cpu_to_le32(td->dma_handle);
 	} else {
 		td->link = uhci->fl->frame[framenum];
-		wmb();
+		mb();
 		uhci->fl->frame[framenum] = cpu_to_le32(td->dma_handle);
 		uhci->fl->frame_cpu[framenum] = td;
 	}
+
+	spin_unlock_irqrestore(&uhci->frame_list_lock, flags);
 }
 
 static void uhci_remove_td(struct uhci_hcd *uhci, struct uhci_td *td)
 {
+	unsigned long flags;
+
 	/* If it's not inserted, don't remove it */
+	spin_lock_irqsave(&uhci->frame_list_lock, flags);
 	if (td->frame == -1 && list_empty(&td->fl_list))
-		return;
+		goto out;
 
 	if (td->frame != -1 && uhci->fl->frame_cpu[td->frame] == td) {
 		if (list_empty(&td->fl_list)) {
@@ -222,17 +235,20 @@
 		ptd->link = td->link;
 	}
 
-	wmb();
+	mb();
 	td->link = UHCI_PTR_TERM;
 
 	list_del_init(&td->fl_list);
 	td->frame = -1;
+
+out:
+	spin_unlock_irqrestore(&uhci->frame_list_lock, flags);
 }
 
 /*
  * Inserts a td into qh list at the top.
  */
-static void uhci_insert_tds_in_qh(struct uhci_qh *qh, struct urb *urb, __le32 breadth)
+static void uhci_insert_tds_in_qh(struct uhci_qh *qh, struct urb *urb, u32 breadth)
 {
 	struct list_head *tmp, *head;
 	struct urb_priv *urbp = (struct urb_priv *)urb->hcpriv;
@@ -323,11 +339,12 @@
 
 /*
  * Append this urb's qh after the last qh in skelqh->list
+ * MUST be called with uhci->frame_list_lock acquired
  *
  * Note that urb_priv.queue_list doesn't have a separate queue head;
  * it's a ring with every element "live".
  */
-static void uhci_insert_qh(struct uhci_hcd *uhci, struct uhci_qh *skelqh, struct urb *urb)
+static void _uhci_insert_qh(struct uhci_hcd *uhci, struct uhci_qh *skelqh, struct urb *urb)
 {
 	struct urb_priv *urbp = (struct urb_priv *)urb->hcpriv;
 	struct list_head *tmp;
@@ -336,7 +353,17 @@
 	/* Grab the last QH */
 	lqh = list_entry(skelqh->list.prev, struct uhci_qh, list);
 
-	/* Point to the next skelqh */
+	/*
+	 * Patch this endpoint's URB's QHs to point to the next skelqh:
+	 *    skelqh --> ... lqh --> newqh --> next skelqh
+	 * Do this first, so the HC always sees the right QH after this one.
+	 */
+	list_for_each (tmp, &urbp->queue_list) {
+		struct urb_priv *turbp =
+			list_entry(tmp, struct urb_priv, queue_list);
+
+		turbp->qh->link = lqh->link;
+	}
 	urbp->qh->link = lqh->link;
 	wmb();				/* Ordering is important */
 
@@ -356,54 +383,52 @@
 	 *
 	 * The HC could see (and use!) any of these as we write them.
 	 */
-	lqh->link = cpu_to_le32(urbp->qh->dma_handle) | UHCI_PTR_QH;
 	if (lqh->urbp) {
 		list_for_each (tmp, &lqh->urbp->queue_list) {
 			struct urb_priv *turbp =
 				list_entry(tmp, struct urb_priv, queue_list);
 
-			turbp->qh->link = lqh->link;
+			turbp->qh->link = cpu_to_le32(urbp->qh->dma_handle) | UHCI_PTR_QH;
 		}
 	}
+	lqh->link = cpu_to_le32(urbp->qh->dma_handle) | UHCI_PTR_QH;
 
 	list_add_tail(&urbp->qh->list, &skelqh->list);
 }
 
+static void uhci_insert_qh(struct uhci_hcd *uhci, struct uhci_qh *skelqh, struct urb *urb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&uhci->frame_list_lock, flags);
+	_uhci_insert_qh(uhci, skelqh, urb);
+	spin_unlock_irqrestore(&uhci->frame_list_lock, flags);
+}
+
 /*
  * Start removal of QH from schedule; it finishes next frame.
  * TDs should be unlinked before this is called.
  */
 static void uhci_remove_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
+	unsigned long flags;
 	struct uhci_qh *pqh;
-	__le32 newlink;
-	unsigned int age;
 
 	if (!qh)
 		return;
 
+	qh->urbp = NULL;
+
 	/*
 	 * Only go through the hoops if it's actually linked in
+	 * Queued QHs are removed in uhci_delete_queued_urb,
+	 * since (for queued URBs) the pqh is pointed to the next
+	 * QH in the queue, not the next endpoint's QH.
 	 */
+	spin_lock_irqsave(&uhci->frame_list_lock, flags);
 	if (!list_empty(&qh->list)) {
-
-		/* If our queue is nonempty, make the next URB the head */
-		if (!list_empty(&qh->urbp->queue_list)) {
-			struct urb_priv *nurbp;
-
-			nurbp = list_entry(qh->urbp->queue_list.next,
-					struct urb_priv, queue_list);
-			nurbp->queued = 0;
-			list_add(&nurbp->qh->list, &qh->list);
-			newlink = cpu_to_le32(nurbp->qh->dma_handle) | UHCI_PTR_QH;
-		} else
-			newlink = qh->link;
-
-		/* Fix up the previous QH's queue to link to either
-		 * the new head of this queue or the start of the
-		 * next endpoint's queue. */
 		pqh = list_entry(qh->list.prev, struct uhci_qh, list);
-		pqh->link = newlink;
+
 		if (pqh->urbp) {
 			struct list_head *head, *tmp;
 
@@ -415,26 +440,21 @@
 
 				tmp = tmp->next;
 
-				turbp->qh->link = newlink;
+				turbp->qh->link = qh->link;
 			}
 		}
-		wmb();
 
+		pqh->link = qh->link;
+		mb();
 		/* Leave qh->link in case the HC is on the QH now, it will */
 		/* continue the rest of the schedule */
 		qh->element = UHCI_PTR_TERM;
 
 		list_del_init(&qh->list);
 	}
+	spin_unlock_irqrestore(&uhci->frame_list_lock, flags);
 
-	list_del_init(&qh->urbp->queue_list);
-	qh->urbp = NULL;
-
-	age = uhci_get_current_frame_number(uhci);
-	if (age != uhci->qh_remove_age) {
-		uhci_free_pending_qhs(uhci);
-		uhci->qh_remove_age = age;
-	}
+	spin_lock_irqsave(&uhci->qh_remove_list_lock, flags);
 
 	/* Check to see if the remove list is empty. Set the IOC bit */
 	/* to force an interrupt so we can remove the QH */
@@ -442,6 +462,8 @@
 		uhci_set_next_interrupt(uhci);
 
 	list_add(&qh->remove_list, &uhci->qh_remove_list);
+
+	spin_unlock_irqrestore(&uhci->qh_remove_list_lock, flags);
 }
 
 static int uhci_fixup_toggle(struct urb *urb, unsigned int toggle)
@@ -475,10 +497,13 @@
 	struct urb_priv *eurbp, *urbp, *furbp, *lurbp;
 	struct list_head *tmp;
 	struct uhci_td *lltd;
+	unsigned long flags;
 
 	eurbp = eurb->hcpriv;
 	urbp = urb->hcpriv;
 
+	spin_lock_irqsave(&uhci->frame_list_lock, flags);
+
 	/* Find the first URB in the queue */
 	if (eurbp->queued) {
 		struct list_head *head = &eurbp->queue_list;
@@ -511,13 +536,15 @@
 	/* All qh's in the queue need to link to the next queue */
 	urbp->qh->link = eurbp->qh->link;
 
-	wmb();			/* Make sure we flush everything */
+	mb();			/* Make sure we flush everything */
 
 	lltd->link = cpu_to_le32(urbp->qh->dma_handle) | UHCI_PTR_QH;
 
 	list_add_tail(&urbp->queue_list, &furbp->queue_list);
 
 	urbp->queued = 1;
+
+	spin_unlock_irqrestore(&uhci->frame_list_lock, flags);
 }
 
 static void uhci_delete_queued_urb(struct uhci_hcd *uhci, struct urb *urb)
@@ -527,11 +554,14 @@
 	struct urb_priv *purbp;
 	struct uhci_td *pltd;
 	unsigned int toggle;
+	unsigned long flags;
 
 	urbp = urb->hcpriv;
 
+	spin_lock_irqsave(&uhci->frame_list_lock, flags);
+
 	if (list_empty(&urbp->queue_list))
-		return;
+		goto out;
 
 	nurbp = list_entry(urbp->queue_list.next, struct urb_priv, queue_list);
 
@@ -573,9 +603,39 @@
 				usb_pipeout(urb->pipe), toggle);
 	}
 
-	if (urbp->queued) {
-		/* We're somewhere in the middle (or end).  The case where
-		 * we're at the head is handled in uhci_remove_qh(). */
+	if (!urbp->queued) {
+		struct uhci_qh *pqh;
+
+		nurbp->queued = 0;
+
+		/*
+		 * Fixup the previous QH's queue to link to the new head
+		 * of this queue.
+		 */
+		pqh = list_entry(urbp->qh->list.prev, struct uhci_qh, list);
+
+		if (pqh->urbp) {
+			struct list_head *head, *tmp;
+
+			head = &pqh->urbp->queue_list;
+			tmp = head->next;
+			while (head != tmp) {
+				struct urb_priv *turbp =
+					list_entry(tmp, struct urb_priv, queue_list);
+
+				tmp = tmp->next;
+
+				turbp->qh->link = cpu_to_le32(nurbp->qh->dma_handle) | UHCI_PTR_QH;
+			}
+		}
+
+		pqh->link = cpu_to_le32(nurbp->qh->dma_handle) | UHCI_PTR_QH;
+
+		list_add_tail(&nurbp->qh->list, &urbp->qh->list);
+		list_del_init(&urbp->qh->list);
+	} else {
+		/* We're somewhere in the middle (or end). A bit trickier */
+		/*  than the head scenario */
 		purbp = list_entry(urbp->queue_list.prev, struct urb_priv,
 				queue_list);
 
@@ -588,7 +648,10 @@
 			pltd->link = UHCI_PTR_TERM;
 	}
 
-	/* urbp->queue_list is handled in uhci_remove_qh() */
+	list_del_init(&urbp->queue_list);
+
+out:
+	spin_unlock_irqrestore(&uhci->frame_list_lock, flags);
 }
 
 static struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci, struct urb *urb)
@@ -616,6 +679,9 @@
 	return urbp;
 }
 
+/*
+ * MUST be called with urb->lock acquired
+ */
 static void uhci_add_td_to_urb(struct urb *urb, struct uhci_td *td)
 {
 	struct urb_priv *urbp = (struct urb_priv *)urb->hcpriv;
@@ -625,6 +691,9 @@
 	list_add_tail(&td->list, &urbp->td_list);
 }
 
+/*
+ * MUST be called with urb->lock acquired
+ */
 static void uhci_remove_td_from_urb(struct uhci_td *td)
 {
 	if (list_empty(&td->list))
@@ -635,11 +704,14 @@
 	td->urb = NULL;
 }
 
+/*
+ * MUST be called with urb->lock acquired
+ */
 static void uhci_destroy_urb_priv(struct uhci_hcd *uhci, struct urb *urb)
 {
 	struct list_head *head, *tmp;
 	struct urb_priv *urbp;
-	unsigned int age;
+	unsigned long flags;
 
 	urbp = (struct urb_priv *)urb->hcpriv;
 	if (!urbp)
@@ -649,11 +721,7 @@
 		dev_warn(uhci_dev(uhci), "urb %p still on uhci->urb_list "
 				"or uhci->remove_list!\n", urb);
 
-	age = uhci_get_current_frame_number(uhci);
-	if (age != uhci->td_remove_age) {
-		uhci_free_pending_tds(uhci);
-		uhci->td_remove_age = age;
-	}
+	spin_lock_irqsave(&uhci->td_remove_list_lock, flags);
 
 	/* Check to see if the remove list is empty. Set the IOC bit */
 	/* to force an interrupt so we can remove the TD's*/
@@ -672,30 +740,42 @@
 		list_add(&td->remove_list, &uhci->td_remove_list);
 	}
 
+	spin_unlock_irqrestore(&uhci->td_remove_list_lock, flags);
+
 	urb->hcpriv = NULL;
 	kmem_cache_free(uhci_up_cachep, urbp);
 }
 
 static void uhci_inc_fsbr(struct uhci_hcd *uhci, struct urb *urb)
 {
+	unsigned long flags;
 	struct urb_priv *urbp = (struct urb_priv *)urb->hcpriv;
 
+	spin_lock_irqsave(&uhci->frame_list_lock, flags);
+
 	if ((!(urb->transfer_flags & URB_NO_FSBR)) && !urbp->fsbr) {
 		urbp->fsbr = 1;
 		if (!uhci->fsbr++ && !uhci->fsbrtimeout)
-			uhci->skel_term_qh->link = cpu_to_le32(uhci->skel_fs_control_qh->dma_handle) | UHCI_PTR_QH;
+			uhci->skel_term_qh->link = cpu_to_le32(uhci->skel_hs_control_qh->dma_handle) | UHCI_PTR_QH;
 	}
+
+	spin_unlock_irqrestore(&uhci->frame_list_lock, flags);
 }
 
 static void uhci_dec_fsbr(struct uhci_hcd *uhci, struct urb *urb)
 {
+	unsigned long flags;
 	struct urb_priv *urbp = (struct urb_priv *)urb->hcpriv;
 
+	spin_lock_irqsave(&uhci->frame_list_lock, flags);
+
 	if ((!(urb->transfer_flags & URB_NO_FSBR)) && urbp->fsbr) {
 		urbp->fsbr = 0;
 		if (!--uhci->fsbr)
 			uhci->fsbrtimeout = jiffies + FSBR_DELAY;
 	}
+
+	spin_unlock_irqrestore(&uhci->frame_list_lock, flags);
 }
 
 /*
@@ -760,16 +840,13 @@
 		urb->setup_dma);
 
 	/*
-	 * If direction is "send", change the packet ID from SETUP (0x2D)
-	 * to OUT (0xE1).  Else change it from SETUP to IN (0x69) and
-	 * set Short Packet Detect (SPD) for all data packets.
+	 * If direction is "send", change the frame from SETUP (0x2D)
+	 * to OUT (0xE1). Else change it from SETUP to IN (0x69).
 	 */
-	if (usb_pipeout(urb->pipe))
-		destination ^= (USB_PID_SETUP ^ USB_PID_OUT);
-	else {
-		destination ^= (USB_PID_SETUP ^ USB_PID_IN);
+	destination ^= (USB_PID_SETUP ^ usb_packetid(urb->pipe));
+
+	if (!(urb->transfer_flags & URB_SHORT_NOT_OK))
 		status |= TD_CTRL_SPD;
-	}
 
 	/*
 	 * Build the DATA TD's
@@ -833,7 +910,7 @@
 	if (urb->dev->speed == USB_SPEED_LOW)
 		skelqh = uhci->skel_ls_control_qh;
 	else {
-		skelqh = uhci->skel_fs_control_qh;
+		skelqh = uhci->skel_hs_control_qh;
 		uhci_inc_fsbr(uhci, urb);
 	}
 
@@ -846,23 +923,50 @@
 }
 
 /*
- * If control-IN transfer was short, the status packet wasn't sent.
- * This routine changes the element pointer in the QH to point at the
- * status TD.  It's safe to do this even while the QH is live, because
- * the hardware only updates the element pointer following a successful
- * transfer.  The inactive TD for the short packet won't cause an update,
- * so the pointer won't get overwritten.  The next time the controller
- * sees this QH, it will send the status packet.
+ * If control was short, then end status packet wasn't sent, so this
+ * reorganize s so it's sent to finish the transfer.  The original QH is
+ * removed from the skel and discarded; all TDs except the last (status)
+ * are deleted; the last (status) TD is put on a new QH which is reinserted
+ * into the skel.  Since the last TD and urb_priv are reused, the TD->link
+ * and urb_priv maintain any queued QHs.
  */
 static int usb_control_retrigger_status(struct uhci_hcd *uhci, struct urb *urb)
 {
+	struct list_head *tmp, *head;
 	struct urb_priv *urbp = (struct urb_priv *)urb->hcpriv;
-	struct uhci_td *td;
 
 	urbp->short_control_packet = 1;
 
-	td = list_entry(urbp->td_list.prev, struct uhci_td, list);
-	urbp->qh->element = cpu_to_le32(td->dma_handle);
+	/* Create a new QH to avoid pointer overwriting problems */
+	uhci_remove_qh(uhci, urbp->qh);
+
+	/* Delete all of the TD's except for the status TD at the end */
+	head = &urbp->td_list;
+	tmp = head->next;
+	while (tmp != head && tmp->next != head) {
+		struct uhci_td *td = list_entry(tmp, struct uhci_td, list);
+
+		tmp = tmp->next;
+
+		uhci_remove_td_from_urb(td);
+		uhci_remove_td(uhci, td);
+		uhci_free_td(uhci, td);
+	}
+
+	urbp->qh = uhci_alloc_qh(uhci, urb->dev);
+	if (!urbp->qh)
+		return -ENOMEM;
+
+	urbp->qh->urbp = urbp;
+
+	/* One TD, who cares about Breadth first? */
+	uhci_insert_tds_in_qh(urbp->qh, urb, UHCI_PTR_DEPTH);
+
+	/* Low-speed transfers get a different queue */
+	if (urb->dev->speed == USB_SPEED_LOW)
+		uhci_insert_qh(uhci, uhci->skel_ls_control_qh, urb);
+	else
+		uhci_insert_qh(uhci, uhci->skel_hs_control_qh, urb);
 
 	return -EINPROGRESS;
 }
@@ -997,20 +1101,17 @@
 	status = uhci_maxerr(3) | TD_CTRL_ACTIVE;
 	if (urb->dev->speed == USB_SPEED_LOW)
 		status |= TD_CTRL_LS;
-	if (usb_pipein(urb->pipe))
+	if (!(urb->transfer_flags & URB_SHORT_NOT_OK))
 		status |= TD_CTRL_SPD;
 
 	/*
 	 * Build the DATA TD's
 	 */
 	do {	/* Allow zero length packets */
-		int pktsze = maxsze;
+		int pktsze = len;
 
-		if (pktsze >= len) {
-			pktsze = len;
-			if (!(urb->transfer_flags & URB_SHORT_NOT_OK))
-				status &= ~TD_CTRL_SPD;
-		}
+		if (pktsze > maxsze)
+			pktsze = maxsze;
 
 		td = uhci_alloc_td(uhci, urb->dev);
 		if (!td)
@@ -1052,12 +1153,7 @@
 			usb_pipeout(urb->pipe));
 	}
 
-	/* Set the interrupt-on-completion flag on the last packet.
-	 * A more-or-less typical 4 KB URB (= size of one memory page)
-	 * will require about 3 ms to transfer; that's a little on the
-	 * fast side but not enough to justify delaying an interrupt
-	 * more than 2 or 3 URBs, so we will ignore the URB_NO_INTERRUPT
-	 * flag setting. */
+	/* Set the flag on the last packet */
 	td->status |= cpu_to_le32(TD_CTRL_IOC);
 
 	qh = uhci_alloc_qh(uhci, urb->dev);
@@ -1120,6 +1216,10 @@
 
 td_error:
 	ret = uhci_map_status(status, uhci_packetout(td_token(td)));
+	if (ret == -EPIPE)
+		/* endpoint has stalled - mark it halted */
+		usb_endpoint_halt(urb->dev, uhci_endpoint(td_token(td)),
+	    			uhci_packetout(td_token(td)));
 
 err:
 	/* 
@@ -1309,6 +1409,9 @@
 	return ret;
 }
 
+/*
+ * MUST be called with uhci->urb_list_lock acquired
+ */
 static struct urb *uhci_find_urb_ep(struct uhci_hcd *uhci, struct urb *urb)
 {
 	struct list_head *tmp, *head;
@@ -1340,16 +1443,15 @@
 
 static int uhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, int mem_flags)
 {
-	int ret;
+	int ret = -EINVAL;
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long flags;
 	struct urb *eurb;
 	int bustime;
 
-	spin_lock_irqsave(&uhci->schedule_lock, flags);
+	spin_lock_irqsave(&uhci->urb_list_lock, flags);
 
-	ret = urb->status;
-	if (ret != -EINPROGRESS)		/* URB already unlinked! */
+	if (urb->status != -EINPROGRESS)	/* URB already unlinked! */
 		goto out;
 
 	eurb = uhci_find_urb_ep(uhci, urb);
@@ -1404,12 +1506,14 @@
 		ret = 0;
 
 out:
-	spin_unlock_irqrestore(&uhci->schedule_lock, flags);
+	spin_unlock_irqrestore(&uhci->urb_list_lock, flags);
 	return ret;
 }
 
 /*
  * Return the result of a transfer
+ *
+ * MUST be called with urb_list_lock acquired
  */
 static void uhci_transfer_result(struct uhci_hcd *uhci, struct urb *urb)
 {
@@ -1445,6 +1549,7 @@
 	case PIPE_BULK:
 	case PIPE_ISOCHRONOUS:
 		/* Release bandwidth for Interrupt or Isoc. transfers */
+		/* Spinlock needed ? */
 		if (urb->bandwidth)
 			usb_release_bandwidth(urb->dev, urb, 1);
 		uhci_unlink_generic(uhci, urb);
@@ -1452,12 +1557,15 @@
 	case PIPE_INTERRUPT:
 		/* Release bandwidth for Interrupt or Isoc. transfers */
 		/* Make sure we don't release if we have a queued URB */
+		spin_lock(&uhci->frame_list_lock);
+		/* Spinlock needed ? */
 		if (list_empty(&urbp->queue_list) && urb->bandwidth)
 			usb_release_bandwidth(urb->dev, urb, 0);
 		else
 			/* bandwidth was passed on to queued URB, */
 			/* so don't let usb_unlink_urb() release it */
 			urb->bandwidth = 0;
+		spin_unlock(&uhci->frame_list_lock);
 		uhci_unlink_generic(uhci, urb);
 		break;
 	default:
@@ -1473,6 +1581,9 @@
 	spin_unlock(&urb->lock);
 }
 
+/*
+ * MUST be called with urb->lock acquired
+ */
 static void uhci_unlink_generic(struct uhci_hcd *uhci, struct urb *urb)
 {
 	struct list_head *head, *tmp;
@@ -1527,9 +1638,8 @@
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long flags;
 	struct urb_priv *urbp;
-	unsigned int age;
 
-	spin_lock_irqsave(&uhci->schedule_lock, flags);
+	spin_lock_irqsave(&uhci->urb_list_lock, flags);
 	urbp = urb->hcpriv;
 	if (!urbp)			/* URB was never linked! */
 		goto done;
@@ -1537,19 +1647,16 @@
 
 	uhci_unlink_generic(uhci, urb);
 
-	age = uhci_get_current_frame_number(uhci);
-	if (age != uhci->urb_remove_age) {
-		uhci_remove_pending_urbps(uhci);
-		uhci->urb_remove_age = age;
-	}
+	spin_lock(&uhci->urb_remove_list_lock);
 
 	/* If we're the first, set the next interrupt bit */
 	if (list_empty(&uhci->urb_remove_list))
 		uhci_set_next_interrupt(uhci);
 	list_add_tail(&urbp->urb_list, &uhci->urb_remove_list);
 
+	spin_unlock(&uhci->urb_remove_list_lock);
 done:
-	spin_unlock_irqrestore(&uhci->schedule_lock, flags);
+	spin_unlock_irqrestore(&uhci->urb_list_lock, flags);
 	return 0;
 }
 
@@ -1608,18 +1715,10 @@
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	struct list_head list, *tmp, *head;
 	unsigned long flags;
-	int called_uhci_finish_completion = 0;
 
 	INIT_LIST_HEAD(&list);
 
-	spin_lock_irqsave(&uhci->schedule_lock, flags);
-	if (!list_empty(&uhci->urb_remove_list) &&
-	    uhci_get_current_frame_number(uhci) != uhci->urb_remove_age) {
-		uhci_remove_pending_urbps(uhci);
-		uhci_finish_completion(hcd, NULL);
-		called_uhci_finish_completion = 1;
-	}
-
+	spin_lock_irqsave(&uhci->urb_list_lock, flags);
 	head = &uhci->urb_list;
 	tmp = head->next;
 	while (tmp != head) {
@@ -1634,13 +1733,13 @@
 		if (up->fsbr && !up->fsbr_timeout && time_after_eq(jiffies, up->fsbrtime + IDLE_TIMEOUT))
 			uhci_fsbr_timeout(uhci, u);
 
+		/* Check if the URB timed out */
+		if (u->timeout && time_after_eq(jiffies, up->inserttime + u->timeout))
+			list_move_tail(&up->urb_list, &list);
+
 		spin_unlock(&u->lock);
 	}
-	spin_unlock_irqrestore(&uhci->schedule_lock, flags);
-
-	/* Wake up anyone waiting for an URB to complete */
-	if (called_uhci_finish_completion)
-		wake_up_all(&uhci->waitqh);
+	spin_unlock_irqrestore(&uhci->urb_list_lock, flags);
 
 	head = &list;
 	tmp = head->next;
@@ -1672,7 +1771,7 @@
 	init_timer(&uhci->stall_timer);
 	uhci->stall_timer.function = stall_callback;
 	uhci->stall_timer.data = (unsigned long)hcd;
-	uhci->stall_timer.expires = jiffies + msecs_to_jiffies(100);
+	uhci->stall_timer.expires = jiffies + (HZ / 10);
 	add_timer(&uhci->stall_timer);
 
 	return 0;
@@ -1682,6 +1781,7 @@
 {
 	struct list_head *tmp, *head;
 
+	spin_lock(&uhci->qh_remove_list_lock);
 	head = &uhci->qh_remove_list;
 	tmp = head->next;
 	while (tmp != head) {
@@ -1693,12 +1793,14 @@
 
 		uhci_free_qh(uhci, qh);
 	}
+	spin_unlock(&uhci->qh_remove_list_lock);
 }
 
 static void uhci_free_pending_tds(struct uhci_hcd *uhci)
 {
 	struct list_head *tmp, *head;
 
+	spin_lock(&uhci->td_remove_list_lock);
 	head = &uhci->td_remove_list;
 	tmp = head->next;
 	while (tmp != head) {
@@ -1710,17 +1812,18 @@
 
 		uhci_free_td(uhci, td);
 	}
+	spin_unlock(&uhci->td_remove_list_lock);
 }
 
 static void uhci_finish_urb(struct usb_hcd *hcd, struct urb *urb, struct pt_regs *regs)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
+	spin_lock(&urb->lock);
 	uhci_destroy_urb_priv(uhci, urb);
+	spin_unlock(&urb->lock);
 
-	spin_unlock(&uhci->schedule_lock);
 	usb_hcd_giveback_urb(hcd, urb, regs);
-	spin_lock(&uhci->schedule_lock);
 }
 
 static void uhci_finish_completion(struct usb_hcd *hcd, struct pt_regs *regs)
@@ -1728,6 +1831,7 @@
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	struct list_head *tmp, *head;
 
+	spin_lock(&uhci->complete_list_lock);
 	head = &uhci->complete_list;
 	tmp = head->next;
 	while (tmp != head) {
@@ -1735,27 +1839,34 @@
 		struct urb *urb = urbp->urb;
 
 		list_del_init(&urbp->urb_list);
+		spin_unlock(&uhci->complete_list_lock);
+
 		uhci_finish_urb(hcd, urb, regs);
 
+		spin_lock(&uhci->complete_list_lock);
 		head = &uhci->complete_list;
 		tmp = head->next;
 	}
+	spin_unlock(&uhci->complete_list_lock);
 }
 
 static void uhci_remove_pending_urbps(struct uhci_hcd *uhci)
 {
+	spin_lock(&uhci->urb_remove_list_lock);
+	spin_lock(&uhci->complete_list_lock);
 
 	/* Splice the urb_remove_list onto the end of the complete_list */
 	list_splice_init(&uhci->urb_remove_list, uhci->complete_list.prev);
+	spin_unlock(&uhci->complete_list_lock);
+	spin_unlock(&uhci->urb_remove_list_lock);
 }
 
 static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned long io_addr = uhci->io_addr;
+	unsigned int io_addr = uhci->io_addr;
 	unsigned short status;
 	struct list_head *tmp, *head;
-	unsigned int age;
 
 	/*
 	 * Read the interrupt status, and write it back to clear the
@@ -1784,24 +1895,16 @@
 	if (status & USBSTS_RD)
 		uhci->resume_detect = 1;
 
-	spin_lock(&uhci->schedule_lock);
+	uhci_free_pending_qhs(uhci);
 
-	age = uhci_get_current_frame_number(uhci);
-	if (age != uhci->qh_remove_age)
-		uhci_free_pending_qhs(uhci);
-	if (age != uhci->td_remove_age)
-		uhci_free_pending_tds(uhci);
-	if (age != uhci->urb_remove_age)
-		uhci_remove_pending_urbps(uhci);
-
-	if (list_empty(&uhci->urb_remove_list) &&
-	    list_empty(&uhci->td_remove_list) &&
-	    list_empty(&uhci->qh_remove_list))
-		uhci_clear_next_interrupt(uhci);
-	else
-		uhci_set_next_interrupt(uhci);
+	uhci_free_pending_tds(uhci);
+
+	uhci_remove_pending_urbps(uhci);
+
+	uhci_clear_next_interrupt(uhci);
 
 	/* Walk the list of pending URB's to see which ones completed */
+	spin_lock(&uhci->urb_list_lock);
 	head = &uhci->urb_list;
 	tmp = head->next;
 	while (tmp != head) {
@@ -1813,40 +1916,32 @@
 		/* Checks the status and does all of the magic necessary */
 		uhci_transfer_result(uhci, urb);
 	}
-	uhci_finish_completion(hcd, regs);
-
-	spin_unlock(&uhci->schedule_lock);
-
-	/* Wake up anyone waiting for an URB to complete */
-	wake_up_all(&uhci->waitqh);
+	spin_unlock(&uhci->urb_list_lock);
 
+	uhci_finish_completion(hcd, regs);
 	return IRQ_HANDLED;
 }
 
 static void reset_hc(struct uhci_hcd *uhci)
 {
-	unsigned long io_addr = uhci->io_addr;
-
-	/* Turn off PIRQ, SMI, and all interrupts.  This also turns off
-	 * the BIOS's USB Legacy Support.
-	 */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
-	outw(0, uhci->io_addr + USBINTR);
+	unsigned int io_addr = uhci->io_addr;
 
 	/* Global reset for 50ms */
 	uhci->state = UHCI_RESET;
 	outw(USBCMD_GRESET, io_addr + USBCMD);
-	msleep(50);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout((HZ*50+999) / 1000);
 	outw(0, io_addr + USBCMD);
 
 	/* Another 10ms delay */
-	msleep(10);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout((HZ*10+999) / 1000);
 	uhci->resume_detect = 0;
 }
 
 static void suspend_hc(struct uhci_hcd *uhci)
 {
-	unsigned long io_addr = uhci->io_addr;
+	unsigned int io_addr = uhci->io_addr;
 
 	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
 	uhci->state = UHCI_SUSPENDED;
@@ -1856,7 +1951,7 @@
 
 static void wakeup_hc(struct uhci_hcd *uhci)
 {
-	unsigned long io_addr = uhci->io_addr;
+	unsigned int io_addr = uhci->io_addr;
 
 	switch (uhci->state) {
 		case UHCI_SUSPENDED:		/* Start the resume */
@@ -1865,7 +1960,7 @@
 			/* Global resume for >= 20ms */
 			outw(USBCMD_FGR | USBCMD_EGSM, io_addr + USBCMD);
 			uhci->state = UHCI_RESUMING_1;
-			uhci->state_end = jiffies + msecs_to_jiffies(20);
+			uhci->state_end = jiffies + (20*HZ+999) / 1000;
 			break;
 
 		case UHCI_RESUMING_1:		/* End global resume */
@@ -1896,7 +1991,7 @@
 
 static int ports_active(struct uhci_hcd *uhci)
 {
-	unsigned long io_addr = uhci->io_addr;
+	unsigned int io_addr = uhci->io_addr;
 	int connection = 0;
 	int i;
 
@@ -1908,7 +2003,7 @@
 
 static int suspend_allowed(struct uhci_hcd *uhci)
 {
-	unsigned long io_addr = uhci->io_addr;
+	unsigned int io_addr = uhci->io_addr;
 	int i;
 
 	if (to_pci_dev(uhci_dev(uhci))->vendor != PCI_VENDOR_ID_INTEL)
@@ -1973,7 +2068,7 @@
 
 static void start_hc(struct uhci_hcd *uhci)
 {
-	unsigned long io_addr = uhci->io_addr;
+	unsigned int io_addr = uhci->io_addr;
 	int timeout = 1000;
 
 	/*
@@ -1990,9 +2085,7 @@
 		}
 	}
 
-	/* Turn on PIRQ and all interrupts */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-			USBLEGSUP_DEFAULT);
+	/* Turn on all interrupts */
 	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
 		io_addr + USBINTR);
 
@@ -2056,10 +2149,15 @@
 
 	uhci->io_addr = (unsigned long) hcd->regs;
 
-	/* Kick BIOS off this hardware and reset, so we won't get
+	/* Turn off all interrupts */
+	outw(0, uhci->io_addr + USBINTR);
+
+	/* Maybe kick BIOS off this hardware.  Then reset, so we won't get
 	 * interrupts from any previous setup.
 	 */
 	reset_hc(uhci);
+	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
+			USBLEGSUP_DEFAULT);
 	return 0;
 }
 
@@ -2110,18 +2208,22 @@
 	uhci->fsbr = 0;
 	uhci->fsbrtimeout = 0;
 
-	spin_lock_init(&uhci->schedule_lock);
+	spin_lock_init(&uhci->qh_remove_list_lock);
 	INIT_LIST_HEAD(&uhci->qh_remove_list);
 
+	spin_lock_init(&uhci->td_remove_list_lock);
 	INIT_LIST_HEAD(&uhci->td_remove_list);
 
+	spin_lock_init(&uhci->urb_remove_list_lock);
 	INIT_LIST_HEAD(&uhci->urb_remove_list);
 
+	spin_lock_init(&uhci->urb_list_lock);
 	INIT_LIST_HEAD(&uhci->urb_list);
 
+	spin_lock_init(&uhci->complete_list_lock);
 	INIT_LIST_HEAD(&uhci->complete_list);
 
-	init_waitqueue_head(&uhci->waitqh);
+	spin_lock_init(&uhci->frame_list_lock);
 
 	uhci->fl = dma_alloc_coherent(uhci_dev(uhci), sizeof(*uhci->fl),
 			&dma_handle, 0);
@@ -2175,7 +2277,7 @@
 
 	uhci->rh_numports = port;
 
-	udev = usb_alloc_dev(NULL, &hcd->self, 0);
+	hcd->self.root_hub = udev = usb_alloc_dev(NULL, &hcd->self, 0);
 	if (!udev) {
 		dev_err(uhci_dev(uhci), "unable to allocate root hub\n");
 		goto err_alloc_root_hub;
@@ -2209,8 +2311,8 @@
 			cpu_to_le32(uhci->skel_int1_qh->dma_handle) | UHCI_PTR_QH;
 	uhci->skel_int1_qh->link = cpu_to_le32(uhci->skel_ls_control_qh->dma_handle) | UHCI_PTR_QH;
 
-	uhci->skel_ls_control_qh->link = cpu_to_le32(uhci->skel_fs_control_qh->dma_handle) | UHCI_PTR_QH;
-	uhci->skel_fs_control_qh->link = cpu_to_le32(uhci->skel_bulk_qh->dma_handle) | UHCI_PTR_QH;
+	uhci->skel_ls_control_qh->link = cpu_to_le32(uhci->skel_hs_control_qh->dma_handle) | UHCI_PTR_QH;
+	uhci->skel_hs_control_qh->link = cpu_to_le32(uhci->skel_bulk_qh->dma_handle) | UHCI_PTR_QH;
 	uhci->skel_bulk_qh->link = cpu_to_le32(uhci->skel_term_qh->dma_handle) | UHCI_PTR_QH;
 
 	/* This dummy TD is to work around a bug in Intel PIIX controllers */
@@ -2248,22 +2350,16 @@
 			irq = 7;
 
 		/* Only place we don't use the frame list routines */
-		uhci->fl->frame[i] = UHCI_PTR_QH |
-				cpu_to_le32(uhci->skelqh[irq]->dma_handle);
+		uhci->fl->frame[i] = cpu_to_le32(uhci->skelqh[irq]->dma_handle);
 	}
 
-	/*
-	 * Some architectures require a full mb() to enforce completion of
-	 * the memory writes above before the I/O transfers in start_hc().
-	 */
-	mb();
 	start_hc(uhci);
 
 	init_stall_timer(hcd);
 
 	udev->speed = USB_SPEED_FULL;
 
-	if (hcd_register_root(udev, &uhci->hcd) != 0) {
+	if (usb_register_root_hub(udev, uhci_dev(uhci)) != 0) {
 		dev_err(uhci_dev(uhci), "unable to start root hub\n");
 		retval = -ENOMEM;
 		goto err_start_root_hub;
@@ -2291,6 +2387,7 @@
 
 err_alloc_term_td:
 	usb_put_dev(udev);
+	hcd->self.root_hub = NULL;
 
 err_alloc_root_hub:
 	dma_pool_destroy(uhci->qh_pool);
@@ -2319,6 +2416,7 @@
 static void uhci_stop(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	unsigned long flags;
 
 	del_timer_sync(&uhci->stall_timer);
 
@@ -2326,21 +2424,16 @@
 	 * At this point, we're guaranteed that no new connects can be made
 	 * to this bus since there are no more parents
 	 */
-
-	reset_hc(uhci);
-
-	spin_lock_irq(&uhci->schedule_lock);
+	local_irq_save(flags);
 	uhci_free_pending_qhs(uhci);
 	uhci_free_pending_tds(uhci);
 	uhci_remove_pending_urbps(uhci);
-	uhci_finish_completion(hcd, NULL);
+
+	reset_hc(uhci);
 
 	uhci_free_pending_qhs(uhci);
 	uhci_free_pending_tds(uhci);
-	spin_unlock_irq(&uhci->schedule_lock);
-
-	/* Wake up anyone waiting for an URB to complete */
-	wake_up_all(&uhci->waitqh);
+	local_irq_restore(flags);
 	
 	release_uhci(uhci);
 }
@@ -2371,18 +2464,14 @@
 		/*
 		 * Some systems don't maintain the UHCI register values
 		 * during a PM suspend/resume cycle, so reinitialize
-		 * the Frame Number, Framelist Base Address, Interrupt
-		 * Enable, and Legacy Support registers.
+		 * the Frame Number, the Framelist Base Address, and the
+		 * Interrupt Enable registers.
 		 */
-		pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-				0);
 		outw(uhci->saved_framenumber, uhci->io_addr + USBFRNUM);
 		outl(uhci->fl->dma_handle, uhci->io_addr + USBFLBASEADD);
 		outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC |
 				USBINTR_SP, uhci->io_addr + USBINTR);
 		uhci->resume_detect = 1;
-		pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-				USBLEGSUP_DEFAULT);
 	} else {
 		reset_hc(uhci);
 		start_hc(uhci);
@@ -2410,46 +2499,6 @@
 	kfree(hcd_to_uhci(hcd));
 }
 
-/* Are there any URBs for a particular device/endpoint on a given list? */
-static int urbs_for_ep_list(struct list_head *head,
-		struct hcd_dev *hdev, int ep)
-{
-	struct urb_priv *urbp;
-
-	list_for_each_entry(urbp, head, urb_list) {
-		struct urb *urb = urbp->urb;
-
-		if (hdev == urb->dev->hcpriv && ep ==
-				(usb_pipeendpoint(urb->pipe) |
-				 usb_pipein(urb->pipe)))
-			return 1;
-	}
-	return 0;
-}
-
-/* Are there any URBs for a particular device/endpoint? */
-static int urbs_for_ep(struct uhci_hcd *uhci, struct hcd_dev *hdev, int ep)
-{
-	int rc;
-
-	spin_lock_irq(&uhci->schedule_lock);
-	rc = (urbs_for_ep_list(&uhci->urb_list, hdev, ep) ||
-			urbs_for_ep_list(&uhci->complete_list, hdev, ep) ||
-			urbs_for_ep_list(&uhci->urb_remove_list, hdev, ep));
-	spin_unlock_irq(&uhci->schedule_lock);
-	return rc;
-}
-
-/* Wait until all the URBs for a particular device/endpoint are gone */
-static void uhci_hcd_endpoint_disable(struct usb_hcd *hcd,
-		struct hcd_dev *hdev, int endpoint)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-
-	wait_event_interruptible(uhci->waitqh,
-			!urbs_for_ep(uhci, hdev, endpoint));
-}
-
 static int uhci_hcd_get_frame_number(struct usb_hcd *hcd)
 {
 	return uhci_get_current_frame_number(hcd_to_uhci(hcd));
@@ -2479,7 +2528,6 @@
 	.urb_enqueue =		uhci_urb_enqueue,
 	.urb_dequeue =		uhci_urb_dequeue,
 
-	.endpoint_disable =	uhci_hcd_endpoint_disable,
 	.get_frame_number =	uhci_hcd_get_frame_number,
 
 	.hub_status_data =	uhci_hub_status_data,
@@ -2524,7 +2572,7 @@
 	}
 
 #ifdef CONFIG_PROC_FS
-	uhci_proc_root = create_proc_entry("driver/uhci", S_IFDIR, NULL);
+	uhci_proc_root = create_proc_entry("driver/uhci", S_IFDIR, 0);
 	if (!uhci_proc_root)
 		goto proc_failed;
 #endif
@@ -2547,7 +2595,7 @@
 up_failed:
 
 #ifdef CONFIG_PROC_FS
-	remove_proc_entry("driver/uhci", NULL);
+	remove_proc_entry("driver/uhci", 0);
 
 proc_failed:
 #endif
@@ -2567,7 +2615,7 @@
 		warn("not all urb_priv's were freed!");
 
 #ifdef CONFIG_PROC_FS
-	remove_proc_entry("driver/uhci", NULL);
+	remove_proc_entry("driver/uhci", 0);
 #endif
 
 	if (errbuf)
diff -Naur linuxppc-2.6.9/drivers/usb/host/uhci-hcd.h linuxppc-2.6.9-dream/drivers/usb/host/uhci-hcd.h
--- linuxppc-2.6.9/drivers/usb/host/uhci-hcd.h	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/uhci-hcd.h	2005-09-19 21:40:05.000000000 +0200
@@ -80,7 +80,7 @@
 #define CAN_SCHEDULE_FRAMES	1000	/* how far future frames can be scheduled */
 
 struct uhci_frame_list {
-	__le32 frame[UHCI_NUMFRAMES];
+	__u32 frame[UHCI_NUMFRAMES];
 
 	void *frame_cpu[UHCI_NUMFRAMES];
 
@@ -105,8 +105,8 @@
  */
 struct uhci_qh {
 	/* Hardware fields */
-	__le32 link;			/* Next queue */
-	__le32 element;			/* Queue element pointer */
+	__u32 link;			/* Next queue */
+	__u32 element;			/* Queue element pointer */
 
 	/* Software fields */
 	dma_addr_t dma_handle;
@@ -185,10 +185,10 @@
  */
 struct uhci_td {
 	/* Hardware fields */
-	__le32 link;
-	__le32 status;
-	__le32 token;
-	__le32 buffer;
+	__u32 link;
+	__u32 status;
+	__u32 token;
+	__u32 buffer;
 
 	/* Software fields */
 	dma_addr_t dma_handle;
@@ -254,7 +254,7 @@
 #define skel_int2_qh		skelqh[6]
 #define skel_int1_qh		skelqh[7]
 #define skel_ls_control_qh	skelqh[8]
-#define skel_fs_control_qh	skelqh[9]
+#define skel_hs_control_qh	skelqh[9]
 #define skel_bulk_qh		skelqh[10]
 #define skel_term_qh		skelqh[11]
 
@@ -342,8 +342,8 @@
 	struct uhci_td *term_td;	/* Terminating TD, see UHCI bug */
 	struct uhci_qh *skelqh[UHCI_NUM_SKELQH];	/* Skeleton QH's */
 
-	spinlock_t schedule_lock;
-	struct uhci_frame_list *fl;		/* P: uhci->schedule_lock */
+	spinlock_t frame_list_lock;
+	struct uhci_frame_list *fl;		/* P: uhci->frame_list_lock */
 	int fsbr;				/* Full-speed bandwidth reclamation */
 	unsigned long fsbrtimeout;		/* FSBR delay */
 
@@ -353,28 +353,28 @@
 	unsigned int saved_framenumber;		/* Save during PM suspend */
 
 	/* Main list of URB's currently controlled by this HC */
-	struct list_head urb_list;		/* P: uhci->schedule_lock */
+	spinlock_t urb_list_lock;
+	struct list_head urb_list;		/* P: uhci->urb_list_lock */
 
 	/* List of QH's that are done, but waiting to be unlinked (race) */
-	struct list_head qh_remove_list;	/* P: uhci->schedule_lock */
-	unsigned int qh_remove_age;		/* Age in frames */
+	spinlock_t qh_remove_list_lock;
+	struct list_head qh_remove_list;	/* P: uhci->qh_remove_list_lock */
 
 	/* List of TD's that are done, but waiting to be freed (race) */
-	struct list_head td_remove_list;	/* P: uhci->schedule_lock */
-	unsigned int td_remove_age;		/* Age in frames */
+	spinlock_t td_remove_list_lock;
+	struct list_head td_remove_list;	/* P: uhci->td_remove_list_lock */
 
 	/* List of asynchronously unlinked URB's */
-	struct list_head urb_remove_list;	/* P: uhci->schedule_lock */
-	unsigned int urb_remove_age;		/* Age in frames */
+	spinlock_t urb_remove_list_lock;
+	struct list_head urb_remove_list;	/* P: uhci->urb_remove_list_lock */
 
 	/* List of URB's awaiting completion callback */
-	struct list_head complete_list;		/* P: uhci->schedule_lock */
+	spinlock_t complete_list_lock;
+	struct list_head complete_list;		/* P: uhci->complete_list_lock */
 
 	int rh_numports;
 
 	struct timer_list stall_timer;
-
-	wait_queue_head_t waitqh;		/* endpoint_disable waiters */
 };
 
 struct urb_priv {
@@ -401,15 +401,26 @@
 /*
  * Locking in uhci.c
  *
- * Almost everything relating to the hardware schedule and processing
- * of URBs is protected by uhci->schedule_lock.  urb->status is protected
- * by urb->lock; that's the one exception.
+ * spinlocks are used extensively to protect the many lists and data
+ * structures we have. It's not that pretty, but it's necessary. We
+ * need to be done with all of the locks (except complete_list_lock) when
+ * we call urb->complete. I've tried to make it simple enough so I don't
+ * have to spend hours racking my brain trying to figure out if the
+ * locking is safe.
  *
- * To prevent deadlocks, never lock uhci->schedule_lock while holding
- * urb->lock.  The safe order of locking is:
+ * Here's the safe locking order to prevent deadlocks:
  *
- * #1 uhci->schedule_lock
+ * #1 uhci->urb_list_lock
  * #2 urb->lock
+ * #3 uhci->urb_remove_list_lock, uhci->frame_list_lock, 
+ *   uhci->qh_remove_list_lock
+ * #4 uhci->complete_list_lock
+ *
+ * If you're going to grab 2 or more locks at once, ALWAYS grab the lock
+ * at the lowest level FIRST and NEVER grab locks at the same level at the
+ * same time.
+ * 
+ * So, if you need uhci->urb_list_lock, grab it before you grab urb->lock
  */
 
 #endif
diff -Naur linuxppc-2.6.9/drivers/usb/host/uhci-hub.c linuxppc-2.6.9-dream/drivers/usb/host/uhci-hub.c
--- linuxppc-2.6.9/drivers/usb/host/uhci-hub.c	2004-10-18 23:53:12.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/host/uhci-hub.c	2005-09-19 21:40:05.000000000 +0200
@@ -36,7 +36,7 @@
 static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned long io_addr = uhci->io_addr;
+	unsigned int io_addr = uhci->io_addr;
 	int i;
 
 	*buf = 0;
@@ -69,7 +69,7 @@
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int status, retval = 0, len = 0;
-	unsigned long port_addr = uhci->io_addr + USBPORTSC1 + 2 * (wIndex-1);
+	unsigned int port_addr = uhci->io_addr + USBPORTSC1 + 2 * (wIndex-1);
 	__u16 wPortChange, wPortStatus;
 
 	switch (typeReq) {
@@ -82,7 +82,7 @@
 		*/
 
 	case GetHubStatus:
-		*(__le32 *)buf = cpu_to_le32(0);
+		*(__u32 *)buf = cpu_to_le32(0);
 		OK(4);		/* hub power */
 	case GetPortStatus:
 		if (!wIndex || wIndex > uhci->rh_numports)
@@ -126,8 +126,8 @@
 			dev_dbg(uhci_dev(uhci), "port %d portsc %04x\n",
 					wIndex, status);
 
-		*(__le16 *)buf = cpu_to_le16(wPortStatus);
-		*(__le16 *)(buf + 2) = cpu_to_le16(wPortChange);
+		*(__u16 *)buf = cpu_to_le16(wPortStatus);
+		*(__u16 *)(buf + 2) = cpu_to_le16(wPortChange);
 		OK(4);
 	case SetHubFeature:		/* We don't implement these */
 	case ClearHubFeature:
diff -Naur linuxppc-2.6.9/drivers/usb/image/hpusbscsi.c linuxppc-2.6.9-dream/drivers/usb/image/hpusbscsi.c
--- linuxppc-2.6.9/drivers/usb/image/hpusbscsi.c	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/image/hpusbscsi.c	2005-09-19 21:40:05.000000000 +0200
@@ -11,7 +11,7 @@
 #include <asm/atomic.h>
 #include <linux/blkdev.h>
 #include "../../scsi/scsi.h"
-#include <scsi/scsi_host.h>
+#include "../../scsi/hosts.h"
 
 #include "hpusbscsi.h"
 
diff -Naur linuxppc-2.6.9/drivers/usb/image/mdc800.c linuxppc-2.6.9-dream/drivers/usb/image/mdc800.c
--- linuxppc-2.6.9/drivers/usb/image/mdc800.c	2004-10-18 23:54:31.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/image/mdc800.c	2005-09-19 21:40:05.000000000 +0200
@@ -33,7 +33,7 @@
  * Fix: mdc800 used sleep_on and slept with io_lock held.
  * Converted sleep_on to waitqueues with schedule_timeout and made io_lock
  * a semaphore from a spinlock.
- * by Oliver Neukum <oliver@neukum.name>
+ * by Oliver Neukum <520047054719-0001@t-online.de>
  * (02/12/2001)
  * 
  * Identify version on module load.
@@ -41,7 +41,7 @@
  *
  * version 0.7.5
  * Fixed potential SMP races with Spinlocks.
- * Thanks to Oliver Neukum <oliver@neukum.name> who 
+ * Thanks to Oliver Neukum <oliver.neukum@lrz.uni-muenchen.de> who 
  * noticed the race conditions.
  * (30/10/2000)
  *
@@ -190,7 +190,7 @@
 
 
 /* The Variable used by the driver */
-static struct mdc800_data* mdc800;
+static struct mdc800_data* mdc800=0;
 
 
 /***************************************************************************
@@ -312,17 +312,14 @@
 static int mdc800_usb_waitForIRQ (int mode, int msec)
 {
         DECLARE_WAITQUEUE(wait, current);
-	long timeout;
 
 	mdc800->camera_request_ready=1+mode;
 
 	add_wait_queue(&mdc800->irq_wait, &wait);
 	set_current_state(TASK_INTERRUPTIBLE);
-	timeout = msec*HZ/1000;
-	while (!mdc800->irq_woken && timeout)
+	if (!mdc800->irq_woken)
 	{
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		timeout = schedule_timeout (timeout);
+		schedule_timeout (msec*HZ/1000);
 	}
         remove_wait_queue(&mdc800->irq_wait, &wait);
 	set_current_state(TASK_RUNNING);
@@ -547,7 +544,7 @@
 		usb_unlink_urb (mdc800->write_urb);
 		usb_unlink_urb (mdc800->download_urb);
 
-		mdc800->dev = NULL;
+		mdc800->dev=0;
 		usb_set_intfdata(intf, NULL);
 	}
 	info ("Mustek MDC800 disconnected from USB.");
@@ -667,11 +664,10 @@
 /*
  * The Device read callback Function
  */
-static ssize_t mdc800_device_read (struct file *file, char __user *buf, size_t len, loff_t *pos)
+static ssize_t mdc800_device_read (struct file *file, char *buf, size_t len, loff_t *pos)
 {
 	size_t left=len, sts=len; /* single transfer size */
-	char __user *ptr = buf;
-	long timeout;
+	char* ptr=buf;
 	DECLARE_WAITQUEUE(wait, current);
 
 	down (&mdc800->io_lock);
@@ -719,11 +715,10 @@
 					return len-left;
 				}
 				add_wait_queue(&mdc800->download_wait, &wait);
-				timeout = TO_DOWNLOAD_GET_READY*HZ/1000;
-				while (!mdc800->downloaded && timeout)
+				set_current_state(TASK_INTERRUPTIBLE);
+				if (!mdc800->downloaded)
 				{
-					set_current_state(TASK_UNINTERRUPTIBLE);
-					timeout = schedule_timeout (timeout);
+					schedule_timeout (TO_DOWNLOAD_GET_READY*HZ/1000);
 				}
 				set_current_state(TASK_RUNNING);
 				remove_wait_queue(&mdc800->download_wait, &wait);
@@ -767,7 +762,7 @@
  * After this the driver initiates the request for the answer or
  * just waits until the camera becomes ready.
  */
-static ssize_t mdc800_device_write (struct file *file, const char __user *buf, size_t len, loff_t *pos)
+static ssize_t mdc800_device_write (struct file *file, const char *buf, size_t len, loff_t *pos)
 {
 	size_t i=0;
 	DECLARE_WAITQUEUE(wait, current);
@@ -824,7 +819,6 @@
 		if (mdc800->in_count == 8)
 		{
 			int answersize;
-			long timeout;
 
 			if (mdc800_usb_waitForIRQ (0,TO_GET_READY))
 			{
@@ -845,11 +839,10 @@
 				return -EIO;
 			}
 			add_wait_queue(&mdc800->write_wait, &wait);
-			timeout = TO_WRITE_GET_READY*HZ/1000;
-			while (!mdc800->written && timeout)
+			set_current_state(TASK_INTERRUPTIBLE);
+			if (!mdc800->written)
 			{
-				set_current_state(TASK_UNINTERRUPTIBLE);
-				timeout = schedule_timeout (timeout);
+				schedule_timeout (TO_WRITE_GET_READY*HZ/1000);
 			}
                         set_current_state(TASK_RUNNING);
 			remove_wait_queue(&mdc800->write_wait, &wait);
@@ -971,7 +964,9 @@
 	Init and Cleanup this driver (Main Functions)
 *************************************************************************/
 
-#define try(A)           if (!(A)) goto cleanup_on_fail;
+#define try(A)           if ((A) == 0) goto cleanup_on_fail;
+#define try_free_mem(A)  if (A != 0) { kfree (A); A=0; }
+#define try_free_urb(A)  if (A != 0) { usb_free_urb (A); A=0; }
 
 static int __init usb_mdc800_init (void)
 {
@@ -980,7 +975,7 @@
 	try (mdc800=kmalloc (sizeof (struct mdc800_data), GFP_KERNEL));
 
 	memset(mdc800, 0, sizeof(struct mdc800_data));
-	mdc800->dev = NULL;
+	mdc800->dev=0;
 	mdc800->open=0;
 	mdc800->state=NOT_CONNECTED;
 	init_MUTEX (&mdc800->io_lock);
@@ -1018,17 +1013,17 @@
 	{
 		err ("can't alloc memory!");
 
-		kfree(mdc800->download_urb_buffer);
-		kfree(mdc800->write_urb_buffer);
-		kfree(mdc800->irq_urb_buffer);
-
-		usb_free_urb(mdc800->write_urb);
-		usb_free_urb(mdc800->download_urb);
-		usb_free_urb(mdc800->irq_urb);
+		try_free_mem (mdc800->download_urb_buffer);
+		try_free_mem (mdc800->write_urb_buffer);
+		try_free_mem (mdc800->irq_urb_buffer);
+
+		try_free_urb (mdc800->write_urb);
+		try_free_urb (mdc800->download_urb);
+		try_free_urb (mdc800->irq_urb);
 
 		kfree (mdc800);
 	}
-	mdc800 = NULL;
+	mdc800=0;
 	return retval;
 }
 
@@ -1046,7 +1041,7 @@
 	kfree (mdc800->download_urb_buffer);
 
 	kfree (mdc800);
-	mdc800 = NULL;
+	mdc800=0;
 }
 
 module_init (usb_mdc800_init);
diff -Naur linuxppc-2.6.9/drivers/usb/image/microtek.c linuxppc-2.6.9-dream/drivers/usb/image/microtek.c
--- linuxppc-2.6.9/drivers/usb/image/microtek.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/image/microtek.c	2005-09-19 21:40:05.000000000 +0200
@@ -136,7 +136,7 @@
 #include <asm/atomic.h>
 #include <linux/blkdev.h>
 #include "../../scsi/scsi.h"
-#include <scsi/scsi_host.h>
+#include "../../scsi/hosts.h"
 
 #include "microtek.h"
 
@@ -214,8 +214,8 @@
 #ifdef MTS_DO_DEBUG
 
 static inline void mts_debug_dump(struct mts_desc* desc) {
-	MTS_DEBUG("desc at 0x%x: toggle = %02x%02x\n",
-		  (int)desc,
+	MTS_DEBUG("desc at 0x%x: halted = %02x%02x, toggle = %02x%02x\n",
+		  (int)desc,(int)desc->usb_dev->halted[1],(int)desc->usb_dev->halted[0],
 		  (int)desc->usb_dev->toggle[1],(int)desc->usb_dev->toggle[0]
 		);
 	MTS_DEBUG("ep_out=%x ep_response=%x ep_image=%x\n",
@@ -534,7 +534,7 @@
 
 	if (!srb->use_sg) {
 		if ( !srb->bufflen ){
-			desc->context.data = NULL;
+			desc->context.data = 0;
 			desc->context.data_length = 0;
 			return;
 		} else {
diff -Naur linuxppc-2.6.9/drivers/usb/input/aiptek.c linuxppc-2.6.9-dream/drivers/usb/input/aiptek.c
--- linuxppc-2.6.9/drivers/usb/input/aiptek.c	2004-10-18 23:54:54.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/aiptek.c	2005-09-19 21:40:05.000000000 +0200
@@ -1,9 +1,7 @@
 /*
- *  Native support for the Aiptek HyperPen USB Tablets
- *  (4000U/5000U/6000U/8000U/12000U)
- *  
- *  Copyright (c) 2001      Chris Atenasio   <chris@crud.net>
- *  Copyright (c) 2002-2004 Bryan W. Headley <bwheadley@earthlink.net>
+ *  Native support for the Aiptek 8000U
+ *
+ *  Copyright (c) 2001 Chris Atenasio		<chris@crud.net>
  *
  *  based on wacom.c by
  *     Vojtech Pavlik      <vojtech@suse.cz>
@@ -13,48 +11,17 @@
  *     James E. Blair      <corvus@gnu.org>
  *     Daniel Egger        <egger@suse.de>
  *
+ *
  *  Many thanks to Oliver Kuechemann for his support.
  *
  *  ChangeLog:
  *      v0.1 - Initial release
- *      v0.2 - Hack to get around fake event 28's. (Bryan W. Headley)
+ *      v0.2 - Hack to get around fake event 28's.
  *      v0.3 - Make URB dynamic (Bryan W. Headley, Jun-8-2002)
- *             Released to Linux 2.4.19 and 2.5.x
- *      v0.4 - Rewrote substantial portions of the code to deal with
- *             corrected control sequences, timing, dynamic configuration,
- *             support of 6000U - 12000U, procfs, and macro key support
- *             (Jan-1-2003 - Feb-5-2003, Bryan W. Headley)
- *      v1.0 - Added support for diagnostic messages, count of messages
- *             received from URB - Mar-8-2003, Bryan W. Headley
- *      v1.1 - added support for tablet resolution, changed DV and proximity
- *             some corrections - Jun-22-2003, martin schneebacher
- *           - Added support for the sysfs interface, deprecating the
- *             procfs interface for 2.5.x kernel. Also added support for
- *             Wheel command. Bryan W. Headley July-15-2003.
- *      v1.2 - Reworked jitter timer as a kernel thread. 
- *             Bryan W. Headley November-28-2003/Jan-10-2004.
- *      v1.3 - Repaired issue of kernel thread going nuts on single-processor
- *             machines, introduced programmableDelay as a command line
- *             parameter. Feb 7 2004, Bryan W. Headley.
- *      v1.4 - Re-wire jitter so it does not require a thread. Courtesy of
- *             Rene van Paassen. Added reporting of physical pointer device
- *             (e.g., stylus, mouse in reports 2, 3, 4, 5. We don't know
- *             for reports 1, 6.)
- *             what physical device reports for reports 1, 6.) Also enabled
- *             MOUSE and LENS tool button modes. Renamed "rubber" to "eraser".
- *             Feb 20, 2004, Bryan W. Headley.
- *      v1.5 - Added previousJitterable, so we don't do jitter delay when the
- *             user is holding a button down for periods of time.
- *
- * NOTE:
- *      This kernel driver is augmented by the "Aiptek" XFree86 input
- *      driver for your X server, as well as the Gaiptek GUI Front-end
- *      "Tablet Manager". 
- *      These three products are highly interactive with one another, 
- *      so therefore it's easier to document them all as one subsystem.
- *      Please visit the project's "home page", located at, 
- *      http://aiptektablet.sourceforge.net.
- *
+ *             (kernel 2.5.x variant, June-14-2002)
+ */
+
+/*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -70,2229 +37,373 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
-#include <linux/jiffies.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/input.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/usb.h>
-#include <linux/sched.h>
-#include <asm/uaccess.h>
 #include <asm/unaligned.h>
-
+#include <asm/byteorder.h>
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v1.5 (May-15-2004)"
-#define DRIVER_AUTHOR  "Bryan W. Headley/Chris Atenasio"
-#define DRIVER_DESC    "Aiptek HyperPen USB Tablet Driver (Linux 2.6.x)"
+#define DRIVER_VERSION "v0.3"
+#define DRIVER_AUTHOR "Chris Atenasio <chris@crud.net>"
+#define DRIVER_DESC "USB Aiptek 6000U/8000U tablet driver (Linux 2.5.x)"
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
 
 /*
  * Aiptek status packet:
  *
- * (returned as Report 1 - relative coordinates from mouse and stylus)
- *
- *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
- * byte0   0     0     0     0     0     0     0     1
- * byte1   0     0     0     0     0    BS2   BS    Tip
- * byte2  X7    X6    X5    X4    X3    X2    X1    X0
- * byte3  Y7    Y6    Y5    Y4    Y3    Y2    Y1    Y0
- *
- * (returned as Report 2 - absolute coordinates from the stylus)
- *
- *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
- * byte0   0     0     0     0     0     0     1     0
- * byte1  X7    X6    X5    X4    X3    X2    X1    X0
- * byte2  X15   X14   X13   X12   X11   X10   X9    X8
- * byte3  Y7    Y6    Y5    Y4    Y3    Y2    Y1    Y0
- * byte4  Y15   Y14   Y13   Y12   Y11   Y10   Y9    Y8
- * byte5   *     *     *    BS2   BS1   Tip   IR    DV
- * byte6  P7    P6    P5    P4    P3    P2    P1    P0
- * byte7  P15   P14   P13   P12   P11   P10   P9    P8
- *
- * (returned as Report 3 - absolute coordinates from the mouse)
- *
  *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
  * byte0   0     0     0     0     0     0     1     0
  * byte1  X7    X6    X5    X4    X3    X2    X1    X0
  * byte2  X15   X14   X13   X12   X11   X10   X9    X8
  * byte3  Y7    Y6    Y5    Y4    Y3    Y2    Y1    Y0
  * byte4  Y15   Y14   Y13   Y12   Y11   Y10   Y9    Y8
- * byte5   *     *     *    BS2   BS1   Tip   IR    DV
+ * byte5   *     *     *    BS2   BS1   Tip   DV    IR
  * byte6  P7    P6    P5    P4    P3    P2    P1    P0
  * byte7  P15   P14   P13   P12   P11   P10   P9    P8
  *
- * (returned as Report 4 - macrokeys from the stylus)
- *
- *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
- * byte0   0     0     0     0     0     1     0     0
- * byte1   0     0     0    BS2   BS    Tip   IR    DV
- * byte2   0     0     0     0     0     0     1     0
- * byte3   0     0     0    K4    K3    K2    K1    K0
- * byte4  P7    P6    P5    P4    P3    P2    P1    P0
- * byte5  P15   P14   P13   P12   P11   P10   P9    P8
- *
- * (returned as Report 5 - macrokeys from the mouse)
- *
- *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
- * byte0   0     0     0     0     0     1     0     0
- * byte1   0     0     0    BS2   BS    Tip   IR    DV
- * byte2   0     0     0     0     0     0     1     0
- * byte3   0     0     0    K4    K3    K2    K1    K0
- * byte4  P7    P6    P5    P4    P3    P2    P1    P0
- * byte5  P15   P14   P13   P12   P11   P10   P9    P8
- *
  * IR: In Range = Proximity on
  * DV = Data Valid
- * BS = Barrel Switch (as in, macro keys)
- * BS2 also referred to as Tablet Pick
  *
+ * 
  * Command Summary:
  *
- * Use report_type CONTROL (3)
- * Use report_id   2
- *
  * Command/Data    Description     Return Bytes    Return Value
  * 0x10/0x00       SwitchToMouse       0
  * 0x10/0x01       SwitchToTablet      0
- * 0x18/0x04       SetResolution       0 
- * 0x12/0xFF       AutoGainOn          0
+ * 0x18/0x04       Resolution500LPI    0
  * 0x17/0x00       FilterOn            0
+ * 0x12/0xFF       AutoGainOn          0
  * 0x01/0x00       GetXExtension       2           MaxX
  * 0x01/0x01       GetYExtension       2           MaxY
  * 0x02/0x00       GetModelCode        2           ModelCode = LOBYTE
  * 0x03/0x00       GetODMCode          2           ODMCode
  * 0x08/0x00       GetPressureLevels   2           =512
  * 0x04/0x00       GetFirmwareVersion  2           Firmware Version
- * 0x11/0x02       EnableMacroKeys     0
  *
- * To initialize the tablet:
  *
- * (1) Send Resolution500LPI (Command)
- * (2) Query for Model code (Option Report)
- * (3) Query for ODM code (Option Report)
- * (4) Query for firmware (Option Report)
- * (5) Query for GetXExtension (Option Report)
- * (6) Query for GetYExtension (Option Report)
- * (7) Query for GetPressureLevels (Option Report)
- * (8) SwitchToTablet for Absolute coordinates, or
- *     SwitchToMouse for Relative coordinates (Command)
- * (9) EnableMacroKeys (Command)
- * (10) FilterOn (Command)
- * (11) AutoGainOn (Command)
+ * To initialize the tablet:
  *
- * (Step 9 can be omitted, but you'll then have no function keys.)
+ * (1) Send command Resolution500LPI
+ * (2) Option Commands (GetXExtension, GetYExtension)
+ * (3) Send command SwitchToTablet
  */
 
-#define USB_VENDOR_ID_AIPTEK				0x08ca
-#define USB_REQ_GET_REPORT				0x01
-#define USB_REQ_SET_REPORT				0x09
-
-	/* PointerMode codes
-	 */
-#define AIPTEK_POINTER_ONLY_MOUSE_MODE			0
-#define AIPTEK_POINTER_ONLY_STYLUS_MODE			1
-#define AIPTEK_POINTER_EITHER_MODE			2
-
-#define AIPTEK_POINTER_ALLOW_MOUSE_MODE(a)		\
-	(a == AIPTEK_POINTER_ONLY_MOUSE_MODE ||		\
-	 a == AIPTEK_POINTER_EITHER_MODE)
-#define AIPTEK_POINTER_ALLOW_STYLUS_MODE(a)		\
-	(a == AIPTEK_POINTER_ONLY_STYLUS_MODE ||	\
-	 a == AIPTEK_POINTER_EITHER_MODE)
-
-	/* CoordinateMode code
-	 */
-#define AIPTEK_COORDINATE_RELATIVE_MODE			0
-#define AIPTEK_COORDINATE_ABSOLUTE_MODE			1
-
-       /* XTilt and YTilt values
-        */
-#define AIPTEK_TILT_MIN					(-128)
-#define AIPTEK_TILT_MAX					127
-#define AIPTEK_TILT_DISABLE				(-10101)
-
-	/* Wheel values
-	 */
-#define AIPTEK_WHEEL_MIN				0
-#define AIPTEK_WHEEL_MAX				1024
-#define AIPTEK_WHEEL_DISABLE				(-10101)
-
-	/* ToolCode values, which BTW are 0x140 .. 0x14f
-	 * We have things set up such that if TOOL_BUTTON_FIRED_BIT is
-	 * not set, we'll send one instance of AIPTEK_TOOL_BUTTON_xxx.
-	 *
-	 * Whenever the user resets the value, TOOL_BUTTON_FIRED_BIT will
-	 * get reset.
-	 */
-#define TOOL_BUTTON(x)					((x) & 0x14f)
-#define TOOL_BUTTON_FIRED(x)				((x) & 0x200)
-#define TOOL_BUTTON_FIRED_BIT				0x200
-	/* toolMode codes
-	 */
-#define AIPTEK_TOOL_BUTTON_PEN_MODE			BTN_TOOL_PEN
-#define AIPTEK_TOOL_BUTTON_PEN_MODE			BTN_TOOL_PEN
-#define AIPTEK_TOOL_BUTTON_PENCIL_MODE			BTN_TOOL_PENCIL
-#define AIPTEK_TOOL_BUTTON_BRUSH_MODE			BTN_TOOL_BRUSH
-#define AIPTEK_TOOL_BUTTON_AIRBRUSH_MODE		BTN_TOOL_AIRBRUSH
-#define AIPTEK_TOOL_BUTTON_ERASER_MODE			BTN_TOOL_RUBBER
-#define AIPTEK_TOOL_BUTTON_MOUSE_MODE			BTN_TOOL_MOUSE
-#define AIPTEK_TOOL_BUTTON_LENS_MODE			BTN_TOOL_LENS
-
-	/* Diagnostic message codes
-	 */
-#define AIPTEK_DIAGNOSTIC_NA				0
-#define AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE	1
-#define AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE	2
-#define AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED		3
-
-	/* Time to wait (in ms) to help mask hand jittering 
-	 * when pressing the stylus buttons.
-	 */
-#define AIPTEK_JITTER_DELAY_DEFAULT			50
-
-	/* Time to wait (in ms) in-between sending the tablet
-	 * a command and beginning the process of reading the return
-	 * sequence from the tablet.
-	 */
-#define AIPTEK_PROGRAMMABLE_DELAY_25		25
-#define AIPTEK_PROGRAMMABLE_DELAY_50		50
-#define AIPTEK_PROGRAMMABLE_DELAY_100		100
-#define AIPTEK_PROGRAMMABLE_DELAY_200		200
-#define AIPTEK_PROGRAMMABLE_DELAY_300		300
-#define AIPTEK_PROGRAMMABLE_DELAY_400		400
-#define AIPTEK_PROGRAMMABLE_DELAY_DEFAULT	AIPTEK_PROGRAMMABLE_DELAY_400
-
-	/* Mouse button programming
-	 */
-#define AIPTEK_MOUSE_LEFT_BUTTON		0x01
-#define AIPTEK_MOUSE_RIGHT_BUTTON		0x02
-#define AIPTEK_MOUSE_MIDDLE_BUTTON		0x04
-
-	/* Stylus button programming
-	 */
-#define AIPTEK_STYLUS_LOWER_BUTTON		0x08
-#define AIPTEK_STYLUS_UPPER_BUTTON		0x10
-
-	/* Length of incoming packet from the tablet
-	 */
-#define AIPTEK_PACKET_LENGTH			8
-
-	/* We report in EV_MISC both the proximity and
-	 * whether the report came from the stylus, tablet mouse
-	 * or "unknown" -- Unknown when the tablet is in relative
-	 * mode, because we only get report 1's.
-	 */
-#define AIPTEK_REPORT_TOOL_UNKNOWN		0x10
-#define AIPTEK_REPORT_TOOL_STYLUS		0x20
-#define AIPTEK_REPORT_TOOL_MOUSE		0x40
-
-static int programmableDelay = AIPTEK_PROGRAMMABLE_DELAY_DEFAULT;
-static int jitterDelay = AIPTEK_JITTER_DELAY_DEFAULT;
+#define USB_VENDOR_ID_AIPTEK   0x08ca
 
 struct aiptek_features {
-	int odmCode;		/* Tablet manufacturer code       */
-	int modelCode;		/* Tablet model code (not unique) */
-	int firmwareCode;	/* prom/eeprom version            */
-	char usbPath[64 + 1];	/* device's physical usb path     */
-	char inputPath[64 + 1];	/* input device path              */
-	char manuName[64 + 1];	/* manufacturer name              */
-	char prodName[64 + 1];	/* product name                   */
-};
-
-struct aiptek_settings {
-	int pointerMode;	/* stylus-, mouse-only or either */
-	int coordinateMode;	/* absolute/relative coords      */
-	int toolMode;		/* pen, pencil, brush, etc. tool */
-	int xTilt;		/* synthetic xTilt amount        */
-	int yTilt;		/* synthetic yTilt amount        */
-	int wheel;		/* synthetic wheel amount        */
-	int stylusButtonUpper;	/* stylus upper btn delivers...  */
-	int stylusButtonLower;	/* stylus lower btn delivers...  */
-	int mouseButtonLeft;	/* mouse left btn delivers...    */
-	int mouseButtonMiddle;	/* mouse middle btn delivers...  */
-	int mouseButtonRight;	/* mouse right btn delivers...   */
-	int programmableDelay;	/* delay for tablet programming  */
-	int jitterDelay;	/* delay for hand jittering      */
+	char *name;
+	int pktlen;
+	int x_max;
+	int y_max;
+	int pressure_min;
+	int pressure_max;
+	usb_complete_t irq;
+	unsigned long evbit;
+	unsigned long absbit;
+	unsigned long relbit;
+	unsigned long btnbit;
+	unsigned long digibit;
 };
 
 struct aiptek {
-	struct input_dev inputdev;		/* input device struct           */
-	struct usb_device *usbdev;		/* usb device struct             */
-	struct urb *urb;			/* urb for incoming reports      */
-	dma_addr_t data_dma;			/* our dma stuffage              */
-	struct aiptek_features features;	/* tablet's array of features    */
-	struct aiptek_settings curSetting;	/* tablet's current programmable */
-	struct aiptek_settings newSetting;	/* ... and new param settings    */
-	unsigned int ifnum;			/* interface number for IO       */
-	int openCount;				/* module use counter            */
-	int diagnostic;				/* tablet diagnostic codes       */
-	unsigned long eventCount;		/* event count                   */
-	int inDelay;				/* jitter: in jitter delay?      */
-	unsigned long endDelay;			/* jitter: time when delay ends  */
-	int previousJitterable;			/* jitterable prev value     */
-	unsigned char *data;			/* incoming packet data          */
-};
+	struct input_dev dev;
+	struct usb_device *usbdev;
+	struct urb *irq;
+	struct aiptek_features *features;
+	int tool;
+	int open;
 
-/*
- * Permit easy lookup of keyboard events to send, versus
- * the bitmap which comes from the tablet. This hides the
- * issue that the F_keys are not sequentially numbered.
- */
-static int macroKeyEvents[] = {
-	KEY_ESC, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5,
-	KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11,
-	KEY_F12, KEY_F13, KEY_F14, KEY_F15, KEY_F16, KEY_F17,
-	KEY_F18, KEY_F19, KEY_F20, KEY_F21, KEY_F22, KEY_F23,
-	KEY_F24, KEY_STOP, KEY_AGAIN, KEY_PROPS, KEY_UNDO,
-	KEY_FRONT, KEY_COPY, KEY_OPEN, KEY_PASTE, 0
+	signed char *data;
+	dma_addr_t data_dma;
 };
 
-/***********************************************************************
- * Relative reports deliver values in 2's complement format to
- * deal with negative offsets.
- */
-static int aiptek_convert_from_2s_complement(unsigned char c)
-{
-	int ret;
-	unsigned char b = c;
-	int negate = 0;
-
-	if ((b & 0x80) != 0) {
-		b = ~b;
-		b--;
-		negate = 1;
-	}
-	ret = b;
-	ret = (negate == 1) ? -ret : ret;
-	return ret;
-}
-
-/***********************************************************************
- * aiptek_irq can receive one of six potential reports.
- * The documentation for each is in the body of the function.
- *
- * The tablet reports on several attributes per invocation of
- * aiptek_irq. Because the Linux Input Event system allows the
- * transmission of ONE attribute per input_report_xxx() call,
- * collation has to be done on the other end to reconstitute
- * a complete tablet report. Further, the number of Input Event reports
- * submitted varies, depending on what USB report type, and circumstance.
- * To deal with this, EV_MSC is used to indicate an 'end-of-report'
- * message. This has been an undocumented convention understood by the kernel
- * tablet driver and clients such as gpm and XFree86's tablet drivers.
- *
- * Of the information received from the tablet, the one piece I
- * cannot transmit is the proximity bit (without resorting to an EV_MSC
- * convention above.) I therefore have taken over REL_MISC and ABS_MISC
- * (for relative and absolute reports, respectively) for communicating
- * Proximity. Why two events? I thought it interesting to know if the
- * Proximity event occured while the tablet was in absolute or relative
- * mode.
- *
- * Other tablets use the notion of a certain minimum stylus pressure
- * to infer proximity. While that could have been done, that is yet
- * another 'by convention' behavior, the documentation for which
- * would be spread between two (or more) pieces of software.
- *
- * EV_MSC usage was terminated for this purpose in Linux 2.5.x, and
- * replaced with the input_sync() method (which emits EV_SYN.)
- */
-
-static void aiptek_irq(struct urb *urb, struct pt_regs *regs)
+static void
+aiptek_irq(struct urb *urb, struct pt_regs *regs)
 {
 	struct aiptek *aiptek = urb->context;
 	unsigned char *data = aiptek->data;
-	struct input_dev *inputdev = &aiptek->inputdev;
-	int jitterable = 0;
-	int retval, macro, x, y, z, left, right, middle, p, dv, tip, bs, pck;
+	struct input_dev *dev = &aiptek->dev;
+	int x;
+	int y;
+	int pressure;
+	int proximity;
+	int retval;
 
 	switch (urb->status) {
 	case 0:
-		/* Success */
+		/* success */
 		break;
-
 	case -ECONNRESET:
 	case -ENOENT:
 	case -ESHUTDOWN:
-		/* This urb is terminated, clean up */
-		dbg("%s - urb shutting down with status: %d",
-		    __FUNCTION__, urb->status);
+		/* this urb is terminated, clean up */
+		dbg("%s - urb shutting down with status: %d", __FUNCTION__, urb->status);
 		return;
-
 	default:
-		dbg("%s - nonzero urb status received: %d",
-		    __FUNCTION__, urb->status);
+		dbg("%s - nonzero urb status received: %d", __FUNCTION__, urb->status);
 		goto exit;
 	}
 
-	/* See if we are in a delay loop -- throw out report if true.
-	 */
-	if (aiptek->inDelay == 1 && time_after(aiptek->endDelay, jiffies)) {
-		goto exit;
+	if ((data[0] & 2) == 0) {
+		dbg("received unknown report #%d", data[0]);
 	}
 
-	aiptek->inDelay = 0;
-	aiptek->eventCount++;
+	input_regs(dev, regs);
 
-	/* Report 1 delivers relative coordinates with either a stylus
-	 * or the mouse. You do not know, however, which input
-	 * tool generated the event.
-	 */
-	if (data[0] == 1) {
-		if (aiptek->curSetting.coordinateMode ==
-		    AIPTEK_COORDINATE_ABSOLUTE_MODE) {
-			aiptek->diagnostic =
-			    AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE;
-		} else {
-			input_regs(inputdev, regs);
-
-			x = aiptek_convert_from_2s_complement(data[2]);
-			y = aiptek_convert_from_2s_complement(data[3]);
-
-			/* jitterable keeps track of whether any button has been pressed.
-			 * We're also using it to remap the physical mouse button mask
-			 * to pseudo-settings. (We don't specifically care about it's
-			 * value after moving/transposing mouse button bitmasks, except
-			 * that a non-zero value indicates that one or more
-			 * mouse button was pressed.)
-			 */
-			jitterable = data[5] & 0x07;
-
-			left = (data[5] & aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;
-			right = (data[5] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;
-			middle = (data[5] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;
-
-			input_report_key(inputdev, BTN_LEFT, left);
-			input_report_key(inputdev, BTN_MIDDLE, middle);
-			input_report_key(inputdev, BTN_RIGHT, right);
-			input_report_rel(inputdev, REL_X, x);
-			input_report_rel(inputdev, REL_Y, y);
-			input_report_rel(inputdev, REL_MISC, 1 | AIPTEK_REPORT_TOOL_UNKNOWN);
-
-			/* Wheel support is in the form of a single-event
-			 * firing.
-			 */
-			if (aiptek->curSetting.wheel != AIPTEK_WHEEL_DISABLE) {
-				input_report_rel(inputdev, REL_WHEEL,
-						 aiptek->curSetting.wheel);
-				aiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;
-			}
-			input_sync(inputdev);
-		}
-	}
-	/* Report 2 is delivered only by the stylus, and delivers
-	 * absolute coordinates.
-	 */
-	else if (data[0] == 2) {
-		if (aiptek->curSetting.coordinateMode == AIPTEK_COORDINATE_RELATIVE_MODE) {
-			aiptek->diagnostic = AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE;
-		} else if (!AIPTEK_POINTER_ALLOW_STYLUS_MODE
-			    (aiptek->curSetting.pointerMode)) {
-				aiptek->diagnostic = AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED;
-		} else {
-			input_regs(inputdev, regs);
-
-			x = le16_to_cpu(get_unaligned((__le16 *) (data + 1)));
-			y = le16_to_cpu(get_unaligned((__le16 *) (data + 3)));
-			z = le16_to_cpu(get_unaligned((__le16 *) (data + 6)));
-
-			p = (data[5] & 0x01) != 0 ? 1 : 0;
-			dv = (data[5] & 0x02) != 0 ? 1 : 0;
-			tip = (data[5] & 0x04) != 0 ? 1 : 0;
-
-			/* Use jitterable to re-arrange button masks
-			 */
-			jitterable = data[5] & 0x18;
-
-			bs = (data[5] & aiptek->curSetting.stylusButtonLower) != 0 ? 1 : 0;
-			pck = (data[5] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;
-
-			/* dv indicates 'data valid' (e.g., the tablet is in sync
-			 * and has delivered a "correct" report) We will ignore
-			 * all 'bad' reports...
-			 */
-			if (dv != 0) {
-				/* If we've not already sent a tool_button_?? code, do
-				 * so now. Then set FIRED_BIT so it won't be resent unless
-				 * the user forces FIRED_BIT off.
-				 */
-				if (TOOL_BUTTON_FIRED
-				    (aiptek->curSetting.toolMode) == 0) {
-					input_report_key(inputdev,
-							 TOOL_BUTTON(aiptek->curSetting.toolMode),
-							 1);
-					aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
-				}
-
-				if (p != 0) {
-					input_report_abs(inputdev, ABS_X, x);
-					input_report_abs(inputdev, ABS_Y, y);
-					input_report_abs(inputdev, ABS_PRESSURE, z);
-
-					input_report_key(inputdev, BTN_TOUCH, tip);
-					input_report_key(inputdev, BTN_STYLUS, bs);
-					input_report_key(inputdev, BTN_STYLUS2, pck);
-
-					if (aiptek->curSetting.xTilt !=
-					    AIPTEK_TILT_DISABLE) {
-						input_report_abs(inputdev,
-								 ABS_TILT_X,
-								 aiptek->curSetting.xTilt);
-					}
-					if (aiptek->curSetting.yTilt != AIPTEK_TILT_DISABLE) {
-						input_report_abs(inputdev,
-								 ABS_TILT_Y,
-								 aiptek->curSetting.yTilt);
-					}
-
-					/* Wheel support is in the form of a single-event
-					 * firing.
-					 */
-					if (aiptek->curSetting.wheel !=
-					    AIPTEK_WHEEL_DISABLE) {
-						input_report_abs(inputdev,
-								 ABS_WHEEL,
-								 aiptek->curSetting.wheel);
-						aiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;
-					}
-				}
-				input_report_abs(inputdev, ABS_MISC, p | AIPTEK_REPORT_TOOL_STYLUS);
-				input_sync(inputdev);
-			}
-		}
-	}
-	/* Report 3's come from the mouse in absolute mode.
-	 */
-	else if (data[0] == 3) {
-		if (aiptek->curSetting.coordinateMode == AIPTEK_COORDINATE_RELATIVE_MODE) {
-			aiptek->diagnostic = AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE;
-		} else if (!AIPTEK_POINTER_ALLOW_MOUSE_MODE
-			(aiptek->curSetting.pointerMode)) {
-			aiptek->diagnostic = AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED;
-		} else {
-			input_regs(inputdev, regs);
-			x = le16_to_cpu(get_unaligned((__le16 *) (data + 1)));
-			y = le16_to_cpu(get_unaligned((__le16 *) (data + 3)));
-
-			jitterable = data[5] & 0x1c;
-
-			p = (data[5] & 0x01) != 0 ? 1 : 0;
-			dv = (data[5] & 0x02) != 0 ? 1 : 0;
-			left = (data[5] & aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;
-			right = (data[5] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;
-			middle = (data[5] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;
-
-			if (dv != 0) {
-				/* If we've not already sent a tool_button_?? code, do
-				 * so now. Then set FIRED_BIT so it won't be resent unless
-				 * the user forces FIRED_BIT off.
-				 */
-				if (TOOL_BUTTON_FIRED
-				    (aiptek->curSetting.toolMode) == 0) {
-					input_report_key(inputdev,
-							 TOOL_BUTTON(aiptek->curSetting.toolMode),
-							 1);
-					aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
-				}
-
-				if (p != 0) {
-					input_report_abs(inputdev, ABS_X, x);
-					input_report_abs(inputdev, ABS_Y, y);
-
-					input_report_key(inputdev, BTN_LEFT, left);
-					input_report_key(inputdev, BTN_MIDDLE, middle);
-					input_report_key(inputdev, BTN_RIGHT, right);
-
-					/* Wheel support is in the form of a single-event
-					 * firing.
-					 */
-					if (aiptek->curSetting.wheel != AIPTEK_WHEEL_DISABLE) {
-						input_report_abs(inputdev,
-								 ABS_WHEEL,
-								 aiptek->curSetting.wheel);
-						aiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;
-					}
-				}
-				input_report_rel(inputdev, REL_MISC, p | AIPTEK_REPORT_TOOL_MOUSE);
-				input_sync(inputdev);
-			}
-		}
-	}
-	/* Report 4s come from the macro keys when pressed by stylus
-	 */
-	else if (data[0] == 4) {
-		jitterable = data[1] & 0x18;
-
-		p = (data[1] & 0x01) != 0 ? 1 : 0;
-		dv = (data[1] & 0x02) != 0 ? 1 : 0;
-		tip = (data[1] & 0x04) != 0 ? 1 : 0;
-		bs = (data[1] & aiptek->curSetting.stylusButtonLower) != 0 ? 1 : 0;
-		pck = (data[1] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;
-
-		macro = data[3];
-		z = le16_to_cpu(get_unaligned((__le16 *) (data + 4)));
-
-		if (dv != 0) {
-			input_regs(inputdev, regs);
-
-			/* If we've not already sent a tool_button_?? code, do
-			 * so now. Then set FIRED_BIT so it won't be resent unless
-			 * the user forces FIRED_BIT off.
-			 */
-			if (TOOL_BUTTON_FIRED(aiptek->curSetting.toolMode) == 0) {
-				input_report_key(inputdev,
-						 TOOL_BUTTON(aiptek->curSetting.toolMode),
-						 1);
-				aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
-			}
-
-			if (p != 0) {
-				input_report_key(inputdev, BTN_TOUCH, tip);
-				input_report_key(inputdev, BTN_STYLUS, bs);
-				input_report_key(inputdev, BTN_STYLUS2, pck);
-				input_report_abs(inputdev, ABS_PRESSURE, z);
-			}
-
-			/* For safety, we're sending key 'break' codes for the
-			 * neighboring macro keys.
-			 */
-			if (macro > 0) {
-				input_report_key(inputdev,
-						 macroKeyEvents[macro - 1], 0);
-			}
-			if (macro < 25) {
-				input_report_key(inputdev,
-						 macroKeyEvents[macro + 1], 0);
-			}
-			input_report_key(inputdev, macroKeyEvents[macro], p);
-			input_report_abs(inputdev, ABS_MISC,
-					 p | AIPTEK_REPORT_TOOL_STYLUS);
-			input_sync(inputdev);
-		}
-	}
-	/* Report 5s come from the macro keys when pressed by mouse
-	 */
-	else if (data[0] == 5) {
-		jitterable = data[1] & 0x1c;
-
-		p = (data[1] & 0x01) != 0 ? 1 : 0;
-		dv = (data[1] & 0x02) != 0 ? 1 : 0;
-		left = (data[1]& aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;
-		right = (data[1] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;
-		middle = (data[1] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;
-		macro = data[3];
-
-		if (dv != 0) {
-			input_regs(inputdev, regs);
-
-			/* If we've not already sent a tool_button_?? code, do
-			 * so now. Then set FIRED_BIT so it won't be resent unless
-			 * the user forces FIRED_BIT off.
-			 */
-			if (TOOL_BUTTON_FIRED(aiptek->curSetting.toolMode) == 0) {
-				input_report_key(inputdev,
-						 TOOL_BUTTON(aiptek->curSetting.toolMode),
-						 1);
-				aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
-			}
-
-			if (p != 0) {
-				input_report_key(inputdev, BTN_LEFT, left);
-				input_report_key(inputdev, BTN_MIDDLE, middle);
-				input_report_key(inputdev, BTN_RIGHT, right);
-			}
-
-			/* For safety, we're sending key 'break' codes for the
-			 * neighboring macro keys.
-			 */
-			if (macro > 0) {
-				input_report_key(inputdev,
-						 macroKeyEvents[macro - 1], 0);
-			}
-			if (macro < 25) {
-				input_report_key(inputdev,
-						 macroKeyEvents[macro + 1], 0);
-			}
-
-			input_report_key(inputdev, macroKeyEvents[macro], 1);
-			input_report_rel(inputdev, ABS_MISC,
-					 p | AIPTEK_REPORT_TOOL_MOUSE);
-			input_sync(inputdev);
-		}
-	}
-	/* We have no idea which tool can generate a report 6. Theoretically,
-	 * neither need to, having been given reports 4 & 5 for such use.
-	 * However, report 6 is the 'official-looking' report for macroKeys;
-	 * reports 4 & 5 supposively are used to support unnamed, unknown
-	 * hat switches (which just so happen to be the macroKeys.)
-	 */
-	else if (data[0] == 6) {
-		macro = le16_to_cpu(get_unaligned((__le16 *) (data + 1)));
-		input_regs(inputdev, regs);
-
-		if (macro > 0) {
-			input_report_key(inputdev, macroKeyEvents[macro - 1],
-					 0);
-		}
-		if (macro < 25) {
-			input_report_key(inputdev, macroKeyEvents[macro + 1],
-					 0);
-		}
-
-		/* If we've not already sent a tool_button_?? code, do
-		 * so now. Then set FIRED_BIT so it won't be resent unless
-		 * the user forces FIRED_BIT off.
-		 */
-		if (TOOL_BUTTON_FIRED(aiptek->curSetting.toolMode) == 0) {
-			input_report_key(inputdev,
-					 TOOL_BUTTON(aiptek->curSetting.
-						     toolMode), 1);
-			aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
-		}
-
-		input_report_key(inputdev, macroKeyEvents[macro], 1);
-		input_report_abs(inputdev, ABS_MISC,
-				 1 | AIPTEK_REPORT_TOOL_UNKNOWN);
-		input_sync(inputdev);
-	} else {
-		dbg("Unknown report %d", data[0]);
+	proximity = data[5] & 0x01;
+	input_report_key(dev, BTN_TOOL_PEN, proximity);
+
+	x = le16_to_cpu(get_unaligned((u16 *) &data[1]));
+	y = le16_to_cpu(get_unaligned((u16 *) &data[3]));
+	pressure = le16_to_cpu(*(u16 *) &data[6]);
+	pressure -= aiptek->features->pressure_min;
+
+	if (pressure < 0) {
+		pressure = 0;
 	}
 
-	/* Jitter may occur when the user presses a button on the stlyus
-	 * or the mouse. What we do to prevent that is wait 'x' milliseconds
-	 * following a 'jitterable' event, which should give the hand some time
-	 * stabilize itself.
-	 *
-	 * We just introduced aiptek->previousJitterable to carry forth the
-	 * notion that jitter occurs when the button state changes from on to off:
-	 * a person drawing, holding a button down is not subject to jittering.
-	 * With that in mind, changing from upper button depressed to lower button
-	 * WILL transition through a jitter delay.
-	 */
-
-	if (aiptek->previousJitterable != jitterable &&
-	    aiptek->curSetting.jitterDelay != 0 && aiptek->inDelay != 1) {
-		aiptek->endDelay = jiffies +
-		    ((aiptek->curSetting.jitterDelay * HZ) / 1000);
-		aiptek->inDelay = 1;
+	if (proximity) {
+		input_report_abs(dev, ABS_X, x);
+		input_report_abs(dev, ABS_Y, y);
+		input_report_abs(dev, ABS_PRESSURE, pressure);
+		input_report_key(dev, BTN_TOUCH, data[5] & 0x04);
+		input_report_key(dev, BTN_STYLUS, data[5] & 0x08);
+		input_report_key(dev, BTN_STYLUS2, data[5] & 0x10);
 	}
-	aiptek->previousJitterable = jitterable;
+
+	input_sync(dev);
 
 exit:
-	retval = usb_submit_urb(urb, GFP_ATOMIC);
-	if (retval != 0) {
-		err("%s - usb_submit_urb failed with result %d",
-		    __FUNCTION__, retval);
-	}
+	retval = usb_submit_urb (urb, GFP_ATOMIC);
+	if (retval)
+		err ("%s - usb_submit_urb failed with result %d",
+		     __FUNCTION__, retval);
 }
 
-/***********************************************************************
- * These are the USB id's known so far. We do not identify them to
- * specific Aiptek model numbers, because there has been overlaps,
- * use, and reuse of id's in existing models. Certain models have
- * been known to use more than one ID, indicative perhaps of
- * manufacturing revisions. In any event, we consider these 
- * IDs to not be model-specific nor unique.
- */
+struct aiptek_features aiptek_features[] = {
+	{"Aiptek 6000U/8000U",
+	 8, 3000, 2250, 26, 511, aiptek_irq, 0, 0, 0, 0},
+	{NULL, 0}
+};
+
 struct usb_device_id aiptek_ids[] = {
-	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x01)},
-	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x10)},
-	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x20)},
-	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x21)},
-	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x22)},
-	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x23)},
-	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x24)},
+	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x20), .driver_info = 0},
 	{}
 };
 
 MODULE_DEVICE_TABLE(usb, aiptek_ids);
 
-/***********************************************************************
- * Open an instance of the tablet driver.
- */
-static int aiptek_open(struct input_dev *inputdev)
+static int
+aiptek_open(struct input_dev *dev)
 {
-	struct aiptek *aiptek = inputdev->private;
+	struct aiptek *aiptek = dev->private;
 
-	if (aiptek->openCount++ > 0) {
+	if (aiptek->open++)
 		return 0;
-	}
 
-	aiptek->urb->dev = aiptek->usbdev;
-	if (usb_submit_urb(aiptek->urb, GFP_KERNEL) != 0) {
-		aiptek->openCount--;
+	aiptek->irq->dev = aiptek->usbdev;
+	if (usb_submit_urb(aiptek->irq, GFP_KERNEL)) {
+		aiptek->open--;
 		return -EIO;
 	}
 
 	return 0;
 }
 
-/***********************************************************************
- * Close an instance of the tablet driver.
- */
-static void aiptek_close(struct input_dev *inputdev)
-{
-	struct aiptek *aiptek = inputdev->private;
-
-	if (--aiptek->openCount == 0) {
-		usb_unlink_urb(aiptek->urb);
-	}
-}
-
-/***********************************************************************
- * aiptek_set_report and aiptek_get_report() are borrowed from Linux 2.4.x, 
- * where they were known as usb_set_report and usb_get_report.
- */
-static int
-aiptek_set_report(struct aiptek *aiptek,
-		  unsigned char report_type,
-		  unsigned char report_id, void *buffer, int size)
+static void
+aiptek_close(struct input_dev *dev)
 {
-	return usb_control_msg(aiptek->usbdev,
-			       usb_sndctrlpipe(aiptek->usbdev, 0),
-			       USB_REQ_SET_REPORT,
-			       USB_TYPE_CLASS | USB_RECIP_INTERFACE |
-			       USB_DIR_OUT, (report_type << 8) + report_id,
-			       aiptek->ifnum, buffer, size, 5 * HZ);
-}
+	struct aiptek *aiptek = dev->private;
 
-static int
-aiptek_get_report(struct aiptek *aiptek,
-		  unsigned char report_type,
-		  unsigned char report_id, void *buffer, int size)
-{
-	return usb_control_msg(aiptek->usbdev,
-			       usb_rcvctrlpipe(aiptek->usbdev, 0),
-			       USB_REQ_GET_REPORT,
-			       USB_TYPE_CLASS | USB_RECIP_INTERFACE |
-			       USB_DIR_IN, (report_type << 8) + report_id,
-			       aiptek->ifnum, buffer, size, 5 * HZ);
+	if (!--aiptek->open)
+		usb_unlink_urb(aiptek->irq);
 }
 
-/***********************************************************************
- * Send a command to the tablet.
- */
+#define USB_REQ_SET_REPORT	0x09
 static int
-aiptek_command(struct aiptek *aiptek, unsigned char command, unsigned char data)
+usb_set_report(struct usb_device *dev, struct usb_host_interface *inter, unsigned char type,
+		unsigned char id, void *buf, int size)
 {
-	const int sizeof_buf = 3 * sizeof(u8);
-	int ret;
-	u8 *buf;
-
-	buf = kmalloc(sizeof_buf, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	buf[0] = 2;
-	buf[1] = command;
-	buf[2] = data;
-
-	if ((ret =
-	     aiptek_set_report(aiptek, 3, 2, buf, sizeof_buf)) != sizeof_buf) {
-		dbg("aiptek_program: failed, tried to send: 0x%02x 0x%02x",
-		    command, data);
-	}
-	kfree(buf);
-	return ret < 0 ? ret : 0;
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+		USB_REQ_SET_REPORT, USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+		(type << 8) + id, inter->desc.bInterfaceNumber, buf, size, HZ);
 }
 
-/***********************************************************************
- * Retrieve information from the tablet. Querying info is defined as first
- * sending the {command,data} sequence as a command, followed by a wait
- * (aka, "programmaticDelay") and then a "read" request.
- */
 static int
-aiptek_query(struct aiptek *aiptek, unsigned char command, unsigned char data)
+aiptek_command(struct usb_device *dev, struct usb_host_interface *inter,
+	       unsigned char command, unsigned char data)
 {
-	const int sizeof_buf = 3 * sizeof(u8);
-	int ret;
 	u8 *buf;
-
-	buf = kmalloc(sizeof_buf, GFP_KERNEL);
+	int err;
+	
+	buf = kmalloc(3, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
-	buf[0] = 2;
+	buf[0] = 4;
 	buf[1] = command;
 	buf[2] = data;
 
-	if (aiptek_command(aiptek, command, data) != 0) {
-		kfree(buf);
-		return -EIO;
-	}
-	msleep(aiptek->curSetting.programmableDelay);
-
-	if ((ret =
-	     aiptek_get_report(aiptek, 3, 2, buf, sizeof_buf)) != sizeof_buf) {
-		dbg("aiptek_query failed: returned 0x%02x 0x%02x 0x%02x",
-		    buf[0], buf[1], buf[2]);
-		ret = -EIO;
-	} else {
-		ret = le16_to_cpu(get_unaligned((__le16 *) (buf + 1)));
+	if ((err = usb_set_report(dev, inter, 3, 2, buf, 3)) != 3) {
+		dbg("aiptek_command: 0x%x 0x%x\n", command, data);
 	}
+	
 	kfree(buf);
-	return ret;
-}
-
-/***********************************************************************
- * Program the tablet into either absolute or relative mode.
- * We also get information about the tablet's size.
- */
-static int aiptek_program_tablet(struct aiptek *aiptek)
-{
-	int ret;
-	/* Execute Resolution500LPI */
-	if ((ret = aiptek_command(aiptek, 0x18, 0x04)) < 0)
-		return ret;
-
-	/* Query getModelCode */
-	if ((ret = aiptek_query(aiptek, 0x02, 0x00)) < 0)
-		return ret;
-	aiptek->features.modelCode = ret & 0xff;
-
-	/* Query getODMCode */
-	if ((ret = aiptek_query(aiptek, 0x03, 0x00)) < 0)
-		return ret;
-	aiptek->features.odmCode = ret;
-
-	/* Query getFirmwareCode */
-	if ((ret = aiptek_query(aiptek, 0x04, 0x00)) < 0)
-		return ret;
-	aiptek->features.firmwareCode = ret;
-
-	/* Query getXextension */
-	if ((ret = aiptek_query(aiptek, 0x01, 0x00)) < 0)
-		return ret;
-	aiptek->inputdev.absmin[ABS_X] = 0;
-	aiptek->inputdev.absmax[ABS_X] = ret - 1;
-
-	/* Query getYextension */
-	if ((ret = aiptek_query(aiptek, 0x01, 0x01)) < 0)
-		return ret;
-	aiptek->inputdev.absmin[ABS_Y] = 0;
-	aiptek->inputdev.absmax[ABS_Y] = ret - 1;
-
-	/* Query getPressureLevels */
-	if ((ret = aiptek_query(aiptek, 0x08, 0x00)) < 0)
-		return ret;
-	aiptek->inputdev.absmin[ABS_PRESSURE] = 0;
-	aiptek->inputdev.absmax[ABS_PRESSURE] = ret - 1;
-
-	/* Depending on whether we are in absolute or relative mode, we will
-	 * do a switchToTablet(absolute) or switchToMouse(relative) command.
-	 */
-	if (aiptek->curSetting.coordinateMode ==
-	    AIPTEK_COORDINATE_ABSOLUTE_MODE) {
-		/* Execute switchToTablet */
-		if ((ret = aiptek_command(aiptek, 0x10, 0x01)) < 0) {
-			return ret;
-		}
-	} else {
-		/* Execute switchToMouse */
-		if ((ret = aiptek_command(aiptek, 0x10, 0x00)) < 0) {
-			return ret;
-		}
-	}
-
-	/* Enable the macro keys */
-	if ((ret = aiptek_command(aiptek, 0x11, 0x02)) < 0)
-		return ret;
-#if 0
-	/* Execute FilterOn */
-	if ((ret = aiptek_command(aiptek, 0x17, 0x00)) < 0)
-		return ret;
-#endif
-
-	/* Execute AutoGainOn */
-	if ((ret = aiptek_command(aiptek, 0x12, 0xff)) < 0)
-		return ret;
-
-	/* Reset the eventCount, so we track events from last (re)programming
-	 */
-	aiptek->diagnostic = AIPTEK_DIAGNOSTIC_NA;
-	aiptek->eventCount = 0;
-
-	return 0;
-}
-
-/***********************************************************************
- * Sysfs functions. Sysfs prefers that individually-tunable parameters
- * exist in their separate pseudo-files. Summary data that is immutable
- * may exist in a singular file so long as you don't define a writeable
- * interface.
- */
-
-/***********************************************************************
- * support the 'size' file -- display support
- */
-static ssize_t show_tabletSize(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "%dx%d\n",
-			aiptek->inputdev.absmax[ABS_X] + 1,
-			aiptek->inputdev.absmax[ABS_Y] + 1);
-}
-
-/* These structs define the sysfs files, param #1 is the name of the
- * file, param 2 is the file permissions, param 3 & 4 are to the
- * output generator and input parser routines. Absence of a routine is
- * permitted -- it only means can't either 'cat' the file, or send data
- * to it.
- */
-static DEVICE_ATTR(size, S_IRUGO, show_tabletSize, NULL);
-
-/***********************************************************************
- * support routines for the 'product_id' file
- */
-static ssize_t show_tabletProductId(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "0x%04x\n",
-			aiptek->inputdev.id.product);
-}
-
-static DEVICE_ATTR(product_id, S_IRUGO, show_tabletProductId, NULL);
-
-/***********************************************************************
- * support routines for the 'vendor_id' file
- */
-static ssize_t show_tabletVendorId(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "0x%04x\n", aiptek->inputdev.id.vendor);
-}
-
-static DEVICE_ATTR(vendor_id, S_IRUGO, show_tabletVendorId, NULL);
-
-/***********************************************************************
- * support routines for the 'vendor' file
- */
-static ssize_t show_tabletManufacturer(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	int retval;
-
-	if (aiptek == NULL)
-		return 0;
-
-	retval = snprintf(buf, PAGE_SIZE, "%s\n", aiptek->features.manuName);
-	return retval;
-}
-
-static DEVICE_ATTR(vendor, S_IRUGO, show_tabletManufacturer, NULL);
-
-/***********************************************************************
- * support routines for the 'product' file
- */
-static ssize_t show_tabletProduct(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	int retval;
-
-	if (aiptek == NULL)
-		return 0;
-
-	retval = snprintf(buf, PAGE_SIZE, "%s\n", aiptek->features.prodName);
-	return retval;
+	return err < 0 ? err : 0;
 }
 
-static DEVICE_ATTR(product, S_IRUGO, show_tabletProduct, NULL);
-
-/***********************************************************************
- * support routines for the 'pointer_mode' file. Note that this file
- * both displays current setting and allows reprogramming.
- */
-static ssize_t show_tabletPointerMode(struct device *dev, char *buf)
+static int 
+aiptek_probe(struct usb_interface *intf,
+	     const struct usb_device_id *id)
 {
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	if (aiptek == NULL)
-		return 0;
-
-	switch (aiptek->curSetting.pointerMode) {
-	case AIPTEK_POINTER_ONLY_STYLUS_MODE:
-		s = "stylus";
-		break;
+	struct usb_device *dev = interface_to_usbdev (intf);
+	struct usb_host_interface *interface = intf->altsetting + 0;
+	struct usb_endpoint_descriptor *endpoint;
+	struct aiptek *aiptek;
+	int err = -ENOMEM;
 
-	case AIPTEK_POINTER_ONLY_MOUSE_MODE:
-		s = "mouse";
-		break;
+	if (!(aiptek = kmalloc(sizeof (struct aiptek), GFP_KERNEL)))
+		goto error_out_noalloc;
 
-	case AIPTEK_POINTER_EITHER_MODE:
-		s = "either";
-		break;
+	memset(aiptek, 0, sizeof (struct aiptek));
 
-	default:
-		s = "unknown";
-		break;
+	aiptek->data = usb_buffer_alloc(dev, 10, GFP_KERNEL, &aiptek->data_dma);
+	if (!aiptek->data) {
+		goto error_out_nobuf;
 	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
-}
 
-static ssize_t
-store_tabletPointerMode(struct device *dev, const char *buf, size_t count)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	if (aiptek == NULL)
-		return 0;
-
-	if (strcmp(buf, "stylus") == 0) {
-		aiptek->newSetting.pointerMode =
-		    AIPTEK_POINTER_ONLY_STYLUS_MODE;
-	} else if (strcmp(buf, "mouse") == 0) {
-		aiptek->newSetting.pointerMode = AIPTEK_POINTER_ONLY_MOUSE_MODE;
-	} else if (strcmp(buf, "either") == 0) {
-		aiptek->newSetting.pointerMode = AIPTEK_POINTER_EITHER_MODE;
+	aiptek->irq = usb_alloc_urb(0, GFP_KERNEL);
+	if (!aiptek->irq) {
+		goto error_out_nourb;
 	}
-	return count;
-}
-
-static DEVICE_ATTR(pointer_mode,
-		   S_IRUGO | S_IWUGO,
-		   show_tabletPointerMode, store_tabletPointerMode);
-
-/***********************************************************************
- * support routines for the 'coordinate_mode' file. Note that this file
- * both displays current setting and allows reprogramming.
- */
-static ssize_t show_tabletCoordinateMode(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	if (aiptek == NULL)
-		return 0;
-
-	switch (aiptek->curSetting.coordinateMode) {
-	case AIPTEK_COORDINATE_ABSOLUTE_MODE:
-		s = "absolute";
-		break;
 
-	case AIPTEK_COORDINATE_RELATIVE_MODE:
-		s = "relative";
-		break;
+	/* Resolution500LPI */
+	err = aiptek_command(dev, interface, 0x18, 0x04);
+	if (err)
+		goto error_out;
 
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
-}
+	/* SwitchToTablet */
+	err = aiptek_command(dev, interface, 0x10, 0x01);
+	if (err)
+		goto error_out;
 
-static ssize_t
-store_tabletCoordinateMode(struct device *dev, const char *buf, size_t count)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	if (aiptek == NULL)
-		return 0;
+	aiptek->features = aiptek_features + id->driver_info;
 
-	if (strcmp(buf, "absolute") == 0) {
-		aiptek->newSetting.pointerMode =
-		    AIPTEK_COORDINATE_ABSOLUTE_MODE;
-	} else if (strcmp(buf, "relative") == 0) {
-		aiptek->newSetting.pointerMode =
-		    AIPTEK_COORDINATE_RELATIVE_MODE;
-	}
-	return count;
-}
+	aiptek->dev.evbit[0] |= BIT(EV_KEY) | BIT(EV_ABS) | BIT(EV_MSC) |
+	    aiptek->features->evbit;
 
-static DEVICE_ATTR(coordinate_mode,
-		   S_IRUGO | S_IWUGO,
-		   show_tabletCoordinateMode, store_tabletCoordinateMode);
-
-/***********************************************************************
- * support routines for the 'tool_mode' file. Note that this file
- * both displays current setting and allows reprogramming.
- */
-static ssize_t show_tabletToolMode(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
+	aiptek->dev.absbit[0] |= BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE) |
+	    BIT(ABS_MISC) | aiptek->features->absbit;
 
-	if (aiptek == NULL)
-		return 0;
+	aiptek->dev.relbit[0] |= aiptek->features->relbit;
 
-	switch (TOOL_BUTTON(aiptek->curSetting.toolMode)) {
-	case AIPTEK_TOOL_BUTTON_MOUSE_MODE:
-		s = "mouse";
-		break;
+	aiptek->dev.keybit[LONG(BTN_LEFT)] |= BIT(BTN_LEFT) | BIT(BTN_RIGHT) |
+	    BIT(BTN_MIDDLE) | aiptek->features->btnbit;
 
-	case AIPTEK_TOOL_BUTTON_ERASER_MODE:
-		s = "eraser";
-		break;
+	aiptek->dev.keybit[LONG(BTN_DIGI)] |= BIT(BTN_TOOL_PEN) |
+	    BIT(BTN_TOOL_MOUSE) | BIT(BTN_TOUCH) |
+	    BIT(BTN_STYLUS) | BIT(BTN_STYLUS2) | aiptek->features->digibit;
 
-	case AIPTEK_TOOL_BUTTON_PENCIL_MODE:
-		s = "pencil";
-		break;
+	aiptek->dev.mscbit[0] = BIT(MSC_SERIAL);
 
-	case AIPTEK_TOOL_BUTTON_PEN_MODE:
-		s = "pen";
-		break;
+	aiptek->dev.absmax[ABS_X] = aiptek->features->x_max;
+	aiptek->dev.absmax[ABS_Y] = aiptek->features->y_max;
+	aiptek->dev.absmax[ABS_PRESSURE] = aiptek->features->pressure_max -
+	    aiptek->features->pressure_min;
 
-	case AIPTEK_TOOL_BUTTON_BRUSH_MODE:
-		s = "brush";
-		break;
+	aiptek->dev.absfuzz[ABS_X] = 0;
+	aiptek->dev.absfuzz[ABS_Y] = 0;
 
-	case AIPTEK_TOOL_BUTTON_AIRBRUSH_MODE:
-		s = "airbrush";
-		break;
+	aiptek->dev.private = aiptek;
+	aiptek->dev.open = aiptek_open;
+	aiptek->dev.close = aiptek_close;
 
-	case AIPTEK_TOOL_BUTTON_LENS_MODE:
-		s = "lens";
-		break;
+	aiptek->dev.name = aiptek->features->name;
+	aiptek->dev.id.bustype = BUS_USB;
+	aiptek->dev.id.vendor = dev->descriptor.idVendor;
+	aiptek->dev.id.product = dev->descriptor.idProduct;
+	aiptek->dev.id.version = dev->descriptor.bcdDevice;
+	aiptek->dev.dev = &intf->dev;
+	aiptek->usbdev = dev;
 
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
-}
+	endpoint = &intf->altsetting[0].endpoint[0].desc;
 
-static ssize_t
-store_tabletToolMode(struct device *dev, const char *buf, size_t count)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	if (aiptek == NULL)
-		return 0;
+	if (aiptek->features->pktlen > 10)
+		BUG();
 
-	if (strcmp(buf, "mouse") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_MOUSE_MODE;
-	} else if (strcmp(buf, "eraser") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_ERASER_MODE;
-	} else if (strcmp(buf, "pencil") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_PENCIL_MODE;
-	} else if (strcmp(buf, "pen") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE;
-	} else if (strcmp(buf, "brush") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_BRUSH_MODE;
-	} else if (strcmp(buf, "airbrush") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_AIRBRUSH_MODE;
-	} else if (strcmp(buf, "lens") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_LENS_MODE;
-	}
+	usb_fill_int_urb(aiptek->irq, dev,
+			 usb_rcvintpipe(dev, endpoint->bEndpointAddress),
+			 aiptek->data, aiptek->features->pktlen,
+			 aiptek->features->irq, aiptek, endpoint->bInterval);
+	aiptek->irq->transfer_dma = aiptek->data_dma;
+	aiptek->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
-	return count;
-}
+	input_register_device(&aiptek->dev);
 
-static DEVICE_ATTR(tool_mode,
-		   S_IRUGO | S_IWUGO,
-		   show_tabletToolMode, store_tabletToolMode);
-
-/***********************************************************************
- * support routines for the 'xtilt' file. Note that this file
- * both displays current setting and allows reprogramming.
- */
-static ssize_t show_tabletXtilt(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
+	printk(KERN_INFO "input: %s on usb%d:%d\n",
+	       aiptek->features->name, dev->bus->busnum, dev->devnum);
 
-	if (aiptek == NULL)
-		return 0;
+	usb_set_intfdata(intf, aiptek);
+	return 0;
 
-	if (aiptek->curSetting.xTilt == AIPTEK_TILT_DISABLE) {
-		return snprintf(buf, PAGE_SIZE, "disable\n");
-	} else {
-		return snprintf(buf, PAGE_SIZE, "%d\n",
-				aiptek->curSetting.xTilt);
-	}
+error_out:
+	usb_free_urb(aiptek->irq);
+error_out_nourb:
+	usb_buffer_free(dev, 10, aiptek->data, aiptek->data_dma);
+error_out_nobuf:
+	kfree(aiptek);
+error_out_noalloc:
+	return err;
+	
 }
 
-static ssize_t
-store_tabletXtilt(struct device *dev, const char *buf, size_t count)
+static void
+aiptek_disconnect(struct usb_interface *intf)
 {
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	int x;
-
-	if (aiptek == NULL)
-		return 0;
+	struct aiptek *aiptek  = usb_get_intfdata (intf);
 
-	if (strcmp(buf, "disable") == 0) {
-		aiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;
-	} else {
-		x = (int)simple_strtol(buf, NULL, 10);
-		if (x >= AIPTEK_TILT_MIN && x <= AIPTEK_TILT_MAX) {
-			aiptek->newSetting.xTilt = x;
-		}
+	usb_set_intfdata(intf, NULL);
+	if (aiptek) {
+		usb_unlink_urb(aiptek->irq);
+		input_unregister_device(&aiptek->dev);
+		usb_free_urb(aiptek->irq);
+		usb_buffer_free(interface_to_usbdev(intf), 10, aiptek->data, aiptek->data_dma);
+		kfree(aiptek);
 	}
-	return count;
 }
 
-static DEVICE_ATTR(xtilt,
-		   S_IRUGO | S_IWUGO, show_tabletXtilt, store_tabletXtilt);
-
-/***********************************************************************
- * support routines for the 'ytilt' file. Note that this file
- * both displays current setting and allows reprogramming.
- */
-static ssize_t show_tabletYtilt(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	if (aiptek->curSetting.yTilt == AIPTEK_TILT_DISABLE) {
-		return snprintf(buf, PAGE_SIZE, "disable\n");
-	} else {
-		return snprintf(buf, PAGE_SIZE, "%d\n",
-				aiptek->curSetting.yTilt);
-	}
-}
+static struct usb_driver aiptek_driver = {
+	.owner =	THIS_MODULE,
+	.name =		"aiptek",
+	.probe =	aiptek_probe,
+	.disconnect =	aiptek_disconnect,
+	.id_table =	aiptek_ids,
+};
 
-static ssize_t
-store_tabletYtilt(struct device *dev, const char *buf, size_t count)
+static int __init
+aiptek_init(void)
 {
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	int y;
-
-	if (aiptek == NULL)
-		return 0;
-
-	if (strcmp(buf, "disable") == 0) {
-		aiptek->newSetting.yTilt = AIPTEK_TILT_DISABLE;
-	} else {
-		y = (int)simple_strtol(buf, NULL, 10);
-		if (y >= AIPTEK_TILT_MIN && y <= AIPTEK_TILT_MAX) {
-			aiptek->newSetting.yTilt = y;
-		}
+	int result = usb_register(&aiptek_driver);
+	if (result == 0) {
+		info(DRIVER_VERSION " " DRIVER_AUTHOR);
+		info(DRIVER_DESC);
 	}
-	return count;
-}
-
-static DEVICE_ATTR(ytilt,
-		   S_IRUGO | S_IWUGO, show_tabletYtilt, store_tabletYtilt);
-
-/***********************************************************************
- * support routines for the 'jitter' file. Note that this file
- * both displays current setting and allows reprogramming.
- */
-static ssize_t show_tabletJitterDelay(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", aiptek->curSetting.jitterDelay);
-}
-
-static ssize_t
-store_tabletJitterDelay(struct device *dev, const char *buf, size_t count)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	aiptek->newSetting.jitterDelay = (int)simple_strtol(buf, NULL, 10);
-	return count;
+	return result;
 }
 
-static DEVICE_ATTR(jitter,
-		   S_IRUGO | S_IWUGO,
-		   show_tabletJitterDelay, store_tabletJitterDelay);
-
-/***********************************************************************
- * support routines for the 'delay' file. Note that this file
- * both displays current setting and allows reprogramming.
- */
-static ssize_t show_tabletProgrammableDelay(struct device *dev, char *buf)
+static void __exit
+aiptek_exit(void)
 {
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "%d\n",
-			aiptek->curSetting.programmableDelay);
+	usb_deregister(&aiptek_driver);
 }
 
-static ssize_t
-store_tabletProgrammableDelay(struct device *dev, const char *buf, size_t count)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	aiptek->newSetting.programmableDelay = (int)simple_strtol(buf, NULL, 10);
-	return count;
-}
-
-static DEVICE_ATTR(delay,
-		   S_IRUGO | S_IWUGO,
-		   show_tabletProgrammableDelay, store_tabletProgrammableDelay);
-
-/***********************************************************************
- * support routines for the 'input_path' file. Note that this file
- * only displays current setting.
- */
-static ssize_t show_tabletInputDevice(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "/dev/input/%s\n",
-			aiptek->features.inputPath);
-}
-
-static DEVICE_ATTR(input_path, S_IRUGO, show_tabletInputDevice, NULL);
-
-/***********************************************************************
- * support routines for the 'event_count' file. Note that this file
- * only displays current setting.
- */
-static ssize_t show_tabletEventsReceived(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "%ld\n", aiptek->eventCount);
-}
-
-static DEVICE_ATTR(event_count, S_IRUGO, show_tabletEventsReceived, NULL);
-
-/***********************************************************************
- * support routines for the 'diagnostic' file. Note that this file
- * only displays current setting.
- */
-static ssize_t show_tabletDiagnosticMessage(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *retMsg;
-
-	if (aiptek == NULL)
-		return 0;
-
-	switch (aiptek->diagnostic) {
-	case AIPTEK_DIAGNOSTIC_NA:
-		retMsg = "no errors\n";
-		break;
-
-	case AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE:
-		retMsg = "Error: receiving relative reports\n";
-		break;
-
-	case AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE:
-		retMsg = "Error: receiving absolute reports\n";
-		break;
-
-	case AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED:
-		if (aiptek->curSetting.pointerMode ==
-		    AIPTEK_POINTER_ONLY_MOUSE_MODE) {
-			retMsg = "Error: receiving stylus reports\n";
-		} else {
-			retMsg = "Error: receiving mouse reports\n";
-		}
-		break;
-
-	default:
-		return 0;
-	}
-	return snprintf(buf, PAGE_SIZE, retMsg);
-}
-
-static DEVICE_ATTR(diagnostic, S_IRUGO, show_tabletDiagnosticMessage, NULL);
-
-/***********************************************************************
- * support routines for the 'stylus_upper' file. Note that this file
- * both displays current setting and allows for setting changing.
- */
-static ssize_t show_tabletStylusUpper(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	if (aiptek == NULL)
-		return 0;
-
-	switch (aiptek->curSetting.stylusButtonUpper) {
-	case AIPTEK_STYLUS_UPPER_BUTTON:
-		s = "upper";
-		break;
-
-	case AIPTEK_STYLUS_LOWER_BUTTON:
-		s = "lower";
-		break;
-
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
-}
-
-static ssize_t
-store_tabletStylusUpper(struct device *dev, const char *buf, size_t count)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	if (strcmp(buf, "upper") == 0) {
-		aiptek->newSetting.stylusButtonUpper =
-		    AIPTEK_STYLUS_UPPER_BUTTON;
-	} else if (strcmp(buf, "lower") == 0) {
-		aiptek->newSetting.stylusButtonUpper =
-		    AIPTEK_STYLUS_LOWER_BUTTON;
-	}
-	return count;
-}
-
-static DEVICE_ATTR(stylus_upper,
-		   S_IRUGO | S_IWUGO,
-		   show_tabletStylusUpper, store_tabletStylusUpper);
-
-/***********************************************************************
- * support routines for the 'stylus_lower' file. Note that this file
- * both displays current setting and allows for setting changing.
- */
-static ssize_t show_tabletStylusLower(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	if (aiptek == NULL)
-		return 0;
-
-	switch (aiptek->curSetting.stylusButtonLower) {
-	case AIPTEK_STYLUS_UPPER_BUTTON:
-		s = "upper";
-		break;
-
-	case AIPTEK_STYLUS_LOWER_BUTTON:
-		s = "lower";
-		break;
-
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
-}
-
-static ssize_t
-store_tabletStylusLower(struct device *dev, const char *buf, size_t count)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	if (strcmp(buf, "upper") == 0) {
-		aiptek->newSetting.stylusButtonLower =
-		    AIPTEK_STYLUS_UPPER_BUTTON;
-	} else if (strcmp(buf, "lower") == 0) {
-		aiptek->newSetting.stylusButtonLower =
-		    AIPTEK_STYLUS_LOWER_BUTTON;
-	}
-	return count;
-}
-
-static DEVICE_ATTR(stylus_lower,
-		   S_IRUGO | S_IWUGO,
-		   show_tabletStylusLower, store_tabletStylusLower);
-
-/***********************************************************************
- * support routines for the 'mouse_left' file. Note that this file
- * both displays current setting and allows for setting changing.
- */
-static ssize_t show_tabletMouseLeft(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	if (aiptek == NULL)
-		return 0;
-
-	switch (aiptek->curSetting.mouseButtonLeft) {
-	case AIPTEK_MOUSE_LEFT_BUTTON:
-		s = "left";
-		break;
-
-	case AIPTEK_MOUSE_MIDDLE_BUTTON:
-		s = "middle";
-		break;
-
-	case AIPTEK_MOUSE_RIGHT_BUTTON:
-		s = "right";
-		break;
-
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
-}
-
-static ssize_t
-store_tabletMouseLeft(struct device *dev, const char *buf, size_t count)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	if (strcmp(buf, "left") == 0) {
-		aiptek->newSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON;
-	} else if (strcmp(buf, "middle") == 0) {
-		aiptek->newSetting.mouseButtonLeft = AIPTEK_MOUSE_MIDDLE_BUTTON;
-	} else if (strcmp(buf, "right") == 0) {
-		aiptek->newSetting.mouseButtonLeft = AIPTEK_MOUSE_RIGHT_BUTTON;
-	}
-	return count;
-}
-
-static DEVICE_ATTR(mouse_left,
-		   S_IRUGO | S_IWUGO,
-		   show_tabletMouseLeft, store_tabletMouseLeft);
-
-/***********************************************************************
- * support routines for the 'mouse_middle' file. Note that this file
- * both displays current setting and allows for setting changing.
- */
-static ssize_t show_tabletMouseMiddle(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	if (aiptek == NULL)
-		return 0;
-
-	switch (aiptek->curSetting.mouseButtonMiddle) {
-	case AIPTEK_MOUSE_LEFT_BUTTON:
-		s = "left";
-		break;
-
-	case AIPTEK_MOUSE_MIDDLE_BUTTON:
-		s = "middle";
-		break;
-
-	case AIPTEK_MOUSE_RIGHT_BUTTON:
-		s = "right";
-		break;
-
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
-}
-
-static ssize_t
-store_tabletMouseMiddle(struct device *dev, const char *buf, size_t count)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	if (strcmp(buf, "left") == 0) {
-		aiptek->newSetting.mouseButtonMiddle = AIPTEK_MOUSE_LEFT_BUTTON;
-	} else if (strcmp(buf, "middle") == 0) {
-		aiptek->newSetting.mouseButtonMiddle =
-		    AIPTEK_MOUSE_MIDDLE_BUTTON;
-	} else if (strcmp(buf, "right") == 0) {
-		aiptek->newSetting.mouseButtonMiddle =
-		    AIPTEK_MOUSE_RIGHT_BUTTON;
-	}
-	return count;
-}
-
-static DEVICE_ATTR(mouse_middle,
-		   S_IRUGO | S_IWUGO,
-		   show_tabletMouseMiddle, store_tabletMouseMiddle);
-
-/***********************************************************************
- * support routines for the 'mouse_right' file. Note that this file
- * both displays current setting and allows for setting changing.
- */
-static ssize_t show_tabletMouseRight(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	if (aiptek == NULL)
-		return 0;
-
-	switch (aiptek->curSetting.mouseButtonRight) {
-	case AIPTEK_MOUSE_LEFT_BUTTON:
-		s = "left";
-		break;
-
-	case AIPTEK_MOUSE_MIDDLE_BUTTON:
-		s = "middle";
-		break;
-
-	case AIPTEK_MOUSE_RIGHT_BUTTON:
-		s = "right";
-		break;
-
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
-}
-
-static ssize_t
-store_tabletMouseRight(struct device *dev, const char *buf, size_t count)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	if (strcmp(buf, "left") == 0) {
-		aiptek->newSetting.mouseButtonRight = AIPTEK_MOUSE_LEFT_BUTTON;
-	} else if (strcmp(buf, "middle") == 0) {
-		aiptek->newSetting.mouseButtonRight =
-		    AIPTEK_MOUSE_MIDDLE_BUTTON;
-	} else if (strcmp(buf, "right") == 0) {
-		aiptek->newSetting.mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON;
-	}
-	return count;
-}
-
-static DEVICE_ATTR(mouse_right,
-		   S_IRUGO | S_IWUGO,
-		   show_tabletMouseRight, store_tabletMouseRight);
-
-/***********************************************************************
- * support routines for the 'wheel' file. Note that this file
- * both displays current setting and allows for setting changing.
- */
-static ssize_t show_tabletWheel(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	if (aiptek->curSetting.wheel == AIPTEK_WHEEL_DISABLE) {
-		return snprintf(buf, PAGE_SIZE, "disable\n");
-	} else {
-		return snprintf(buf, PAGE_SIZE, "%d\n",
-				aiptek->curSetting.wheel);
-	}
-}
-
-static ssize_t
-store_tabletWheel(struct device *dev, const char *buf, size_t count)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	aiptek->newSetting.wheel = (int)simple_strtol(buf, NULL, 10);
-	return count;
-}
-
-static DEVICE_ATTR(wheel,
-		   S_IRUGO | S_IWUGO, show_tabletWheel, store_tabletWheel);
-
-/***********************************************************************
- * support routines for the 'execute' file. Note that this file
- * both displays current setting and allows for setting changing.
- */
-static ssize_t show_tabletExecute(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	/* There is nothing useful to display, so a one-line manual
-	 * is in order...
-	 */
-	return snprintf(buf, PAGE_SIZE,
-			"Write anything to this file to program your tablet.\n");
-}
-
-static ssize_t
-store_tabletExecute(struct device *dev, const char *buf, size_t count)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	/* We do not care what you write to this file. Merely the action
-	 * of writing to this file triggers a tablet reprogramming.
-	 */
-	memcpy(&aiptek->curSetting, &aiptek->newSetting,
-	       sizeof(struct aiptek_settings));
-
-	if (aiptek_program_tablet(aiptek) < 0)
-		return -EIO;
-
-	return count;
-}
-
-static DEVICE_ATTR(execute,
-		   S_IRUGO | S_IWUGO, show_tabletExecute, store_tabletExecute);
-
-/***********************************************************************
- * support routines for the 'odm_code' file. Note that this file
- * only displays current setting.
- */
-static ssize_t show_tabletODMCode(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "0x%04x\n", aiptek->features.odmCode);
-}
-
-static DEVICE_ATTR(odm_code, S_IRUGO, show_tabletODMCode, NULL);
-
-/***********************************************************************
- * support routines for the 'model_code' file. Note that this file
- * only displays current setting.
- */
-static ssize_t show_tabletModelCode(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "0x%04x\n", aiptek->features.modelCode);
-}
-
-static DEVICE_ATTR(model_code, S_IRUGO, show_tabletModelCode, NULL);
-
-/***********************************************************************
- * support routines for the 'firmware_code' file. Note that this file
- * only displays current setting.
- */
-static ssize_t show_firmwareCode(struct device *dev, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "%04x\n",
-			aiptek->features.firmwareCode);
-}
-
-static DEVICE_ATTR(firmware_code, S_IRUGO, show_firmwareCode, NULL);
-
-/***********************************************************************
- * This routine removes all existing sysfs files managed by this device
- * driver.
- */
-static void aiptek_delete_files(struct device *dev)
-{
-	device_remove_file(dev, &dev_attr_size);
-	device_remove_file(dev, &dev_attr_product_id);
-	device_remove_file(dev, &dev_attr_vendor_id);
-	device_remove_file(dev, &dev_attr_vendor);
-	device_remove_file(dev, &dev_attr_product);
-	device_remove_file(dev, &dev_attr_pointer_mode);
-	device_remove_file(dev, &dev_attr_coordinate_mode);
-	device_remove_file(dev, &dev_attr_tool_mode);
-	device_remove_file(dev, &dev_attr_xtilt);
-	device_remove_file(dev, &dev_attr_ytilt);
-	device_remove_file(dev, &dev_attr_jitter);
-	device_remove_file(dev, &dev_attr_delay);
-	device_remove_file(dev, &dev_attr_input_path);
-	device_remove_file(dev, &dev_attr_event_count);
-	device_remove_file(dev, &dev_attr_diagnostic);
-	device_remove_file(dev, &dev_attr_odm_code);
-	device_remove_file(dev, &dev_attr_model_code);
-	device_remove_file(dev, &dev_attr_firmware_code);
-	device_remove_file(dev, &dev_attr_stylus_lower);
-	device_remove_file(dev, &dev_attr_stylus_upper);
-	device_remove_file(dev, &dev_attr_mouse_left);
-	device_remove_file(dev, &dev_attr_mouse_middle);
-	device_remove_file(dev, &dev_attr_mouse_right);
-	device_remove_file(dev, &dev_attr_wheel);
-	device_remove_file(dev, &dev_attr_execute);
-}
-
-/***********************************************************************
- * This routine creates the sysfs files managed by this device
- * driver.
- */
-static int aiptek_add_files(struct device *dev)
-{
-	int ret;
-
-	if ((ret = device_create_file(dev, &dev_attr_size)) ||
-	    (ret = device_create_file(dev, &dev_attr_product_id)) ||
-	    (ret = device_create_file(dev, &dev_attr_vendor_id)) ||
-	    (ret = device_create_file(dev, &dev_attr_vendor)) ||
-	    (ret = device_create_file(dev, &dev_attr_product)) ||
-	    (ret = device_create_file(dev, &dev_attr_pointer_mode)) ||
-	    (ret = device_create_file(dev, &dev_attr_coordinate_mode)) ||
-	    (ret = device_create_file(dev, &dev_attr_tool_mode)) ||
-	    (ret = device_create_file(dev, &dev_attr_xtilt)) ||
-	    (ret = device_create_file(dev, &dev_attr_ytilt)) ||
-	    (ret = device_create_file(dev, &dev_attr_jitter)) ||
-	    (ret = device_create_file(dev, &dev_attr_delay)) ||
-	    (ret = device_create_file(dev, &dev_attr_input_path)) ||
-	    (ret = device_create_file(dev, &dev_attr_event_count)) ||
-	    (ret = device_create_file(dev, &dev_attr_diagnostic)) ||
-	    (ret = device_create_file(dev, &dev_attr_odm_code)) ||
-	    (ret = device_create_file(dev, &dev_attr_model_code)) ||
-	    (ret = device_create_file(dev, &dev_attr_firmware_code)) ||
-	    (ret = device_create_file(dev, &dev_attr_stylus_lower)) ||
-	    (ret = device_create_file(dev, &dev_attr_stylus_upper)) ||
-	    (ret = device_create_file(dev, &dev_attr_mouse_left)) ||
-	    (ret = device_create_file(dev, &dev_attr_mouse_middle)) ||
-	    (ret = device_create_file(dev, &dev_attr_mouse_right)) ||
-	    (ret = device_create_file(dev, &dev_attr_wheel)) ||
-	    (ret = device_create_file(dev, &dev_attr_execute))) {
-		err("aiptek: killing own sysfs device files\n");
-		aiptek_delete_files(dev);
-	}
-	return ret;
-}
-
-/***********************************************************************
- * This routine is called when a tablet has been identified. It basically
- * sets up the tablet and the driver's internal structures.
- */
-static int
-aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
-{
-	struct usb_device *usbdev = interface_to_usbdev(intf);
-	struct usb_endpoint_descriptor *endpoint;
-	struct aiptek *aiptek;
-	struct input_dev *inputdev;
-	struct input_handle *inputhandle;
-	struct list_head *node, *next;
-	char path[64 + 1];
-	int i;
-	int speeds[] = { 0,
-		AIPTEK_PROGRAMMABLE_DELAY_50,
-		AIPTEK_PROGRAMMABLE_DELAY_400,
-		AIPTEK_PROGRAMMABLE_DELAY_25,
-		AIPTEK_PROGRAMMABLE_DELAY_100,
-		AIPTEK_PROGRAMMABLE_DELAY_200,
-		AIPTEK_PROGRAMMABLE_DELAY_300
-	};
-
-	/* programmableDelay is where the command-line specified
-	 * delay is kept. We make it the first element of speeds[],
-	 * so therefore, your override speed is tried first, then the
-	 * remainder. Note that the default value of 400ms will be tried
-	 * if you do not specify any command line parameter.
-	 */
-	speeds[0] = programmableDelay;
-
-	if ((aiptek = kmalloc(sizeof(struct aiptek), GFP_KERNEL)) == NULL)
-		return -ENOMEM;
-	memset(aiptek, 0, sizeof(struct aiptek));
-
-	aiptek->data = usb_buffer_alloc(usbdev, AIPTEK_PACKET_LENGTH,
-					SLAB_ATOMIC, &aiptek->data_dma);
-	if (aiptek->data == NULL) {
-		kfree(aiptek);
-		return -ENOMEM;
-	}
-
-	aiptek->urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (aiptek->urb == NULL) {
-		usb_buffer_free(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data,
-				aiptek->data_dma);
-		kfree(aiptek);
-		return -ENOMEM;
-	}
-
-	/* Set up the curSettings struct. Said struct contains the current
-	 * programmable parameters. The newSetting struct contains changes
-	 * the user makes to the settings via the sysfs interface. Those
-	 * changes are not "committed" to curSettings until the user
-	 * writes to the sysfs/.../execute file.
-	 */
-	aiptek->curSetting.pointerMode = AIPTEK_POINTER_EITHER_MODE;
-	aiptek->curSetting.coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE;
-	aiptek->curSetting.toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE;
-	aiptek->curSetting.xTilt = AIPTEK_TILT_DISABLE;
-	aiptek->curSetting.yTilt = AIPTEK_TILT_DISABLE;
-	aiptek->curSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON;
-	aiptek->curSetting.mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON;
-	aiptek->curSetting.mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON;
-	aiptek->curSetting.stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON;
-	aiptek->curSetting.stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON;
-	aiptek->curSetting.jitterDelay = jitterDelay;
-	aiptek->curSetting.programmableDelay = programmableDelay;
-
-	/* Both structs should have equivalent settings
-	 */
-	memcpy(&aiptek->newSetting, &aiptek->curSetting,
-	       sizeof(struct aiptek_settings));
-
-	/* Now program the capacities of the tablet, in terms of being
-	 * an input device.
-	 */
-	aiptek->inputdev.evbit[0] |= BIT(EV_KEY)
-	    | BIT(EV_ABS)
-	    | BIT(EV_REL)
-	    | BIT(EV_MSC);
-
-	aiptek->inputdev.absbit[0] |=
-	    (BIT(ABS_X) |
-	     BIT(ABS_Y) |
-	     BIT(ABS_PRESSURE) |
-	     BIT(ABS_TILT_X) |
-	     BIT(ABS_TILT_Y) | BIT(ABS_WHEEL) | BIT(ABS_MISC));
-
-	aiptek->inputdev.relbit[0] |=
-	    (BIT(REL_X) | BIT(REL_Y) | BIT(REL_WHEEL) | BIT(REL_MISC));
-
-	aiptek->inputdev.keybit[LONG(BTN_LEFT)] |=
-	    (BIT(BTN_LEFT) | BIT(BTN_RIGHT) | BIT(BTN_MIDDLE));
-
-	aiptek->inputdev.keybit[LONG(BTN_DIGI)] |=
-	    (BIT(BTN_TOOL_PEN) |
-	     BIT(BTN_TOOL_RUBBER) |
-	     BIT(BTN_TOOL_PENCIL) |
-	     BIT(BTN_TOOL_AIRBRUSH) |
-	     BIT(BTN_TOOL_BRUSH) |
-	     BIT(BTN_TOOL_MOUSE) |
-	     BIT(BTN_TOOL_LENS) |
-	     BIT(BTN_TOUCH) | BIT(BTN_STYLUS) | BIT(BTN_STYLUS2));
-
-	aiptek->inputdev.mscbit[0] = BIT(MSC_SERIAL);
-
-	/* Programming the tablet macro keys needs to be done with a for loop
-	 * as the keycodes are discontiguous.
-	 */
-	for (i = 0; i < sizeof(macroKeyEvents) / sizeof(macroKeyEvents[0]); ++i)
-		set_bit(macroKeyEvents[i], aiptek->inputdev.keybit);
-
-	/* Set up client data, pointers to open and close routines
-	 * for the input device.
-	 */
-	aiptek->inputdev.private = aiptek;
-	aiptek->inputdev.open = aiptek_open;
-	aiptek->inputdev.close = aiptek_close;
-
-	/* Determine the usb devices' physical path.
-	 * Asketh not why we always pretend we're using "../input0",
-	 * but I suspect this will have to be refactored one
-	 * day if a single USB device can be a keyboard & a mouse
-	 * & a tablet, and the inputX number actually will tell
-	 * us something...
-	 */
-	if (usb_make_path(usbdev, path, 64) > 0)
-		sprintf(aiptek->features.usbPath, "%s/input0", path);
-
-	/* Program the input device coordinate capacities. We do not yet
-	 * know what maximum X, Y, and Z values are, so we're putting fake
-	 * values in. Later, we'll ask the tablet to put in the correct
-	 * values.
-	 */
-	aiptek->inputdev.absmin[ABS_X] = 0;
-	aiptek->inputdev.absmax[ABS_X] = 2999;
-	aiptek->inputdev.absmin[ABS_Y] = 0;
-	aiptek->inputdev.absmax[ABS_Y] = 2249;
-	aiptek->inputdev.absmin[ABS_PRESSURE] = 0;
-	aiptek->inputdev.absmax[ABS_PRESSURE] = 511;
-	aiptek->inputdev.absmin[ABS_TILT_X] = AIPTEK_TILT_MIN;
-	aiptek->inputdev.absmax[ABS_TILT_X] = AIPTEK_TILT_MAX;
-	aiptek->inputdev.absmin[ABS_TILT_Y] = AIPTEK_TILT_MIN;
-	aiptek->inputdev.absmax[ABS_TILT_Y] = AIPTEK_TILT_MAX;
-	aiptek->inputdev.absmin[ABS_WHEEL] = AIPTEK_WHEEL_MIN;
-	aiptek->inputdev.absmax[ABS_WHEEL] = AIPTEK_WHEEL_MAX - 1;
-	aiptek->inputdev.absfuzz[ABS_X] = 0;
-	aiptek->inputdev.absfuzz[ABS_Y] = 0;
-	aiptek->inputdev.absfuzz[ABS_PRESSURE] = 0;
-	aiptek->inputdev.absfuzz[ABS_TILT_X] = 0;
-	aiptek->inputdev.absfuzz[ABS_TILT_Y] = 0;
-	aiptek->inputdev.absfuzz[ABS_WHEEL] = 0;
-	aiptek->inputdev.absflat[ABS_X] = 0;
-	aiptek->inputdev.absflat[ABS_Y] = 0;
-	aiptek->inputdev.absflat[ABS_PRESSURE] = 0;
-	aiptek->inputdev.absflat[ABS_TILT_X] = 0;
-	aiptek->inputdev.absflat[ABS_TILT_Y] = 0;
-	aiptek->inputdev.absflat[ABS_WHEEL] = 0;
-	aiptek->inputdev.name = "Aiptek";
-	aiptek->inputdev.phys = aiptek->features.usbPath;
-	aiptek->inputdev.id.bustype = BUS_USB;
-	aiptek->inputdev.id.vendor = usbdev->descriptor.idVendor;
-	aiptek->inputdev.id.product = usbdev->descriptor.idProduct;
-	aiptek->inputdev.id.version = usbdev->descriptor.bcdDevice;
-
-	aiptek->usbdev = usbdev;
-	aiptek->ifnum = intf->altsetting[0].desc.bInterfaceNumber;
-	aiptek->inDelay = 0;
-	aiptek->endDelay = 0;
-	aiptek->previousJitterable = 0;
-
-	endpoint = &intf->altsetting[0].endpoint[0].desc;
-
-	/* Go set up our URB, which is called when the tablet receives
-	 * input.
-	 */
-	usb_fill_int_urb(aiptek->urb,
-			 aiptek->usbdev,
-			 usb_rcvintpipe(aiptek->usbdev,
-					endpoint->bEndpointAddress),
-			 aiptek->data, 8, aiptek_irq, aiptek,
-			 endpoint->bInterval);
-
-	aiptek->urb->transfer_dma = aiptek->data_dma;
-	aiptek->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-
-	/* Register the tablet as an Input Device
-	 */
-	input_register_device(&aiptek->inputdev);
-
-	/* Go and decode the USB representation of the tablet's manufacturer
-	 * name and product name. They only change once every hotplug event,
-	 * which is why we put it here instead of in the sysfs interface.
-	 */
-	usb_string(usbdev,
-		   usbdev->descriptor.iManufacturer,
-		   aiptek->features.manuName,
-		   sizeof(aiptek->features.manuName));
-	usb_string(usbdev,
-		   usbdev->descriptor.iProduct,
-		   aiptek->features.prodName,
-		   sizeof(aiptek->features.prodName));
-
-	/* We now will look for the evdev device which is mapped to
-	 * the tablet. The partial name is kept in the link list of
-	 * input_handles associated with this input device.
-	 * What identifies an evdev input_handler is that it begins
-	 * with 'event', continues with a digit, and that in turn
-	 * is mapped to /{devfs}/input/eventN.
-	 */
-	inputdev = &aiptek->inputdev;
-	list_for_each_safe(node, next, &inputdev->h_list) {
-		inputhandle = to_handle(node);
-		if (strncmp(inputhandle->name, "event", 5) == 0) {
-			strcpy(aiptek->features.inputPath, inputhandle->name);
-			break;
-		}
-	}
-
-	info("input: Aiptek on %s (%s)\n", path, aiptek->features.inputPath);
-
-	/* Program the tablet. This sets the tablet up in the mode
-	 * specified in newSetting, and also queries the tablet's
-	 * physical capacities.
-	 *
-	 * Sanity check: if a tablet doesn't like the slow programmatic
-	 * delay, we often get sizes of 0x0. Let's use that as an indicator
-	 * to try faster delays, up to 25 ms. If that logic fails, well, you'll
-	 * have to explain to us how your tablet thinks it's 0x0, and yet that's
-	 * not an error :-)
-	 */
-
-	for (i = 0; i < sizeof(speeds) / sizeof(speeds[0]); ++i) {
-		aiptek->curSetting.programmableDelay = speeds[i];
-		(void)aiptek_program_tablet(aiptek);
-		if (aiptek->inputdev.absmax[ABS_X] > 0) {
-			info("input: Aiptek using %d ms programming speed\n",
-			     aiptek->curSetting.programmableDelay);
-			break;
-		}
-	}
-
-	/* Associate this driver's struct with the usb interface.
-	 */
-	usb_set_intfdata(intf, aiptek);
-
-	/* Set up the sysfs files
-	 */
-	aiptek_add_files(&intf->dev);
-
-	/* Make sure the evdev module is loaded. Assuming evdev IS a module :-)
-	 */
-	if (request_module("evdev") != 0)
-		info("aiptek: error loading 'evdev' module");
-
-	return 0;
-}
-
-/* Forward declaration */
-static void aiptek_disconnect(struct usb_interface *intf);
-
-static struct usb_driver aiptek_driver = {
-	.owner = THIS_MODULE,
-	.name = "aiptek",
-	.probe = aiptek_probe,
-	.disconnect = aiptek_disconnect,
-	.id_table = aiptek_ids,
-};
-
-/***********************************************************************
- * Deal with tablet disconnecting from the system.
- */
-static void aiptek_disconnect(struct usb_interface *intf)
-{
-	struct aiptek *aiptek = usb_get_intfdata(intf);
-
-	/* Disassociate driver's struct with usb interface
-	 */
-	usb_set_intfdata(intf, NULL);
-	if (aiptek != NULL) {
-		/* Free & unhook everything from the system.
-		 */
-		usb_unlink_urb(aiptek->urb);
-		input_unregister_device(&aiptek->inputdev);
-		aiptek_delete_files(&intf->dev);
-		usb_free_urb(aiptek->urb);
-		usb_buffer_free(interface_to_usbdev(intf),
-				AIPTEK_PACKET_LENGTH,
-				aiptek->data, aiptek->data_dma);
-		kfree(aiptek);
-		aiptek = NULL;
-	}
-}
-
-static int __init aiptek_init(void)
-{
-	int result = usb_register(&aiptek_driver);
-	if (result == 0) {
-		info(DRIVER_VERSION ": " DRIVER_AUTHOR);
-		info(DRIVER_DESC);
-	}
-	return result;
-}
-
-static void __exit aiptek_exit(void)
-{
-	usb_deregister(&aiptek_driver);
-}
-
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
-
-module_param(programmableDelay, int, 0);
-MODULE_PARM_DESC(programmableDelay, "delay used during tablet programming");
-module_param(jitterDelay, int, 0);
-MODULE_PARM_DESC(jitterDelay, "stylus/mouse settlement delay");
-
 module_init(aiptek_init);
 module_exit(aiptek_exit);
diff -Naur linuxppc-2.6.9/drivers/usb/input/ati_remote.c linuxppc-2.6.9-dream/drivers/usb/input/ati_remote.c
--- linuxppc-2.6.9/drivers/usb/input/ati_remote.c	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/ati_remote.c	2005-09-19 21:40:05.000000000 +0200
@@ -16,12 +16,6 @@
  *
  *  Feb 2004: Torrey Hoffman <thoffman@arnor.net>
  *            Version 2.2.0
- *  Jun 2004: Torrey Hoffman <thoffman@arnor.net>
- *            Version 2.2.1
- *            Added key repeat support contributed by:
- *                Vincent Vanackere <vanackere@lif.univ-mrs.fr>
- *            Added support for the "Lola" remote contributed by:
- *                Seth Cohn <sethcohn@yahoo.com>
  *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
  *
@@ -47,11 +41,6 @@
  * "All-In-Wonder" video card packages.  The receiver self-identifies as a 
  * "USB Receiver" with manufacturer "X10 Wireless Technology Inc".
  *
- * The "Lola" remote is available from X10.  See: 
- *    http://www.x10.com/products/lola_sg1.htm
- * The Lola is similar to the ATI remote but has no mouse support, and slightly
- * different keys.
- *
  * It is possible to use multiple receivers and remotes on multiple computers 
  * simultaneously by configuring them to use specific channels.
  * 
@@ -101,9 +90,8 @@
  
 #define ATI_REMOTE_VENDOR_ID 	0x0bc7
 #define ATI_REMOTE_PRODUCT_ID 	0x004
-#define LOLA_REMOTE_PRODUCT_ID 	0x002
 
-#define DRIVER_VERSION 	        "2.2.1"
+#define DRIVER_VERSION 	        "2.2.0"
 #define DRIVER_AUTHOR           "Torrey Hoffman <thoffman@arnor.net>"
 #define DRIVER_DESC             "ATI/X10 RF USB Remote Control"
 
@@ -111,12 +99,12 @@
 #define DATA_BUFSIZE      63    /* size of URB data buffers */
 #define ATI_INPUTNUM      1     /* Which input device to register as */
 
-static unsigned long channel_mask = 0;
-module_param(channel_mask, ulong, 0444);
+unsigned long channel_mask = 0;
+module_param(channel_mask, ulong, 444);
 MODULE_PARM_DESC(channel_mask, "Bitmask of remote control channels to ignore");
 
 static int debug = 0;
-module_param(debug, int, 0444);
+module_param(debug, int, 444);
 MODULE_PARM_DESC(debug, "Enable extra debug messages and information");
 
 #define dbginfo(dev, format, arg...) do { if (debug) dev_info(dev , format , ## arg); } while (0)
@@ -125,7 +113,6 @@
  
 static struct usb_device_id ati_remote_table[] = {
 	{ USB_DEVICE(ATI_REMOTE_VENDOR_ID, ATI_REMOTE_PRODUCT_ID) },
-	{ USB_DEVICE(ATI_REMOTE_VENDOR_ID, LOLA_REMOTE_PRODUCT_ID) },
 	{}	/* Terminating entry */
 };
 
@@ -147,15 +134,10 @@
 
 /* Duplicate event filtering time. 
  * Sequential, identical KIND_FILTERED inputs with less than
- * FILTER_TIME jiffies between them are considered as repeat
- * events. The hardware generates 5 events for the first keypress
- * and we have to take this into account for an accurate repeat
- * behaviour.
- * (HZ / 20) == 50 ms and works well for me.
+ * FILTER_TIME jiffies between them are dropped.  
+ * (HZ >> 4) == 1/16th of a second and works well for me.
  */
-#define FILTER_TIME (HZ / 20)
-
-static DECLARE_MUTEX(disconnect_sem);
+#define FILTER_TIME (HZ >> 4)
 
 struct ati_remote {
 	struct input_dev idev;		
@@ -177,7 +159,6 @@
 	unsigned char old_data[2];  /* Detect duplicate events */
 	unsigned long old_jiffies;
 	unsigned long acc_jiffies;  /* handle acceleration */
-	unsigned int repeat_count;
 	
 	char name[NAME_BUFSIZE];
 	char phys[NAME_BUFSIZE];
@@ -273,12 +254,6 @@
 	{KIND_FILTERED, 0xeb, 0x26, EV_KEY, KEY_FORWARD, 1},    /* (>>) */
 	{KIND_FILTERED, 0xed, 0x28, EV_KEY, KEY_STOP, 1},       /* ([]) */ 
 	{KIND_FILTERED, 0xee, 0x29, EV_KEY, KEY_PAUSE, 1},      /* ('') */
-	{KIND_FILTERED, 0xf0, 0x2b, EV_KEY, KEY_PREVIOUS, 1},   /* (<-) */
-	{KIND_FILTERED, 0xef, 0x2a, EV_KEY, KEY_NEXT, 1},       /* (>+) */
-	{KIND_FILTERED, 0xf2, 0x2D, EV_KEY, KEY_INFO, 1},       /* PLAYING */
-	{KIND_FILTERED, 0xf3, 0x2E, EV_KEY, KEY_HOME, 1},       /* TOP */
-	{KIND_FILTERED, 0xf4, 0x2F, EV_KEY, KEY_END, 1},        /* END */
-	{KIND_FILTERED, 0xf5, 0x30, EV_KEY, KEY_SELECT, 1},     /* SELECT */	
 	
 	{KIND_END, 0x00, 0x00, EV_MAX + 1, 0, 0}
 };
@@ -311,12 +286,12 @@
 static void ati_remote_dump(unsigned char *data, unsigned int len)
 {
 	if ((len == 1) && (data[0] != (unsigned char)0xff) && (data[0] != 0x00))
-		warn("Weird byte 0x%02x", data[0]);
+		warn("Weird byte 0x%02x\n", data[0]);
 	else if (len == 4)
-		warn("Weird key %02x %02x %02x %02x", 
+		warn("Weird key %02x %02x %02x %02x\n", 
 		     data[0], data[1], data[2], data[3]);
 	else
-		warn("Weird data, len=%d %02x %02x %02x %02x %02x %02x ...",
+		warn("Weird data, len=%d %02x %02x %02x %02x %02x %02x ...\n",
 		     len, data[0], data[1], data[2], data[3], data[4], data[5]);
 }
 
@@ -326,12 +301,9 @@
 static int ati_remote_open(struct input_dev *inputdev)
 {
 	struct ati_remote *ati_remote = inputdev->private;
-	int retval = 0;
-
-	down(&disconnect_sem);
 
 	if (ati_remote->open++)
-		goto exit;
+		return 0;
 
 	/* On first open, submit the read urb which was set up previously. */
 	ati_remote->irq_urb->dev = ati_remote->udev;
@@ -339,12 +311,10 @@
 		dev_err(&ati_remote->interface->dev, 
 			"%s: usb_submit_urb failed!\n", __FUNCTION__);
 		ati_remote->open--;
-		retval = -EIO;
+		return -EIO;
 	}
 
-exit:
-	up(&disconnect_sem);
-	return retval;
+	return 0;
 }
 
 /*
@@ -384,7 +354,8 @@
 	
 	ati_remote->send_flags |= SEND_FLAG_COMPLETE;
 	wmb();
-	wake_up(&ati_remote->wait);
+	if (waitqueue_active(&ati_remote->wait))
+		wake_up(&ati_remote->wait);
 }
 
 /*
@@ -406,16 +377,18 @@
 	ati_remote->out_urb->dev = ati_remote->udev;
 	ati_remote->send_flags = SEND_FLAG_IN_PROGRESS;
 
-	retval = usb_submit_urb(ati_remote->out_urb, GFP_ATOMIC);
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&ati_remote->wait, &wait);
+
+	retval = usb_submit_urb(ati_remote->out_urb, GFP_KERNEL);
 	if (retval) {
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&ati_remote->wait, &wait);
 		dev_dbg(&ati_remote->interface->dev, 
 			 "sendpacket: usb_submit_urb failed: %d\n", retval);
 		return retval;
 	}
 
-	set_current_state(TASK_INTERRUPTIBLE);
-	add_wait_queue(&ati_remote->wait, &wait);
-
 	while (timeout && (ati_remote->out_urb->status == -EINPROGRESS) 
 	       && !(ati_remote->send_flags & SEND_FLAG_COMPLETE)) {
 		timeout = schedule_timeout(timeout);
@@ -506,20 +479,9 @@
 		if ((ati_remote->old_data[0] == data[1]) && 
 	 		(ati_remote->old_data[1] == data[2]) && 
 	 		((ati_remote->old_jiffies + FILTER_TIME) > jiffies)) {
-			ati_remote->repeat_count++;
-		} 
-		else {
-			ati_remote->repeat_count = 0;
-		}
-		
-		ati_remote->old_data[0] = data[1];
-		ati_remote->old_data[1] = data[2];
-		ati_remote->old_jiffies = jiffies;
-
-		if ((ati_remote->repeat_count > 0)
-		    && (ati_remote->repeat_count < 5))
+			ati_remote->old_jiffies = jiffies;			
 			return;
-		
+		}		
 
 		input_regs(dev, regs);
 		input_event(dev, ati_remote_tbl[index].type,
@@ -528,6 +490,9 @@
 			ati_remote_tbl[index].code, 0);
 		input_sync(dev);
 
+		ati_remote->old_data[0] = data[1];
+		ati_remote->old_data[1] = data[2];
+		ati_remote->old_jiffies = jiffies;
 		return;
 	}			
 	
@@ -629,7 +594,11 @@
 	if (ati_remote->out_urb)
 		usb_unlink_urb(ati_remote->out_urb);
 
-	input_unregister_device(&ati_remote->idev);
+	if (ati_remote->irq_urb)
+		usb_free_urb(ati_remote->irq_urb);
+	
+	if (ati_remote->out_urb)
+		usb_free_urb(ati_remote->out_urb);
 
 	if (ati_remote->inbuf)
 		usb_buffer_free(ati_remote->udev, DATA_BUFSIZE, 
@@ -639,12 +608,6 @@
 		usb_buffer_free(ati_remote->udev, DATA_BUFSIZE, 
 				ati_remote->inbuf, ati_remote->outbuf_dma);
 	
-	if (ati_remote->irq_urb)
-		usb_free_urb(ati_remote->irq_urb);
-	
-	if (ati_remote->out_urb)
-		usb_free_urb(ati_remote->out_urb);
-
 	kfree(ati_remote);
 }
 
@@ -728,9 +691,9 @@
 
 	/* See if the offered device matches what we can accept */
 	if ((udev->descriptor.idVendor != ATI_REMOTE_VENDOR_ID) ||
-		( (udev->descriptor.idProduct != ATI_REMOTE_PRODUCT_ID) &&
-		  (udev->descriptor.idProduct != LOLA_REMOTE_PRODUCT_ID) ))
+	    (udev->descriptor.idProduct != ATI_REMOTE_PRODUCT_ID)) {
 		return -ENODEV;
+	}
 
 	/* Allocate and clear an ati_remote struct */
 	if (!(ati_remote = kmalloc(sizeof (struct ati_remote), GFP_KERNEL)))
@@ -816,14 +779,14 @@
 
 	usb_set_intfdata(interface, ati_remote);
 	ati_remote->present = 1;	
+	kfree(buf);
+	return 0;
 	
 error:
 	if (buf)
 		kfree(buf);
 
-	if (retval)
-		ati_remote_delete(ati_remote);
-
+	ati_remote_delete(ati_remote);
 	return retval;
 }
 
@@ -833,9 +796,7 @@
 static void ati_remote_disconnect(struct usb_interface *interface)
 {
 	struct ati_remote *ati_remote;
-
-	down(&disconnect_sem);
-
+	
 	ati_remote = usb_get_intfdata(interface);
 	usb_set_intfdata(interface, NULL);
 	if (!ati_remote) {
@@ -843,14 +804,14 @@
 		return;
 	}
 	
+	input_unregister_device(&ati_remote->idev);
+
 	/* Mark device as unplugged */
 	ati_remote->present = 0;
 
 	/* If device is still open, ati_remote_close will call delete. */
 	if (!ati_remote->open)
 		ati_remote_delete(ati_remote);
-
-	up(&disconnect_sem);
 }
 
 /*
@@ -887,3 +848,4 @@
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
+
diff -Naur linuxppc-2.6.9/drivers/usb/input/hid-core.c linuxppc-2.6.9-dream/drivers/usb/input/hid-core.c
--- linuxppc-2.6.9/drivers/usb/input/hid-core.c	2004-10-18 23:54:32.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/hid-core.c	2005-09-19 21:40:05.000000000 +0200
@@ -219,13 +219,17 @@
 		dbg("logical range invalid %d %d", parser->global.logical_minimum, parser->global.logical_maximum);
 		return -1;
 	}
-	
-	if (!(usages = max_t(int, parser->local.usage_index, parser->global.report_count)))
-		return 0; /* Ignore padding fields */
+	usages = parser->local.usage_index;
 
 	offset = report->size;
 	report->size += parser->global.report_size * parser->global.report_count;
 
+	if (usages < parser->global.report_count)
+		usages = parser->global.report_count;
+
+	if (usages == 0)
+		return 0; /* ignore padding fields */
+
 	if ((field = hid_register_field(report, usages, parser->global.report_count)) == NULL)
 		return 0;
 
@@ -605,16 +609,16 @@
 		case 2:
 			if ((end - start) < 2) 
 				return NULL;
-			item->data.u16 = le16_to_cpu(get_unaligned((__le16*)start));
-			start = (__u8 *)((__le16 *)start + 1);
+			item->data.u16 = le16_to_cpu(get_unaligned((__u16*)start));
+			start = (__u8 *)((__u16 *)start + 1);
 			return start;
 
 		case 3:
 			item->size++;
 			if ((end - start) < 4)
 				return NULL;
-			item->data.u32 = le32_to_cpu(get_unaligned((__le32*)start));
-			start = (__u8 *)((__le32 *)start + 1);
+			item->data.u32 = le32_to_cpu(get_unaligned((__u32*)start));
+			start = (__u8 *)((__u32 *)start + 1);
 			return start;
 	}
 
@@ -756,15 +760,15 @@
 static __inline__ __u32 extract(__u8 *report, unsigned offset, unsigned n)
 {
 	report += (offset >> 5) << 2; offset &= 31;
-	return (le64_to_cpu(get_unaligned((__le64*)report)) >> offset) & ((1 << n) - 1);
+	return (le64_to_cpu(get_unaligned((__u64*)report)) >> offset) & ((1 << n) - 1);
 }
 
 static __inline__ void implement(__u8 *report, unsigned offset, unsigned n, __u32 value)
 {
 	report += (offset >> 5) << 2; offset &= 31;
-	put_unaligned((get_unaligned((__le64*)report)
+	put_unaligned((get_unaligned((__u64*)report)
 		& cpu_to_le64(~((((__u64) 1 << n) - 1) << offset)))
-		| cpu_to_le64((__u64)value << offset), (__le64*)report);
+		| cpu_to_le64((__u64)value << offset), (__u64*)report);
 }
 
 /*
@@ -803,11 +807,7 @@
 	unsigned size = field->report_size;
 	__s32 min = field->logical_minimum;
 	__s32 max = field->logical_maximum;
-	__s32 *value;
-
-	value = kmalloc(sizeof(__s32)*count, GFP_ATOMIC);
-	if (!value)
-		return;
+	__s32 value[count]; /* WARNING: gcc specific */
 
 	for (n = 0; n < count; n++) {
 
@@ -817,7 +817,7 @@
 			if (!(field->flags & HID_MAIN_ITEM_VARIABLE) /* Ignore report if ErrorRollOver */
 			    && value[n] >= min && value[n] <= max
 			    && field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)
-				goto exit;
+				return;
 	}
 
 	for (n = 0; n < count; n++) {
@@ -847,8 +847,6 @@
 	}
 
 	memcpy(field->value, value, count * sizeof(__s32));
-exit:
-	kfree(value);
 }
 
 static int hid_input_report(int type, struct urb *urb, struct pt_regs *regs)
@@ -919,22 +917,20 @@
 	int			status;
 
 	switch (urb->status) {
-		case 0:			/* success */
-			hid_input_report(HID_INPUT_REPORT, urb, regs);
-			break;
-		case -ECONNRESET:	/* unlink */
-		case -ENOENT:
-		case -ESHUTDOWN:
-			return;
-		case -ETIMEDOUT:	/* NAK */
-			break;
-		default:		/* error */
-			warn("input irq status %d received", urb->status);
+	case 0:			/* success */
+		hid_input_report(HID_INPUT_REPORT, urb, regs);
+		break;
+	case -ECONNRESET:	/* unlink */
+	case -ENOENT:
+	case -ESHUTDOWN:
+		return;
+	default:		/* error */
+		dbg("nonzero status in input irq %d", urb->status);
 	}
 	
-	status = usb_submit_urb(urb, SLAB_ATOMIC);
+	status = usb_submit_urb (urb, SLAB_ATOMIC);
 	if (status)
-		err("can't resubmit intr, %s-%s/input%d, status %d",
+		err ("can't resubmit intr, %s-%s/input%d, status %d",
 				hid->dev->bus->bus_name, hid->dev->devpath,
 				hid->ifnum, status);
 }
@@ -962,7 +958,7 @@
  * Create a report.
  */
 
-static void hid_output_report(struct hid_report *report, __u8 *data)
+void hid_output_report(struct hid_report *report, __u8 *data)
 {
 	unsigned n;
 
@@ -1042,8 +1038,7 @@
 	return -1;
 }
 
-#if 0
-static int hid_find_field_in_report(struct hid_report *report, __u32 wanted_usage, struct hid_field **field)
+int hid_find_field_in_report(struct hid_report *report, __u32 wanted_usage, struct hid_field **field)
 {
 	int i, j;
 
@@ -1056,7 +1051,6 @@
 
 	return -1;
 }
-#endif
 
 static int hid_submit_out(struct hid_device *hid)
 {
@@ -1135,31 +1129,23 @@
 	struct hid_device *hid = urb->context;
 	unsigned long flags;
 
-	switch (urb->status) {
-		case 0:			/* success */
-		case -ECONNRESET:	/* unlink */
-		case -ENOENT:
-		case -ESHUTDOWN:
-			break;
-		default:		/* error */
-			warn("output irq status %d received", urb->status);
-	}
+	if (urb->status)
+		warn("output irq status %d received", urb->status);
 
 	spin_lock_irqsave(&hid->outlock, flags);
 
 	hid->outtail = (hid->outtail + 1) & (HID_OUTPUT_FIFO_SIZE - 1);
 
 	if (hid->outhead != hid->outtail) {
-		if (hid_submit_out(hid)) {
-			clear_bit(HID_OUT_RUNNING, &hid->iofl);;
-			wake_up(&hid->wait);
-		}
+		hid_submit_out(hid);
 		spin_unlock_irqrestore(&hid->outlock, flags);
 		return;
 	}
 
 	clear_bit(HID_OUT_RUNNING, &hid->iofl);
+
 	spin_unlock_irqrestore(&hid->outlock, flags);
+
 	wake_up(&hid->wait);
 }
 
@@ -1172,34 +1158,26 @@
 	struct hid_device *hid = urb->context;
 	unsigned long flags;
 
+	if (urb->status)
+		warn("ctrl urb status %d received", urb->status);
+
 	spin_lock_irqsave(&hid->ctrllock, flags);
 
-	switch (urb->status) {
-		case 0:			/* success */
-			if (hid->ctrl[hid->ctrltail].dir == USB_DIR_IN) 
-				hid_input_report(hid->ctrl[hid->ctrltail].report->type, urb, regs);
-		case -ECONNRESET:	/* unlink */
-		case -ENOENT:
-		case -ESHUTDOWN:
-		case -EPIPE:		/* report not available */
-			break;
-		default:		/* error */
-			warn("ctrl urb status %d received", urb->status);
-	}
+	if (hid->ctrl[hid->ctrltail].dir == USB_DIR_IN) 
+		hid_input_report(hid->ctrl[hid->ctrltail].report->type, urb, regs);
 
 	hid->ctrltail = (hid->ctrltail + 1) & (HID_CONTROL_FIFO_SIZE - 1);
 
 	if (hid->ctrlhead != hid->ctrltail) {
-		if (hid_submit_ctrl(hid)) {
-			clear_bit(HID_CTRL_RUNNING, &hid->iofl);
-			wake_up(&hid->wait);
-		}
+		hid_submit_ctrl(hid);
 		spin_unlock_irqrestore(&hid->ctrllock, flags);
 		return;
 	}
 
 	clear_bit(HID_CTRL_RUNNING, &hid->iofl);
+
 	spin_unlock_irqrestore(&hid->ctrllock, flags);
+
 	wake_up(&hid->wait);
 }
 
@@ -1225,8 +1203,7 @@
 		hid->outhead = head;
 
 		if (!test_and_set_bit(HID_OUT_RUNNING, &hid->iofl))
-			if (hid_submit_out(hid))
-				clear_bit(HID_OUT_RUNNING, &hid->iofl);
+			hid_submit_out(hid);
 
 		spin_unlock_irqrestore(&hid->outlock, flags);
 		return;
@@ -1245,8 +1222,7 @@
 	hid->ctrlhead = head;
 
 	if (!test_and_set_bit(HID_CTRL_RUNNING, &hid->iofl))
-		if (hid_submit_ctrl(hid))
-			clear_bit(HID_CTRL_RUNNING, &hid->iofl);
+		hid_submit_ctrl(hid);
 
 	spin_unlock_irqrestore(&hid->ctrllock, flags);
 }
@@ -1298,7 +1274,7 @@
 void hid_close(struct hid_device *hid)
 {
 	if (!--hid->open)
-		usb_kill_urb(hid->urbin);
+		usb_unlink_urb(hid->urbin);
 }
 
 /*
@@ -1346,14 +1322,12 @@
 	}
 
 	err = 0;
-	ret = hid_wait_io(hid);
-	while (ret) {
+	while ((ret = hid_wait_io(hid))) {
 		err |= ret;
 		if (test_bit(HID_CTRL_RUNNING, &hid->iofl))
 			usb_unlink_urb(hid->urbctrl);
 		if (test_bit(HID_OUT_RUNNING, &hid->iofl))
 			usb_unlink_urb(hid->urbout);
-		ret = hid_wait_io(hid);
 	}
 
 	if (err)
@@ -1383,13 +1357,7 @@
 #define USB_DEVICE_ID_KBGEAR_JAMSTUDIO  0x1001
 
 #define USB_VENDOR_ID_AIPTEK		0x08ca
-#define USB_DEVICE_ID_AIPTEK_01		0x0001
-#define USB_DEVICE_ID_AIPTEK_10		0x0010
-#define USB_DEVICE_ID_AIPTEK_20		0x0020
-#define USB_DEVICE_ID_AIPTEK_21		0x0021
-#define USB_DEVICE_ID_AIPTEK_22		0x0022
-#define USB_DEVICE_ID_AIPTEK_23		0x0023
-#define USB_DEVICE_ID_AIPTEK_24		0x0024
+#define USB_DEVICE_ID_AIPTEK_6000	0x0020
 
 #define USB_VENDOR_ID_GRIFFIN		0x077d
 #define USB_DEVICE_ID_POWERMATE		0x0410
@@ -1444,50 +1412,28 @@
 #define USB_VENDOR_ID_CHIC		0x05fe
 #define USB_DEVICE_ID_CHIC_GAMEPAD	0x0014
 
-#define USB_VENDOR_ID_GLAB		0x06c2
-#define USB_DEVICE_ID_4_PHIDGETSERVO_30	0x0038
-#define USB_DEVICE_ID_1_PHIDGETSERVO_30	0x0039
-#define USB_DEVICE_ID_8_8_8_IF_KIT	0x0045
-#define USB_DEVICE_ID_0_0_4_IF_KIT	0x0040
-#define USB_DEVICE_ID_0_8_8_IF_KIT	0x0053
-
-#define USB_VENDOR_ID_WISEGROUP		0x0925
-#define USB_DEVICE_ID_1_PHIDGETSERVO_20	0x8101
-#define USB_DEVICE_ID_4_PHIDGETSERVO_20	0x8104
-
-#define USB_VENDOR_ID_CODEMERCS		0x07c0
-#define USB_DEVICE_ID_CODEMERCS_IOW40	0x1500
-#define USB_DEVICE_ID_CODEMERCS_IOW24	0x1501
-
-
-static struct hid_blacklist {
+struct hid_blacklist {
 	__u16 idVendor;
 	__u16 idProduct;
 	unsigned quirks;
 } hid_blacklist[] = {
 
-	{ USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_01, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_10, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_20, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_21, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_22, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_23, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_24, HID_QUIRK_IGNORE },
+	{ USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_6000, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_BERKSHIRE, USB_DEVICE_ID_BERKSHIRE_PCWD, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_CODEMERCS, USB_DEVICE_ID_CODEMERCS_IOW40, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_CODEMERCS, USB_DEVICE_ID_CODEMERCS_IOW24, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_ESSENTIAL_REALITY, USB_DEVICE_ID_ESSENTIAL_REALITY_P5, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_KBGEAR, USB_DEVICE_ID_KBGEAR_JAMSTUDIO, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_POWERMATE, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_SOUNDKNOB, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS1, HID_QUIRK_IGNORE },
+
 	{ USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 100, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 200, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 300, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 400, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 500, HID_QUIRK_IGNORE },
+
 	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_PENPARTNER, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_GRAPHIRE, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_GRAPHIRE + 1, HID_QUIRK_IGNORE },
@@ -1514,15 +1460,6 @@
 	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_VOLITO, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_PTU, HID_QUIRK_IGNORE },
 
-	{ USB_VENDOR_ID_GLAB, USB_DEVICE_ID_4_PHIDGETSERVO_30, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_GLAB, USB_DEVICE_ID_1_PHIDGETSERVO_30, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_GLAB, USB_DEVICE_ID_8_8_8_IF_KIT, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_GLAB, USB_DEVICE_ID_0_0_4_IF_KIT, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_GLAB, USB_DEVICE_ID_0_8_8_IF_KIT, HID_QUIRK_IGNORE },
-
-	{ USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_4_PHIDGETSERVO_20, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_1_PHIDGETSERVO_20, HID_QUIRK_IGNORE },
-
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_UC100KM, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_CS124U, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_2PORTKVM, HID_QUIRK_NOGET },
@@ -1640,17 +1577,11 @@
 
 		struct usb_endpoint_descriptor *endpoint;
 		int pipe;
-		int interval;
 
 		endpoint = &interface->endpoint[n].desc;
 		if ((endpoint->bmAttributes & 3) != 3)		/* Not an interrupt endpoint */
 			continue;
 
-		/* handle potential highspeed HID correctly */
-		interval = endpoint->bInterval;
-		if (dev->speed == USB_SPEED_HIGH)
-			interval = 1 << (interval - 1);
-
 		if (endpoint->bEndpointAddress & USB_DIR_IN) {
 			int len;
 
@@ -1663,9 +1594,9 @@
 			if (len > HID_BUFFER_SIZE)
 				len = HID_BUFFER_SIZE;
 			usb_fill_int_urb(hid->urbin, dev, pipe, hid->inbuf, len,
-					 hid_irq_in, hid, interval);
+					 hid_irq_in, hid, endpoint->bInterval);
 			hid->urbin->transfer_dma = hid->inbuf_dma;
-			hid->urbin->transfer_flags |=(URB_NO_TRANSFER_DMA_MAP | URB_ASYNC_UNLINK);
+			hid->urbin->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 		} else {
 			if (hid->urbout)
 				continue;
@@ -1673,9 +1604,9 @@
 				goto fail;
 			pipe = usb_sndintpipe(dev, endpoint->bEndpointAddress);
 			usb_fill_int_urb(hid->urbout, dev, pipe, hid->outbuf, 0,
-					 hid_irq_out, hid, interval);
+					  hid_irq_out, hid, 1);
 			hid->urbout->transfer_dma = hid->outbuf_dma;
-			hid->urbout->transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_ASYNC_UNLINK);
+			hid->urbout->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 		}
 	}
 
@@ -1725,7 +1656,8 @@
 			     hid->ctrlbuf, 1, hid_ctrl, hid);
 	hid->urbctrl->setup_dma = hid->cr_dma;
 	hid->urbctrl->transfer_dma = hid->ctrlbuf_dma;
-	hid->urbctrl->transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP | URB_ASYNC_UNLINK);
+	hid->urbctrl->transfer_flags |= (URB_NO_TRANSFER_DMA_MAP
+				| URB_NO_SETUP_DMA_MAP);
 
 	return hid;
 
@@ -1751,9 +1683,9 @@
 		return;
 
 	usb_set_intfdata(intf, NULL);
-	usb_kill_urb(hid->urbin);
-	usb_kill_urb(hid->urbout);
-	usb_kill_urb(hid->urbctrl);
+	usb_unlink_urb(hid->urbin);
+	usb_unlink_urb(hid->urbout);
+	usb_unlink_urb(hid->urbctrl);
 
 	if (hid->claimed & HID_CLAIMED_INPUT)
 		hidinput_disconnect(hid);
@@ -1835,7 +1767,7 @@
 
 static struct usb_driver hid_driver = {
 	.owner =	THIS_MODULE,
-	.name =		"usbhid",
+	.name =		"hid",
 	.probe =	hid_probe,
 	.disconnect =	hid_disconnect,
 	.id_table =	hid_usb_ids,
@@ -1861,8 +1793,8 @@
 
 static void __exit hid_exit(void)
 {
-	usb_deregister(&hid_driver);
 	hiddev_exit();
+	usb_deregister(&hid_driver);
 }
 
 module_init(hid_init);
diff -Naur linuxppc-2.6.9/drivers/usb/input/hiddev.c linuxppc-2.6.9-dream/drivers/usb/input/hiddev.c
--- linuxppc-2.6.9/drivers/usb/input/hiddev.c	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/hiddev.c	2005-09-19 21:40:05.000000000 +0200
@@ -49,9 +49,11 @@
 struct hiddev {
 	int exist;
 	int open;
+	int minor;
 	wait_queue_head_t wait;
 	struct hid_device *hid;
 	struct hiddev_list *list;
+	struct usb_interface intf;
 };
 
 struct hiddev_list {
@@ -66,6 +68,9 @@
 
 static struct hiddev *hiddev_table[HIDDEV_MINORS];
 
+/* forward reference to make our lives easier */
+extern struct usb_driver hiddev_driver;
+
 /*
  * Find a report, given the report's type and ID.  The ID can be specified
  * indirectly by REPORT_ID_FIRST (which returns the first report of the given
@@ -223,6 +228,16 @@
 	return retval < 0 ? retval : 0;
 }
 
+/*
+ * De-allocate a hiddev structure
+ */
+static struct usb_class_driver hiddev_class;
+static void hiddev_cleanup(struct hiddev *hiddev)
+{
+	usb_deregister_dev(&hiddev->intf, &hiddev_class);
+	hiddev_table[hiddev->minor] = NULL;
+	kfree(hiddev);
+}
 
 /*
  * release file op
@@ -243,7 +258,7 @@
 		if (list->hiddev->exist) 
 			hid_close(list->hiddev->hid);
 		else
-			kfree(list->hiddev);
+			hiddev_cleanup(list->hiddev);
 	}
 
 	kfree(list);
@@ -282,7 +297,7 @@
 /*
  * "write" file op
  */
-static ssize_t hiddev_write(struct file * file, const char __user * buffer, size_t count, loff_t *ppos)
+static ssize_t hiddev_write(struct file * file, const char * buffer, size_t count, loff_t *ppos)
 {
 	return -EINVAL;
 }
@@ -290,7 +305,7 @@
 /*
  * "read" file op
  */
-static ssize_t hiddev_read(struct file * file, char __user * buffer, size_t count, loff_t *ppos)
+static ssize_t hiddev_read(struct file * file, char * buffer, size_t count, loff_t *ppos)
 {
 	DECLARE_WAITQUEUE(wait, current);
 	struct hiddev_list *list = file->private_data;
@@ -388,12 +403,11 @@
 	struct hiddev_collection_info cinfo;
 	struct hiddev_report_info rinfo;
 	struct hiddev_field_info finfo;
-	struct hiddev_usage_ref_multi *uref_multi=NULL;
-	struct hiddev_usage_ref *uref;
+	struct hiddev_usage_ref_multi uref_multi;
+	struct hiddev_usage_ref *uref = &uref_multi.uref;
 	struct hiddev_devinfo dinfo;
 	struct hid_report *report;
 	struct hid_field *field;
-	void __user *user_arg = (void __user *)arg;
 	int i;
 
 	if (!hiddev->exist)
@@ -402,7 +416,7 @@
 	switch (cmd) {
 
 	case HIDIOCGVERSION:
-		return put_user(HID_VERSION, (int __user *)arg);
+		return put_user(HID_VERSION, (int *) arg);
 
 	case HIDIOCAPPLICATION:
 		if (arg < 0 || arg >= hid->maxapplication)
@@ -427,13 +441,13 @@
 		dinfo.product = dev->descriptor.idProduct;
 		dinfo.version = dev->descriptor.bcdDevice;
 		dinfo.num_applications = hid->maxapplication;
-		if (copy_to_user(user_arg, &dinfo, sizeof(dinfo)))
+		if (copy_to_user((void *) arg, &dinfo, sizeof(dinfo)))
 			return -EFAULT;
 
 		return 0;
 
 	case HIDIOCGFLAG:
-		if (put_user(list->flags, (int __user *)arg))
+		if (put_user(list->flags, (int *) arg))
 			return -EFAULT;
 
 		return 0;
@@ -441,7 +455,7 @@
 	case HIDIOCSFLAG:
 		{
 			int newflags;
-			if (get_user(newflags, (int __user *)arg))
+			if (get_user(newflags, (int *) arg))
 				return -EFAULT;
 
 			if ((newflags & ~HIDDEV_FLAGS) != 0 ||
@@ -459,7 +473,7 @@
 			int idx, len;
 			char *buf;
 
-			if (get_user(idx, (int __user *)arg))
+			if (get_user(idx, (int *) arg))
 				return -EFAULT;
 
 			if ((buf = kmalloc(HID_STRING_SIZE, GFP_KERNEL)) == NULL)
@@ -470,7 +484,7 @@
 				return -EINVAL;
 			}
 
-			if (copy_to_user(user_arg+sizeof(int), buf, len+1)) {
+			if (copy_to_user((void *) (arg+sizeof(int)), buf, len+1)) {
 				kfree(buf);
 				return -EFAULT;
 			}
@@ -486,7 +500,7 @@
 		return 0;
 
 	case HIDIOCGREPORT:
-		if (copy_from_user(&rinfo, user_arg, sizeof(rinfo)))
+		if (copy_from_user(&rinfo, (void *) arg, sizeof(rinfo)))
 			return -EFAULT;
 
 		if (rinfo.report_type == HID_REPORT_TYPE_OUTPUT)
@@ -501,7 +515,7 @@
 		return 0;
 
 	case HIDIOCSREPORT:
-		if (copy_from_user(&rinfo, user_arg, sizeof(rinfo)))
+		if (copy_from_user(&rinfo, (void *) arg, sizeof(rinfo)))
 			return -EFAULT;
 
 		if (rinfo.report_type == HID_REPORT_TYPE_INPUT)
@@ -515,7 +529,7 @@
 		return 0;
 
 	case HIDIOCGREPORTINFO:
-		if (copy_from_user(&rinfo, user_arg, sizeof(rinfo)))
+		if (copy_from_user(&rinfo, (void *) arg, sizeof(rinfo)))
 			return -EFAULT;
 
 		if ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)
@@ -523,13 +537,13 @@
 
 		rinfo.num_fields = report->maxfield;
 
-		if (copy_to_user(user_arg, &rinfo, sizeof(rinfo)))
+		if (copy_to_user((void *) arg, &rinfo, sizeof(rinfo)))
 			return -EFAULT;
 
 		return 0;
 
 	case HIDIOCGFIELDINFO:
-		if (copy_from_user(&finfo, user_arg, sizeof(finfo)))
+		if (copy_from_user(&finfo, (void *) arg, sizeof(finfo)))
 			return -EFAULT;
 		rinfo.report_type = finfo.report_type;
 		rinfo.report_id = finfo.report_id;
@@ -556,37 +570,32 @@
 		finfo.unit_exponent = field->unit_exponent;
 		finfo.unit = field->unit;
 
-		if (copy_to_user(user_arg, &finfo, sizeof(finfo)))
+		if (copy_to_user((void *) arg, &finfo, sizeof(finfo)))
 			return -EFAULT;
 
 		return 0;
 
 	case HIDIOCGUCODE:
-		uref_multi = kmalloc(sizeof(struct hiddev_usage_ref_multi), GFP_KERNEL);
-		if (!uref_multi)
-			return -ENOMEM;
-		uref = &uref_multi->uref;
-		if (copy_from_user(uref, user_arg, sizeof(*uref))) 
-			goto fault;
+		if (copy_from_user(uref, (void *) arg, sizeof(*uref)))
+			return -EFAULT;
 
 		rinfo.report_type = uref->report_type;
 		rinfo.report_id = uref->report_id;
 		if ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)
-			goto inval;
+			return -EINVAL;
 
 		if (uref->field_index >= report->maxfield)
-			goto inval;
+			return -EINVAL;
 
 		field = report->field[uref->field_index];
 		if (uref->usage_index >= field->maxusage)
-			goto inval;
+			return -EINVAL;
 
 		uref->usage_code = field->usage[uref->usage_index].hid;
 
-		if (copy_to_user(user_arg, uref, sizeof(*uref)))
-			goto fault;
+		if (copy_to_user((void *) arg, uref, sizeof(*uref)))
+			return -EFAULT;
 
-		kfree(uref_multi);
 		return 0;
 
 	case HIDIOCGUSAGE:
@@ -594,93 +603,77 @@
 	case HIDIOCGUSAGES:
 	case HIDIOCSUSAGES:
 	case HIDIOCGCOLLECTIONINDEX:
-		uref_multi = kmalloc(sizeof(struct hiddev_usage_ref_multi), GFP_KERNEL);
-		if (!uref_multi)
-			return -ENOMEM;
-		uref = &uref_multi->uref;
 		if (cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) {
-			if (copy_from_user(uref_multi, user_arg, 
-					   sizeof(*uref_multi)))
-				goto fault;
+			if (copy_from_user(&uref_multi, (void *) arg, 
+					   sizeof(uref_multi)))
+				return -EFAULT;
 		} else {
-			if (copy_from_user(uref, user_arg, sizeof(*uref)))
-				goto fault;
+			if (copy_from_user(uref, (void *) arg, sizeof(*uref)))
+				return -EFAULT;
 		}
 
 		if (cmd != HIDIOCGUSAGE && 
 		    cmd != HIDIOCGUSAGES &&
 		    uref->report_type == HID_REPORT_TYPE_INPUT)
-			goto inval;
+			return -EINVAL;
 
 		if (uref->report_id == HID_REPORT_ID_UNKNOWN) {
 			field = hiddev_lookup_usage(hid, uref);
 			if (field == NULL)
-				goto inval;
+				return -EINVAL;
 		} else {
 			rinfo.report_type = uref->report_type;
 			rinfo.report_id = uref->report_id;
 			if ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)
-				goto inval;
+				return -EINVAL;
 
 			if (uref->field_index >= report->maxfield)
-				goto inval;
+				return -EINVAL;
 
 			field = report->field[uref->field_index];
+			if (uref->usage_index >= field->maxusage)
+				return -EINVAL;
 
-			if (cmd == HIDIOCGCOLLECTIONINDEX) {
-				if (uref->usage_index >= field->maxusage)
-					goto inval;
-			} else if (uref->usage_index >= field->report_count)
-				goto inval;
-
-			else if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&
-				 (uref_multi->num_values >= HID_MAX_MULTI_USAGES ||
-				  uref->usage_index + uref_multi->num_values >= field->report_count ||
-				  uref->usage_index + uref_multi->num_values < uref->usage_index))
-				goto inval;
+			if (cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) {
+				if (uref_multi.num_values >= HID_MAX_USAGES || 
+				    uref->usage_index >= field->maxusage || 
+				   (uref->usage_index + uref_multi.num_values) >= field->maxusage)
+					return -EINVAL;
 			}
+		}
 
 		switch (cmd) {
 			case HIDIOCGUSAGE:
 				uref->value = field->value[uref->usage_index];
-				if (copy_to_user(user_arg, uref, sizeof(*uref)))
-					goto fault;
-				goto goodreturn;
+				if (copy_to_user((void *) arg, uref, sizeof(*uref)))
+					return -EFAULT;
+				return 0;
 
 			case HIDIOCSUSAGE:
 				field->value[uref->usage_index] = uref->value;
-				goto goodreturn;
+				return 0;
 
 			case HIDIOCGCOLLECTIONINDEX:
-				kfree(uref_multi);
 				return field->usage[uref->usage_index].collection_index;
 			case HIDIOCGUSAGES:
-				for (i = 0; i < uref_multi->num_values; i++)
-					uref_multi->values[i] = 
+				for (i = 0; i < uref_multi.num_values; i++)
+					uref_multi.values[i] = 
 					    field->value[uref->usage_index + i];
-				if (copy_to_user(user_arg, uref_multi, 
-						 sizeof(*uref_multi)))
-					goto fault;
-				goto goodreturn;
+				if (copy_to_user((void *) arg, &uref_multi, 
+						 sizeof(uref_multi)))
+					return -EFAULT;
+				return 0;
 			case HIDIOCSUSAGES:
-				for (i = 0; i < uref_multi->num_values; i++)
+				for (i = 0; i < uref_multi.num_values; i++)
 					field->value[uref->usage_index + i] = 
-				  	    uref_multi->values[i];
-				goto goodreturn;
+				  	    uref_multi.values[i];
+				return 0;
 		}
 
-goodreturn:
-		kfree(uref_multi);
 		return 0;
-fault:
-		kfree(uref_multi);
-		return -EFAULT;
-inval:		
-		kfree(uref_multi);
-		return -EINVAL;
 
 	case HIDIOCGCOLLECTIONINFO:
-		if (copy_from_user(&cinfo, user_arg, sizeof(cinfo)))
+		if (copy_from_user(&cinfo, (void *) arg, sizeof(cinfo)))
 			return -EFAULT;
 
 		if (cinfo.index >= hid->maxcollection)
@@ -690,7 +683,7 @@
 		cinfo.usage = hid->collection[cinfo.index].usage;
 		cinfo.level = hid->collection[cinfo.index].level;
 
-		if (copy_to_user(user_arg, &cinfo, sizeof(cinfo)))
+		if (copy_to_user((void *) arg, &cinfo, sizeof(cinfo)))
 			return -EFAULT;
 		return 0;
 
@@ -706,7 +699,7 @@
 			len = strlen(hid->name) + 1;
 			if (len > _IOC_SIZE(cmd))
 				 len = _IOC_SIZE(cmd);
-			return copy_to_user(user_arg, hid->name, len) ?
+			return copy_to_user((char *) arg, hid->name, len) ?
 				-EFAULT : len;
 		}
 
@@ -717,7 +710,7 @@
 			len = strlen(hid->phys) + 1;
 			if (len > _IOC_SIZE(cmd))
 				len = _IOC_SIZE(cmd);
-			return copy_to_user(user_arg, hid->phys, len) ?
+			return copy_to_user((char *) arg, hid->phys, len) ?
 				-EFAULT : len;
 		}
 	}
@@ -764,7 +757,7 @@
 		return -1;
 	memset(hiddev, 0, sizeof(struct hiddev));
 
- 	retval = usb_register_dev(hid->intf, &hiddev_class);
+ 	retval = usb_register_dev(&hiddev->intf, &hiddev_class);
 	if (retval) {
 		err("Not able to get a minor for this device.");
 		kfree(hiddev);
@@ -773,12 +766,13 @@
 
 	init_waitqueue_head(&hiddev->wait);
 
- 	hiddev_table[hid->intf->minor - HIDDEV_MINOR_BASE] = hiddev;
+ 	hiddev->minor = hiddev->intf.minor;
+ 	hiddev_table[hiddev->intf.minor - HIDDEV_MINOR_BASE] = hiddev;
 
 	hiddev->hid = hid;
 	hiddev->exist = 1;
 
- 	hid->minor = hid->intf->minor;
+ 	hid->minor = hiddev->intf.minor;
 	hid->hiddev = hiddev;
 
 	return 0;
@@ -788,21 +782,17 @@
  * This is where hid.c calls us to disconnect a hiddev device from the
  * corresponding hid device (usually because the usb device has disconnected)
  */
-static struct usb_class_driver hiddev_class;
 void hiddev_disconnect(struct hid_device *hid)
 {
 	struct hiddev *hiddev = hid->hiddev;
 
 	hiddev->exist = 0;
 
-	hiddev_table[hiddev->hid->minor - HIDDEV_MINOR_BASE] = NULL;
-	usb_deregister_dev(hiddev->hid->intf, &hiddev_class);
-
 	if (hiddev->open) {
 		hid_close(hiddev->hid);
 		wake_up_interruptible(&hiddev->wait);
 	} else {
-		kfree(hiddev);
+		hiddev_cleanup(hiddev);
 	}
 }
 
diff -Naur linuxppc-2.6.9/drivers/usb/input/hid-tmff.c linuxppc-2.6.9-dream/drivers/usb/input/hid-tmff.c
--- linuxppc-2.6.9/drivers/usb/input/hid-tmff.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/hid-tmff.c	2005-09-19 21:40:05.000000000 +0200
@@ -110,7 +110,7 @@
 {
 	struct tmff_device *private;
 	struct list_head *pos;
-	struct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);
+	struct hid_input *hidinput = list_entry(&hid->inputs, struct hid_input, list);
 
 	private = kmalloc(sizeof(struct tmff_device), GFP_KERNEL);
 	if (!private)
diff -Naur linuxppc-2.6.9/drivers/usb/input/kbtab.c linuxppc-2.6.9-dream/drivers/usb/input/kbtab.c
--- linuxppc-2.6.9/drivers/usb/input/kbtab.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/kbtab.c	2005-09-19 21:40:05.000000000 +0200
@@ -26,9 +26,10 @@
 
 #define USB_VENDOR_ID_KBGEAR	0x084e
 
-static int kb_pressure_click = 0x10;
-module_param(kb_pressure_click, int, 0);
-MODULE_PARM_DESC(kb_pressure_click, "pressure threshold for clicks");
+static int       kb_pressure_click = 0x10;
+MODULE_PARM     (kb_pressure_click,"i");
+MODULE_PARM_DESC(kb_pressure_click,
+		 "pressure threshold for clicks");
 
 struct kbtab {
 	signed char *data;
@@ -66,8 +67,8 @@
 		goto exit;
 	}
 
-	kbtab->x = le16_to_cpu(get_unaligned((__le16 *) &data[1]));
-	kbtab->y = le16_to_cpu(get_unaligned((__le16 *) &data[3]));
+	kbtab->x = le16_to_cpu(get_unaligned((u16 *) &data[1]));
+	kbtab->y = le16_to_cpu(get_unaligned((u16 *) &data[3]));
 
 	kbtab->pressure = (data[5]);
 
@@ -94,7 +95,7 @@
 		     __FUNCTION__, retval);
 }
 
-static struct usb_device_id kbtab_ids[] = {
+struct usb_device_id kbtab_ids[] = {
 	{ USB_DEVICE(USB_VENDOR_ID_KBGEAR, 0x1001), .driver_info = 0 },
 	{ }
 };
@@ -181,7 +182,7 @@
 	kbtab->dev.dev = &intf->dev;
 	kbtab->usbdev = dev;
 
-	endpoint = &intf->cur_altsetting->endpoint[0].desc;
+	endpoint = &intf->altsetting[0].endpoint[0].desc;
 
 	usb_fill_int_urb(kbtab->irq, dev,
 			 usb_rcvintpipe(dev, endpoint->bEndpointAddress),
diff -Naur linuxppc-2.6.9/drivers/usb/input/Kconfig linuxppc-2.6.9-dream/drivers/usb/input/Kconfig
--- linuxppc-2.6.9/drivers/usb/input/Kconfig	2004-10-18 23:54:54.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/Kconfig	2005-09-19 21:40:05.000000000 +0200
@@ -21,7 +21,7 @@
 	  If unsure, say Y.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called usbhid.
+	  module will be called hid.
 
 comment "Input core support is needed for USB HID input layer or HIDBP support"
 	depends on USB && INPUT=n
@@ -191,19 +191,6 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called mtouchusb.
 
-config USB_EGALAX
-	tristate "eGalax TouchKit USB Touchscreen Driver"
-	depends on USB && INPUT
-	---help---
-	  Say Y here if you want to use a eGalax TouchKit USB
-	  Touchscreen controller.
-
-	  The driver has been tested on a Xenarc 700TSV monitor
-	  with eGalax touchscreen.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called touchkitusb.
-
 config USB_XPAD
 	tristate "X-Box gamepad support"
 	depends on USB && INPUT
@@ -219,16 +206,14 @@
 	  module will be called xpad.
 	  
 config USB_ATI_REMOTE
-	tristate "ATI / X10 USB RF remote control"
+	tristate "ATI USB RF remote control"
 	depends on USB && INPUT
 	---help---
-	  Say Y here if you want to use an ATI or X10 "Lola" USB remote control.
-	  These are RF remotes with USB receivers. 
-	  The ATI remote comes with many of ATI's All-In-Wonder video cards.
-	  The X10 "Lola" remote is available at:
-	     http://www.x10.com/products/lola_sg1.htm
-	  This driver provides mouse pointer, left and right mouse buttons, 
-	  and maps all the other remote buttons to keypress events.
+	  Say Y here if you want to use one of ATI's USB remote controls.
+	  These are RF remotes with USB receivers. They come with many of ATI's 
+	  All-In-Wonder video cards.  This driver provides mouse pointer, left
+          and right mouse buttons, and maps all the other remote buttons to
+	  keypress events.
 	  
 	  To compile this driver as a module, choose M here: the module will be
 	  called ati_remote.
diff -Naur linuxppc-2.6.9/drivers/usb/input/Makefile linuxppc-2.6.9-dream/drivers/usb/input/Makefile
--- linuxppc-2.6.9/drivers/usb/input/Makefile	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/Makefile	2005-09-19 21:40:05.000000000 +0200
@@ -3,37 +3,36 @@
 #
 
 # Multipart objects.
-usbhid-objs	:= hid-core.o
+hid-objs	:= hid-core.o
 
 # Optional parts of multipart objects.
 
 ifeq ($(CONFIG_USB_HIDDEV),y)
-	usbhid-objs	+= hiddev.o
+	hid-objs        += hiddev.o
 endif
 ifeq ($(CONFIG_USB_HIDINPUT),y)
-	usbhid-objs	+= hid-input.o
+	hid-objs        += hid-input.o
 endif
 ifeq ($(CONFIG_HID_PID),y)
-	usbhid-objs	+= pid.o
+	hid-objs	+= pid.o
 endif
 ifeq ($(CONFIG_LOGITECH_FF),y)
-	usbhid-objs	+= hid-lgff.o
+	hid-objs	+= hid-lgff.o
 endif
 ifeq ($(CONFIG_THRUSTMASTER_FF),y)
-	usbhid-objs	+= hid-tmff.o
+	hid-objs	+= hid-tmff.o
 endif
 ifeq ($(CONFIG_HID_FF),y)
-	usbhid-objs	+= hid-ff.o
+	hid-objs	+= hid-ff.o
 endif
 
 obj-$(CONFIG_USB_AIPTEK)	+= aiptek.o
 obj-$(CONFIG_USB_ATI_REMOTE)	+= ati_remote.o
-obj-$(CONFIG_USB_HID)		+= usbhid.o
+obj-$(CONFIG_USB_HID)		+= hid.o
 obj-$(CONFIG_USB_KBD)		+= usbkbd.o
 obj-$(CONFIG_USB_KBTAB)		+= kbtab.o
 obj-$(CONFIG_USB_MOUSE)		+= usbmouse.o
 obj-$(CONFIG_USB_MTOUCH)	+= mtouchusb.o
-obj-$(CONFIG_USB_EGALAX)	+= touchkitusb.o
 obj-$(CONFIG_USB_POWERMATE)	+= powermate.o
 obj-$(CONFIG_USB_WACOM)		+= wacom.o
 obj-$(CONFIG_USB_XPAD)		+= xpad.o
diff -Naur linuxppc-2.6.9/drivers/usb/input/mtouchusb.c linuxppc-2.6.9-dream/drivers/usb/input/mtouchusb.c
--- linuxppc-2.6.9/drivers/usb/input/mtouchusb.c	2004-10-18 23:54:31.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/mtouchusb.c	2005-09-19 21:40:05.000000000 +0200
@@ -28,12 +28,6 @@
  *    Complete rewrite using Linux Input in 2.6.3
  *    Unfortunately no calibration support at this time
  *
- *  1.4 04/25/2004 (TEJ) tejohnson@yahoo.com
- *    Changed reset from standard USB dev reset to vendor reset
- *    Changed data sent to host from compensated to raw coordinates
- *    Eliminated vendor/product module params
- *    Performed multiple successfull tests with an EXII-5010UC
- *
  *****************************************************************************/
 
 #include <linux/config.h>
@@ -51,28 +45,25 @@
 #include <linux/init.h>
 #include <linux/usb.h>
 
-#define MTOUCHUSB_MIN_XC                0x0
-#define MTOUCHUSB_MAX_XC                0x4000
+#define MTOUCHUSB_MIN_XC                0xc8
+#define MTOUCHUSB_MAX_XC                0xff78
 #define MTOUCHUSB_XC_FUZZ               0x0
 #define MTOUCHUSB_XC_FLAT               0x0
 #define MTOUCHUSB_MIN_YC                0x0
-#define MTOUCHUSB_MAX_YC                0x4000
+#define MTOUCHUSB_MAX_YC                0xff78
 #define MTOUCHUSB_YC_FUZZ               0x0
 #define MTOUCHUSB_YC_FLAT               0x0
-
-#define MTOUCHUSB_ASYNC_REPORT          1
-#define MTOUCHUSB_RESET                 7
-#define MTOUCHUSB_REPORT_DATA_SIZE      11
+#define MTOUCHUSB_ASYC_REPORT           1
+#define MTOUCHUSB_REPORT_SIZE_DATA      11
 #define MTOUCHUSB_REQ_CTRLLR_ID         10
 
-#define MTOUCHUSB_GET_XC(data)          (data[8]<<8 | data[7])
-#define MTOUCHUSB_GET_YC(data)          (data[10]<<8 | data[9])
+#define MTOUCHUSB_GET_XC(data)          (data[4]<<8 | data[3])
+#define MTOUCHUSB_GET_YC(data)          (data[6]<<8 | data[5])
 #define MTOUCHUSB_GET_TOUCHED(data)     ((data[2] & 0x40) ? 1:0)
 
-#define DRIVER_VERSION "v1.4"
+#define DRIVER_VERSION "v0.1"
 #define DRIVER_AUTHOR "Todd E. Johnson, tejohnson@yahoo.com"
-#define DRIVER_DESC "3M USB Touchscreen Driver"
-#define DRIVER_LICENSE "GPL"
+#define DRIVER_DESC "Microtouch USB HID Touchscreen Driver"
 
 struct mtouch_usb {
         unsigned char *data;
@@ -85,9 +76,11 @@
         char phys[64];
 };
 
+static __s32 vendor=-1, product=-1;
+
 static struct usb_device_id mtouchusb_devices [] = {
-        { USB_DEVICE(0x0596, 0x0001) },
-        { }
+        { USB_DEVICE(0x0596, 0x0001) }, /* 3M (Formerly MicroTouch) 14-206 */
+        { }                             /* Terminating entry */
 };
 
 static void mtouchusb_irq(struct urb *urb, struct pt_regs *regs)
@@ -142,10 +135,8 @@
 
         mtouch->irq->dev = mtouch->udev;
 
-        if (usb_submit_urb (mtouch->irq, GFP_ATOMIC)) {
-                mtouch->open--;
+        if (usb_submit_urb (mtouch->irq, GFP_ATOMIC))
                 return -EIO;
-        }
 
         return 0;
 }
@@ -162,7 +153,7 @@
 {
         dbg("%s - called", __FUNCTION__);
 
-        mtouch->data = usb_buffer_alloc(udev, MTOUCHUSB_REPORT_DATA_SIZE,
+        mtouch->data = usb_buffer_alloc(udev, MTOUCHUSB_REPORT_SIZE_DATA,
                                         SLAB_ATOMIC, &mtouch->data_dma);
 
         if (!mtouch->data)
@@ -176,7 +167,7 @@
         dbg("%s - called", __FUNCTION__);
 
         if (mtouch->data)
-                usb_buffer_free(udev, MTOUCHUSB_REPORT_DATA_SIZE,
+                usb_buffer_free(udev, MTOUCHUSB_REPORT_SIZE_DATA,
                                 mtouch->data, mtouch->data_dma);
 }
 
@@ -189,8 +180,41 @@
         char path[64];
         char *buf;
         int nRet;
+        int ix;
+        char valid_device = 0;
 
         dbg("%s - called", __FUNCTION__);
+        if (vendor != -1 && product != -1) {
+                info("%s - User specified USB Touch -- Vend:Prod - %x:%x",
+                     __FUNCTION__, vendor, product);
+        }
+
+        for (ix = 0; ix < sizeof (mtouchusb_devices) /
+             sizeof (struct usb_device_id); ix++) {
+                if ((udev->descriptor.idVendor ==
+                     mtouchusb_devices [ix].idVendor) &&
+                     (udev->descriptor.idProduct ==
+                     mtouchusb_devices [ix].idProduct)) {
+                        valid_device = 1;
+                        break;
+                }
+        }
+
+        if (udev->descriptor.idVendor == vendor &&
+            udev->descriptor.idProduct == product) {  /* User specified */
+                valid_device = 1;
+        }
+
+        if (!valid_device) {
+                err("%s - No valid device!", __FUNCTION__);
+                return -EIO;
+        }
+
+        if (udev->descriptor.bNumConfigurations != 1) {
+                err("%s -  Only one device configuration is supported.",
+                    __FUNCTION__);
+                return -EIO;
+        }
 
         dbg("%s - setting interface", __FUNCTION__);
         interface = intf->cur_altsetting;
@@ -198,6 +222,11 @@
         dbg("%s - setting endpoint", __FUNCTION__);
         endpoint = &interface->endpoint[0].desc;
 
+        if (interface->desc.bNumEndpoints != 1) {
+                err("%s - Only one endpoint is supported.", __FUNCTION__);
+                return -EIO;
+        }
+
         if (!(mtouch = kmalloc (sizeof (struct mtouch_usb), GFP_KERNEL))) {
                 err("%s - Out of memory.", __FUNCTION__);
                 return -ENOMEM;
@@ -237,8 +266,8 @@
         mtouch->input.absmax[ABS_X] =  MTOUCHUSB_MAX_XC;
         mtouch->input.absfuzz[ABS_X] = MTOUCHUSB_XC_FUZZ;
         mtouch->input.absflat[ABS_X] = MTOUCHUSB_XC_FLAT;
-        mtouch->input.absmin[ABS_Y] =  MTOUCHUSB_MIN_YC;
-        mtouch->input.absmax[ABS_Y] =  MTOUCHUSB_MAX_YC;
+        mtouch->input.absmin[ABS_Y] =  MTOUCHUSB_MAX_YC;
+        mtouch->input.absmax[ABS_Y] =  MTOUCHUSB_MIN_YC;
         mtouch->input.absfuzz[ABS_Y] = MTOUCHUSB_YC_FUZZ;
         mtouch->input.absflat[ABS_Y] = MTOUCHUSB_YC_FLAT;
 
@@ -261,15 +290,15 @@
         kfree(buf);
 
         nRet = usb_control_msg(mtouch->udev,
-                               usb_rcvctrlpipe(udev, 0),
-                               MTOUCHUSB_RESET,
-                               USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-                               1,
+                               usb_rcvctrlpipe(udev, 0x80),
+                               USB_REQ_GET_CONFIGURATION,
+                               USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE,
                                0,
+                               0x81,
                                NULL,
                                0,
                                HZ * USB_CTRL_SET_TIMEOUT);
-        dbg("%s - usb_control_msg - MTOUCHUSB_RESET - bytes|err: %d",
+        dbg("%s - usb_control_msg - USB_REQ_GET_CONFIGURATION - bytes|err: %d",
             __FUNCTION__, nRet);
 
         dbg("%s - usb_alloc_urb: mtouch->irq", __FUNCTION__);
@@ -286,7 +315,7 @@
                          mtouch->udev,
                          usb_rcvintpipe(mtouch->udev, 0x81),
                          mtouch->data,
-                         MTOUCHUSB_REPORT_DATA_SIZE,
+                         MTOUCHUSB_REPORT_SIZE_DATA,
                          mtouchusb_irq,
                          mtouch,
                          endpoint->bInterval);
@@ -295,15 +324,15 @@
         input_register_device(&mtouch->input);
 
         nRet = usb_control_msg(mtouch->udev,
-                               usb_rcvctrlpipe(udev, 0),
-                               MTOUCHUSB_ASYNC_REPORT,
+                               usb_rcvctrlpipe(udev, 0x80),
+                               MTOUCHUSB_ASYC_REPORT,
                                USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-                               1,
-                               1,
+                               MTOUCHUSB_ASYC_REPORT,
+                               MTOUCHUSB_ASYC_REPORT,
                                NULL,
                                0,
                                HZ * USB_CTRL_SET_TIMEOUT);
-        dbg("%s - usb_control_msg - MTOUCHUSB_ASYNC_REPORT - bytes|err: %d",
+        dbg("%s - usb_control_msg - MTOUCHUSB_ASYC_REPORT - bytes|err: %d",
             __FUNCTION__, nRet);
 
         printk(KERN_INFO "input: %s on %s\n", mtouch->name, path);
@@ -354,3 +383,9 @@
 MODULE_AUTHOR( DRIVER_AUTHOR );
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
+MODULE_PARM(vendor, "i");
+MODULE_PARM_DESC(vendor, "User specified USB idVendor");
+MODULE_PARM(product, "i");
+MODULE_PARM_DESC(product, "User specified USB idProduct");
+
+
diff -Naur linuxppc-2.6.9/drivers/usb/input/powermate.c linuxppc-2.6.9-dream/drivers/usb/input/powermate.c
--- linuxppc-2.6.9/drivers/usb/input/powermate.c	2004-10-18 23:54:32.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/powermate.c	2005-09-19 21:40:05.000000000 +0200
@@ -33,7 +33,6 @@
 #include <linux/input.h>
 #include <linux/module.h>
 #include <linux/init.h>
-#include <linux/spinlock.h>
 #include <linux/usb.h>
 
 #define POWERMATE_VENDOR	0x077d	/* Griffin Technology, Inc. */
@@ -68,7 +67,7 @@
 	dma_addr_t configcr_dma;
 	struct usb_device *udev;
 	struct input_dev input;
-	spinlock_t lock;
+	struct semaphore lock;
 	int static_brightness;
 	int pulse_speed;
 	int pulse_table;
@@ -117,7 +116,7 @@
 		     __FUNCTION__, retval);
 }
 
-/* Decide if we need to issue a control message and do so. Must be called with pm->lock taken */
+/* Decide if we need to issue a control message and do so. Must be called with pm->lock down */
 static void powermate_sync_state(struct powermate_device *pm)
 {
 	if (pm->requires_update == 0) 
@@ -182,7 +181,7 @@
 	pm->configcr->wLength = 0;
 
 	usb_fill_control_urb(pm->config, pm->udev, usb_sndctrlpipe(pm->udev, 0),
-			     (void *) pm->configcr, NULL, 0,
+			     (void *) pm->configcr, 0, 0,
 			     powermate_config_complete, pm);
 	pm->config->setup_dma = pm->configcr_dma;
 	pm->config->transfer_flags |= URB_NO_SETUP_DMA_MAP;
@@ -195,22 +194,19 @@
 static void powermate_config_complete(struct urb *urb, struct pt_regs *regs)
 {
 	struct powermate_device *pm = urb->context;
-	unsigned long flags;
 
 	if (urb->status)
 		printk(KERN_ERR "powermate: config urb returned %d\n", urb->status);
 	
-	spin_lock_irqsave(&pm->lock, flags);
+	down(&pm->lock);
 	powermate_sync_state(pm);
-	spin_unlock_irqrestore(&pm->lock, flags);
+	up(&pm->lock);
 }
 
 /* Set the LED up as described and begin the sync with the hardware if required */
 static void powermate_pulse_led(struct powermate_device *pm, int static_brightness, int pulse_speed, 
 				int pulse_table, int pulse_asleep, int pulse_awake)
 {
-	unsigned long flags;
-
 	if (pulse_speed < 0)
 		pulse_speed = 0;
 	if (pulse_table < 0)
@@ -223,8 +219,7 @@
 	pulse_asleep = !!pulse_asleep;
 	pulse_awake = !!pulse_awake;
 
-
-	spin_lock_irqsave(&pm->lock, flags);
+	down(&pm->lock);
 
 	/* mark state updates which are required */
 	if (static_brightness != pm->static_brightness){
@@ -247,7 +242,7 @@
 
 	powermate_sync_state(pm);
    
-	spin_unlock_irqrestore(&pm->lock, flags);
+	up(&pm->lock);
 }
 
 /* Callback from the Input layer when an event arrives from userspace to configure the LED */
@@ -310,7 +305,7 @@
 	int pipe, maxp;
 	char path[64];
 
-	interface = intf->cur_altsetting;
+	interface = intf->altsetting + 0;
 	endpoint = &interface->endpoint[0].desc;
 	if (!(endpoint->bEndpointAddress & 0x80))
 		return -EIO;
@@ -349,7 +344,7 @@
 		return -ENOMEM;
 	}
 
-	pm->lock = SPIN_LOCK_UNLOCKED;
+	init_MUTEX(&pm->lock);
 	init_input_dev(&pm->input);
 
 	/* get a handle to the interrupt data pipe */
@@ -416,6 +411,7 @@
 
 	usb_set_intfdata(intf, NULL);
 	if (pm) {
+		down(&pm->lock);
 		pm->requires_update = 0;
 		usb_unlink_urb(pm->irq);
 		input_unregister_device(&pm->input);
diff -Naur linuxppc-2.6.9/drivers/usb/input/touchkitusb.c linuxppc-2.6.9-dream/drivers/usb/input/touchkitusb.c
--- linuxppc-2.6.9/drivers/usb/input/touchkitusb.c	2004-10-18 23:53:41.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/touchkitusb.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,310 +0,0 @@
-/******************************************************************************
- * touchkitusb.c  --  Driver for eGalax TouchKit USB Touchscreens
- *
- * Copyright (C) 2004 by Daniel Ritz
- * Copyright (C) by Todd E. Johnson (mtouchusb.c)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- * Based upon mtouchusb.c
- *
- *****************************************************************************/
-
-//#define DEBUG
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/input.h>
-#include <linux/module.h>
-#include <linux/init.h>
-
-#if !defined(DEBUG) && defined(CONFIG_USB_DEBUG)
-#define DEBUG
-#endif
-#include <linux/usb.h>
-
-
-#define TOUCHKIT_MIN_XC			0x0
-#define TOUCHKIT_MAX_XC			0x07ff
-#define TOUCHKIT_XC_FUZZ		0x0
-#define TOUCHKIT_XC_FLAT		0x0
-#define TOUCHKIT_MIN_YC			0x0
-#define TOUCHKIT_MAX_YC			0x07ff
-#define TOUCHKIT_YC_FUZZ		0x0
-#define TOUCHKIT_YC_FLAT		0x0
-#define TOUCHKIT_REPORT_DATA_SIZE	8
-
-#define TOUCHKIT_DOWN			0x01
-#define TOUCHKIT_POINT_TOUCH		0x81
-#define TOUCHKIT_POINT_NOTOUCH		0x80
-
-#define TOUCHKIT_GET_TOUCHED(dat)	((((dat)[0]) & TOUCHKIT_DOWN) ? 1 : 0)
-#define TOUCHKIT_GET_X(dat)		(((dat)[3] << 7) | (dat)[4])
-#define TOUCHKIT_GET_Y(dat)		(((dat)[1] << 7) | (dat)[2])
-
-#define DRIVER_VERSION			"v0.1"
-#define DRIVER_AUTHOR			"Daniel Ritz <daniel.ritz@gmx.ch>"
-#define DRIVER_DESC			"eGalax TouchKit USB HID Touchscreen Driver"
-
-struct touchkit_usb {
-	unsigned char *data;
-	dma_addr_t data_dma;
-	struct urb *irq;
-	struct usb_device *udev;
-	struct input_dev input;
-	int open;
-	char name[128];
-	char phys[64];
-};
-
-static struct usb_device_id touchkit_devices[] = {
-	{USB_DEVICE(0x3823, 0x0001)},
-	{USB_DEVICE(0x0eef, 0x0001)},
-	{}
-};
-
-static void touchkit_irq(struct urb *urb, struct pt_regs *regs)
-{
-	struct touchkit_usb *touchkit = urb->context;
-	int retval;
-
-	switch (urb->status) {
-	case 0:
-		/* success */
-		break;
-	case -ETIMEDOUT:
-		/* this urb is timing out */
-		dbg("%s - urb timed out - was the device unplugged?",
-		    __FUNCTION__);
-		return;
-	case -ECONNRESET:
-	case -ENOENT:
-	case -ESHUTDOWN:
-		/* this urb is terminated, clean up */
-		dbg("%s - urb shutting down with status: %d",
-		    __FUNCTION__, urb->status);
-		return;
-	default:
-		dbg("%s - nonzero urb status received: %d",
-		    __FUNCTION__, urb->status);
-		goto exit;
-	}
-
-	input_regs(&touchkit->input, regs);
-	input_report_key(&touchkit->input, BTN_TOUCH,
-	                 TOUCHKIT_GET_TOUCHED(touchkit->data));
-	input_report_abs(&touchkit->input, ABS_X,
-	                 TOUCHKIT_GET_X(touchkit->data));
-	input_report_abs(&touchkit->input, ABS_Y,
-	                 TOUCHKIT_GET_Y(touchkit->data));
-	input_sync(&touchkit->input);
-
-exit:
-	retval = usb_submit_urb(urb, GFP_ATOMIC);
-	if (retval)
-		err("%s - usb_submit_urb failed with result: %d",
-		    __FUNCTION__, retval);
-}
-
-static int touchkit_open(struct input_dev *input)
-{
-	struct touchkit_usb *touchkit = input->private;
-
-	if (touchkit->open++)
-		return 0;
-
-	touchkit->irq->dev = touchkit->udev;
-
-	if (usb_submit_urb(touchkit->irq, GFP_ATOMIC)) {
-		touchkit->open--;
-		return -EIO;
-	}
-
-	return 0;
-}
-
-static void touchkit_close(struct input_dev *input)
-{
-	struct touchkit_usb *touchkit = input->private;
-
-	if (!--touchkit->open)
-		usb_unlink_urb(touchkit->irq);
-}
-
-static int touchkit_alloc_buffers(struct usb_device *udev,
-				  struct touchkit_usb *touchkit)
-{
-	touchkit->data = usb_buffer_alloc(udev, TOUCHKIT_REPORT_DATA_SIZE,
-	                                  SLAB_ATOMIC, &touchkit->data_dma);
-
-	if (!touchkit->data)
-		return -1;
-
-	return 0;
-}
-
-static void touchkit_free_buffers(struct usb_device *udev,
-				  struct touchkit_usb *touchkit)
-{
-	if (touchkit->data)
-		usb_buffer_free(udev, TOUCHKIT_REPORT_DATA_SIZE,
-		                touchkit->data, touchkit->data_dma);
-}
-
-static int touchkit_probe(struct usb_interface *intf,
-			  const struct usb_device_id *id)
-{
-	int ret;
-	struct touchkit_usb *touchkit;
-	struct usb_host_interface *interface;
-	struct usb_endpoint_descriptor *endpoint;
-	struct usb_device *udev = interface_to_usbdev(intf);
-	char path[64];
-	char *buf;
-
-	interface = intf->cur_altsetting;
-	endpoint = &interface->endpoint[0].desc;
-
-	touchkit = kmalloc(sizeof(struct touchkit_usb), GFP_KERNEL);
-	if (!touchkit)
-		return -ENOMEM;
-
-	memset(touchkit, 0, sizeof(struct touchkit_usb));
-	touchkit->udev = udev;
-
-	if (touchkit_alloc_buffers(udev, touchkit)) {
-		ret = -ENOMEM;
-		goto out_free;
-	}
-
-	touchkit->input.private = touchkit;
-	touchkit->input.open = touchkit_open;
-	touchkit->input.close = touchkit_close;
-
-	usb_make_path(udev, path, 64);
-	sprintf(touchkit->phys, "%s/input0", path);
-
-	touchkit->input.name = touchkit->name;
-	touchkit->input.phys = touchkit->phys;
-	touchkit->input.id.bustype = BUS_USB;
-	touchkit->input.id.vendor = udev->descriptor.idVendor;
-	touchkit->input.id.product = udev->descriptor.idProduct;
-	touchkit->input.id.version = udev->descriptor.bcdDevice;
-	touchkit->input.dev = &intf->dev;
-
-	touchkit->input.evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
-	touchkit->input.absbit[0] = BIT(ABS_X) | BIT(ABS_Y);
-	touchkit->input.keybit[LONG(BTN_TOUCH)] = BIT(BTN_TOUCH);
-
-	/* Used to Scale Compensated Data */
-	touchkit->input.absmin[ABS_X] = TOUCHKIT_MIN_XC;
-	touchkit->input.absmax[ABS_X] = TOUCHKIT_MAX_XC;
-	touchkit->input.absfuzz[ABS_X] = TOUCHKIT_XC_FUZZ;
-	touchkit->input.absflat[ABS_X] = TOUCHKIT_XC_FLAT;
-	touchkit->input.absmin[ABS_Y] = TOUCHKIT_MIN_YC;
-	touchkit->input.absmax[ABS_Y] = TOUCHKIT_MAX_YC;
-	touchkit->input.absfuzz[ABS_Y] = TOUCHKIT_YC_FUZZ;
-	touchkit->input.absflat[ABS_Y] = TOUCHKIT_YC_FLAT;
-
-	buf = kmalloc(63, GFP_KERNEL);
-	if (!buf) {
-		ret = -ENOMEM;
-		goto out_free_buffers;
-	}
-
-	if (udev->descriptor.iManufacturer &&
-	    usb_string(udev, udev->descriptor.iManufacturer, buf, 63) > 0)
-		strcat(touchkit->name, buf);
-	if (udev->descriptor.iProduct &&
-	    usb_string(udev, udev->descriptor.iProduct, buf, 63) > 0)
-		sprintf(touchkit->name, "%s %s", touchkit->name, buf);
-
-	if (!strlen(touchkit->name))
-		sprintf(touchkit->name, "USB Touchscreen %04x:%04x",
-		        touchkit->input.id.vendor, touchkit->input.id.product);
-
-	kfree(buf);
-
-	touchkit->irq = usb_alloc_urb(0, GFP_KERNEL);
-	if (!touchkit->irq) {
-		dbg("%s - usb_alloc_urb failed: touchkit->irq", __FUNCTION__);
-		ret = -ENOMEM;
-		goto out_free_buffers;
-	}
-
-	usb_fill_int_urb(touchkit->irq, touchkit->udev,
-	                 usb_rcvintpipe(touchkit->udev, 0x81),
-	                 touchkit->data, TOUCHKIT_REPORT_DATA_SIZE,
-	                 touchkit_irq, touchkit, endpoint->bInterval);
-
-	input_register_device(&touchkit->input);
-
-	printk(KERN_INFO "input: %s on %s\n", touchkit->name, path);
-	usb_set_intfdata(intf, touchkit);
-
-	return 0;
-
-out_free_buffers:
-	touchkit_free_buffers(udev, touchkit);
-out_free:
-	kfree(touchkit);
-	return ret;
-}
-
-static void touchkit_disconnect(struct usb_interface *intf)
-{
-	struct touchkit_usb *touchkit = usb_get_intfdata(intf);
-
-	dbg("%s - called", __FUNCTION__);
-
-	if (!touchkit)
-		return;
-
-	dbg("%s - touchkit is initialized, cleaning up", __FUNCTION__);
-	usb_set_intfdata(intf, NULL);
-	input_unregister_device(&touchkit->input);
-	usb_unlink_urb(touchkit->irq);
-	usb_free_urb(touchkit->irq);
-	touchkit_free_buffers(interface_to_usbdev(intf), touchkit);
-	kfree(touchkit);
-}
-
-MODULE_DEVICE_TABLE(usb, touchkit_devices);
-
-static struct usb_driver touchkit_driver = {
-	.owner		= THIS_MODULE,
-	.name		= "touchkitusb",
-	.probe		= touchkit_probe,
-	.disconnect	= touchkit_disconnect,
-	.id_table	= touchkit_devices,
-};
-
-static int __init touchkit_init(void)
-{
-	return usb_register(&touchkit_driver);
-}
-
-static void __exit touchkit_cleanup(void)
-{
-	usb_deregister(&touchkit_driver);
-}
-
-module_init(touchkit_init);
-module_exit(touchkit_cleanup);
-
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
diff -Naur linuxppc-2.6.9/drivers/usb/input/wacom.c linuxppc-2.6.9-dream/drivers/usb/input/wacom.c
--- linuxppc-2.6.9/drivers/usb/input/wacom.c	2004-10-18 23:53:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/wacom.c	2005-09-19 21:40:05.000000000 +0200
@@ -285,8 +285,8 @@
 
 	input_regs(dev, regs);
 	input_report_key(dev, BTN_TOOL_PEN, 1);
-	input_report_abs(dev, ABS_X, le16_to_cpu(get_unaligned((__le16 *) &data[1])));
-	input_report_abs(dev, ABS_Y, le16_to_cpu(get_unaligned((__le16 *) &data[3])));
+	input_report_abs(dev, ABS_X, le16_to_cpu(get_unaligned((u16 *) &data[1])));
+	input_report_abs(dev, ABS_Y, le16_to_cpu(get_unaligned((u16 *) &data[3])));
 	input_report_abs(dev, ABS_PRESSURE, (signed char)data[6] + 127);
 	input_report_key(dev, BTN_TOUCH, ((signed char)data[6] > -80) && !(data[5] & 0x20));
 	input_report_key(dev, BTN_STYLUS, (data[5] & 0x40));
@@ -329,8 +329,8 @@
 	if (data[0] != 2)
 		dbg("wacom_graphire_irq: received unknown report #%d", data[0]);
 
-	x = le16_to_cpu(*(__le16 *) &data[2]);
-	y = le16_to_cpu(*(__le16 *) &data[4]);
+	x = le16_to_cpu(*(u16 *) &data[2]);
+	y = le16_to_cpu(*(u16 *) &data[4]);
 
 	input_regs(dev, regs);
 
@@ -367,7 +367,7 @@
 		input_report_abs(dev, ABS_Y, y);
 	}
 
-	input_report_abs(dev, ABS_PRESSURE, le16_to_cpu(*(__le16 *) &data[6]));
+	input_report_abs(dev, ABS_PRESSURE, le16_to_cpu(*(u16 *) &data[6]));
 	input_report_key(dev, BTN_TOUCH, data[1] & 0x01);
 	input_report_key(dev, BTN_STYLUS, data[1] & 0x02);
 	input_report_key(dev, BTN_STYLUS2, data[1] & 0x04);
@@ -456,8 +456,8 @@
 		goto exit;
 	}
 
-	input_report_abs(dev, ABS_X, be16_to_cpu(*(__be16 *) &data[2]));
-	input_report_abs(dev, ABS_Y, be16_to_cpu(*(__be16 *) &data[4]));
+	input_report_abs(dev, ABS_X, be16_to_cpu(*(u16 *) &data[2]));
+	input_report_abs(dev, ABS_Y, be16_to_cpu(*(u16 *) &data[4]));
 	input_report_abs(dev, ABS_DISTANCE, data[9]);
 
 	if ((data[1] & 0xb8) == 0xa0) {						/* general pen packet */
@@ -527,7 +527,7 @@
 		     __FUNCTION__, retval);
 }
 
-static struct wacom_features wacom_features[] = {
+struct wacom_features wacom_features[] = {
 	{ "Wacom Penpartner",    7,   5040,  3780,  255, 32, 0, wacom_penpartner_irq },
         { "Wacom Graphire",      8,  10206,  7422,  511, 32, 1, wacom_graphire_irq },
 	{ "Wacom Graphire2 4x5", 8,  10206,  7422,  511, 32, 1, wacom_graphire_irq },
@@ -556,7 +556,7 @@
  	{ }
 };
 
-static struct usb_device_id wacom_ids[] = {
+struct usb_device_id wacom_ids[] = {
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0x00) },
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0x10) },
 	{ USB_DEVICE(USB_VENDOR_ID_WACOM, 0x11) },
@@ -698,7 +698,7 @@
 	wacom->dev.dev = &intf->dev;
 	wacom->usbdev = dev;
 
-	endpoint = &intf->cur_altsetting->endpoint[0].desc;
+	endpoint = &intf->altsetting[0].endpoint[0].desc;
 
 	if (wacom->features->pktlen > 10)
 		BUG();
diff -Naur linuxppc-2.6.9/drivers/usb/input/xpad.c linuxppc-2.6.9-dream/drivers/usb/input/xpad.c
--- linuxppc-2.6.9/drivers/usb/input/xpad.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/input/xpad.c	2005-09-19 21:40:05.000000000 +0200
@@ -252,7 +252,7 @@
 		return -ENOMEM;
         }
 	
-	ep_irq_in = &intf->cur_altsetting->endpoint[0].desc;
+	ep_irq_in = &intf->altsetting[0].endpoint[0].desc;
 	
 	usb_fill_int_urb(xpad->irq_in, udev,
 			 usb_rcvintpipe(udev, ep_irq_in->bEndpointAddress),
diff -Naur linuxppc-2.6.9/drivers/usb/Kconfig linuxppc-2.6.9-dream/drivers/usb/Kconfig
--- linuxppc-2.6.9/drivers/usb/Kconfig	2004-10-18 23:53:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/Kconfig	2005-09-19 21:40:05.000000000 +0200
@@ -7,7 +7,7 @@
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
 config USB
 	tristate "Support for Host-side USB"
-	depends on PCI || SA1111 || ARCH_OMAP1510 || ARCH_OMAP1610 || ARCH_LH7A404
+	depends on PCI || SA1111 || ARCH_OMAP1510 || ARCH_OMAP1610 || OCP
 	---help---
 	  Universal Serial Bus (USB) is a specification for a serial bus
 	  subsystem which offers higher speeds and more features than the
diff -Naur linuxppc-2.6.9/drivers/usb/Makefile linuxppc-2.6.9-dream/drivers/usb/Makefile
--- linuxppc-2.6.9/drivers/usb/Makefile	2004-10-18 23:55:27.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/Makefile	2005-09-19 21:40:05.000000000 +0200
@@ -55,15 +55,11 @@
 obj-$(CONFIG_USB_SERIAL)	+= serial/
 
 obj-$(CONFIG_USB_AUERSWALD)	+= misc/
-obj-$(CONFIG_USB_CYTHERM)	+= misc/
 obj-$(CONFIG_USB_EMI26)		+= misc/
-obj-$(CONFIG_USB_EMI62)		+= misc/
 obj-$(CONFIG_USB_LCD)		+= misc/
-obj-$(CONFIG_USB_LED)		+= misc/
 obj-$(CONFIG_USB_LEGOTOWER)	+= misc/
 obj-$(CONFIG_USB_RIO500)	+= misc/
 obj-$(CONFIG_USB_SPEEDTOUCH)	+= misc/
 obj-$(CONFIG_USB_TEST)		+= misc/
 obj-$(CONFIG_USB_TIGL)		+= misc/
 obj-$(CONFIG_USB_USS720)	+= misc/
-obj-$(CONFIG_USB_PHIDGETSERVO)	+= misc/
diff -Naur linuxppc-2.6.9/drivers/usb/media/dabusb.c linuxppc-2.6.9-dream/drivers/usb/media/dabusb.c
--- linuxppc-2.6.9/drivers/usb/media/dabusb.c	2004-10-18 23:54:32.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/dabusb.c	2005-09-19 21:40:05.000000000 +0200
@@ -61,7 +61,7 @@
 
 static dabusb_t dabusb[NRDABUSB];
 static int buffers = 256;
-static struct usb_driver dabusb_driver;
+extern struct usb_driver dabusb_driver;
 
 /*-------------------------------------------------------------------*/
 
@@ -476,7 +476,7 @@
 	return 0;
 }
 
-static ssize_t dabusb_read (struct file *file, char __user *buf, size_t count, loff_t * ppos)
+static ssize_t dabusb_read (struct file *file, char *buf, size_t count, loff_t * ppos)
 {
 	pdabusb_t s = (pdabusb_t) file->private_data;
 	unsigned long flags;
@@ -616,7 +616,7 @@
 	file->f_pos = 0;
 	file->private_data = s;
 
-	return nonseekable_open(inode, file);
+	return 0;
 }
 
 static int dabusb_release (struct inode *inode, struct file *file)
@@ -670,7 +670,7 @@
 			break;
 		}
 
-		if (copy_from_user (pbulk, (void __user *) arg, sizeof (bulk_transfer_t))) {
+		if (copy_from_user (pbulk, (void *) arg, sizeof (bulk_transfer_t))) {
 			ret = -EFAULT;
 			kfree (pbulk);
 			break;
@@ -678,18 +678,18 @@
 
 		ret=dabusb_bulk (s, pbulk);
 		if(ret==0)
-			if (copy_to_user((void __user *)arg, pbulk,
+			if (copy_to_user((void *)arg, pbulk,
 					 sizeof(bulk_transfer_t)))
 				ret = -EFAULT;
 		kfree (pbulk);
 		break;
 
 	case IOCTL_DAB_OVERRUNS:
-		ret = put_user (s->overruns, (unsigned int __user *) arg);
+		ret = put_user (s->overruns, (unsigned int *) arg);
 		break;
 
 	case IOCTL_DAB_VERSION:
-		ret = put_user (version, (unsigned int __user *) arg);
+		ret = put_user (version, (unsigned int *) arg);
 		break;
 
 	default:
@@ -868,7 +868,7 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(buffers, int, 0);
+MODULE_PARM (buffers, "i");
 MODULE_PARM_DESC (buffers, "Number of buffers (default=256)");
 
 module_init (dabusb_init);
diff -Naur linuxppc-2.6.9/drivers/usb/media/dsbr100.c linuxppc-2.6.9-dream/drivers/usb/media/dsbr100.c
--- linuxppc-2.6.9/drivers/usb/media/dsbr100.c	2004-10-18 23:53:50.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/dsbr100.c	2005-09-19 21:40:05.000000000 +0200
@@ -33,9 +33,6 @@
 
  History:
 
- Version 0.40:
-  Markus: Updates for 2.6.x kernels, code layout changes, name sanitizing
-
  Version 0.30:
  	Markus: Updates for 2.5.x kernel and more ISO compliant source
 
@@ -78,17 +75,13 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v0.40"
+#define DRIVER_VERSION "v0.30"
 #define DRIVER_AUTHOR "Markus Demleitner <msdemlei@tucana.harvard.edu>"
 #define DRIVER_DESC "D-Link DSB-R100 USB FM radio driver"
 
 #define DSB100_VENDOR 0x04b4
 #define DSB100_PRODUCT 0x1002
 
-/* Commands the device appears to understand */
-#define DSB100_TUNE 1
-#define DSB100_ONOFF 2
-
 #define TB_LEN 16
 
 /* Frequency limits in MHz -- these are European values.  For Japanese
@@ -107,21 +100,17 @@
 static int usb_dsbr100_close(struct inode *inode, struct file *file);
 
 static int radio_nr = -1;
-module_param(radio_nr, int, 0);
+MODULE_PARM(radio_nr, "i");
 
-/* Data for one (physical) device */
-typedef struct {
-	struct usb_device *usbdev;
-	struct video_device *videodev;
+typedef struct
+{
+	struct usb_device *dev;
 	unsigned char transfer_buffer[TB_LEN];
 	int curfreq;
 	int stereo;
-	int users;
-	int removed;
-} dsbr100_device;
+} usb_dsbr100;
 
 
-/* File system interface */
 static struct file_operations usb_dsbr100_fops = {
 	.owner =	THIS_MODULE,
 	.open =		usb_dsbr100_open,
@@ -129,84 +118,65 @@
 	.ioctl =        usb_dsbr100_ioctl,
 	.llseek =       no_llseek,
 };
-
-/* V4L interface */
-static struct video_device dsbr100_videodev_template=
+static struct video_device usb_dsbr100_radio=
 {
 	.owner =	THIS_MODULE,
 	.name =		"D-Link DSB-R 100",
 	.type =		VID_TYPE_TUNER,
 	.hardware =	VID_HARDWARE_AZTECH,
 	.fops =         &usb_dsbr100_fops,
-	.release = video_device_release,
 };
 
-static struct usb_device_id usb_dsbr100_device_table [] = {
+static int users = 0;
+
+static struct usb_device_id usb_dsbr100_table [] = {
 	{ USB_DEVICE(DSB100_VENDOR, DSB100_PRODUCT) },
 	{ }						/* Terminating entry */
 };
 
-MODULE_DEVICE_TABLE (usb, usb_dsbr100_device_table);
+MODULE_DEVICE_TABLE (usb, usb_dsbr100_table);
 
-/* USB subsystem interface */
 static struct usb_driver usb_dsbr100_driver = {
 	.owner =	THIS_MODULE,
 	.name =		"dsbr100",
 	.probe =	usb_dsbr100_probe,
 	.disconnect =	usb_dsbr100_disconnect,
-	.id_table =	usb_dsbr100_device_table,
+	.id_table =	usb_dsbr100_table,
 };
 
-/* Low-level device interface begins here */
 
-/* switch on radio */
-static int dsbr100_start(dsbr100_device *radio)
+static int dsbr100_start(usb_dsbr100 *radio)
 {
-	if (usb_control_msg(radio->usbdev, usb_rcvctrlpipe(radio->usbdev, 0),
-			USB_REQ_GET_STATUS, 
-			USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,
-			0x00, 0xC7, radio->transfer_buffer, 8, 300)<0 ||
-	usb_control_msg(radio->usbdev, usb_rcvctrlpipe(radio->usbdev, 0),
-			DSB100_ONOFF, 
-			USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,
-			0x01, 0x00, radio->transfer_buffer, 8, 300)<0)
+	if (usb_control_msg(radio->dev, usb_rcvctrlpipe(radio->dev, 0),
+		0x00, 0xC0, 0x00, 0xC7, radio->transfer_buffer, 8, 300)<0 ||
+	    usb_control_msg(radio->dev, usb_rcvctrlpipe(radio->dev, 0),
+		0x02, 0xC0, 0x01, 0x00, radio->transfer_buffer, 8, 300)<0)
 		return -1;
 	return (radio->transfer_buffer)[0];
 }
 
 
-/* switch off radio */
-static int dsbr100_stop(dsbr100_device *radio)
+static int dsbr100_stop(usb_dsbr100 *radio)
 {
-	if (usb_control_msg(radio->usbdev, usb_rcvctrlpipe(radio->usbdev, 0),
-			USB_REQ_GET_STATUS, 
-			USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,
-			0x16, 0x1C, radio->transfer_buffer, 8, 300)<0 ||
-	usb_control_msg(radio->usbdev, usb_rcvctrlpipe(radio->usbdev, 0),
-			DSB100_ONOFF, 
-			USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,
-			0x00, 0x00, radio->transfer_buffer, 8, 300)<0)
+	if (usb_control_msg(radio->dev, usb_rcvctrlpipe(radio->dev, 0),
+		0x00, 0xC0, 0x16, 0x1C, radio->transfer_buffer, 8, 300)<0 ||
+	    usb_control_msg(radio->dev, usb_rcvctrlpipe(radio->dev, 0),
+		0x02, 0xC0, 0x00, 0x00, radio->transfer_buffer, 8, 300)<0)
 		return -1;
 	return (radio->transfer_buffer)[0];
 }
 
-/* set a frequency, freq is defined by v4l's TUNER_LOW, i.e. 1/16th kHz */
-static int dsbr100_setfreq(dsbr100_device *radio, int freq)
+
+static int dsbr100_setfreq(usb_dsbr100 *radio, int freq)
 {
 	freq = (freq/16*80)/1000+856;
-	if (usb_control_msg(radio->usbdev, usb_rcvctrlpipe(radio->usbdev, 0),
-			DSB100_TUNE, 
-			USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,
-			(freq>>8)&0x00ff, freq&0xff, 
-			radio->transfer_buffer, 8, 300)<0 ||
-	   usb_control_msg(radio->usbdev, usb_rcvctrlpipe(radio->usbdev, 0),
-		 	USB_REQ_GET_STATUS, 
-			USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,
-			0x96, 0xB7, radio->transfer_buffer, 8, 300)<0 ||
-	usb_control_msg(radio->usbdev, usb_rcvctrlpipe(radio->usbdev, 0),
-			USB_REQ_GET_STATUS, 
-			USB_TYPE_VENDOR | USB_RECIP_DEVICE |  USB_DIR_IN,
-			0x00, 0x24, radio->transfer_buffer, 8, 300)<0) {
+	if (usb_control_msg(radio->dev, usb_rcvctrlpipe(radio->dev, 0),
+		0x01, 0xC0, (freq>>8)&0x00ff, freq&0xff, 
+		radio->transfer_buffer, 8, 300)<0 ||
+	    usb_control_msg(radio->dev, usb_rcvctrlpipe(radio->dev, 0),
+		0x00, 0xC0, 0x96, 0xB7, radio->transfer_buffer, 8, 300)<0 ||
+	    usb_control_msg(radio->dev, usb_rcvctrlpipe(radio->dev, 0),
+		0x00, 0xC0, 0x00, 0x24, radio->transfer_buffer, 8, 300)<0) {
 		radio->stereo = -1;
 		return -1;
 	}
@@ -214,91 +184,61 @@
 	return (radio->transfer_buffer)[0];
 }
 
-/* return the device status.  This is, in effect, just whether it
-sees a stereo signal or not.  Pity. */
-static void dsbr100_getstat(dsbr100_device *radio)
-{
-	if (usb_control_msg(radio->usbdev, usb_rcvctrlpipe(radio->usbdev, 0),
-		USB_REQ_GET_STATUS, 
-		USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,
-		0x00 , 0x24, radio->transfer_buffer, 8, 300)<0)
+static void dsbr100_getstat(usb_dsbr100 *radio)
+{
+	if (usb_control_msg(radio->dev, usb_rcvctrlpipe(radio->dev, 0),
+		0x00, 0xC0, 0x00 , 0x24, radio->transfer_buffer, 8, 300)<0)
 		radio->stereo = -1;
 	else
 		radio->stereo = ! (radio->transfer_buffer[0]&0x01);
 }
 
 
-/* USB subsystem interface begins here */
-
-/* check if the device is present and register with v4l and
-usb if it is */
 static int usb_dsbr100_probe(struct usb_interface *intf, 
 			 const struct usb_device_id *id)
 {
-	dsbr100_device *radio;
+	usb_dsbr100 *radio;
 
-	if (!(radio = kmalloc(sizeof(dsbr100_device), GFP_KERNEL)))
+	if (!(radio = kmalloc(sizeof(usb_dsbr100),GFP_KERNEL)))
 		return -ENOMEM;
-	if (!(radio->videodev = video_device_alloc())) {
-		kfree(radio);
-		return -ENOMEM;
-	}
-	memcpy(radio->videodev, &dsbr100_videodev_template, 
-		sizeof(dsbr100_videodev_template));
-	radio->removed = 0;
-	radio->users = 0;
-	radio->usbdev = interface_to_usbdev(intf);
+	usb_dsbr100_radio.priv = radio;
+	radio->dev = interface_to_usbdev (intf);
 	radio->curfreq = FREQ_MIN*FREQ_MUL;
-	video_set_drvdata(radio->videodev, radio);
-	if (video_register_device(radio->videodev, VFL_TYPE_RADIO,
-		radio_nr)) {
-		warn("Could not register video device");
-		video_device_release(radio->videodev);
-		kfree(radio);
-		return -EIO;
-	}
-	usb_set_intfdata(intf, radio);
+	usb_set_intfdata (intf, radio);
 	return 0;
 }
 
-/* handle unplugging of the device, release data structures
-if nothing keeps us from doing it.  If something is still
-keeping us busy, the release callback of v4l will take care
-of releasing it.  stv680.c does not relase its private
-data, so I don't do this here either.  Checking out the
-code I'd expect I better did that, but if there's a memory
-leak here it's tiny (~50 bytes per disconnect) */
 static void usb_dsbr100_disconnect(struct usb_interface *intf)
 {
-	dsbr100_device *radio = usb_get_intfdata(intf);
+	usb_dsbr100 *radio = usb_get_intfdata (intf);
 
 	usb_set_intfdata (intf, NULL);
+
 	if (radio) {
-		video_unregister_device(radio->videodev);
-		radio->videodev = NULL;
-		if (radio->users) {
-			kfree(radio);
-		} else {
-			radio->removed = 1;
+		lock_kernel();
+		if (users) {
+			unlock_kernel();
+			return;
 		}
+		kfree(radio);
+		usb_dsbr100_radio.priv = NULL;
+		unlock_kernel();
 	}
 }
 
-
-/* Video for Linux interface */
-
 static int usb_dsbr100_do_ioctl(struct inode *inode, struct file *file,
 				unsigned int cmd, void *arg)
 {
-	dsbr100_device *radio=video_get_drvdata(video_devdata(file));
+	struct video_device *dev = video_devdata(file);
+	usb_dsbr100 *radio=dev->priv;
 
 	if (!radio)
-		return -EIO;
+		return -EINVAL;
 
-	switch(cmd) {
+	switch(cmd)
+	{
 		case VIDIOCGCAP: {
 			struct video_capability *v = arg;
-
 			memset(v, 0, sizeof(*v));
 			v->type = VID_TYPE_TUNER;
 			v->channels = 1;
@@ -308,7 +248,6 @@
 		}
 		case VIDIOCGTUNER: {
 			struct video_tuner *v = arg;
-
 			dsbr100_getstat(radio);
 			if(v->tuner)	/* Only 1 tuner */ 
 				return -EINVAL;
@@ -324,21 +263,21 @@
 		}
 		case VIDIOCSTUNER: {
 			struct video_tuner *v = arg;
-
 			if(v->tuner!=0)
 				return -EINVAL;
 			/* Only 1 tuner so no setting needed ! */
 			return 0;
 		}
-		case VIDIOCGFREQ: {
+		case VIDIOCGFREQ:
+		{
 			int *freq = arg;
-
 			if (radio->curfreq==-1)
 				return -EINVAL;
 			*freq = radio->curfreq;
 			return 0;
 		}
-		case VIDIOCSFREQ: {
+		case VIDIOCSFREQ:
+		{
 			int *freq = arg;
 
 			radio->curfreq = *freq;
@@ -348,7 +287,6 @@
 		}
 		case VIDIOCGAUDIO: {
 			struct video_audio *v = arg;
-
 			memset(v, 0, sizeof(*v));
 			v->flags |= VIDEO_AUDIO_MUTABLE;
 			v->mode = VIDEO_SOUND_STEREO;
@@ -359,9 +297,9 @@
 		}
 		case VIDIOCSAUDIO: {
 			struct video_audio *v = arg;
-
 			if (v->audio) 
 				return -EINVAL;
+
 			if (v->flags&VIDEO_AUDIO_MUTE) {
 				if (dsbr100_stop(radio)==-1)
 					warn("Radio did not respond properly");
@@ -384,40 +322,64 @@
 
 static int usb_dsbr100_open(struct inode *inode, struct file *file)
 {
-	dsbr100_device *radio=video_get_drvdata(video_devdata(file));
+	struct video_device *dev = video_devdata(file);
+	usb_dsbr100 *radio=dev->priv;
 
-	radio->users = 1;
-	if (dsbr100_start(radio)<0) {
-		warn("Radio did not start up properly");
-		radio->users = 0;
-		return -EIO;
+	if (! radio) {
+		warn("Radio not initialised");
+		return -EAGAIN;
 	}
+	if(users)
+	{
+		warn("Radio in use");
+		return -EBUSY;
+	}
+	users++;
+	if (dsbr100_start(radio)<0)
+		warn("Radio did not start up properly");
 	dsbr100_setfreq(radio, radio->curfreq);
 	return 0;
 }
 
 static int usb_dsbr100_close(struct inode *inode, struct file *file)
 {
-	dsbr100_device *radio=video_get_drvdata(video_devdata(file));
+	struct video_device *dev = video_devdata(file);
+	usb_dsbr100 *radio=dev->priv;
 
 	if (!radio)
 		return -ENODEV;
-	radio->users = 0;
-	if (radio->removed) {
-		kfree(radio);
-	}
+	users--;
 	return 0;
 }
 
 static int __init dsbr100_init(void)
 {
-	int retval = usb_register(&usb_dsbr100_driver);
+	int retval;
+	usb_dsbr100_radio.priv = NULL;
+	retval = usb_register(&usb_dsbr100_driver);
+	if (retval)
+		goto failed_usb_register;
+	retval = video_register_device(&usb_dsbr100_radio, VFL_TYPE_RADIO,
+				       radio_nr);
+	if (retval) {	
+		warn("Couldn't register video device");
+		goto failed_video_register;
+	}
 	info(DRIVER_VERSION ":" DRIVER_DESC);
+	return 0;
+failed_video_register:
+	usb_deregister(&usb_dsbr100_driver);
+failed_usb_register:
 	return retval;
 }
 
 static void __exit dsbr100_exit(void)
 {
+	usb_dsbr100 *radio=usb_dsbr100_radio.priv;
+
+	if (radio)
+		dsbr100_stop(radio);
+	video_unregister_device(&usb_dsbr100_radio);
 	usb_deregister(&usb_dsbr100_driver);
 }
 
diff -Naur linuxppc-2.6.9/drivers/usb/media/ibmcam.c linuxppc-2.6.9-dream/drivers/usb/media/ibmcam.c
--- linuxppc-2.6.9/drivers/usb/media/ibmcam.c	2004-10-18 23:53:44.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/ibmcam.c	2005-09-19 21:40:05.000000000 +0200
@@ -124,38 +124,38 @@
 /* Settings for camera model 3 */
 static int init_model3_input = 0;
 
-module_param(debug, int, 0);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug level: 0-9 (default=0)");
-module_param(flags, int, 0);
+MODULE_PARM(flags, "i");
 MODULE_PARM_DESC(flags, "Bitfield: 0=VIDIOCSYNC, 1=B/W, 2=show hints, 3=show stats, 4=test pattern, 5=separate frames, 6=clean frames");
-module_param(framerate, int, 0);
+MODULE_PARM(framerate, "i");
 MODULE_PARM_DESC(framerate, "Framerate setting: 0=slowest, 6=fastest (default=2)");
-module_param(lighting, int, 0);
+MODULE_PARM(lighting, "i");
 MODULE_PARM_DESC(lighting, "Photosensitivity: 0=bright, 1=medium (default), 2=low light");
-module_param(sharpness, int, 0);
+MODULE_PARM(sharpness, "i");
 MODULE_PARM_DESC(sharpness, "Model1 noise reduction: 0=smooth, 6=sharp (default=4)");
-module_param(size, int, 0);
+MODULE_PARM(size, "i");
 MODULE_PARM_DESC(size, "Image size: 0=128x96 1=160x120 2=176x144 3=320x240 4=352x240 5=352x288 6=640x480  (default=5)");
-module_param(init_brightness, int, 0);
+MODULE_PARM(init_brightness, "i");
 MODULE_PARM_DESC(init_brightness, "Brightness preconfiguration: 0-255 (default=128)");
-module_param(init_contrast, int, 0);
+MODULE_PARM(init_contrast, "i");
 MODULE_PARM_DESC(init_contrast, "Contrast preconfiguration: 0-255 (default=192)");
-module_param(init_color, int, 0);
+MODULE_PARM(init_color, "i");
 MODULE_PARM_DESC(init_color, "Color preconfiguration: 0-255 (default=128)");
-module_param(init_hue, int, 0);
+MODULE_PARM(init_hue, "i");
 MODULE_PARM_DESC(init_hue, "Hue preconfiguration: 0-255 (default=128)");
-module_param(hue_correction, int, 0);
+MODULE_PARM(hue_correction, "i");
 MODULE_PARM_DESC(hue_correction, "YUV colorspace regulation: 0-255 (default=128)");
 
-module_param(init_model2_rg2, int, 0);
+MODULE_PARM(init_model2_rg2, "i");
 MODULE_PARM_DESC(init_model2_rg2, "Model2 preconfiguration: 0-255 (default=47)");
-module_param(init_model2_sat, int, 0);
+MODULE_PARM(init_model2_sat, "i");
 MODULE_PARM_DESC(init_model2_sat, "Model2 preconfiguration: 0-255 (default=52)");
-module_param(init_model2_yb, int, 0);
+MODULE_PARM(init_model2_yb, "i");
 MODULE_PARM_DESC(init_model2_yb, "Model2 preconfiguration: 0-255 (default=160)");
 
 /* 01.01.08 - Added for RCA video in support -LO */
-module_param(init_model3_input, int, 0);
+MODULE_PARM(init_model3_input, "i");
 MODULE_PARM_DESC(init_model3_input, "Model3 input: 0=CCD 1=RCA");
 
 MODULE_AUTHOR ("Dmitri");
@@ -3647,7 +3647,7 @@
 {
 	struct usb_device *dev = interface_to_usbdev(intf);
 	struct uvd *uvd = NULL;
-	int ix, i, nas, model=0, canvasX=0, canvasY=0;
+	int i, nas, model=0, canvasX=0, canvasY=0;
 	int actInterface=-1, inactInterface=-1, maxPS=0;
 	__u8 ifnum = intf->altsetting->desc.bInterfaceNumber;
 	unsigned char video_ep = 0;
@@ -3718,7 +3718,7 @@
 	} while (0);
 
 	/* Validate found interface: must have one ISO endpoint */
-	nas = intf->num_altsetting;
+	nas = dev->actconfig->interface[ifnum]->num_altsetting;
 	if (debug > 0)
 		info("Number of alternate settings=%d.", nas);
 	if (nas < 2) {
@@ -3726,12 +3726,11 @@
 		return -ENODEV;
 	}
 	/* Validate all alternate settings */
-	for (ix=0; ix < nas; ix++) {
+	for (i=0; i < nas; i++) {
 		const struct usb_host_interface *interface;
 		const struct usb_endpoint_descriptor *endpoint;
 
-		interface = &intf->altsetting[ix];
-		i = interface->desc.bAlternateSetting;
+		interface = &dev->actconfig->interface[ifnum]->altsetting[i];
 		if (interface->desc.bNumEndpoints != 1) {
 			err("Interface %d. has %u. endpoints!",
 			    ifnum, (unsigned)(interface->desc.bNumEndpoints));
diff -Naur linuxppc-2.6.9/drivers/usb/media/Kconfig linuxppc-2.6.9-dream/drivers/usb/media/Kconfig
--- linuxppc-2.6.9/drivers/usb/media/Kconfig	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/Kconfig	2005-09-19 21:40:05.000000000 +0200
@@ -106,36 +106,61 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called ov511.
 
-config USB_SE401
-	tristate "USB SE401 Camera support"
+config USB_PWC
+	tristate "USB Philips Cameras"
 	depends on USB && VIDEO_DEV
 	---help---
-	  Say Y here if you want to connect this type of camera to your
-	  computer's USB port. See <file:Documentation/usb/se401.txt> for more
-	  information and for a list of supported cameras.
+	  Say Y or M here if you want to use one of these Philips & OEM
+          webcams:
+           * Philips PCA645, PCA646
+           * Philips PCVC675, PCVC680, PCVC690
+           * Philips PCVC720/40, PCVC730, PCVC740, PCVC750
+	   * Askey VC010
+	   * Logitech QuickCam Pro 3000, 4000, 'Zoom', 'Notebook Pro' 
+             and 'Orbit'/'Sphere'
+           * Samsung MPC-C10, MPC-C30
+	   * Creative Webcam 5, Pro Ex
+	   * SOTEC Afina Eye
+	   * Visionite VCS-UC300, VCS-UM100
+	   
+	  The PCA635, PCVC665 and PCVC720/20 are not supported by this driver
+	  and never will be, but the 665 and 720/20 are supported by other 
+	  drivers.
+
+	  This driver has an optional plugin (called PWCX), which is 
+	  distributed as a binary module only. It contains code that allow you 
+	  to use higher resolutions and framerates but may not be distributed 
+	  as source. But even without this plugin you can these cams for most
+	  applications.
+
+	  See <file:Documentation/usb/philips.txt> for more information and
+	  installation instructions.
+
+	  The built-in microphone is enabled by selecting USB Audio support.
 
 	  This driver uses the Video For Linux API. You must say Y or M to
-	  "Video For Linux" (under Multimedia Devices) to use this driver.
+	  "Video For Linux" (under Character Devices) to use this driver.
 	  Information on this API and pointers to "v4l" programs may be found
 	  at <file:Documentation/video4linux/API.html>.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called se401.
+	  module will be called pwc.
 
-config USB_SN9C102
-	tristate "USB SN9C10[12] PC Camera Controller support"
+config USB_SE401
+	tristate "USB SE401 Camera support"
 	depends on USB && VIDEO_DEV
 	---help---
-	  Say Y here if you want support for cameras based on SONiX SN9C101
-	  or SN9C102 PC Camera Controllers.
-
-	  See <file:Documentation/usb/sn9c102.txt> for more informations.
+	  Say Y here if you want to connect this type of camera to your
+	  computer's USB port. See <file:Documentation/usb/se401.txt> for more
+	  information and for a list of supported cameras.
 
 	  This driver uses the Video For Linux API. You must say Y or M to
-	  "Video For Linux" to use this driver.
+	  "Video For Linux" (under Multimedia Devices) to use this driver.
+	  Information on this API and pointers to "v4l" programs may be found
+	  at <file:Documentation/video4linux/API.html>.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called sn9c102.
+	  module will be called se401.
 
 config USB_STV680
 	tristate "USB STV680 (Pencam) Camera support"
@@ -156,7 +181,7 @@
 
 config USB_W9968CF
 	tristate "USB W996[87]CF JPEG Dual Mode Camera support"
-	depends on USB && VIDEO_DEV && I2C && VIDEO_OVCAMCHIP
+	depends on USB && VIDEO_DEV && I2C
 	---help---
 	  Say Y here if you want support for cameras based on OV681 or
 	  Winbond W9967CF/W9968CF JPEG USB Dual Mode Camera Chips.
@@ -165,13 +190,16 @@
 	  separate module only (released under GPL). It allows to use higher 
 	  resolutions and framerates, but cannot be included in the official 
 	  Linux kernel for performance purposes.
-
-	  See <file:Documentation/usb/w9968cf.txt> for more informations.
-
-	  This driver uses the Video For Linux and the I2C APIs. It needs the
-	  OmniVision Camera Chip support as well. You must say Y or M to
-	  "Video For Linux", "I2C Support" and "OmniVision Camera Chip 
-	  support" to use this driver.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called w9968cf.
+	  At the moment the driver needs a third-party module for the CMOS 
+	  sensors, which is available on internet: it is recommended to read
+	  <file:Documentation/usb/w9968cf.txt> for more informations and for
+	  a list of supported cameras.
+	
+	  This driver uses the Video For Linux and the I2C APIs. You must say
+	  Y or M to both "Video For Linux" and "I2C Support" to use this 
+	  driver.
+	
+	  This code is also available as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want).
+	  The module will be called w9968cf.o. If you want to compile it as a
+	  module, say M here and read <file:Documentation/kbuild/modules.txt>.
diff -Naur linuxppc-2.6.9/drivers/usb/media/konicawc.c linuxppc-2.6.9-dream/drivers/usb/media/konicawc.c
--- linuxppc-2.6.9/drivers/usb/media/konicawc.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/konicawc.c	2005-09-19 21:40:05.000000000 +0200
@@ -68,7 +68,7 @@
 /* Some default values for initial camera settings,
    can be set by modprobe */
 
-static int size;	
+static enum frame_sizes size;	
 static int speed = 6;		/* Speed (fps) 0 (slowest) to 6 (fastest) */
 static int brightness =	MAX_BRIGHTNESS/2;
 static int contrast =	MAX_CONTRAST/2;
@@ -324,7 +324,7 @@
         }
         urb->dev = uvd->dev;
         urb->status = 0;
-	ret = usb_submit_urb(urb, GFP_ATOMIC);
+        ret = usb_submit_urb(urb, GFP_KERNEL);
 	DEBUG(3, "submitting urb of length %d", urb->transfer_buffer_length);
         if(ret)
                 err("usb_submit_urb error (%d)", ret);
@@ -362,8 +362,8 @@
 		else if (!urb->status && !cam->last_data_urb->status)
 			len = konicawc_compress_iso(uvd, cam->last_data_urb, urb);
 
-		resubmit_urb(uvd, cam->last_data_urb);
 		resubmit_urb(uvd, urb);
+		resubmit_urb(uvd, cam->last_data_urb);
 		cam->last_data_urb = NULL;
 		uvd->stats.urb_length = len;
 		uvd->stats.data_count += len;
@@ -381,15 +381,9 @@
 	int i, errFlag;
 	struct konicawc *cam = (struct konicawc *)uvd->user_data;
 	int pktsz;
-	struct usb_interface *intf;
-	struct usb_host_interface *interface = NULL;
+	struct usb_host_interface *interface;
 
-	intf = usb_ifnum_to_if(dev, uvd->iface);
-	if (intf)
-		interface = usb_altnum_to_altsetting(intf,
-				spd_to_iface[cam->speed]);
-	if (!interface)
-		return -ENXIO;
+	interface = &dev->actconfig->interface[uvd->iface]->altsetting[spd_to_iface[cam->speed]];
 	pktsz = interface->endpoint[1].desc.wMaxPacketSize;
 	DEBUG(1, "pktsz = %d", pktsz);
 	if (!CAMERA_IS_OPERATIONAL(uvd)) {
@@ -727,7 +721,7 @@
 {
 	struct usb_device *dev = interface_to_usbdev(intf);
 	struct uvd *uvd = NULL;
-	int ix, i, nas;
+	int i, nas;
 	int actInterface=-1, inactInterface=-1, maxPS=0;
 	unsigned char video_ep = 0;
 
@@ -747,12 +741,11 @@
 		return -ENODEV;
 	}
 	/* Validate all alternate settings */
-	for (ix=0; ix < nas; ix++) {
+	for (i=0; i < nas; i++) {
 		const struct usb_host_interface *interface;
 		const struct usb_endpoint_descriptor *endpoint;
 
-		interface = &intf->altsetting[ix];
-		i = interface->desc.bAlternateSetting;
+		interface = &intf->altsetting[i];
 		if (interface->desc.bNumEndpoints != 2) {
 			err("Interface %d. has %u. endpoints!",
 			    interface->desc.bInterfaceNumber,
@@ -928,23 +921,23 @@
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Simon Evans <spse@secret.org.uk>");
 MODULE_DESCRIPTION(DRIVER_DESC);
-module_param(speed, int, 0);
+MODULE_PARM(speed, "i");
 MODULE_PARM_DESC(speed, "Initial speed: 0 (slowest) - 6 (fastest)");
-module_param(size, int, 0);
+MODULE_PARM(size, "i");
 MODULE_PARM_DESC(size, "Initial Size 0: 160x120 1: 160x136 2: 176x144 3: 320x240");
-module_param(brightness, int, 0);
+MODULE_PARM(brightness, "i");
 MODULE_PARM_DESC(brightness, "Initial brightness 0 - 108");
-module_param(contrast, int, 0);
+MODULE_PARM(contrast, "i");
 MODULE_PARM_DESC(contrast, "Initial contrast 0 - 108");
-module_param(saturation, int, 0);
+MODULE_PARM(saturation, "i");
 MODULE_PARM_DESC(saturation, "Initial saturation 0 - 108");
-module_param(sharpness, int, 0);
+MODULE_PARM(sharpness, "i");
 MODULE_PARM_DESC(sharpness, "Initial brightness 0 - 108");
-module_param(whitebal, int, 0);
+MODULE_PARM(whitebal, "i");
 MODULE_PARM_DESC(whitebal, "Initial white balance 0 - 363");
 
 #ifdef CONFIG_USB_DEBUG
-module_param(debug, int, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug level: 0-9 (default=0)");
 #endif
 
diff -Naur linuxppc-2.6.9/drivers/usb/media/Makefile linuxppc-2.6.9-dream/drivers/usb/media/Makefile
--- linuxppc-2.6.9/drivers/usb/media/Makefile	2004-10-18 23:53:05.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/Makefile	2005-09-19 21:40:05.000000000 +0200
@@ -2,15 +2,15 @@
 # Makefile for USB Media drivers
 #
 
-sn9c102-objs	:= sn9c102_core.o sn9c102_pas106b.o sn9c102_tas5110c1b.o sn9c102_tas5130d1b.o sn9c102_pas202bcb.o
+pwc-objs	:= pwc-if.o pwc-misc.o pwc-ctrl.o pwc-uncompress.o
 
 obj-$(CONFIG_USB_DABUSB)	+= dabusb.o
 obj-$(CONFIG_USB_DSBR)		+= dsbr100.o
 obj-$(CONFIG_USB_IBMCAM)	+= ibmcam.o usbvideo.o ultracam.o
 obj-$(CONFIG_USB_KONICAWC)	+= konicawc.o usbvideo.o
 obj-$(CONFIG_USB_OV511)		+= ov511.o
+obj-$(CONFIG_USB_PWC)		+= pwc.o
 obj-$(CONFIG_USB_SE401)		+= se401.o
-obj-$(CONFIG_USB_SN9C102)	+= sn9c102.o
 obj-$(CONFIG_USB_STV680)	+= stv680.o
 obj-$(CONFIG_USB_VICAM)		+= vicam.o usbvideo.o
 obj-$(CONFIG_USB_W9968CF)	+= w9968cf.o
diff -Naur linuxppc-2.6.9/drivers/usb/media/ov511.c linuxppc-2.6.9-dream/drivers/usb/media/ov511.c
--- linuxppc-2.6.9/drivers/usb/media/ov511.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/ov511.c	2005-09-19 21:40:05.000000000 +0200
@@ -16,7 +16,7 @@
  * Based on the Linux CPiA driver written by Peter Pregler,
  * Scott J. Bertin and Johannes Erdfelt.
  * 
- * Please see the file: Documentation/usb/ov511.txt
+ * Please see the file: linux/Documentation/usb/ov511.txt 
  * and the website at:  http://alpha.dyndns.org/ov511
  * for more info.
  *
@@ -119,79 +119,78 @@
 static int mirror;
 static int ov518_color;
 
-module_param(autobright, int, 0);
+MODULE_PARM(autobright, "i");
 MODULE_PARM_DESC(autobright, "Sensor automatically changes brightness");
-module_param(autogain, int, 0);
+MODULE_PARM(autogain, "i");
 MODULE_PARM_DESC(autogain, "Sensor automatically changes gain");
-module_param(autoexp, int, 0);
+MODULE_PARM(autoexp, "i");
 MODULE_PARM_DESC(autoexp, "Sensor automatically changes exposure");
-module_param(debug, int, 0);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug,
   "Debug level: 0=none, 1=inits, 2=warning, 3=config, 4=functions, 5=max");
-module_param(snapshot, int, 0);
+MODULE_PARM(snapshot, "i");
 MODULE_PARM_DESC(snapshot, "Enable snapshot mode");
-module_param(cams, int, 0);
+MODULE_PARM(cams, "i");
 MODULE_PARM_DESC(cams, "Number of simultaneous cameras");
-module_param(compress, int, 0);
+MODULE_PARM(compress, "i");
 MODULE_PARM_DESC(compress, "Turn on compression");
-module_param(testpat, int, 0);
+MODULE_PARM(testpat, "i");
 MODULE_PARM_DESC(testpat,
   "Replace image with vertical bar testpattern (only partially working)");
-module_param(dumppix, int, 0);
+MODULE_PARM(dumppix, "i");
 MODULE_PARM_DESC(dumppix, "Dump raw pixel data");
-module_param(led, int, 0);
+MODULE_PARM(led, "i");
 MODULE_PARM_DESC(led,
   "LED policy (OV511+ or later). 0=off, 1=on (default), 2=auto (on when open)");
-module_param(dump_bridge, int, 0);
+MODULE_PARM(dump_bridge, "i");
 MODULE_PARM_DESC(dump_bridge, "Dump the bridge registers");
-module_param(dump_sensor, int, 0);
+MODULE_PARM(dump_sensor, "i");
 MODULE_PARM_DESC(dump_sensor, "Dump the sensor registers");
-module_param(printph, int, 0);
+MODULE_PARM(printph, "i");
 MODULE_PARM_DESC(printph, "Print frame start/end headers");
-module_param(phy, int, 0);
+MODULE_PARM(phy, "i");
 MODULE_PARM_DESC(phy, "Prediction range (horiz. Y)");
-module_param(phuv, int, 0);
+MODULE_PARM(phuv, "i");
 MODULE_PARM_DESC(phuv, "Prediction range (horiz. UV)");
-module_param(pvy, int, 0);
+MODULE_PARM(pvy, "i");
 MODULE_PARM_DESC(pvy, "Prediction range (vert. Y)");
-module_param(pvuv, int, 0);
+MODULE_PARM(pvuv, "i");
 MODULE_PARM_DESC(pvuv, "Prediction range (vert. UV)");
-module_param(qhy, int, 0);
+MODULE_PARM(qhy, "i");
 MODULE_PARM_DESC(qhy, "Quantization threshold (horiz. Y)");
-module_param(qhuv, int, 0);
+MODULE_PARM(qhuv, "i");
 MODULE_PARM_DESC(qhuv, "Quantization threshold (horiz. UV)");
-module_param(qvy, int, 0);
+MODULE_PARM(qvy, "i");
 MODULE_PARM_DESC(qvy, "Quantization threshold (vert. Y)");
-module_param(qvuv, int, 0);
+MODULE_PARM(qvuv, "i");
 MODULE_PARM_DESC(qvuv, "Quantization threshold (vert. UV)");
-module_param(lightfreq, int, 0);
+MODULE_PARM(lightfreq, "i");
 MODULE_PARM_DESC(lightfreq,
   "Light frequency. Set to 50 or 60 Hz, or zero for default settings");
-module_param(bandingfilter, int, 0);
+MODULE_PARM(bandingfilter, "i");
 MODULE_PARM_DESC(bandingfilter,
   "Enable banding filter (to reduce effects of fluorescent lighting)");
-module_param(clockdiv, int, 0);
+MODULE_PARM(clockdiv, "i");
 MODULE_PARM_DESC(clockdiv, "Force pixel clock divisor to a specific value");
-module_param(packetsize, int, 0);
+MODULE_PARM(packetsize, "i");
 MODULE_PARM_DESC(packetsize, "Force a specific isoc packet size");
-module_param(framedrop, int, 0);
+MODULE_PARM(framedrop, "i");
 MODULE_PARM_DESC(framedrop, "Force a specific frame drop register setting");
-module_param(fastset, int, 0);
+MODULE_PARM(fastset, "i");
 MODULE_PARM_DESC(fastset, "Allows picture settings to take effect immediately");
-module_param(force_palette, int, 0);
+MODULE_PARM(force_palette, "i");
 MODULE_PARM_DESC(force_palette, "Force the palette to a specific value");
-module_param(backlight, int, 0);
+MODULE_PARM(backlight, "i");
 MODULE_PARM_DESC(backlight, "For objects that are lit from behind");
-static int num_uv;
-module_param_array(unit_video, int, num_uv, 0);
+MODULE_PARM(unit_video, "1-" __MODULE_STRING(OV511_MAX_UNIT_VIDEO) "i");
 MODULE_PARM_DESC(unit_video,
   "Force use of specific minor number(s). 0 is not allowed.");
-module_param(remove_zeros, int, 0);
+MODULE_PARM(remove_zeros, "i");
 MODULE_PARM_DESC(remove_zeros,
   "Remove zero-padding from uncompressed incoming data");
-module_param(mirror, int, 0);
+MODULE_PARM(mirror, "i");
 MODULE_PARM_DESC(mirror, "Reverse image horizontally");
-module_param(ov518_color, int, 0);
+MODULE_PARM(ov518_color, "i");
 MODULE_PARM_DESC(ov518_color, "Enable OV518 color (experimental)");
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
@@ -473,7 +472,7 @@
 
 	down(&ov->cbuf_lock);
 
-	*((__le32 *)ov->cbuf) = __cpu_to_le32(val);
+	*((u32 *)ov->cbuf) = __cpu_to_le32(val);
 
 	rc = usb_control_msg(ov->dev,
 			     usb_sndctrlpipe(ov->dev, 0),
@@ -1170,7 +1169,7 @@
 		return -EIO;
 
 	/* Wait for it to initialize */
-	msleep(150);
+	schedule_timeout(1 + 150 * HZ / 1000);
 
 	for (i = 0, success = 0; i < i2c_detect_tries && !success; i++) {
 		if ((i2c_r(ov, OV7610_REG_ID_HIGH) == 0x7F) &&
@@ -1183,7 +1182,7 @@
 		if (i2c_w(ov, 0x12, 0x80) < 0)
 			return -EIO;
 		/* Wait for it to initialize */
-		msleep(150);
+		schedule_timeout(1 + 150 * HZ / 1000);
 		/* Dummy read to sync I2C */
 		if (i2c_r(ov, 0x00) < 0)
 			return -EIO;
@@ -1901,7 +1900,7 @@
 	case SEN_KS0127:
 	case SEN_KS0127B:
 	case SEN_SAA7111A:
-		val = NULL;
+		val = 0;
 		PDEBUG(3, "Unsupported with this sensor");
 		return -EPERM;
 	default:
@@ -4594,7 +4593,7 @@
 }
 
 static ssize_t
-ov51x_v4l1_read(struct file *file, char __user *buf, size_t cnt, loff_t *ppos)
+ov51x_v4l1_read(struct file *file, char *buf, size_t cnt, loff_t *ppos)
 {
 	struct video_device *vdev = file->private_data;
 	int noblock = file->f_flags&O_NONBLOCK;
@@ -4948,7 +4947,7 @@
 			return -1;
 
 		/* Wait for it to initialize */
-		msleep(150);
+		schedule_timeout(1 + 150 * HZ / 1000);
 
 		i = 0;
 		success = 0;
@@ -5604,16 +5603,8 @@
 
 	if (ov->bridge == BRG_OV518)
 	{
-		struct usb_interface *ifp;
-		struct usb_host_interface *alt;
-		__u16 mxps = 0;
-
-		ifp = usb_ifnum_to_if(ov->dev, 0);
-		if (ifp) {
-			alt = usb_altnum_to_altsetting(ifp, 7);
-			if (alt)
-				mxps = alt->endpoint[0].desc.wMaxPacketSize;
-		}
+		struct usb_interface *ifp = ov->dev->config[0].interface[0];
+		__u16 mxps = ifp->altsetting[7].endpoint[0].desc.wMaxPacketSize;
 
 		/* Some OV518s have packet numbering by default, some don't */
 		if (mxps == 897)
@@ -5814,7 +5805,7 @@
 	if (dev->descriptor.bNumConfigurations != 1)
 		return -ENODEV;
 
-	idesc = &intf->cur_altsetting->desc;
+	idesc = &intf->altsetting[0].desc;
 
 	if (idesc->bInterfaceClass != 0xFF)
 		return -ENODEV;
diff -Naur linuxppc-2.6.9/drivers/usb/media/ov511.h linuxppc-2.6.9-dream/drivers/usb/media/ov511.h
--- linuxppc-2.6.9/drivers/usb/media/ov511.h	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/ov511.h	2005-09-19 21:40:05.000000000 +0200
@@ -11,7 +11,7 @@
 #ifdef OV511_DEBUG
 	#define PDEBUG(level, fmt, args...) \
 		if (debug >= (level)) info("[%s:%d] " fmt, \
-		__FUNCTION__, __LINE__ , ## args)
+		__PRETTY_FUNCTION__, __LINE__ , ## args)
 #else
 	#define PDEBUG(level, fmt, args...) do {} while(0)
 #endif
diff -Naur linuxppc-2.6.9/drivers/usb/media/pwc-ctrl.c linuxppc-2.6.9-dream/drivers/usb/media/pwc-ctrl.c
--- linuxppc-2.6.9/drivers/usb/media/pwc-ctrl.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/media/pwc-ctrl.c	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,1697 @@
+/* Driver for Philips webcam
+   Functions that send various control messages to the webcam, including
+   video modes.
+   (C) 1999-2003 Nemosoft Unv. (webcam@smcc.demon.nl)
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*
+   Changes
+   2001/08/03  Alvarado   Added methods for changing white balance and 
+                          red/green gains
+ */
+
+/* Control functions for the cam; brightness, contrast, video mode, etc. */
+
+#ifdef __KERNEL__
+#include <asm/uaccess.h> 
+#endif
+#include <asm/errno.h>
+ 
+#include "pwc.h"
+#include "pwc-ioctl.h"
+#include "pwc-uncompress.h"
+
+/* Request types: video */
+#define SET_LUM_CTL			0x01
+#define GET_LUM_CTL			0x02
+#define SET_CHROM_CTL			0x03
+#define GET_CHROM_CTL			0x04
+#define SET_STATUS_CTL			0x05
+#define GET_STATUS_CTL			0x06
+#define SET_EP_STREAM_CTL		0x07
+#define GET_EP_STREAM_CTL		0x08
+#define SET_MPT_CTL			0x0D
+#define GET_MPT_CTL			0x0E
+
+/* Selectors for the Luminance controls [GS]ET_LUM_CTL */
+#define AGC_MODE_FORMATTER			0x2000
+#define PRESET_AGC_FORMATTER			0x2100
+#define SHUTTER_MODE_FORMATTER			0x2200
+#define PRESET_SHUTTER_FORMATTER		0x2300
+#define PRESET_CONTOUR_FORMATTER		0x2400
+#define AUTO_CONTOUR_FORMATTER			0x2500
+#define BACK_LIGHT_COMPENSATION_FORMATTER	0x2600
+#define CONTRAST_FORMATTER			0x2700
+#define DYNAMIC_NOISE_CONTROL_FORMATTER		0x2800
+#define FLICKERLESS_MODE_FORMATTER		0x2900
+#define AE_CONTROL_SPEED			0x2A00
+#define BRIGHTNESS_FORMATTER			0x2B00
+#define GAMMA_FORMATTER				0x2C00
+
+/* Selectors for the Chrominance controls [GS]ET_CHROM_CTL */
+#define WB_MODE_FORMATTER			0x1000
+#define AWB_CONTROL_SPEED_FORMATTER		0x1100
+#define AWB_CONTROL_DELAY_FORMATTER		0x1200
+#define PRESET_MANUAL_RED_GAIN_FORMATTER	0x1300
+#define PRESET_MANUAL_BLUE_GAIN_FORMATTER	0x1400
+#define COLOUR_MODE_FORMATTER			0x1500
+#define SATURATION_MODE_FORMATTER1		0x1600
+#define SATURATION_MODE_FORMATTER2		0x1700
+
+/* Selectors for the Status controls [GS]ET_STATUS_CTL */
+#define SAVE_USER_DEFAULTS_FORMATTER		0x0200
+#define RESTORE_USER_DEFAULTS_FORMATTER		0x0300
+#define RESTORE_FACTORY_DEFAULTS_FORMATTER	0x0400
+#define READ_AGC_FORMATTER			0x0500
+#define READ_SHUTTER_FORMATTER			0x0600
+#define READ_RED_GAIN_FORMATTER			0x0700
+#define READ_BLUE_GAIN_FORMATTER		0x0800
+#define SENSOR_TYPE_FORMATTER1			0x0C00
+#define READ_RAW_Y_MEAN_FORMATTER		0x3100
+#define SET_POWER_SAVE_MODE_FORMATTER		0x3200
+#define MIRROR_IMAGE_FORMATTER			0x3300
+#define LED_FORMATTER				0x3400
+#define SENSOR_TYPE_FORMATTER2			0x3700
+
+/* Formatters for the Video Endpoint controls [GS]ET_EP_STREAM_CTL */
+#define VIDEO_OUTPUT_CONTROL_FORMATTER		0x0100
+
+/* Formatters for the motorized pan & tilt [GS]ET_MPT_CTL */
+#define PT_RELATIVE_CONTROL_FORMATTER		0x01
+#define PT_RESET_CONTROL_FORMATTER		0x02
+#define PT_STATUS_FORMATTER			0x03
+
+static char *size2name[PSZ_MAX] =
+{
+	"subQCIF",
+	"QSIF",
+	"QCIF",
+	"SIF",
+	"CIF",
+	"VGA",
+};  
+
+/********/
+
+/* Entries for the Nala (645/646) camera; the Nala doesn't have compression 
+   preferences, so you either get compressed or non-compressed streams.
+   
+   An alternate value of 0 means this mode is not available at all.
+ */
+
+struct Nala_table_entry {
+	char alternate;			/* USB alternate setting */
+	int compressed;			/* Compressed yes/no */
+
+	unsigned char mode[3];		/* precomputed mode table */
+};
+
+static struct Nala_table_entry Nala_table[PSZ_MAX][8] =
+{
+#include "pwc_nala.h"
+};
+
+/* This tables contains entries for the 675/680/690 (Timon) camera, with
+   4 different qualities (no compression, low, medium, high).
+   It lists the bandwidth requirements for said mode by its alternate interface 
+   number. An alternate of 0 means that the mode is unavailable.
+   
+   There are 6 * 4 * 4 entries: 
+     6 different resolutions subqcif, qsif, qcif, sif, cif, vga
+     6 framerates: 5, 10, 15, 20, 25, 30
+     4 compression modi: none, low, medium, high
+     
+   When an uncompressed mode is not available, the next available compressed mode 
+   will be chosen (unless the decompressor is absent). Sometimes there are only
+   1 or 2 compressed modes available; in that case entries are duplicated.
+*/
+struct Timon_table_entry 
+{
+	char alternate;			/* USB alternate interface */
+	unsigned short packetsize;	/* Normal packet size */
+	unsigned short bandlength;	/* Bandlength when decompressing */
+	unsigned char mode[13];		/* precomputed mode settings for cam */
+};
+
+static struct Timon_table_entry Timon_table[PSZ_MAX][6][4] = 
+{
+#include "pwc_timon.h"
+};
+
+/* Entries for the Kiara (730/740/750) camera */
+
+struct Kiara_table_entry
+{
+	char alternate;			/* USB alternate interface */
+	unsigned short packetsize;	/* Normal packet size */
+	unsigned short bandlength;	/* Bandlength when decompressing */
+	unsigned char mode[12];		/* precomputed mode settings for cam */
+};
+
+static struct Kiara_table_entry Kiara_table[PSZ_MAX][6][4] =
+{
+#include "pwc_kiara.h"
+};
+
+
+/****************************************************************************/
+
+
+#define SendControlMsg(request, value, buflen) \
+	usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0), \
+		request, \
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE, \
+		value, \
+		pdev->vcinterface, \
+		&buf, buflen, HZ / 2)
+
+#define RecvControlMsg(request, value, buflen) \
+	usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0), \
+		request, \
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE, \
+		value, \
+		pdev->vcinterface, \
+		&buf, buflen, HZ / 2)
+
+
+#if PWC_DEBUG
+void pwc_hexdump(void *p, int len)
+{
+	int i;
+	unsigned char *s;
+	char buf[100], *d;
+	
+	s = (unsigned char *)p;
+	d = buf;
+	*d = '\0';
+	Debug("Doing hexdump @ %p, %d bytes.\n", p, len);
+	for (i = 0; i < len; i++) {
+		d += sprintf(d, "%02X ", *s++);
+		if ((i & 0xF) == 0xF) {
+			Debug("%s\n", buf);
+			d = buf;
+			*d = '\0';
+		}
+	}
+	if ((i & 0xF) != 0)
+		Debug("%s\n", buf);
+}
+#endif
+
+static inline int send_video_command(struct usb_device *udev, int index, void *buf, int buflen)
+{
+	return usb_control_msg(udev,
+		usb_sndctrlpipe(udev, 0),
+		SET_EP_STREAM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		VIDEO_OUTPUT_CONTROL_FORMATTER,
+		index,
+		buf, buflen, HZ);
+}
+
+
+
+static inline int set_video_mode_Nala(struct pwc_device *pdev, int size, int frames)
+{
+	unsigned char buf[3];
+	int ret, fps;
+	struct Nala_table_entry *pEntry;
+	int frames2frames[31] = 
+	{ /* closest match of framerate */
+	   0,  0,  0,  0,  4,  /*  0-4  */
+	   5,  5,  7,  7, 10,  /*  5-9  */
+          10, 10, 12, 12, 15,  /* 10-14 */
+          15, 15, 15, 20, 20,  /* 15-19 */
+          20, 20, 20, 24, 24,  /* 20-24 */
+          24, 24, 24, 24, 24,  /* 25-29 */
+          24                   /* 30    */
+	};
+	int frames2table[31] = 
+	{ 0, 0, 0, 0, 0, /*  0-4  */
+	  1, 1, 1, 2, 2, /*  5-9  */
+	  3, 3, 4, 4, 4, /* 10-14 */
+	  5, 5, 5, 5, 5, /* 15-19 */
+	  6, 6, 6, 6, 7, /* 20-24 */
+	  7, 7, 7, 7, 7, /* 25-29 */
+	  7              /* 30    */
+	};
+	
+	if (size < 0 || size > PSZ_CIF || frames < 4 || frames > 25)
+		return -EINVAL;
+	frames = frames2frames[frames];
+	fps = frames2table[frames];
+	pEntry = &Nala_table[size][fps];
+	if (pEntry->alternate == 0)
+		return -EINVAL;
+
+	if (pEntry->compressed && pdev->decompressor == NULL)
+		return -ENOENT; /* Not supported. */
+
+	memcpy(buf, pEntry->mode, 3);	
+	ret = send_video_command(pdev->udev, pdev->vendpoint, buf, 3);
+	if (ret < 0) {
+		Debug("Failed to send video command... %d\n", ret);
+		return ret;
+	}
+	if (pEntry->compressed && pdev->decompressor != NULL)
+		pdev->decompressor->init(pdev->release, buf, pdev->decompress_data);
+		
+	/* Set various parameters */
+	pdev->vframes = frames;
+	pdev->vsize = size;
+	pdev->valternate = pEntry->alternate;
+	pdev->image = pwc_image_sizes[size];
+	pdev->frame_size = (pdev->image.x * pdev->image.y * 3) / 2;
+	if (pEntry->compressed) {
+		if (pdev->release < 5) { /* 4 fold compression */
+			pdev->vbandlength = 528;
+			pdev->frame_size /= 4;
+		}
+		else {
+			pdev->vbandlength = 704;
+			pdev->frame_size /= 3;
+		}
+	}
+	else
+		pdev->vbandlength = 0;
+	return 0;
+}
+
+
+static inline int set_video_mode_Timon(struct pwc_device *pdev, int size, int frames, int compression, int snapshot)
+{
+	unsigned char buf[13];
+	struct Timon_table_entry *pChoose;
+	int ret, fps;
+
+	if (size >= PSZ_MAX || frames < 5 || frames > 30 || compression < 0 || compression > 3)
+		return -EINVAL;
+	if (size == PSZ_VGA && frames > 15)
+		return -EINVAL;
+	fps = (frames / 5) - 1;
+	
+	/* Find a supported framerate with progressively higher compression ratios
+	   if the preferred ratio is not available.
+	*/
+	pChoose = NULL;
+	if (pdev->decompressor == NULL) {
+#if PWC_DEBUG	
+		Debug("Trying to find uncompressed mode.\n");
+#endif
+		pChoose = &Timon_table[size][fps][0];
+	}
+	else {
+		while (compression <= 3) {
+			pChoose = &Timon_table[size][fps][compression];
+			if (pChoose->alternate != 0)
+				break;
+			compression++;	
+		}
+	}
+	if (pChoose == NULL || pChoose->alternate == 0)
+		return -ENOENT; /* Not supported. */
+
+	memcpy(buf, pChoose->mode, 13);
+	if (snapshot)
+		buf[0] |= 0x80;
+	ret = send_video_command(pdev->udev, pdev->vendpoint, buf, 13);
+	if (ret < 0)
+		return ret;
+
+	if (pChoose->bandlength > 0)
+		pdev->decompressor->init(pdev->release, buf, pdev->decompress_data);
+	
+	/* Set various parameters */
+	pdev->vframes = frames;
+	pdev->vsize = size;
+	pdev->vsnapshot = snapshot;
+	pdev->valternate = pChoose->alternate;
+	pdev->image = pwc_image_sizes[size];
+	pdev->vbandlength = pChoose->bandlength;
+	if (pChoose->bandlength > 0) 
+		pdev->frame_size = (pChoose->bandlength * pdev->image.y) / 4;
+	else
+		pdev->frame_size = (pdev->image.x * pdev->image.y * 12) / 8;
+	return 0;
+}
+
+
+static inline int set_video_mode_Kiara(struct pwc_device *pdev, int size, int frames, int compression, int snapshot)
+{
+	struct Kiara_table_entry *pChoose;
+	int fps, ret;
+	unsigned char buf[12];
+	
+	if (size >= PSZ_MAX || frames < 5 || frames > 30 || compression < 0 || compression > 3)
+		return -EINVAL;
+	if (size == PSZ_VGA && frames > 15)
+		return -EINVAL;
+	fps = (frames / 5) - 1;
+	
+	/* Find a supported framerate with progressively higher compression ratios
+	   if the preferred ratio is not available.
+	*/
+	pChoose = NULL;
+	if (pdev->decompressor == NULL) {
+#if PWC_DEBUG	
+		Debug("Trying to find uncompressed mode.\n");
+#endif		
+		pChoose = &Kiara_table[size][fps][0];
+	}
+	else {
+		while (compression <= 3) {
+			pChoose = &Kiara_table[size][fps][compression];
+			if (pChoose->alternate != 0)
+				break;
+			compression++;	
+		}
+	}
+	if (pChoose == NULL || pChoose->alternate == 0)
+		return -ENOENT; /* Not supported. */
+
+	/* usb_control_msg won't take staticly allocated arrays as argument?? */
+	memcpy(buf, pChoose->mode, 12);
+	if (snapshot)
+		buf[0] |= 0x80;
+
+	/* Firmware bug: video endpoint is 5, but commands are sent to endpoint 4 */
+	ret = send_video_command(pdev->udev, 4 /* pdev->vendpoint */, buf, 12);
+	if (ret < 0)
+		return ret;
+
+	if (pChoose->bandlength > 0)
+		pdev->decompressor->init(pdev->release, buf, pdev->decompress_data);
+		
+	/* All set and go */
+	pdev->vframes = frames;
+	pdev->vsize = size;
+	pdev->vsnapshot = snapshot;
+	pdev->valternate = pChoose->alternate;
+	pdev->image = pwc_image_sizes[size];
+	pdev->vbandlength = pChoose->bandlength;
+	if (pChoose->bandlength > 0)
+		pdev->frame_size = (pChoose->bandlength * pdev->image.y) / 4;
+	else 
+		pdev->frame_size = (pdev->image.x * pdev->image.y * 12) / 8;
+	pdev->frame_size += (pdev->frame_header_size + pdev->frame_trailer_size);
+	return 0;
+}
+
+
+/**
+   @pdev: device structure
+   @width: viewport width
+   @height: viewport height
+   @frame: framerate, in fps
+   @compression: preferred compression ratio
+   @snapshot: snapshot mode or streaming
+ */
+int pwc_set_video_mode(struct pwc_device *pdev, int width, int height, int frames, int compression, int snapshot)
+{
+	int ret, size;
+	
+	size = pwc_decode_size(pdev, width, height);
+	if (size < 0) {
+		Debug("Could not find suitable size.\n");
+		return -ERANGE;
+	}
+	ret = -EINVAL;	
+	switch(pdev->type) {
+	case 645:
+	case 646:
+		ret = set_video_mode_Nala(pdev, size, frames);
+		break;
+
+	case 675:
+	case 680:
+	case 690:
+		ret = set_video_mode_Timon(pdev, size, frames, compression, snapshot);
+		break;
+		
+	case 720:
+	case 730:
+	case 740:
+	case 750:
+		ret = set_video_mode_Kiara(pdev, size, frames, compression, snapshot);
+		break;
+	}
+	if (ret < 0) {
+		if (ret == -ENOENT)
+			Info("Video mode %s@%d fps is only supported with the decompressor module (pwcx).\n", size2name[size], frames);
+		else {
+			Err("Failed to set video mode %s@%d fps; return code = %d\n", size2name[size], frames, ret);
+		}
+		return ret;
+	}
+	pdev->view.x = width;
+	pdev->view.y = height;
+	pwc_set_image_buffer_size(pdev);
+	Trace(TRACE_SIZE, "Set viewport to %dx%d, image size is %dx%d.\n", width, height, pwc_image_sizes[size].x, pwc_image_sizes[size].y);
+	return 0;
+}
+
+
+void pwc_set_image_buffer_size(struct pwc_device *pdev)
+{
+	int factor, i, filler = 0;
+
+	factor = 6;
+	filler = 128;
+
+	/* Set sizes in bytes */
+	pdev->image.size = pdev->image.x * pdev->image.y * factor / 4;
+	pdev->view.size  = pdev->view.x  * pdev->view.y  * factor / 4;
+
+	/* Align offset, or you'll get some very weird results in
+	   YUV420 mode... x must be multiple of 4 (to get the Y's in 
+	   place), and y even (or you'll mixup U & V). This is less of a
+	   problem for YUV420P.
+	 */
+	pdev->offset.x = ((pdev->view.x - pdev->image.x) / 2) & 0xFFFC;
+	pdev->offset.y = ((pdev->view.y - pdev->image.y) / 2) & 0xFFFE;
+	
+	/* Fill buffers with gray or black */
+	for (i = 0; i < MAX_IMAGES; i++) {
+		if (pdev->image_ptr[i] != NULL)
+			memset(pdev->image_ptr[i], filler, pdev->view.size);
+	}
+}
+
+
+
+/* BRIGHTNESS */
+
+int pwc_get_brightness(struct pwc_device *pdev)
+{
+	char buf;
+	int ret;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+		GET_LUM_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		BRIGHTNESS_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	if (ret < 0)
+		return ret;
+	return buf << 9;
+}
+
+int pwc_set_brightness(struct pwc_device *pdev, int value)
+{
+	char buf;
+
+	if (value < 0)
+		value = 0;
+	if (value > 0xffff)
+		value = 0xffff;
+	buf = (value >> 9) & 0x7f;
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_LUM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		BRIGHTNESS_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+}
+
+/* CONTRAST */
+
+int pwc_get_contrast(struct pwc_device *pdev)
+{
+	char buf;
+	int ret;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+		GET_LUM_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		CONTRAST_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	if (ret < 0)
+		return ret;
+	return buf << 10;
+}
+
+int pwc_set_contrast(struct pwc_device *pdev, int value)
+{
+	char buf;
+
+	if (value < 0)
+		value = 0;
+	if (value > 0xffff)
+		value = 0xffff;
+	buf = (value >> 10) & 0x3f;
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_LUM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		CONTRAST_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+}
+
+/* GAMMA */
+
+int pwc_get_gamma(struct pwc_device *pdev)
+{
+	char buf;
+	int ret;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+		GET_LUM_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		GAMMA_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	if (ret < 0)
+		return ret;
+	return buf << 11;
+}
+
+int pwc_set_gamma(struct pwc_device *pdev, int value)
+{
+	char buf;
+
+	if (value < 0)
+		value = 0;
+	if (value > 0xffff)
+		value = 0xffff;
+	buf = (value >> 11) & 0x1f;
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_LUM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		GAMMA_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+}
+
+
+/* SATURATION */
+
+int pwc_get_saturation(struct pwc_device *pdev)
+{
+	char buf;
+	int ret;
+
+	if (pdev->type < 675)
+		return -1;
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+		GET_CHROM_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		pdev->type < 730 ? SATURATION_MODE_FORMATTER2 : SATURATION_MODE_FORMATTER1,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	if (ret < 0)
+		return ret;
+	return 32768 + buf * 327;
+}
+
+int pwc_set_saturation(struct pwc_device *pdev, int value)
+{
+	char buf;
+
+	if (pdev->type < 675)
+		return -EINVAL;
+	if (value < 0)
+		value = 0;
+	if (value > 0xffff)
+		value = 0xffff;
+	/* saturation ranges from -100 to +100 */
+	buf = (value - 32768) / 327;
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_CHROM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		pdev->type < 730 ? SATURATION_MODE_FORMATTER2 : SATURATION_MODE_FORMATTER1,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+}
+
+/* AGC */
+
+static inline int pwc_set_agc(struct pwc_device *pdev, int mode, int value)
+{
+	char buf;
+	int ret;
+	
+	if (mode)
+		buf = 0x0; /* auto */
+	else
+		buf = 0xff; /* fixed */
+
+	ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_LUM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		AGC_MODE_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	
+	if (!mode && ret >= 0) {
+		if (value < 0)
+			value = 0;
+		if (value > 0xffff)
+			value = 0xffff;
+		buf = (value >> 10) & 0x3F;
+		ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+			SET_LUM_CTL,
+			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			PRESET_AGC_FORMATTER,
+			pdev->vcinterface,
+			&buf, 1, HZ / 2);
+	}
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static inline int pwc_get_agc(struct pwc_device *pdev, int *value)
+{
+	unsigned char buf;
+	int ret;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+		GET_LUM_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		AGC_MODE_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	if (ret < 0)
+		return ret;
+
+	if (buf != 0) { /* fixed */
+		ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+			GET_LUM_CTL,
+			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			PRESET_AGC_FORMATTER,
+			pdev->vcinterface,
+			&buf, 1, HZ / 2);
+		if (ret < 0)
+			return ret;
+		if (buf > 0x3F)
+			buf = 0x3F;
+		*value = (buf << 10);		
+	}
+	else { /* auto */
+		ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+			GET_STATUS_CTL,
+			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			READ_AGC_FORMATTER,
+			pdev->vcinterface,
+			&buf, 1, HZ / 2);
+		if (ret < 0)
+			return ret;
+		/* Gah... this value ranges from 0x00 ... 0x9F */
+		if (buf > 0x9F)
+			buf = 0x9F;
+		*value = -(48 + buf * 409);
+	}
+
+	return 0;
+}
+
+static inline int pwc_set_shutter_speed(struct pwc_device *pdev, int mode, int value)
+{
+	char buf[2];
+	int speed, ret;
+
+
+	if (mode)
+		buf[0] = 0x0;	/* auto */
+	else
+		buf[0] = 0xff; /* fixed */
+	
+	ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_LUM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		SHUTTER_MODE_FORMATTER,
+		pdev->vcinterface,
+		buf, 1, HZ / 2);
+
+	if (!mode && ret >= 0) {
+		if (value < 0)
+			value = 0;
+		if (value > 0xffff)
+			value = 0xffff;
+		switch(pdev->type) {
+		case 675:
+		case 680:
+		case 690:
+			/* speed ranges from 0x0 to 0x290 (656) */
+			speed = (value / 100);
+			buf[1] = speed >> 8;
+			buf[0] = speed & 0xff;
+			break;
+		case 720:
+		case 730:
+		case 740:
+		case 750:
+			/* speed seems to range from 0x0 to 0xff */
+			buf[1] = 0;
+			buf[0] = value >> 8;
+			break;
+		}
+
+		ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+			SET_LUM_CTL,
+			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			PRESET_SHUTTER_FORMATTER,
+			pdev->vcinterface,
+			&buf, 2, HZ / 2);
+	}
+	return ret;
+}	
+
+
+/* POWER */
+
+int pwc_camera_power(struct pwc_device *pdev, int power)
+{
+	char buf;
+
+	if (pdev->type < 675 || (pdev->type < 730 && pdev->release < 6))
+		return 0;	/* Not supported by Nala or Timon < release 6 */
+
+	if (power)
+		buf = 0x00; /* active */
+	else
+		buf = 0xFF; /* power save */
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_STATUS_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		SET_POWER_SAVE_MODE_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+}
+
+
+
+/* private calls */
+
+static inline int pwc_restore_user(struct pwc_device *pdev)
+{
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_STATUS_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		RESTORE_USER_DEFAULTS_FORMATTER,
+		pdev->vcinterface,
+		NULL, 0, HZ / 2);
+}
+
+static inline int pwc_save_user(struct pwc_device *pdev)
+{
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_STATUS_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		SAVE_USER_DEFAULTS_FORMATTER,
+		pdev->vcinterface,
+		NULL, 0, HZ / 2);
+}
+
+static inline int pwc_restore_factory(struct pwc_device *pdev)
+{
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_STATUS_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		RESTORE_FACTORY_DEFAULTS_FORMATTER,
+		pdev->vcinterface,
+		NULL, 0, HZ / 2);
+}
+
+ /* ************************************************* */
+ /* Patch by Alvarado: (not in the original version   */
+
+ /*
+  * the camera recognizes modes from 0 to 4:
+  *
+  * 00: indoor (incandescant lighting)
+  * 01: outdoor (sunlight)
+  * 02: fluorescent lighting
+  * 03: manual
+  * 04: auto
+  */ 
+static inline int pwc_set_awb(struct pwc_device *pdev, int mode)
+{
+	char buf;
+	int ret;
+	
+	if (mode < 0)
+	    mode = 0;
+	
+	if (mode > 4)
+	    mode = 4;
+	
+	buf = mode & 0x07; /* just the lowest three bits */
+	
+	ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_CHROM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		WB_MODE_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static inline int pwc_get_awb(struct pwc_device *pdev)
+{
+	unsigned char buf;
+	int ret;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+		GET_CHROM_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		WB_MODE_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+
+	if (ret < 0) 
+		return ret;
+	return buf;
+}
+
+static inline int pwc_set_red_gain(struct pwc_device *pdev, int value)
+{
+        unsigned char buf;
+
+	if (value < 0)
+		value = 0;
+	if (value > 0xffff)
+		value = 0xffff;
+
+	/* only the msb are considered */
+	buf = value >> 8;
+
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_CHROM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		PRESET_MANUAL_RED_GAIN_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+}
+
+static inline int pwc_get_red_gain(struct pwc_device *pdev)
+{
+	unsigned char buf;
+	int ret;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+ 	        GET_CHROM_CTL, 
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+	        PRESET_MANUAL_RED_GAIN_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+
+	if (ret < 0)
+	    return ret;
+	
+	return (buf << 8);
+}
+
+
+static inline int pwc_set_blue_gain(struct pwc_device *pdev, int value)
+{
+	unsigned char buf;
+
+	if (value < 0)
+		value = 0;
+	if (value > 0xffff)
+		value = 0xffff;
+
+	/* linear mapping of 0..0xffff to -0x80..0x7f */
+	buf = (value >> 8);
+
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_CHROM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		PRESET_MANUAL_BLUE_GAIN_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+}
+
+static inline int pwc_get_blue_gain(struct pwc_device *pdev)
+{
+	unsigned char buf;
+	int ret;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+   	        GET_CHROM_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		PRESET_MANUAL_BLUE_GAIN_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+
+	if (ret < 0)
+	    return ret;
+	
+	return (buf << 8);
+}
+
+
+/* The following two functions are different, since they only read the
+   internal red/blue gains, which may be different from the manual 
+   gains set or read above.
+ */   
+static inline int pwc_read_red_gain(struct pwc_device *pdev)
+{
+	unsigned char buf;
+	int ret;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+ 	        GET_STATUS_CTL, 
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+	        READ_RED_GAIN_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+
+	if (ret < 0)
+		return ret;
+	
+	return (buf << 8);
+}
+
+static inline int pwc_read_blue_gain(struct pwc_device *pdev)
+{
+	unsigned char buf;
+	int ret;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+   	        GET_STATUS_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		READ_BLUE_GAIN_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+
+	if (ret < 0)
+		return ret;
+	
+	return (buf << 8);
+}
+
+
+static inline int pwc_set_wb_speed(struct pwc_device *pdev, int speed)
+{
+	unsigned char buf;
+	
+	/* useful range is 0x01..0x20 */
+	buf = speed / 0x7f0;
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_CHROM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		AWB_CONTROL_SPEED_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+}
+
+static inline int pwc_get_wb_speed(struct pwc_device *pdev)
+{
+	unsigned char buf;
+	int ret;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+		GET_CHROM_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		AWB_CONTROL_SPEED_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	if (ret < 0)
+		return ret;
+	return (buf * 0x7f0);
+}
+
+
+static inline int pwc_set_wb_delay(struct pwc_device *pdev, int delay)
+{
+	unsigned char buf;
+	
+	/* useful range is 0x01..0x3F */
+	buf = (delay >> 10);
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_CHROM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		AWB_CONTROL_DELAY_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+}
+
+static inline int pwc_get_wb_delay(struct pwc_device *pdev)
+{
+	unsigned char buf;
+	int ret;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+		GET_CHROM_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		AWB_CONTROL_DELAY_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	if (ret < 0)
+		return ret;
+	return (buf << 10);
+}
+
+
+int pwc_set_leds(struct pwc_device *pdev, int on_value, int off_value)
+{
+	unsigned char buf[2];
+
+	if (pdev->type < 730)
+		return 0;
+	on_value /= 100;
+	off_value /= 100;
+	if (on_value < 0)
+		on_value = 0;
+	if (on_value > 0xff)
+		on_value = 0xff;
+	if (off_value < 0)
+		off_value = 0;
+	if (off_value > 0xff)
+		off_value = 0xff;
+
+	buf[0] = on_value;
+	buf[1] = off_value;
+
+	return SendControlMsg(SET_STATUS_CTL, LED_FORMATTER, 2);
+}
+
+int pwc_get_leds(struct pwc_device *pdev, int *on_value, int *off_value)
+{
+	unsigned char buf[2];
+	int ret;
+	
+	if (pdev->type < 730) {
+		*on_value = -1;
+		*off_value = -1;
+		return 0;
+	}
+
+	ret = RecvControlMsg(GET_STATUS_CTL, LED_FORMATTER, 2);
+	if (ret < 0)
+		return ret;
+	*on_value = buf[0] * 100;
+	*off_value = buf[1] * 100;
+	return 0;
+}
+
+static inline int pwc_set_contour(struct pwc_device *pdev, int contour)
+{
+	unsigned char buf;
+	int ret;
+	
+	if (contour < 0)
+		buf = 0xff; /* auto contour on */
+	else
+		buf = 0x0; /* auto contour off */
+	ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_LUM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		AUTO_CONTOUR_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	if (ret < 0)
+		return ret;
+	
+	if (contour < 0)
+		return 0;
+	if (contour > 0xffff)
+		contour = 0xffff;
+	
+	buf = (contour >> 10); /* contour preset is [0..3f] */
+	ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_LUM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		PRESET_CONTOUR_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	if (ret < 0)	
+		return ret;	
+	return 0;
+}
+
+static inline int pwc_get_contour(struct pwc_device *pdev, int *contour)
+{
+	unsigned char buf;
+	int ret;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+		GET_LUM_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		AUTO_CONTOUR_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	if (ret < 0)
+		return ret;
+
+	if (buf == 0) {
+		/* auto mode off, query current preset value */
+		ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+			GET_LUM_CTL,
+			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			PRESET_CONTOUR_FORMATTER,
+			pdev->vcinterface,
+			&buf, 1, HZ / 2);
+		if (ret < 0)	
+			return ret;
+		*contour =  (buf << 10);
+	}
+	else
+		*contour = -1;
+	return 0;
+}
+
+
+static inline int pwc_set_backlight(struct pwc_device *pdev, int backlight)
+{
+	unsigned char buf;
+	
+	if (backlight)
+		buf = 0xff;
+	else
+		buf = 0x0;
+	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
+		SET_LUM_CTL,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		BACK_LIGHT_COMPENSATION_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+}
+
+static inline int pwc_get_backlight(struct pwc_device *pdev)
+{
+	int ret;
+	unsigned char buf;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+		GET_LUM_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		BACK_LIGHT_COMPENSATION_FORMATTER,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	if (ret < 0)
+		return ret;
+	return buf;
+}
+
+
+static inline int pwc_set_flicker(struct pwc_device *pdev, int flicker)
+{
+	unsigned char buf;
+	
+	if (flicker)
+		buf = 0xff;
+	else
+		buf = 0x0;
+	return SendControlMsg(SET_LUM_CTL, FLICKERLESS_MODE_FORMATTER, 1);
+}
+
+static inline int pwc_get_flicker(struct pwc_device *pdev)
+{
+	int ret;
+	unsigned char buf;
+	
+	ret = RecvControlMsg(GET_LUM_CTL, FLICKERLESS_MODE_FORMATTER, 1);
+	if (ret < 0)
+		return ret;
+	return buf;
+}
+
+
+static inline int pwc_set_dynamic_noise(struct pwc_device *pdev, int noise)
+{
+	unsigned char buf;
+
+	if (noise < 0)
+		noise = 0;
+	if (noise > 3)
+		noise = 3;
+	buf = noise;
+	return SendControlMsg(SET_LUM_CTL, DYNAMIC_NOISE_CONTROL_FORMATTER, 1);
+}
+
+static inline int pwc_get_dynamic_noise(struct pwc_device *pdev)
+{
+	int ret;
+	unsigned char buf;
+	
+	ret = RecvControlMsg(GET_LUM_CTL, DYNAMIC_NOISE_CONTROL_FORMATTER, 1);
+	if (ret < 0)
+		return ret;
+	return buf;
+}
+
+int pwc_mpt_reset(struct pwc_device *pdev, int flags)
+{
+	unsigned char buf;
+	
+	buf = flags & 0x03; // only lower two bits are currently used 
+	return SendControlMsg(SET_MPT_CTL, PT_RESET_CONTROL_FORMATTER, 1);
+}
+
+static inline int pwc_mpt_set_angle(struct pwc_device *pdev, int pan, int tilt)
+{
+	unsigned char buf[4];
+	
+	/* set new relative angle; angles are expressed in degrees * 100,
+	   but cam as .5 degree resolution, hence devide by 200. Also
+	   the angle must be multiplied by 64 before it's send to
+	   the cam (??)
+	 */
+	pan  =  64 * pan  / 100;
+	tilt = -64 * tilt / 100; /* positive tilt is down, which is not what the user would expect */
+	buf[0] = pan & 0xFF;
+	buf[1] = (pan >> 8) & 0xFF;
+	buf[2] = tilt & 0xFF;
+	buf[3] = (tilt >> 8) & 0xFF;
+	return SendControlMsg(SET_MPT_CTL, PT_RELATIVE_CONTROL_FORMATTER, 4);
+}
+
+static inline int pwc_mpt_get_status(struct pwc_device *pdev, struct pwc_mpt_status *status)
+{
+	int ret;
+	unsigned char buf[5];
+	
+	ret = RecvControlMsg(GET_MPT_CTL, PT_STATUS_FORMATTER, 5);
+	if (ret < 0)
+		return ret;
+	status->status = buf[0] & 0x7; // 3 bits are used for reporting
+	status->time_pan = (buf[1] << 8) + buf[2];
+	status->time_tilt = (buf[3] << 8) + buf[4];
+	return 0;
+}
+
+
+int pwc_get_cmos_sensor(struct pwc_device *pdev)
+{
+	unsigned char buf;
+	int ret = -1, request;
+	
+	if (pdev->type < 675)
+		request = SENSOR_TYPE_FORMATTER1;
+	else if (pdev->type < 730)
+		return -1; /* The Vesta series doesn't have this call */
+	else
+		request = SENSOR_TYPE_FORMATTER2;
+	
+	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
+		GET_STATUS_CTL,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		request,
+		pdev->vcinterface,
+		&buf, 1, HZ / 2);
+	if (ret < 0)
+		return ret;
+	if (pdev->type < 675)
+		return buf | 0x100;
+	else
+		return buf;
+}
+
+
+ /* End of Add-Ons                                    */
+ /* ************************************************* */
+
+int pwc_ioctl(struct pwc_device *pdev, unsigned int cmd, void *arg)
+{
+	int ret = 0;
+
+	switch(cmd) {
+	case VIDIOCPWCRUSER:
+	{
+		if (pwc_restore_user(pdev))
+			ret = -EINVAL;
+		break;
+	}
+	
+	case VIDIOCPWCSUSER:
+	{
+		if (pwc_save_user(pdev))
+			ret = -EINVAL;
+		break;
+	}
+		
+	case VIDIOCPWCFACTORY:
+	{
+		if (pwc_restore_factory(pdev))
+			ret = -EINVAL;
+		break;
+	}
+	
+	case VIDIOCPWCSCQUAL:
+	{	
+		int *qual = arg;
+
+		if (*qual < 0 || *qual > 3)
+			ret = -EINVAL;
+		else
+			ret = pwc_try_video_mode(pdev, pdev->view.x, pdev->view.y, pdev->vframes, *qual, pdev->vsnapshot);
+		if (ret >= 0)
+			pdev->vcompression = *qual;
+		break;
+	}
+	
+	case VIDIOCPWCGCQUAL:
+	{
+		int *qual = arg;
+		
+		*qual = pdev->vcompression;
+		break;
+	}
+
+	case VIDIOCPWCPROBE:
+	{
+		struct pwc_probe *probe = arg;
+		
+		strcpy(probe->name, pdev->vdev.name);
+		probe->type = pdev->type;
+		break;
+	}
+
+	case VIDIOCPWCSAGC:
+	{
+		int *agc = arg;
+
+		if (pwc_set_agc(pdev, *agc < 0 ? 1 : 0, *agc))
+			ret = -EINVAL;
+		break;
+	}
+	
+	case VIDIOCPWCGAGC:
+	{
+		int *agc = arg;
+		
+		if (pwc_get_agc(pdev, agc))
+			ret = -EINVAL;
+		break;
+	}
+	
+	case VIDIOCPWCSSHUTTER:
+	{
+		int *shutter_speed = arg;
+
+		ret = pwc_set_shutter_speed(pdev, *shutter_speed < 0 ? 1 : 0, *shutter_speed);
+		break;
+	}
+	
+        case VIDIOCPWCSAWB:
+	{
+		struct pwc_whitebalance *wb = arg;
+		
+		ret = pwc_set_awb(pdev, wb->mode);
+		if (ret >= 0 && wb->mode == PWC_WB_MANUAL) {
+			pwc_set_red_gain(pdev, wb->manual_red);
+			pwc_set_blue_gain(pdev, wb->manual_blue);
+		}
+		break;
+	}
+
+	case VIDIOCPWCGAWB:
+	{
+		struct pwc_whitebalance *wb = arg;
+
+		memset(wb, 0, sizeof(*wb));
+		wb->mode = pwc_get_awb(pdev);
+		if (wb->mode < 0)
+			ret = -EINVAL;
+		else {
+			if (wb->mode == PWC_WB_MANUAL) {
+				wb->manual_red = pwc_get_red_gain(pdev);
+				wb->manual_blue = pwc_get_blue_gain(pdev);
+			}
+			if (wb->mode == PWC_WB_AUTO) {
+				wb->read_red = pwc_read_red_gain(pdev);
+				wb->read_blue = pwc_read_blue_gain(pdev);
+			}
+		}
+		break;
+	}
+	
+	case VIDIOCPWCSAWBSPEED:
+	{
+		struct pwc_wb_speed *wbs = arg;
+		
+		if (wbs->control_speed > 0) {
+			ret = pwc_set_wb_speed(pdev, wbs->control_speed);
+		}
+		if (wbs->control_delay > 0) {
+			ret = pwc_set_wb_delay(pdev, wbs->control_delay);
+		}
+		break;
+	}
+	
+	case VIDIOCPWCGAWBSPEED:
+	{
+		struct pwc_wb_speed *wbs = arg;
+		
+		ret = pwc_get_wb_speed(pdev);
+		if (ret < 0)
+			break;
+		wbs->control_speed = ret;
+		ret = pwc_get_wb_delay(pdev);
+		if (ret < 0)
+			break;
+		wbs->control_delay = ret;
+		break;
+	}
+
+        case VIDIOCPWCSLED:
+	{
+		struct pwc_leds *leds = arg;
+
+		ret = pwc_set_leds(pdev, leds->led_on, leds->led_off);
+	    	break;
+	}
+
+
+	case VIDIOCPWCGLED:
+	{
+		struct pwc_leds *leds = arg;
+		
+		ret = pwc_get_leds(pdev, &leds->led_on, &leds->led_off); 
+		break;
+	}
+
+	case VIDIOCPWCSCONTOUR:
+	{
+		int *contour = arg;
+
+		ret = pwc_set_contour(pdev, *contour);
+		break;
+	}
+			
+	case VIDIOCPWCGCONTOUR:
+	{
+		int *contour = arg;
+		
+		ret = pwc_get_contour(pdev, contour);
+		break;
+	}
+	
+	case VIDIOCPWCSBACKLIGHT:
+	{
+		int *backlight = arg;
+		
+		ret = pwc_set_backlight(pdev, *backlight);
+		break;
+	}
+
+	case VIDIOCPWCGBACKLIGHT:
+	{
+		int *backlight = arg;
+		
+		ret = pwc_get_backlight(pdev);
+		if (ret >= 0)
+			*backlight = ret;
+		break;
+	}
+	
+	case VIDIOCPWCSFLICKER:
+	{
+		int *flicker = arg;
+		
+		ret = pwc_set_flicker(pdev, *flicker);
+		break;
+	}
+
+	case VIDIOCPWCGFLICKER:
+	{
+		int *flicker = arg;
+		
+		ret = pwc_get_flicker(pdev);
+		if (ret >= 0)
+			*flicker = ret;
+		break;
+	}
+	
+	case VIDIOCPWCSDYNNOISE:
+	{
+		int *dynnoise = arg;
+		
+		ret = pwc_set_dynamic_noise(pdev, *dynnoise);
+		break;
+	}
+	
+	case VIDIOCPWCGDYNNOISE:
+	{
+		int *dynnoise = arg;
+
+		ret = pwc_get_dynamic_noise(pdev);
+		if (ret < 0)
+			break;
+		*dynnoise = ret;
+		break;
+	}
+
+	case VIDIOCPWCGREALSIZE:
+	{
+		struct pwc_imagesize *size = arg;
+		
+		size->width = pdev->image.x;
+		size->height = pdev->image.y;
+		break;
+ 	}
+ 	
+ 	case VIDIOCPWCMPTRESET:
+ 	{
+ 		int *flags = arg;
+ 		
+ 		if (pdev->features & FEATURE_MOTOR_PANTILT)
+ 		{
+			ret = pwc_mpt_reset(pdev, *flags);
+ 			if (ret >= 0)
+ 			{
+ 				pdev->pan_angle = 0;
+ 				pdev->tilt_angle = 0;
+ 			}
+ 		}
+ 		else
+ 		{
+ 			ret = -ENXIO;
+ 		}
+ 		break;		
+ 	}
+ 	case VIDIOCPWCMPTGRANGE:
+ 	{
+ 		if (pdev->features & FEATURE_MOTOR_PANTILT)
+ 		{
+ 			memcpy(arg, &pdev->angle_range, sizeof(struct pwc_mpt_range));
+ 		}
+ 		else
+ 		{	
+ 			ret = -ENXIO;
+ 		}
+ 		break;
+ 	}
+ 	
+ 	case VIDIOCPWCMPTSANGLE:
+ 	{
+ 		struct pwc_mpt_angles *angles = arg;
+ 		int new_pan, new_tilt;
+ 		
+ 		if (pdev->features & FEATURE_MOTOR_PANTILT)
+ 		{
+			/* The camera can only set relative angles, so
+			   do some calculations when getting an absolute angle .
+			 */
+			if (angles->absolute)
+			{
+ 				new_pan  = angles->pan; 
+ 				new_tilt = angles->tilt;
+ 			}
+ 			else
+ 			{
+ 				new_pan  = pdev->pan_angle  + angles->pan;
+ 				new_tilt = pdev->tilt_angle + angles->tilt;
+			}
+			/* check absolute ranges */
+			if (new_pan  < pdev->angle_range.pan_min  ||
+			    new_pan  > pdev->angle_range.pan_max  ||
+			    new_tilt < pdev->angle_range.tilt_min ||
+			    new_tilt > pdev->angle_range.tilt_max)
+			{
+				ret = -ERANGE;
+			}
+			else
+			{
+				/* go to relative range, check again */
+				new_pan  -= pdev->pan_angle;
+				new_tilt -= pdev->tilt_angle;
+				/* angles are specified in degrees * 100, thus the limit = 36000 */
+				if (new_pan < -36000 || new_pan > 36000 || new_tilt < -36000 || new_tilt > 36000)
+					ret = -ERANGE;
+			}
+			if (ret == 0) /* no errors so far */
+			{
+				ret = pwc_mpt_set_angle(pdev, new_pan, new_tilt);
+				if (ret >= 0)
+				{
+					pdev->pan_angle  += new_pan;
+					pdev->tilt_angle += new_tilt;
+				}
+				if (ret == -EPIPE) /* stall -> out of range */
+					ret = -ERANGE;				
+			}
+ 		}
+ 		else
+ 		{
+ 			ret = -ENXIO;
+ 		}
+ 		break;
+ 	} 
+ 	
+ 	case VIDIOCPWCMPTGANGLE:
+ 	{
+ 		struct pwc_mpt_angles *angles = arg;
+ 		
+ 		if (pdev->features & FEATURE_MOTOR_PANTILT)
+ 		{
+ 			angles->absolute = 1;
+ 			angles->pan  = pdev->pan_angle;
+ 			angles->tilt = pdev->tilt_angle;
+ 		}
+ 		else
+ 		{
+ 			ret = -ENXIO;
+ 		}
+ 		break;
+ 	}
+ 
+ 	case VIDIOCPWCMPTSTATUS:
+ 	{
+ 		struct pwc_mpt_status *status = arg;
+ 	
+ 		if (pdev->features & FEATURE_MOTOR_PANTILT)
+ 		{
+ 			ret = pwc_mpt_get_status(pdev, status);
+ 		}
+ 		else
+ 		{
+ 			ret = -ENXIO;
+ 		}
+  		break;
+  	}
+  	
+	default:
+		ret = -ENOIOCTLCMD;
+		break;
+	}
+	
+	if (ret > 0)
+		return 0;
+	return ret;
+}
+
+
+
diff -Naur linuxppc-2.6.9/drivers/usb/media/pwc.h linuxppc-2.6.9-dream/drivers/usb/media/pwc.h
--- linuxppc-2.6.9/drivers/usb/media/pwc.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/media/pwc.h	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,280 @@
+/* (C) 1999-2003 Nemosoft Unv. (webcam@smcc.demon.nl)
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef PWC_H
+#define PWC_H
+
+#include <linux/version.h>
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/smp_lock.h>
+#include <linux/spinlock.h>
+#include <linux/usb.h>
+#include <linux/videodev.h>
+#include <linux/wait.h>
+
+#include <asm/semaphore.h>
+#include <asm/errno.h>
+
+#include "pwc-ioctl.h"
+
+/* Defines and structures for the Philips webcam */
+/* Used for checking memory corruption/pointer validation */
+#define PWC_MAGIC 0x89DC10ABUL
+#undef PWC_MAGIC
+
+/* Turn some debugging options on/off */
+#define PWC_DEBUG 0
+
+/* Trace certain actions in the driver */
+#define TRACE_MODULE	0x0001
+#define TRACE_PROBE	0x0002
+#define TRACE_OPEN	0x0004
+#define TRACE_READ	0x0008
+#define TRACE_MEMORY	0x0010
+#define TRACE_FLOW	0x0020
+#define TRACE_SIZE	0x0040
+#define TRACE_PWCX	0x0080
+#define TRACE_SEQUENCE	0x1000
+
+#define Trace(R, A...) if (pwc_trace & R) printk(KERN_DEBUG PWC_NAME " " A)
+#define Debug(A...) printk(KERN_DEBUG PWC_NAME " " A)
+#define Info(A...)  printk(KERN_INFO  PWC_NAME " " A)
+#define Err(A...)   printk(KERN_ERR   PWC_NAME " " A)
+
+
+/* Defines for ToUCam cameras */
+#define TOUCAM_HEADER_SIZE		8
+#define TOUCAM_TRAILER_SIZE		4
+
+#define FEATURE_MOTOR_PANTILT		0x0001
+
+/* Version block */
+#define PWC_MAJOR	8
+#define PWC_MINOR	12
+#define PWC_VERSION 	"8.12"
+#define PWC_NAME 	"pwc"
+
+/* Turn certain features on/off */
+#define PWC_INT_PIPE 0
+
+/* Ignore errors in the first N frames, to allow for startup delays */
+#define FRAME_LOWMARK 5
+
+/* Size and number of buffers for the ISO pipe. */
+#define MAX_ISO_BUFS		2
+#define ISO_FRAMES_PER_DESC	10
+#define ISO_MAX_FRAME_SIZE	960
+#define ISO_BUFFER_SIZE 	(ISO_FRAMES_PER_DESC * ISO_MAX_FRAME_SIZE)
+
+/* Frame buffers: contains compressed or uncompressed video data. */
+#define MAX_FRAMES		5
+/* Maximum size after decompression is 640x480 YUV data, 1.5 * 640 * 480 */
+#define PWC_FRAME_SIZE 		(460800 + TOUCAM_HEADER_SIZE + TOUCAM_TRAILER_SIZE)
+
+/* Absolute maximum number of buffers available for mmap() */
+#define MAX_IMAGES 		10
+
+struct pwc_coord
+{
+	int x, y;		/* guess what */
+	int size;		/* size, or offset */
+};
+
+/* The following structures were based on cpia.h. Why reinvent the wheel? :-) */
+struct pwc_iso_buf
+{
+	void *data;
+	int  length;
+	int  read;
+	struct urb *urb;
+};
+
+/* intermediate buffers with raw data from the USB cam */
+struct pwc_frame_buf
+{
+   void *data;
+   volatile int filled;		/* number of bytes filled */
+   struct pwc_frame_buf *next;	/* list */
+#if PWC_DEBUG
+   int sequence;		/* Sequence number */
+#endif
+};
+
+struct pwc_device
+{
+   struct video_device vdev;
+#ifdef PWC_MAGIC
+   int magic;
+#endif
+   /* Pointer to our usb_device */
+   struct usb_device *udev;
+   
+   int type;                    /* type of cam (645, 646, 675, 680, 690, 720, 730, 740, 750) */
+   int release;			/* release number */
+   int features;		/* feature bits */
+   int error_status;		/* set when something goes wrong with the cam (unplugged, USB errors) */
+   int usb_init;		/* set when the cam has been initialized over USB */
+
+   /*** Video data ***/
+   int vopen;			/* flag */
+   int vendpoint;		/* video isoc endpoint */
+   int vcinterface;		/* video control interface */
+   int valternate;		/* alternate interface needed */
+   int vframes, vsize;		/* frames-per-second & size (see PSZ_*) */
+   int vframe_count;		/* received frames */
+   int vframes_dumped; 		/* counter for dumped frames */
+   int vframes_error;		/* frames received in error */
+   int vmax_packet_size;	/* USB maxpacket size */
+   int vlast_packet_size;	/* for frame synchronisation */
+   int visoc_errors;		/* number of contiguous ISOC errors */
+   int vcompression;		/* desired compression factor */
+   int vbandlength;		/* compressed band length; 0 is uncompressed */
+   char vsnapshot;		/* snapshot mode */
+   char vsync;			/* used by isoc handler */
+   char vmirror;		/* for ToUCaM series */
+
+   /* The image acquisition requires 3 to 4 steps:
+      1. data is gathered in short packets from the USB controller
+      2. data is synchronized and packed into a frame buffer
+      3a. in case data is compressed, decompress it directly into image buffer
+      3b. in case data is uncompressed, copy into image buffer with viewport
+      4. data is transferred to the user process
+
+      Note that MAX_ISO_BUFS != MAX_FRAMES != MAX_IMAGES....
+      We have in effect a back-to-back-double-buffer system.
+    */
+   /* 1: isoc */
+   struct pwc_iso_buf sbuf[MAX_ISO_BUFS];
+   char iso_init;
+
+   /* 2: frame */
+   struct pwc_frame_buf *fbuf;	/* all frames */
+   struct pwc_frame_buf *empty_frames, *empty_frames_tail;	/* all empty frames */
+   struct pwc_frame_buf *full_frames, *full_frames_tail;	/* all filled frames */
+   struct pwc_frame_buf *fill_frame;	/* frame currently being filled */
+   struct pwc_frame_buf *read_frame;	/* frame currently read by user process */
+   int frame_size;
+   int frame_header_size, frame_trailer_size;
+   int drop_frames;
+#if PWC_DEBUG
+   int sequence;			/* Debugging aid */
+#endif
+
+   /* 3: decompression */
+   struct pwc_decompressor *decompressor;	/* function block with decompression routines */
+   void *decompress_data;		/* private data for decompression engine */
+
+   /* 4: image */
+   /* We have an 'image' and a 'view', where 'image' is the fixed-size image
+      as delivered by the camera, and 'view' is the size requested by the
+      program. The camera image is centered in this viewport, laced with
+      a gray or black border. view_min <= image <= view <= view_max;
+    */
+   int image_mask;			/* bitmask of supported sizes */
+   struct pwc_coord view_min, view_max;	/* minimum and maximum sizes */
+   struct pwc_coord image, view;	/* image and viewport size */
+   struct pwc_coord offset;		/* offset within the viewport */
+
+   void *image_data;			/* total buffer, which is subdivided into ... */
+   void *image_ptr[MAX_IMAGES];		/* ...several images... */
+   int fill_image;			/* ...which are rotated. */
+   int len_per_image;			/* length per image */
+   int image_read_pos;			/* In case we read data in pieces, keep track of were we are in the imagebuffer */
+   int image_used[MAX_IMAGES];		/* For MCAPTURE and SYNC */
+
+   struct semaphore modlock;		/* to prevent races in video_open(), etc */
+   spinlock_t ptrlock;			/* for manipulating the buffer pointers */
+
+   /*** motorized pan/tilt feature */
+   struct pwc_mpt_range angle_range;
+   int pan_angle;			/* in degrees * 100 */
+   int tilt_angle;			/* absolute angle; 0,0 is home position */
+
+   /*** Misc. data ***/
+   wait_queue_head_t frameq;		/* When waiting for a frame to finish... */
+#if PWC_INT_PIPE
+   void *usb_int_handler;		/* for the interrupt endpoint */
+#endif
+};
+
+/* Enumeration of image sizes */
+#define PSZ_SQCIF	0x00
+#define PSZ_QSIF	0x01
+#define PSZ_QCIF	0x02
+#define PSZ_SIF		0x03
+#define PSZ_CIF		0x04
+#define PSZ_VGA		0x05
+#define PSZ_MAX		6
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Global variables */
+extern int pwc_trace;
+extern int pwc_preferred_compression;
+
+/** functions in pwc-if.c */
+int pwc_try_video_mode(struct pwc_device *pdev, int width, int height, int new_fps, int new_compression, int new_snapshot);
+
+/** Functions in pwc-misc.c */
+/* sizes in pixels */
+extern struct pwc_coord pwc_image_sizes[PSZ_MAX];
+
+int pwc_decode_size(struct pwc_device *pdev, int width, int height);
+void pwc_construct(struct pwc_device *pdev);
+
+/** Functions in pwc-ctrl.c */
+/* Request a certain video mode. Returns < 0 if not possible */
+extern int pwc_set_video_mode(struct pwc_device *pdev, int width, int height, int frames, int compression, int snapshot);
+/* Calculate the number of bytes per image (not frame) */
+extern void pwc_set_image_buffer_size(struct pwc_device *pdev);
+
+/* Various controls; should be obvious. Value 0..65535, or < 0 on error */
+extern int pwc_get_brightness(struct pwc_device *pdev);
+extern int pwc_set_brightness(struct pwc_device *pdev, int value);
+extern int pwc_get_contrast(struct pwc_device *pdev);
+extern int pwc_set_contrast(struct pwc_device *pdev, int value);
+extern int pwc_get_gamma(struct pwc_device *pdev);
+extern int pwc_set_gamma(struct pwc_device *pdev, int value);
+extern int pwc_get_saturation(struct pwc_device *pdev);
+extern int pwc_set_saturation(struct pwc_device *pdev, int value);
+extern int pwc_set_leds(struct pwc_device *pdev, int on_value, int off_value);
+extern int pwc_get_leds(struct pwc_device *pdev, int *on_value, int *off_value);
+extern int pwc_get_cmos_sensor(struct pwc_device *pdev);
+
+/* Power down or up the camera; not supported by all models */
+extern int pwc_camera_power(struct pwc_device *pdev, int power);
+
+/* Private ioctl()s; see pwc-ioctl.h */
+extern int pwc_ioctl(struct pwc_device *pdev, unsigned int cmd, void *arg);
+
+
+/** pwc-uncompress.c */
+/* Expand frame to image, possibly including decompression. Uses read_frame and fill_image */
+extern int pwc_decompress(struct pwc_device *pdev);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
diff -Naur linuxppc-2.6.9/drivers/usb/media/pwc-if.c linuxppc-2.6.9-dream/drivers/usb/media/pwc-if.c
--- linuxppc-2.6.9/drivers/usb/media/pwc-if.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/media/pwc-if.c	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,2129 @@
+/* Linux driver for Philips webcam 
+   USB and Video4Linux interface part.
+   (C) 1999-2003 Nemosoft Unv.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*/
+
+/*  
+   This code forms the interface between the USB layers and the Philips
+   specific stuff. Some adanved stuff of the driver falls under an
+   NDA, signed between me and Philips B.V., Eindhoven, the Netherlands, and
+   is thus not distributed in source form. The binary pwcx.o module 
+   contains the code that falls under the NDA.
+   
+   In case you're wondering: 'pwc' stands for "Philips WebCam", but 
+   I really didn't want to type 'philips_web_cam' every time (I'm lazy as
+   any Linux kernel hacker, but I don't like uncomprehensible abbreviations
+   without explanation).
+   
+   Oh yes, convention: to disctinguish between all the various pointers to
+   device-structures, I use these names for the pointer variables:
+   udev: struct usb_device *
+   vdev: struct video_device *
+   pdev: struct pwc_devive *
+*/
+
+/* Contributors:
+   - Alvarado: adding whitebalance code
+   - Alistar Moire: QuickCam 3000 Pro device/product ID
+   - Tony Hoyle: Creative Labs Webcam 5 device/product ID
+   - Mark Burazin: solving hang in VIDIOCSYNC when camera gets unplugged
+   - Jk Fang: SOTEC Afina Eye ID
+   - Xavier Roche: QuickCam Pro 4000 ID
+   - Jens Knudsen: QuickCam Zoom ID
+   - J. Debert: QuickCam for Notebooks ID
+*/
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <asm/io.h>
+
+#include "pwc.h"
+#include "pwc-ioctl.h"
+#include "pwc-uncompress.h"
+
+/* Function prototypes and driver templates */
+
+/* hotplug device table support */
+static struct usb_device_id pwc_device_table [] = {
+	{ USB_DEVICE(0x0471, 0x0302) }, /* Philips models */
+	{ USB_DEVICE(0x0471, 0x0303) },
+	{ USB_DEVICE(0x0471, 0x0304) },
+	{ USB_DEVICE(0x0471, 0x0307) },
+	{ USB_DEVICE(0x0471, 0x0308) },
+	{ USB_DEVICE(0x0471, 0x030C) },
+	{ USB_DEVICE(0x0471, 0x0310) },
+	{ USB_DEVICE(0x0471, 0x0311) },
+	{ USB_DEVICE(0x0471, 0x0312) },
+	{ USB_DEVICE(0x0471, 0x0313) }, /* the 'new' 720K */
+	{ USB_DEVICE(0x069A, 0x0001) }, /* Askey */
+	{ USB_DEVICE(0x046D, 0x08B0) }, /* Logitech QuickCam Pro 3000 */
+	{ USB_DEVICE(0x046D, 0x08B1) }, /* Logitech QuickCam Notebook Pro */
+	{ USB_DEVICE(0x046D, 0x08B2) }, /* Logitech QuickCam Pro 4000 */
+	{ USB_DEVICE(0x046D, 0x08B3) }, /* Logitech QuickCam Zoom (old model) */
+	{ USB_DEVICE(0x046D, 0x08B4) }, /* Logitech QuickCam Zoom (new model) */
+	{ USB_DEVICE(0x046D, 0x08B5) }, /* Logitech QuickCam Orbit/Sphere */
+	{ USB_DEVICE(0x046D, 0x08B6) }, /* Logitech (reserved) */
+	{ USB_DEVICE(0x046D, 0x08B7) }, /* Logitech (reserved) */
+	{ USB_DEVICE(0x046D, 0x08B8) }, /* Logitech (reserved) */
+	{ USB_DEVICE(0x055D, 0x9000) }, /* Samsung */
+	{ USB_DEVICE(0x055D, 0x9001) },
+	{ USB_DEVICE(0x041E, 0x400C) }, /* Creative Webcam 5 */
+	{ USB_DEVICE(0x041E, 0x4011) }, /* Creative Webcam Pro Ex */
+	{ USB_DEVICE(0x04CC, 0x8116) }, /* Afina Eye */
+	{ USB_DEVICE(0x0d81, 0x1910) }, /* Visionite */
+	{ USB_DEVICE(0x0d81, 0x1900) },
+	{ }
+};
+MODULE_DEVICE_TABLE(usb, pwc_device_table);
+
+static int usb_pwc_probe(struct usb_interface *intf, const struct usb_device_id *id);
+static void usb_pwc_disconnect(struct usb_interface *intf);
+
+static struct usb_driver pwc_driver = {
+	.owner =		THIS_MODULE,
+	.name =			"Philips webcam",	/* name */
+	.id_table =		pwc_device_table,
+	.probe =		usb_pwc_probe,		/* probe() */
+	.disconnect =		usb_pwc_disconnect,	/* disconnect() */
+};
+
+#define MAX_DEV_HINTS	20
+#define MAX_ISOC_ERRORS	20
+
+static int default_size = PSZ_QCIF;
+static int default_fps = 10;
+static int default_fbufs = 3;   /* Default number of frame buffers */
+static int default_mbufs = 2;	/* Default number of mmap() buffers */
+       int pwc_trace = TRACE_MODULE | TRACE_FLOW | TRACE_PWCX;
+static int power_save = 0;
+static int led_on = 100, led_off = 0; /* defaults to LED that is on while in use */
+       int pwc_preferred_compression = 2; /* 0..3 = uncompressed..high */
+static struct {
+	int type;
+	char serial_number[30];
+	int device_node;
+	struct pwc_device *pdev;
+} device_hint[MAX_DEV_HINTS];
+
+/***/
+
+static int pwc_video_open(struct inode *inode, struct file *file);
+static int pwc_video_close(struct inode *inode, struct file *file);
+static int pwc_video_release(struct video_device *);			  
+static ssize_t pwc_video_read(struct file *file, char *buf,
+			  size_t count, loff_t *ppos);
+static unsigned int pwc_video_poll(struct file *file, poll_table *wait);
+static int  pwc_video_ioctl(struct inode *inode, struct file *file,
+			    unsigned int ioctlnr, unsigned long arg);
+static int  pwc_video_mmap(struct file *file, struct vm_area_struct *vma);
+
+static struct file_operations pwc_fops = {
+	.owner =	THIS_MODULE,
+	.open =		pwc_video_open,
+	.release =     	pwc_video_close,
+	.read =		pwc_video_read,
+	.poll =		pwc_video_poll,
+	.mmap =		pwc_video_mmap,
+	.ioctl =        pwc_video_ioctl,
+	.llseek =       no_llseek,
+};
+static struct video_device pwc_template = {
+	.owner =	THIS_MODULE,
+	.name =		"Philips Webcam",	/* Filled in later */
+	.type =		VID_TYPE_CAPTURE,
+	.hardware =	VID_HARDWARE_PWC,
+	.fops =         &pwc_fops,
+};
+
+/***************************************************************************/
+
+/* Okay, this is some magic that I worked out and the reasoning behind it...
+
+   The biggest problem with any USB device is of course: "what to do 
+   when the user unplugs the device while it is in use by an application?"
+   We have several options:
+   1) Curse them with the 7 plagues when they do (requires divine intervention)
+   2) Tell them not to (won't work: they'll do it anyway)
+   3) Oops the kernel (this will have a negative effect on a user's uptime)
+   4) Do something sensible.
+   
+   Of course, we go for option 4.
+
+   It happens that this device will be linked to two times, once from
+   usb_device and once from the video_device in their respective 'private'
+   pointers. This is done when the device is probed() and all initialization
+   succeeded. The pwc_device struct links back to both structures.
+
+   When a device is unplugged while in use it will be removed from the 
+   list of known USB devices; I also de-register it as a V4L device, but 
+   unfortunately I can't free the memory since the struct is still in use
+   by the file descriptor. This free-ing is then deferend until the first
+   opportunity. Crude, but it works.
+   
+   A small 'advantage' is that if a user unplugs the cam and plugs it back
+   in, it should get assigned the same video device minor, but unfortunately
+   it's non-trivial to re-link the cam back to the video device... (that 
+   would surely be magic! :))
+*/
+
+/***************************************************************************/
+/* Private functions */
+
+/* Here we want the physical address of the memory.
+ * This is used when initializing the contents of the area.
+ */
+static inline unsigned long kvirt_to_pa(unsigned long adr) 
+{
+        unsigned long kva, ret;
+
+	kva = (unsigned long) page_address(vmalloc_to_page((void *)adr));
+	kva |= adr & (PAGE_SIZE-1); /* restore the offset */
+	ret = __pa(kva);
+        return ret;
+}
+
+static void * rvmalloc(unsigned long size)
+{
+	void * mem;
+	unsigned long adr;
+
+	size=PAGE_ALIGN(size);
+        mem=vmalloc_32(size);
+	if (mem) 
+	{
+		memset(mem, 0, size); /* Clear the ram out, no junk to the user */
+	        adr=(unsigned long) mem;
+		while (size > 0) 
+                {
+			SetPageReserved(vmalloc_to_page((void *)adr));
+			adr+=PAGE_SIZE;
+			size-=PAGE_SIZE;
+		}
+	}
+	return mem;
+}
+
+static void rvfree(void * mem, unsigned long size)
+{
+        unsigned long adr;
+
+	if (mem) 
+	{
+	        adr=(unsigned long) mem;
+		while ((long) size > 0) 
+                {
+			ClearPageReserved(vmalloc_to_page((void *)adr));
+			adr+=PAGE_SIZE;
+			size-=PAGE_SIZE;
+		}
+		vfree(mem);
+	}
+}
+
+
+
+
+static int pwc_allocate_buffers(struct pwc_device *pdev)
+{
+	int i;
+	void *kbuf;
+
+	Trace(TRACE_MEMORY, ">> pwc_allocate_buffers(pdev = 0x%p)\n", pdev);
+
+	if (pdev == NULL)
+		return -ENXIO;
+		
+#ifdef PWC_MAGIC
+	if (pdev->magic != PWC_MAGIC) {
+		Err("allocate_buffers(): magic failed.\n");
+		return -ENXIO;
+	}
+#endif	
+	/* Allocate Isochronous pipe buffers */
+	for (i = 0; i < MAX_ISO_BUFS; i++) {
+		if (pdev->sbuf[i].data == NULL) {
+			kbuf = kmalloc(ISO_BUFFER_SIZE, GFP_KERNEL);
+			if (kbuf == NULL) {
+				Err("Failed to allocate iso buffer %d.\n", i);
+				return -ENOMEM;
+			}
+			Trace(TRACE_MEMORY, "Allocated iso buffer at %p.\n", kbuf);
+			pdev->sbuf[i].data = kbuf;
+			memset(kbuf, 0, ISO_BUFFER_SIZE);
+		}
+	}
+
+	/* Allocate frame buffer structure */
+	if (pdev->fbuf == NULL) {
+		kbuf = kmalloc(default_fbufs * sizeof(struct pwc_frame_buf), GFP_KERNEL);
+		if (kbuf == NULL) {
+			Err("Failed to allocate frame buffer structure.\n");
+			return -ENOMEM;
+		}
+		Trace(TRACE_MEMORY, "Allocated frame buffer structure at %p.\n", kbuf);
+		pdev->fbuf = kbuf;
+		memset(kbuf, 0, default_fbufs * sizeof(struct pwc_frame_buf));
+	}
+	/* create frame buffers, and make circular ring */
+	for (i = 0; i < default_fbufs; i++) {
+		if (pdev->fbuf[i].data == NULL) {
+			kbuf = vmalloc(PWC_FRAME_SIZE); /* need vmalloc since frame buffer > 128K */
+			if (kbuf == NULL) {
+				Err("Failed to allocate frame buffer %d.\n", i);
+				return -ENOMEM;
+			}
+			Trace(TRACE_MEMORY, "Allocated frame buffer %d at %p.\n", i, kbuf);
+			pdev->fbuf[i].data = kbuf;
+			memset(kbuf, 128, PWC_FRAME_SIZE);
+		}
+	}
+	
+	/* Allocate decompressor table space */
+	kbuf = NULL;
+	if (pdev->decompressor != NULL) {
+		kbuf = kmalloc(pdev->decompressor->table_size, GFP_KERNEL);
+		if (kbuf == NULL) {
+			Err("Failed to allocate decompress table.\n");
+			return -ENOMEM;
+		}
+		Trace(TRACE_MEMORY, "Allocated decompress table %p.\n", kbuf);
+	}
+	pdev->decompress_data = kbuf;
+	
+	/* Allocate image buffer; double buffer for mmap() */
+	kbuf = rvmalloc(default_mbufs * pdev->len_per_image);
+	if (kbuf == NULL) {
+		Err("Failed to allocate image buffer(s).\n");
+		return -ENOMEM;
+	}
+	Trace(TRACE_MEMORY, "Allocated image buffer at %p.\n", kbuf);
+	pdev->image_data = kbuf;
+	for (i = 0; i < default_mbufs; i++)
+		pdev->image_ptr[i] = kbuf + i * pdev->len_per_image;
+	for (; i < MAX_IMAGES; i++)
+		pdev->image_ptr[i] = NULL;
+
+	kbuf = NULL;
+	  
+	Trace(TRACE_MEMORY, "<< pwc_allocate_buffers()\n");
+	return 0;
+}
+
+static void pwc_free_buffers(struct pwc_device *pdev)
+{
+	int i;
+
+	Trace(TRACE_MEMORY, "Entering free_buffers(%p).\n", pdev);
+
+	if (pdev == NULL)
+		return;
+#ifdef PWC_MAGIC
+	if (pdev->magic != PWC_MAGIC) {
+		Err("free_buffers(): magic failed.\n");
+		return;
+	}
+#endif	
+
+	/* Release Iso-pipe buffers */
+	for (i = 0; i < MAX_ISO_BUFS; i++)
+		if (pdev->sbuf[i].data != NULL) {
+			Trace(TRACE_MEMORY, "Freeing ISO buffer at %p.\n", pdev->sbuf[i].data);
+			kfree(pdev->sbuf[i].data);
+			pdev->sbuf[i].data = NULL;
+		}
+
+	/* The same for frame buffers */
+	if (pdev->fbuf != NULL) {
+		for (i = 0; i < default_fbufs; i++) {
+			if (pdev->fbuf[i].data != NULL) {
+				Trace(TRACE_MEMORY, "Freeing frame buffer %d at %p.\n", i, pdev->fbuf[i].data);
+				vfree(pdev->fbuf[i].data);
+				pdev->fbuf[i].data = NULL;
+			}
+		}
+		kfree(pdev->fbuf);
+		pdev->fbuf = NULL;
+	}
+
+	/* Intermediate decompression buffer & tables */
+	if (pdev->decompress_data != NULL) {
+		Trace(TRACE_MEMORY, "Freeing decompression buffer at %p.\n", pdev->decompress_data);
+		kfree(pdev->decompress_data);
+		pdev->decompress_data = NULL;
+	}
+	pdev->decompressor = NULL;
+
+	/* Release image buffers */
+	if (pdev->image_data != NULL) {
+		Trace(TRACE_MEMORY, "Freeing image buffer at %p.\n", pdev->image_data);
+		rvfree(pdev->image_data, default_mbufs * pdev->len_per_image);
+	}
+	pdev->image_data = NULL;
+	
+	Trace(TRACE_MEMORY, "Leaving free_buffers().\n");
+}
+
+/* The frame & image buffer mess. 
+
+   Yes, this is a mess. Well, it used to be simple, but alas...  In this
+   module, 3 buffers schemes are used to get the data from the USB bus to
+   the user program. The first scheme involves the ISO buffers (called thus
+   since they transport ISO data from the USB controller), and not really
+   interesting. Suffices to say the data from this buffer is quickly 
+   gathered in an interrupt handler (pwc_isoc_handler) and placed into the
+   frame buffer.
+
+   The frame buffer is the second scheme, and is the central element here.
+   It collects the data from a single frame from the camera (hence, the
+   name). Frames are delimited by the USB camera with a short USB packet,
+   so that's easy to detect. The frame buffers form a list that is filled
+   by the camera+USB controller and drained by the user process through
+   either read() or mmap().
+
+   The image buffer is the third scheme, in which frames are decompressed
+   and converted into planar format. For mmap() there is more than
+   one image buffer available.
+
+   The frame buffers provide the image buffering. In case the user process
+   is a bit slow, this introduces lag and some undesired side-effects.
+   The problem arises when the frame buffer is full. I used to drop the last
+   frame, which makes the data in the queue stale very quickly. But dropping
+   the frame at the head of the queue proved to be a litte bit more difficult.
+   I tried a circular linked scheme, but this introduced more problems than
+   it solved.
+
+   Because filling and draining are completely asynchronous processes, this
+   requires some fiddling with pointers and mutexes.
+
+   Eventually, I came up with a system with 2 lists: an 'empty' frame list
+   and a 'full' frame list:
+     * Initially, all frame buffers but one are on the 'empty' list; the one
+       remaining buffer is our initial fill frame.
+     * If a frame is needed for filling, we try to take it from the 'empty' 
+       list, unless that list is empty, in which case we take the buffer at 
+       the head of the 'full' list.
+     * When our fill buffer has been filled, it is appended to the 'full'
+       list.
+     * If a frame is needed by read() or mmap(), it is taken from the head of
+       the 'full' list, handled, and then appended to the 'empty' list. If no
+       buffer is present on the 'full' list, we wait.
+   The advantage is that the buffer that is currently being decompressed/
+   converted, is on neither list, and thus not in our way (any other scheme
+   I tried had the problem of old data lingering in the queue).
+
+   Whatever strategy you choose, it always remains a tradeoff: with more
+   frame buffers the chances of a missed frame are reduced. On the other
+   hand, on slower machines it introduces lag because the queue will
+   always be full.
+ */
+
+/**
+  \brief Find next frame buffer to fill. Take from empty or full list, whichever comes first.
+ */
+static inline int pwc_next_fill_frame(struct pwc_device *pdev)
+{
+	int ret;
+	unsigned long flags;
+	
+	ret = 0;
+	spin_lock_irqsave(&pdev->ptrlock, flags);
+	if (pdev->fill_frame != NULL) {
+		/* append to 'full' list */
+		if (pdev->full_frames == NULL) {
+			pdev->full_frames = pdev->fill_frame;
+			pdev->full_frames_tail = pdev->full_frames;
+		}
+		else {
+			pdev->full_frames_tail->next = pdev->fill_frame;
+			pdev->full_frames_tail = pdev->fill_frame;
+		}
+	}
+	if (pdev->empty_frames != NULL) {
+		/* We have empty frames available. That's easy */
+		pdev->fill_frame = pdev->empty_frames;
+		pdev->empty_frames = pdev->empty_frames->next;
+	}
+	else {
+		/* Hmm. Take it from the full list */
+#if PWC_DEBUG
+		/* sanity check */
+		if (pdev->full_frames == NULL) {
+			Err("Neither empty or full frames available!\n");
+			spin_unlock_irqrestore(&pdev->ptrlock, flags);
+			return -EINVAL;
+		}
+#endif
+		pdev->fill_frame = pdev->full_frames;
+		pdev->full_frames = pdev->full_frames->next;
+		ret = 1;
+	}
+	pdev->fill_frame->next = NULL;
+#if PWC_DEBUG
+	Trace(TRACE_SEQUENCE, "Assigning sequence number %d.\n", pdev->sequence);
+	pdev->fill_frame->sequence = pdev->sequence++;
+#endif
+	spin_unlock_irqrestore(&pdev->ptrlock, flags);
+	return ret;
+}
+
+
+/**
+  \brief Reset all buffers, pointers and lists, except for the image_used[] buffer.
+  
+  If the image_used[] buffer is cleared too, mmap()/VIDIOCSYNC will run into trouble.
+ */
+static void pwc_reset_buffers(struct pwc_device *pdev)
+{
+	int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pdev->ptrlock, flags);
+	pdev->full_frames = NULL;
+	pdev->full_frames_tail = NULL;
+	for (i = 0; i < default_fbufs; i++) {
+		pdev->fbuf[i].filled = 0;
+		if (i > 0)
+			pdev->fbuf[i].next = &pdev->fbuf[i - 1];
+		else
+			pdev->fbuf->next = NULL;
+	}
+	pdev->empty_frames = &pdev->fbuf[default_fbufs - 1];
+	pdev->empty_frames_tail = pdev->fbuf;
+	pdev->read_frame = NULL;
+	pdev->fill_frame = pdev->empty_frames;
+	pdev->empty_frames = pdev->empty_frames->next;
+
+	pdev->image_read_pos = 0;
+	pdev->fill_image = 0;
+	spin_unlock_irqrestore(&pdev->ptrlock, flags);
+}
+
+
+/**
+  \brief Do all the handling for getting one frame: get pointer, decompress, advance pointers.
+ */
+static int pwc_handle_frame(struct pwc_device *pdev)
+{
+	int ret = 0;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&pdev->ptrlock, flags);
+	/* First grab our read_frame; this is removed from all lists, so
+	   we can release the lock after this without problems */
+	if (pdev->read_frame != NULL) {
+		/* This can't theoretically happen */
+		Err("Huh? Read frame still in use?\n");
+	}
+	else {
+		if (pdev->full_frames == NULL) {
+			Err("Woops. No frames ready.\n");
+		}
+		else {
+			pdev->read_frame = pdev->full_frames;
+			pdev->full_frames = pdev->full_frames->next;
+			pdev->read_frame->next = NULL;
+		}
+
+		if (pdev->read_frame != NULL) {
+#if PWC_DEBUG
+			Trace(TRACE_SEQUENCE, "Decompressing frame %d\n", pdev->read_frame->sequence);
+#endif
+			/* Decompression is a lenghty process, so it's outside of the lock.
+			   This gives the isoc_handler the opportunity to fill more frames 
+			   in the mean time.
+			*/
+			spin_unlock_irqrestore(&pdev->ptrlock, flags);
+			ret = pwc_decompress(pdev);
+			spin_lock_irqsave(&pdev->ptrlock, flags);
+
+			/* We're done with read_buffer, tack it to the end of the empty buffer list */
+			if (pdev->empty_frames == NULL) {
+				pdev->empty_frames = pdev->read_frame;
+				pdev->empty_frames_tail = pdev->empty_frames;
+			}
+			else {
+				pdev->empty_frames_tail->next = pdev->read_frame;
+				pdev->empty_frames_tail = pdev->read_frame;
+			}
+			pdev->read_frame = NULL;
+		}
+	}
+	spin_unlock_irqrestore(&pdev->ptrlock, flags);
+	return ret;
+}
+
+/**
+  \brief Advance pointers of image buffer (after each user request)
+*/
+static inline void pwc_next_image(struct pwc_device *pdev)
+{
+	pdev->image_used[pdev->fill_image] = 0;
+	pdev->fill_image = (pdev->fill_image + 1) % default_mbufs;
+}
+
+
+/* This gets called for the Isochronous pipe (video). This is done in
+ * interrupt time, so it has to be fast, not crash, and not stall. Neat.
+ */
+static void pwc_isoc_handler(struct urb *urb, struct pt_regs *regs)
+{
+	struct pwc_device *pdev;
+	int i, fst, flen;
+	int awake;
+	struct pwc_frame_buf *fbuf;
+	unsigned char *fillptr = 0, *iso_buf = 0;
+
+	awake = 0;
+	pdev = (struct pwc_device *)urb->context;
+	if (pdev == NULL) {
+		Err("isoc_handler() called with NULL device?!\n");
+		return;
+	}
+#ifdef PWC_MAGIC
+	if (pdev->magic != PWC_MAGIC) {
+		Err("isoc_handler() called with bad magic!\n");
+		return;
+	}
+#endif
+	if (urb->status == -ENOENT || urb->status == -ECONNRESET) {
+		Trace(TRACE_OPEN, "pwc_isoc_handler(): URB (%p) unlinked %ssynchronuously.\n", urb, urb->status == -ENOENT ? "" : "a");
+		return;
+	}
+	if (urb->status != -EINPROGRESS && urb->status != 0) {
+		const char *errmsg;
+
+		errmsg = "Unknown";
+		switch(urb->status) {
+			case -ENOSR:		errmsg = "Buffer error (overrun)"; break;
+			case -EPIPE:		errmsg = "Stalled (device not responding)"; break;
+			case -EOVERFLOW:	errmsg = "Babble (bad cable?)"; break;
+			case -EPROTO:		errmsg = "Bit-stuff error (bad cable?)"; break;
+			case -EILSEQ:		errmsg = "CRC/Timeout (could be anything)"; break;
+			case -ETIMEDOUT:	errmsg = "NAK (device does not respond)"; break;
+		}
+		Trace(TRACE_FLOW, "pwc_isoc_handler() called with status %d [%s].\n", urb->status, errmsg);
+		/* Give up after a number of contiguous errors on the USB bus. 
+		   Appearantly something is wrong so we simulate an unplug event.
+		 */
+		if (++pdev->visoc_errors > MAX_ISOC_ERRORS)
+		{
+			Info("Too many ISOC errors, bailing out.\n");
+			pdev->error_status = EIO;
+			awake = 1;
+			wake_up_interruptible(&pdev->frameq);
+		}
+		goto handler_end; // ugly, but practical
+	}
+
+	fbuf = pdev->fill_frame;
+	if (fbuf == NULL) {
+		Err("pwc_isoc_handler without valid fill frame.\n");
+		awake = 1;
+		goto handler_end;
+	}
+	else {
+		fillptr = fbuf->data + fbuf->filled;
+	}
+	
+	/* Reset ISOC error counter. We did get here, after all. */
+	pdev->visoc_errors = 0;
+
+	/* vsync: 0 = don't copy data
+	          1 = sync-hunt
+	          2 = synched
+	 */
+	/* Compact data */
+	for (i = 0; i < urb->number_of_packets; i++) {
+		fst  = urb->iso_frame_desc[i].status;
+		flen = urb->iso_frame_desc[i].actual_length;
+		iso_buf = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
+		if (fst == 0) {
+			if (flen > 0) { /* if valid data... */
+				if (pdev->vsync > 0) { /* ...and we are not sync-hunting... */
+					pdev->vsync = 2;
+
+					/* ...copy data to frame buffer, if possible */
+					if (flen + fbuf->filled > pdev->frame_size) {
+						Trace(TRACE_FLOW, "Frame buffer overflow (flen = %d, frame_size = %d).\n", flen, pdev->frame_size);
+						pdev->vsync = 0; /* Hmm, let's wait for an EOF (end-of-frame) */
+						pdev->vframes_error++;
+					}
+					else {
+						memmove(fillptr, iso_buf, flen);
+						fillptr += flen;
+					}
+				}
+				fbuf->filled += flen;
+			} /* ..flen > 0 */
+
+			if (flen < pdev->vlast_packet_size) {
+				/* Shorter packet... We probably have the end of an image-frame; 
+				   wake up read() process and let select()/poll() do something.
+				   Decompression is done in user time over there.
+				 */
+				if (pdev->vsync == 2) {
+					/* The ToUCam Fun CMOS sensor causes the firmware to send 2 or 3 bogus 
+					   frames on the USB wire after an exposure change. This conditition is 
+					   however detected  in the cam and a bit is set in the header.
+					 */
+					if (pdev->type == 730) {
+						unsigned char *ptr = (unsigned char *)fbuf->data;
+						
+						if (ptr[1] == 1 && ptr[0] & 0x10) {
+#if PWC_DEBUG
+							Debug("Hyundai CMOS sensor bug. Dropping frame %d.\n", fbuf->sequence);
+#endif
+							pdev->drop_frames += 2;
+							pdev->vframes_error++;
+						}
+						if ((ptr[0] ^ pdev->vmirror) & 0x01) {
+							if (ptr[0] & 0x01)
+								Info("Snapshot button pressed.\n");
+							else
+								Info("Snapshot button released.\n");
+						}
+						if ((ptr[0] ^ pdev->vmirror) & 0x02) {
+							if (ptr[0] & 0x02)
+								Info("Image is mirrored.\n");
+							else
+								Info("Image is normal.\n");
+						}
+						pdev->vmirror = ptr[0] & 0x03;
+						/* Sometimes the trailer of the 730 is still sent as a 4 byte packet 
+						   after a short frame; this condition is filtered out specifically. A 4 byte
+						   frame doesn't make sense anyway.
+						   So we get either this sequence: 
+						   	drop_bit set -> 4 byte frame -> short frame -> good frame
+						   Or this one:
+						   	drop_bit set -> short frame -> good frame
+						   So we drop either 3 or 2 frames in all!
+						 */
+						if (fbuf->filled == 4)
+							pdev->drop_frames++;
+					}
+
+					/* In case we were instructed to drop the frame, do so silently.
+					   The buffer pointers are not updated either (but the counters are reset below).
+					 */
+					if (pdev->drop_frames > 0)
+						pdev->drop_frames--;
+					else {
+						/* Check for underflow first */
+						if (fbuf->filled < pdev->frame_size) {
+							Trace(TRACE_FLOW, "Frame buffer underflow (%d bytes); discarded.\n", fbuf->filled);
+							pdev->vframes_error++;
+						}
+						else {
+							/* Send only once per EOF */
+							awake = 1; /* delay wake_ups */
+
+							/* Find our next frame to fill. This will always succeed, since we
+							 * nick a frame from either empty or full list, but if we had to
+							 * take it from the full list, it means a frame got dropped.
+							 */
+							if (pwc_next_fill_frame(pdev)) {
+								pdev->vframes_dumped++;
+								if ((pdev->vframe_count > FRAME_LOWMARK) && (pwc_trace & TRACE_FLOW)) {
+									if (pdev->vframes_dumped < 20)
+										Trace(TRACE_FLOW, "Dumping frame %d.\n", pdev->vframe_count);
+									if (pdev->vframes_dumped == 20)
+										Trace(TRACE_FLOW, "Dumping frame %d (last message).\n", pdev->vframe_count);
+								}
+							}
+							fbuf = pdev->fill_frame;
+						}
+					} /* !drop_frames */
+					pdev->vframe_count++;
+				}
+				fbuf->filled = 0;
+				fillptr = fbuf->data;
+				pdev->vsync = 1;
+			} /* .. flen < last_packet_size */
+			pdev->vlast_packet_size = flen;
+		} /* ..status == 0 */
+#if PWC_DEBUG
+		/* This is normally not interesting to the user, unless you are really debugging something */
+		else {
+			static int iso_error = 0;
+			iso_error++;
+			if (iso_error < 20)
+				Trace(TRACE_FLOW, "Iso frame %d of USB has error %d\n", i, fst);
+		}
+#endif
+	}
+
+handler_end:
+	if (awake)
+		wake_up_interruptible(&pdev->frameq);
+
+	urb->dev = pdev->udev;
+	i = usb_submit_urb(urb, GFP_ATOMIC);
+	if (i != 0)
+		Err("Error (%d) re-submitting urb in pwc_isoc_handler.\n", i);
+}
+
+
+static int pwc_isoc_init(struct pwc_device *pdev)
+{
+	struct usb_device *udev;
+	struct urb *urb;
+	int i, j, ret;
+
+	struct usb_host_interface *idesc;
+
+	if (pdev == NULL)
+		return -EFAULT;
+	if (pdev->iso_init)
+		return 0;
+	pdev->vsync = 0;
+	udev = pdev->udev;
+
+	/* Get the current alternate interface, adjust packet size */
+	if (!udev->actconfig)
+		return -EFAULT;
+	idesc = &udev->actconfig->interface[0]->altsetting[pdev->valternate];
+	if (!idesc)
+		return -EFAULT;
+
+	/* Search video endpoint */
+	pdev->vmax_packet_size = -1;
+	for (i = 0; i < idesc->desc.bNumEndpoints; i++)
+		if ((idesc->endpoint[i].desc.bEndpointAddress & 0xF) == pdev->vendpoint) {
+			pdev->vmax_packet_size = idesc->endpoint[i].desc.wMaxPacketSize;
+			break;
+		}
+	
+	if (pdev->vmax_packet_size < 0 || pdev->vmax_packet_size > ISO_MAX_FRAME_SIZE) {
+		Err("Failed to find packet size for video endpoint in current alternate setting.\n");
+		return -ENFILE; /* Odd error, that should be noticeable */
+	}
+
+	/* Set alternate interface */
+	ret = 0;
+	Trace(TRACE_OPEN, "Setting alternate interface %d\n", pdev->valternate);
+	ret = usb_set_interface(pdev->udev, 0, pdev->valternate);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < MAX_ISO_BUFS; i++) {
+		urb = usb_alloc_urb(ISO_FRAMES_PER_DESC, GFP_KERNEL);
+		if (urb == NULL) {
+			Err("Failed to allocate urb %d\n", i);
+			ret = -ENOMEM;
+			break;
+		}
+		pdev->sbuf[i].urb = urb;
+		Trace(TRACE_MEMORY, "Allocated URB at 0x%p\n", urb);
+	}
+	if (ret) {
+		/* De-allocate in reverse order */
+		while (i >= 0) {
+			if (pdev->sbuf[i].urb != NULL)
+				usb_free_urb(pdev->sbuf[i].urb);
+			pdev->sbuf[i].urb = NULL;
+			i--;
+		}
+		return ret;
+	}
+
+	/* init URB structure */	
+	for (i = 0; i < MAX_ISO_BUFS; i++) {
+		urb = pdev->sbuf[i].urb;
+
+		urb->interval = 1; // devik
+		urb->dev = udev;
+	        urb->pipe = usb_rcvisocpipe(udev, pdev->vendpoint);
+		urb->transfer_flags = URB_ISO_ASAP;
+	        urb->transfer_buffer = pdev->sbuf[i].data;
+	        urb->transfer_buffer_length = ISO_BUFFER_SIZE;
+	        urb->complete = pwc_isoc_handler;
+	        urb->context = pdev;
+		urb->start_frame = 0;
+		urb->number_of_packets = ISO_FRAMES_PER_DESC;
+		for (j = 0; j < ISO_FRAMES_PER_DESC; j++) {
+			urb->iso_frame_desc[j].offset = j * ISO_MAX_FRAME_SIZE;
+			urb->iso_frame_desc[j].length = pdev->vmax_packet_size;
+		}
+	}
+
+	/* link */
+	for (i = 0; i < MAX_ISO_BUFS; i++) {
+		ret = usb_submit_urb(pdev->sbuf[i].urb, GFP_KERNEL);
+		if (ret)
+			Err("isoc_init() submit_urb %d failed with error %d\n", i, ret);
+		else
+			Trace(TRACE_OPEN, "URB 0x%p submitted.\n", pdev->sbuf[i].urb);
+	}
+
+	/* All is done... */
+	pdev->iso_init = 1;
+	Trace(TRACE_OPEN, "<< pwc_isoc_init()\n");
+	return 0;
+}
+
+static void pwc_isoc_cleanup(struct pwc_device *pdev)
+{
+	int i;
+	
+	Trace(TRACE_OPEN, ">> pwc_isoc_cleanup()\n");
+	if (pdev == NULL)
+		return;
+
+	/* Unlinking ISOC buffers one by one */
+	for (i = 0; i < MAX_ISO_BUFS; i++) {
+		struct urb *urb;
+
+		urb = pdev->sbuf[i].urb;
+		if (urb != 0) {
+			if (pdev->iso_init) {
+				Trace(TRACE_MEMORY, "Unlinking URB %p\n", urb);
+				usb_unlink_urb(urb);
+			}
+			Trace(TRACE_MEMORY, "Freeing URB\n");
+			usb_free_urb(urb);
+			pdev->sbuf[i].urb = NULL;
+		}
+	}
+
+	/* Stop camera, but only if we are sure the camera is still there (unplug
+	   is signalled by EPIPE) 
+	 */
+	if (pdev->error_status && pdev->error_status != EPIPE) {
+		Trace(TRACE_OPEN, "Setting alternate interface 0.\n");
+		usb_set_interface(pdev->udev, 0, 0);
+	}
+
+	pdev->iso_init = 0;
+	Trace(TRACE_OPEN, "<< pwc_isoc_cleanup()\n");
+}
+
+int pwc_try_video_mode(struct pwc_device *pdev, int width, int height, int new_fps, int new_compression, int new_snapshot)
+{
+	int ret, start;
+
+	/* Stop isoc stuff */
+	pwc_isoc_cleanup(pdev);
+	/* Reset parameters */
+	pwc_reset_buffers(pdev);
+	/* Try to set video mode... */
+	start = ret = pwc_set_video_mode(pdev, width, height, new_fps, new_compression, new_snapshot);
+	if (ret) { 
+	        Trace(TRACE_FLOW, "pwc_set_video_mode attempt 1 failed.\n");
+		/* That failed... restore old mode (we know that worked) */
+		start = pwc_set_video_mode(pdev, pdev->view.x, pdev->view.y, pdev->vframes, pdev->vcompression, pdev->vsnapshot);
+		if (start) {
+		        Trace(TRACE_FLOW, "pwc_set_video_mode attempt 2 failed.\n");
+		}
+	}
+	if (start == 0) 
+	{
+		if (pwc_isoc_init(pdev) < 0) 
+		{
+			Info("Failed to restart ISOC transfers in pwc_try_video_mode.\n");
+			ret = -EAGAIN; /* let's try again, who knows if it works a second time */
+		}
+	}
+	pdev->drop_frames++; /* try to avoid garbage during switch */
+	return ret; /* Return original error code */
+}
+
+
+/***************************************************************************/
+/* Video4Linux functions */
+
+static int pwc_video_open(struct inode *inode, struct file *file)
+{
+	int i;
+	struct video_device *vdev = video_devdata(file);
+	struct pwc_device *pdev;
+
+	Trace(TRACE_OPEN, ">> video_open called(vdev = 0x%p).\n", vdev);
+	
+	pdev = (struct pwc_device *)vdev->priv;
+	if (pdev == NULL)
+		BUG();
+	if (pdev->vopen)
+		return -EBUSY;
+	
+	down(&pdev->modlock);
+	if (!pdev->usb_init) {
+		Trace(TRACE_OPEN, "Doing first time initialization.\n");
+		pdev->usb_init = 1;
+		
+		if (pwc_trace & TRACE_OPEN) {
+			/* Query sensor type */
+			const char *sensor_type = NULL;
+
+			i = pwc_get_cmos_sensor(pdev);
+			switch(i) {
+			case -1: /* Unknown, show nothing */; break;
+			case 0x00:  sensor_type = "Hyundai CMOS sensor"; break;
+			case 0x20:  sensor_type = "Sony CCD sensor + TDA8787"; break;
+			case 0x2E:  sensor_type = "Sony CCD sensor + Exas 98L59"; break;
+			case 0x2F:  sensor_type = "Sony CCD sensor + ADI 9804"; break;
+			case 0x30:  sensor_type = "Sharp CCD sensor + TDA8787"; break;
+			case 0x3E:  sensor_type = "Sharp CCD sensor + Exas 98L59"; break;
+			case 0x3F:  sensor_type = "Sharp CCD sensor + ADI 9804"; break;
+			case 0x40:  sensor_type = "UPA 1021 sensor"; break;
+			case 0x100: sensor_type = "VGA sensor"; break;
+			case 0x101: sensor_type = "PAL MR sensor"; break;
+			default:    sensor_type = "unknown type of sensor"; break;
+			}
+			if (sensor_type != NULL)
+				Info("This %s camera is equipped with a %s (%d).\n", pdev->vdev.name, sensor_type, i);
+		}
+	}
+
+	/* Turn on camera */
+	if (power_save) {
+		i = pwc_camera_power(pdev, 1);
+		if (i < 0)
+			Info("Failed to restore power to the camera! (%d)\n", i);
+	}
+	/* Set LED on/off time */
+	if (pwc_set_leds(pdev, led_on, led_off) < 0)
+		Info("Failed to set LED on/off time.\n");
+
+	/* Find our decompressor, if any */
+	pdev->decompressor = pwc_find_decompressor(pdev->type);
+#if PWC_DEBUG	
+	Debug("Found decompressor for %d at 0x%p\n", pdev->type, pdev->decompressor);
+#endif
+	pwc_construct(pdev); /* set min/max sizes correct */
+
+	/* So far, so good. Allocate memory. */
+	i = pwc_allocate_buffers(pdev);
+	if (i < 0) {
+		Trace(TRACE_OPEN, "Failed to allocate buffer memory.\n");
+		up(&pdev->modlock);
+		return i;
+	}
+	
+	/* Reset buffers & parameters */
+	pwc_reset_buffers(pdev);
+	for (i = 0; i < default_mbufs; i++)
+		pdev->image_used[i] = 0;
+	pdev->vframe_count = 0;
+	pdev->vframes_dumped = 0;
+	pdev->vframes_error = 0;
+	pdev->visoc_errors = 0;
+	pdev->error_status = 0;
+#if PWC_DEBUG
+	pdev->sequence = 0;
+#endif
+	pwc_construct(pdev); /* set min/max sizes correct */
+
+	/* Set some defaults */
+	pdev->vsnapshot = 0;
+	/* Start iso pipe for video; first try the last used video size
+	   (or the default one); if that fails try QCIF/10 or QSIF/10;
+	   it that fails too, give up.
+	 */
+	i = pwc_set_video_mode(pdev, pwc_image_sizes[pdev->vsize].x, pwc_image_sizes[pdev->vsize].y, pdev->vframes, pdev->vcompression, 0);
+	if (i)	{
+		Trace(TRACE_OPEN, "First attempt at set_video_mode failed.\n");
+		if (pdev->type == 730 || pdev->type == 740 || pdev->type == 750)
+			i = pwc_set_video_mode(pdev, pwc_image_sizes[PSZ_QSIF].x, pwc_image_sizes[PSZ_QSIF].y, 10, pdev->vcompression, 0);
+		else
+			i = pwc_set_video_mode(pdev, pwc_image_sizes[PSZ_QCIF].x, pwc_image_sizes[PSZ_QCIF].y, 10, pdev->vcompression, 0);
+	}
+	if (i) {
+		Trace(TRACE_OPEN, "Second attempt at set_video_mode failed.\n");
+		up(&pdev->modlock);
+		return i;
+	}
+	
+	i = pwc_isoc_init(pdev);
+	if (i) {
+		Trace(TRACE_OPEN, "Failed to init ISOC stuff = %d.\n", i);
+		up(&pdev->modlock);
+		return i;
+	}
+
+	pdev->vopen++;
+	file->private_data = vdev;
+	/* lock decompressor; this has a small race condition, since we 
+	   could in theory unload pwcx.o between pwc_find_decompressor()
+	   above and this call. I doubt it's ever going to be a problem.
+	 */
+	if (pdev->decompressor != NULL)
+		pdev->decompressor->lock();
+	up(&pdev->modlock);
+	Trace(TRACE_OPEN, "<< video_open() returns 0.\n");
+	return 0;
+}
+
+/* Note that all cleanup is done in the reverse order as in _open */
+static int pwc_video_close(struct inode *inode, struct file *file)
+{
+	struct video_device *vdev = file->private_data;
+	struct pwc_device *pdev;
+	int i;
+
+	Trace(TRACE_OPEN, ">> video_close called(vdev = 0x%p).\n", vdev);
+
+	pdev = (struct pwc_device *)vdev->priv;
+	if (pdev->vopen == 0)
+		Info("video_close() called on closed device?\n");
+
+	/* Dump statistics, but only if a reasonable amount of frames were
+	   processed (to prevent endless log-entries in case of snap-shot
+	   programs) 
+	 */
+	if (pdev->vframe_count > 20)
+		Info("Closing video device: %d frames received, dumped %d frames, %d frames with errors.\n", pdev->vframe_count, pdev->vframes_dumped, pdev->vframes_error);
+
+	if (pdev->decompressor != NULL) {
+		pdev->decompressor->exit();
+		pdev->decompressor->unlock();
+		pdev->decompressor = NULL;
+	}
+
+	pwc_isoc_cleanup(pdev);
+	pwc_free_buffers(pdev);
+
+	/* Turn off LEDS and power down camera, but only when not unplugged */
+	if (pdev->error_status != EPIPE) {
+		/* Turn LEDs off */
+		if (pwc_set_leds(pdev, 0, 0) < 0)
+			Info("Failed to set LED on/off time.\n");
+		if (power_save) {
+			i = pwc_camera_power(pdev, 0);
+			if (i < 0) 
+				Err("Failed to power down camera (%d)\n", i);
+		}
+	}
+	pdev->vopen = 0;
+	Trace(TRACE_OPEN, "<< video_close()\n");
+	return 0;
+}
+
+static int pwc_video_release(struct video_device *vfd)
+{
+	Trace(TRACE_OPEN, "pwc_video_release() called. Now what?\n");
+}
+		
+
+/*
+ *	FIXME: what about two parallel reads ????
+ *      ANSWER: Not supported. You can't open the device more than once,
+                despite what the V4L1 interface says. First, I don't see
+                the need, second there's no mechanism of alerting the
+                2nd/3rd/... process of events like changing image size.
+                And I don't see the point of blocking that for the
+                2nd/3rd/... process.
+                In multi-threaded environments reading parallel from any
+                device is tricky anyhow.
+ */
+
+static ssize_t pwc_video_read(struct file *file, char *buf,
+			  size_t count, loff_t *ppos)
+{
+	struct video_device *vdev = file->private_data;
+	struct pwc_device *pdev;
+	int noblock = file->f_flags & O_NONBLOCK;
+	DECLARE_WAITQUEUE(wait, current);
+
+	Trace(TRACE_READ, "video_read(0x%p, %p, %d) called.\n", vdev, buf, count);
+	if (vdev == NULL)
+		return -EFAULT;
+	pdev = vdev->priv;
+	if (pdev == NULL)
+		return -EFAULT;
+	if (pdev->error_status)
+		return -pdev->error_status; /* Something happened, report what. */
+
+	/* In case we're doing partial reads, we don't have to wait for a frame */
+	if (pdev->image_read_pos == 0) {
+		/* Do wait queueing according to the (doc)book */
+		add_wait_queue(&pdev->frameq, &wait);
+		while (pdev->full_frames == NULL) {
+			/* Check for unplugged/etc. here */
+			if (pdev->error_status) {
+				remove_wait_queue(&pdev->frameq, &wait);
+				set_current_state(TASK_RUNNING);
+				return -pdev->error_status ;
+			}
+	                if (noblock) {
+	                	remove_wait_queue(&pdev->frameq, &wait);
+	                	set_current_state(TASK_RUNNING);
+	                	return -EWOULDBLOCK;
+	                }
+	                if (signal_pending(current)) {
+	                	remove_wait_queue(&pdev->frameq, &wait);
+	                	set_current_state(TASK_RUNNING);
+	                	return -ERESTARTSYS;
+	                }
+	                schedule();
+	               	set_current_state(TASK_INTERRUPTIBLE);
+		}
+		remove_wait_queue(&pdev->frameq, &wait);
+		set_current_state(TASK_RUNNING);
+	                                                                                                                                                                                
+		/* Decompress and release frame */
+		if (pwc_handle_frame(pdev))
+			return -EFAULT;
+	}
+
+	Trace(TRACE_READ, "Copying data to user space.\n");
+	/* copy bytes to user space; we allow for partial reads */
+	if (count + pdev->image_read_pos > pdev->view.size)
+		count = pdev->view.size - pdev->image_read_pos;
+	if (copy_to_user(buf, pdev->image_ptr[pdev->fill_image] + pdev->image_read_pos, count))
+		return -EFAULT;
+	pdev->image_read_pos += count;
+	if (pdev->image_read_pos >= pdev->view.size) { /* All data has been read */
+		pdev->image_read_pos = 0;
+		pwc_next_image(pdev);
+	}
+	return count;
+}
+
+static unsigned int pwc_video_poll(struct file *file, poll_table *wait)
+{
+	struct video_device *vdev = file->private_data;
+	struct pwc_device *pdev;
+
+	if (vdev == NULL)
+		return -EFAULT;
+	pdev = vdev->priv;
+	if (pdev == NULL)
+		return -EFAULT;
+
+	poll_wait(file, &pdev->frameq, wait);
+	if (pdev->error_status)
+		return POLLERR;
+	if (pdev->full_frames != NULL) /* we have frames waiting */
+		return (POLLIN | POLLRDNORM);
+
+	return 0;
+}
+
+static int pwc_video_do_ioctl(struct inode *inode, struct file *file,
+			      unsigned int cmd, void *arg)
+{
+	struct video_device *vdev = file->private_data;
+	struct pwc_device *pdev;
+	DECLARE_WAITQUEUE(wait, current);
+
+	if (vdev == NULL)
+		return -EFAULT;
+	pdev = vdev->priv;
+	if (pdev == NULL)
+		return -EFAULT;
+
+	switch (cmd) {
+		/* Query cabapilities */
+		case VIDIOCGCAP:
+		{
+			struct video_capability *caps = arg;
+
+			strcpy(caps->name, vdev->name);
+			caps->type = VID_TYPE_CAPTURE;
+			caps->channels = 1;
+			caps->audios = 1;
+			caps->minwidth  = pdev->view_min.x;
+			caps->minheight = pdev->view_min.y;
+			caps->maxwidth  = pdev->view_max.x;
+			caps->maxheight = pdev->view_max.y;
+			break;
+		}
+
+		/* Channel functions (simulate 1 channel) */
+		case VIDIOCGCHAN:
+		{
+			struct video_channel *v = arg;
+
+			if (v->channel != 0)
+				return -EINVAL;
+			v->flags = 0;
+			v->tuners = 0;
+			v->type = VIDEO_TYPE_CAMERA;
+			strcpy(v->name, "Webcam");
+			return 0;
+		}
+
+		case VIDIOCSCHAN:
+		{	
+			/* The spec says the argument is an integer, but
+			   the bttv driver uses a video_channel arg, which
+			   makes sense becasue it also has the norm flag.
+			 */
+			struct video_channel *v = arg;
+			if (v->channel != 0)
+				return -EINVAL;
+			return 0;
+		}
+
+
+		/* Picture functions; contrast etc. */
+		case VIDIOCGPICT:
+		{
+			struct video_picture *p = arg;
+			int val;
+
+			p->colour = 0x8000;
+			p->hue = 0x8000;
+			val = pwc_get_brightness(pdev);
+			if (val >= 0)
+				p->brightness = val;
+			else
+				p->brightness = 0xffff;
+			val = pwc_get_contrast(pdev);
+			if (val >= 0)
+				p->contrast = val;
+			else
+				p->contrast = 0xffff;
+			/* Gamma, Whiteness, what's the difference? :) */
+			val = pwc_get_gamma(pdev);
+			if (val >= 0)
+				p->whiteness = val;
+			else
+				p->whiteness = 0xffff;
+			val = pwc_get_saturation(pdev);
+			if (val >= 0)
+				p->colour = val;
+			else
+				p->colour = 0xffff;
+			p->depth = 24;
+			p->palette = VIDEO_PALETTE_YUV420P;
+			p->hue = 0xFFFF; /* N/A */
+			break;
+		}
+		
+		case VIDIOCSPICT:
+		{
+			struct video_picture *p = arg;
+			/*
+			 *	FIXME:	Suppose we are mid read
+			        ANSWER: No problem: the firmware of the camera
+			                can handle brightness/contrast/etc
+			                changes at _any_ time, and the palette
+			                is used exactly once in the uncompress
+			                routine.
+			 */
+			if (p->palette && p->palette != VIDEO_PALETTE_YUV420P) {
+				return -EINVAL;
+			}
+			pwc_set_brightness(pdev, p->brightness);
+			pwc_set_contrast(pdev, p->contrast);
+			pwc_set_gamma(pdev, p->whiteness);
+			pwc_set_saturation(pdev, p->colour);
+			break;
+		}
+
+		/* Window/size parameters */		
+		case VIDIOCGWIN:
+		{
+			struct video_window *vw = arg;
+			
+			vw->x = 0;
+			vw->y = 0;
+			vw->width = pdev->view.x;
+			vw->height = pdev->view.y;
+			vw->chromakey = 0;
+			vw->flags = (pdev->vframes << PWC_FPS_SHIFT) | 
+			           (pdev->vsnapshot ? PWC_FPS_SNAPSHOT : 0);
+			break;
+		}
+		
+		case VIDIOCSWIN:
+		{
+			struct video_window *vw = arg;
+			int fps, snapshot, ret;
+
+			fps = (vw->flags & PWC_FPS_FRMASK) >> PWC_FPS_SHIFT;
+			snapshot = vw->flags & PWC_FPS_SNAPSHOT;
+			if (fps == 0)
+				fps = pdev->vframes;
+			if (pdev->view.x == vw->width && pdev->view.y && fps == pdev->vframes && snapshot == pdev->vsnapshot)
+				return 0;
+			ret = pwc_try_video_mode(pdev, vw->width, vw->height, fps, pdev->vcompression, snapshot);
+			if (ret)
+				return ret;
+			break;		
+		}
+		
+		/* We don't have overlay support (yet) */
+		case VIDIOCGFBUF:
+		{
+			struct video_buffer *vb = arg;
+
+			memset(vb,0,sizeof(*vb));
+			break;
+		}
+
+		/* mmap() functions */
+		case VIDIOCGMBUF:
+		{
+			/* Tell the user program how much memory is needed for a mmap() */
+			struct video_mbuf *vm = arg;
+			int i;
+
+			memset(vm, 0, sizeof(*vm));
+			vm->size = default_mbufs * pdev->len_per_image;
+			vm->frames = default_mbufs; /* double buffering should be enough for most applications */
+			for (i = 0; i < default_mbufs; i++)
+				vm->offsets[i] = i * pdev->len_per_image;
+			break;
+		}
+
+		case VIDIOCMCAPTURE:
+		{
+			/* Start capture into a given image buffer (called 'frame' in video_mmap structure) */
+			struct video_mmap *vm = arg;
+
+			Trace(TRACE_READ, "VIDIOCMCAPTURE: %dx%d, frame %d, format %d\n", vm->width, vm->height, vm->frame, vm->format);
+			if (vm->frame < 0 || vm->frame >= default_mbufs)
+				return -EINVAL;
+
+			/* xawtv is nasty. It probes the available palettes
+			   by setting a very small image size and trying
+			   various palettes... The driver doesn't support
+			   such small images, so I'm working around it.
+			 */
+			if (vm->format && vm->format != VIDEO_PALETTE_YUV420P)
+				return -EINVAL;
+			 
+			if ((vm->width != pdev->view.x || vm->height != pdev->view.y) &&
+			    (vm->width >= pdev->view_min.x && vm->height >= pdev->view_min.y)) {
+				int ret;
+				
+				Trace(TRACE_OPEN, "VIDIOCMCAPTURE: changing size to please xawtv :-(.\n");
+				ret = pwc_try_video_mode(pdev, vm->width, vm->height, pdev->vframes, pdev->vcompression, pdev->vsnapshot);
+				if (ret)
+					return ret;
+			} /* ... size mismatch */
+
+			/* FIXME: should we lock here? */
+			if (pdev->image_used[vm->frame])
+				return -EBUSY;	/* buffer wasn't available. Bummer */
+			pdev->image_used[vm->frame] = 1;
+
+			/* Okay, we're done here. In the SYNC call we wait until a 
+			   frame comes available, then expand image into the given 
+			   buffer.
+			   In contrast to the CPiA cam the Philips cams deliver a
+			   constant stream, almost like a grabber card. Also,
+			   we have separate buffers for the rawdata and the image,
+			   meaning we can nearly always expand into the requested buffer.
+			 */
+			Trace(TRACE_READ, "VIDIOCMCAPTURE done.\n");
+			break;
+		}
+
+		case VIDIOCSYNC:
+		{
+			/* The doc says: "Whenever a buffer is used it should
+			   call VIDIOCSYNC to free this frame up and continue."
+			   
+			   The only odd thing about this whole procedure is 
+			   that MCAPTURE flags the buffer as "in use", and
+			   SYNC immediately unmarks it, while it isn't 
+			   after SYNC that you know that the buffer actually
+			   got filled! So you better not start a CAPTURE in
+			   the same frame immediately (use double buffering). 
+			   This is not a problem for this cam, since it has 
+			   extra intermediate buffers, but a hardware 
+			   grabber card will then overwrite the buffer 
+			   you're working on.
+			 */
+			int *mbuf = arg;
+			int ret;
+
+			Trace(TRACE_READ, "VIDIOCSYNC called (%d).\n", *mbuf);
+
+			/* bounds check */
+			if (*mbuf < 0 || *mbuf >= default_mbufs)
+				return -EINVAL;
+			/* check if this buffer was requested anyway */
+			if (pdev->image_used[*mbuf] == 0)
+				return -EINVAL;
+
+			/* Add ourselves to the frame wait-queue.
+			   
+			   FIXME: needs auditing for safety.
+			   QUESTION: In what respect? I think that using the
+			             frameq is safe now.
+			 */
+			add_wait_queue(&pdev->frameq, &wait);
+			while (pdev->full_frames == NULL) {
+				if (pdev->error_status) {
+					remove_wait_queue(&pdev->frameq, &wait);
+					set_current_state(TASK_RUNNING);
+					return -pdev->error_status;
+				}
+			
+	                	if (signal_pending(current)) {
+	                		remove_wait_queue(&pdev->frameq, &wait);
+		                	set_current_state(TASK_RUNNING);
+		                	return -ERESTARTSYS;
+	        	        }
+	                	schedule();
+		                set_current_state(TASK_INTERRUPTIBLE);
+			}
+			remove_wait_queue(&pdev->frameq, &wait);
+			set_current_state(TASK_RUNNING);
+				
+			/* The frame is ready. Expand in the image buffer 
+			   requested by the user. I don't care if you 
+			   mmap() 5 buffers and request data in this order: 
+			   buffer 4 2 3 0 1 2 3 0 4 3 1 . . .
+			   Grabber hardware may not be so forgiving.
+			 */
+			Trace(TRACE_READ, "VIDIOCSYNC: frame ready.\n");
+			pdev->fill_image = *mbuf; /* tell in which buffer we want the image to be expanded */
+			/* Decompress, etc */
+			ret = pwc_handle_frame(pdev);
+			pdev->image_used[*mbuf] = 0;
+			if (ret)
+				return -EFAULT;
+			break;
+		}
+		
+		case VIDIOCGAUDIO:
+		{
+			struct video_audio *v = arg;
+			
+			strcpy(v->name, "Microphone");
+			v->audio = -1; /* unknown audio minor */
+			v->flags = 0;
+			v->mode = VIDEO_SOUND_MONO;
+			v->volume = 0;
+			v->bass = 0;
+			v->treble = 0;
+			v->balance = 0x8000;
+			v->step = 1;
+			break;	
+		}
+		
+		case VIDIOCSAUDIO:
+		{
+			/* Dummy: nothing can be set */
+			break;
+		}
+		
+		case VIDIOCGUNIT:
+		{
+			struct video_unit *vu = arg;
+			
+			vu->video = pdev->vdev.minor & 0x3F;
+			vu->audio = -1; /* not known yet */
+			vu->vbi = -1;
+			vu->radio = -1;
+			vu->teletext = -1;
+			break;
+		}
+		default:
+			return pwc_ioctl(pdev, cmd, arg);
+	} /* ..switch */
+	return 0;
+}	
+
+static int pwc_video_ioctl(struct inode *inode, struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	return video_usercopy(inode, file, cmd, arg, pwc_video_do_ioctl);
+}
+
+
+static int pwc_video_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct video_device *vdev = file->private_data;
+	struct pwc_device *pdev;
+	unsigned long start = vma->vm_start;
+	unsigned long size  = vma->vm_end-vma->vm_start;
+	unsigned long page, pos;
+	
+	Trace(TRACE_MEMORY, "mmap(0x%p, 0x%lx, %lu) called.\n", vdev, start, size);
+	pdev = vdev->priv;
+
+	pos = (unsigned long)pdev->image_data;
+	while (size > 0) {
+		page = kvirt_to_pa(pos);
+		if (remap_page_range(vma, start, page, PAGE_SIZE, PAGE_SHARED))
+			return -EAGAIN;
+
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+
+	return 0;
+}
+
+/***************************************************************************/
+/* USB functions */
+
+/* This function gets called when a new device is plugged in or the usb core
+ * is loaded.
+ */
+
+static int usb_pwc_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct pwc_device *pdev = NULL;
+	int vendor_id, product_id, type_id;
+	int i, hint;
+	int features = 0;
+	int video_nr = -1; /* default: use next available device */
+	char serial_number[30], *name;
+
+	/* Check if we can handle this device */
+	Trace(TRACE_PROBE, "probe() called [%04X %04X], if %d\n", 
+		udev->descriptor.idVendor, udev->descriptor.idProduct, 
+		intf->altsetting->desc.bInterfaceNumber);
+
+	/* the interfaces are probed one by one. We are only interested in the
+	   video interface (0) now.
+	   Interface 1 is the Audio Control, and interface 2 Audio itself.
+	 */
+	if (intf->altsetting->desc.bInterfaceNumber > 0)
+		return -ENODEV;
+
+	vendor_id = udev->descriptor.idVendor;
+	product_id = udev->descriptor.idProduct;
+
+	if (vendor_id == 0x0471) {
+		switch (product_id) {
+		case 0x0302:
+			Info("Philips PCA645VC USB webcam detected.\n");
+			name = "Philips 645 webcam";
+			type_id = 645;
+			break;
+		case 0x0303:
+			Info("Philips PCA646VC USB webcam detected.\n");
+			name = "Philips 646 webcam";
+			type_id = 646;
+			break;
+		case 0x0304:
+			Info("Askey VC010 type 2 USB webcam detected.\n");
+			name = "Askey VC010 webcam";
+			type_id = 646;
+			break;
+		case 0x0307:
+			Info("Philips PCVC675K (Vesta) USB webcam detected.\n");
+			name = "Philips 675 webcam";
+			type_id = 675;
+			break;
+		case 0x0308:
+			Info("Philips PCVC680K (Vesta Pro) USB webcam detected.\n");
+			name = "Philips 680 webcam";
+			type_id = 680;
+			break;
+		case 0x030C:
+			Info("Philips PCVC690K (Vesta Pro Scan) USB webcam detected.\n");
+			name = "Philips 690 webcam";
+			type_id = 690;
+			break;
+		case 0x0310:
+			Info("Philips PCVC730K (ToUCam Fun) USB webcam detected.\n");
+			name = "Philips 730 webcam";
+			type_id = 730;
+			break;
+		case 0x0311:
+			Info("Philips PCVC740K (ToUCam Pro) USB webcam detected.\n");
+			name = "Philips 740 webcam";
+			type_id = 740;
+			break;
+		case 0x0312:
+			Info("Philips PCVC750K (ToUCam Pro Scan) USB webcam detected.\n");
+			name = "Philips 750 webcam";
+			type_id = 750;
+			break;
+		case 0x0313:
+			Info("Philips PCVC720K/40 (ToUCam XS) USB webcam detected.\n");
+			name = "Philips 720K/40 webcam";
+			type_id = 720;
+			break;
+		default:
+			return -ENODEV;
+			break;
+		}
+	}
+	else if (vendor_id == 0x069A) {
+		switch(product_id) {
+		case 0x0001:
+			Info("Askey VC010 type 1 USB webcam detected.\n");
+			name = "Askey VC010 webcam";
+			type_id = 645;
+			break;
+		default:
+			return -ENODEV;
+			break;
+		}
+	}
+	else if (vendor_id == 0x046d) {
+		switch(product_id) {
+		case 0x08b0:
+			Info("Logitech QuickCam Pro 3000 USB webcam detected.\n");
+			name = "Logitech QuickCam Pro 3000";
+			type_id = 740; /* CCD sensor */
+			break;
+		case 0x08b1:
+			Info("Logitech QuickCam Notebook Pro USB webcam detected.\n");
+			name = "Logitech QuickCam Notebook Pro";
+			type_id = 740; /* CCD sensor */
+			break;
+		case 0x08b2:
+			Info("Logitech QuickCam 4000 Pro USB webcam detected.\n");
+			name = "Logitech QuickCam Pro 4000";
+			type_id = 740; /* CCD sensor */
+			break;
+		case 0x08b3:
+			Info("Logitech QuickCam Zoom USB webcam detected.\n");
+			name = "Logitech QuickCam Zoom";
+			type_id = 740; /* CCD sensor */
+			break;
+		case 0x08B4:
+			Info("Logitech QuickCam Zoom (new model) USB webcam detected.\n");
+			name = "Logitech QuickCam Zoom";
+			type_id = 740; /* CCD sensor */
+			break;
+		case 0x08b5:
+			Info("Logitech QuickCam Orbit/Sphere USB webcam detected.\n");
+			name = "Logitech QuickCam Orbit";
+			type_id = 740; /* CCD sensor */
+			features |= FEATURE_MOTOR_PANTILT;
+			break;
+		case 0x08b6:
+		case 0x08b7:
+		case 0x08b8:
+			Info("Logitech QuickCam detected (reserved ID).\n");
+			name = "Logitech QuickCam (res.)";
+			type_id = 730; /* Assuming CMOS */
+			break;
+        	default:
+			return -ENODEV;
+        		break;
+        	}
+        }
+	else if (vendor_id == 0x055d) {
+		/* I don't know the difference between the C10 and the C30;
+		   I suppose the difference is the sensor, but both cameras
+		   work equally well with a type_id of 675
+		 */
+		switch(product_id) {
+		case 0x9000:
+			Info("Samsung MPC-C10 USB webcam detected.\n");
+			name = "Samsung MPC-C10";
+			type_id = 675;
+			break;
+		case 0x9001:
+			Info("Samsung MPC-C30 USB webcam detected.\n");
+			name = "Samsung MPC-C30";
+			type_id = 675;
+			break;
+		default:
+			return -ENODEV;
+			break;
+		}
+	}
+	else if (vendor_id == 0x041e) {
+		switch(product_id) {
+		case 0x400c:
+			Info("Creative Labs Webcam 5 detected.\n");
+			name = "Creative Labs Webcam 5";
+			type_id = 730;
+			break;
+		case 0x4011:
+			Info("Creative Labs Webcam Pro Ex detected.\n");
+			name = "Creative Labs Webcam Pro Ex";
+			type_id = 740;
+			break;
+		default:
+			return -ENODEV;
+			break;
+		}
+	}
+	else if (vendor_id == 0x04cc) { 
+		switch(product_id) {
+		case 0x8116:
+			Info("Sotec Afina Eye USB webcam detected.\n");
+			name = "Sotec Afina Eye";
+			type_id = 730;
+			break;  
+		default:
+			return -ENODEV;
+			break;
+		}
+	}
+	else if (vendor_id == 0x0d81) {
+		switch(product_id) {
+		case 0x1900:
+			Info("Visionite VCS-UC300 USB webcam detected.\n");
+			name = "Visionite VCS-UC300";
+			type_id = 740; /* CCD sensor */
+			break;
+		case 0x1910:
+			Info("Visionite VCS-UM100 USB webcam detected.\n");
+			name = "Visionite VCS-UM100";
+			type_id = 730; /* CMOS sensor */
+			break;
+		default:
+			return -ENODEV;
+			break;
+		}
+	}
+	else 
+		return -ENODEV; /* Not any of the know types; but the list keeps growing. */
+
+	memset(serial_number, 0, 30);
+	usb_string(udev, udev->descriptor.iSerialNumber, serial_number, 29);
+	Trace(TRACE_PROBE, "Device serial number is %s\n", serial_number);
+
+	if (udev->descriptor.bNumConfigurations > 1)
+		Info("Warning: more than 1 configuration available.\n");
+
+	/* Allocate structure, initialize pointers, mutexes, etc. and link it to the usb_device */
+	pdev = kmalloc(sizeof(struct pwc_device), GFP_KERNEL);
+	if (pdev == NULL) {
+		Err("Oops, could not allocate memory for pwc_device.\n");
+		return -ENOMEM;
+	}
+	memset(pdev, 0, sizeof(struct pwc_device));
+	pdev->type = type_id;
+	pdev->vsize = default_size;
+	pdev->vframes = default_fps;
+	pdev->features = features;
+	if (vendor_id == 0x046D && product_id == 0x08B5)
+	{
+		/* Logitech QuickCam Orbit
+	           The ranges have been determined experimentally; they may differ from cam to cam.
+	           Also, the exact ranges left-right and up-down are different for my cam
+	          */
+		pdev->angle_range.pan_min  = -7000;
+		pdev->angle_range.pan_max  =  7000;
+		pdev->angle_range.tilt_min = -3000;
+		pdev->angle_range.tilt_max =  2500;
+		pdev->angle_range.zoom_min = -1;
+		pdev->angle_range.zoom_max = -1;
+	}
+
+	init_MUTEX(&pdev->modlock);
+	pdev->ptrlock = SPIN_LOCK_UNLOCKED;
+
+	pdev->udev = udev;
+	init_waitqueue_head(&pdev->frameq);
+	pdev->vcompression = pwc_preferred_compression;
+
+	memcpy(&pdev->vdev, &pwc_template, sizeof(pwc_template));
+	strcpy(pdev->vdev.name, name);
+	pdev->vdev.owner = THIS_MODULE;
+	pdev->vdev.priv = pdev;
+	
+	pdev->release = udev->descriptor.bcdDevice;
+	Trace(TRACE_PROBE, "Release: %04x\n", pdev->release);
+
+	/* Now search device_hint[] table for a match, so we can hint a node number. */
+	for (hint = 0; hint < MAX_DEV_HINTS; hint++) {
+		if (((device_hint[hint].type == -1) || (device_hint[hint].type == pdev->type)) &&
+		     (device_hint[hint].pdev == NULL)) {
+			/* so far, so good... try serial number */
+			if ((device_hint[hint].serial_number[0] == '*') || !strcmp(device_hint[hint].serial_number, serial_number)) {
+			    	/* match! */
+			    	video_nr = device_hint[hint].device_node;
+			    	Trace(TRACE_PROBE, "Found hint, will try to register as /dev/video%d\n", video_nr);
+			    	break;
+			}
+		}
+	}
+
+	pdev->vdev.release = pwc_video_release;
+	i = video_register_device(&pdev->vdev, VFL_TYPE_GRABBER, video_nr);
+	if (i < 0) {
+		Err("Failed to register as video device (%d).\n", i);
+		kfree(pdev); /* Oops, no memory leaks please */
+		return -EIO;
+	}
+	else {
+		Info("Registered as /dev/video%d.\n", pdev->vdev.minor & 0x3F);
+	}
+
+	/* occupy slot */
+	if (hint < MAX_DEV_HINTS) 
+		device_hint[hint].pdev = pdev;
+
+	Trace(TRACE_PROBE, "probe() function returning struct at 0x%p.\n", pdev);
+	usb_set_intfdata (intf, pdev);
+	return 0;
+}
+
+/* The user janked out the cable... */
+static void usb_pwc_disconnect(struct usb_interface *intf)
+{
+	struct pwc_device *pdev;
+	int hint;
+
+	lock_kernel();
+	pdev = usb_get_intfdata (intf);
+	usb_set_intfdata (intf, NULL);
+	if (pdev == NULL) {
+		Err("pwc_disconnect() Called without private pointer.\n");
+		goto disconnect_out;
+	}
+	if (pdev->udev == NULL) {
+		Err("pwc_disconnect() already called for %p\n", pdev);
+		goto disconnect_out;
+	}
+	if (pdev->udev != interface_to_usbdev(intf)) {
+		Err("pwc_disconnect() Woops: pointer mismatch udev/pdev.\n");
+		goto disconnect_out;
+	}
+#ifdef PWC_MAGIC	
+	if (pdev->magic != PWC_MAGIC) {
+		Err("pwc_disconnect() Magic number failed. Consult your scrolls and try again.\n");
+		goto disconnect_out;
+	}
+#endif	
+	
+	/* We got unplugged; this is signalled by an EPIPE error code */
+	if (pdev->vopen) {
+		Info("Disconnected while webcam is in use!\n");
+		pdev->error_status = EPIPE;
+	}
+	
+	/* Alert waiting processes */
+	wake_up_interruptible(&pdev->frameq);
+	/* Wait until device is closed */
+	while (pdev->vopen)
+		schedule();
+	/* Device is now closed, so we can safely unregister it */
+	Trace(TRACE_PROBE, "Unregistering video device in disconnect().\n");
+	video_unregister_device(&pdev->vdev); 
+
+	/* Free memory (don't set pdev to 0 just yet) */
+	kfree(pdev);
+
+disconnect_out:
+	/* search device_hint[] table if we occupy a slot, by any chance */
+	for (hint = 0; hint < MAX_DEV_HINTS; hint++)
+		if (device_hint[hint].pdev == pdev)
+			device_hint[hint].pdev = NULL;
+
+	unlock_kernel();
+}
+
+
+/* *grunt* We have to do atoi ourselves :-( */
+static int pwc_atoi(const char *s)
+{
+	int k = 0;
+	
+	k = 0;
+	while (*s != '\0' && *s >= '0' && *s <= '9') {
+		k = 10 * k + (*s - '0');
+		s++;
+	}
+	return k;
+}
+
+
+/* 
+ * Initialization code & module stuff 
+ */
+
+static char *size = NULL;
+static int fps = 0;
+static int fbufs = 0;
+static int mbufs = 0;
+static int trace = -1;
+static int compression = -1;
+static int leds[2] = { -1, -1 };
+static char *dev_hint[MAX_DEV_HINTS] = { };
+
+MODULE_PARM(size, "s");
+MODULE_PARM_DESC(size, "Initial image size. One of sqcif, qsif, qcif, sif, cif, vga");
+MODULE_PARM(fps, "i");
+MODULE_PARM_DESC(fps, "Initial frames per second. Varies with model, useful range 5-30");
+MODULE_PARM(fbufs, "i");
+MODULE_PARM_DESC(fbufs, "Number of internal frame buffers to reserve");
+MODULE_PARM(mbufs, "i");
+MODULE_PARM_DESC(mbufs, "Number of external (mmap()ed) image buffers");
+MODULE_PARM(trace, "i");
+MODULE_PARM_DESC(trace, "For debugging purposes");
+MODULE_PARM(power_save, "i");
+MODULE_PARM_DESC(power_save, "Turn power save feature in camera on or off");
+MODULE_PARM(compression, "i");
+MODULE_PARM_DESC(compression, "Preferred compression quality. Range 0 (uncompressed) to 3 (high compression)");
+MODULE_PARM(leds, "2i");
+MODULE_PARM_DESC(leds, "LED on,off time in milliseconds");
+MODULE_PARM(dev_hint, "0-20s");
+MODULE_PARM_DESC(dev_hint, "Device node hints");
+
+MODULE_DESCRIPTION("Philips & OEM USB webcam driver");
+MODULE_AUTHOR("Nemosoft Unv. <nemosoft@smcc.demon.nl>");
+MODULE_LICENSE("GPL");
+
+static int __init usb_pwc_init(void)
+{
+	int i, sz;
+	char *sizenames[PSZ_MAX] = { "sqcif", "qsif", "qcif", "sif", "cif", "vga" };
+
+	Info("Philips PCA645/646 + PCVC675/680/690 + PCVC730/740/750 webcam module version " PWC_VERSION " loaded.\n");
+	Info("Also supports the Askey VC010, various Logitech QuickCams, Samsung MPC-C10 and MPC-C30,\n");
+	Info("the Creative WebCam 5, SOTEC Afina Eye and Visionite VCS-UC300 and VCS-UM100.\n");
+
+	if (fps) {
+		if (fps < 4 || fps > 30) {
+			Err("Framerate out of bounds (4-30).\n");
+			return -EINVAL;
+		}
+		default_fps = fps;
+		Info("Default framerate set to %d.\n", default_fps);
+	}
+	
+	if (size) {
+		/* string; try matching with array */
+		for (sz = 0; sz < PSZ_MAX; sz++) {
+			if (!strcmp(sizenames[sz], size)) { /* Found! */
+				default_size = sz;
+				break;
+			}
+		}
+		if (sz == PSZ_MAX) {
+			Err("Size not recognized; try size=[sqcif | qsif | qcif | sif | cif | vga].\n");
+			return -EINVAL;
+		}
+		Info("Default image size set to %s [%dx%d].\n", sizenames[default_size], pwc_image_sizes[default_size].x, pwc_image_sizes[default_size].y);
+	}
+	if (mbufs) {
+		if (mbufs < 1 || mbufs > MAX_IMAGES) {
+			Err("Illegal number of mmap() buffers; use a number between 1 and %d.\n", MAX_IMAGES);
+			return -EINVAL;
+		}
+		default_mbufs = mbufs;
+		Info("Number of image buffers set to %d.\n", default_mbufs);
+	}
+	if (fbufs) {
+		if (fbufs < 2 || fbufs > MAX_FRAMES) {
+			Err("Illegal number of frame buffers; use a number between 2 and %d.\n", MAX_FRAMES);
+			return -EINVAL;
+		}
+		default_fbufs = fbufs;
+		Info("Number of frame buffers set to %d.\n", default_fbufs);
+	}
+	if (trace >= 0) {
+		Info("Trace options: 0x%04x\n", trace);
+		pwc_trace = trace;
+	}
+	if (compression >= 0) {
+		if (compression > 3) {
+			Err("Invalid compression setting; use a number between 0 (uncompressed) and 3 (high).\n");
+			return -EINVAL;
+		}
+		pwc_preferred_compression = compression;
+		Info("Preferred compression set to %d.\n", pwc_preferred_compression);
+	}
+	if (power_save)
+		Info("Enabling power save on open/close.\n");
+	if (leds[0] >= 0)
+		led_on = leds[0];
+	if (leds[1] >= 0)
+		led_off = leds[1];
+
+	/* Big device node whoopla. Basically, it allows you to assign a 
+	   device node (/dev/videoX) to a camera, based on its type 
+	   & serial number. The format is [type[.serialnumber]:]node.
+
+           Any camera that isn't matched by these rules gets the next 
+           available free device node.
+	 */
+	for (i = 0; i < MAX_DEV_HINTS; i++) {
+		char *s, *colon, *dot;
+
+		/* This loop also initializes the array */
+		device_hint[i].pdev = NULL;
+		s = dev_hint[i];
+		if (s != NULL && *s != '\0') {
+			device_hint[i].type = -1; /* wildcard */
+			strcpy(device_hint[i].serial_number, "*");
+
+			/* parse string: chop at ':' & '/' */
+			colon = dot = s;
+			while (*colon != '\0' && *colon != ':')
+				colon++;
+			while (*dot != '\0' && *dot != '.')
+				dot++;
+			/* Few sanity checks */
+			if (*dot != '\0' && dot > colon) {
+				Err("Malformed camera hint: the colon must be after the dot.\n");
+				return -EINVAL;
+			}
+
+			if (*colon == '\0') {
+				/* No colon */
+				if (*dot != '\0') {
+					Err("Malformed camera hint: no colon + device node given.\n");
+					return -EINVAL;
+				}
+				else {
+					/* No type or serial number specified, just a number. */
+					device_hint[i].device_node = pwc_atoi(s);
+				}
+			}
+			else {
+				/* There's a colon, so we have at least a type and a device node */
+				device_hint[i].type = pwc_atoi(s);
+				device_hint[i].device_node = pwc_atoi(colon + 1);
+				if (*dot != '\0') {
+					/* There's a serial number as well */
+					int k;
+					
+					dot++;
+					k = 0;
+					while (*dot != ':' && k < 29) {
+						device_hint[i].serial_number[k++] = *dot;
+						dot++;
+					}
+					device_hint[i].serial_number[k] = '\0';
+				}
+			}
+#if PWC_DEBUG		
+			Debug("device_hint[%d]:\n", i);
+			Debug("  type    : %d\n", device_hint[i].type);
+			Debug("  serial# : %s\n", device_hint[i].serial_number);
+			Debug("  node    : %d\n", device_hint[i].device_node);
+#endif			
+		}
+		else
+			device_hint[i].type = 0; /* not filled */
+	} /* ..for MAX_DEV_HINTS */
+
+ 	Trace(TRACE_PROBE, "Registering driver at address 0x%p.\n", &pwc_driver);
+	return usb_register(&pwc_driver);
+}
+
+static void __exit usb_pwc_exit(void)
+{
+	Trace(TRACE_MODULE, "Deregistering driver.\n");
+	usb_deregister(&pwc_driver);
+	Info("Philips webcam module removed.\n");
+}
+
+module_init(usb_pwc_init);
+module_exit(usb_pwc_exit);
+
diff -Naur linuxppc-2.6.9/drivers/usb/media/pwc-ioctl.h linuxppc-2.6.9-dream/drivers/usb/media/pwc-ioctl.h
--- linuxppc-2.6.9/drivers/usb/media/pwc-ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/media/pwc-ioctl.h	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,229 @@
+#ifndef PWC_IOCTL_H
+#define PWC_IOCTL_H
+
+/* (C) 2001-2003 Nemosoft Unv.    webcam@smcc.demon.nl
+   
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*         This is pwc-ioctl.h belonging to PWC 8.10                        */
+
+/* 
+   Changes
+   2001/08/03  Alvarado   Added ioctl constants to access methods for 
+                          changing white balance and red/blue gains
+   2002/12/15  G. H. Fernandez-Toribio   VIDIOCGREALSIZE
+ */
+
+/* These are private ioctl() commands, specific for the Philips webcams.
+   They contain functions not found in other webcams, and settings not
+   specified in the Video4Linux API. 
+   
+   The #define names are built up like follows:
+   VIDIOC		VIDeo IOCtl prefix
+         PWC		Philps WebCam
+            G           optional: Get
+            S           optional: Set
+             ... 	the function
+ */
+
+
+
+
+/* The frame rate is encoded in the video_window.flags parameter using
+   the upper 16 bits, since some flags are defined nowadays. The following
+   defines provide a mask and shift to filter out this value.
+   
+   In 'Snapshot' mode the camera freezes its automatic exposure and colour 
+   balance controls.
+ */
+#define PWC_FPS_SHIFT		16
+#define PWC_FPS_MASK		0x00FF0000
+#define PWC_FPS_FRMASK		0x003F0000
+#define PWC_FPS_SNAPSHOT	0x00400000
+
+
+
+struct pwc_probe
+{
+	char name[32];
+	int type;
+};
+
+
+/* pwc_whitebalance.mode values */
+#define PWC_WB_INDOOR		0
+#define PWC_WB_OUTDOOR		1
+#define PWC_WB_FL		2
+#define PWC_WB_MANUAL		3
+#define PWC_WB_AUTO		4
+
+/* Used with VIDIOCPWC[SG]AWB (Auto White Balance). 
+   Set mode to one of the PWC_WB_* values above.
+   *red and *blue are the respective gains of these colour components inside 
+   the camera; range 0..65535
+   When 'mode' == PWC_WB_MANUAL, 'manual_red' and 'manual_blue' are set or read; 
+   otherwise undefined.
+   'read_red' and 'read_blue' are read-only.
+*/   
+   
+struct pwc_whitebalance
+{
+	int mode;
+	int manual_red, manual_blue;	/* R/W */
+	int read_red, read_blue;	/* R/O */
+};
+
+/* 
+   'control_speed' and 'control_delay' are used in automatic whitebalance mode,
+   and tell the camera how fast it should react to changes in lighting, and 
+   with how much delay. Valid values are 0..65535.
+*/
+struct pwc_wb_speed
+{
+	int control_speed;
+	int control_delay;
+
+};
+
+/* Used with VIDIOCPWC[SG]LED */
+struct pwc_leds
+{
+	int led_on;			/* Led on-time; range = 0..25000 */
+	int led_off;			/* Led off-time; range = 0..25000  */
+};
+
+/* Image size (used with GREALSIZE) */
+struct pwc_imagesize
+{
+	int width;
+	int height;
+};
+
+/* Defines and structures for Motorized Pan & Tilt */
+#define PWC_MPT_PAN		0x01
+#define PWC_MPT_TILT		0x02
+#define PWC_MPT_TIMEOUT		0x04 /* for status */
+
+/* Set angles; when absolute = 1, the angle is absolute and the 
+   driver calculates the relative offset for you. This can only
+   be used with VIDIOCPWCSANGLE; VIDIOCPWCGANGLE always returns
+   absolute angles.
+ */   
+struct pwc_mpt_angles
+{
+	int absolute;		/* write-only */
+	int pan;		/* degrees * 100 */
+	int tilt;		/* degress * 100 */
+	int zoom;		/* N/A, set to -1 */
+};
+
+/* Range of angles of the camera, both horizontally and vertically.
+   The zoom is not used, maybe in the future...
+
+ */
+struct pwc_mpt_range
+{
+	int pan_min, pan_max;		/* degrees * 100 */
+	int tilt_min, tilt_max;
+	int zoom_min, zoom_max;		/* -1, -1 */
+};
+
+struct pwc_mpt_status
+{
+	int status;
+	int time_pan;
+	int time_tilt;
+};
+
+
+ /* Restore user settings */
+#define VIDIOCPWCRUSER		_IO('v', 192)
+ /* Save user settings */
+#define VIDIOCPWCSUSER		_IO('v', 193)
+ /* Restore factory settings */
+#define VIDIOCPWCFACTORY	_IO('v', 194)
+
+ /* You can manipulate the compression factor. A compression preference of 0
+    means use uncompressed modes when available; 1 is low compression, 2 is
+    medium and 3 is high compression preferred. Of course, the higher the
+    compression, the lower the bandwidth used but more chance of artefacts
+    in the image. The driver automatically chooses a higher compression when
+    the preferred mode is not available.
+  */
+ /* Set preferred compression quality (0 = uncompressed, 3 = highest compression) */
+#define VIDIOCPWCSCQUAL		_IOW('v', 195, int)
+ /* Get preferred compression quality */
+#define VIDIOCPWCGCQUAL		_IOR('v', 195, int)
+
+
+ /* This is a probe function; since so many devices are supported, it
+    becomes difficult to include all the names in programs that want to
+    check for the enhanced Philips stuff. So in stead, try this PROBE;
+    it returns a structure with the original name, and the corresponding 
+    Philips type.
+    To use, fill the structure with zeroes, call PROBE and if that succeeds,
+    compare the name with that returned from VIDIOCGCAP; they should be the
+    same. If so, you can be assured it is a Philips (OEM) cam and the type
+    is valid.
+ */    
+#define VIDIOCPWCPROBE		_IOR('v', 199, struct pwc_probe)
+
+ /* Set AGC (Automatic Gain Control); int < 0 = auto, 0..65535 = fixed */
+#define VIDIOCPWCSAGC		_IOW('v', 200, int)
+ /* Get AGC; int < 0 = auto; >= 0 = fixed, range 0..65535 */
+#define VIDIOCPWCGAGC		_IOR('v', 200, int)
+ /* Set shutter speed; int < 0 = auto; >= 0 = fixed, range 0..65535 */
+#define VIDIOCPWCSSHUTTER	_IOW('v', 201, int)
+
+ /* Color compensation (Auto White Balance) */
+#define VIDIOCPWCSAWB           _IOW('v', 202, struct pwc_whitebalance)
+#define VIDIOCPWCGAWB           _IOR('v', 202, struct pwc_whitebalance)
+
+ /* Auto WB speed */
+#define VIDIOCPWCSAWBSPEED	_IOW('v', 203, struct pwc_wb_speed)
+#define VIDIOCPWCGAWBSPEED	_IOR('v', 203, struct pwc_wb_speed)
+
+ /* LEDs on/off/blink; int range 0..65535 */
+#define VIDIOCPWCSLED           _IOW('v', 205, struct pwc_leds)
+#define VIDIOCPWCGLED           _IOR('v', 205, struct pwc_leds)
+
+  /* Contour (sharpness); int < 0 = auto, 0..65536 = fixed */
+#define VIDIOCPWCSCONTOUR	_IOW('v', 206, int)
+#define VIDIOCPWCGCONTOUR	_IOR('v', 206, int)
+
+  /* Backlight compensation; 0 = off, otherwise on */
+#define VIDIOCPWCSBACKLIGHT	_IOW('v', 207, int)
+#define VIDIOCPWCGBACKLIGHT	_IOR('v', 207, int)
+
+  /* Flickerless mode; = 0 off, otherwise on */
+#define VIDIOCPWCSFLICKER	_IOW('v', 208, int)
+#define VIDIOCPWCGFLICKER	_IOR('v', 208, int)  
+
+  /* Dynamic noise reduction; 0 off, 3 = high noise reduction */
+#define VIDIOCPWCSDYNNOISE	_IOW('v', 209, int)
+#define VIDIOCPWCGDYNNOISE	_IOR('v', 209, int)
+
+ /* Real image size as used by the camera; tells you whether or not there's a gray border around the image */
+#define VIDIOCPWCGREALSIZE	_IOR('v', 210, struct pwc_imagesize)
+
+ /* Motorized pan & tilt functions */ 
+#define VIDIOCPWCMPTRESET	_IOW('v', 211, int)
+#define VIDIOCPWCMPTGRANGE	_IOR('v', 211, struct pwc_mpt_range)
+#define VIDIOCPWCMPTSANGLE	_IOW('v', 212, struct pwc_mpt_angles)
+#define VIDIOCPWCMPTGANGLE	_IOR('v', 212, struct pwc_mpt_angles)
+#define VIDIOCPWCMPTSTATUS	_IOR('v', 213, struct pwc_mpt_status)
+ 
+#endif
diff -Naur linuxppc-2.6.9/drivers/usb/media/pwc_kiara.h linuxppc-2.6.9-dream/drivers/usb/media/pwc_kiara.h
--- linuxppc-2.6.9/drivers/usb/media/pwc_kiara.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/media/pwc_kiara.h	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,270 @@
+   /* SQCIF */
+   {
+      /* 5 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 10 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 15 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 20 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 25 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 30 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+   },
+   /* QSIF */
+   {
+      /* 5 fps */
+      {
+         {1, 146,    0, {0x1D, 0xF4, 0x30, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x92, 0x00, 0x80}},
+         {1, 146,    0, {0x1D, 0xF4, 0x30, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x92, 0x00, 0x80}},
+         {1, 146,    0, {0x1D, 0xF4, 0x30, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x92, 0x00, 0x80}},
+         {1, 146,    0, {0x1D, 0xF4, 0x30, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x92, 0x00, 0x80}},
+      },
+      /* 10 fps */
+      {
+         {2, 291,    0, {0x1C, 0xF4, 0x30, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x23, 0x01, 0x80}},
+         {1, 192,  630, {0x14, 0xF4, 0x30, 0x13, 0xA9, 0x12, 0xE1, 0x17, 0x08, 0xC0, 0x00, 0x80}},
+         {1, 192,  630, {0x14, 0xF4, 0x30, 0x13, 0xA9, 0x12, 0xE1, 0x17, 0x08, 0xC0, 0x00, 0x80}},
+         {1, 192,  630, {0x14, 0xF4, 0x30, 0x13, 0xA9, 0x12, 0xE1, 0x17, 0x08, 0xC0, 0x00, 0x80}},
+      },
+      /* 15 fps */
+      {
+         {3, 437,    0, {0x1B, 0xF4, 0x30, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0xB5, 0x01, 0x80}},
+         {2, 292,  640, {0x13, 0xF4, 0x30, 0x13, 0xF7, 0x13, 0x2F, 0x13, 0x20, 0x24, 0x01, 0x80}},
+         {2, 292,  640, {0x13, 0xF4, 0x30, 0x13, 0xF7, 0x13, 0x2F, 0x13, 0x20, 0x24, 0x01, 0x80}},
+         {1, 192,  420, {0x13, 0xF4, 0x30, 0x0D, 0x1B, 0x0C, 0x53, 0x1E, 0x18, 0xC0, 0x00, 0x80}},
+      },
+      /* 20 fps */
+      {
+         {4, 589,    0, {0x1A, 0xF4, 0x30, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x4D, 0x02, 0x80}},
+         {3, 448,  730, {0x12, 0xF4, 0x30, 0x16, 0xC9, 0x16, 0x01, 0x0E, 0x18, 0xC0, 0x01, 0x80}},
+         {2, 292,  476, {0x12, 0xF4, 0x30, 0x0E, 0xD8, 0x0E, 0x10, 0x19, 0x18, 0x24, 0x01, 0x80}},
+         {1, 192,  312, {0x12, 0xF4, 0x50, 0x09, 0xB3, 0x08, 0xEB, 0x1E, 0x18, 0xC0, 0x00, 0x80}},
+      },
+      /* 25 fps */
+      {
+         {5, 703,    0, {0x19, 0xF4, 0x30, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0xBF, 0x02, 0x80}},
+         {3, 447,  610, {0x11, 0xF4, 0x30, 0x13, 0x0B, 0x12, 0x43, 0x14, 0x28, 0xBF, 0x01, 0x80}},
+         {2, 292,  398, {0x11, 0xF4, 0x50, 0x0C, 0x6C, 0x0B, 0xA4, 0x1E, 0x28, 0x24, 0x01, 0x80}},
+         {1, 193,  262, {0x11, 0xF4, 0x50, 0x08, 0x23, 0x07, 0x5B, 0x1E, 0x28, 0xC1, 0x00, 0x80}},
+      },
+      /* 30 fps */
+      {
+         {8, 874,    0, {0x18, 0xF4, 0x30, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x6A, 0x03, 0x80}},
+         {5, 704,  730, {0x10, 0xF4, 0x30, 0x16, 0xC9, 0x16, 0x01, 0x0E, 0x28, 0xC0, 0x02, 0x80}},
+         {3, 448,  492, {0x10, 0xF4, 0x30, 0x0F, 0x5D, 0x0E, 0x95, 0x15, 0x28, 0xC0, 0x01, 0x80}},
+         {2, 292,  320, {0x10, 0xF4, 0x50, 0x09, 0xFB, 0x09, 0x33, 0x1E, 0x28, 0x24, 0x01, 0x80}},
+      },
+   },
+   /* QCIF */
+   {
+      /* 5 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 10 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 15 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 20 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 25 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 30 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+   },
+   /* SIF */
+   {
+      /* 5 fps */
+      {
+         {4, 582,    0, {0x0D, 0xF4, 0x30, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x46, 0x02, 0x80}},
+         {3, 387, 1276, {0x05, 0xF4, 0x30, 0x27, 0xD8, 0x26, 0x48, 0x03, 0x10, 0x83, 0x01, 0x80}},
+         {2, 291,  960, {0x05, 0xF4, 0x30, 0x1D, 0xF2, 0x1C, 0x62, 0x04, 0x10, 0x23, 0x01, 0x80}},
+         {1, 191,  630, {0x05, 0xF4, 0x50, 0x13, 0xA9, 0x12, 0x19, 0x05, 0x18, 0xBF, 0x00, 0x80}},
+      },
+      /* 10 fps */
+      {
+         {0, },
+         {6, 775, 1278, {0x04, 0xF4, 0x30, 0x27, 0xE8, 0x26, 0x58, 0x05, 0x30, 0x07, 0x03, 0x80}},
+         {3, 447,  736, {0x04, 0xF4, 0x30, 0x16, 0xFB, 0x15, 0x6B, 0x05, 0x28, 0xBF, 0x01, 0x80}},
+         {2, 292,  480, {0x04, 0xF4, 0x70, 0x0E, 0xF9, 0x0D, 0x69, 0x09, 0x28, 0x24, 0x01, 0x80}},
+      },
+      /* 15 fps */
+      {
+         {0, },
+         {9, 955, 1050, {0x03, 0xF4, 0x30, 0x20, 0xCF, 0x1F, 0x3F, 0x06, 0x48, 0xBB, 0x03, 0x80}},
+         {4, 592,  650, {0x03, 0xF4, 0x30, 0x14, 0x44, 0x12, 0xB4, 0x08, 0x30, 0x50, 0x02, 0x80}},
+         {3, 448,  492, {0x03, 0xF4, 0x50, 0x0F, 0x52, 0x0D, 0xC2, 0x09, 0x38, 0xC0, 0x01, 0x80}},
+      },
+      /* 20 fps */
+      {
+         {0, },
+         {9, 958,  782, {0x02, 0xF4, 0x30, 0x18, 0x6A, 0x16, 0xDA, 0x0B, 0x58, 0xBE, 0x03, 0x80}},
+         {5, 703,  574, {0x02, 0xF4, 0x50, 0x11, 0xE7, 0x10, 0x57, 0x0B, 0x40, 0xBF, 0x02, 0x80}},
+         {3, 446,  364, {0x02, 0xF4, 0x90, 0x0B, 0x5C, 0x09, 0xCC, 0x0E, 0x38, 0xBE, 0x01, 0x80}},
+      },
+      /* 25 fps */
+      {
+         {0, },
+         {9, 958,  654, {0x01, 0xF4, 0x30, 0x14, 0x66, 0x12, 0xD6, 0x0B, 0x50, 0xBE, 0x03, 0x80}},
+         {6, 776,  530, {0x01, 0xF4, 0x50, 0x10, 0x8C, 0x0E, 0xFC, 0x0C, 0x48, 0x08, 0x03, 0x80}},
+         {4, 592,  404, {0x01, 0xF4, 0x70, 0x0C, 0x96, 0x0B, 0x06, 0x0B, 0x48, 0x50, 0x02, 0x80}},
+      },
+      /* 30 fps */
+      {
+         {0, },
+         {9, 957,  526, {0x00, 0xF4, 0x50, 0x10, 0x68, 0x0E, 0xD8, 0x0D, 0x58, 0xBD, 0x03, 0x80}},
+         {6, 775,  426, {0x00, 0xF4, 0x70, 0x0D, 0x48, 0x0B, 0xB8, 0x0F, 0x50, 0x07, 0x03, 0x80}},
+         {4, 590,  324, {0x00, 0x7A, 0x88, 0x0A, 0x1C, 0x08, 0xB4, 0x0E, 0x50, 0x4E, 0x02, 0x80}},
+      },
+   },
+   /* CIF */
+   {
+      /* 5 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 10 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 15 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 20 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 25 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 30 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+   },
+   /* VGA */
+   {
+      /* 5 fps */
+      {
+         {0, },
+         {6, 773, 1272, {0x25, 0xF4, 0x30, 0x27, 0xB6, 0x24, 0x96, 0x02, 0x30, 0x05, 0x03, 0x80}},
+         {4, 592,  976, {0x25, 0xF4, 0x50, 0x1E, 0x78, 0x1B, 0x58, 0x03, 0x30, 0x50, 0x02, 0x80}},
+         {3, 448,  738, {0x25, 0xF4, 0x90, 0x17, 0x0C, 0x13, 0xEC, 0x04, 0x30, 0xC0, 0x01, 0x80}},
+      },
+      /* 10 fps */
+      {
+         {0, },
+         {9, 956,  788, {0x24, 0xF4, 0x70, 0x18, 0x9C, 0x15, 0x7C, 0x03, 0x48, 0xBC, 0x03, 0x80}},
+         {6, 776,  640, {0x24, 0xF4, 0xB0, 0x13, 0xFC, 0x11, 0x2C, 0x04, 0x48, 0x08, 0x03, 0x80}},
+         {4, 592,  488, {0x24, 0x7A, 0xE8, 0x0F, 0x3C, 0x0C, 0x6C, 0x06, 0x48, 0x50, 0x02, 0x80}},
+      },
+      /* 15 fps */
+      {
+         {0, },
+         {9, 957,  526, {0x23, 0x7A, 0xE8, 0x10, 0x68, 0x0D, 0x98, 0x06, 0x58, 0xBD, 0x03, 0x80}},
+         {9, 957,  526, {0x23, 0x7A, 0xE8, 0x10, 0x68, 0x0D, 0x98, 0x06, 0x58, 0xBD, 0x03, 0x80}},
+         {8, 895,  492, {0x23, 0x7A, 0xE8, 0x0F, 0x5D, 0x0C, 0x8D, 0x06, 0x58, 0x7F, 0x03, 0x80}},
+      },
+      /* 20 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 25 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 30 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+   },
diff -Naur linuxppc-2.6.9/drivers/usb/media/pwc-misc.c linuxppc-2.6.9-dream/drivers/usb/media/pwc-misc.c
--- linuxppc-2.6.9/drivers/usb/media/pwc-misc.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/media/pwc-misc.c	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,122 @@
+/* Linux driver for Philips webcam 
+   Various miscellaneous functions and tables.
+   (C) 1999-2003 Nemosoft Unv. (webcam@smcc.demon.nl)
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/  
+
+#include <linux/slab.h>
+
+#include "pwc.h"
+
+struct pwc_coord pwc_image_sizes[PSZ_MAX] = 
+{
+	{ 128,  96, 0 },
+	{ 160, 120, 0 },
+	{ 176, 144, 0 },
+	{ 320, 240, 0 },
+	{ 352, 288, 0 },
+	{ 640, 480, 0 },
+};
+
+/* x,y -> PSZ_ */
+int pwc_decode_size(struct pwc_device *pdev, int width, int height)
+{
+	int i, find;
+
+	/* Make sure we don't go beyond our max size */
+	if (width > pdev->view_max.x || height > pdev->view_max.y)
+		return -1;
+	/* Find the largest size supported by the camera that fits into the
+	   requested size. 
+	 */
+	find = -1;
+	for (i = 0; i < PSZ_MAX; i++) {
+		if (pdev->image_mask & (1 << i)) {
+			if (pwc_image_sizes[i].x <= width && pwc_image_sizes[i].y <= height)
+				find = i;
+		}
+	}
+	return find;
+}
+
+/* initialize variables depending on type and decompressor*/
+void pwc_construct(struct pwc_device *pdev)
+{
+	switch(pdev->type) {
+	case 645:
+	case 646:
+		pdev->view_min.x = 128;
+		pdev->view_min.y =  96;
+		pdev->view_max.x = 352;
+		pdev->view_max.y = 288;
+		pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QCIF | 1 << PSZ_CIF;
+		pdev->vcinterface = 2;
+		pdev->vendpoint = 4;
+		pdev->frame_header_size = 0;
+		pdev->frame_trailer_size = 0;
+		break;
+	case 675:
+	case 680:
+	case 690:
+		pdev->view_min.x = 128;
+		pdev->view_min.y =  96;
+		/* Anthill bug #38: PWC always reports max size, even without PWCX */
+		if (pdev->decompressor != NULL) {
+			pdev->view_max.x = 640;
+			pdev->view_max.y = 480;
+			pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QSIF | 1 << PSZ_QCIF | 1 << PSZ_SIF | 1 << PSZ_CIF | 1 << PSZ_VGA;
+		}
+		else {
+			pdev->view_max.x = 352;
+			pdev->view_max.y = 288;
+			pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QSIF | 1 << PSZ_QCIF | 1 << PSZ_SIF | 1 << PSZ_CIF;
+		}
+		pdev->vcinterface = 3;
+		pdev->vendpoint = 4;
+		pdev->frame_header_size = 0;
+		pdev->frame_trailer_size = 0;
+		break;
+	case 720:
+	case 730:
+	case 740:
+	case 750:
+		pdev->view_min.x = 160;
+		pdev->view_min.y = 120;
+		/* Anthill bug #38: PWC always reports max size, even without PWCX */
+		if (pdev->decompressor != NULL) {
+			pdev->view_max.x = 640;
+			pdev->view_max.y = 480;
+			pdev->image_mask = 1 << PSZ_QSIF | 1 << PSZ_SIF | 1 << PSZ_VGA;
+		}
+		else {
+			/* Tell CIF, even though SIF really is the maximum, but some tools really need CIF */
+			pdev->view_max.x = 352;
+			pdev->view_max.y = 288;
+			pdev->image_mask = 1 << PSZ_QSIF | 1 << PSZ_SIF;
+		}
+		pdev->vcinterface = 3;
+		pdev->vendpoint = 5;
+		pdev->frame_header_size = TOUCAM_HEADER_SIZE;
+		pdev->frame_trailer_size = TOUCAM_TRAILER_SIZE;
+		break;
+	}
+	pdev->view_min.size = pdev->view_min.x * pdev->view_min.y;
+	pdev->view_max.size = pdev->view_max.x * pdev->view_max.y;
+	/* length of image, in YUV format */
+	pdev->len_per_image = (pdev->view_max.size * 3) / 2;
+}
+
+
diff -Naur linuxppc-2.6.9/drivers/usb/media/pwc_nala.h linuxppc-2.6.9-dream/drivers/usb/media/pwc_nala.h
--- linuxppc-2.6.9/drivers/usb/media/pwc_nala.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/media/pwc_nala.h	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,66 @@
+   /* SQCIF */
+   {
+      {0, 0, {0x04, 0x01, 0x03}},
+      {8, 0, {0x05, 0x01, 0x03}},
+      {7, 0, {0x08, 0x01, 0x03}},
+      {7, 0, {0x0A, 0x01, 0x03}},
+      {6, 0, {0x0C, 0x01, 0x03}},
+      {5, 0, {0x0F, 0x01, 0x03}},
+      {4, 0, {0x14, 0x01, 0x03}},
+      {3, 0, {0x18, 0x01, 0x03}},
+   },
+   /* QSIF */
+   {
+      {0},
+      {0},
+      {0},
+      {0},
+      {0},
+      {0},
+      {0},
+      {0},
+   },
+   /* QCIF */
+   {
+      {0, 0, {0x04, 0x01, 0x02}},
+      {8, 0, {0x05, 0x01, 0x02}},
+      {7, 0, {0x08, 0x01, 0x02}},
+      {6, 0, {0x0A, 0x01, 0x02}},
+      {5, 0, {0x0C, 0x01, 0x02}},
+      {4, 0, {0x0F, 0x01, 0x02}},
+      {1, 0, {0x14, 0x01, 0x02}},
+      {1, 0, {0x18, 0x01, 0x02}},
+   },
+   /* SIF */
+   {
+      {0},
+      {0},
+      {0},
+      {0},
+      {0},
+      {0},
+      {0},
+      {0},
+   },
+   /* CIF */
+   {
+      {4, 0, {0x04, 0x01, 0x01}},
+      {7, 1, {0x05, 0x03, 0x01}},
+      {6, 1, {0x08, 0x03, 0x01}},
+      {4, 1, {0x0A, 0x03, 0x01}},
+      {3, 1, {0x0C, 0x03, 0x01}},
+      {2, 1, {0x0F, 0x03, 0x01}},
+      {0},
+      {0},
+   },
+   /* VGA */
+   {  
+      {0},
+      {0},
+      {0},
+      {0},
+      {0},
+      {0},
+      {0},
+      {0},
+   },
diff -Naur linuxppc-2.6.9/drivers/usb/media/pwc_timon.h linuxppc-2.6.9-dream/drivers/usb/media/pwc_timon.h
--- linuxppc-2.6.9/drivers/usb/media/pwc_timon.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/media/pwc_timon.h	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,270 @@
+   /* SQCIF */
+   {
+      /* 5 fps */
+      {
+         {1, 140,    0, {0x05, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x8C, 0xFC, 0x80, 0x02}},
+         {1, 140,    0, {0x05, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x8C, 0xFC, 0x80, 0x02}},
+         {1, 140,    0, {0x05, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x8C, 0xFC, 0x80, 0x02}},
+         {1, 140,    0, {0x05, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x8C, 0xFC, 0x80, 0x02}},
+      },
+      /* 10 fps */
+      {
+         {2, 280,    0, {0x04, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x18, 0xA9, 0x80, 0x02}},
+         {2, 280,    0, {0x04, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x18, 0xA9, 0x80, 0x02}},
+         {2, 280,    0, {0x04, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x18, 0xA9, 0x80, 0x02}},
+         {2, 280,    0, {0x04, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x18, 0xA9, 0x80, 0x02}},
+      },
+      /* 15 fps */
+      {
+         {3, 410,    0, {0x03, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x9A, 0x71, 0x80, 0x02}},
+         {3, 410,    0, {0x03, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x9A, 0x71, 0x80, 0x02}},
+         {3, 410,    0, {0x03, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x9A, 0x71, 0x80, 0x02}},
+         {3, 410,    0, {0x03, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x9A, 0x71, 0x80, 0x02}},
+      },
+      /* 20 fps */
+      {
+         {4, 559,    0, {0x02, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x2F, 0x56, 0x80, 0x02}},
+         {4, 559,    0, {0x02, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x2F, 0x56, 0x80, 0x02}},
+         {4, 559,    0, {0x02, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x2F, 0x56, 0x80, 0x02}},
+         {4, 559,    0, {0x02, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x2F, 0x56, 0x80, 0x02}},
+      },
+      /* 25 fps */
+      {
+         {5, 659,    0, {0x01, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x93, 0x46, 0x80, 0x02}},
+         {5, 659,    0, {0x01, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x93, 0x46, 0x80, 0x02}},
+         {5, 659,    0, {0x01, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x93, 0x46, 0x80, 0x02}},
+         {5, 659,    0, {0x01, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x93, 0x46, 0x80, 0x02}},
+      },
+      /* 30 fps */
+      {
+         {7, 838,    0, {0x00, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x46, 0x3B, 0x80, 0x02}},
+         {7, 838,    0, {0x00, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x46, 0x3B, 0x80, 0x02}},
+         {7, 838,    0, {0x00, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x46, 0x3B, 0x80, 0x02}},
+         {7, 838,    0, {0x00, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x46, 0x3B, 0x80, 0x02}},
+      },
+   },
+   /* QSIF */
+   {
+      /* 5 fps */
+      {
+         {1, 146,    0, {0x2D, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x92, 0xFC, 0xC0, 0x02}},
+         {1, 146,    0, {0x2D, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x92, 0xFC, 0xC0, 0x02}},
+         {1, 146,    0, {0x2D, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x92, 0xFC, 0xC0, 0x02}},
+         {1, 146,    0, {0x2D, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x92, 0xFC, 0xC0, 0x02}},
+      },
+      /* 10 fps */
+      {
+         {2, 291,    0, {0x2C, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x23, 0xA1, 0xC0, 0x02}},
+         {1, 191,  630, {0x2C, 0xF4, 0x05, 0x13, 0xA9, 0x12, 0xE1, 0x17, 0x08, 0xBF, 0xF4, 0xC0, 0x02}},
+         {1, 191,  630, {0x2C, 0xF4, 0x05, 0x13, 0xA9, 0x12, 0xE1, 0x17, 0x08, 0xBF, 0xF4, 0xC0, 0x02}},
+         {1, 191,  630, {0x2C, 0xF4, 0x05, 0x13, 0xA9, 0x12, 0xE1, 0x17, 0x08, 0xBF, 0xF4, 0xC0, 0x02}},
+      },
+      /* 15 fps */
+      {
+         {3, 437,    0, {0x2B, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0xB5, 0x6D, 0xC0, 0x02}},
+         {2, 291,  640, {0x2B, 0xF4, 0x05, 0x13, 0xF7, 0x13, 0x2F, 0x13, 0x08, 0x23, 0xA1, 0xC0, 0x02}},
+         {2, 291,  640, {0x2B, 0xF4, 0x05, 0x13, 0xF7, 0x13, 0x2F, 0x13, 0x08, 0x23, 0xA1, 0xC0, 0x02}},
+         {1, 191,  420, {0x2B, 0xF4, 0x0D, 0x0D, 0x1B, 0x0C, 0x53, 0x1E, 0x08, 0xBF, 0xF4, 0xC0, 0x02}},
+      },
+      /* 20 fps */
+      {
+         {4, 588,    0, {0x2A, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x4C, 0x52, 0xC0, 0x02}},
+         {3, 447,  730, {0x2A, 0xF4, 0x05, 0x16, 0xC9, 0x16, 0x01, 0x0E, 0x18, 0xBF, 0x69, 0xC0, 0x02}},
+         {2, 292,  476, {0x2A, 0xF4, 0x0D, 0x0E, 0xD8, 0x0E, 0x10, 0x19, 0x18, 0x24, 0xA1, 0xC0, 0x02}},
+         {1, 192,  312, {0x2A, 0xF4, 0x1D, 0x09, 0xB3, 0x08, 0xEB, 0x1E, 0x18, 0xC0, 0xF4, 0xC0, 0x02}},
+      },
+      /* 25 fps */
+      {
+         {5, 703,    0, {0x29, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0xBF, 0x42, 0xC0, 0x02}},
+         {3, 447,  610, {0x29, 0xF4, 0x05, 0x13, 0x0B, 0x12, 0x43, 0x14, 0x18, 0xBF, 0x69, 0xC0, 0x02}},
+         {2, 292,  398, {0x29, 0xF4, 0x0D, 0x0C, 0x6C, 0x0B, 0xA4, 0x1E, 0x18, 0x24, 0xA1, 0xC0, 0x02}},
+         {1, 192,  262, {0x29, 0xF4, 0x25, 0x08, 0x23, 0x07, 0x5B, 0x1E, 0x18, 0xC0, 0xF4, 0xC0, 0x02}},
+      },
+      /* 30 fps */
+      {
+         {8, 873,    0, {0x28, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x69, 0x37, 0xC0, 0x02}},
+         {5, 704,  774, {0x28, 0xF4, 0x05, 0x18, 0x21, 0x17, 0x59, 0x0F, 0x18, 0xC0, 0x42, 0xC0, 0x02}},
+         {3, 448,  492, {0x28, 0xF4, 0x05, 0x0F, 0x5D, 0x0E, 0x95, 0x15, 0x18, 0xC0, 0x69, 0xC0, 0x02}},
+         {2, 291,  320, {0x28, 0xF4, 0x1D, 0x09, 0xFB, 0x09, 0x33, 0x1E, 0x18, 0x23, 0xA1, 0xC0, 0x02}},
+      },
+   },
+   /* QCIF */
+   {
+      /* 5 fps */
+      {
+         {1, 193,    0, {0x0D, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0xC1, 0xF4, 0xC0, 0x02}},
+         {1, 193,    0, {0x0D, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0xC1, 0xF4, 0xC0, 0x02}},
+         {1, 193,    0, {0x0D, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0xC1, 0xF4, 0xC0, 0x02}},
+         {1, 193,    0, {0x0D, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0xC1, 0xF4, 0xC0, 0x02}},
+      },
+      /* 10 fps */
+      {
+         {3, 385,    0, {0x0C, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x81, 0x79, 0xC0, 0x02}},
+         {2, 291,  800, {0x0C, 0xF4, 0x05, 0x18, 0xF4, 0x18, 0x18, 0x11, 0x08, 0x23, 0xA1, 0xC0, 0x02}},
+         {2, 291,  800, {0x0C, 0xF4, 0x05, 0x18, 0xF4, 0x18, 0x18, 0x11, 0x08, 0x23, 0xA1, 0xC0, 0x02}},
+         {1, 194,  532, {0x0C, 0xF4, 0x05, 0x10, 0x9A, 0x0F, 0xBE, 0x1B, 0x08, 0xC2, 0xF0, 0xC0, 0x02}},
+      },
+      /* 15 fps */
+      {
+         {4, 577,    0, {0x0B, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x41, 0x52, 0xC0, 0x02}},
+         {3, 447,  818, {0x0B, 0xF4, 0x05, 0x19, 0x89, 0x18, 0xAD, 0x0F, 0x10, 0xBF, 0x69, 0xC0, 0x02}},
+         {2, 292,  534, {0x0B, 0xF4, 0x05, 0x10, 0xA3, 0x0F, 0xC7, 0x19, 0x10, 0x24, 0xA1, 0xC0, 0x02}},
+         {1, 195,  356, {0x0B, 0xF4, 0x15, 0x0B, 0x11, 0x0A, 0x35, 0x1E, 0x10, 0xC3, 0xF0, 0xC0, 0x02}},
+      },
+      /* 20 fps */
+      {
+         {6, 776,    0, {0x0A, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x08, 0x3F, 0xC0, 0x02}},
+         {4, 591,  804, {0x0A, 0xF4, 0x05, 0x19, 0x1E, 0x18, 0x42, 0x0F, 0x18, 0x4F, 0x4E, 0xC0, 0x02}},
+         {3, 447,  608, {0x0A, 0xF4, 0x05, 0x12, 0xFD, 0x12, 0x21, 0x15, 0x18, 0xBF, 0x69, 0xC0, 0x02}},
+         {2, 291,  396, {0x0A, 0xF4, 0x15, 0x0C, 0x5E, 0x0B, 0x82, 0x1E, 0x18, 0x23, 0xA1, 0xC0, 0x02}},
+      },
+      /* 25 fps */
+      {
+         {9, 928,    0, {0x09, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0xA0, 0x33, 0xC0, 0x02}},
+         {5, 703,  800, {0x09, 0xF4, 0x05, 0x18, 0xF4, 0x18, 0x18, 0x10, 0x18, 0xBF, 0x42, 0xC0, 0x02}},
+         {3, 447,  508, {0x09, 0xF4, 0x0D, 0x0F, 0xD2, 0x0E, 0xF6, 0x1B, 0x18, 0xBF, 0x69, 0xC0, 0x02}},
+         {2, 292,  332, {0x09, 0xF4, 0x1D, 0x0A, 0x5A, 0x09, 0x7E, 0x1E, 0x18, 0x24, 0xA1, 0xC0, 0x02}},
+      },
+      /* 30 fps */
+      {
+         {0, },
+         {9, 956,  876, {0x08, 0xF4, 0x05, 0x1B, 0x58, 0x1A, 0x7C, 0x0E, 0x20, 0xBC, 0x33, 0x10, 0x02}},
+         {4, 592,  542, {0x08, 0xF4, 0x05, 0x10, 0xE4, 0x10, 0x08, 0x17, 0x20, 0x50, 0x4E, 0x10, 0x02}},
+         {2, 291,  266, {0x08, 0xF4, 0x25, 0x08, 0x48, 0x07, 0x6C, 0x1E, 0x20, 0x23, 0xA1, 0x10, 0x02}},
+      },
+   },
+   /* SIF */
+   {
+      /* 5 fps */
+      {
+         {4, 582,    0, {0x35, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x46, 0x52, 0x60, 0x02}},
+         {3, 387, 1276, {0x35, 0xF4, 0x05, 0x27, 0xD8, 0x26, 0x48, 0x03, 0x10, 0x83, 0x79, 0x60, 0x02}},
+         {2, 291,  960, {0x35, 0xF4, 0x0D, 0x1D, 0xF2, 0x1C, 0x62, 0x04, 0x10, 0x23, 0xA1, 0x60, 0x02}},
+         {1, 191,  630, {0x35, 0xF4, 0x1D, 0x13, 0xA9, 0x12, 0x19, 0x05, 0x08, 0xBF, 0xF4, 0x60, 0x02}},
+      },
+      /* 10 fps */
+      {
+         {0, },
+         {6, 775, 1278, {0x34, 0xF4, 0x05, 0x27, 0xE8, 0x26, 0x58, 0x05, 0x30, 0x07, 0x3F, 0x10, 0x02}},
+         {3, 447,  736, {0x34, 0xF4, 0x15, 0x16, 0xFB, 0x15, 0x6B, 0x05, 0x18, 0xBF, 0x69, 0x10, 0x02}},
+         {2, 291,  480, {0x34, 0xF4, 0x2D, 0x0E, 0xF9, 0x0D, 0x69, 0x09, 0x18, 0x23, 0xA1, 0x10, 0x02}},
+      },
+      /* 15 fps */
+      {
+         {0, },
+         {9, 955, 1050, {0x33, 0xF4, 0x05, 0x20, 0xCF, 0x1F, 0x3F, 0x06, 0x48, 0xBB, 0x33, 0x10, 0x02}},
+         {4, 591,  650, {0x33, 0xF4, 0x15, 0x14, 0x44, 0x12, 0xB4, 0x08, 0x30, 0x4F, 0x4E, 0x10, 0x02}},
+         {3, 448,  492, {0x33, 0xF4, 0x25, 0x0F, 0x52, 0x0D, 0xC2, 0x09, 0x28, 0xC0, 0x69, 0x10, 0x02}},
+      },
+      /* 20 fps */
+      {
+         {0, },
+         {9, 958,  782, {0x32, 0xF4, 0x0D, 0x18, 0x6A, 0x16, 0xDA, 0x0B, 0x58, 0xBE, 0x33, 0xD0, 0x02}},
+         {5, 703,  574, {0x32, 0xF4, 0x1D, 0x11, 0xE7, 0x10, 0x57, 0x0B, 0x40, 0xBF, 0x42, 0xD0, 0x02}},
+         {3, 446,  364, {0x32, 0xF4, 0x3D, 0x0B, 0x5C, 0x09, 0xCC, 0x0E, 0x30, 0xBE, 0x69, 0xD0, 0x02}},
+      },
+      /* 25 fps */
+      {
+         {0, },
+         {9, 958,  654, {0x31, 0xF4, 0x15, 0x14, 0x66, 0x12, 0xD6, 0x0B, 0x50, 0xBE, 0x33, 0x90, 0x02}},
+         {6, 776,  530, {0x31, 0xF4, 0x25, 0x10, 0x8C, 0x0E, 0xFC, 0x0C, 0x48, 0x08, 0x3F, 0x90, 0x02}},
+         {4, 592,  404, {0x31, 0xF4, 0x35, 0x0C, 0x96, 0x0B, 0x06, 0x0B, 0x38, 0x50, 0x4E, 0x90, 0x02}},
+      },
+      /* 30 fps */
+      {
+         {0, },
+         {9, 957,  526, {0x30, 0xF4, 0x25, 0x10, 0x68, 0x0E, 0xD8, 0x0D, 0x58, 0xBD, 0x33, 0x60, 0x02}},
+         {6, 775,  426, {0x30, 0xF4, 0x35, 0x0D, 0x48, 0x0B, 0xB8, 0x0F, 0x50, 0x07, 0x3F, 0x60, 0x02}},
+         {4, 590,  324, {0x30, 0x7A, 0x4B, 0x0A, 0x1C, 0x08, 0xB4, 0x0E, 0x40, 0x4E, 0x52, 0x60, 0x02}},
+      },
+   },
+   /* CIF */
+   {
+      /* 5 fps */
+      {
+         {6, 771,    0, {0x15, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x3F, 0x80, 0x02}},
+         {4, 465, 1278, {0x15, 0xF4, 0x05, 0x27, 0xEE, 0x26, 0x36, 0x03, 0x18, 0xD1, 0x65, 0x80, 0x02}},
+         {2, 291,  800, {0x15, 0xF4, 0x15, 0x18, 0xF4, 0x17, 0x3C, 0x05, 0x18, 0x23, 0xA1, 0x80, 0x02}},
+         {1, 193,  528, {0x15, 0xF4, 0x2D, 0x10, 0x7E, 0x0E, 0xC6, 0x0A, 0x18, 0xC1, 0xF4, 0x80, 0x02}},
+      },
+      /* 10 fps */
+      {
+         {0, },
+         {9, 932, 1278, {0x14, 0xF4, 0x05, 0x27, 0xEE, 0x26, 0x36, 0x04, 0x30, 0xA4, 0x33, 0x10, 0x02}},
+         {4, 591,  812, {0x14, 0xF4, 0x15, 0x19, 0x56, 0x17, 0x9E, 0x06, 0x28, 0x4F, 0x4E, 0x10, 0x02}},
+         {2, 291,  400, {0x14, 0xF4, 0x3D, 0x0C, 0x7A, 0x0A, 0xC2, 0x0E, 0x28, 0x23, 0xA1, 0x10, 0x02}},
+      },
+      /* 15 fps */
+      {
+         {0, },
+         {9, 956,  876, {0x13, 0xF4, 0x0D, 0x1B, 0x58, 0x19, 0xA0, 0x05, 0x38, 0xBC, 0x33, 0x60, 0x02}},
+         {5, 703,  644, {0x13, 0xF4, 0x1D, 0x14, 0x1C, 0x12, 0x64, 0x08, 0x38, 0xBF, 0x42, 0x60, 0x02}},
+         {3, 448,  410, {0x13, 0xF4, 0x3D, 0x0C, 0xC4, 0x0B, 0x0C, 0x0E, 0x38, 0xC0, 0x69, 0x60, 0x02}},
+      },
+      /* 20 fps */
+      {
+         {0, },
+         {9, 956,  650, {0x12, 0xF4, 0x1D, 0x14, 0x4A, 0x12, 0x92, 0x09, 0x48, 0xBC, 0x33, 0x10, 0x03}},
+         {6, 776,  528, {0x12, 0xF4, 0x2D, 0x10, 0x7E, 0x0E, 0xC6, 0x0A, 0x40, 0x08, 0x3F, 0x10, 0x03}},
+         {4, 591,  402, {0x12, 0xF4, 0x3D, 0x0C, 0x8F, 0x0A, 0xD7, 0x0E, 0x40, 0x4F, 0x4E, 0x10, 0x03}},
+      },
+      /* 25 fps */
+      {
+         {0, },
+         {9, 956,  544, {0x11, 0xF4, 0x25, 0x10, 0xF4, 0x0F, 0x3C, 0x0A, 0x48, 0xBC, 0x33, 0xC0, 0x02}},
+         {7, 840,  478, {0x11, 0xF4, 0x2D, 0x0E, 0xEB, 0x0D, 0x33, 0x0B, 0x48, 0x48, 0x3B, 0xC0, 0x02}},
+         {5, 703,  400, {0x11, 0xF4, 0x3D, 0x0C, 0x7A, 0x0A, 0xC2, 0x0E, 0x48, 0xBF, 0x42, 0xC0, 0x02}},
+      },
+      /* 30 fps */
+      {
+         {0, },
+         {9, 956,  438, {0x10, 0xF4, 0x35, 0x0D, 0xAC, 0x0B, 0xF4, 0x0D, 0x50, 0xBC, 0x33, 0x10, 0x02}},
+         {7, 838,  384, {0x10, 0xF4, 0x45, 0x0B, 0xFD, 0x0A, 0x45, 0x0F, 0x50, 0x46, 0x3B, 0x10, 0x02}},
+         {6, 773,  354, {0x10, 0x7A, 0x4B, 0x0B, 0x0C, 0x09, 0x80, 0x10, 0x50, 0x05, 0x3F, 0x10, 0x02}},
+      },
+   },
+   /* VGA */
+   {
+      /* 5 fps */
+      {
+         {0, },
+         {6, 773, 1272, {0x1D, 0xF4, 0x15, 0x27, 0xB6, 0x24, 0x96, 0x02, 0x30, 0x05, 0x3F, 0x10, 0x02}},
+         {4, 592,  976, {0x1D, 0xF4, 0x25, 0x1E, 0x78, 0x1B, 0x58, 0x03, 0x30, 0x50, 0x4E, 0x10, 0x02}},
+         {3, 448,  738, {0x1D, 0xF4, 0x3D, 0x17, 0x0C, 0x13, 0xEC, 0x04, 0x30, 0xC0, 0x69, 0x10, 0x02}},
+      },
+      /* 10 fps */
+      {
+         {0, },
+         {9, 956,  788, {0x1C, 0xF4, 0x35, 0x18, 0x9C, 0x15, 0x7C, 0x03, 0x48, 0xBC, 0x33, 0x10, 0x02}},
+         {6, 776,  640, {0x1C, 0x7A, 0x53, 0x13, 0xFC, 0x11, 0x2C, 0x04, 0x48, 0x08, 0x3F, 0x10, 0x02}},
+         {4, 592,  488, {0x1C, 0x7A, 0x6B, 0x0F, 0x3C, 0x0C, 0x6C, 0x06, 0x48, 0x50, 0x4E, 0x10, 0x02}},
+      },
+      /* 15 fps */
+      {
+         {0, },
+         {9, 957,  526, {0x1B, 0x7A, 0x63, 0x10, 0x68, 0x0D, 0x98, 0x06, 0x58, 0xBD, 0x33, 0x80, 0x02}},
+         {9, 957,  526, {0x1B, 0x7A, 0x63, 0x10, 0x68, 0x0D, 0x98, 0x06, 0x58, 0xBD, 0x33, 0x80, 0x02}},
+         {8, 895,  492, {0x1B, 0x7A, 0x6B, 0x0F, 0x5D, 0x0C, 0x8D, 0x06, 0x58, 0x7F, 0x37, 0x80, 0x02}},
+      },
+      /* 20 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 25 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+      /* 30 fps */
+      {
+         {0, },
+         {0, },
+         {0, },
+         {0, },
+      },
+   },
diff -Naur linuxppc-2.6.9/drivers/usb/media/pwc-uncompress.c linuxppc-2.6.9-dream/drivers/usb/media/pwc-uncompress.c
--- linuxppc-2.6.9/drivers/usb/media/pwc-uncompress.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/media/pwc-uncompress.c	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,165 @@
+/* Linux driver for Philips webcam 
+   Decompression frontend.
+   (C) 1999-2003 Nemosoft Unv. (webcam@smcc.demon.nl)
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+/*
+   This is where the decompression routines register and unregister 
+   themselves. It also has a decompressor wrapper function.
+*/
+
+#include <asm/types.h>
+
+#include "pwc.h"
+#include "pwc-uncompress.h"
+
+
+/* This contains a list of all registered decompressors */
+static LIST_HEAD(pwc_decompressor_list);
+
+/* Should the pwc_decompress structure ever change, we increase the 
+   version number so that we don't get nasty surprises, or can 
+   dynamically adjust our structure.
+ */
+const int pwc_decompressor_version = PWC_MAJOR;
+
+/* Add decompressor to list, ignoring duplicates */
+void pwc_register_decompressor(struct pwc_decompressor *pwcd)
+{
+	if (pwc_find_decompressor(pwcd->type) == NULL) {
+		Trace(TRACE_PWCX, "Adding decompressor for model %d.\n", pwcd->type);
+		list_add_tail(&pwcd->pwcd_list, &pwc_decompressor_list);
+	}
+}
+
+/* Remove decompressor from list */
+void pwc_unregister_decompressor(int type)
+{
+	struct pwc_decompressor *find;
+	
+	find = pwc_find_decompressor(type);
+	if (find != NULL) {
+		Trace(TRACE_PWCX, "Removing decompressor for model %d.\n", type);
+		list_del(&find->pwcd_list);
+	}
+}
+
+/* Find decompressor in list */
+struct pwc_decompressor *pwc_find_decompressor(int type)
+{
+	struct list_head *tmp;
+	struct pwc_decompressor *pwcd;
+
+	list_for_each(tmp, &pwc_decompressor_list) {
+		pwcd  = list_entry(tmp, struct pwc_decompressor, pwcd_list);
+		if (pwcd->type == type)
+			return pwcd;
+	}
+	return NULL;
+}
+
+
+
+int pwc_decompress(struct pwc_device *pdev)
+{
+	struct pwc_frame_buf *fbuf;
+	int n, line, col, stride;
+	void *yuv, *image;
+	u16 *src;
+	u16 *dsty, *dstu, *dstv;
+
+	
+	if (pdev == NULL)
+		return -EFAULT;
+#if defined(__KERNEL__) && defined(PWC_MAGIC)
+	if (pdev->magic != PWC_MAGIC) {
+		Err("pwc_decompress(): magic failed.\n");
+		return -EFAULT;
+	}
+#endif
+
+	fbuf = pdev->read_frame;
+	if (fbuf == NULL)
+		return -EFAULT;
+	image = pdev->image_ptr[pdev->fill_image];
+	if (!image)
+		return -EFAULT;
+	
+	yuv = fbuf->data + pdev->frame_header_size;  /* Skip header */
+	if (pdev->vbandlength == 0) { 
+		/* Uncompressed mode. We copy the data into the output buffer,
+		   using the viewport size (which may be larger than the image
+		   size). Unfortunately we have to do a bit of byte stuffing
+		   to get the desired output format/size.
+		 */
+			/* 
+			 * We do some byte shuffling here to go from the 
+			 * native format to YUV420P.
+			 */
+			src = (u16 *)yuv;
+			n = pdev->view.x * pdev->view.y;
+
+			/* offset in Y plane */
+			stride = pdev->view.x * pdev->offset.y + pdev->offset.x;
+			dsty = (u16 *)(image + stride);
+
+			/* offsets in U/V planes */
+			stride = pdev->view.x * pdev->offset.y / 4 + pdev->offset.x / 2;
+			dstu = (u16 *)(image + n +         stride);
+			dstv = (u16 *)(image + n + n / 4 + stride);
+
+			/* increment after each line */
+			stride = (pdev->view.x - pdev->image.x) / 2; /* u16 is 2 bytes */
+
+			for (line = 0; line < pdev->image.y; line++) {
+				for (col = 0; col < pdev->image.x; col += 4) {
+					*dsty++ = *src++;
+					*dsty++ = *src++;
+					if (line & 1)
+						*dstv++ = *src++;
+					else
+						*dstu++ = *src++;
+				}
+				dsty += stride;
+				if (line & 1)
+					dstv += (stride >> 1);
+				else
+					dstu += (stride >> 1);
+			}
+	}
+	else { 
+		/* Compressed; the decompressor routines will write the data 
+		   in planar format immediately.
+		 */
+		if (pdev->decompressor)
+			pdev->decompressor->decompress(
+				&pdev->image, &pdev->view, &pdev->offset,
+				yuv, image,
+				1,
+				pdev->decompress_data, pdev->vbandlength);
+		else
+			return -ENXIO; /* No such device or address: missing decompressor */
+	}
+	return 0;
+}
+
+/* Make sure these functions are available for the decompressor plugin
+   both when this code is compiled into the kernel or as as module.
+ */
+
+EXPORT_SYMBOL_NOVERS(pwc_decompressor_version);
+EXPORT_SYMBOL(pwc_register_decompressor);
+EXPORT_SYMBOL(pwc_unregister_decompressor);
diff -Naur linuxppc-2.6.9/drivers/usb/media/pwc-uncompress.h linuxppc-2.6.9-dream/drivers/usb/media/pwc-uncompress.h
--- linuxppc-2.6.9/drivers/usb/media/pwc-uncompress.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/media/pwc-uncompress.h	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,77 @@
+/* (C) 1999-2003 Nemosoft Unv. (webcam@smcc.demon.nl)
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* This file is the bridge between the kernel module and the plugin; it
+   describes the structures and datatypes used in both modules. Any
+   significant change should be reflected by increasing the 
+   pwc_decompressor_version major number.
+ */
+#ifndef PWC_UNCOMPRESS_H
+#define PWC_UNCOMPRESS_H
+
+#include <linux/config.h>
+#include <linux/list.h>
+
+#include "pwc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* The decompressor structure. 
+   Every type of decompressor registers itself with the main module. 
+   When a device is opened, it looks up the correct compressor, and
+   uses that when a compressed video mode is requested.
+ */
+struct pwc_decompressor
+{
+	int  type;		/* type of camera (645, 680, etc) */
+	int  table_size;	/* memory needed */
+
+	void (* init)(int release, void *buffer, void *table);	/* Initialization routine; should be called after each set_video_mode */
+	void (* exit)(void);	/* Cleanup routine */
+	void (* decompress)(struct pwc_coord *image, struct pwc_coord *view, struct pwc_coord *offset,
+                            void *src, void *dst, int planar,
+	                    void *table, int bandlength);
+	void (* lock)(void);	/* make sure module cannot be unloaded */
+	void (* unlock)(void);	/* release lock on module */
+
+	struct list_head pwcd_list;
+};
+
+
+/* Our structure version number. Is set to the version number major */
+extern const int pwc_decompressor_version;
+
+/* Adds decompressor to list, based on its 'type' field (which matches the 'type' field in pwc_device; ignores any double requests */
+extern void pwc_register_decompressor(struct pwc_decompressor *pwcd);
+/* Removes decompressor, based on the type number */
+extern void pwc_unregister_decompressor(int type);
+/* Returns pointer to decompressor struct, or NULL if it doesn't exist */
+extern struct pwc_decompressor *pwc_find_decompressor(int type);
+
+#ifdef CONFIG_USB_PWCX
+/* If the decompressor is compiled in, we must call these manually */
+extern int usb_pwcx_init(void);
+extern void usb_pwcx_exit(void);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Naur linuxppc-2.6.9/drivers/usb/media/se401.c linuxppc-2.6.9-dream/drivers/usb/media/se401.c
--- linuxppc-2.6.9/drivers/usb/media/se401.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/se401.c	2005-09-19 21:40:05.000000000 +0200
@@ -53,9 +53,9 @@
 MODULE_AUTHOR("Jeroen Vreeken <pe1rxq@amsat.org>");
 MODULE_DESCRIPTION("SE401 USB Camera Driver");
 MODULE_LICENSE("GPL");
-module_param(flickerless, int, 0);
+MODULE_PARM(flickerless, "i");
 MODULE_PARM_DESC(flickerless, "Net frequency to adjust exposure time to (0/50/60)");
-module_param(video_nr, int, 0);
+MODULE_PARM(video_nr, "i");
 
 static struct usb_driver se401_driver;
 
@@ -1121,7 +1121,7 @@
 	return video_usercopy(inode, file, cmd, arg, se401_do_ioctl);
 }
 
-static ssize_t se401_read(struct file *file, char __user *buf,
+static ssize_t se401_read(struct file *file, char *buf,
 		     size_t count, loff_t *ppos)
 {
 	int realcount=count, ret=0;
@@ -1295,7 +1295,7 @@
 		    &se401->button, sizeof(se401->button),
 		    se401_button_irq,
 		    se401,
-		    8
+		    HZ/10
 		);
 		if (usb_submit_urb(se401->inturb, GFP_KERNEL)) {
 			info("int urb burned down");
@@ -1326,7 +1326,7 @@
         if (dev->descriptor.bNumConfigurations != 1)
                 return -ENODEV;
 
-        interface = &intf->cur_altsetting->desc;
+        interface = &intf->altsetting[0].desc;
 
         /* Is it an se401? */
         if (dev->descriptor.idVendor == 0x03e8 &&
diff -Naur linuxppc-2.6.9/drivers/usb/media/sn9c102_core.c linuxppc-2.6.9-dream/drivers/usb/media/sn9c102_core.c
--- linuxppc-2.6.9/drivers/usb/media/sn9c102_core.c	2004-10-18 23:53:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/sn9c102_core.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2434 +0,0 @@
-/***************************************************************************
- * V4L2 driver for SN9C10[12] PC Camera Controllers                        *
- *                                                                         *
- * Copyright (C) 2004 by Luca Risolia <luca.risolia@studio.unibo.it>       *
- *                                                                         *
- * This program is free software; you can redistribute it and/or modify    *
- * it under the terms of the GNU General Public License as published by    *
- * the Free Software Foundation; either version 2 of the License, or       *
- * (at your option) any later version.                                     *
- *                                                                         *
- * This program is distributed in the hope that it will be useful,         *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
- * GNU General Public License for more details.                            *
- *                                                                         *
- * You should have received a copy of the GNU General Public License       *
- * along with this program; if not, write to the Free Software             *
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
- ***************************************************************************/
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/param.h>
-#include <linux/moduleparam.h>
-#include <linux/errno.h>
-#include <linux/slab.h>
-#include <linux/string.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/time.h>
-#include <linux/delay.h>
-#include <linux/stddef.h>
-#include <linux/compiler.h>
-#include <linux/ioctl.h>
-#include <linux/poll.h>
-#include <linux/stat.h>
-#include <linux/mm.h>
-#include <linux/vmalloc.h>
-#include <linux/page-flags.h>
-#include <asm/page.h>
-#include <asm/uaccess.h>
-
-#include "sn9c102.h"
-
-/*****************************************************************************/
-
-MODULE_DEVICE_TABLE(usb, sn9c102_id_table);
-
-MODULE_AUTHOR(SN9C102_MODULE_AUTHOR " " SN9C102_AUTHOR_EMAIL);
-MODULE_DESCRIPTION(SN9C102_MODULE_NAME);
-MODULE_VERSION(SN9C102_MODULE_VERSION);
-MODULE_LICENSE(SN9C102_MODULE_LICENSE);
-
-static short video_nr[] = {[0 ... SN9C102_MAX_DEVICES-1] = -1};
-static unsigned int nv;
-module_param_array(video_nr, short, nv, 0444);
-MODULE_PARM_DESC(video_nr,
-                 "\n<-1|n[,...]> Specify V4L2 minor mode number."
-                 "\n -1 = use next available (default)"
-                 "\n  n = use minor number n (integer >= 0)"
-                 "\nYou can specify up to "__MODULE_STRING(SN9C102_MAX_DEVICES)
-                 " cameras this way."
-                 "\nFor example:"
-                 "\nvideo_nr=-1,2,-1 would assign minor number 2 to"
-                 "\nthe second camera and use auto for the first"
-                 "\none and for every other camera."
-                 "\n");
-
-#ifdef SN9C102_DEBUG
-static unsigned short debug = SN9C102_DEBUG_LEVEL;
-module_param(debug, ushort, 0644);
-MODULE_PARM_DESC(debug,
-                 "\n<n> Debugging information level, from 0 to 3:"
-                 "\n0 = none (use carefully)"
-                 "\n1 = critical errors"
-                 "\n2 = significant informations"
-                 "\n3 = more verbose messages"
-                 "\nLevel 3 is useful for testing only, when only "
-                 "one device is used."
-                 "\nDefault value is "__MODULE_STRING(SN9C102_DEBUG_LEVEL)"."
-                 "\n");
-#endif
-
-/*****************************************************************************/
-
-typedef char sn9c102_sof_header_t[12];
-typedef char sn9c102_eof_header_t[4];
-
-static sn9c102_sof_header_t sn9c102_sof_header[] = {
-	{0xff, 0xff, 0x00, 0xc4, 0xc4, 0x96, 0x00},
-	{0xff, 0xff, 0x00, 0xc4, 0xc4, 0x96, 0x01},
-};
-
-
-static sn9c102_eof_header_t sn9c102_eof_header[] = {
-	{0x00, 0x00, 0x00, 0x00},
-	{0x40, 0x00, 0x00, 0x00},
-	{0x80, 0x00, 0x00, 0x00},
-	{0xc0, 0x00, 0x00, 0x00},
-};
-
-/*****************************************************************************/
-
-static inline unsigned long kvirt_to_pa(unsigned long adr)
-{
-	unsigned long kva, ret;
-
-	kva = (unsigned long)page_address(vmalloc_to_page((void *)adr));
-	kva |= adr & (PAGE_SIZE-1);
-	ret = __pa(kva);
-	return ret;
-}
-
-
-static void* rvmalloc(size_t size)
-{
-	void* mem;
-	unsigned long adr;
-
-	size = PAGE_ALIGN(size);
-
-	mem = vmalloc_32((unsigned long)size);
-	if (!mem)
-		return NULL;
-
-	memset(mem, 0, size);
-
-	adr = (unsigned long)mem;
-	while (size > 0) {
-		SetPageReserved(vmalloc_to_page((void *)adr));
-		adr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	return mem;
-}
-
-
-static void rvfree(void* mem, size_t size)
-{
-	unsigned long adr;
-
-	if (!mem)
-		return;
-
-	size = PAGE_ALIGN(size);
-
-	adr = (unsigned long)mem;
-	while (size > 0) {
-		ClearPageReserved(vmalloc_to_page((void *)adr));
-		adr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	vfree(mem);
-}
-
-
-static u32 sn9c102_request_buffers(struct sn9c102_device* cam, u32 count)
-{
-	struct v4l2_pix_format* p = &(cam->sensor->pix_format);
-	const size_t imagesize = (p->width * p->height * p->priv)/8;
-	void* buff = NULL;
-	u32 i;
-
-	if (count > SN9C102_MAX_FRAMES)
-		count = SN9C102_MAX_FRAMES;
-
-	cam->nbuffers = count;
-	while (cam->nbuffers > 0) {
-		if ((buff = rvmalloc(cam->nbuffers * imagesize)))
-			break;
-		cam->nbuffers--;
-	}
-
-	for (i = 0; i < cam->nbuffers; i++) {
-		cam->frame[i].bufmem = buff + i*imagesize;
-		cam->frame[i].buf.index = i;
-		cam->frame[i].buf.m.offset = i*imagesize;
-		cam->frame[i].buf.length = imagesize;
-		cam->frame[i].buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		cam->frame[i].buf.sequence = 0;
-		cam->frame[i].buf.field = V4L2_FIELD_NONE;
-		cam->frame[i].buf.memory = V4L2_MEMORY_MMAP;
-		cam->frame[i].buf.flags = 0;
-	}
-
-	return cam->nbuffers;
-}
-
-
-static void sn9c102_release_buffers(struct sn9c102_device* cam)
-{
-	if (cam->nbuffers) {
-		rvfree(cam->frame[0].bufmem,
-		       cam->nbuffers * cam->frame[0].buf.length);
-		cam->nbuffers = 0;
-	}
-}
-
-
-static void sn9c102_empty_framequeues(struct sn9c102_device* cam)
-{
-	u32 i;
-
-	INIT_LIST_HEAD(&cam->inqueue);
-	INIT_LIST_HEAD(&cam->outqueue);
-
-	for (i = 0; i < SN9C102_MAX_FRAMES; i++) {
-		cam->frame[i].state = F_UNUSED;
-		cam->frame[i].buf.bytesused = 0;
-	}
-}
-
-
-static void sn9c102_queue_unusedframes(struct sn9c102_device* cam)
-{
-	unsigned long lock_flags;
-	u32 i;
-
-	for (i = 0; i < cam->nbuffers; i++)
-		if (cam->frame[i].state == F_UNUSED) {
-			cam->frame[i].state = F_QUEUED;
-			spin_lock_irqsave(&cam->queue_lock, lock_flags);
-			list_add_tail(&cam->frame[i].frame, &cam->inqueue);
-			spin_unlock_irqrestore(&cam->queue_lock, lock_flags);
-		}
-}
-
-/*****************************************************************************/
-
-int sn9c102_write_reg(struct sn9c102_device* cam, u8 value, u16 index)
-{
-	struct usb_device* udev = cam->usbdev;
-	u8* buff = cam->control_buffer;
-	int res;
-
-	*buff = value;
-
-	res = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x08, 0x41,
-	                      index, 0, buff, 1, SN9C102_CTRL_TIMEOUT);
-	if (res < 0) {
-		DBG(3, "Failed to write a register (value 0x%02X, index "
-		       "0x%02X, error %d)", value, index, res)
-		return -1;
-	}
-
-	cam->reg[index] = value;
-
-	return 0;
-}
-
-
-/* NOTE: reading some registers always returns 0 */
-static int sn9c102_read_reg(struct sn9c102_device* cam, u16 index)
-{
-	struct usb_device* udev = cam->usbdev;
-	u8* buff = cam->control_buffer;
-	int res;
-
-	res = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x00, 0xc1,
-	                      index, 0, buff, 1, SN9C102_CTRL_TIMEOUT);
-	if (res < 0)
-		DBG(3, "Failed to read a register (index 0x%02X, error %d)",
-		    index, res)
-
-	return (res >= 0) ? (int)(*buff) : -1;
-}
-
-
-int sn9c102_pread_reg(struct sn9c102_device* cam, u16 index)
-{
-	if (index > 0x1f)
-		return -EINVAL;
-
-	return cam->reg[index];
-}
-
-
-static int
-sn9c102_i2c_wait(struct sn9c102_device* cam, struct sn9c102_sensor* sensor)
-{
-	int i, r;
-
-	for (i = 1; i <= 5; i++) {
-		r = sn9c102_read_reg(cam, 0x08);
-		if (r < 0)
-			return -EIO;
-		if (r & 0x04)
-			return 0;
-		if (sensor->frequency & SN9C102_I2C_400KHZ)
-			udelay(5*8);
-		else
-			udelay(16*8);
-	}
-	return -EBUSY;
-}
-
-
-static int
-sn9c102_i2c_detect_read_error(struct sn9c102_device* cam, 
-                              struct sn9c102_sensor* sensor)
-{
-	int r;
-	r = sn9c102_read_reg(cam, 0x08);
-	return (r < 0 || (r >= 0 && !(r & 0x08))) ? -EIO : 0;
-}
-
-
-static int
-sn9c102_i2c_detect_write_error(struct sn9c102_device* cam, 
-                               struct sn9c102_sensor* sensor)
-{
-	int r;
-	r = sn9c102_read_reg(cam, 0x08);
-	return (r < 0 || (r >= 0 && (r & 0x08))) ? -EIO : 0;
-}
-
-
-int 
-sn9c102_i2c_try_read(struct sn9c102_device* cam,
-                     struct sn9c102_sensor* sensor, u8 address)
-{
-	struct usb_device* udev = cam->usbdev;
-	u8* data = cam->control_buffer;
-	int err = 0, res;
-
-	/* Write cycle - address */
-	data[0] = ((sensor->interface == SN9C102_I2C_2WIRES) ? 0x80 : 0) |
-	          ((sensor->frequency & SN9C102_I2C_400KHZ) ? 0x01 : 0) | 0x10;
-	data[1] = sensor->slave_write_id;
-	data[2] = address;
-	data[7] = 0x10;
-	res = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x08, 0x41,
-	                      0x08, 0, data, 8, SN9C102_CTRL_TIMEOUT);
-	if (res < 0)
-		err += res;
-
-	err += sn9c102_i2c_wait(cam, sensor);
-
-	/* Read cycle - 1 byte */
-	data[0] = ((sensor->interface == SN9C102_I2C_2WIRES) ? 0x80 : 0) |
-	          ((sensor->frequency & SN9C102_I2C_400KHZ) ? 0x01 : 0) |
-	          0x10 | 0x02;
-	data[1] = sensor->slave_read_id;
-	data[7] = 0x10;
-	res = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x08, 0x41,
-	                      0x08, 0, data, 8, SN9C102_CTRL_TIMEOUT);
-	if (res < 0)
-		err += res;
-
-	err += sn9c102_i2c_wait(cam, sensor);
-
-	/* The read byte will be placed in data[4] */
-	res = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x00, 0xc1,
-	                      0x0a, 0, data, 5, SN9C102_CTRL_TIMEOUT);
-	if (res < 0)
-		err += res;
-
-	err += sn9c102_i2c_detect_read_error(cam, sensor);
-
-	if (err)
-		DBG(3, "I2C read failed for %s image sensor", sensor->name)
-
-	PDBGG("I2C read: address 0x%02X, value: 0x%02X", address, data[4])
-
-	return err ? -1 : (int)data[4];
-}
-
-
-int 
-sn9c102_i2c_try_raw_write(struct sn9c102_device* cam,
-                          struct sn9c102_sensor* sensor, u8 n, u8 data0,
-                          u8 data1, u8 data2, u8 data3, u8 data4, u8 data5)
-{
-	struct usb_device* udev = cam->usbdev;
-	u8* data = cam->control_buffer;
-	int err = 0, res;
-
-	/* Write cycle. It usually is address + value */
-	data[0] = ((sensor->interface == SN9C102_I2C_2WIRES) ? 0x80 : 0) |
-	          ((sensor->frequency & SN9C102_I2C_400KHZ) ? 0x01 : 0)
-	          | ((n - 1) << 4);
-	data[1] = data0;
-	data[2] = data1;
-	data[3] = data2;
-	data[4] = data3;
-	data[5] = data4;
-	data[6] = data5;
-	data[7] = 0x10;
-	res = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x08, 0x41,
-	                      0x08, 0, data, 8, SN9C102_CTRL_TIMEOUT);
-	if (res < 0)
-		err += res;
-
-	err += sn9c102_i2c_wait(cam, sensor);
-	err += sn9c102_i2c_detect_write_error(cam, sensor);
-
-	if (err)
-		DBG(3, "I2C write failed for %s image sensor", sensor->name)
-
-	PDBGG("I2C write: %u bytes, data0 = 0x%02X, data1 = 0x%02X, "
-	      "data2 = 0x%02X, data3 = 0x%02X, data4 = 0x%02X, data5 = 0x%02X",
-	      n, data0, data1, data2, data3, data4, data5)
-
-	return err ? -1 : 0;
-}
-
-
-int 
-sn9c102_i2c_try_write(struct sn9c102_device* cam,
-                      struct sn9c102_sensor* sensor, u8 address, u8 value)
-{
-	return sn9c102_i2c_try_raw_write(cam, sensor, 3, 
-	                                 sensor->slave_write_id, address,
-	                                 value, 0, 0, 0);
-}
-
-
-int sn9c102_i2c_read(struct sn9c102_device* cam, u8 address)
-{
-	if (!cam->sensor)
-		return -1;
-
-	return sn9c102_i2c_try_read(cam, cam->sensor, address);
-}
-
-
-int sn9c102_i2c_write(struct sn9c102_device* cam, u8 address, u8 value)
-{
-	if (!cam->sensor)
-		return -1;
-
-	return sn9c102_i2c_try_write(cam, cam->sensor, address, value);
-}
-
-/*****************************************************************************/
-
-static void* sn9c102_find_sof_header(void* mem, size_t len)
-{
-	size_t soflen = sizeof(sn9c102_sof_header_t), i;
-	u8 j, n = sizeof(sn9c102_sof_header) / soflen;
-
-	for (i = 0; (len >= soflen) && (i <= len - soflen); i++)
-		for (j = 0; j < n; j++)
-			/* It's enough to compare 7 bytes */
-			if (!memcmp(mem + i, sn9c102_sof_header[j], 7))
-				/* Skips the header */
-				return mem + i + soflen;
-
-	return NULL;
-}
-
-
-static void* sn9c102_find_eof_header(void* mem, size_t len)
-{
-	size_t eoflen = sizeof(sn9c102_eof_header_t), i;
-	unsigned j, n = sizeof(sn9c102_eof_header) / eoflen;
-
-	for (i = 0; (len >= eoflen) && (i <= len - eoflen); i++)
-		for (j = 0; j < n; j++)
-			if (!memcmp(mem + i, sn9c102_eof_header[j], eoflen))
-				return mem + i;
-
-	return NULL;
-}
-
-
-static void sn9c102_urb_complete(struct urb *urb, struct pt_regs* regs)
-{
-	struct sn9c102_device* cam = urb->context;
-	struct sn9c102_frame_t** f;
-	unsigned long lock_flags;
-	u8 i;
-	int err = 0;
-
-	if (urb->status == -ENOENT)
-		return;
-
-	f = &cam->frame_current;
-
-	if (cam->stream == STREAM_INTERRUPT) {
-		cam->stream = STREAM_OFF;
-		if ((*f))
-			(*f)->state = F_QUEUED;
-		DBG(3, "Stream interrupted")
-		wake_up_interruptible(&cam->wait_stream);
-	}
-
-	if ((cam->state & DEV_DISCONNECTED)||(cam->state & DEV_MISCONFIGURED))
-		return;
-
-	if (cam->stream == STREAM_OFF || list_empty(&cam->inqueue))
-		goto resubmit_urb;
-
-	if (!(*f))
-		(*f) = list_entry(cam->inqueue.next, struct sn9c102_frame_t,
-		                  frame);
-
-	for (i = 0; i < urb->number_of_packets; i++) {
-		unsigned int img, len, status;
-		void *pos, *sof, *eof;
-
-		len = urb->iso_frame_desc[i].actual_length;
-		status = urb->iso_frame_desc[i].status;
-		pos = urb->iso_frame_desc[i].offset + urb->transfer_buffer;
-
-		if (status) {
-			DBG(3, "Error in isochronous frame")
-			(*f)->state = F_ERROR;
-			continue;
-		}
-
-		PDBGG("Isochrnous frame: length %u, #%u i", len, i)
-
-		/*
-		   NOTE: It is probably correct to assume that SOF and EOF
-		         headers do not occur between two consecutive packets,
-		         but who knows..Whatever is the truth, this assumption
-		         doesn't introduce bugs.
-		*/
-
-redo:
-		sof = sn9c102_find_sof_header(pos, len);
-		if (!sof) {
-			eof = sn9c102_find_eof_header(pos, len);
-			if ((*f)->state == F_GRABBING) {
-end_of_frame:
-				img = len;
-
-				if (eof)
-					img = (eof > pos) ? eof - pos - 1 : 0;
-
-				if ((*f)->buf.bytesused+img>(*f)->buf.length) {
-					u32 b = (*f)->buf.bytesused + img -
-					        (*f)->buf.length;
-					img = (*f)->buf.length - 
-					      (*f)->buf.bytesused;
-					DBG(3, "Expected EOF not found: "
-					       "video frame cut")
-					if (eof)
-						DBG(3, "Exceeded limit: +%u "
-						       "bytes", (unsigned)(b))
-				}
-
-				memcpy((*f)->bufmem + (*f)->buf.bytesused, pos,
-				       img);
-
-				if ((*f)->buf.bytesused == 0)
-					do_gettimeofday(&(*f)->buf.timestamp);
-
-				(*f)->buf.bytesused += img;
-
-				if ((*f)->buf.bytesused == (*f)->buf.length) {
-					u32 b = (*f)->buf.bytesused;
-					(*f)->state = F_DONE;
-					(*f)->buf.sequence= ++cam->frame_count;
-					spin_lock_irqsave(&cam->queue_lock,
-					                  lock_flags);
-					list_move_tail(&(*f)->frame,
-					               &cam->outqueue);
-					if (!list_empty(&cam->inqueue))
-						(*f) = list_entry(
-						        cam->inqueue.next,
-						        struct sn9c102_frame_t,
-						        frame );
-					else
-						(*f) = NULL;
-					spin_unlock_irqrestore(&cam->queue_lock
-					                       , lock_flags);
-					DBG(3, "Video frame captured: "
-					       "%lu bytes", (unsigned long)(b))
-
-					if (!(*f))
-						goto resubmit_urb;
-
-				} else if (eof) {
-					(*f)->state = F_ERROR;
-					DBG(3, "Not expected EOF after %lu "
-					       "bytes of image data", 
-					  (unsigned long)((*f)->buf.bytesused))
-				}
-
-				if (sof) /* (1) */
-					goto start_of_frame;
-
-			} else if (eof) {
-				DBG(3, "EOF without SOF")
-				continue;
-
-			} else {
-				PDBGG("Ignoring pointless isochronous frame")
-				continue;
-			}
-
-		} else if ((*f)->state == F_QUEUED || (*f)->state == F_ERROR) {
-start_of_frame:
-			(*f)->state = F_GRABBING;
-			(*f)->buf.bytesused = 0;
-			len -= (sof - pos);
-			pos = sof;
-			DBG(3, "SOF detected: new video frame")
-			if (len)
-				goto redo;
-
-		} else if ((*f)->state == F_GRABBING) {
-			eof = sn9c102_find_eof_header(pos, len);
-			if (eof && eof < sof)
-				goto end_of_frame; /* (1) */
-			else {
-				DBG(3, "SOF before expected EOF after %lu "
-				       "bytes of image data", 
-				    (unsigned long)((*f)->buf.bytesused))
-				goto start_of_frame;
-			}
-		}
-	}
-
-resubmit_urb:
-	urb->dev = cam->usbdev;
-	err = usb_submit_urb(urb, GFP_ATOMIC);
-	if (err < 0 && err != -EPERM) {
-		cam->state |= DEV_MISCONFIGURED;
-		DBG(1, "usb_submit_urb() failed")
-	}
-
-	wake_up_interruptible(&cam->wait_frame);
-}
-
-
-static int sn9c102_start_transfer(struct sn9c102_device* cam)
-{
-	struct usb_device *udev = cam->usbdev;
-	struct urb* urb;
-	const unsigned int wMaxPacketSize[] = {0, 128, 256, 384, 512,
-                                               680, 800, 900, 1023};
-	const unsigned int psz = wMaxPacketSize[SN9C102_ALTERNATE_SETTING];
-	s8 i, j;
-	int err = 0;
-
-	for (i = 0; i < SN9C102_URBS; i++) {
-		cam->transfer_buffer[i] = kmalloc(SN9C102_ISO_PACKETS * psz,
-		                                  GFP_KERNEL);
-		if (!cam->transfer_buffer[i]) {
-			err = -ENOMEM;
-			DBG(1, "Not enough memory")
-			goto free_buffers;
-		}
-	}
-
-	for (i = 0; i < SN9C102_URBS; i++) {
-		urb = usb_alloc_urb(SN9C102_ISO_PACKETS, GFP_KERNEL);
-		cam->urb[i] = urb;
-		if (!urb) {
-			err = -ENOMEM;
-			DBG(1, "usb_alloc_urb() failed")
-			goto free_urbs;
-		}
-		urb->dev = udev;
-		urb->context = cam;
-		urb->pipe = usb_rcvisocpipe(udev, 1);
-		urb->transfer_flags = URB_ISO_ASAP;
-		urb->number_of_packets = SN9C102_ISO_PACKETS;
-		urb->complete = sn9c102_urb_complete;
-		urb->transfer_buffer = cam->transfer_buffer[i];
-		urb->transfer_buffer_length = psz * SN9C102_ISO_PACKETS;
-		urb->interval = 1;
-		for (j = 0; j < SN9C102_ISO_PACKETS; j++) {
-			urb->iso_frame_desc[j].offset = psz * j;
-			urb->iso_frame_desc[j].length = psz;
-		}
-	}
-
-	/* Enable video */
-	if (!(cam->reg[0x01] & 0x04)) {
-		err = sn9c102_write_reg(cam, cam->reg[0x01] | 0x04, 0x01);
-		if (err) {
-			err = -EIO;
-			DBG(1, "I/O hardware error")
-			goto free_urbs;
-		}
-	}
-
-	err = usb_set_interface(udev, 0, SN9C102_ALTERNATE_SETTING);
-	if (err) {
-		DBG(1, "usb_set_interface() failed")
-		goto free_urbs;
-	}
-
-	cam->frame_current = NULL;
-
-	for (i = 0; i < SN9C102_URBS; i++) {
-		err = usb_submit_urb(cam->urb[i], GFP_KERNEL);
-		if (err) {
-			for (j = i-1; j >= 0; j--)
-				usb_kill_urb(cam->urb[j]);
-			DBG(1, "usb_submit_urb() failed, error %d", err)
-			goto free_urbs;
-		}
-	}
-
-	return 0;
-
-free_urbs:
-	for (i = 0; (i < SN9C102_URBS) &&  cam->urb[i]; i++)
-		usb_free_urb(cam->urb[i]);
-
-free_buffers:
-	for (i = 0; (i < SN9C102_URBS) && cam->transfer_buffer[i]; i++)
-		kfree(cam->transfer_buffer[i]);
-
-	return err;
-}
-
-
-static int sn9c102_stop_transfer(struct sn9c102_device* cam)
-{
-	struct usb_device *udev = cam->usbdev;
-	s8 i;
-	int err = 0;
-
-	if (cam->state & DEV_DISCONNECTED)
-		return 0;
-
-	for (i = SN9C102_URBS-1; i >= 0; i--) {
-		usb_kill_urb(cam->urb[i]);
-		usb_free_urb(cam->urb[i]);
-		kfree(cam->transfer_buffer[i]);
-	}
-
-	err = usb_set_interface(udev, 0, 0); /* 0 Mb/s */
-	if (err)
-		DBG(3, "usb_set_interface() failed")
-
-	return err;
-}
-
-/*****************************************************************************/
-
-static u8 sn9c102_strtou8(const char* buff, size_t len, ssize_t* count)
-{
-	char str[5];
-	char* endp;
-	unsigned long val;
-
-	if (len < 4) {
-		strncpy(str, buff, len);
-		str[len+1] = '\0';
-	} else {
-		strncpy(str, buff, 4);
-		str[4] = '\0';
-	}
-
-	val = simple_strtoul(str, &endp, 0);
-
-	*count = 0;
-	if (val <= 0xff)
-		*count = (ssize_t)(endp - str);
-	if ((*count) && (len == *count+1) && (buff[*count] == '\n'))
-		*count += 1;
-
-	return (u8)val;
-}
-
-/*
-   NOTE 1: being inside one of the following methods implies that the v4l
-           device exists for sure (see kobjects and reference counters)
-   NOTE 2: buffers are PAGE_SIZE long
-*/
-
-static ssize_t sn9c102_show_reg(struct class_device* cd, char* buf)
-{
-	struct sn9c102_device* cam;
-	ssize_t count;
-
-	if (down_interruptible(&sn9c102_sysfs_lock))
-		return -ERESTARTSYS;
-
-	cam = video_get_drvdata(to_video_device(cd));
-	if (!cam) {
-		up(&sn9c102_sysfs_lock);
-		return -ENODEV;
-	}
-
-	count = sprintf(buf, "%u\n", cam->sysfs.reg);
-
-	up(&sn9c102_sysfs_lock);
-
-	return count;
-} 
-
-
-static ssize_t 
-sn9c102_store_reg(struct class_device* cd, const char* buf, size_t len)
-{
-	struct sn9c102_device* cam;
-	u8 index;
-	ssize_t count;
-
-	if (down_interruptible(&sn9c102_sysfs_lock))
-		return -ERESTARTSYS;
-
-	cam = video_get_drvdata(to_video_device(cd));
-	if (!cam) {
-		up(&sn9c102_sysfs_lock);
-		return -ENODEV;
-	}
-
-	index = sn9c102_strtou8(buf, len, &count);
-	if (index > 0x1f || !count) {
-		up(&sn9c102_sysfs_lock);
-		return -EINVAL;
-	}
-
-	cam->sysfs.reg = index;
-
-	DBG(2, "Moved SN9C10X register index to 0x%02X", cam->sysfs.reg)
-	DBG(3, "Written bytes: %zd", count)
-
-	up(&sn9c102_sysfs_lock);
-
-	return count;
-}
-
-
-static ssize_t sn9c102_show_val(struct class_device* cd, char* buf)
-{
-	struct sn9c102_device* cam;
-	ssize_t count;
-	int val;
-
-	if (down_interruptible(&sn9c102_sysfs_lock))
-		return -ERESTARTSYS;
-
-	cam = video_get_drvdata(to_video_device(cd));
-	if (!cam) {
-		up(&sn9c102_sysfs_lock);
-		return -ENODEV;
-	}
-
-	if ((val = sn9c102_read_reg(cam, cam->sysfs.reg)) < 0) {
-		up(&sn9c102_sysfs_lock);
-		return -EIO;
-	}
-
-	count = sprintf(buf, "%d\n", val);
-
-	DBG(3, "Read bytes: %zd", count)
-
-	up(&sn9c102_sysfs_lock);
-
-	return count;
-} 
-
-
-static ssize_t
-sn9c102_store_val(struct class_device* cd, const char* buf, size_t len)
-{
-	struct sn9c102_device* cam;
-	u8 value;
-	ssize_t count;
-	int err;
-
-	if (down_interruptible(&sn9c102_sysfs_lock))
-		return -ERESTARTSYS;
-
-	cam = video_get_drvdata(to_video_device(cd));
-	if (!cam) {
-		up(&sn9c102_sysfs_lock);
-		return -ENODEV;
-	}
-
-	value = sn9c102_strtou8(buf, len, &count);
-	if (!count) {
-		up(&sn9c102_sysfs_lock);
-		return -EINVAL;
-	}
-
-	err = sn9c102_write_reg(cam, value, cam->sysfs.reg);
-	if (err) {
-		up(&sn9c102_sysfs_lock);
-		return -EIO;
-	}
-
-	DBG(2, "Written SN9C10X reg. 0x%02X, val. 0x%02X",
-	    cam->sysfs.reg, value)
-	DBG(3, "Written bytes: %zd", count)
-
-	up(&sn9c102_sysfs_lock);
-
-	return count;
-}
-
-
-static ssize_t sn9c102_show_i2c_reg(struct class_device* cd, char* buf)
-{
-	struct sn9c102_device* cam;
-	ssize_t count;
-
-	if (down_interruptible(&sn9c102_sysfs_lock))
-		return -ERESTARTSYS;
-
-	cam = video_get_drvdata(to_video_device(cd));
-	if (!cam) {
-		up(&sn9c102_sysfs_lock);
-		return -ENODEV;
-	}
-
-	count = sprintf(buf, "%u\n", cam->sysfs.i2c_reg);
-
-	DBG(3, "Read bytes: %zd", count)
-
-	up(&sn9c102_sysfs_lock);
-
-	return count;
-} 
-
-
-static ssize_t 
-sn9c102_store_i2c_reg(struct class_device* cd, const char* buf, size_t len)
-{
-	struct sn9c102_device* cam;
-	u8 index;
-	ssize_t count;
-
-	if (down_interruptible(&sn9c102_sysfs_lock))
-		return -ERESTARTSYS;
-
-	cam = video_get_drvdata(to_video_device(cd));
-	if (!cam) {
-		up(&sn9c102_sysfs_lock);
-		return -ENODEV;
-	}
-
-	index = sn9c102_strtou8(buf, len, &count);
-	if (!count) {
-		up(&sn9c102_sysfs_lock);
-		return -EINVAL;
-	}
-
-	cam->sysfs.i2c_reg = index;
-
-	DBG(2, "Moved sensor register index to 0x%02X", cam->sysfs.i2c_reg)
-	DBG(3, "Written bytes: %zd", count)
-
-	up(&sn9c102_sysfs_lock);
-
-	return count;
-}
-
-
-static ssize_t sn9c102_show_i2c_val(struct class_device* cd, char* buf)
-{
-	struct sn9c102_device* cam;
-	ssize_t count;
-	int val;
-
-	if (down_interruptible(&sn9c102_sysfs_lock))
-		return -ERESTARTSYS;
-
-	cam = video_get_drvdata(to_video_device(cd));
-	if (!cam) {
-		up(&sn9c102_sysfs_lock);
-		return -ENODEV;
-	}
-
-	if ((val = sn9c102_i2c_read(cam, cam->sysfs.i2c_reg)) < 0) {
-		up(&sn9c102_sysfs_lock);
-		return -EIO;
-	}
-
-	count = sprintf(buf, "%d\n", val);
-
-	DBG(3, "Read bytes: %zd", count)
-
-	up(&sn9c102_sysfs_lock);
-
-	return count;
-} 
-
-
-static ssize_t
-sn9c102_store_i2c_val(struct class_device* cd, const char* buf, size_t len)
-{
-	struct sn9c102_device* cam;
-	u8 value;
-	ssize_t count;
-	int err;
-
-	if (down_interruptible(&sn9c102_sysfs_lock))
-		return -ERESTARTSYS;
-
-	cam = video_get_drvdata(to_video_device(cd));
-	if (!cam) {
-		up(&sn9c102_sysfs_lock);
-		return -ENODEV;
-	}
-
-	value = sn9c102_strtou8(buf, len, &count);
-	if (!count) {
-		up(&sn9c102_sysfs_lock);
-		return -EINVAL;
-	}
-
-	err = sn9c102_i2c_write(cam, cam->sysfs.i2c_reg, value);
-	if (err) {
-		up(&sn9c102_sysfs_lock);
-		return -EIO;
-	}
-
-	DBG(2, "Written sensor reg. 0x%02X, val. 0x%02X",
-	    cam->sysfs.i2c_reg, value)
-	DBG(3, "Written bytes: %zd", count)
-
-	up(&sn9c102_sysfs_lock);
-
-	return count;
-}
-
-
-static ssize_t
-sn9c102_store_green(struct class_device* cd, const char* buf, size_t len)
-{
-	ssize_t res = 0;
-	u8 value;
-	ssize_t count;
-
-	value = sn9c102_strtou8(buf, len, &count);
-	if (!count || value > 0x0f)
-		return -EINVAL;
-
-	if ((res = sn9c102_store_reg(cd, "0x11", 4)) >= 0)
-		res = sn9c102_store_val(cd, buf, len);
-
-	return res;
-}
-
-
-static CLASS_DEVICE_ATTR(reg, S_IRUGO | S_IWUSR,
-                         sn9c102_show_reg, sn9c102_store_reg);
-static CLASS_DEVICE_ATTR(val, S_IRUGO | S_IWUSR,
-                         sn9c102_show_val, sn9c102_store_val);
-static CLASS_DEVICE_ATTR(i2c_reg, S_IRUGO | S_IWUSR,
-                         sn9c102_show_i2c_reg, sn9c102_store_i2c_reg);
-static CLASS_DEVICE_ATTR(i2c_val, S_IRUGO | S_IWUSR,
-                         sn9c102_show_i2c_val, sn9c102_store_i2c_val);
-static CLASS_DEVICE_ATTR(green, S_IWUGO, NULL, sn9c102_store_green);
-
-
-static void sn9c102_create_sysfs(struct sn9c102_device* cam)
-{
-	struct video_device *v4ldev = cam->v4ldev;
-
-	video_device_create_file(v4ldev, &class_device_attr_reg);
-	video_device_create_file(v4ldev, &class_device_attr_val);
-	video_device_create_file(v4ldev, &class_device_attr_green);
-	if (cam->sensor->slave_write_id && cam->sensor->slave_read_id) {
-		video_device_create_file(v4ldev, &class_device_attr_i2c_reg);
-		video_device_create_file(v4ldev, &class_device_attr_i2c_val);
-	}
-}
-
-/*****************************************************************************/
-
-static int sn9c102_set_scale(struct sn9c102_device* cam, u8 scale)
-{
-	u8 r = 0;
-	int err = 0;
-
-	if (scale == 1)
-		r = cam->reg[0x18] & 0xcf;
-	else if (scale == 2) {
-		r = cam->reg[0x18] & 0xcf;
-		r |= 0x10;
-	} else if (scale == 4)
-		r = cam->reg[0x18] | 0x20;
-
-	err += sn9c102_write_reg(cam, r, 0x18);
-	if (err)
-		return -EIO;
-
-	PDBGG("Scaling factor: %u", scale)
-
-	return 0;
-}
-
-
-static int sn9c102_set_crop(struct sn9c102_device* cam, struct v4l2_rect* rect)
-{
-	struct sn9c102_sensor* s = cam->sensor;
-	u8 h_start = (u8)(rect->left - s->cropcap.bounds.left),
-	   v_start = (u8)(rect->top - s->cropcap.bounds.top),
-	   h_size = (u8)(rect->width / 16),
-	   v_size = (u8)(rect->height / 16),
-	   ae_strx = 0x00,
-	   ae_stry = 0x00,
-	   ae_endx = h_size / 2,
-	   ae_endy = v_size / 2;
-	int err = 0;
-
-	err += sn9c102_write_reg(cam, h_start, 0x12);
-	err += sn9c102_write_reg(cam, v_start, 0x13);
-	err += sn9c102_write_reg(cam, h_size, 0x15);
-	err += sn9c102_write_reg(cam, v_size, 0x16);
-	err += sn9c102_write_reg(cam, ae_strx, 0x1c);
-	err += sn9c102_write_reg(cam, ae_stry, 0x1d);
-	err += sn9c102_write_reg(cam, ae_endx, 0x1e);
-	err += sn9c102_write_reg(cam, ae_endy, 0x1f);
-	if (err)
-		return -EIO;
-
-	PDBGG("h_start, v_start, h_size, v_size, ho_size, vo_size "
-	      "%u %u %u %u", h_start, v_start, h_size, v_size)
-
-	return 0;
-}
-
-
-static int sn9c102_init(struct sn9c102_device* cam)
-{
-	struct sn9c102_sensor* s = cam->sensor;
-	struct v4l2_control ctrl;
-	struct v4l2_queryctrl *qctrl;
-	struct v4l2_rect* rect;
-	u8 i = 0, n = 0;
-	int err = 0;
-
-	if (!(cam->state & DEV_INITIALIZED)) {
-		init_waitqueue_head(&cam->open);
-		qctrl = s->qctrl;
-		rect = &(s->cropcap.defrect);
-	} else { /* use current values */
-		qctrl = s->_qctrl;
-		rect = &(s->_rect);
-	}
-
-	err += sn9c102_set_scale(cam, rect->width / s->pix_format.width);
-	err += sn9c102_set_crop(cam, rect);
-	if (err)
-		return err;
-
-	if (s->init) {
-		err = s->init(cam);
-		if (err) {
-			DBG(3, "Sensor initialization failed")
-			return err;
-		}
-	}
-
-	if (s->set_crop)
-		if ((err = s->set_crop(cam, rect))) {
-			DBG(3, "set_crop() failed")
-			return err;
-		}
-
-	if (s->set_ctrl) {
-		n = sizeof(s->qctrl) / sizeof(s->qctrl[0]);
-		for (i = 0; i < n; i++)
-			if (s->qctrl[i].id != 0 && 
-			    !(s->qctrl[i].flags & V4L2_CTRL_FLAG_DISABLED)) {
-				ctrl.id = s->qctrl[i].id;
-				ctrl.value = qctrl[i].default_value;
-				err = s->set_ctrl(cam, &ctrl);
-				if (err) {
-					DBG(3, "Set control failed")
-					return err;
-				}
-			}
-	}
-
-	if (!(cam->state & DEV_INITIALIZED)) {
-		init_MUTEX(&cam->fileop_sem);
-		spin_lock_init(&cam->queue_lock);
-		init_waitqueue_head(&cam->wait_frame);
-		init_waitqueue_head(&cam->wait_stream);
-		memcpy(s->_qctrl, s->qctrl, sizeof(s->qctrl));
-		memcpy(&(s->_rect), &(s->cropcap.defrect), 
-		       sizeof(struct v4l2_rect));
-		cam->state |= DEV_INITIALIZED;
-	}
-
-	DBG(2, "Initialization succeeded")
-	return 0;
-}
-
-
-static void sn9c102_release_resources(struct sn9c102_device* cam)
-{
-	down(&sn9c102_sysfs_lock);
-
-	DBG(2, "V4L2 device /dev/video%d deregistered", cam->v4ldev->minor)
-	video_set_drvdata(cam->v4ldev, NULL);
-	video_unregister_device(cam->v4ldev);
-
-	up(&sn9c102_sysfs_lock);
-
-	kfree(cam->control_buffer);
-}
-
-/*****************************************************************************/
-
-static int sn9c102_open(struct inode* inode, struct file* filp)
-{
-	struct sn9c102_device* cam;
-	int err = 0;
-
-	/*
-	   This is the only safe way to prevent race conditions with
-	   disconnect
-	*/
-	if (!down_read_trylock(&sn9c102_disconnect))
-		return -ERESTARTSYS;
-
-	cam = video_get_drvdata(video_devdata(filp));
-
-	if (down_interruptible(&cam->dev_sem)) {
-		up_read(&sn9c102_disconnect);
-		return -ERESTARTSYS;
-	}
-
-	if (cam->users) {
-		DBG(2, "Device /dev/video%d is busy...", cam->v4ldev->minor)
-		if ((filp->f_flags & O_NONBLOCK) ||
-		    (filp->f_flags & O_NDELAY)) {
-			err = -EWOULDBLOCK;
-			goto out;
-		}
-		up(&cam->dev_sem);
-		err = wait_event_interruptible_exclusive(cam->open,
-		                                  cam->state & DEV_DISCONNECTED
-		                                         || !cam->users);
-		if (err) {
-			up_read(&sn9c102_disconnect);
-			return err;
-		}
-		if (cam->state & DEV_DISCONNECTED) {
-			up_read(&sn9c102_disconnect);
-			return -ENODEV;
-		}
-		down(&cam->dev_sem);
-	}
-
-
-	if (cam->state & DEV_MISCONFIGURED) {
-		err = sn9c102_init(cam);
-		if (err) {
-			DBG(1, "Initialization failed again. "
-			       "I will retry on next open().")
-			goto out;
-		}
-		cam->state &= ~DEV_MISCONFIGURED;
-	}
-
-	if ((err = sn9c102_start_transfer(cam)))
-		goto out;
-
-	filp->private_data = cam;
-	cam->users++;
-	cam->io = IO_NONE;
-	cam->stream = STREAM_OFF;
-	cam->nbuffers = 0;
-	cam->frame_count = 0;
-	sn9c102_empty_framequeues(cam);
-
-	DBG(3, "Video device /dev/video%d is open", cam->v4ldev->minor)
-
-out:
-	up(&cam->dev_sem);
-	up_read(&sn9c102_disconnect);
-	return err;
-}
-
-
-static int sn9c102_release(struct inode* inode, struct file* filp)
-{
-	struct sn9c102_device* cam = video_get_drvdata(video_devdata(filp));
-
-	down(&cam->dev_sem); /* prevent disconnect() to be called */
-
-	sn9c102_stop_transfer(cam);
-
-	sn9c102_release_buffers(cam);
-
-	if (cam->state & DEV_DISCONNECTED) {
-		sn9c102_release_resources(cam);
-		up(&cam->dev_sem);
-		kfree(cam);
-		return 0;
-	}
-
-	cam->users--;
-	wake_up_interruptible_nr(&cam->open, 1);
-
-	DBG(3, "Video device /dev/video%d closed", cam->v4ldev->minor)
-
-	up(&cam->dev_sem);
-
-	return 0;
-}
-
-
-static ssize_t
-sn9c102_read(struct file* filp, char __user * buf, size_t count, loff_t* f_pos)
-{
-	struct sn9c102_device* cam = video_get_drvdata(video_devdata(filp));
-	struct sn9c102_frame_t* f, * i;
-	unsigned long lock_flags;
-	int err = 0;
-
-	if (down_interruptible(&cam->fileop_sem))
-		return -ERESTARTSYS;
-
-	if (cam->state & DEV_DISCONNECTED) {
-		DBG(1, "Device not present")
-		up(&cam->fileop_sem);
-		return -ENODEV;
-	}
-
-	if (cam->state & DEV_MISCONFIGURED) {
-		DBG(1, "The camera is misconfigured. Close and open it again.")
-		up(&cam->fileop_sem);
-		return -EIO;
-	}
-
-	if (cam->io == IO_MMAP) {
-		DBG(3, "Close and open the device again to choose "
-		       "the read method")
-		up(&cam->fileop_sem);
-		return -EINVAL;
-	}
-
-	if (cam->io == IO_NONE) {
-		if (!sn9c102_request_buffers(cam, 2)) {
-			DBG(1, "read() failed, not enough memory")
-			up(&cam->fileop_sem);
-			return -ENOMEM;
-		}
-		cam->io = IO_READ;
-		cam->stream = STREAM_ON;
-		sn9c102_queue_unusedframes(cam);
-	}
-
-	if (!count) {
-		up(&cam->fileop_sem);
-		return 0;
-	}
-
-	if (list_empty(&cam->outqueue)) {
-		if (filp->f_flags & O_NONBLOCK) {
-			up(&cam->fileop_sem);
-			return -EAGAIN;
-		}
-		err = wait_event_interruptible
-		      ( cam->wait_frame, 
-		        (!list_empty(&cam->outqueue)) ||
-		        (cam->state & DEV_DISCONNECTED) );
-		if (err) {
-			up(&cam->fileop_sem);
-			return err;
-		}
-		if (cam->state & DEV_DISCONNECTED) {
-			up(&cam->fileop_sem);
-			return -ENODEV;
-		}
-	}
-
-	f = list_entry(cam->outqueue.prev, struct sn9c102_frame_t, frame);
-
-	spin_lock_irqsave(&cam->queue_lock, lock_flags);
-	list_for_each_entry(i, &cam->outqueue, frame)
-		i->state = F_UNUSED;
-	INIT_LIST_HEAD(&cam->outqueue);
-	spin_unlock_irqrestore(&cam->queue_lock, lock_flags);
-
-	sn9c102_queue_unusedframes(cam);
-
-	if (count > f->buf.length)
-		count = f->buf.length;
-
-	if (copy_to_user(buf, f->bufmem, count)) {
-		up(&cam->fileop_sem);
-		return -EFAULT;
-	}
-	*f_pos += count;
-
-	PDBGG("Frame #%lu, bytes read: %zu", (unsigned long)f->buf.index,count)
-
-	up(&cam->fileop_sem);
-
-	return count;
-}
-
-
-static unsigned int sn9c102_poll(struct file *filp, poll_table *wait)
-{
-	struct sn9c102_device* cam = video_get_drvdata(video_devdata(filp));
-	unsigned int mask = 0;
-
-	if (down_interruptible(&cam->fileop_sem))
-		return POLLERR;
-
-	if (cam->state & DEV_DISCONNECTED) {
-		DBG(1, "Device not present")
-		goto error;
-	}
-
-	if (cam->state & DEV_MISCONFIGURED) {
-		DBG(1, "The camera is misconfigured. Close and open it again.")
-		goto error;
-	}
-
-	if (cam->io == IO_NONE) {
-		if (!sn9c102_request_buffers(cam, 2)) {
-			DBG(1, "poll() failed, not enough memory")
-			goto error;
-		}
-		cam->io = IO_READ;
-		cam->stream = STREAM_ON;
-	}
-
-	if (cam->io == IO_READ)
-		sn9c102_queue_unusedframes(cam);
-
-	poll_wait(filp, &cam->wait_frame, wait);
-
-	if (!list_empty(&cam->outqueue))
-		mask |= POLLIN | POLLRDNORM;
-
-	up(&cam->fileop_sem);
-
-	return mask;
-
-error:
-	up(&cam->fileop_sem);
-	return POLLERR;
-}
-
-
-static void sn9c102_vm_open(struct vm_area_struct* vma)
-{
-	struct sn9c102_frame_t* f = vma->vm_private_data;
-	f->vma_use_count++;
-}
-
-
-static void sn9c102_vm_close(struct vm_area_struct* vma)
-{
-	/* NOTE: buffers are not freed here */
-	struct sn9c102_frame_t* f = vma->vm_private_data;
-	f->vma_use_count--;
-}
-
-
-static struct vm_operations_struct sn9c102_vm_ops = {
-	.open = sn9c102_vm_open,
-	.close = sn9c102_vm_close,
-};
-
-
-static int sn9c102_mmap(struct file* filp, struct vm_area_struct *vma)
-{
-	struct sn9c102_device* cam = video_get_drvdata(video_devdata(filp));
-	unsigned long size = vma->vm_end - vma->vm_start,
-	              start = vma->vm_start,
-	              pos,
-	              page;
-	u32 i;
-
-	if (down_interruptible(&cam->fileop_sem))
-		return -ERESTARTSYS;
-
-	if (cam->state & DEV_DISCONNECTED) {
-		DBG(1, "Device not present")
-		up(&cam->fileop_sem);
-		return -ENODEV;
-	}
-
-	if (cam->state & DEV_MISCONFIGURED) {
-		DBG(1, "The camera is misconfigured. Close and open it again.")
-		up(&cam->fileop_sem);
-		return -EIO;
-	}
-
-	if (cam->io != IO_MMAP || !(vma->vm_flags & VM_WRITE) ||
-	    size != PAGE_ALIGN(cam->frame[0].buf.length)) {
-		up(&cam->fileop_sem);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < cam->nbuffers; i++) {
-		if ((cam->frame[i].buf.m.offset>>PAGE_SHIFT) == vma->vm_pgoff)
-			break;
-	}
-	if (i == cam->nbuffers) {
-		up(&cam->fileop_sem);
-		return -EINVAL;
-	}
-
-	pos = (unsigned long)cam->frame[i].bufmem;
-	while (size > 0) { /* size is page-aligned */
-		page = kvirt_to_pa(pos);
-		if (remap_page_range(vma, start, page, PAGE_SIZE, 
-		                     vma->vm_page_prot)) {
-			up(&cam->fileop_sem);
-			return -EAGAIN;
-		}
-		start += PAGE_SIZE;
-		pos += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	vma->vm_ops = &sn9c102_vm_ops;
-	vma->vm_flags &= ~VM_IO; /* not I/O memory */
-	vma->vm_flags |= VM_RESERVED; /* avoid to swap out this VMA */
-	vma->vm_private_data = &cam->frame[i];
-
-	sn9c102_vm_open(vma);
-
-	up(&cam->fileop_sem);
-
-	return 0;
-}
-
-
-static int sn9c102_v4l2_ioctl(struct inode* inode, struct file* filp,
-                              unsigned int cmd, void __user * arg)
-{
-	struct sn9c102_device* cam = video_get_drvdata(video_devdata(filp));
-
-	switch (cmd) {
-
-	case VIDIOC_QUERYCAP:
-	{
-		struct v4l2_capability cap = {
-			.driver = "sn9c102",
-			.version = SN9C102_MODULE_VERSION_CODE,
-			.capabilities = V4L2_CAP_VIDEO_CAPTURE | 
-			                V4L2_CAP_READWRITE |
-		 	                V4L2_CAP_STREAMING,
-		};
-
-		strlcpy(cap.card, cam->v4ldev->name, sizeof(cap.card));
-		strlcpy(cap.bus_info, cam->dev.bus_id, sizeof(cap.bus_info));
-
-		if (copy_to_user(arg, &cap, sizeof(cap)))
-			return -EFAULT;
-
-		return 0;
-	}
-
-	case VIDIOC_ENUMINPUT:
-	{
-		struct v4l2_input i;
-
-		if (copy_from_user(&i, arg, sizeof(i)))
-			return -EFAULT;
-
-		if (i.index)
-			return -EINVAL;
-
-		memset(&i, 0, sizeof(i));
-		strcpy(i.name, "USB");
-
-		if (copy_to_user(arg, &i, sizeof(i)))
-			return -EFAULT;
-
-		return 0;
-	}
-
-	case VIDIOC_G_INPUT:
-	case VIDIOC_S_INPUT:
-	{
-		int index;
-
-		if (copy_from_user(&index, arg, sizeof(index)))
-			return -EFAULT;
-
-		if (index != 0)
-			return -EINVAL;
-
-		return 0;
-	}
-
-	case VIDIOC_QUERYCTRL:
-	{
-		struct sn9c102_sensor* s = cam->sensor;
-		struct v4l2_queryctrl qc;
-		u8 i, n;
-
-		if (copy_from_user(&qc, arg, sizeof(qc)))
-			return -EFAULT;
-
-		n = sizeof(s->qctrl) / sizeof(s->qctrl[0]);
-		for (i = 0; i < n; i++)
-			if (qc.id && qc.id == s->qctrl[i].id) {
-				memcpy(&qc, &(s->qctrl[i]), sizeof(qc));
-				if (copy_to_user(arg, &qc, sizeof(qc)))
-					return -EFAULT;
-				return 0;
-			}
-
-		return -EINVAL;
-	}
-
-	case VIDIOC_G_CTRL:
-	{
-		struct sn9c102_sensor* s = cam->sensor;
-		struct v4l2_control ctrl;
-		int err = 0;
-
-		if (!s->get_ctrl)
-			return -EINVAL;
-
-		if (copy_from_user(&ctrl, arg, sizeof(ctrl)))
-			return -EFAULT;
-
-		err = s->get_ctrl(cam, &ctrl);
-
-		if (copy_to_user(arg, &ctrl, sizeof(ctrl)))
-			return -EFAULT;
-
-		return err;
-	}
-
-	case VIDIOC_S_CTRL:
-	{
-		struct sn9c102_sensor* s = cam->sensor;
-		struct v4l2_control ctrl;
-		u8 i, n;
-		int err = 0;
-
-		if (!s->set_ctrl)
-			return -EINVAL;
-
-		if (copy_from_user(&ctrl, arg, sizeof(ctrl)))
-			return -EFAULT;
-
-		if ((err = s->set_ctrl(cam, &ctrl)))
-			return err;
-
-		n = sizeof(s->qctrl) / sizeof(s->qctrl[0]);
-		for (i = 0; i < n; i++)
-			if (ctrl.id == s->qctrl[i].id) {
-				s->_qctrl[i].default_value = ctrl.value;
-				break;
-			}
-
-		return 0;
-	}
-
-	case VIDIOC_CROPCAP:
-	{
-		struct v4l2_cropcap* cc = &(cam->sensor->cropcap);
-
-		cc->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		cc->pixelaspect.numerator = 1;
-		cc->pixelaspect.denominator = 1;
-
-		if (copy_to_user(arg, cc, sizeof(*cc)))
-			return -EFAULT;
-
-		return 0;
-	}
-
-	case VIDIOC_G_CROP:
-	{
-		struct sn9c102_sensor* s = cam->sensor;
-		struct v4l2_crop crop = {
-			.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
-		};
-
-		memcpy(&(crop.c), &(s->_rect), sizeof(struct v4l2_rect));
-
-		if (copy_to_user(arg, &crop, sizeof(crop)))
-			return -EFAULT;
-
-		return 0;
-	}
-
-	case VIDIOC_S_CROP:
-	{
-		struct sn9c102_sensor* s = cam->sensor;
-		struct v4l2_crop crop;
-		struct v4l2_rect* rect;
-		struct v4l2_rect* bounds = &(s->cropcap.bounds);
-		struct v4l2_pix_format* pix_format = &(s->pix_format);
-		u8 scale;
-		const enum sn9c102_stream_state stream = cam->stream;
-		const u32 nbuffers = cam->nbuffers;
-		u32 i;
-		int err = 0;
-
-		if (copy_from_user(&crop, arg, sizeof(crop)))
-			return -EFAULT;
-
-		rect = &(crop.c);
-
-		if (crop.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-			return -EINVAL;
-
-		for (i = 0; i < cam->nbuffers; i++)
-			if (cam->frame[i].vma_use_count) {
-				DBG(3, "VIDIOC_S_CROP failed. "
-				       "Unmap the buffers first.")
-				return -EINVAL;
-			}
-
-		/* Preserve R,G or B origin */
-		rect->left = (s->_rect.left & 1L) ?
-		             rect->left | 1L : rect->left & ~1L;
-		rect->top = (s->_rect.top & 1L) ?
-		            rect->top | 1L : rect->top & ~1L;
-
-		if (rect->width < 16)
-			rect->width = 16;
-		if (rect->height < 16)
-			rect->height = 16;
-		if (rect->width > bounds->width)
-			rect->width = bounds->width;
-		if (rect->height > bounds->height)
-			rect->height = bounds->height;
-		if (rect->left < bounds->left)
-			rect->left = bounds->left;
-		if (rect->top < bounds->top)
-			rect->top = bounds->top;
-		if (rect->left + rect->width > bounds->left + bounds->width)
-			rect->left = bounds->left+bounds->width - rect->width;
-		if (rect->top + rect->height > bounds->top + bounds->height)
-			rect->top = bounds->top+bounds->height - rect->height;
-
-		rect->width &= ~15L;
-		rect->height &= ~15L;
-
-		if (SN9C102_PRESERVE_IMGSCALE) {
-			/* Calculate the actual scaling factor */
-			u32 a, b;
-			a = rect->width * rect->height;
-			b = pix_format->width * pix_format->height;
-			scale = b ? (u8)((a / b) < 4 ? 1 :
-		                        ((a / b) < 16 ? 2 : 4)) : 1;
-		} else
-			scale = 1;
-
-		if (cam->stream == STREAM_ON) {
-			cam->stream = STREAM_INTERRUPT;
-			err = wait_event_interruptible
-			      ( cam->wait_stream, 
-			        (cam->stream == STREAM_OFF) ||
-			        (cam->state & DEV_DISCONNECTED) );
-			if (err) {
-				cam->state |= DEV_MISCONFIGURED;
-				DBG(1, "The camera is misconfigured. To use "
-				       "it, close and open /dev/video%d "
-				       "again.", cam->v4ldev->minor)
-				return err;
-			}
-			if (cam->state & DEV_DISCONNECTED)
-				return -ENODEV;
-		}
-
-		if (copy_to_user(arg, &crop, sizeof(crop))) {
-			cam->stream = stream;
-			return -EFAULT;
-		}
-
-		sn9c102_release_buffers(cam);
-
-		err = sn9c102_set_crop(cam, rect);
-		if (s->set_crop)
-			err += s->set_crop(cam, rect);
-		err += sn9c102_set_scale(cam, scale);
-
-		if (err) { /* atomic, no rollback in ioctl() */
-			cam->state |= DEV_MISCONFIGURED;
-			DBG(1, "VIDIOC_S_CROP failed because of hardware "
-			       "problems. To use the camera, close and open "
-			       "/dev/video%d again.", cam->v4ldev->minor)
-			return err;
-		}
-
-		s->pix_format.width = rect->width/scale;
-		s->pix_format.height = rect->height/scale;
-		memcpy(&(s->_rect), rect, sizeof(*rect));
-
-		if (nbuffers != sn9c102_request_buffers(cam, nbuffers)) {
-			cam->state |= DEV_MISCONFIGURED;
-			DBG(1, "VIDIOC_S_CROP failed because of not enough "
-			       "memory. To use the camera, close and open "
-			       "/dev/video%d again.", cam->v4ldev->minor)
-			return -ENOMEM;
-		}
-
-		cam->stream = stream;
-
-		return 0;
-	}
-
-	case VIDIOC_ENUM_FMT:
-	{
-		struct sn9c102_sensor* s = cam->sensor;
-		struct v4l2_fmtdesc fmtd;
-
-		if (copy_from_user(&fmtd, arg, sizeof(fmtd)))
-			return -EFAULT;
-
-		if (fmtd.index != 0)
-			return -EINVAL;
-
-		memset(&fmtd, 0, sizeof(fmtd));
-
-		fmtd.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		strcpy(fmtd.description, "bayer rgb");
-		fmtd.pixelformat = s->pix_format.pixelformat;
-
-		if (copy_to_user(arg, &fmtd, sizeof(fmtd)))
-			return -EFAULT;
-
-		return 0;
-	}
-
-	case VIDIOC_G_FMT:
-	{
-		struct v4l2_format format;
-		struct v4l2_pix_format* pfmt = &(cam->sensor->pix_format);
-
-		if (copy_from_user(&format, arg, sizeof(format)))
-			return -EFAULT;
-
-		if (format.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-			return -EINVAL;
-
-		pfmt->bytesperline = (pfmt->width * pfmt->priv) / 8;
-		pfmt->sizeimage = pfmt->height * pfmt->bytesperline;
-		pfmt->field = V4L2_FIELD_NONE;
-		memcpy(&(format.fmt.pix), pfmt, sizeof(*pfmt));
-
-		if (copy_to_user(arg, &format, sizeof(format)))
-			return -EFAULT;
-
-		return 0;
-	}
-
-	case VIDIOC_TRY_FMT:
-	case VIDIOC_S_FMT:
-	{
-		struct sn9c102_sensor* s = cam->sensor;
-		struct v4l2_format format;
-		struct v4l2_pix_format* pix;
-		struct v4l2_pix_format* pfmt = &(s->pix_format);
-		struct v4l2_rect* bounds = &(s->cropcap.bounds);
-		struct v4l2_rect rect;
-		u8 scale;
-		const enum sn9c102_stream_state stream = cam->stream;
-		const u32 nbuffers = cam->nbuffers;
-		u32 i;
-		int err = 0;
-
-		if (copy_from_user(&format, arg, sizeof(format)))
-			return -EFAULT;
-
-		pix = &(format.fmt.pix);
-
-		if (format.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-			return -EINVAL;
-
-		memcpy(&rect, &(s->_rect), sizeof(rect));
-
-		{ /* calculate the actual scaling factor */
-			u32 a, b;
-			a = rect.width * rect.height;
-			b = pix->width * pix->height;
-			scale = b ? (u8)((a / b) < 4 ? 1 :
-		                        ((a / b) < 16 ? 2 : 4)) : 1;
-		}
-
-		rect.width = scale * pix->width;
-		rect.height = scale * pix->height;
-
-		if (rect.width < 16)
-			rect.width = 16;
-		if (rect.height < 16)
-			rect.height = 16;
-		if (rect.width > bounds->left + bounds->width - rect.left)
-			rect.width = bounds->left + bounds->width - rect.left;
-		if (rect.height > bounds->top + bounds->height - rect.top)
-			rect.height = bounds->top + bounds->height - rect.top;
-
-		rect.width &= ~15L;
-		rect.height &= ~15L;
-
-		{ /* adjust the scaling factor */
-			u32 a, b;
-			a = rect.width * rect.height;
-			b = pix->width * pix->height;
-			scale = b ? (u8)((a / b) < 4 ? 1 :
-		                        ((a / b) < 16 ? 2 : 4)) : 1;
-		}
-
-		pix->width = rect.width / scale;
-		pix->height = rect.height / scale;
-
-		pix->pixelformat = pfmt->pixelformat;
-		pix->priv = pfmt->priv; /* bpp */
-		pix->colorspace = pfmt->colorspace;
-		pix->bytesperline = (pix->width * pix->priv) / 8;
-		pix->sizeimage = pix->height * pix->bytesperline;
-		pix->field = V4L2_FIELD_NONE;
-
-		if (cmd == VIDIOC_TRY_FMT)
-			return 0;
-
-		for (i = 0; i < cam->nbuffers; i++)
-			if (cam->frame[i].vma_use_count) {
-				DBG(3, "VIDIOC_S_FMT failed. "
-				       "Unmap the buffers first.")
-				return -EINVAL;
-			}
-
-		if (cam->stream == STREAM_ON) {
-			cam->stream = STREAM_INTERRUPT;
-			err = wait_event_interruptible
-			      ( cam->wait_stream, 
-			        (cam->stream == STREAM_OFF) ||
-			        (cam->state & DEV_DISCONNECTED) );
-			if (err) {
-				cam->state |= DEV_MISCONFIGURED;
-				DBG(1, "The camera is misconfigured. To use "
-				       "it, close and open /dev/video%d "
-				       "again.", cam->v4ldev->minor)
-				return err;
-			}
-			if (cam->state & DEV_DISCONNECTED)
-				return -ENODEV;
-		}
-
-		if (copy_to_user(arg, &format, sizeof(format))) {
-			cam->stream = stream;
-			return -EFAULT;
-		}
-
-		sn9c102_release_buffers(cam);
-
-		err = sn9c102_set_crop(cam, &rect);
-		if (s->set_crop)
-			err += s->set_crop(cam, &rect);
-		err += sn9c102_set_scale(cam, scale);
-
-		if (err) { /* atomic, no rollback in ioctl() */
-			cam->state |= DEV_MISCONFIGURED;
-			DBG(1, "VIDIOC_S_FMT failed because of hardware "
-			       "problems. To use the camera, close and open "
-			       "/dev/video%d again.", cam->v4ldev->minor)
-			return err;
-		}
-
-		memcpy(pfmt, pix, sizeof(*pix));
-		memcpy(&(s->_rect), &rect, sizeof(rect));
-
-		if (nbuffers != sn9c102_request_buffers(cam, nbuffers)) {
-			cam->state |= DEV_MISCONFIGURED;
-			DBG(1, "VIDIOC_S_FMT failed because of not enough "
-			       "memory. To use the camera, close and open "
-			       "/dev/video%d again.", cam->v4ldev->minor)
-			return -ENOMEM;
-		}
-
-		cam->stream = stream;
-
-		return 0;
-	}
-
-	case VIDIOC_REQBUFS:
-	{
-		struct v4l2_requestbuffers rb;
-		u32 i;
-		int err;
-
-		if (copy_from_user(&rb, arg, sizeof(rb)))
-			return -EFAULT;
-
-		if (rb.type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
-		    rb.memory != V4L2_MEMORY_MMAP)
-			return -EINVAL;
-
-		if (cam->io == IO_READ) {
-			DBG(3, "Close and open the device again to choose "
-			       "the mmap I/O method")
-			return -EINVAL;
-		}
-
-		for (i = 0; i < cam->nbuffers; i++)
-			if (cam->frame[i].vma_use_count) {
-				DBG(3, "VIDIOC_REQBUFS failed. "
-				       "Previous buffers are still mapped.")
-				return -EINVAL;
-			}
-
-		if (cam->stream == STREAM_ON) {
-			cam->stream = STREAM_INTERRUPT;
-			err = wait_event_interruptible
-			      ( cam->wait_stream, 
-			        (cam->stream == STREAM_OFF) ||
-			        (cam->state & DEV_DISCONNECTED) );
-			if (err) {
-				cam->state |= DEV_MISCONFIGURED;
-				DBG(1, "The camera is misconfigured. To use "
-				       "it, close and open /dev/video%d "
-				       "again.", cam->v4ldev->minor)
-				return err;
-			}
-			if (cam->state & DEV_DISCONNECTED)
-				return -ENODEV;
-		}
-
-		sn9c102_empty_framequeues(cam);
-
-		sn9c102_release_buffers(cam);
-		if (rb.count)
-			rb.count = sn9c102_request_buffers(cam, rb.count);
-
-		if (copy_to_user(arg, &rb, sizeof(rb))) {
-			sn9c102_release_buffers(cam);
-			cam->io = IO_NONE;
-			return -EFAULT;
-		}
-
-		cam->io = rb.count ? IO_MMAP : IO_NONE;
-
-		return 0;
-	}
-
-	case VIDIOC_QUERYBUF:
-	{
-		struct v4l2_buffer b;
-
-		if (copy_from_user(&b, arg, sizeof(b)))
-			return -EFAULT;
-
-		if (b.type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
-		    b.index >= cam->nbuffers || cam->io != IO_MMAP)
-			return -EINVAL;
-
-		memcpy(&b, &cam->frame[b.index].buf, sizeof(b));
-
-		if (cam->frame[b.index].vma_use_count)
-			b.flags |= V4L2_BUF_FLAG_MAPPED;
-
-		if (cam->frame[b.index].state == F_DONE)
-			b.flags |= V4L2_BUF_FLAG_DONE;
-		else if (cam->frame[b.index].state != F_UNUSED)
-			b.flags |= V4L2_BUF_FLAG_QUEUED;
-
-		if (copy_to_user(arg, &b, sizeof(b)))
-			return -EFAULT;
-
-		return 0;
-	}
-
-	case VIDIOC_QBUF:
-	{
-		struct v4l2_buffer b;
-		unsigned long lock_flags;
-
-		if (copy_from_user(&b, arg, sizeof(b)))
-			return -EFAULT;
-
-		if (b.type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
-		    b.index >= cam->nbuffers || cam->io != IO_MMAP)
-			return -EINVAL;
-
-		if (cam->frame[b.index].state != F_UNUSED)
-			return -EINVAL;
-
-		cam->frame[b.index].state = F_QUEUED;
-
-		spin_lock_irqsave(&cam->queue_lock, lock_flags);
-		list_add_tail(&cam->frame[b.index].frame, &cam->inqueue);
-		spin_unlock_irqrestore(&cam->queue_lock, lock_flags);
-
-		PDBGG("Frame #%lu queued", (unsigned long)b.index)
-
-		return 0;
-	}
-
-	case VIDIOC_DQBUF:
-	{
-		struct v4l2_buffer b;
-		struct sn9c102_frame_t *f;
-		unsigned long lock_flags;
-		int err = 0;
-
-		if (copy_from_user(&b, arg, sizeof(b)))
-			return -EFAULT;
-
-		if (b.type != V4L2_BUF_TYPE_VIDEO_CAPTURE || cam->io!= IO_MMAP)
-			return -EINVAL;
-
-		if (list_empty(&cam->outqueue)) {
-			if (cam->stream == STREAM_OFF)
-				return -EINVAL;
-			if (filp->f_flags & O_NONBLOCK)
-				return -EAGAIN;
-			err = wait_event_interruptible
-			      ( cam->wait_frame, 
-			        (!list_empty(&cam->outqueue)) ||
-			        (cam->state & DEV_DISCONNECTED) );
-			if (err)
-				return err;
-			if (cam->state & DEV_DISCONNECTED)
-				return -ENODEV;
-		}
-
-		spin_lock_irqsave(&cam->queue_lock, lock_flags);
-		f = list_entry(cam->outqueue.next, struct sn9c102_frame_t,
-		               frame);
-		list_del(cam->outqueue.next);
-		spin_unlock_irqrestore(&cam->queue_lock, lock_flags);
-
-		f->state = F_UNUSED;
-
-		memcpy(&b, &f->buf, sizeof(b));
-		if (f->vma_use_count)
-			b.flags |= V4L2_BUF_FLAG_MAPPED;
-
-		if (copy_to_user(arg, &b, sizeof(b)))
-			return -EFAULT;
-
-		PDBGG("Frame #%lu dequeued", (unsigned long)f->buf.index)
-
-		return 0;
-	}
-
-	case VIDIOC_STREAMON:
-	{
-		int type;
-
-		if (copy_from_user(&type, arg, sizeof(type)))
-			return -EFAULT;
-
-		if (type != V4L2_BUF_TYPE_VIDEO_CAPTURE || cam->io != IO_MMAP)
-			return -EINVAL;
-
-		if (list_empty(&cam->inqueue))
-			return -EINVAL;
-
-		cam->stream = STREAM_ON;
-
-		DBG(3, "Stream on")
-
-		return 0;
-	}
-
-	case VIDIOC_STREAMOFF:
-	{
-		int type, err;
-
-		if (copy_from_user(&type, arg, sizeof(type)))
-			return -EFAULT;
-
-		if (type != V4L2_BUF_TYPE_VIDEO_CAPTURE || cam->io != IO_MMAP)
-			return -EINVAL;
-
-		if (cam->stream == STREAM_ON) {
-			cam->stream = STREAM_INTERRUPT;
-			err = wait_event_interruptible
-			      ( cam->wait_stream, 
-			        (cam->stream == STREAM_OFF) ||
-			        (cam->state & DEV_DISCONNECTED) );
-			if (err) {
-				cam->state |= DEV_MISCONFIGURED;
-				DBG(1, "The camera is misconfigured. To use "
-				       "it, close and open /dev/video%d "
-				       "again.", cam->v4ldev->minor)
-				return err;
-			}
-			if (cam->state & DEV_DISCONNECTED)
-				return -ENODEV;
-		}
-
-		sn9c102_empty_framequeues(cam);
-
-		DBG(3, "Stream off")
-
-		return 0;
-	}
-
-	case VIDIOC_G_STD:
-	case VIDIOC_S_STD:
-	case VIDIOC_QUERYSTD:
-	case VIDIOC_ENUMSTD:
-	case VIDIOC_QUERYMENU:
-	case VIDIOC_G_PARM:
-	case VIDIOC_S_PARM:
-		return -EINVAL;
-
-	default:
-		return -EINVAL;
-
-	}
-}
-
-
-static int sn9c102_ioctl(struct inode* inode, struct file* filp,
-                         unsigned int cmd, unsigned long arg)
-{
-	struct sn9c102_device* cam = video_get_drvdata(video_devdata(filp));
-	int err = 0;
-
-	if (down_interruptible(&cam->fileop_sem))
-		return -ERESTARTSYS;
-
-	if (cam->state & DEV_DISCONNECTED) {
-		DBG(1, "Device not present")
-		up(&cam->fileop_sem);
-		return -ENODEV;
-	}
-
-	if (cam->state & DEV_MISCONFIGURED) {
-		DBG(1, "The camera is misconfigured. Close and open it again.")
-		up(&cam->fileop_sem);
-		return -EIO;
-	}
-
-	err = sn9c102_v4l2_ioctl(inode, filp, cmd, (void __user *)arg);
-
-	up(&cam->fileop_sem);
-
-	return err;
-}
-
-
-static struct file_operations sn9c102_fops = {
-	.owner =   THIS_MODULE,
-	.open =    sn9c102_open,
-	.release = sn9c102_release,
-	.ioctl =   sn9c102_ioctl,
-	.read =    sn9c102_read,
-	.poll =    sn9c102_poll,
-	.mmap =    sn9c102_mmap,
-	.llseek =  no_llseek,
-};
-
-/*****************************************************************************/
-
-/* It exists a single interface only. We do not need to validate anything. */
-static int
-sn9c102_usb_probe(struct usb_interface* intf, const struct usb_device_id* id)
-{
-	struct usb_device *udev = interface_to_usbdev(intf);
-	struct sn9c102_device* cam;
-	static unsigned int dev_nr = 0;
-	unsigned int i, n;
-	int err = 0, r;
-
-	n = sizeof(sn9c102_id_table)/sizeof(sn9c102_id_table[0]);
-	for (i = 0; i < n-1; i++)
-		if (udev->descriptor.idVendor==sn9c102_id_table[i].idVendor &&
-		    udev->descriptor.idProduct==sn9c102_id_table[i].idProduct)
-			break;
-	if (i == n-1)
-		return -ENODEV;
-
-	if (!(cam = kmalloc(sizeof(struct sn9c102_device), GFP_KERNEL)))
-		return -ENOMEM;
-	memset(cam, 0, sizeof(*cam));
-
-	cam->usbdev = udev;
-
-	memcpy(&cam->dev, &udev->dev, sizeof(struct device));
-
-	if (!(cam->control_buffer = kmalloc(8, GFP_KERNEL))) {
-		DBG(1, "kmalloc() failed")
-		err = -ENOMEM;
-		goto fail;
-	}
-	memset(cam->control_buffer, 0, 8);
-
-	if (!(cam->v4ldev = video_device_alloc())) {
-		DBG(1, "video_device_alloc() failed")
-		err = -ENOMEM;
-		goto fail;
-	}
-
-	init_MUTEX(&cam->dev_sem);
-
-	r = sn9c102_read_reg(cam, 0x00);
-	if (r < 0 || r != 0x10) {
-		DBG(1, "Sorry, this is not a SN9C10[12] based camera "
-		       "(vid/pid 0x%04X/0x%04X)",
-		    sn9c102_id_table[i].idVendor,sn9c102_id_table[i].idProduct)
-		err = -ENODEV;
-		goto fail;
-	}
-
-	DBG(2, "SN9C10[12] PC Camera Controller detected "
-	       "(vid/pid 0x%04X/0x%04X)",
-	    sn9c102_id_table[i].idVendor, sn9c102_id_table[i].idProduct)
-
-	for  (i = 0; sn9c102_sensor_table[i]; i++) {
-		err = sn9c102_sensor_table[i](cam);
-		if (!err)
-			break;
-	}
-
-	if (!err && cam->sensor) {
-		DBG(2, "%s image sensor detected", cam->sensor->name)
-		DBG(3, "Support for %s maintained by %s",
-		    cam->sensor->name, cam->sensor->maintainer)
-	} else {
-		DBG(1, "No supported image sensor detected")
-		err = -ENODEV;
-		goto fail;
-	}
-
-	if (sn9c102_init(cam)) {
-		DBG(1, "Initialization failed. I will retry on open().")
-		cam->state |= DEV_MISCONFIGURED;
-	}
-
-	strcpy(cam->v4ldev->name, "SN9C10[12] PC Camera");
-	cam->v4ldev->owner = THIS_MODULE;
-	cam->v4ldev->type = VID_TYPE_CAPTURE | VID_TYPE_SCALES;
-	cam->v4ldev->hardware = VID_HARDWARE_SN9C102;
-	cam->v4ldev->fops = &sn9c102_fops;
-	cam->v4ldev->minor = video_nr[dev_nr];
-	cam->v4ldev->release = video_device_release;
-	video_set_drvdata(cam->v4ldev, cam);
-
-	down(&cam->dev_sem);
-
-	err = video_register_device(cam->v4ldev, VFL_TYPE_GRABBER,
-	                            video_nr[dev_nr]);
-	if (err) {
-		DBG(1, "V4L2 device registration failed")
-		if (err == -ENFILE && video_nr[dev_nr] == -1)
-			DBG(1, "Free /dev/videoX node not found")
-		video_nr[dev_nr] = -1;
-		dev_nr = (dev_nr < SN9C102_MAX_DEVICES-1) ? dev_nr+1 : 0;
-		up(&cam->dev_sem);
-		goto fail;
-	}
-
-	DBG(2, "V4L2 device registered as /dev/video%d", cam->v4ldev->minor)
-
-	sn9c102_create_sysfs(cam);
-
-	usb_set_intfdata(intf, cam);
-
-	up(&cam->dev_sem);
-
-	return 0;
-
-fail:
-	if (cam) {
-		kfree(cam->control_buffer);
-		if (cam->v4ldev)
-			video_device_release(cam->v4ldev);
-		kfree(cam);
-	}
-	return err;
-}
-
-
-static void sn9c102_usb_disconnect(struct usb_interface* intf)
-{
-	struct sn9c102_device* cam = usb_get_intfdata(intf);
-
-	if (!cam)
-		return;
-
-	down_write(&sn9c102_disconnect);
-
-	down(&cam->dev_sem); 
-
-	DBG(2, "Disconnecting %s...", cam->v4ldev->name)
-
-	wake_up_interruptible_all(&cam->open);
-
-	if (cam->users) {
-		DBG(2, "Device /dev/video%d is open! Deregistration and "
-		       "memory deallocation are deferred on close.",
-		    cam->v4ldev->minor)
-		cam->state |= DEV_MISCONFIGURED;
-		sn9c102_stop_transfer(cam);
-		cam->state |= DEV_DISCONNECTED;
-		wake_up_interruptible(&cam->wait_frame);
-		wake_up_interruptible(&cam->wait_stream);
-	} else {
-		cam->state |= DEV_DISCONNECTED;
-		sn9c102_release_resources(cam);
-	}
-
-	up(&cam->dev_sem);
-
-	if (!cam->users)
-		kfree(cam);
-
-	up_write(&sn9c102_disconnect);
-}
-
-
-static struct usb_driver sn9c102_usb_driver = {
-	.owner =      THIS_MODULE,
-	.name =       "sn9c102",
-	.id_table =   sn9c102_id_table,
-	.probe =      sn9c102_usb_probe,
-	.disconnect = sn9c102_usb_disconnect,
-};
-
-/*****************************************************************************/
-
-static int __init sn9c102_module_init(void)
-{
-	int err = 0;
-
-	KDBG(2, SN9C102_MODULE_NAME " v" SN9C102_MODULE_VERSION)
-	KDBG(3, SN9C102_MODULE_AUTHOR)
-
-	if ((err = usb_register(&sn9c102_usb_driver)))
-		KDBG(1, "usb_register() failed")
-
-	return err;
-}
-
-
-static void __exit sn9c102_module_exit(void)
-{
-	usb_deregister(&sn9c102_usb_driver);
-}
-
-
-module_init(sn9c102_module_init);
-module_exit(sn9c102_module_exit);
diff -Naur linuxppc-2.6.9/drivers/usb/media/sn9c102.h linuxppc-2.6.9-dream/drivers/usb/media/sn9c102.h
--- linuxppc-2.6.9/drivers/usb/media/sn9c102.h	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/sn9c102.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,183 +0,0 @@
-/***************************************************************************
- * V4L2 driver for SN9C10[12] PC Camera Controllers                        *
- *                                                                         *
- * Copyright (C) 2004 by Luca Risolia <luca.risolia@studio.unibo.it>       *
- *                                                                         *
- * This program is free software; you can redistribute it and/or modify    *
- * it under the terms of the GNU General Public License as published by    *
- * the Free Software Foundation; either version 2 of the License, or       *
- * (at your option) any later version.                                     *
- *                                                                         *
- * This program is distributed in the hope that it will be useful,         *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
- * GNU General Public License for more details.                            *
- *                                                                         *
- * You should have received a copy of the GNU General Public License       *
- * along with this program; if not, write to the Free Software             *
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
- ***************************************************************************/
-
-#ifndef _SN9C102_H_
-#define _SN9C102_H_
-
-#include <linux/version.h>
-#include <linux/usb.h>
-#include <linux/videodev.h>
-#include <linux/device.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/wait.h>
-#include <linux/types.h>
-#include <linux/param.h>
-#include <linux/rwsem.h>
-#include <asm/semaphore.h>
-
-#include "sn9c102_sensor.h"
-
-/*****************************************************************************/
-
-#define SN9C102_DEBUG
-#define SN9C102_DEBUG_LEVEL       2
-#define SN9C102_MAX_DEVICES       64
-#define SN9C102_PRESERVE_IMGSCALE 0
-#define SN9C102_MAX_FRAMES        32
-#define SN9C102_URBS              2
-#define SN9C102_ISO_PACKETS       7
-#define SN9C102_ALTERNATE_SETTING 8
-#define SN9C102_CTRL_TIMEOUT      10*HZ
-
-/*****************************************************************************/
-
-#define SN9C102_MODULE_NAME  "V4L2 driver for SN9C10[12] PC Camera Controllers"
-#define SN9C102_MODULE_AUTHOR   "(C) 2004 Luca Risolia"
-#define SN9C102_AUTHOR_EMAIL    "<luca.risolia@studio.unibo.it>"
-#define SN9C102_MODULE_LICENSE  "GPL"
-#define SN9C102_MODULE_VERSION  "1:1.08"
-#define SN9C102_MODULE_VERSION_CODE  KERNEL_VERSION(1, 0, 8)
-
-SN9C102_ID_TABLE;
-SN9C102_SENSOR_TABLE;
-
-enum sn9c102_frame_state {
-	F_UNUSED,
-	F_QUEUED,
-	F_GRABBING,
-	F_DONE,
-	F_ERROR,
-};
-
-struct sn9c102_frame_t {
-	void* bufmem;
-	struct v4l2_buffer buf;
-	enum sn9c102_frame_state state;
-	struct list_head frame;
-	unsigned long vma_use_count;
-};
-
-enum sn9c102_dev_state {
-	DEV_INITIALIZED = 0x01,
-	DEV_DISCONNECTED = 0x02,
-	DEV_MISCONFIGURED = 0x04,
-};
-
-enum sn9c102_io_method {
-	IO_NONE,
-	IO_READ,
-	IO_MMAP,
-};
-
-enum sn9c102_stream_state {
-	STREAM_OFF,
-	STREAM_INTERRUPT,
-	STREAM_ON,
-};
-
-struct sn9c102_sysfs_attr {
-	u8 reg, val, i2c_reg, i2c_val;
-};
-
-static DECLARE_MUTEX(sn9c102_sysfs_lock);
-static DECLARE_RWSEM(sn9c102_disconnect);
-
-struct sn9c102_device {
-	struct device dev;
-
-	struct video_device* v4ldev;
-
-	struct sn9c102_sensor* sensor;
-
-	struct usb_device* usbdev;
-	struct urb* urb[SN9C102_URBS];
-	void* transfer_buffer[SN9C102_URBS];
-	u8* control_buffer;
-
-	struct sn9c102_frame_t *frame_current, frame[SN9C102_MAX_FRAMES];
-	struct list_head inqueue, outqueue;
-	u32 frame_count, nbuffers;
-
-	enum sn9c102_io_method io;
-	enum sn9c102_stream_state stream;
-
-	struct sn9c102_sysfs_attr sysfs;
-	u16 reg[32];
-
-	enum sn9c102_dev_state state;
-	u8 users;
-
-	struct semaphore dev_sem, fileop_sem;
-	spinlock_t queue_lock;
-	wait_queue_head_t open, wait_frame, wait_stream;
-};
-
-/*****************************************************************************/
-
-void
-sn9c102_attach_sensor(struct sn9c102_device* cam,
-                      struct sn9c102_sensor* sensor)
-{
-	cam->sensor = sensor;
-	cam->sensor->dev = &cam->dev;
-	cam->sensor->usbdev = cam->usbdev;
-}
-
-/*****************************************************************************/
-
-#undef DBG
-#undef KDBG
-#ifdef SN9C102_DEBUG
-#	define DBG(level, fmt, args...)                                       \
-{                                                                             \
-	if (debug >= (level)) {                                               \
-		if ((level) == 1)                                             \
-			dev_err(&cam->dev, fmt "\n", ## args);                \
-		else if ((level) == 2)                                        \
-			dev_info(&cam->dev, fmt "\n", ## args);               \
-		else if ((level) >= 3)                                        \
-			dev_info(&cam->dev, "[%s:%d] " fmt "\n",              \
-			         __FUNCTION__, __LINE__ , ## args);           \
-	}                                                                     \
-}
-#	define KDBG(level, fmt, args...)                                      \
-{                                                                             \
-	if (debug >= (level)) {                                               \
-		if ((level) == 1 || (level) == 2)                             \
-			pr_info("sn9c102: " fmt "\n", ## args);               \
-		else if ((level) == 3)                                        \
-			pr_debug("sn9c102: [%s:%d] " fmt "\n", __FUNCTION__,  \
-			         __LINE__ , ## args);                         \
-	}                                                                     \
-}
-#else
-#	define KDBG(level, fmt, args...) do {;} while(0);
-#	define DBG(level, fmt, args...) do {;} while(0);
-#endif
-
-#undef PDBG
-#define PDBG(fmt, args...)                                                    \
-dev_info(&cam->dev, "[%s:%d] " fmt "\n", __FUNCTION__, __LINE__ , ## args);
-
-#undef PDBGG
-#define PDBGG(fmt, args...) do {;} while(0); /* placeholder */
-
-#endif /* _SN9C102_H_ */
diff -Naur linuxppc-2.6.9/drivers/usb/media/sn9c102_pas106b.c linuxppc-2.6.9-dream/drivers/usb/media/sn9c102_pas106b.c
--- linuxppc-2.6.9/drivers/usb/media/sn9c102_pas106b.c	2004-10-18 23:53:13.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/sn9c102_pas106b.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,255 +0,0 @@
-/***************************************************************************
- * Driver for PAS106B image sensor connected to the SN9C10[12] PC Camera   *
- * Controllers                                                             *
- *                                                                         *
- * Copyright (C) 2004 by Luca Risolia <luca.risolia@studio.unibo.it>       *
- *                                                                         *
- * This program is free software; you can redistribute it and/or modify    *
- * it under the terms of the GNU General Public License as published by    *
- * the Free Software Foundation; either version 2 of the License, or       *
- * (at your option) any later version.                                     *
- *                                                                         *
- * This program is distributed in the hope that it will be useful,         *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
- * GNU General Public License for more details.                            *
- *                                                                         *
- * You should have received a copy of the GNU General Public License       *
- * along with this program; if not, write to the Free Software             *
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
- ***************************************************************************/
-
-#include <linux/delay.h>
-#include "sn9c102_sensor.h"
-
-
-static struct sn9c102_sensor pas106b;
-
-
-static int pas106b_init(struct sn9c102_device* cam)
-{
-	int err = 0;
-
-	err += sn9c102_write_reg(cam, 0x00, 0x10);
-	err += sn9c102_write_reg(cam, 0x00, 0x11);
-	err += sn9c102_write_reg(cam, 0x00, 0x14);
-	err += sn9c102_write_reg(cam, 0x20, 0x17);
-	err += sn9c102_write_reg(cam, 0x20, 0x19);
-	err += sn9c102_write_reg(cam, 0x09, 0x18);
-
-	err += sn9c102_i2c_write(cam, 0x02, 0x0c);
-	err += sn9c102_i2c_write(cam, 0x03, 0x12);
-	err += sn9c102_i2c_write(cam, 0x04, 0x05);
-	err += sn9c102_i2c_write(cam, 0x05, 0x5a);
-	err += sn9c102_i2c_write(cam, 0x06, 0x88);
-	err += sn9c102_i2c_write(cam, 0x07, 0x80);
-	err += sn9c102_i2c_write(cam, 0x08, 0x01);
-	err += sn9c102_i2c_write(cam, 0x0a, 0x01);
-	err += sn9c102_i2c_write(cam, 0x0b, 0x00);
-	err += sn9c102_i2c_write(cam, 0x10, 0x06);
-	err += sn9c102_i2c_write(cam, 0x11, 0x06);
-	err += sn9c102_i2c_write(cam, 0x12, 0x00);
-	err += sn9c102_i2c_write(cam, 0x14, 0x02);
-	err += sn9c102_i2c_write(cam, 0x13, 0x01);
-
-	msleep(400);
-
-	return err;
-}
-
-
-static int pas106b_get_ctrl(struct sn9c102_device* cam, 
-                            struct v4l2_control* ctrl)
-{
-	switch (ctrl->id) {
-	case V4L2_CID_RED_BALANCE:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x0c)) < 0)
-			return -EIO;
-		ctrl->value &= 0x1f;
-		return 0;
-	case V4L2_CID_BLUE_BALANCE:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x09)) < 0)
-			return -EIO;
-		ctrl->value &= 0x1f;
-		return 0;
-	case V4L2_CID_GAIN:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x0e)) < 0)
-			return -EIO;
-		ctrl->value &= 0x1f;
-		return 0;
-	case V4L2_CID_BRIGHTNESS:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x0d)) < 0)
-			return -EIO;
-		ctrl->value &= 0x1f;
-		return 0;
-	case V4L2_CID_CONTRAST:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x0f)) < 0)
-			return -EIO;
-		ctrl->value &= 0x07;
-		return 0;
-	default:
-		return -EINVAL;
-	}
-}
-
-
-static int pas106b_set_ctrl(struct sn9c102_device* cam, 
-                            const struct v4l2_control* ctrl)
-{
-	int err = 0;
-
-	switch (ctrl->id) {
-	case V4L2_CID_RED_BALANCE:
-		err += sn9c102_i2c_write(cam, 0x0c, ctrl->value & 0x1f);
-		break;
-	case V4L2_CID_BLUE_BALANCE:
-		err += sn9c102_i2c_write(cam, 0x09, ctrl->value & 0x1f);
-		break;
-	case V4L2_CID_GAIN:
-		err += sn9c102_i2c_write(cam, 0x0e, ctrl->value & 0x1f);
-		break;
-	case V4L2_CID_BRIGHTNESS:
-		err += sn9c102_i2c_write(cam, 0x0d, 0x1f-(ctrl->value & 0x1f));
-		break;
-	case V4L2_CID_CONTRAST:
-		err += sn9c102_i2c_write(cam, 0x0f, ctrl->value & 0x03);
-		break;
-	default:
-		return -EINVAL;
-	}
-	err += sn9c102_i2c_write(cam, 0x13, 0x01);
-
-	return err;
-}
-
-
-static int pas106b_set_crop(struct sn9c102_device* cam, 
-                            const struct v4l2_rect* rect)
-{
-	struct sn9c102_sensor* s = &pas106b;
-	int err = 0;
-	u8 h_start = (u8)(rect->left - s->cropcap.bounds.left) + 4,
-	   v_start = (u8)(rect->top - s->cropcap.bounds.top) + 3;
-
-	err += sn9c102_write_reg(cam, h_start, 0x12);
-	err += sn9c102_write_reg(cam, v_start, 0x13);
-
-	return err;
-}
-
-
-static struct sn9c102_sensor pas106b = {
-	.name = "PAS106B",
-	.maintainer = "Luca Risolia <luca.risolia@studio.unibo.it>",
-	.frequency = SN9C102_I2C_400KHZ | SN9C102_I2C_100KHZ,
-	.interface = SN9C102_I2C_2WIRES,
-	.slave_read_id = 0x40,
-	.slave_write_id = 0x40,
-	.init = &pas106b_init,
-	.qctrl = {
-		{
-			.id = V4L2_CID_RED_BALANCE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "red balance",
-			.minimum = 0x00,
-			.maximum = 0x1f,
-			.step = 0x01,
-			.default_value = 0x04,
-			.flags = 0,
-		},
-		{
-			.id = V4L2_CID_BLUE_BALANCE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "blue balance",
-			.minimum = 0x00,
-			.maximum = 0x1f,
-			.step = 0x01,
-			.default_value = 0x06,
-			.flags = 0,
-		},
-		{
-			.id = V4L2_CID_GAIN,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "global gain",
-			.minimum = 0x00,
-			.maximum = 0x1f,
-			.step = 0x01,
-			.default_value = 0x0d,
-			.flags = 0,
-		},
-		{
-			.id = V4L2_CID_BRIGHTNESS,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "brightness",
-			.minimum = 0x00,
-			.maximum = 0x1f,
-			.step = 0x01,
-			.default_value = 0x1f,
-			.flags = 0,
-		},
-		{
-			.id = V4L2_CID_CONTRAST,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "contrast",
-			.minimum = 0x00,
-			.maximum = 0x07,
-			.step = 0x01,
-			.default_value = 0x00, /* 0x00~0x03 have same effect */
-			.flags = 0,
-		},
-	},
-	.get_ctrl = &pas106b_get_ctrl,
-	.set_ctrl = &pas106b_set_ctrl,
-	.cropcap = {
-		.bounds = {
-			.left = 0,
-			.top = 0,
-			.width = 352,
-			.height = 288,
-		},
-		.defrect = {
-			.left = 0,
-			.top = 0,
-			.width = 352,
-			.height = 288,
-		},
-	},
-	.set_crop = &pas106b_set_crop,
-	.pix_format = {
-		.width = 352,
-		.height = 288,
-		.pixelformat = V4L2_PIX_FMT_SBGGR8,
-		.priv = 8, /* we use this field as 'bits per pixel' */
-	}
-};
-
-
-int sn9c102_probe_pas106b(struct sn9c102_device* cam)
-{
-	int r0 = 0, r1 = 0, err = 0;
-	unsigned int pid = 0;
-
-	/*
-	   Minimal initialization to enable the I2C communication
-	   NOTE: do NOT change the values!
-	*/
-	err += sn9c102_write_reg(cam, 0x01, 0x01); /* sensor power down */
-	err += sn9c102_write_reg(cam, 0x00, 0x01); /* sensor power on */
-	err += sn9c102_write_reg(cam, 0x28, 0x17); /* sensor clock at 24 MHz */
-	if (err)
-		return -EIO;
-
-	r0 = sn9c102_i2c_try_read(cam, &pas106b, 0x00);
-	r1 = sn9c102_i2c_try_read(cam, &pas106b, 0x01);
-
-	if (r0 < 0 || r1 < 0)
-		return -EIO;
-
-	pid = (r0 << 11) | ((r1 & 0xf0) >> 4);
-	if (pid != 0x007)
-		return -ENODEV;
-
-	sn9c102_attach_sensor(cam, &pas106b);
-
-	return 0;
-}
diff -Naur linuxppc-2.6.9/drivers/usb/media/sn9c102_pas202bcb.c linuxppc-2.6.9-dream/drivers/usb/media/sn9c102_pas202bcb.c
--- linuxppc-2.6.9/drivers/usb/media/sn9c102_pas202bcb.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/sn9c102_pas202bcb.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,238 +0,0 @@
-/***************************************************************************
- * Driver for PAS202BCB image sensor connected to the SN9C10[12] PC Camera *
- * Controllers                                                             *
- *                                                                         *
- * Copyright (C) 2004 by Carlos Eduardo Medaglia Dyonisio                  *
- *                       <medaglia@undl.org.br>                            *
- *                       http://cadu.homelinux.com:8080/                   *
- *                                                                         *
- * This program is free software; you can redistribute it and/or modify    *
- * it under the terms of the GNU General Public License as published by    *
- * the Free Software Foundation; either version 2 of the License, or       *
- * (at your option) any later version.                                     *
- *                                                                         *
- * This program is distributed in the hope that it will be useful,         *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
- * GNU General Public License for more details.                            *
- *                                                                         *
- * You should have received a copy of the GNU General Public License       *
- * along with this program; if not, write to the Free Software             *
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
- ***************************************************************************/
-
-#include <linux/delay.h>
-#include "sn9c102_sensor.h"
-
-
-static struct sn9c102_sensor pas202bcb;
-
-
-static int pas202bcb_init(struct sn9c102_device* cam)
-{
-	int err = 0;
-
-	err += sn9c102_write_reg(cam, 0x00, 0x10);
-	err += sn9c102_write_reg(cam, 0x00, 0x11);
-	err += sn9c102_write_reg(cam, 0x00, 0x14);
-	err += sn9c102_write_reg(cam, 0x20, 0x17);
-	err += sn9c102_write_reg(cam, 0x20, 0x19);
-	err += sn9c102_write_reg(cam, 0x09, 0x18);
-
-	err += sn9c102_i2c_write(cam, 0x02, 0x0c);
-	err += sn9c102_i2c_write(cam, 0x03, 0x40);
-	err += sn9c102_i2c_write(cam, 0x04, 0x07);
-	err += sn9c102_i2c_write(cam, 0x05, 0x25);
-	err += sn9c102_i2c_write(cam, 0x0d, 0x2c);
-	err += sn9c102_i2c_write(cam, 0x0e, 0x01);
-	err += sn9c102_i2c_write(cam, 0x0f, 0xa9);
-	err += sn9c102_i2c_write(cam, 0x08, 0x01);
-	err += sn9c102_i2c_write(cam, 0x0b, 0x01);
-	err += sn9c102_i2c_write(cam, 0x13, 0x63);
-	err += sn9c102_i2c_write(cam, 0x15, 0x70);
-	err += sn9c102_i2c_write(cam, 0x11, 0x01);
-
-	msleep(400);
-
-	return err;
-}
-
-
-static int pas202bcb_get_ctrl(struct sn9c102_device* cam, 
-                              struct v4l2_control* ctrl)
-{
-	switch (ctrl->id) {
-	case V4L2_CID_RED_BALANCE:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x09)) < 0)
-			return -EIO;
-		ctrl->value &= 0x0f;
-		return 0;
-	case V4L2_CID_BLUE_BALANCE:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x07)) < 0)
-			return -EIO;
-		ctrl->value &= 0x0f;
-		return 0;
-	case V4L2_CID_GAIN:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x10)) < 0)
-			return -EIO;
-		ctrl->value &= 0x1f;
-		return 0;
-	case V4L2_CID_BRIGHTNESS:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x06)) < 0)
-			return -EIO;
-		ctrl->value &= 0x0f;
-		return 0;
-	default:
-		return -EINVAL;
-	}
-}
-
-
-static int pas202bcb_set_ctrl(struct sn9c102_device* cam, 
-                              const struct v4l2_control* ctrl)
-{
-	int err = 0;
-
-	switch (ctrl->id) {
-	case V4L2_CID_RED_BALANCE:
-		err += sn9c102_i2c_write(cam, 0x09, ctrl->value & 0x0f);
-		break;
-	case V4L2_CID_BLUE_BALANCE:
-		err += sn9c102_i2c_write(cam, 0x07, ctrl->value & 0x0f);
-		break;
-	case V4L2_CID_GAIN:
-		err += sn9c102_i2c_write(cam, 0x10, ctrl->value & 0x1f);
-		break;
-	case V4L2_CID_BRIGHTNESS:
-		err += sn9c102_i2c_write(cam, 0x06, 0x0f-(ctrl->value & 0x0f));
-		break;
-	default:
-		return -EINVAL;
-	}
-	err += sn9c102_i2c_write(cam, 0x11, 0x01);
-
-	return err;
-}
-
-
-static int pas202bcb_set_crop(struct sn9c102_device* cam, 
-                              const struct v4l2_rect* rect)
-{
-	struct sn9c102_sensor* s = &pas202bcb;
-	int err = 0;
-	u8 h_start = (u8)(rect->left - s->cropcap.bounds.left) + 4,
-	   v_start = (u8)(rect->top - s->cropcap.bounds.top) + 3;
-
-	err += sn9c102_write_reg(cam, h_start, 0x12);
-	err += sn9c102_write_reg(cam, v_start, 0x13);
-
-	return err;
-}
-
-
-static struct sn9c102_sensor pas202bcb = {
-	.name = "PAS202BCB",
-	.maintainer = "Carlos Eduardo Medaglia Dyonisio "
-	              "<medaglia@undl.org.br>",
-	.frequency = SN9C102_I2C_400KHZ | SN9C102_I2C_100KHZ,
-	.interface = SN9C102_I2C_2WIRES,
-	.slave_read_id = 0x40,
-	.slave_write_id = 0x40,
-	.init = &pas202bcb_init,
-	.qctrl = {
-		{
-			.id = V4L2_CID_RED_BALANCE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "red balance",
-			.minimum = 0x00,
-			.maximum = 0x0f,
-			.step = 0x01,
-			.default_value = 0x01,
-			.flags = 0,
-		},
-		{
-			.id = V4L2_CID_BLUE_BALANCE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "blue balance",
-			.minimum = 0x00,
-			.maximum = 0x0f,
-			.step = 0x01,
-			.default_value = 0x05,
-			.flags = 0,
-		},
-		{
-			.id = V4L2_CID_GAIN,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "global gain",
-			.minimum = 0x00,
-			.maximum = 0x1f,
-			.step = 0x01,
-			.default_value = 0x0c,
-			.flags = 0,
-		},
-		{
-			.id = V4L2_CID_BRIGHTNESS,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "brightness",
-			.minimum = 0x00,
-			.maximum = 0x0f,
-			.step = 0x01,
-			.default_value = 0x0f,
-			.flags = 0,
-		},
-	},
-	.get_ctrl = &pas202bcb_get_ctrl,
-	.set_ctrl = &pas202bcb_set_ctrl,
-	.cropcap = {
-		.bounds = {
-			.left = 0,
-			.top = 0,
-			.width = 640,
-			.height = 480,
-		},
-		.defrect = {
-			.left = 0,
-			.top = 0,
-			.width = 640,
-			.height = 480,
-		},
-	},
-	.set_crop = &pas202bcb_set_crop,
-	.pix_format = {
-		.width = 640,
-		.height = 480,
-		.pixelformat = V4L2_PIX_FMT_SBGGR8,
-		.priv = 8,
-	}
-};
-
-
-int sn9c102_probe_pas202bcb(struct sn9c102_device* cam)
-{       
-	int r0 = 0, r1 = 0, err = 0;
-	unsigned int pid = 0;
-
-	/*
-	 *  Minimal initialization to enable the I2C communication
-	 *  NOTE: do NOT change the values!
-	 */
-	err += sn9c102_write_reg(cam, 0x01, 0x01); /* sensor power down */
-	err += sn9c102_write_reg(cam, 0x00, 0x01); /* sensor power on */
-	err += sn9c102_write_reg(cam, 0x28, 0x17); /* sensor clock at 24 MHz */
-	if (err)
-		return -EIO;
-
-	r0 = sn9c102_i2c_try_read(cam, &pas202bcb, 0x00);
-	r1 = sn9c102_i2c_try_read(cam, &pas202bcb, 0x01);
-	
-	if (r0 < 0 || r1 < 0)
-		return -EIO;
-
-	pid = (r0 << 4) | ((r1 & 0xf0) >> 4);
-	if (pid != 0x017)
-		return -ENODEV;
-
-	sn9c102_attach_sensor(cam, &pas202bcb);
-
-	return 0;
-}
diff -Naur linuxppc-2.6.9/drivers/usb/media/sn9c102_sensor.h linuxppc-2.6.9-dream/drivers/usb/media/sn9c102_sensor.h
--- linuxppc-2.6.9/drivers/usb/media/sn9c102_sensor.h	2004-10-18 23:53:44.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/sn9c102_sensor.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,307 +0,0 @@
-/***************************************************************************
- * API for image sensors connected to the SN9C10[12] PC Camera Controllers *
- *                                                                         *
- * Copyright (C) 2004 by Luca Risolia <luca.risolia@studio.unibo.it>       *
- *                                                                         *
- * This program is free software; you can redistribute it and/or modify    *
- * it under the terms of the GNU General Public License as published by    *
- * the Free Software Foundation; either version 2 of the License, or       *
- * (at your option) any later version.                                     *
- *                                                                         *
- * This program is distributed in the hope that it will be useful,         *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
- * GNU General Public License for more details.                            *
- *                                                                         *
- * You should have received a copy of the GNU General Public License       *
- * along with this program; if not, write to the Free Software             *
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
- ***************************************************************************/
-
-#ifndef _SN9C102_SENSOR_H_
-#define _SN9C102_SENSOR_H_
-
-#include <linux/usb.h>
-#include <linux/videodev.h>
-#include <linux/device.h>
-#include <linux/stddef.h>
-#include <linux/errno.h>
-#include <asm/types.h>
-
-struct sn9c102_device;
-struct sn9c102_sensor;
-
-/*****************************************************************************/
-
-/*
-   OVERVIEW.
-   This is a small interface that allows you to add support for any CCD/CMOS
-   image sensors connected to the SN9C10X bridges. The entire API is documented
-   below. In the most general case, to support a sensor there are three steps
-   you have to follow:
-   1) define the main "sn9c102_sensor" structure by setting the basic fields;
-   2) write a probing function to be called by the core module when the USB
-      camera is recognized, then add both the USB ids and the name of that
-      function to the two corresponding tables SENSOR_TABLE and ID_TABLE (see
-      below);
-   3) implement the methods that you want/need (and fill the rest of the main
-      structure accordingly).
-   "sn9c102_pas106b.c" is an example of all this stuff. Remember that you do
-   NOT need to touch the source code of the core module for the things to work
-   properly, unless you find bugs or flaws in it. Finally, do not forget to
-   read the V4L2 API for completeness.
-*/
-
-/*****************************************************************************/
-
-/*
-   Probing functions: on success, you must attach the sensor to the camera
-   by calling sn9c102_attach_sensor() provided below.
-   To enable the I2C communication, you might need to perform a really basic
-   initialization of the SN9C10X chip by using the write function declared 
-   ahead.
-   Functions must return 0 on success, the appropriate error otherwise.
-*/
-extern int sn9c102_probe_pas106b(struct sn9c102_device* cam);
-extern int sn9c102_probe_pas202bcb(struct sn9c102_device* cam);
-extern int sn9c102_probe_tas5110c1b(struct sn9c102_device* cam);
-extern int sn9c102_probe_tas5130d1b(struct sn9c102_device* cam);
-
-/*
-   Add the above entries to this table. Be sure to add the entry in the right
-   place, since, on failure, the next probing routine is called according to 
-   the order of the list below, from top to bottom.
-*/
-#define SN9C102_SENSOR_TABLE                                                  \
-static int (*sn9c102_sensor_table[])(struct sn9c102_device*) = {              \
-	&sn9c102_probe_pas106b, /* strong detection based on SENSOR ids */    \
-	&sn9c102_probe_pas202bcb, /* strong detection based on SENSOR ids */  \
-	&sn9c102_probe_tas5110c1b, /* detection based on USB pid/vid */       \
-	&sn9c102_probe_tas5130d1b, /* detection based on USB pid/vid */       \
-	NULL,                                                                 \
-};
-
-/* Attach a probed sensor to the camera. */
-extern void 
-sn9c102_attach_sensor(struct sn9c102_device* cam,
-                      struct sn9c102_sensor* sensor);
-
-/* Each SN9C10X camera has proper PID/VID identifiers. Add them here in case.*/
-#define SN9C102_ID_TABLE                                                      \
-static const struct usb_device_id sn9c102_id_table[] = {                      \
-	{ USB_DEVICE(0xc45, 0x6001), }, /* TAS5110C1B */                      \
-	{ USB_DEVICE(0xc45, 0x6005), }, /* TAS5110C1B */                      \
-	{ USB_DEVICE(0xc45, 0x6009), }, /* PAS106B */                         \
-	{ USB_DEVICE(0xc45, 0x600d), }, /* PAS106B */                         \
-	{ USB_DEVICE(0xc45, 0x6024), },                                       \
-	{ USB_DEVICE(0xc45, 0x6025), }, /* TAS5130D1B and TAS5110C1B */       \
-	{ USB_DEVICE(0xc45, 0x6028), }, /* PAS202BCB */                       \
-	{ USB_DEVICE(0xc45, 0x6029), }, /* PAS106B */                         \
-	{ USB_DEVICE(0xc45, 0x602a), }, /* HV7131[D|E1] */                    \
-	{ USB_DEVICE(0xc45, 0x602c), }, /* OV7620 */                          \
-	{ USB_DEVICE(0xc45, 0x6030), }, /* MI03 */                            \
-	{ }                                                                   \
-};
-
-/*****************************************************************************/
-
-/*
-   Read/write routines: they always return -1 on error, 0 or the read value
-   otherwise. NOTE that a real read operation is not supported by the SN9C10X
-   chip for some of its registers. To work around this problem, a pseudo-read
-   call is provided instead: it returns the last successfully written value 
-   on the register (0 if it has never been written), the usual -1 on error.
-*/
-
-/* The "try" I2C I/O versions are used when probing the sensor */
-extern int sn9c102_i2c_try_write(struct sn9c102_device*,struct sn9c102_sensor*,
-                                 u8 address, u8 value);
-extern int sn9c102_i2c_try_read(struct sn9c102_device*,struct sn9c102_sensor*,
-                                u8 address);
-
-/*
-   This must be used if and only if the sensor doesn't implement the standard
-   I2C protocol. There a number of good reasons why you must use the 
-   single-byte versions of this function: do not abuse. It writes n bytes, 
-   from data0 to datan, (registers 0x09 - 0x09+n of SN9C10X chip).
-*/
-extern int sn9c102_i2c_try_raw_write(struct sn9c102_device* cam,
-                                     struct sn9c102_sensor* sensor, u8 n, 
-                                     u8 data0, u8 data1, u8 data2, u8 data3,
-                                     u8 data4, u8 data5);
-
-/* To be used after the sensor struct has been attached to the camera struct */
-extern int sn9c102_i2c_write(struct sn9c102_device*, u8 address, u8 value);
-extern int sn9c102_i2c_read(struct sn9c102_device*, u8 address);
-
-/* I/O on registers in the bridge. Could be used by the sensor methods too */
-extern int sn9c102_write_reg(struct sn9c102_device*, u8 value, u16 index);
-extern int sn9c102_pread_reg(struct sn9c102_device*, u16 index);
-
-/*
-   NOTE: there are no debugging functions here. To uniform the output you must
-   use the dev_info()/dev_warn()/dev_err() macros defined in device.h, already
-   included here, the argument being the struct device 'dev' of the sensor
-   structure. Do NOT use these macros before the sensor is attached or the
-   kernel will crash! However you should not need to notify the user about
-   common errors or other messages, since this is done by the master module.
-*/
-
-/*****************************************************************************/
-
-enum sn9c102_i2c_frequency { /* sensors may support both the frequencies */
-	SN9C102_I2C_100KHZ = 0x01,
-	SN9C102_I2C_400KHZ = 0x02,
-};
-
-enum sn9c102_i2c_interface {
-	SN9C102_I2C_2WIRES,
-	SN9C102_I2C_3WIRES,
-};
-
-struct sn9c102_sensor {
-	char name[32], /* sensor name */
-	     maintainer[64]; /* name of the mantainer <email> */
-
-	/*
-	   These sensor capabilities must be provided if the SN9C10X controller
-	   needs to communicate through the sensor serial interface by using
-	   at least one of the i2c functions available.
-	*/
-	enum sn9c102_i2c_frequency frequency;
-	enum sn9c102_i2c_interface interface;
-
-	/*
-	   These identifiers must be provided if the image sensor implements
-	   the standard I2C protocol. TASC sensors don't, although they have a
-	   serial interface: so this is a case where the "raw" I2C version
-	   could be helpful.
-	*/
-	u8 slave_read_id, slave_write_id; /* reg. 0x09 */
-
-	/*
-	   NOTE: Where not noted,most of the functions below are not mandatory.
-	         Set to null if you do not implement them. If implemented,
-	         they must return 0 on success, the proper error otherwise.
-	*/
-
-	int (*init)(struct sn9c102_device* cam);
-	/*
-	   This function is called after the sensor has been attached. 
-	   It should be used to initialize the sensor only, but may also
-	   configure part of the SN9C10X chip if necessary. You don't need to
-	   setup picture settings like brightness, contrast, etc.. here, if
-	   the corrisponding controls are implemented (see below), since 
-	   they are adjusted in the core driver by calling the set_ctrl()
-	   method after init(), where the arguments are the default values
-	   specified in the v4l2_queryctrl list of supported controls;
-	   Same suggestions apply for other settings, _if_ the corresponding
-	   methods are present; if not, the initialization must configure the
-	   sensor according to the default configuration structures below.
-	*/
-
-	struct v4l2_queryctrl qctrl[V4L2_CID_LASTP1-V4L2_CID_BASE];
-	/*
-	   Optional list of default controls, defined as indicated in the 
-	   V4L2 API. Menu type controls are not handled by this interface.
-	*/
-
-	int (*get_ctrl)(struct sn9c102_device* cam, struct v4l2_control* ctrl);
-	int (*set_ctrl)(struct sn9c102_device* cam,
-	                const struct v4l2_control* ctrl);
-	/*
-	   You must implement at least the set_ctrl method if you have defined
-	   the list above. The returned value must follow the V4L2
-	   specifications for the VIDIOC_G|C_CTRL ioctls. V4L2_CID_H|VCENTER
-	   are not supported by this driver, so do not implement them. Also,
-	   passed values are NOT checked to see if they are out of bounds.
-	*/
-
-	struct v4l2_cropcap cropcap;
-	/*
-	   Think the image sensor as a grid of R,G,B monochromatic pixels
-	   disposed according to a particular Bayer pattern, which describes
-	   the complete array of pixels, from (0,0) to (xmax, ymax). We will
-	   use this coordinate system from now on. It is assumed the sensor
-	   chip can be programmed to capture/transmit a subsection of that
-	   array of pixels: we will call this subsection "active window".
-	   It is not always true that the largest achievable active window can
-	   cover the whole array of pixels. The V4L2 API defines another
-	   area called "source rectangle", which, in turn, is a subrectangle of
-	   the active window. The SN9C10X chip is always programmed to read the
-	   source rectangle.
-	   The bounds of both the active window and the source rectangle are
-	   specified in the cropcap substructures 'bounds' and 'defrect'.
-	   By default, the source rectangle should cover the largest possible
-	   area. Again, it is not always true that the largest source rectangle
-	   can cover the entire active window, although it is a rare case for 
-	   the hardware we have. The bounds of the source rectangle _must_ be
-	   multiple of 16 and must use the same coordinate system as indicated
-	   before; their centers shall align initially.
-	   If necessary, the sensor chip must be initialized during init() to
-	   set the bounds of the active sensor window; however, by default, it
-	   usually covers the largest achievable area (maxwidth x maxheight)
-	   of pixels, so no particular initialization is needed, if you have
-	   defined the correct default bounds in the structures.
-	   See the V4L2 API for further details.
-	   NOTE: once you have defined the bounds of the active window
-	         (struct cropcap.bounds) you must not change them.anymore.
-	   Only 'bounds' and 'defrect' fields are mandatory, other fields
-	   will be ignored.
-	*/
-
-	int (*set_crop)(struct sn9c102_device* cam,
-	                const struct v4l2_rect* rect);
-	/*
-	   To be called on VIDIOC_C_SETCROP. The core module always calls a
-	   default routine which configures the appropriate SN9C10X regs (also
-	   scaling), but you may need to override/adjust specific stuff.
-	   'rect' contains width and height values that are multiple of 16: in
-	   case you override the default function, you always have to program
-	   the chip to match those values; on error return the corresponding
-	   error code without rolling back.
-	   NOTE: in case, you must program the SN9C10X chip to get rid of 
-	         blank pixels or blank lines at the _start_ of each line or
-	         frame after each HSYNC or VSYNC, so that the image starts with
-	         real RGB data (see regs 0x12,0x13) (having set H_SIZE and,
-	         V_SIZE you don't have to care about blank pixels or blank
-	         lines at the end of each line or frame).
-	*/
-
-	struct v4l2_pix_format pix_format;
-	/*
-	   What you have to define here are: initial 'width' and 'height' of
-	   the target rectangle, the bayer 'pixelformat' and 'priv' which we'll
-	   be used to indicate the number of bits per pixel, 8 or 9. 
-	   Nothing more.
-	   NOTE 1: both 'width' and 'height' _must_ be either 1/1 or 1/2 or 1/4
-	           of cropcap.defrect.width and cropcap.defrect.height. I
-	           suggest 1/1.
-	   NOTE 2: as said above, you have to program the SN9C10X chip to get
-	           rid of any blank pixels, so that the output of the sensor
-	           matches the RGB bayer sequence (i.e. BGBGBG...GRGRGR).
-	*/
-
-	const struct device* dev;
-	/*
-	   This is the argument for dev_err(), dev_info() and dev_warn(). It
-	   is used for debugging purposes. You must not access the struct
-	   before the sensor is attached.
-	*/
-
-	const struct usb_device* usbdev;
-	/*
-	   Points to the usb_device struct after the sensor is attached.
-	   Do not touch unless you know what you are doing.
-	*/
-
-	/*
-	   Do NOT write to the data below, it's READ ONLY. It is used by the
-	   core module to store successfully updated values of the above
-	   settings, for rollbacks..etc..in case of errors during atomic I/O
-	*/
-	struct v4l2_queryctrl _qctrl[V4L2_CID_LASTP1-V4L2_CID_BASE];
-	struct v4l2_rect _rect;
-};
-
-#endif /* _SN9C102_SENSOR_H_ */
diff -Naur linuxppc-2.6.9/drivers/usb/media/sn9c102_tas5110c1b.c linuxppc-2.6.9-dream/drivers/usb/media/sn9c102_tas5110c1b.c
--- linuxppc-2.6.9/drivers/usb/media/sn9c102_tas5110c1b.c	2004-10-18 23:53:05.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/sn9c102_tas5110c1b.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,137 +0,0 @@
-/***************************************************************************
- * Driver for TAS5110C1B image sensor connected to the SN9C10[12] PC       *
- * Camera Controllers                                                      *
- *                                                                         *
- * Copyright (C) 2004 by Luca Risolia <luca.risolia@studio.unibo.it>       *
- *                                                                         *
- * This program is free software; you can redistribute it and/or modify    *
- * it under the terms of the GNU General Public License as published by    *
- * the Free Software Foundation; either version 2 of the License, or       *
- * (at your option) any later version.                                     *
- *                                                                         *
- * This program is distributed in the hope that it will be useful,         *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
- * GNU General Public License for more details.                            *
- *                                                                         *
- * You should have received a copy of the GNU General Public License       *
- * along with this program; if not, write to the Free Software             *
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
- ***************************************************************************/
-
-#include "sn9c102_sensor.h"
-
-
-static struct sn9c102_sensor tas5110c1b;
-
-
-static int tas5110c1b_init(struct sn9c102_device* cam)
-{
-	int err = 0;
-
-	err += sn9c102_write_reg(cam, 0x01, 0x01);
-	err += sn9c102_write_reg(cam, 0x44, 0x01);
-	err += sn9c102_write_reg(cam, 0x00, 0x10);
-	err += sn9c102_write_reg(cam, 0x00, 0x11);
-	err += sn9c102_write_reg(cam, 0x0a, 0x14);
-	err += sn9c102_write_reg(cam, 0x60, 0x17);
-	err += sn9c102_write_reg(cam, 0x06, 0x18);
-	err += sn9c102_write_reg(cam, 0xfb, 0x19);
-
-	err += sn9c102_i2c_try_raw_write(cam, &tas5110c1b, 4, 0x11, 0x00, 0xc0,
-	                                 0x80, 0, 0);
-
-	return err;
-}
-
-
-static int tas5110c1b_set_ctrl(struct sn9c102_device* cam, 
-                               const struct v4l2_control* ctrl)
-{
-	switch (ctrl->id) {
-	case V4L2_CID_GAIN:
-		return sn9c102_i2c_try_raw_write(cam, &tas5110c1b, 4, 0x11,
-		                                 0x02, 0x20,
-		                                 0xff - (ctrl->value & 0xff),
-		                                 0, 0);
-	default:
-		return -EINVAL;
-	}
-}
-
-
-static int tas5110c1b_set_crop(struct sn9c102_device* cam, 
-                               const struct v4l2_rect* rect)
-{
-	struct sn9c102_sensor* s = &tas5110c1b;
-	int err = 0;
-	u8 h_start = (u8)(rect->left - s->cropcap.bounds.left) + 69,
-	   v_start = (u8)(rect->top - s->cropcap.bounds.top) + 9;
-
-	err += sn9c102_write_reg(cam, h_start, 0x12);
-	err += sn9c102_write_reg(cam, v_start, 0x13);
-
-	/* Don't change ! */
-	err += sn9c102_write_reg(cam, 0x14, 0x1a);
-	err += sn9c102_write_reg(cam, 0x0a, 0x1b);
-	err += sn9c102_write_reg(cam, 0xfb, 0x19);
-
-	return err;
-}
-
-
-static struct sn9c102_sensor tas5110c1b = {
-	.name = "TAS5110C1B",
-	.maintainer = "Luca Risolia <luca.risolia@studio.unibo.it>",
-	.frequency = SN9C102_I2C_100KHZ,
-	.interface = SN9C102_I2C_3WIRES,
-	.init = &tas5110c1b_init,
-	.qctrl = {
-		{
-			.id = V4L2_CID_GAIN,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "global gain",
-			.minimum = 0x00,
-			.maximum = 0xff,
-			.step = 0x01,
-			.default_value = 0x48,
-			.flags = 0,
-		},
-	},
-	.set_ctrl = &tas5110c1b_set_ctrl,
-	.cropcap = {
-		.bounds = {
-			.left = 0,
-			.top = 0,
-			.width = 352,
-			.height = 288,
-		},
-		.defrect = {
-			.left = 0,
-			.top = 0,
-			.width = 352,
-			.height = 288,
-		},
-	},
-	.set_crop = &tas5110c1b_set_crop,
-	.pix_format = {
-		.width = 352,
-		.height = 288,
-		.pixelformat = V4L2_PIX_FMT_SBGGR8,
-		.priv = 8,
-	}
-};
-
-
-int sn9c102_probe_tas5110c1b(struct sn9c102_device* cam)
-{
-	/* This sensor has no identifiers, so let's attach it anyway */
-	sn9c102_attach_sensor(cam, &tas5110c1b);
-
-	/* At the moment, sensor detection is based on USB pid/vid */
-	if (tas5110c1b.usbdev->descriptor.idProduct != 0x6001 &&
-	    tas5110c1b.usbdev->descriptor.idProduct != 0x6005)
-		return -ENODEV;
-
-	return 0;
-}
diff -Naur linuxppc-2.6.9/drivers/usb/media/sn9c102_tas5130d1b.c linuxppc-2.6.9-dream/drivers/usb/media/sn9c102_tas5130d1b.c
--- linuxppc-2.6.9/drivers/usb/media/sn9c102_tas5130d1b.c	2004-10-18 23:54:31.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/sn9c102_tas5130d1b.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,136 +0,0 @@
-/***************************************************************************
- * Driver for TAS5130D1B image sensor connected to the SN9C10[12] PC       *
- * Camera Controllers                                                      *
- *                                                                         *
- * Copyright (C) 2004 by Luca Risolia <luca.risolia@studio.unibo.it>       *
- *                                                                         *
- * This program is free software; you can redistribute it and/or modify    *
- * it under the terms of the GNU General Public License as published by    *
- * the Free Software Foundation; either version 2 of the License, or       *
- * (at your option) any later version.                                     *
- *                                                                         *
- * This program is distributed in the hope that it will be useful,         *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
- * GNU General Public License for more details.                            *
- *                                                                         *
- * You should have received a copy of the GNU General Public License       *
- * along with this program; if not, write to the Free Software             *
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
- ***************************************************************************/
-
-#include "sn9c102_sensor.h"
-
-
-static struct sn9c102_sensor tas5130d1b;
-
-
-static int tas5130d1b_init(struct sn9c102_device* cam)
-{
-	int err = 0;
-
-	err += sn9c102_write_reg(cam, 0x01, 0x01);
-	err += sn9c102_write_reg(cam, 0x20, 0x17);
-	err += sn9c102_write_reg(cam, 0x04, 0x01);
-	err += sn9c102_write_reg(cam, 0x01, 0x10);
-	err += sn9c102_write_reg(cam, 0x00, 0x11);
-	err += sn9c102_write_reg(cam, 0x00, 0x14);
-	err += sn9c102_write_reg(cam, 0x60, 0x17);
-	err += sn9c102_write_reg(cam, 0x07, 0x18);
-
-	err += sn9c102_i2c_try_raw_write(cam, &tas5130d1b, 4, 0x11, 0x00, 0x40,
-	                                 0x47, 0, 0);
-
-	return err;
-}
-
-
-static int tas5130d1b_set_ctrl(struct sn9c102_device* cam, 
-                               const struct v4l2_control* ctrl)
-{
-	switch (ctrl->id) {
-	case V4L2_CID_GAIN:
-		return sn9c102_i2c_try_raw_write(cam, &tas5130d1b, 4, 0x11,
-		                                 0x02, 0x20,
-		                                 0xff - (ctrl->value & 0xff),
-		                                 0, 0);
-	default:
-		return -EINVAL;
-	}
-}
-
-
-static int tas5130d1b_set_crop(struct sn9c102_device* cam, 
-                               const struct v4l2_rect* rect)
-{
-	struct sn9c102_sensor* s = &tas5130d1b;
-	u8 h_start = (u8)(rect->left - s->cropcap.bounds.left) + 104,
-	   v_start = (u8)(rect->top - s->cropcap.bounds.top) + 12;
-	int err = 0;
-
-	err += sn9c102_write_reg(cam, h_start, 0x12);
-	err += sn9c102_write_reg(cam, v_start, 0x13);
-
-	/* Do NOT change! */
-	err += sn9c102_write_reg(cam, 0x1d, 0x1a);
-	err += sn9c102_write_reg(cam, 0x10, 0x1b);
-	err += sn9c102_write_reg(cam, 0xf3, 0x19);
-
-	return err;
-}
-
-
-static struct sn9c102_sensor tas5130d1b = {
-	.name = "TAS5130D1B",
-	.maintainer = "Luca Risolia <luca.risolia@studio.unibo.it>",
-	.frequency = SN9C102_I2C_100KHZ,
-	.interface = SN9C102_I2C_3WIRES,
-	.init = &tas5130d1b_init,
-	.qctrl = {
-		{
-			.id = V4L2_CID_GAIN,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "global gain",
-			.minimum = 0x00,
-			.maximum = 0xff,
-			.step = 0x01,
-			.default_value = 0x00,
-			.flags = 0,
-		},
-	},
-	.set_ctrl = &tas5130d1b_set_ctrl,
-	.cropcap = {
-		.bounds = {
-			.left = 0,
-			.top = 0,
-			.width = 640,
-			.height = 480,
-		},
-		.defrect = {
-			.left = 0,
-			.top = 0,
-			.width = 640,
-			.height = 480,
-		},
-	},
-	.set_crop = &tas5130d1b_set_crop,
-	.pix_format = {
-		.width = 640,
-		.height = 480,
-		.pixelformat = V4L2_PIX_FMT_SBGGR8,
-		.priv = 8,
-	}
-};
-
-
-int sn9c102_probe_tas5130d1b(struct sn9c102_device* cam)
-{
-	/* This sensor has no identifiers, so let's attach it anyway */
-	sn9c102_attach_sensor(cam, &tas5130d1b);
-
-	/* At the moment, sensor detection is based on USB pid/vid */
-	if (tas5130d1b.usbdev->descriptor.idProduct != 0x6025)
-		return -ENODEV;
-
-	return 0;
-}
diff -Naur linuxppc-2.6.9/drivers/usb/media/stv680.c linuxppc-2.6.9-dream/drivers/usb/media/stv680.c
--- linuxppc-2.6.9/drivers/usb/media/stv680.c	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/stv680.c	2005-09-19 21:40:05.000000000 +0200
@@ -93,11 +93,11 @@
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_DESCRIPTION (DRIVER_DESC);
 MODULE_LICENSE ("GPL");
-module_param(debug, int, S_IRUGO | S_IWUSR);
+MODULE_PARM (debug, "i");
 MODULE_PARM_DESC (debug, "Debug enabled or not");
-module_param(swapRGB_on, int, 0);
+MODULE_PARM (swapRGB_on, "i");
 MODULE_PARM_DESC (swapRGB_on, "Red/blue swap: 1=always, 0=auto, -1=never");
-module_param(video_nr, int, 0);
+MODULE_PARM (video_nr, "i");
 
 /********************************************************************
  *
@@ -704,6 +704,7 @@
 				   usb_rcvbulkpipe (stv680->udev, stv680->bulk_in_endpointAddr),
 				   stv680->sbuf[i].data, stv680->rawbufsize,
 				   stv680_video_irq, stv680);
+		urb->timeout = PENCAM_TIMEOUT * 2;
 		stv680->urb[i] = urb;
 		err = usb_submit_urb (stv680->urb[i], GFP_KERNEL);
 		if (err)
@@ -1308,7 +1309,7 @@
 	return 0;
 }
 
-static ssize_t stv680_read (struct file *file, char __user *buf,
+static ssize_t stv680_read (struct file *file, char *buf,
 			size_t count, loff_t *ppos)
 {
 	struct video_device *dev = file->private_data;
diff -Naur linuxppc-2.6.9/drivers/usb/media/ultracam.c linuxppc-2.6.9-dream/drivers/usb/media/ultracam.c
--- linuxppc-2.6.9/drivers/usb/media/ultracam.c	2004-10-18 23:53:26.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/ultracam.c	2005-09-19 21:40:05.000000000 +0200
@@ -60,9 +60,9 @@
 static int init_hue = 128;
 static int hue_correction = 128;
 
-module_param(debug, int, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug level: 0-9 (default=0)");
-module_param(flags, int, 0);
+MODULE_PARM(flags, "i");
 MODULE_PARM_DESC(flags,
 		"Bitfield: 0=VIDIOCSYNC, "
 		"1=B/W, "
@@ -71,18 +71,18 @@
 		"4=test pattern, "
 		"5=separate frames, "
 		"6=clean frames");
-module_param(framerate, int, 0);
+MODULE_PARM(framerate, "i");
 MODULE_PARM_DESC(framerate, "Framerate setting: 0=slowest, 6=fastest (default=2)");
 
-module_param(init_brightness, int, 0);
+MODULE_PARM(init_brightness, "i");
 MODULE_PARM_DESC(init_brightness, "Brightness preconfiguration: 0-255 (default=128)");
-module_param(init_contrast, int, 0);
+MODULE_PARM(init_contrast, "i");
 MODULE_PARM_DESC(init_contrast, "Contrast preconfiguration: 0-255 (default=192)");
-module_param(init_color, int, 0);
+MODULE_PARM(init_color, "i");
 MODULE_PARM_DESC(init_color, "Color preconfiguration: 0-255 (default=128)");
-module_param(init_hue, int, 0);
+MODULE_PARM(init_hue, "i");
 MODULE_PARM_DESC(init_hue, "Hue preconfiguration: 0-255 (default=128)");
-module_param(hue_correction, int, 0);
+MODULE_PARM(hue_correction, "i");
 MODULE_PARM_DESC(hue_correction, "YUV colorspace regulation: 0-255 (default=128)");
 
 /*
@@ -95,7 +95,7 @@
  * 02-Nov-2000 First (mostly dummy) version.
  * 06-Nov-2000 Rewrote to dump all data into frame.
  */
-static void ultracam_ProcessIsocData(struct uvd *uvd, struct usbvideo_frame *frame)
+void ultracam_ProcessIsocData(struct uvd *uvd, struct usbvideo_frame *frame)
 {
 	int n;
 
@@ -513,7 +513,7 @@
 {
 	struct usb_device *dev = interface_to_usbdev(intf);
 	struct uvd *uvd = NULL;
-	int ix, i, nas;
+	int i, nas;
 	int actInterface=-1, inactInterface=-1, maxPS=0;
 	unsigned char video_ep = 0;
 
@@ -540,12 +540,11 @@
 		return -ENODEV;
 	}
 	/* Validate all alternate settings */
-	for (ix=0; ix < nas; ix++) {
+	for (i=0; i < nas; i++) {
 		const struct usb_host_interface *interface;
 		const struct usb_endpoint_descriptor *endpoint;
 
-		interface = &intf->altsetting[ix];
-		i = interface->desc.bAlternateSetting;
+		interface = &intf->altsetting[i];
 		if (interface->desc.bNumEndpoints != 1) {
 			err("Interface %d. has %u. endpoints!",
 			    interface->desc.bInterfaceNumber,
diff -Naur linuxppc-2.6.9/drivers/usb/media/usbvideo.c linuxppc-2.6.9-dream/drivers/usb/media/usbvideo.c
--- linuxppc-2.6.9/drivers/usb/media/usbvideo.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/usbvideo.c	2005-09-19 21:40:05.000000000 +0200
@@ -34,7 +34,7 @@
 #endif
 
 static int video_nr = -1;
-module_param(video_nr, int, 0);
+MODULE_PARM(video_nr, "i");
 
 /*
  * Local prototypes.
@@ -46,7 +46,7 @@
 			      unsigned int cmd, unsigned long arg);
 static int usbvideo_v4l_mmap(struct file *file, struct vm_area_struct *vma);
 static int usbvideo_v4l_open(struct inode *inode, struct file *file);
-static ssize_t usbvideo_v4l_read(struct file *file, char __user *buf,
+static ssize_t usbvideo_v4l_read(struct file *file, char *buf,
 			     size_t count, loff_t *ppos);
 static int usbvideo_v4l_close(struct inode *inode, struct file *file);
 
@@ -1587,7 +1587,7 @@
  * 20-Oct-2000 Created.
  * 01-Nov-2000 Added mutex (uvd->lock).
  */
-static ssize_t usbvideo_v4l_read(struct file *file, char __user *buf,
+static ssize_t usbvideo_v4l_read(struct file *file, char *buf,
 		      size_t count, loff_t *ppos)
 {
 	struct uvd *uvd = file->private_data;
diff -Naur linuxppc-2.6.9/drivers/usb/media/vicam.c linuxppc-2.6.9-dream/drivers/usb/media/vicam.c
--- linuxppc-2.6.9/drivers/usb/media/vicam.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/vicam.c	2005-09-19 21:40:05.000000000 +0200
@@ -523,9 +523,9 @@
 }
 
 static int
-vicam_ioctl(struct inode *inode, struct file *file, unsigned int ioctlnr, unsigned long arg)
+vicam_ioctl(struct inode *inode, struct file *file, unsigned int ioctlnr, unsigned long ul_arg)
 {
-	void __user *user_arg = (void __user *)arg;
+	void *arg = (void *)ul_arg;
 	struct vicam_camera *cam = file->private_data;
 	int retval = 0;
 
@@ -549,7 +549,7 @@
 			b.minwidth = 320;	/* VIDEOSIZE_48_48 */
 			b.minheight = 240;
 
-			if (copy_to_user(user_arg, &b, sizeof(b)))
+			if (copy_to_user(arg, &b, sizeof (b)))
 				retval = -EFAULT;
 
 			break;
@@ -560,7 +560,7 @@
 			struct video_channel v;
 
 			DBG("VIDIOCGCHAN\n");
-			if (copy_from_user(&v, user_arg, sizeof(v))) {
+			if (copy_from_user(&v, arg, sizeof (v))) {
 				retval = -EFAULT;
 				break;
 			}
@@ -576,7 +576,7 @@
 			v.type = VIDEO_TYPE_CAMERA;
 			v.norm = 0;
 
-			if (copy_to_user(user_arg, &v, sizeof(v)))
+			if (copy_to_user(arg, &v, sizeof (v)))
 				retval = -EFAULT;
 			break;
 		}
@@ -585,7 +585,7 @@
 		{
 			int v;
 
-			if (copy_from_user(&v, user_arg, sizeof(v)))
+			if (copy_from_user(&v, arg, sizeof (v)))
 				retval = -EFAULT;
 			DBG("VIDIOCSCHAN %d\n", v);
 
@@ -604,27 +604,23 @@
 			vp.brightness = cam->gain << 8;
 			vp.depth = 24;
 			vp.palette = VIDEO_PALETTE_RGB24;
-			if (copy_to_user(user_arg, &vp, sizeof (struct video_picture)))
+			if (copy_to_user
+			    (arg, &vp, sizeof (struct video_picture)))
 				retval = -EFAULT;
 			break;
 		}
 
 	case VIDIOCSPICT:
 		{
-			struct video_picture vp;
-			
-			if (copy_from_user(&vp, user_arg, sizeof(vp))) {
-				retval = -EFAULT;
-				break;
-			}
-			
-			DBG("VIDIOCSPICT depth = %d, pal = %d\n", vp.depth,
-			    vp.palette);
+			struct video_picture *vp = (struct video_picture *) arg;
+
+			DBG("VIDIOCSPICT depth = %d, pal = %d\n", vp->depth,
+			    vp->palette);
 
-			cam->gain = vp.brightness >> 8;
+			cam->gain = vp->brightness >> 8;
 
-			if (vp.depth != 24
-			    || vp.palette != VIDEO_PALETTE_RGB24)
+			if (vp->depth != 24
+			    || vp->palette != VIDEO_PALETTE_RGB24)
 				retval = -EINVAL;
 
 			break;
@@ -645,7 +641,8 @@
 
 			DBG("VIDIOCGWIN\n");
 
-			if (copy_to_user(user_arg, (void *)&vw, sizeof(vw)))
+			if (copy_to_user
+			    ((void *) arg, (void *) &vw, sizeof (vw)))
 				retval = -EFAULT;
 
 			// I'm not sure what the deal with a capture window is, it is very poorly described
@@ -656,18 +653,12 @@
 	case VIDIOCSWIN:
 		{
 
-			struct video_window vw;
+			struct video_window *vw = (struct video_window *) arg;
+			DBG("VIDIOCSWIN %d x %d\n", vw->width, vw->height);
 
-			if (copy_from_user(&vw, user_arg, sizeof(vw))) {
+			if ( vw->width != 320 || vw->height != 240 )
 				retval = -EFAULT;
-				break;
-			}
-
-			DBG("VIDIOCSWIN %d x %d\n", vw.width, vw.height);
 			
-			if ( vw.width != 320 || vw.height != 240 )
-				retval = -EFAULT;
-
 			break;
 		}
 
@@ -685,7 +676,8 @@
 			for (i = 0; i < VICAM_FRAMES; i++)
 				vm.offsets[i] = VICAM_MAX_FRAME_SIZE * i;
 
-			if (copy_to_user(user_arg, (void *)&vm, sizeof(vm)))
+			if (copy_to_user
+			    ((void *) arg, (void *) &vm, sizeof (vm)))
 				retval = -EFAULT;
 
 			break;
@@ -696,7 +688,8 @@
 			struct video_mmap vm;
 			// int video_size;
 
-			if (copy_from_user((void *)&vm, user_arg, sizeof(vm))) {
+			if (copy_from_user
+			    ((void *) &vm, (void *) arg, sizeof (vm))) {
 				retval = -EFAULT;
 				break;
 			}
@@ -719,7 +712,7 @@
 		{
 			int frame;
 
-			if (copy_from_user((void *)&frame, user_arg, sizeof(int))) {
+			if (copy_from_user((void *) &frame, arg, sizeof (int))) {
 				retval = -EFAULT;
 				break;
 			}
@@ -999,7 +992,7 @@
 }
 
 static ssize_t
-vicam_read( struct file *file, char __user *buf, size_t count, loff_t *ppos )
+vicam_read( struct file *file, char *buf, size_t count, loff_t *ppos )
 {
 	struct vicam_camera *cam = file->private_data;
 
@@ -1276,8 +1269,6 @@
 
 /**
  *	vicam_probe
- *	@intf: the interface
- *	@id: the device id
  *
  *	Called by the usb core when a new device is connected that it thinks
  *	this driver might be interested in.
@@ -1299,7 +1290,7 @@
 
 	printk(KERN_INFO "ViCam based webcam connected\n");
 
-	interface = intf->cur_altsetting;
+	interface = &intf->altsetting[0];
 
 	DBG(KERN_DEBUG "Interface %d. has %u. endpoints!\n",
 	       interface->desc.bInterfaceNumber, (unsigned) (interface->desc.bNumEndpoints));
diff -Naur linuxppc-2.6.9/drivers/usb/media/w9968cf.c linuxppc-2.6.9-dream/drivers/usb/media/w9968cf.c
--- linuxppc-2.6.9/drivers/usb/media/w9968cf.c	2004-10-18 23:54:54.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/w9968cf.c	2005-09-19 21:40:05.000000000 +0200
@@ -5,7 +5,7 @@
  *                                                                         *
  * - Memory management code from bttv driver by Ralph Metzler,             *
  *   Marcus Metzler and Gerd Knorr.                                        *
- * - I2C interface to kernel, high-level image sensor control routines and *
+ * - I2C interface to kernel, high-level CMOS sensor control routines and  *
  *   some symbolic names from OV511 driver by Mark W. McClelland.          *
  * - Low-level I2C fast write function by Piotr Czerczak.                  *
  * - Low-level I2C read function by Frederic Jouault.                      *
@@ -27,23 +27,21 @@
 
 #include <linux/version.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
-#include <linux/kmod.h>
 #include <linux/init.h>
 #include <linux/fs.h>
 #include <linux/vmalloc.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/string.h>
+#include <linux/ctype.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
 #include <linux/ioctl.h>
 #include <linux/delay.h>
-#include <linux/stddef.h>
 #include <asm/page.h>
 #include <asm/uaccess.h>
-#include <linux/page-flags.h>
-#include <linux/moduleparam.h>
 
 #include "w9968cf.h"
 #include "w9968cf_decoder.h"
@@ -51,18 +49,14 @@
 
 
 /****************************************************************************
- * Module macros and parameters                                             *
+ * Module macros and paramaters                                             *
  ****************************************************************************/
 
-MODULE_DEVICE_TABLE(usb, winbond_id_table);
-
 MODULE_AUTHOR(W9968CF_MODULE_AUTHOR" "W9968CF_AUTHOR_EMAIL);
-MODULE_DESCRIPTION(W9968CF_MODULE_NAME);
-MODULE_VERSION(W9968CF_MODULE_VERSION);
+MODULE_DESCRIPTION(W9968CF_MODULE_NAME" "W9968CF_MODULE_VERSION);
 MODULE_LICENSE(W9968CF_MODULE_LICENSE);
 MODULE_SUPPORTED_DEVICE("Video");
 
-static int ovmod_load = W9968CF_OVMOD_LOAD;
 static int vppmod_load = W9968CF_VPPMOD_LOAD;
 static unsigned short simcams = W9968CF_SIMCAMS;
 static short video_nr[]={[0 ... W9968CF_MAX_DEVICES-1] = -1}; /*-1=first free*/
@@ -106,11 +100,8 @@
 
 static unsigned int param_nv[24]; /* number of values per parameter */
 
-#ifdef CONFIG_KMOD
-module_param(ovmod_load, bool, 0644);
 module_param(vppmod_load, bool, 0444);
-#endif
-module_param(simcams, ushort, 0644);
+module_param(simcams, ushort, 0444);
 module_param_array(video_nr, short, param_nv[0], 0444);
 module_param_array(packet_size, uint, param_nv[1], 0444);
 module_param_array(max_buffers, ushort, param_nv[2], 0444);
@@ -136,34 +127,21 @@
 module_param_array(contrast, uint, param_nv[22], 0444);
 module_param_array(whiteness, uint, param_nv[23], 0444);
 #ifdef W9968CF_DEBUG
-module_param(debug, ushort, 0644);
-module_param(specific_debug, bool, 0644);
+module_param(debug, ushort, 0444);
+module_param(specific_debug, bool, 0444);
 #endif
 
-#ifdef CONFIG_KMOD
-MODULE_PARM_DESC(ovmod_load, 
-                 "\n<0|1> Automatic 'ovcamchip' module loading."
-                 "\n0 disabled, 1 enabled."
-                 "\nIf enabled,'insmod' searches for the required 'ovcamchip'"
-                 "\nmodule in the system, according to its configuration, and"
-                 "\nattempts to load that module automatically. This action is"
-                 "\nperformed once as soon as the 'w9968cf' module is loaded"
-                 "\ninto memory."
-                 "\nDefault value is "__MODULE_STRING(W9968CF_OVMOD_LOAD)"."
-                 "\n");
 MODULE_PARM_DESC(vppmod_load, 
                  "\n<0|1> Automatic 'w9968cf-vpp' module loading."
-                 "\n0 disabled, 1 enabled."
+                 "\n0 disable, 1 enable."
                  "\nIf enabled, every time an application attempts to open a"
                  "\ncamera, 'insmod' searches for the video post-processing"
                  "\nmodule in the system and loads it automatically (if"
-                 "\npresent). The optional 'w9968cf-vpp' module adds extra"
-                 "\n image manipulation functions to the 'w9968cf' module,like"
-                 "\nsoftware up-scaling,colour conversions and video decoding"
-                 "\nfor very high frame rates."
+                 "\npresent). The 'w9968cf-vpp' module adds extra image"
+                 "\nmanipulation functions to the 'w9968cf' module, like"
+                 "\nsoftware up-scaling,colour conversions and video decoding."
                  "\nDefault value is "__MODULE_STRING(W9968CF_VPPMOD_LOAD)"."
                  "\n");
-#endif
 MODULE_PARM_DESC(simcams, 
                  "\n<n> Number of cameras allowed to stream simultaneously."
                  "\nn may vary from 0 to "
@@ -198,8 +176,8 @@
                  "\n<0|1[,...]> "
                  "Hardware double buffering: 0 disabled, 1 enabled."
                  "\nIt should be enabled if you want smooth video output: if"
-                 "\nyou obtain out of sync. video, disable it, or try to"
-                 "\ndecrease the 'clockdiv' module parameter value."
+                 "\nyou obtain out of sync. video, disable it at all, or try"
+                 "\nto decrease the 'clockdiv' module paramater value."
                  "\nDefault value is "__MODULE_STRING(W9968CF_DOUBLE_BUFFER)
                  " for every device."
                  "\n");
@@ -215,7 +193,7 @@
                  "\nDefault value is "__MODULE_STRING(W9968CF_FILTER_TYPE)
                  " for every device."
                  "\nThe filter is used to reduce noise and aliasing artifacts"
-                 "\nproduced by the CCD or CMOS image sensor, and the scaling"
+                 "\nproduced by the CCD or CMOS sensor, and the scaling"
                  " process."
                  "\n");
 MODULE_PARM_DESC(largeview, 
@@ -230,7 +208,7 @@
                  " enough memory."
                  "\nDefault value is "__MODULE_STRING(W9968CF_UPSCALING)
                  " for every device."
-                 "\nIf 'w9968cf-vpp' is not present, this parameter is"
+                 "\nIf 'w9968cf-vpp' is not loaded, this paramater is"
                  " set to 0."
                  "\n");
 MODULE_PARM_DESC(decompression,
@@ -246,8 +224,8 @@
                  "a multiple of 16."
                  "\nDefault value is "__MODULE_STRING(W9968CF_DECOMPRESSION)
                  " for every device."
-                 "\nIf 'w9968cf-vpp' is not present, forcing decompression is "
-                 "\nnot allowed; in this case this parameter is set to 2."
+                 "\nIf 'w9968cf-vpp' is not loaded, forcing decompression is "
+                 "\nnot allowed; in this case this paramater is set to 2."
                  "\n");
 MODULE_PARM_DESC(force_palette,
                  "\n<0"
@@ -277,11 +255,11 @@
                  "\n- RGB565  16 bpp - Software conversion from UYVY"
                  "\n- RGB24   24 bpp - Software conversion from UYVY"
                  "\n- RGB32   32 bpp - Software conversion from UYVY"
-                 "\nWhen not 0, this parameter will override 'decompression'."
+                 "\nWhen not 0, this paramater will override 'decompression'."
                  "\nDefault value is 0 for every device."
                  "\nInitial palette is "
                  __MODULE_STRING(W9968CF_PALETTE_DECOMP_ON)"."
-                 "\nIf 'w9968cf-vpp' is not present, this parameter is"
+                 "\nIf 'w9968cf-vpp' is not loaded, this paramater is"
                  " set to 9 (UYVY)."
                  "\n");
 MODULE_PARM_DESC(force_rgb, 
@@ -293,13 +271,13 @@
                  " for every device."
                  "\n");
 MODULE_PARM_DESC(autobright,
-                 "\n<0|1[,...]> Image sensor automatically changes brightness:"
+                 "\n<0|1[,...]> CMOS sensor automatically changes brightness:"
                  "\n 0 = no, 1 = yes"
                  "\nDefault value is "__MODULE_STRING(W9968CF_AUTOBRIGHT)
                  " for every device."
                  "\n");
 MODULE_PARM_DESC(autoexp,
-                 "\n<0|1[,...]> Image sensor automatically changes exposure:"
+                 "\n<0|1[,...]> CMOS sensor automatically changes exposure:"
                  "\n 0 = no, 1 = yes"
                  "\nDefault value is "__MODULE_STRING(W9968CF_AUTOEXP)
                  " for every device."
@@ -326,7 +304,7 @@
                  "Force pixel clock divisor to a specific value (for experts):"
                  "\n  n may vary from 0 to 127."
                  "\n -1 for automatic value."
-                 "\nSee also the 'double_buffer' module parameter."
+                 "\nSee also the 'double_buffer' module paramater."
                  "\nDefault value is "__MODULE_STRING(W9968CF_CLOCKDIV)
                  " for every device."
                  "\n");
@@ -343,7 +321,7 @@
                  " for every device."
                  "\n");
 MODULE_PARM_DESC(monochrome,
-                 "\n<0|1[,...]> Use image sensor as monochrome sensor:"
+                 "\n<0|1[,...]> Use OV CMOS sensor as monochrome sensor:"
                  "\n 0 = no, 1 = yes"
                  "\nNot all the sensors support monochrome color."
                  "\nDefault value is "__MODULE_STRING(W9968CF_MONOCHROME)
@@ -385,7 +363,7 @@
                  "\n4 = warnings"
                  "\n5 = called functions"
                  "\n6 = function internals"
-                 "\nLevel 5 and 6 are useful for testing only, when only "
+                 "\nLevel 5 and 6 are useful for testing only, when just "
                  "one device is used."
                  "\nDefault value is "__MODULE_STRING(W9968CF_DEBUG_LEVEL)"."
                  "\n");
@@ -410,14 +388,14 @@
 static struct file_operations w9968cf_fops;
 static int w9968cf_open(struct inode*, struct file*);
 static int w9968cf_release(struct inode*, struct file*);
+static ssize_t w9968cf_read(struct file*, char*, size_t, loff_t*);
 static int w9968cf_mmap(struct file*, struct vm_area_struct*);
 static int w9968cf_ioctl(struct inode*, struct file*, unsigned, unsigned long);
-static ssize_t w9968cf_read(struct file*, char __user *, size_t, loff_t*);
-static int w9968cf_v4l_ioctl(struct inode*, struct file*, unsigned int,
-                             void __user *);
+static int w9968cf_v4l_ioctl(struct inode*, struct file*, unsigned int, void*);
 
 /* USB-specific */
 static int w9968cf_start_transfer(struct w9968cf_device*);
+static void w9968cf_urb_complete(struct urb *urb, struct pt_regs *regs);
 static int w9968cf_stop_transfer(struct w9968cf_device*);
 static int w9968cf_write_reg(struct w9968cf_device*, u16 value, u16 index);
 static int w9968cf_read_reg(struct w9968cf_device*, u16 index);
@@ -425,7 +403,6 @@
 static int w9968cf_write_sb(struct w9968cf_device*, u16 value);
 static int w9968cf_read_sb(struct w9968cf_device*);
 static int w9968cf_upload_quantizationtables(struct w9968cf_device*);
-static void w9968cf_urb_complete(struct urb *urb, struct pt_regs *regs);
 
 /* Low-level I2C (SMBus) I/O */
 static int w9968cf_smbus_start(struct w9968cf_device*);
@@ -462,12 +439,13 @@
 static void rvfree(void *mem, unsigned long size);
 static void w9968cf_deallocate_memory(struct w9968cf_device*);
 static int  w9968cf_allocate_memory(struct w9968cf_device*);
+static inline unsigned long w9968cf_get_max_bufsize(struct w9968cf_device*);
 
-/* High-level image sensor control functions */
+/* High-level CMOS sensor control functions */
 static int w9968cf_sensor_set_control(struct w9968cf_device*,int cid,int val);
 static int w9968cf_sensor_get_control(struct w9968cf_device*,int cid,int *val);
-static int w9968cf_sensor_cmd(struct w9968cf_device*,
-                              unsigned int cmd, void *arg);
+static inline int w9968cf_sensor_cmd(struct w9968cf_device*, 
+                                     unsigned int cmd, void *arg);
 static int w9968cf_sensor_init(struct w9968cf_device*);
 static int w9968cf_sensor_update_settings(struct w9968cf_device*);
 static int w9968cf_sensor_get_picture(struct w9968cf_device*);
@@ -478,14 +456,13 @@
 static void w9968cf_configure_camera(struct w9968cf_device*,struct usb_device*,
                                      enum w9968cf_model_id, 
                                      const unsigned short dev_nr);
-static void w9968cf_adjust_configuration(struct w9968cf_device*);
 static int w9968cf_turn_on_led(struct w9968cf_device*);
 static int w9968cf_init_chip(struct w9968cf_device*);
+static int w9968cf_set_picture(struct w9968cf_device*, struct video_picture);
+static int w9968cf_set_window(struct w9968cf_device*, struct video_window);
 static inline u16 w9968cf_valid_palette(u16 palette);
 static inline u16 w9968cf_valid_depth(u16 palette);
 static inline u8 w9968cf_need_decompression(u16 palette);
-static int w9968cf_set_picture(struct w9968cf_device*, struct video_picture);
-static int w9968cf_set_window(struct w9968cf_device*, struct video_window);
 static int w9968cf_postprocess_frame(struct w9968cf_device*, 
                                      struct w9968cf_frame_t*);
 static int w9968cf_adjust_window_size(struct w9968cf_device*, u16* w, u16* h);
@@ -495,8 +472,18 @@
 static void w9968cf_release_resources(struct w9968cf_device*);
 
 /* Intermodule communication */
-static int w9968cf_vppmod_detect(struct w9968cf_device*);
-static void w9968cf_vppmod_release(struct w9968cf_device*);
+static int w9968cf_vppmod_detect(void);
+static void w9968cf_vppmod_release(void);
+
+/* Pointers to registered video post-processing functions */
+static void (*w9968cf_vpp_init_decoder)(void);
+static int (*w9968cf_vpp_check_headers)(const unsigned char*,
+                                        const unsigned long);
+static int (*w9968cf_vpp_decode)(const char*, const unsigned, 
+                                 const unsigned, const unsigned, char*);
+static void (*w9968cf_vpp_swap_yuvbytes)(void*, unsigned long);
+static void (*w9968cf_vpp_uyvy_to_rgbx)(u8*, unsigned long, u8*, u16, u8);
+static void (*w9968cf_vpp_scale_up)(u8*, u8*, u16, u16, u16, u16, u16);
 
 
 
@@ -531,15 +518,12 @@
 	{ W9968CF_MOD_CLVBWGP, "Creative Labs Video Blaster WebCam Go Plus" },
 
 	/* Other cameras (having the same descriptors as Generic W996[87]CF) */
-	{ W9968CF_MOD_ADPVDMA, "Aroma Digi Pen VGA Dual Mode ADG-5000" },
-	{ W9986CF_MOD_AAU, "AVerMedia AVerTV USB" },
+	{ W9968CF_MOD_ADPA5R, "Aroma Digi Pen ADG-5000 Refurbished" },
+	{ W9986CF_MOD_AU, "AVerTV USB" },
 	{ W9968CF_MOD_CLVBWG, "Creative Labs Video Blaster WebCam Go" },
-	{ W9968CF_MOD_LL, "Lebon LDC-035A" },
+	{ W9968CF_MOD_DLLDK, "Die Lebon LDC-D35A Digital Kamera" },
 	{ W9968CF_MOD_EEEMC, "Ezonics EZ-802 EZMega Cam" },
-	{ W9968CF_MOD_OOE, "OmniVision OV8610-EDE" },
 	{ W9968CF_MOD_ODPVDMPC, "OPCOM Digi Pen VGA Dual Mode Pen Camera" },
-	{ W9968CF_MOD_PDPII, "Pretec Digi Pen-II" },
-	{ W9968CF_MOD_PDP480, "Pretec DigiPen-480" },
 
 	{  -1, NULL }
 };
@@ -665,6 +649,17 @@
 
 
 /*--------------------------------------------------------------------------
+  Return the maximum size (in bytes) of a frame buffer.
+  --------------------------------------------------------------------------*/
+static inline unsigned long w9968cf_get_max_bufsize(struct w9968cf_device* cam)
+{
+	u8 bpp = (w9968cf_vppmod_present) ? 4 : 2;
+	return (cam->upscaling) ? W9968CF_MAX_WIDTH*W9968CF_MAX_HEIGHT*bpp :
+	                          cam->maxwidth*cam->maxheight*bpp;
+}
+
+
+/*--------------------------------------------------------------------------
   Deallocate previously allocated memory.
   --------------------------------------------------------------------------*/
 static void w9968cf_deallocate_memory(struct w9968cf_device* cam)
@@ -679,25 +674,26 @@
 
 	/* Free temporary frame buffer */
 	if (cam->frame_tmp.buffer) {
-		rvfree(cam->frame_tmp.buffer, cam->frame_tmp.size);
+		rvfree(cam->frame_tmp.buffer, W9968CF_HW_BUF_SIZE);
 		cam->frame_tmp.buffer = NULL;
 	}
 
 	/* Free helper buffer */
-	if (cam->frame_vpp.buffer) {
-		rvfree(cam->frame_vpp.buffer, cam->frame_vpp.size);
-		cam->frame_vpp.buffer = NULL;
+	if (cam->vpp_buffer) {
+		rvfree(cam->vpp_buffer, w9968cf_get_max_bufsize(cam));
+		cam->vpp_buffer = NULL;
 	}
-
+	
 	/* Free video frame buffers */
 	if (cam->frame[0].buffer) {
-		rvfree(cam->frame[0].buffer, cam->nbuffers*cam->frame[0].size);
+		rvfree(cam->frame[0].buffer, 
+		       cam->nbuffers * w9968cf_get_max_bufsize(cam));
 		cam->frame[0].buffer = NULL;
 	}
 
 	cam->nbuffers = 0;
 
-	DBG(5, "Memory successfully deallocated")
+	DBG(5, "Memory successfully deallocated.")
 }
 
 
@@ -708,30 +704,19 @@
   --------------------------------------------------------------------------*/
 static int w9968cf_allocate_memory(struct w9968cf_device* cam)
 {
+	const unsigned long bufsize = w9968cf_get_max_bufsize(cam);
 	const u16 p_size = wMaxPacketSize[cam->altsetting-1];
 	void* buff = NULL;
-	unsigned long hw_bufsize, vpp_bufsize;
-	u8 i, bpp;
+	u8 i;
 
 	/* NOTE: Deallocation is done elsewhere in case of error */
 
-	/* Calculate the max amount of raw data per frame from the device */
-	hw_bufsize = cam->maxwidth*cam->maxheight*2;
-
-	/* Calculate the max buf. size needed for post-processing routines */
-	bpp = (w9968cf_vpp) ? 4 : 2;
-	if (cam->upscaling)
-		vpp_bufsize = max(W9968CF_MAX_WIDTH*W9968CF_MAX_HEIGHT*bpp,
-		                  cam->maxwidth*cam->maxheight*bpp);
-	else
-		vpp_bufsize = cam->maxwidth*cam->maxheight*bpp;
-
 	/* Allocate memory for the isochronous transfer buffers */
 	for (i = 0; i < W9968CF_URBS; i++) {
 		if (!(cam->transfer_buffer[i] =
 		      kmalloc(W9968CF_ISO_PACKETS*p_size, GFP_KERNEL))) {
 			DBG(1, "Couldn't allocate memory for the isochronous "
-			       "transfer buffers (%u bytes)", 
+			       "transfer buffers (%d bytes).", 
 			    p_size * W9968CF_ISO_PACKETS)
 			return -ENOMEM;
 		}
@@ -739,49 +724,44 @@
 	}
 
 	/* Allocate memory for the temporary frame buffer */
-	if (!(cam->frame_tmp.buffer = rvmalloc(hw_bufsize))) {
+	if (!(cam->frame_tmp.buffer = rvmalloc(W9968CF_HW_BUF_SIZE))) {
 		DBG(1, "Couldn't allocate memory for the temporary "
-		       "video frame buffer (%lu bytes)", hw_bufsize)
+		       "video frame buffer (%i bytes).", W9968CF_HW_BUF_SIZE)
 		return -ENOMEM;
 	}
-	cam->frame_tmp.size = hw_bufsize;
-	cam->frame_tmp.number = -1;
 
 	/* Allocate memory for the helper buffer */
-	if (w9968cf_vpp) {
-		if (!(cam->frame_vpp.buffer = rvmalloc(vpp_bufsize))) {
+	if (w9968cf_vppmod_present) {
+		if (!(cam->vpp_buffer = rvmalloc(bufsize))) {
 			DBG(1, "Couldn't allocate memory for the helper buffer"
-			       " (%lu bytes)", vpp_bufsize)
+			       " (%li bytes).", bufsize)
 			return -ENOMEM;
 		}
-		cam->frame_vpp.size = vpp_bufsize;
 	} else
-		cam->frame_vpp.buffer = NULL;
+		cam->vpp_buffer = NULL;
 
-	/* Allocate memory for video frame buffers */
+	/* Allocate memory for video frame buffers */	
 	cam->nbuffers = cam->max_buffers;
 	while (cam->nbuffers >= 2) {
-		if ((buff = rvmalloc(cam->nbuffers * vpp_bufsize)))
+		if ((buff = rvmalloc(cam->nbuffers * bufsize)))
 			break;
 		else
 			cam->nbuffers--;
 	}
 
 	if (!buff) {
-		DBG(1, "Couldn't allocate memory for the video frame buffers")
+		DBG(1, "Couldn't allocate memory for the video frame buffers.")
 		cam->nbuffers = 0;
 		return -ENOMEM;
 	}
 
 	if (cam->nbuffers != cam->max_buffers)
-		DBG(2, "Couldn't allocate memory for %u video frame buffers. "
-		       "Only memory for %u buffers has been allocated",
+		DBG(2, "Couldn't allocate memory for %d video frame buffers. "
+		       "Only memory for %d buffers has been allocated.",
 		    cam->max_buffers, cam->nbuffers)
 
 	for (i = 0; i < cam->nbuffers; i++) {
-		cam->frame[i].buffer = buff + i*vpp_bufsize;
-		cam->frame[i].size = vpp_bufsize;
-		cam->frame[i].number = i;
+		cam->frame[i].buffer = buff + i*bufsize;
 		/* Circular list */
 		if (i != cam->nbuffers-1)
 			cam->frame[i].next = &cam->frame[i+1];
@@ -790,7 +770,7 @@
 		cam->frame[i].status = F_UNUSED;
 	}
 
-	DBG(5, "Memory successfully allocated")
+	DBG(5, "Memory successfully allocated.")
 	return 0;
 }
 
@@ -814,16 +794,20 @@
 {
 	struct w9968cf_device* cam = (struct w9968cf_device*)urb->context;
 	struct w9968cf_frame_t** f;
+	unsigned long maxbufsize;
 	unsigned int len, status;
 	void* pos;
 	u8 i;
 	int err = 0;
 
 	if ((!cam->streaming) || cam->disconnected) {
-		DBG(4, "Got interrupt, but not streaming")
+		DBG(4, "Got interrupt, but not streaming.")
 		return;
 	}
 
+	maxbufsize = min( (unsigned long)W9968CF_HW_BUF_SIZE, 
+	                  w9968cf_get_max_bufsize(cam) );
+
 	/* "(*f)" will be used instead of "cam->frame_current" */
 	f = &cam->frame_current;
 
@@ -836,8 +820,8 @@
 			(*f)->length = cam->frame_tmp.length;
 			memcpy((*f)->buffer, cam->frame_tmp.buffer,
 			       (*f)->length);
-			DBG(6, "Switched from temp. frame to frame #%d", 
-			    (*f)->number)
+			DBG(6, "Switched from temp. frame to frame #%zd", 
+			    (*f) - &cam->frame[0])
 		}
 	}
 
@@ -848,7 +832,7 @@
 
 		if (status && len != 0) {
 			DBG(4, "URB failed, error in data packet "
-			       "(error #%u, %s)",
+			       "(error #%d, %s).",
 			    status, symbolic(urb_errlist, status))
 			(*f)->status = F_ERROR;
 			continue;
@@ -862,8 +846,8 @@
 			}
 
 			/* Buffer overflows shouldn't happen, however...*/
-			if ((*f)->length + len > (*f)->size) {
-				DBG(4, "Buffer overflow: bad data packets")
+			if ((*f)->length + len > maxbufsize) {
+				DBG(4, "Buffer overflow: bad data packets.")
 				(*f)->status = F_ERROR;
 			}
 
@@ -874,10 +858,11 @@
 
 		} else if ((*f)->status == F_GRABBING) { /* end of frame */
 
-			DBG(6, "Frame #%d successfully grabbed", (*f)->number)
+			DBG(6, "Frame #%zd successfully grabbed.",
+			    ((*f)==&cam->frame_tmp ? -1 : (*f)-&cam->frame[0]))
 
 			if (cam->vpp_flag & VPP_DECOMPRESSION) {
-				err = w9968cf_vpp->check_headers((*f)->buffer,
+				err=(*w9968cf_vpp_check_headers)((*f)->buffer,
 				                                 (*f)->length);
 				if (err) {
 					DBG(4, "Skip corrupted frame: %s",
@@ -902,7 +887,7 @@
 		} else if ((*f)->status == F_ERROR)
 			(*f)->status = F_UNUSED; /* grab it again */
 
-		PDBGG("Frame length %lu | pack.#%u | pack.len. %u | state %d",
+		PDBGG("Frame length %li | pack.#%d | pack.len. %d | state %d",
 		      (unsigned long)(*f)->length, i, len, (*f)->status)
 
 	} /* end for */
@@ -915,12 +900,13 @@
 		if ((err = usb_submit_urb(urb, GFP_ATOMIC))) {
 			cam->misconfigured = 1;
 			DBG(1, "Couldn't resubmit the URB: error %d, %s",
-			    err, symbolic(urb_errlist, err))
+			    err, symbolic(urb_errlist, err));
 		}
 	spin_unlock(&cam->urb_lock);
 
 	/* Wake up the user process */
-	wake_up_interruptible(&cam->wait_queue);
+	if (waitqueue_active(&cam->wait_queue))
+		wake_up_interruptible(&cam->wait_queue);
 }
 
 
@@ -946,7 +932,7 @@
 		if (!urb) {
 			for (j = 0; j < i; j++)
 				usb_free_urb(cam->urb[j]);
-			DBG(1, "Couldn't allocate the URB structures")
+			DBG(1, "Couldn't allocate the URB structures.")
 			return -ENOMEM;
 		}
 
@@ -991,7 +977,7 @@
 	if (err || (vidcapt < 0)) {
 		for (i = 0; i < W9968CF_URBS; i++)
 			usb_free_urb(cam->urb[i]);
-		DBG(1, "Couldn't tell the camera to start the data transfer")
+		DBG(1, "Couldn't tell the camera to start the data transfer.")
 		return err;
 	}
 
@@ -1003,29 +989,26 @@
 	cam->frame_current = &cam->frame_tmp;
 
 	if (!(cam->vpp_flag & VPP_DECOMPRESSION))
-		DBG(5, "Isochronous transfer size: %lu bytes/frame", 
+		DBG(5, "Isochronous transfer size: %li bytes/frame.",
 		    (unsigned long)t_size*2)
 
 	DBG(5, "Starting the isochronous transfer...")
 
-	cam->streaming = 1;
-
 	/* Submit the URBs */
 	for (i = 0; i < W9968CF_URBS; i++) {
 		err = usb_submit_urb(cam->urb[i], GFP_KERNEL);
 		if (err) {
-			cam->streaming = 0;
-			for (j = i-1; j >= 0; j--) {
-				usb_kill_urb(cam->urb[j]);
-				usb_free_urb(cam->urb[j]);
-			}
+			for (j = i-1; j >= 0; j--)
+				if (!usb_unlink_urb(cam->urb[j]))
+					usb_free_urb(cam->urb[j]);
 			DBG(1, "Couldn't send a transfer request to the "
-			       "USB core (error #%d, %s)", err, 
+			       "USB core (error #%d, %s).", err, 
 			    symbolic(urb_errlist, err))
-			return err;
 		}
 	}
 
+	cam->streaming = 1;
+
 	return 0;
 }
 
@@ -1041,9 +1024,6 @@
 	int err = 0;
 	s8 i;
 
-	if (!cam->streaming)
-		return 0;
-
 	/* This avoids race conditions with usb_submit_urb() 
 	   in the URB completition handler */
 	spin_lock_irqsave(&cam->urb_lock, lock_flags);
@@ -1052,9 +1032,10 @@
 
 	for (i = W9968CF_URBS-1; i >= 0; i--)
 		if (cam->urb[i]) {
-			usb_kill_urb(cam->urb[i]);
-			usb_free_urb(cam->urb[i]);
-			cam->urb[i] = NULL;
+			if (!usb_unlink_urb(cam->urb[i])) {
+				usb_free_urb(cam->urb[i]);
+				cam->urb[i] = NULL;
+			}
 		}
 
 	if (cam->disconnected)
@@ -1072,7 +1053,7 @@
 	}
 
 exit:
-	DBG(5, "Isochronous transfer stopped")
+	DBG(5, "Isochronous transfer stopped.")
 	return 0;
 }
 
@@ -1092,7 +1073,7 @@
 
 	if (res < 0)
 		DBG(4, "Failed to write a register "
-		       "(value 0x%04X, index 0x%02X, error #%d, %s)",
+		       "(value 0x%04X, index 0x%02X, error #%d, %s).",
 		    value, index, res, symbolic(urb_errlist, res))
 
 	return (res >= 0) ? 0 : -1;
@@ -1115,7 +1096,7 @@
 
 	if (res < 0)
 		DBG(4, "Failed to read a register "
-		       "(index 0x%02X, error #%d, %s)",
+		       "(index 0x%02X, error #%d, %s).",
 		    index, res, symbolic(urb_errlist, res))
 
 	return (res >= 0) ? (int)(*buff) : -1;
@@ -1140,7 +1121,7 @@
 
 	if (res < 0)
 		DBG(4, "Failed to write the FSB registers "
-		       "(error #%d, %s)", res, symbolic(urb_errlist, res))
+		       "(error #%d, %s).", res, symbolic(urb_errlist, res))
 
 	return (res >= 0) ? 0 : -1;
 }
@@ -1290,7 +1271,7 @@
 	if (sda < 0)
 		err += sda;
 	if (sda == 1) {
-		DBG(6, "Couldn't receive the ACK")
+		DBG(6, "Couldn't receive the ACK.")
 		err += -1;
 	}
 
@@ -1373,11 +1354,11 @@
 
 	if (!err)
 		DBG(5, "I2C write byte data done, addr.0x%04X, subaddr.0x%02X "
-		       "value 0x%02X", address, subaddress, value)
+		       "value 0x%02X.", address, subaddress, value)
 	else
 		DBG(5, "I2C write byte data failed, addr.0x%04X, "
-		       "subaddr.0x%02X, value 0x%02X", 
-		    address, subaddress, value)
+		       "subaddr.0x%02X, value 0x%02X.", 
+	            address, subaddress, value)
 
 	return err;
 }
@@ -1412,11 +1393,11 @@
 
 	if (!err)
 		DBG(5, "I2C read byte data done, addr.0x%04X, "
-		       "subaddr.0x%02X, value 0x%02X", 
+		       "subaddr.0x%02X, value 0x%02X.", 
 		    address, subaddress, *value)
 	else
 		DBG(5, "I2C read byte data failed, addr.0x%04X, "
-		       "subaddr.0x%02X, wrong value 0x%02X",
+		       "subaddr.0x%02X, wrong value 0x%02X.",
 		    address, subaddress, *value)
 
 	return err;
@@ -1444,11 +1425,11 @@
 	err += w9968cf_write_sb(cam, 0x0000);
 
 	if (!err)
-		DBG(5, "I2C read byte done, addr.0x%04X, "
-		       "value 0x%02X", address, *value)
+		DBG(5, "I2C read byte done, addr.0x%04X."
+		       "value 0x%02X.", address, *value)
 	else
-		DBG(5, "I2C read byte failed, addr.0x%04X, "
-		       "wrong value 0x%02X", address, *value)
+		DBG(5, "I2C read byte failed, addr.0x%04X."
+		       "wrong value 0x%02X.", address, *value)
 
 	return err;
 }
@@ -1459,7 +1440,7 @@
 w9968cf_i2c_adap_write_byte(struct w9968cf_device* cam,
                             u16 address, u8 value)
 {
-	DBG(4, "i2c_write_byte() is an unsupported transfer mode")
+	DBG(4, "i2c_write_byte() is an unsupported transfer mode.")
 	return -EINVAL;
 }
 
@@ -1566,8 +1547,9 @@
 	struct w9968cf_device* cam = i2c_get_adapdata(client->adapter);
 	const char* clientname = i2c_clientname(client);
 
-	if (cam->sensor_client == client)
+	if (cam->sensor_client == client) {
 		cam->sensor_client = NULL;
+	}
 
 	DBG(5, "I2C detach client [%s]", clientname)
 
@@ -1597,7 +1579,7 @@
 
 	static struct i2c_adapter adap = {
 		.id =                I2C_ALGO_SMBUS | I2C_HW_SMBUS_W9968CF,
-		.class =             I2C_CLASS_CAM_DIGITAL,
+		.class =             I2C_ADAP_CLASS_CAM_DIGITAL,
 		.owner =             THIS_MODULE,
 		.client_register =   w9968cf_i2c_attach_inform,
 		.client_unregister = w9968cf_i2c_detach_inform,
@@ -1612,9 +1594,9 @@
 
 	err = i2c_add_adapter(&cam->i2c_adapter);
 	if (err)
-		DBG(1, "Failed to register the I2C adapter")
+		DBG(1, "Failed to register the I2C adapter.")
 	else
-		DBG(5, "I2C adapter registered")
+		DBG(5, "I2C adapter registered.")
 
 	return err;
 }
@@ -1641,9 +1623,9 @@
 	err += w9968cf_write_reg(cam, 0x0010, 0x01); /* ..high 'beep-beep' */
 
 	if (err)
-		DBG(2, "Couldn't turn on the LED")
+		DBG(2, "Couldn't turn on the LED.")
 
-	DBG(5, "LED turned on")
+	DBG(5, "LED turned on.")
 
 	return err;
 }
@@ -1656,13 +1638,6 @@
   --------------------------------------------------------------------------*/
 static int w9968cf_init_chip(struct w9968cf_device* cam)
 {
-	unsigned long hw_bufsize = cam->maxwidth*cam->maxheight*2,
-	              y0 = 0x0000,
-	              u0 = y0 + hw_bufsize/2,
-	              v0 = u0 + hw_bufsize/4,
-	              y1 = v0 + hw_bufsize/4,
-	              u1 = y1 + hw_bufsize/2,
-	              v1 = u1 + hw_bufsize/4;
 	int err = 0;
 
 	err += w9968cf_write_reg(cam, 0xff00, 0x00); /* power off */
@@ -1671,25 +1646,23 @@
 	err += w9968cf_write_reg(cam, 0x405d, 0x03); /* DRAM timings */
 	err += w9968cf_write_reg(cam, 0x0030, 0x04); /* SDRAM timings */
 
-	err += w9968cf_write_reg(cam, y0 & 0xffff, 0x20); /* Y buf.0, low */
-	err += w9968cf_write_reg(cam, y0 >> 16, 0x21);    /* Y buf.0, high */
-	err += w9968cf_write_reg(cam, u0 & 0xffff, 0x24); /* U buf.0, low */
-	err += w9968cf_write_reg(cam, u0 >> 16, 0x25);    /* U buf.0, high */
-	err += w9968cf_write_reg(cam, v0 & 0xffff, 0x28); /* V buf.0, low */
-	err += w9968cf_write_reg(cam, v0 >> 16, 0x29);    /* V buf.0, high */
-
-	err += w9968cf_write_reg(cam, y1 & 0xffff, 0x22); /* Y buf.1, low */
-	err += w9968cf_write_reg(cam, y1 >> 16, 0x23);    /* Y buf.1, high */
-	err += w9968cf_write_reg(cam, u1 & 0xffff, 0x26); /* U buf.1, low */
-	err += w9968cf_write_reg(cam, u1 >> 16, 0x27);    /* U buf.1, high */
-	err += w9968cf_write_reg(cam, v1 & 0xffff, 0x2a); /* V buf.1, low */
-	err += w9968cf_write_reg(cam, v1 >> 16, 0x2b);    /* V buf.1, high */
-
-	err += w9968cf_write_reg(cam, y1 & 0xffff, 0x32); /* JPEG buf 0 low */
-	err += w9968cf_write_reg(cam, y1 >> 16, 0x33);    /* JPEG buf 0 high */
-
-	err += w9968cf_write_reg(cam, y1 & 0xffff, 0x34); /* JPEG buf 1 low */
-	err += w9968cf_write_reg(cam, y1 >> 16, 0x35);    /* JPEG bug 1 high */
+	err += w9968cf_write_reg(cam, 0x0000, 0x20); /* Y frame buf.0, low */
+	err += w9968cf_write_reg(cam, 0x0000, 0x21); /* Y frame buf.0, high */
+	err += w9968cf_write_reg(cam, 0xb000, 0x22); /* Y frame buf.1, low */
+	err += w9968cf_write_reg(cam, 0x0004, 0x23); /* Y frame buf.1, high */
+	err += w9968cf_write_reg(cam, 0x5800, 0x24); /* U frame buf.0, low */
+	err += w9968cf_write_reg(cam, 0x0002, 0x25); /* U frame buf.0, high */
+	err += w9968cf_write_reg(cam, 0x0800, 0x26); /* U frame buf.1, low */
+	err += w9968cf_write_reg(cam, 0x0007, 0x27); /* U frame buf.1, high */
+	err += w9968cf_write_reg(cam, 0x8400, 0x28); /* V frame buf.0, low */
+	err += w9968cf_write_reg(cam, 0x0003, 0x29); /* V frame buf.0, high */
+	err += w9968cf_write_reg(cam, 0x3400, 0x2a); /* V frame buf.1, low */
+	err += w9968cf_write_reg(cam, 0x0008, 0x2b); /* V frame buf.1, high */
+
+	err += w9968cf_write_reg(cam, 0x6000, 0x32); /* JPEG bitstream buf 0 */
+	err += w9968cf_write_reg(cam, 0x0009, 0x33); /* JPEG bitstream buf 0 */
+	err += w9968cf_write_reg(cam, 0x2000, 0x34); /* JPEG bitstream buf 1 */
+	err += w9968cf_write_reg(cam, 0x000d, 0x35); /* JPEG bitstream buf 1 */
 
 	err += w9968cf_write_reg(cam, 0x0000, 0x36);/* JPEG restart interval */
 	err += w9968cf_write_reg(cam, 0x0804, 0x37);/*JPEG VLE FIFO threshold*/
@@ -1700,59 +1673,15 @@
 	err += w9968cf_set_window(cam, cam->window);
 
 	if (err)
-		DBG(1, "Chip initialization failed")
+		DBG(1, "Chip initialization failed.")
 	else
-		DBG(5, "Chip successfully initialized")
+		DBG(5, "Chip successfully initialized.")
 
 	return err;
 }
 
 
 /*--------------------------------------------------------------------------
-  Return non-zero if the palette is supported, 0 otherwise.
-  --------------------------------------------------------------------------*/
-static inline u16 w9968cf_valid_palette(u16 palette)
-{
-	u8 i = 0;
-	while (w9968cf_formatlist[i].palette != 0) {
-		if (palette == w9968cf_formatlist[i].palette)
-			return palette;
-		i++;
-	}
-	return 0;
-}
-
-
-/*--------------------------------------------------------------------------
-  Return the depth corresponding to the given palette.
-  Palette _must_ be supported !
-  --------------------------------------------------------------------------*/
-static inline u16 w9968cf_valid_depth(u16 palette)
-{
-	u8 i=0;
-	while (w9968cf_formatlist[i].palette != palette)
-		i++;
-
-	return w9968cf_formatlist[i].depth;
-}
-
-
-/*--------------------------------------------------------------------------
-  Return non-zero if the format requires decompression, 0 otherwise.
-  --------------------------------------------------------------------------*/
-static inline u8 w9968cf_need_decompression(u16 palette)
-{
-	u8 i = 0;
-	while (w9968cf_formatlist[i].palette != 0) {
-		if (palette == w9968cf_formatlist[i].palette)
-			return w9968cf_formatlist[i].compression;
-		i++;
-	}
-	return 0;
-}
-
-
-/*--------------------------------------------------------------------------
   Change the picture settings of the camera.
   Return 0 on success, a negative number otherwise.
   --------------------------------------------------------------------------*/
@@ -1808,8 +1737,8 @@
 			break;
 	}
 
-	/* NOTE: due to memory issues, it is better to disable the hardware
-	         double buffering during compression */
+	/* FIXME: 'hardware double buffer' doesn't work when compressed video
+	          is enabled (corrupted frames). */
 	if (cam->double_buffer && !(cam->vpp_flag & VPP_DECOMPRESSION))
 		reg_v |= 0x0080;
 
@@ -1833,15 +1762,16 @@
 	cam->hw_palette = hw_palette;
 
 	/* Settings changed, so we clear the frame buffers */
-	memset(cam->frame[0].buffer, 0, cam->nbuffers*cam->frame[0].size);
+	memset(cam->frame[0].buffer, 0, 
+	       cam->nbuffers*w9968cf_get_max_bufsize(cam));
 
-	DBG(4, "Palette is %s, depth is %u bpp",
+	DBG(4, "Palette is %s, depth is %d bpp.",
 	    symbolic(v4l1_plist, pict.palette), pict.depth)
 
 	return 0;
 
 error:
-	DBG(1, "Failed to change picture settings")
+	DBG(1, "Failed to change picture settings.")
 	return err;
 }
 
@@ -1992,24 +1922,69 @@
 	cam->hw_height = h;
 
 	/* Settings changed, so we clear the frame buffers */
-	memset(cam->frame[0].buffer, 0, cam->nbuffers*cam->frame[0].size);
+	memset(cam->frame[0].buffer, 0, 
+	       cam->nbuffers*w9968cf_get_max_bufsize(cam));
 
-	DBG(4, "The capture area is %dx%d, Offset (x,y)=(%u,%u)", 
+	DBG(4, "The capture area is %dx%d, Offset (x,y)=(%d,%d).", 
 	    win.width, win.height, win.x, win.y)
 
-	PDBGG("x=%u ,y=%u, w=%u, h=%u, ax=%u, ay=%u, s_win.x=%u, s_win.y=%u, "
-	      "cw=%u, ch=%u, win.x=%u, win.y=%u, win.width=%u, win.height=%u",
+	PDBGG("x=%d ,y=%d, w=%d, h=%d, ax=%d, ay=%d, s_win.x=%d, s_win.y=%d, "
+	      "cw=%d, ch=%d, win.x=%d ,win.y=%d, win.width=%d, win.height=%d",
 	      x, y, w, h, ax, ay, s_win.x, s_win.y, cw, ch, win.x, win.y,
 	      win.width, win.height)
 
 	return 0;
 
 error:
-	DBG(1, "Failed to change the capture area size")
+	DBG(1, "Failed to change the capture area size.")
 	return err;
 }
 
 
+/*--------------------------------------------------------------------------
+  Return non-zero if the palette is supported, 0 otherwise.
+  --------------------------------------------------------------------------*/
+static inline u16 w9968cf_valid_palette(u16 palette)
+{
+	u8 i = 0;
+	while (w9968cf_formatlist[i].palette != 0) {
+		if (palette == w9968cf_formatlist[i].palette)
+			return palette;
+		i++;
+	}
+	return 0;
+}
+
+
+/*--------------------------------------------------------------------------
+  Return the depth corresponding to the given palette.
+  Palette _must_ be supported !
+  --------------------------------------------------------------------------*/
+static inline u16 w9968cf_valid_depth(u16 palette)
+{
+	u8 i=0;
+	while (w9968cf_formatlist[i].palette != palette)
+		i++;
+
+	return w9968cf_formatlist[i].depth;
+}
+
+
+/*--------------------------------------------------------------------------
+  Return non-zero if the format requires decompression, 0 otherwise.
+  --------------------------------------------------------------------------*/
+static inline u8 w9968cf_need_decompression(u16 palette)
+{
+	u8 i = 0;
+	while (w9968cf_formatlist[i].palette != 0) {
+		if (palette == w9968cf_formatlist[i].palette)
+			return w9968cf_formatlist[i].compression;
+		i++;
+	}
+	return 0;
+}
+
+
 /*-------------------------------------------------------------------------- 
   Adjust the asked values for window width and height.
   Return 0 on success, -1 otherwise.
@@ -2022,12 +1997,10 @@
 	if ((*width < cam->minwidth) || (*height < cam->minheight))
 		return -ERANGE;
 
-	maxw = cam->upscaling && !(cam->vpp_flag & VPP_DECOMPRESSION) &&
-	       w9968cf_vpp ? max((u16)W9968CF_MAX_WIDTH, cam->maxwidth)
-	                   : cam->maxwidth;
-	maxh = cam->upscaling && !(cam->vpp_flag & VPP_DECOMPRESSION) &&
-	       w9968cf_vpp ? max((u16)W9968CF_MAX_HEIGHT, cam->maxheight)
-	                   : cam->maxheight;
+	maxw = cam->upscaling && !(cam->vpp_flag & VPP_DECOMPRESSION)
+	       && w9968cf_vppmod_present ? W9968CF_MAX_WIDTH : cam->maxwidth;
+	maxh = cam->upscaling && !(cam->vpp_flag & VPP_DECOMPRESSION)
+	       && w9968cf_vppmod_present ? W9968CF_MAX_HEIGHT : cam->maxheight;
 
 	if (*width > maxw)
 		*width = maxw;
@@ -2039,7 +2012,7 @@
 		*height &= ~15L;
 	}
 
-	PDBGG("Window size adjusted w=%u, h=%u ", *width, *height)
+	PDBGG("Window size adjusted w=%d, h=%d ", *width, *height)
 
 	return 0;
 }
@@ -2078,7 +2051,7 @@
 
 	spin_unlock_irqrestore(&cam->flist_lock, lock_flags);
 
-	DBG(6, "Frame #%u pushed into the FIFO list. Position %u", f_num, f)
+	DBG(6, "Frame #%d pushed into the FIFO list. Position %d.", f_num, f)
 }
 
 
@@ -2102,7 +2075,7 @@
 
 	spin_unlock(&cam->flist_lock);
 
-	DBG(6,"Popped frame #%d from the list", (*framep)->number)
+	DBG(6,"Popped frame #%zd from the list.",*framep-&cam->frame[0])
 }
 
 
@@ -2114,7 +2087,7 @@
 w9968cf_postprocess_frame(struct w9968cf_device* cam, 
                           struct w9968cf_frame_t* fr)
 {
-	void *pIn = fr->buffer, *pOut = cam->frame_vpp.buffer, *tmp;
+	void *pIn = fr->buffer, *pOut = cam->vpp_buffer, *tmp;
 	u16 w = cam->window.width,
 	    h = cam->window.height,
 	    d = cam->picture.depth,
@@ -2130,41 +2103,41 @@
 	if (cam->vpp_flag & VPP_DECOMPRESSION) {
 		memcpy(pOut, pIn, fr->length);
 		_PSWAP(pIn, pOut)
-		err = w9968cf_vpp->decode(pIn, fr->length, hw_w, hw_h, pOut);
-		PDBGG("Compressed frame length: %lu",(unsigned long)fr->length)
+		err = (*w9968cf_vpp_decode)(pIn, fr->length, hw_w, hw_h, pOut);
+		PDBGG("Compressed frame length: %li",(unsigned long)fr->length)
 		fr->length = (hw_w*hw_h*hw_d)/8;
 		_PSWAP(pIn, pOut)
 		if (err) {
 			DBG(4, "An error occurred while decoding the frame: "
-			       "%s", symbolic(decoder_errlist, err))
+			       "%s.", symbolic(decoder_errlist, err))
 			return err;
 		} else
 			DBG(6, "Frame decoded")
 	}
 
 	if (cam->vpp_flag & VPP_SWAP_YUV_BYTES) {
-		w9968cf_vpp->swap_yuvbytes(pIn, fr->length);
-		DBG(6, "Original UYVY component ordering changed")
+		(*w9968cf_vpp_swap_yuvbytes)(pIn, fr->length);
+		DBG(6, "Original UYVY component ordering changed.")
 	}
 
 	if (cam->vpp_flag & VPP_UPSCALE) {
-		w9968cf_vpp->scale_up(pIn, pOut, hw_w, hw_h, hw_d, w, h);
+		(*w9968cf_vpp_scale_up)(pIn, pOut, hw_w, hw_h, hw_d, w, h);
 		fr->length = (w*h*hw_d)/8;
 		_PSWAP(pIn, pOut)
-		DBG(6, "Vertical up-scaling done: %u,%u,%ubpp->%u,%u",
+		DBG(6, "Vertical up-scaling done: %d,%d,%dbpp->%d,%d",
 		    hw_w, hw_h, hw_d, w, h)
 	}
 
 	if (cam->vpp_flag & VPP_UYVY_TO_RGBX) {
-		w9968cf_vpp->uyvy_to_rgbx(pIn, fr->length, pOut, fmt, rgb);
+		(*w9968cf_vpp_uyvy_to_rgbx)(pIn, fr->length, pOut, fmt, rgb);
 		fr->length = (w*h*d)/8;
 		_PSWAP(pIn, pOut)
-		DBG(6, "UYVY-16bit to %s conversion done", 
+		DBG(6, "UYVY-16bit to %s conversion done.", 
 		    symbolic(v4l1_plist, fmt))
 	}
 
 	if (pOut == fr->buffer)
-		memcpy(fr->buffer, cam->frame_vpp.buffer, fr->length);
+		memcpy(fr->buffer, cam->vpp_buffer, fr->length);
 
 	return 0;
 }
@@ -2172,7 +2145,7 @@
 
 
 /****************************************************************************
- * Image sensor control routines                                            *
+ * CMOS sensor control routines                                             *
  ****************************************************************************/
 
 static int 
@@ -2206,23 +2179,23 @@
 }
 
 
-static int
+static inline int
 w9968cf_sensor_cmd(struct w9968cf_device* cam, unsigned int cmd, void* arg)
 {
 	struct i2c_client* c = cam->sensor_client;
 	int rc = 0;
 
-	if (!c || !c->driver || !c->driver->command)
-		return -EINVAL;
-
-	rc = c->driver->command(c, cmd, arg);
-	/* The I2C driver returns -EPERM on non-supported controls */
-	return (rc < 0 && rc != -EPERM) ? rc : 0;
+	if (c->driver->command) {
+		rc = c->driver->command(cam->sensor_client, cmd, arg);
+		/* The I2C driver returns -EPERM on non-supported controls */
+		return (rc < 0 && rc != -EPERM) ? rc : 0;
+	} else
+		return -ENODEV;
 }
 
 
 /*--------------------------------------------------------------------------
-  Update some settings of the image sensor.
+  Update some settings of the CMOS sensor.
   Returns: 0 on success, a negative number otherwise.
   --------------------------------------------------------------------------*/
 static int w9968cf_sensor_update_settings(struct w9968cf_device* cam)
@@ -2270,7 +2243,7 @@
 
 
 /*--------------------------------------------------------------------------
-  Get some current picture settings from the image sensor and update the
+  Get some current picture settings from the CMOS sensor and update the
   internal 'picture' structure of the camera.
   Returns: 0 on success, a negative number otherwise.
   --------------------------------------------------------------------------*/
@@ -2298,10 +2271,10 @@
 		return err;
 	cam->picture.hue = v;
 
-	DBG(5, "Got picture settings from the image sensor")
+	DBG(5, "Got picture settings from the CMOS sensor.")
 
 	PDBGG("Brightness, contrast, hue, colour, whiteness are "
-	      "%u,%u,%u,%u,%u", cam->picture.brightness,cam->picture.contrast,
+	      "%d,%d,%d,%d,%d.", cam->picture.brightness,cam->picture.contrast,
 	      cam->picture.hue, cam->picture.colour, cam->picture.whiteness)
 
 	return 0;
@@ -2309,7 +2282,7 @@
 
 
 /*--------------------------------------------------------------------------
-  Update picture settings of the image sensor.
+  Update picture settings of the CMOS sensor.
   Returns: 0 on success, a negative number otherwise.
   --------------------------------------------------------------------------*/
 static int
@@ -2324,7 +2297,7 @@
 		                                 pict.contrast);
 		if (err)
 			goto fail;
-		DBG(4, "Contrast changed from %u to %u",
+		DBG(4, "Contrast changed from %d to %d.",
 		    cam->picture.contrast, pict.contrast)
 		cam->picture.contrast = pict.contrast;
 	}
@@ -2335,7 +2308,7 @@
 		                                 pict.brightness);
 		if (err)
 			goto fail;
-		DBG(4, "Brightness changed from %u to %u",
+		DBG(4, "Brightness changed from %d to %d.",
 		    cam->picture.brightness, pict.brightness)
 		cam->picture.brightness = pict.brightness;
 	}
@@ -2345,7 +2318,7 @@
 		                                 pict.colour);
 		if (err)
 			goto fail;
-		DBG(4, "Colour changed from %u to %u",
+		DBG(4, "Colour changed from %d to %d.",
 		    cam->picture.colour, pict.colour)
 		cam->picture.colour = pict.colour;
 	}
@@ -2355,7 +2328,7 @@
 		                                 pict.hue);
 		if (err)
 			goto fail;
-		DBG(4, "Hue changed from %u to %u",
+		DBG(4, "Hue changed from %d to %d.",
 		    cam->picture.hue, pict.hue)
 		cam->picture.hue = pict.hue;
 	}
@@ -2363,7 +2336,7 @@
 	return 0;
 
 fail:
-	DBG(4, "Failed to change sensor picture setting")
+	DBG(4, "Failed to change sensor picture setting.")
 	return err;
 }
 
@@ -2374,7 +2347,7 @@
  ****************************************************************************/
 
 /*--------------------------------------------------------------------------
-  This function is called when a supported image sensor is detected.
+  This function is called when a supported CMOS sensor is detected.
   Return 0 if the initialization succeeds, a negative number otherwise.
   --------------------------------------------------------------------------*/
 static int w9968cf_sensor_init(struct w9968cf_device* cam)
@@ -2404,7 +2377,7 @@
 			cam->minheight = 48;
 			break;
 		default:
-			DBG(1, "Not supported image sensor detected for %s",
+			DBG(1, "Not supported CMOS sensor detected for %s.",
 			    symbolic(camlist, cam->id))
 			return -EINVAL;
 	}
@@ -2414,7 +2387,7 @@
 		case CC_OV7620:
 			cam->start_cropx = 287;
 			cam->start_cropy = 35;
-			/* Seems to work around a bug in the image sensor */
+			/* Seems to work around a bug in the CMOS sensor */
 			cam->vs_polarity = 1;
 			cam->hs_polarity = 1;
 			break;
@@ -2433,14 +2406,14 @@
 
 	cam->sensor_initialized = 1;
 
-	DBG(2, "%s image sensor initialized", symbolic(senlist, cam->sensor))
+	DBG(2, "%s CMOS sensor initialized.", symbolic(senlist, cam->sensor))
 	return 0;
 
 error:
 	cam->sensor_initialized = 0;
 	cam->sensor = CC_UNKNOWN;
-	DBG(1, "Image sensor initialization failed for %s (/dev/video%d). "
-	       "Try to detach and attach this device again",
+	DBG(1, "CMOS sensor initialization failed for %s (/dev/video%d). "
+	       "Try to detach and attach this device again.",
 	    symbolic(camlist, cam->id), cam->v4ldev->minor)
 	return err;
 }
@@ -2464,6 +2437,7 @@
 
 	cam->users = 0;
 	cam->disconnected = 0;
+	cam->usbdev = udev;
 	cam->id = mod_id;
 	cam->sensor = CC_UNKNOWN;
 	cam->sensor_initialized = 0;
@@ -2548,7 +2522,6 @@
 		else
 			cam->picture.palette = W9968CF_PALETTE_DECOMP_ON;
 	}
-	cam->picture.depth = w9968cf_valid_depth(cam->picture.palette);
 
 	cam->force_rgb = (force_rgb[dev_nr] == 0 || force_rgb[dev_nr] == 1)
 	                 ? (u8)force_rgb[dev_nr] : W9968CF_FORCE_RGB;
@@ -2561,120 +2534,105 @@
 	cam->window.clipcount = 0;
 	cam->window.flags = 0;
 
-	DBG(3, "%s configured with settings #%u:",
+	/* If the video post-processing module is not present, some paramaters
+	   must be overridden: */
+	if (!w9968cf_vppmod_present) {
+		if (cam->decompression == 1)
+			cam->decompression = 2;
+		cam->upscaling = 0;
+		if (cam->picture.palette != VIDEO_PALETTE_UYVY)
+			cam->force_palette = 0;
+		cam->picture.palette = VIDEO_PALETTE_UYVY;
+	}
+
+	cam->picture.depth = w9968cf_valid_depth(cam->picture.palette);
+
+	DBG(3, "%s configured with settings #%d:", 
 	    symbolic(camlist, cam->id), dev_nr)
 	
-	DBG(3, "- Data packet size for USB isochrnous transfer: %u bytes",
+	DBG(3, "- Data packet size for USB isochrnous transfer: %d bytes.",
 	    wMaxPacketSize[cam->altsetting-1])
 	
-	DBG(3, "- Number of requested video frame buffers: %u",
+	DBG(3, "- Number of requested video frame buffers: %d", 
 	    cam->max_buffers)
 
 	if (cam->double_buffer)
-		DBG(3, "- Hardware double buffering enabled")
+		DBG(3, "- Hardware double buffering enabled.")
 	else 
-		DBG(3, "- Hardware double buffering disabled")
+		DBG(3, "- Hardware double buffering disabled.")
 
 	if (cam->filter_type == 0)
-		DBG(3, "- Video filtering disabled")
+		DBG(3, "- Video filtering disabled.")
 	else if (cam->filter_type == 1)
-		DBG(3, "- Video filtering enabled: type 1-2-1")
+		DBG(3, "- Video filtering enabled: type 1-2-1.")
 	else if (cam->filter_type == 2)
-		DBG(3, "- Video filtering enabled: type 2-3-6-3-2")
+		DBG(3, "- Video filtering enabled: type 2-3-6-3-2.")
 
 	if (cam->clamping)
-		DBG(3, "- Video data clamping (CCIR-601 format) enabled")
+		DBG(3, "- Video data clamping (CCIR-601 format) enabled.")
 	else
-		DBG(3, "- Video data clamping (CCIR-601 format) disabled")
+		DBG(3, "- Video data clamping (CCIR-601 format) disabled.")
 
 	if (cam->largeview)
-		DBG(3, "- Large view enabled")
+		DBG(3, "- Large view enabled.")
 	else
-		DBG(3, "- Large view disabled")
+		DBG(3, "- Large view disabled.")
 
 	if ((cam->decompression) == 0 && (!cam->force_palette))
-		DBG(3, "- Decompression disabled")
+		DBG(3, "- Decompression disabled.")
 	else if ((cam->decompression) == 1 && (!cam->force_palette))
-		DBG(3, "- Decompression forced")
+		DBG(3, "- Decompression forced.")
 	else if ((cam->decompression) == 2 && (!cam->force_palette))
-		DBG(3, "- Decompression allowed")
+		DBG(3, "- Decompression allowed.")
 
 	if (cam->upscaling)
-		DBG(3, "- Software image scaling enabled")
+		DBG(3, "- Software image scaling enabled.")
 	else
-		DBG(3, "- Software image scaling disabled")
+		DBG(3, "- Software image scaling disabled.")
 
 	if (cam->force_palette)
-		DBG(3, "- Image palette forced to %s",
+		DBG(3, "- Image palette forced to %s.",
 		    symbolic(v4l1_plist, cam->picture.palette))
 
 	if (cam->force_rgb)
-		DBG(3, "- RGB component ordering will be used instead of BGR")
+		DBG(3, "- RGB component ordering will be used instead of BGR.")
 
 	if (cam->auto_brt)
-		DBG(3, "- Auto brightness enabled")
+		DBG(3, "- Auto brightness enabled.")
 	else
-		DBG(3, "- Auto brightness disabled")
+		DBG(3, "- Auto brightness disabled.")
 
 	if (cam->auto_exp)
-		DBG(3, "- Auto exposure enabled")
+		DBG(3, "- Auto exposure enabled.")
 	else
-		DBG(3, "- Auto exposure disabled")
+		DBG(3, "- Auto exposure disabled.")
 
 	if (cam->backlight)
-		DBG(3, "- Backlight exposure algorithm enabled")
+		DBG(3, "- Backlight exposure algorithm enabled.")
 	else
-		DBG(3, "- Backlight exposure algorithm disabled")
+		DBG(3, "- Backlight exposure algorithm disabled.")
 
 	if (cam->mirror)
-		DBG(3, "- Mirror enabled")
+		DBG(3, "- Mirror enabled.")
 	else
-		DBG(3, "- Mirror disabled")
+		DBG(3, "- Mirror disabled.")
 
 	if (cam->bandfilt)
-		DBG(3, "- Banding filter enabled")
+		DBG(3, "- Banding filter enabled.")
 	else
-		DBG(3, "- Banding filter disabled")
+		DBG(3, "- Banding filter disabled.")
 
-	DBG(3, "- Power lighting frequency: %u", cam->lightfreq)
+	DBG(3, "- Power lighting frequency: %d", cam->lightfreq)
 
 	if (cam->clockdiv == -1)
-		DBG(3, "- Automatic clock divisor enabled")
+		DBG(3, "- Automatic clock divisor enabled.")
 	else
 		DBG(3, "- Clock divisor: %d", cam->clockdiv)
 
 	if (cam->monochrome)
-		DBG(3, "- Image sensor used as monochrome")
+		DBG(3, "- CMOS sensor used as monochrome.")
 	else
-		DBG(3, "- Image sensor not used as monochrome")
-}
-
-
-/*--------------------------------------------------------------------------
-  If the video post-processing module is not loaded, some parameters
-  must be overridden.
-  --------------------------------------------------------------------------*/
-static void w9968cf_adjust_configuration(struct w9968cf_device* cam)
-{
-	if (!w9968cf_vpp) {
-		if (cam->decompression == 1) {
-			cam->decompression = 2;
-			DBG(2, "Video post-processing module not found: "
-			       "'decompression' parameter forced to 2")
-		}
-		if (cam->upscaling) {
-			cam->upscaling = 0;
-			DBG(2, "Video post-processing module not found: "
-			       "'upscaling' parameter forced to 0")
-		}
-		if (cam->picture.palette != VIDEO_PALETTE_UYVY) {
-			cam->force_palette = 0;
-			DBG(2, "Video post-processing module not found: "
-			       "'force_palette' parameter forced to 0")
-		}
-		cam->picture.palette = VIDEO_PALETTE_UYVY;
-		cam->picture.depth = w9968cf_valid_depth(cam->picture.palette);
-	}
+		DBG(3, "- CMOS sensor not used as monochrome.")
 }
 
 
@@ -2697,6 +2655,8 @@
 	kfree(cam->data_buffer);
 
 	up(&w9968cf_devlist_sem);
+
+	DBG(5, "Resources released.")
 }
 
 
@@ -2710,44 +2670,33 @@
 	struct w9968cf_device* cam;
 	int err;
 
-	/* This the only safe way to prevent race conditions with disconnect */
-	if (!down_read_trylock(&w9968cf_disconnect))
-		return -ERESTARTSYS;
-
 	cam = (struct w9968cf_device*)video_get_drvdata(video_devdata(filp));
 
 	down(&cam->dev_sem);
 
 	if (cam->sensor == CC_UNKNOWN) {
-		DBG(2, "No supported image sensor has been detected by the "
+		DBG(2, "No supported CMOS sensor has been detected by the "
 		       "'ovcamchip' module for the %s (/dev/video%d). Make "
-		       "sure it is loaded *before* (re)connecting the camera.",
+		       "sure it is loaded *before* the 'w9968cf' module.", 
 		    symbolic(camlist, cam->id), cam->v4ldev->minor)
 		up(&cam->dev_sem);
-		up_read(&w9968cf_disconnect);
 		return -ENODEV;
 	}
 
 	if (cam->users) {
-		DBG(2, "%s (/dev/video%d) has been already occupied by '%s'",
+		DBG(2, "%s (/dev/video%d) has been already occupied by '%s'.",
 		    symbolic(camlist, cam->id),cam->v4ldev->minor,cam->command)
 		if ((filp->f_flags & O_NONBLOCK)||(filp->f_flags & O_NDELAY)) {
 			up(&cam->dev_sem);
-			up_read(&w9968cf_disconnect);
 			return -EWOULDBLOCK;
 		}
 		up(&cam->dev_sem);
-		err = wait_event_interruptible_exclusive(cam->open,
-		                                         cam->disconnected ||
-		                                         !cam->users);
-		if (err) {
-			up_read(&w9968cf_disconnect);
+		err = wait_event_interruptible(cam->open, cam->disconnected ||
+		                               (cam->users == 0));
+		if (err)
 			return err;
-		}
-		if (cam->disconnected) {
-			up_read(&w9968cf_disconnect);
+		if (cam->disconnected)
 			return -ENODEV;
-		}
 		down(&cam->dev_sem);
 	}
 
@@ -2757,9 +2706,8 @@
 	cam->streaming = 0;
 	cam->misconfigured = 0;
 
-	if (!w9968cf_vpp)
-		if ((err = w9968cf_vppmod_detect(cam)))
-			goto out;
+	if (!w9968cf_vppmod_present)
+		w9968cf_vppmod_detect();
 
 	if ((err = w9968cf_allocate_memory(cam)))
 		goto deallocate_memory;
@@ -2777,19 +2725,15 @@
 
 	init_waitqueue_head(&cam->wait_queue);
 
-	DBG(5, "Video device is open")
-
 	up(&cam->dev_sem);
-	up_read(&w9968cf_disconnect);
 
+	DBG(5, "Video device is open.")
 	return 0;
 
 deallocate_memory:
 	w9968cf_deallocate_memory(cam);
-out:
-	DBG(2, "Failed to open the video device")
+	DBG(2, "Failed to open the video device.")
 	up(&cam->dev_sem);
-	up_read(&w9968cf_disconnect);
 	return err;
 }
 
@@ -2804,8 +2748,6 @@
 
 	w9968cf_stop_transfer(cam);
 
-	w9968cf_vppmod_release(cam);
-
 	if (cam->disconnected) {
 		w9968cf_release_resources(cam);
 		up(&cam->dev_sem);
@@ -2815,16 +2757,18 @@
 
 	cam->users--;
 	w9968cf_deallocate_memory(cam);
-	wake_up_interruptible_nr(&cam->open, 1);
 
-	DBG(5, "Video device closed")
+	if (waitqueue_active(&cam->open))
+		wake_up_interruptible(&cam->open);
+
+	DBG(5, "Video device closed.")
 	up(&cam->dev_sem);
 	return 0;
 }
 
 
 static ssize_t
-w9968cf_read(struct file* filp, char __user * buf, size_t count, loff_t* f_pos)
+w9968cf_read(struct file* filp, char* buf, size_t count, loff_t* f_pos)
 {
 	struct w9968cf_device* cam;
 	struct w9968cf_frame_t* fr;
@@ -2839,7 +2783,7 @@
 		return -ERESTARTSYS;
 
 	if (cam->disconnected) {
-		DBG(2, "Device not present")
+		DBG(2, "Device not present.")
 		up(&cam->fileop_sem);
 		return -ENODEV;
 	}
@@ -2871,7 +2815,7 @@
 
 	fr = (cam->frame[0].status == F_READY) ? &cam->frame[0]:&cam->frame[1];
 
-	if (w9968cf_vpp)
+	if (w9968cf_vppmod_present)
 		w9968cf_postprocess_frame(cam, fr);
 
 	if (count > fr->length)
@@ -2886,7 +2830,7 @@
 
 	fr->status = F_UNUSED;
 
-	DBG(5, "%zu bytes read", count)
+	DBG(5, "%zd bytes read.", count)
 
 	up(&cam->fileop_sem);
 	return count;
@@ -2898,25 +2842,25 @@
 	struct w9968cf_device* cam = (struct w9968cf_device*)
 	                             video_get_drvdata(video_devdata(filp));
 	unsigned long vsize = vma->vm_end - vma->vm_start,
-	              psize = cam->nbuffers * cam->frame[0].size,
+	              psize = cam->nbuffers * w9968cf_get_max_bufsize(cam),
 	              start = vma->vm_start,
 	              pos = (unsigned long)cam->frame[0].buffer,
 	              page;
 
 	if (cam->disconnected) {
-		DBG(2, "Device not present")
+		DBG(2, "Device not present.")
 		return -ENODEV;
 	}
 
 	if (cam->misconfigured) {
-		DBG(2, "The camera is misconfigured. Close and open it again")
+		DBG(2, "The camera is misconfigured. Close and open it again.")
 		return -EIO;
 	}
 
-	PDBGG("mmapping %lu bytes...", vsize)
+	PDBGG("mmapping %li bytes...", vsize)
 
-	if (vsize > psize - (vma->vm_pgoff << PAGE_SHIFT))
-		return -EINVAL;
+        if (vsize > psize - (vma->vm_pgoff << PAGE_SHIFT))
+		return -EAGAIN;
 
 	while (vsize > 0) {
 		page = kvirt_to_pa(pos) + vma->vm_pgoff;
@@ -2925,10 +2869,10 @@
 			return -EAGAIN;
 		start += PAGE_SIZE;
 		pos += PAGE_SIZE;
-		vsize -= PAGE_SIZE;
+		vsize = (vsize > PAGE_SIZE) ? vsize-PAGE_SIZE : 0;
 	}
 
-	DBG(5, "mmap method successfully called")
+	DBG(5, "mmap method successfully called.")
 	return 0;
 }
 
@@ -2946,7 +2890,7 @@
 		return -ERESTARTSYS;
 
 	if (cam->disconnected) {
-		DBG(2, "Device not present")
+		DBG(2, "Device not present.")
 		up(&cam->fileop_sem);
 		return -ENODEV;
 	}
@@ -2957,15 +2901,16 @@
 		return -EIO;
 	}
 
-	err = w9968cf_v4l_ioctl(inode, filp, cmd, (void __user *)arg);
+	err = w9968cf_v4l_ioctl(inode, filp, cmd, (void* )arg);
 
 	up(&cam->fileop_sem);
 	return err;
 }
 
 
-static int w9968cf_v4l_ioctl(struct inode* inode, struct file* filp,
-                             unsigned int cmd, void __user * arg)
+static int 
+w9968cf_v4l_ioctl(struct inode* inode, struct file* filp,
+                  unsigned int cmd, void* arg)
 {
 	struct w9968cf_device* cam;
 	const char* v4l1_ioctls[] = {
@@ -2996,17 +2941,15 @@
 		};
 		sprintf(cap.name, "W996[87]CF USB Camera #%d", 
 		        cam->v4ldev->minor);
-		cap.maxwidth = (cam->upscaling && w9968cf_vpp)
-		               ? max((u16)W9968CF_MAX_WIDTH, cam->maxwidth) 
-		                 : cam->maxwidth;
-		cap.maxheight = (cam->upscaling && w9968cf_vpp)
-		                ? max((u16)W9968CF_MAX_HEIGHT, cam->maxheight)
-		                  : cam->maxheight;
+		cap.maxwidth = (cam->upscaling && w9968cf_vppmod_present)
+		               ? W9968CF_MAX_WIDTH : cam->maxwidth;
+		cap.maxheight = (cam->upscaling && w9968cf_vppmod_present)
+		                ? W9968CF_MAX_HEIGHT : cam->maxheight;
 
 		if (copy_to_user(arg, &cap, sizeof(cap)))
 			return -EFAULT;
 
-		DBG(5, "VIDIOCGCAP successfully called")
+		DBG(5, "VIDIOCGCAP successfully called.")
 		return 0;
 	}
 
@@ -3028,7 +2971,7 @@
 		if (copy_to_user(arg, &chan, sizeof(chan)))
 			return -EFAULT;
 
-		DBG(5, "VIDIOCGCHAN successfully called")
+		DBG(5, "VIDIOCGCHAN successfully called.")
 		return 0;
 	}
 
@@ -3042,7 +2985,7 @@
 		if (chan.channel != 0)
 			return -EINVAL;
 
-		DBG(5, "VIDIOCSCHAN successfully called")
+		DBG(5, "VIDIOCSCHAN successfully called.")
 		return 0;
 	}
 
@@ -3054,7 +2997,7 @@
 		if (copy_to_user(arg, &cam->picture, sizeof(cam->picture)))
 			return -EFAULT;
 
-		DBG(5, "VIDIOCGPICT successfully called")
+		DBG(5, "VIDIOCGPICT successfully called.")
 		return 0;
 	}
 
@@ -3066,16 +3009,16 @@
 		if (copy_from_user(&pict, arg, sizeof(pict)))
 			return -EFAULT;
 
-		if ( (cam->force_palette || !w9968cf_vpp) 
+		if ( (cam->force_palette || !w9968cf_vppmod_present) 
 		     && pict.palette != cam->picture.palette ) {
-			DBG(4, "Palette %s rejected: only %s is allowed",
+			DBG(4, "Palette %s rejected. Only %s is allowed.",
 			    symbolic(v4l1_plist, pict.palette),
 			    symbolic(v4l1_plist, cam->picture.palette))
 			return -EINVAL;
 		}
 
 		if (!w9968cf_valid_palette(pict.palette)) {
-			DBG(4, "Palette %s not supported. VIDIOCSPICT failed",
+			DBG(4, "Palette %s not supported. VIDIOCSPICT failed.",
 			    symbolic(v4l1_plist, pict.palette))
 			return -EINVAL;
 		}
@@ -3084,14 +3027,14 @@
 		   if (cam->decompression == 0) {
 		      if (w9968cf_need_decompression(pict.palette)) {
 		         DBG(4, "Decompression disabled: palette %s is not "
-		                "allowed. VIDIOCSPICT failed",
+		                "allowed. VIDIOCSPICT failed.",
 		             symbolic(v4l1_plist, pict.palette))
 		         return -EINVAL;
 		      }
 		   } else if (cam->decompression == 1) {
 		      if (!w9968cf_need_decompression(pict.palette)) {
 		         DBG(4, "Decompression forced: palette %s is not "
-		                "allowed. VIDIOCSPICT failed",
+		                "allowed. VIDIOCSPICT failed.",
 		             symbolic(v4l1_plist, pict.palette))
 		         return -EINVAL;
 		      }
@@ -3099,8 +3042,8 @@
 		}
 
 		if (pict.depth != w9968cf_valid_depth(pict.palette)) {
-			DBG(4, "Requested depth %u bpp is not valid for %s "
-			       "palette: ignored and changed to %u bpp", 
+			DBG(4, "Requested depth %d bpp is not valid for %s "
+			       "palette: ignored and changed to %d bpp.", 
 			    pict.depth, symbolic(v4l1_plist, pict.palette),
 			    w9968cf_valid_depth(pict.palette))
 			pict.depth = w9968cf_valid_depth(pict.palette);
@@ -3133,7 +3076,7 @@
 			return -EIO;
 
 
-		DBG(5, "VIDIOCSPICT successfully called")
+		DBG(5, "VIDIOCSPICT successfully called.")
 		return 0;
 	}
 
@@ -3145,8 +3088,8 @@
 		if (copy_from_user(&win, arg, sizeof(win)))
 			return -EFAULT;
 
-		DBG(6, "VIDIOCSWIN called: clipcount=%d, flags=%u, "
-		       "x=%u, y=%u, %ux%u", win.clipcount, win.flags,
+		DBG(6, "VIDIOCSWIN called: clipcount=%d, flags=%d, "
+		       "x=%d, y=%d, %dx%d", win.clipcount, win.flags,
 		    win.x, win.y, win.width, win.height)
 
 		if (win.clipcount != 0 || win.flags != 0)
@@ -3154,8 +3097,8 @@
 
 		if ((err = w9968cf_adjust_window_size(cam, (u16*)&win.width,
 		                                      (u16*)&win.height))) {
-			DBG(4, "Resolution not supported (%ux%u). "
-			       "VIDIOCSWIN failed", win.width, win.height)
+			DBG(4, "Resolution not supported (%dx%d)."
+			       "VIDIOCSWIN failed.", win.width, win.height)
 			return err;
 		}
 
@@ -3199,7 +3142,7 @@
 		if (copy_to_user(arg,&cam->window,sizeof(struct video_window)))
 			return -EFAULT;
 
-		DBG(5, "VIDIOCGWIN successfully called")
+		DBG(5, "VIDIOCGWIN successfully called.")
 		return 0;
 	}
 
@@ -3208,7 +3151,7 @@
 		struct video_mbuf mbuf;
 		u8 i;
 
-		mbuf.size = cam->nbuffers * cam->frame[0].size;
+		mbuf.size = cam->nbuffers * w9968cf_get_max_bufsize(cam);
 		mbuf.frames = cam->nbuffers;
 		for (i = 0; i < cam->nbuffers; i++)
 			mbuf.offsets[i] = (unsigned long)cam->frame[i].buffer -
@@ -3217,7 +3160,7 @@
 		if (copy_to_user(arg, &mbuf, sizeof(mbuf)))
 			return -EFAULT;
 
-		DBG(5, "VIDIOCGMBUF successfully called")
+		DBG(5, "VIDIOCGMBUF successfully called.")
 		return 0;
 	}
 
@@ -3230,19 +3173,19 @@
 		if (copy_from_user(&mmap, arg, sizeof(mmap)))
 			return -EFAULT;
 
-		DBG(6, "VIDIOCMCAPTURE called: frame #%u, format=%s, %dx%d",
+		DBG(6, "VIDIOCMCAPTURE called: frame #%d, format=%s, %dx%d",
 		    mmap.frame, symbolic(v4l1_plist, mmap.format), 
 		    mmap.width, mmap.height)
 
 		if (mmap.frame >= cam->nbuffers) {
-			DBG(4, "Invalid frame number (%u). "
-			       "VIDIOCMCAPTURE failed", mmap.frame)
+			DBG(4, "Invalid frame number (%d). "
+			       "VIDIOCMCAPTURE failed.", mmap.frame)
 			return -EINVAL;
 		}
 
 		if (mmap.format!=cam->picture.palette && 
-		    (cam->force_palette || !w9968cf_vpp)) {
-			DBG(4, "Palette %s rejected: only %s is allowed",
+		    (cam->force_palette || !w9968cf_vppmod_present)) {
+			DBG(4, "Palette %s rejected. Only %s is allowed.",
 			    symbolic(v4l1_plist, mmap.format),
 			    symbolic(v4l1_plist, cam->picture.palette))
 			return -EINVAL;
@@ -3250,7 +3193,7 @@
 
 		if (!w9968cf_valid_palette(mmap.format)) {
 			DBG(4, "Palette %s not supported. "
-			       "VIDIOCMCAPTURE failed", 
+			       "VIDIOCMCAPTURE failed.", 
 			    symbolic(v4l1_plist, mmap.format))
 			return -EINVAL;
 		}
@@ -3259,14 +3202,14 @@
 		   if (cam->decompression == 0) {
 		      if (w9968cf_need_decompression(mmap.format)) {
 		         DBG(4, "Decompression disabled: palette %s is not "
-		                "allowed. VIDIOCSPICT failed",
+		                "allowed. VIDIOCSPICT failed.",
 		             symbolic(v4l1_plist, mmap.format))
 		         return -EINVAL;
 		      }
 		   } else if (cam->decompression == 1) {
 		      if (!w9968cf_need_decompression(mmap.format)) {
 		         DBG(4, "Decompression forced: palette %s is not "
-		                "allowed. VIDIOCSPICT failed",
+		                "allowed. VIDIOCSPICT failed.",
 		             symbolic(v4l1_plist, mmap.format))
 		         return -EINVAL;
 		      }
@@ -3276,7 +3219,7 @@
 		if ((err = w9968cf_adjust_window_size(cam, (u16*)&mmap.width, 
 		                                      (u16*)&mmap.height))) {
 			DBG(4, "Resolution not supported (%dx%d). "
-			       "VIDIOCMCAPTURE failed",
+			       "VIDIOCMCAPTURE failed.",
 			    mmap.width, mmap.height)
 			return err;
 		}
@@ -3293,7 +3236,7 @@
 			if(*cam->requested_frame
 			   || cam->frame_current->queued) {
 				DBG(6, "VIDIOCMCAPTURE. Change settings for "
-				       "frame #%u: %dx%d, format %s. Wait...",
+				       "frame #%d: %dx%d, format %s. Wait...",
 				    mmap.frame, mmap.width, mmap.height,
 			            symbolic(v4l1_plist, mmap.format))
 				err = wait_event_interruptible
@@ -3328,7 +3271,7 @@
 
 		} else 	if (fr->queued) {
 
-			DBG(6, "Wait until frame #%u is free", mmap.frame)
+			DBG(6, "Wait until frame #%d is free.", mmap.frame)
 			
 			err = wait_event_interruptible(cam->wait_queue, 
 			                               cam->disconnected ||
@@ -3340,7 +3283,7 @@
 		}
 
 		w9968cf_push_frame(cam, mmap.frame);
-		DBG(5, "VIDIOCMCAPTURE(%u): successfully called", mmap.frame)
+		DBG(5, "VIDIOCMCAPTURE(%d): successfully called.", mmap.frame)
 		return 0;
 	}
 
@@ -3354,19 +3297,19 @@
 			return -EFAULT;
 
 		if (f_num >= cam->nbuffers) {
-			DBG(4, "Invalid frame number (%u). "
-			       "VIDIOCMCAPTURE failed", f_num)
+			DBG(4, "Invalid frame number (%d). "
+			       "VIDIOCMCAPTURE failed.", f_num)
 			return -EINVAL;
 		}
 
-		DBG(6, "VIDIOCSYNC called for frame #%u", f_num)
+		DBG(6, "VIDIOCSYNC called for frame #%d", f_num)
 
 		fr = &cam->frame[f_num];
 
 		switch (fr->status) {
 		case F_UNUSED:
 			if (!fr->queued) {
-				DBG(4, "VIDIOSYNC: Frame #%u not requested!",
+				DBG(4, "VIDIOSYNC: Frame #%d not requested!",
 				    f_num)
 				return -EFAULT;
 			}
@@ -3384,12 +3327,12 @@
 			break;
 		}
 
-		if (w9968cf_vpp)
+		if (w9968cf_vppmod_present)
 			w9968cf_postprocess_frame(cam, fr);
 
 		fr->status = F_UNUSED;
 
-		DBG(5, "VIDIOCSYNC(%u) successfully called", f_num)
+		DBG(5, "VIDIOCSYNC(%d) successfully called.", f_num)
 		return 0;
 	}
 
@@ -3406,7 +3349,7 @@
 		if (copy_to_user(arg, &unit, sizeof(unit)))
 			return -EFAULT;
 
-		DBG(5, "VIDIOCGUNIT successfully called")
+		DBG(5, "VIDIOCGUNIT successfully called.")
 		return 0;
 	}
 
@@ -3418,7 +3361,7 @@
 		if (clear_user(arg, sizeof(struct video_buffer)))
 			return -EFAULT;
 
-		DBG(5, "VIDIOCGFBUF successfully called")
+		DBG(5, "VIDIOCGFBUF successfully called.")
 		return 0;
 	}
 
@@ -3428,7 +3371,7 @@
 		if (copy_from_user(&tuner, arg, sizeof(tuner)))
 			return -EFAULT;
 
-		if (tuner.tuner != 0)
+		if (tuner.tuner != 0);
 			return -EINVAL;
 
 		strcpy(tuner.name, "no_tuner");
@@ -3441,7 +3384,7 @@
 		if (copy_to_user(arg, &tuner, sizeof(tuner)))
 			return -EFAULT;
 
-		DBG(5, "VIDIOCGTUNER successfully called")
+		DBG(5, "VIDIOCGTUNER successfully called.")
 		return 0;
 	}
 
@@ -3457,7 +3400,7 @@
 		if (tuner.mode != VIDEO_MODE_AUTO)
 			return -EINVAL;
 
-		DBG(5, "VIDIOCSTUNER successfully called")
+		DBG(5, "VIDIOCSTUNER successfully called.")
 		return 0;
 	}
 
@@ -3477,7 +3420,7 @@
 		       "(type 0x%01X, "
 		       "n. 0x%01X, "
 		       "dir. 0x%01X, " 
-		       "size 0x%02X)",
+		       "size 0x%02X).",
 		    V4L1_IOCTL(cmd),
 		    _IOC_TYPE(cmd),_IOC_NR(cmd),_IOC_DIR(cmd),_IOC_SIZE(cmd))
 
@@ -3488,7 +3431,7 @@
 		       "type 0x%01X, "
 		       "n. 0x%01X, "
 		       "dir. 0x%01X, "
-		       "size 0x%02X",
+		       "size 0x%02X.",
 		    V4L1_IOCTL(cmd),
 		    _IOC_TYPE(cmd),_IOC_NR(cmd),_IOC_DIR(cmd),_IOC_SIZE(cmd))
 
@@ -3534,27 +3477,15 @@
 	if (udev->descriptor.idVendor  == winbond_id_table[0].idVendor &&
 	    udev->descriptor.idProduct == winbond_id_table[0].idProduct)
 		mod_id = W9968CF_MOD_CLVBWGP; /* see camlist[] table */
+
 	else if (udev->descriptor.idVendor  == winbond_id_table[1].idVendor &&
 	         udev->descriptor.idProduct == winbond_id_table[1].idProduct)
 		mod_id = W9968CF_MOD_GENERIC; /* see camlist[] table */
+
 	else
 		return -ENODEV;
 
-	cam = (struct w9968cf_device*)
-	          kmalloc(sizeof(struct w9968cf_device), GFP_KERNEL);
-	if (!cam)
-		return -ENOMEM;
-
-	memset(cam, 0, sizeof(*cam));
-
-	init_MUTEX(&cam->dev_sem);
-	down(&cam->dev_sem);
-
-	cam->usbdev = udev;
-	/* NOTE: a local copy is used to avoid possible race conditions */
-	memcpy(&cam->dev, &udev->dev, sizeof(struct device));
-
-	DBG(2, "%s detected", symbolic(camlist, mod_id))
+	DBG(2, "%s detected.", symbolic(camlist, mod_id))
 
 	if (simcams > W9968CF_MAX_DEVICES)
 		simcams = W9968CF_SIMCAMS;
@@ -3567,15 +3498,27 @@
 
 	if (sc >= simcams) {
 		DBG(2, "Device rejected: too many connected cameras "
-		       "(max. %u)", simcams)
-		err = -EPERM;
+		       "(max. %d)", simcams)
+		return -EPERM;
+	}
+
+	cam = (struct w9968cf_device*)
+	          kmalloc(sizeof(struct w9968cf_device), GFP_KERNEL);
+
+	if (!cam) {
+		DBG(1, "Couldn't allocate %zd bytes of kernel memory.",
+		    sizeof(struct w9968cf_device))
+		err = -ENOMEM;
 		goto fail;
 	}
+	memset(cam, 0, sizeof(*cam));
 
+	init_MUTEX(&cam->dev_sem);
+	down(&cam->dev_sem);
 
 	/* Allocate 2 bytes of memory for camera control USB transfers */
 	if (!(cam->control_buffer = (u16*)kmalloc(2, GFP_KERNEL))) {
-		DBG(1,"Couldn't allocate memory for camera control transfers")
+		DBG(1,"Couldn't allocate memory for camera control transfers.")
 		err = -ENOMEM;
 		goto fail;
 	}
@@ -3584,7 +3527,7 @@
 	/* Allocate 8 bytes of memory for USB data transfers to the FSB */
 	if (!(cam->data_buffer = (u16*)kmalloc(8, GFP_KERNEL))) {
 		DBG(1, "Couldn't allocate memory for data "
-		       "transfers to the FSB")
+		       "transfers to the FSB.")
 		err = -ENOMEM;
 		goto fail;
 	}
@@ -3593,7 +3536,7 @@
 	/* Register the V4L device */
 	cam->v4ldev = video_device_alloc();
 	if (!cam->v4ldev) {
-		DBG(1, "Could not allocate memory for a V4L structure")
+		DBG(1, "Could not allocate memory for a V4L structure.")
 		err = -ENOMEM;
 		goto fail;
 	}
@@ -3606,20 +3549,19 @@
 	cam->v4ldev->minor = video_nr[dev_nr];
 	cam->v4ldev->release = video_device_release;
 	video_set_drvdata(cam->v4ldev, cam);
-	cam->v4ldev->dev = &cam->dev;
 
 	err = video_register_device(cam->v4ldev, VFL_TYPE_GRABBER,
 	                            video_nr[dev_nr]);
 	if (err) {
-		DBG(1, "V4L device registration failed")
+		DBG(1, "V4L device registration failed.")
 		if (err == -ENFILE && video_nr[dev_nr] == -1)
-			DBG(2, "Couldn't find a free /dev/videoX node")
+			DBG(2, "Couldn't find a free /dev/videoX node.")
 		video_nr[dev_nr] = -1;
 		dev_nr = (dev_nr < W9968CF_MAX_DEVICES-1) ? dev_nr+1 : 0;
 		goto fail;
 	}
 
-	DBG(2, "V4L device registered as /dev/video%d", cam->v4ldev->minor)
+	DBG(2, "V4L device registered as /dev/video%d.", cam->v4ldev->minor)
 
 	/* Set some basic constants */
 	w9968cf_configure_camera(cam, udev, mod_id, dev_nr);
@@ -3634,19 +3576,22 @@
 
 	w9968cf_i2c_init(cam);
 
-	usb_set_intfdata(intf, cam);
 	up(&cam->dev_sem);
+
+	usb_set_intfdata(intf, cam);
 	return 0;
 
 fail: /* Free unused memory */
-	if (cam->control_buffer)
-		kfree(cam->control_buffer);
-	if (cam->data_buffer)
-		kfree(cam->data_buffer);
-	if (cam->v4ldev)
-		video_device_release(cam->v4ldev);
-	up(&cam->dev_sem);
-	kfree(cam);
+	if (cam) {
+		if (cam->control_buffer)
+			kfree(cam->control_buffer);
+		if (cam->data_buffer)
+			kfree(cam->data_buffer);
+		if (cam->v4ldev)
+			video_device_release(cam->v4ldev);
+		up(&cam->dev_sem);
+		kfree(cam);
+	}
 	return err;
 }
 
@@ -3656,26 +3601,28 @@
 	struct w9968cf_device* cam = 
 	   (struct w9968cf_device*)usb_get_intfdata(intf);
 
-	down_write(&w9968cf_disconnect);
-
 	if (cam) {
 		/* Prevent concurrent accesses to data */
 		down(&cam->dev_sem); 
 
+		cam->streaming = 0;
 		cam->disconnected = 1;
 
 		DBG(2, "Disconnecting %s...", symbolic(camlist, cam->id))
 
-		wake_up_interruptible_all(&cam->open);
+		if (waitqueue_active(&cam->open))
+			wake_up_interruptible(&cam->open);
 
 		if (cam->users) {
 			DBG(2, "The device is open (/dev/video%d)! "
 			       "Process name: %s. Deregistration and memory "
 			       "deallocation are deferred on close.",
 			    cam->v4ldev->minor, cam->command)
+
 			cam->misconfigured = 1;
-			w9968cf_stop_transfer(cam);
-			wake_up_interruptible(&cam->wait_queue);
+
+			if (waitqueue_active(&cam->wait_queue))
+				wake_up_interruptible(&cam->wait_queue);
 		} else
 			w9968cf_release_resources(cam);
 
@@ -3685,7 +3632,7 @@
 			kfree(cam);
 	}
 
-	up_write(&w9968cf_disconnect);
+	usb_set_intfdata(intf, NULL);
 }
 
 
@@ -3703,103 +3650,48 @@
  * Module init, exit and intermodule communication                          *
  ****************************************************************************/
 
-static int w9968cf_vppmod_detect(struct w9968cf_device* cam)
+static int w9968cf_vppmod_detect(void)
 {
-	if (!w9968cf_vpp)
-		if (vppmod_load)
-			request_module("w9968cf-vpp");
-
-	down(&w9968cf_vppmod_lock);
+	w9968cf_vpp_init_decoder = inter_module_get("w9968cf_init_decoder");
 
-	if (!w9968cf_vpp) {
-		DBG(4, "Video post-processing module not detected")
-		w9968cf_adjust_configuration(cam);
-		goto out;
-	}
-
-	if (!try_module_get(w9968cf_vpp->owner)) {
-		DBG(1, "Couldn't increment the reference count of "
-		       "the video post-processing module")
-		up(&w9968cf_vppmod_lock);
-		return -ENOSYS;
-	}
-
-	w9968cf_vpp->busy++;
-
-	DBG(5, "Video post-processing module detected")
-
-out:
-	up(&w9968cf_vppmod_lock);
-	return 0;
-}
-
-
-static void w9968cf_vppmod_release(struct w9968cf_device* cam)
-{
-	down(&w9968cf_vppmod_lock);
-
-	if (w9968cf_vpp && w9968cf_vpp->busy) {
-		module_put(w9968cf_vpp->owner);
-		w9968cf_vpp->busy--;
-		wake_up(&w9968cf_vppmod_wait);
-		DBG(5, "Video post-processing module released")
+	if (!w9968cf_vpp_init_decoder) {
+		if (vppmod_load)
+			w9968cf_vpp_init_decoder = inter_module_get_request
+		                                  ( "w9968cf_init_decoder",
+			                            "w9968cf-vpp" );
+		if (!w9968cf_vpp_init_decoder) {
+			w9968cf_vppmod_present = 0;
+			DBG(4, "Video post-processing module not detected.")
+			return -ENODEV;
+		}
 	}
 
-	up(&w9968cf_vppmod_lock);
-}
+	w9968cf_vpp_check_headers = inter_module_get("w9968cf_check_headers");
+	w9968cf_vpp_decode = inter_module_get("w9968cf_decode");
+	w9968cf_vpp_swap_yuvbytes = inter_module_get("w9968cf_swap_yuvbytes");
+	w9968cf_vpp_uyvy_to_rgbx = inter_module_get("w9968cf_uyvy_to_rgbx");
+	w9968cf_vpp_scale_up = inter_module_get("w9968cf_scale_up");
 
+	w9968cf_vppmod_present = 1;
 
-int w9968cf_vppmod_register(struct w9968cf_vpp_t* vpp)
-{
-	down(&w9968cf_vppmod_lock);
+	/* Initialization */
+	(*w9968cf_vpp_init_decoder)();
 
-	if (w9968cf_vpp) {
-		KDBG(1, "Video post-processing module already registered")
-		up(&w9968cf_vppmod_lock);
-		return -EINVAL;
-	}
-
-	w9968cf_vpp = vpp;
-	w9968cf_vpp->busy = 0;
-
-	KDBG(2, "Video post-processing module registered")
-	up(&w9968cf_vppmod_lock);
+	DBG(2, "Video post-processing module detected.")
 	return 0;
 }
 
 
-int w9968cf_vppmod_deregister(struct w9968cf_vpp_t* vpp)
+static void w9968cf_vppmod_release(void)
 {
-	down(&w9968cf_vppmod_lock);
-
-	if (!w9968cf_vpp) {
-		up(&w9968cf_vppmod_lock);
-		return -EINVAL;
-	}
-
-	if (w9968cf_vpp != vpp) {
-		KDBG(1, "Only the owner can unregister the video "
-		        "post-processing module")
-		up(&w9968cf_vppmod_lock);
-		return -EINVAL;
-	}
-
-	if (w9968cf_vpp->busy) {
-		KDBG(2, "Video post-processing module busy. Wait for it to be "
-		        "released...")
-		up(&w9968cf_vppmod_lock);
-		wait_event(w9968cf_vppmod_wait, !w9968cf_vpp->busy);
-		w9968cf_vpp = NULL;
-		goto out;
-	}
-
-	w9968cf_vpp = NULL;
+	inter_module_put("w9968cf_init_decoder");
+	inter_module_put("w9968cf_check_headers");
+	inter_module_put("w9968cf_decode");
+	inter_module_put("w9968cf_swap_yuvbytes");
+	inter_module_put("w9968cf_uyvy_to_rgbx");
+	inter_module_put("w9968cf_scale_up");
 
-	up(&w9968cf_vppmod_lock);
-
-out:
-	KDBG(2, "Video post-processing module unregistered")
-	return 0;
+	DBG(2, "Video post-processing module released.")
 }
 
 
@@ -3807,14 +3699,18 @@
 {
 	int err;
 
-	KDBG(2, W9968CF_MODULE_NAME" "W9968CF_MODULE_VERSION)
-	KDBG(3, W9968CF_MODULE_AUTHOR)
+	DBG(2, W9968CF_MODULE_NAME" "W9968CF_MODULE_VERSION)
+	DBG(3, W9968CF_MODULE_AUTHOR)
 
-	if (ovmod_load)
-		request_module("ovcamchip");
+	init_MUTEX(&w9968cf_devlist_sem);
 
-	if ((err = usb_register(&w9968cf_usb_driver)))
+	w9968cf_vppmod_detect();
+
+	if ((err = usb_register(&w9968cf_usb_driver))) {
+		if (w9968cf_vppmod_present)
+			w9968cf_vppmod_release();
 		return err;
+	}
 
 	return 0;
 }
@@ -3825,13 +3721,12 @@
 	/* w9968cf_usb_disconnect() will be called */
 	usb_deregister(&w9968cf_usb_driver);
 
-	KDBG(2, W9968CF_MODULE_NAME" deregistered")
+	if (w9968cf_vppmod_present)
+		w9968cf_vppmod_release();
+
+	DBG(2, W9968CF_MODULE_NAME" deregistered.")
 }
 
 
 module_init(w9968cf_module_init);
 module_exit(w9968cf_module_exit);
-
-
-EXPORT_SYMBOL(w9968cf_vppmod_register);
-EXPORT_SYMBOL(w9968cf_vppmod_deregister);
diff -Naur linuxppc-2.6.9/drivers/usb/media/w9968cf_externaldef.h linuxppc-2.6.9-dream/drivers/usb/media/w9968cf_externaldef.h
--- linuxppc-2.6.9/drivers/usb/media/w9968cf_externaldef.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/drivers/usb/media/w9968cf_externaldef.h	2005-09-19 21:40:05.000000000 +0200
@@ -0,0 +1,94 @@
+/***************************************************************************
+ * Various definitions for compatibility with OVCAMCHIP external module.   *
+ * This file is part of the W996[87]CF driver for Linux.                   *
+ *                                                                         *
+ * The definitions have been taken from the OVCAMCHIP module written by    *
+ * Mark McClelland.                                                        *
+ *                                                                         *
+ * This program is free software; you can redistribute it and/or modify    *
+ * it under the terms of the GNU General Public License as published by    *
+ * the Free Software Foundation; either version 2 of the License, or       *
+ * (at your option) any later version.                                     *
+ *                                                                         *
+ * This program is distributed in the hope that it will be useful,         *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
+ * GNU General Public License for more details.                            *
+ *                                                                         *
+ * You should have received a copy of the GNU General Public License       *
+ * along with this program; if not, write to the Free Software             *
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
+ ***************************************************************************/
+
+#ifndef _W9968CF_EXTERNALDEF_H_
+#define _W9968CF_EXTERNALDEF_H_
+
+#include <linux/videodev.h>
+#include <linux/i2c.h>
+#include <asm/ioctl.h>
+#include <asm/types.h>
+
+#ifndef I2C_DRIVERID_OVCAMCHIP
+#	define I2C_DRIVERID_OVCAMCHIP 0xf00f
+#endif
+
+/* Controls */
+enum {
+	OVCAMCHIP_CID_CONT,       /* Contrast */
+	OVCAMCHIP_CID_BRIGHT,     /* Brightness */
+	OVCAMCHIP_CID_SAT,        /* Saturation */
+	OVCAMCHIP_CID_HUE,        /* Hue */
+	OVCAMCHIP_CID_EXP,        /* Exposure */
+	OVCAMCHIP_CID_FREQ,       /* Light frequency */
+	OVCAMCHIP_CID_BANDFILT,   /* Banding filter */
+	OVCAMCHIP_CID_AUTOBRIGHT, /* Auto brightness */
+	OVCAMCHIP_CID_AUTOEXP,    /* Auto exposure */
+	OVCAMCHIP_CID_BACKLIGHT,  /* Back light compensation */
+	OVCAMCHIP_CID_MIRROR,     /* Mirror horizontally */
+};
+
+/* I2C addresses */
+#define OV7xx0_SID   (0x42 >> 1)
+#define OV6xx0_SID   (0xC0 >> 1)
+
+/* Sensor types */
+enum {
+	CC_UNKNOWN,
+	CC_OV76BE,
+	CC_OV7610,
+	CC_OV7620,
+	CC_OV7620AE,
+	CC_OV6620,
+	CC_OV6630,
+	CC_OV6630AE,
+	CC_OV6630AF,
+};
+
+/* API */
+struct ovcamchip_control {
+	__u32 id;
+	__s32 value;
+};
+
+struct ovcamchip_window {
+	int x;
+	int y;
+	int width;
+	int height;
+	int format;
+	int quarter;  /* Scale width and height down 2x */
+
+	/* This stuff will be removed eventually */
+	int clockdiv; /* Clock divisor setting */
+};
+
+/* Commands. 
+   You must call OVCAMCHIP_CMD_INITIALIZE before any of other commands */
+#define OVCAMCHIP_CMD_Q_SUBTYPE  _IOR  (0x88, 0x00, int)
+#define OVCAMCHIP_CMD_INITIALIZE _IOW  (0x88, 0x01, int)
+#define OVCAMCHIP_CMD_S_CTRL     _IOW  (0x88, 0x02, struct ovcamchip_control)
+#define OVCAMCHIP_CMD_G_CTRL     _IOWR (0x88, 0x03, struct ovcamchip_control)
+#define OVCAMCHIP_CMD_S_MODE     _IOW  (0x88, 0x04, struct ovcamchip_window)
+#define OVCAMCHIP_MAX_CMD        _IO   (0x88, 0x3f)
+
+#endif /* _W9968CF_EXTERNALDEF_H_ */
diff -Naur linuxppc-2.6.9/drivers/usb/media/w9968cf.h linuxppc-2.6.9-dream/drivers/usb/media/w9968cf.h
--- linuxppc-2.6.9/drivers/usb/media/w9968cf.h	2004-10-18 23:53:11.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/w9968cf.h	2005-09-19 21:40:05.000000000 +0200
@@ -24,26 +24,21 @@
 #include <linux/videodev.h>
 #include <linux/usb.h>
 #include <linux/i2c.h>
-#include <linux/device.h>
 #include <linux/spinlock.h>
 #include <linux/list.h>
 #include <linux/wait.h>
 #include <linux/config.h>
 #include <linux/param.h>
-#include <linux/types.h>
-#include <linux/rwsem.h>
 #include <asm/semaphore.h>
+#include <asm/types.h>
 
-#include <media/ovcamchip.h>
-
-#include "w9968cf_vpp.h"
+#include "w9968cf_externaldef.h"
 
 
 /****************************************************************************
  * Default values                                                           *
  ****************************************************************************/
 
-#define W9968CF_OVMOD_LOAD      1  /* automatic 'ovcamchip' module loading */
 #define W9968CF_VPPMOD_LOAD     1  /* automatic 'w9968cf-vpp' module loading */
 
 /* Comment/uncomment the following line to enable/disable debugging messages */
@@ -100,8 +95,8 @@
 
 #define W9968CF_FORCE_RGB        0  /* read RGB instead of BGR, yes=1/no=0 */
 
-#define W9968CF_MAX_WIDTH      800 /* Has effect if up-scaling is on */
-#define W9968CF_MAX_HEIGHT     600 /* Has effect if up-scaling is on */
+#define W9968CF_MAX_WIDTH      800 /* should be >= 640 */
+#define W9968CF_MAX_HEIGHT     600 /* should be >= 480 */
 #define W9968CF_WIDTH          320 /* from 128 to 352, multiple of 16 */
 #define W9968CF_HEIGHT         240 /* from  96 to 288, multiple of 16 */
 
@@ -135,11 +130,13 @@
 
 #define W9968CF_MODULE_NAME     "V4L driver for W996[87]CF JPEG USB " \
                                 "Dual Mode Camera Chip"
-#define W9968CF_MODULE_VERSION  "1:1.32-basic"
+#define W9968CF_MODULE_VERSION  "v1.25-basic"
 #define W9968CF_MODULE_AUTHOR   "(C) 2002-2004 Luca Risolia"
 #define W9968CF_AUTHOR_EMAIL    "<luca.risolia@studio.unibo.it>"
 #define W9968CF_MODULE_LICENSE  "GPL"
 
+static u8 w9968cf_vppmod_present; /* status flag: yes=1, no=0 */
+
 static const struct usb_device_id winbond_id_table[] = {
 	{
 		/* Creative Labs Video Blaster WebCam Go Plus */
@@ -154,19 +151,18 @@
 	{ } /* terminating entry */
 };
 
+MODULE_DEVICE_TABLE(usb, winbond_id_table);
+
 /* W996[87]CF camera models, internal ids: */
 enum w9968cf_model_id {
 	W9968CF_MOD_GENERIC = 1, /* Generic W996[87]CF based device */
 	W9968CF_MOD_CLVBWGP = 11,/*Creative Labs Video Blaster WebCam Go Plus*/
-	W9968CF_MOD_ADPVDMA = 21, /* Aroma Digi Pen VGA Dual Mode ADG-5000 */
-	W9986CF_MOD_AAU = 31,     /* AVerMedia AVerTV USB */
-	W9968CF_MOD_CLVBWG = 34,  /* Creative Labs Video Blaster WebCam Go */
-	W9968CF_MOD_LL = 37,      /* Lebon LDC-035A */
+	W9968CF_MOD_ADPA5R = 21, /* Aroma Digi Pen ADG-5000 Refurbished */
+	W9986CF_MOD_AU = 31,     /* AVerTV USB */
+	W9968CF_MOD_CLVBWG = 34, /* Creative Labs Video Blaster WebCam Go */
+	W9968CF_MOD_DLLDK = 37,  /* Die Lebon LDC-D35A Digital Kamera */
 	W9968CF_MOD_EEEMC = 40,   /* Ezonics EZ-802 EZMega Cam */
-	W9968CF_MOD_OOE = 42,     /* OmniVision OV8610-EDE */
 	W9968CF_MOD_ODPVDMPC = 43,/* OPCOM Digi Pen VGA Dual Mode Pen Camera */
-	W9968CF_MOD_PDPII = 46,   /* Pretec Digi Pen-II */
-	W9968CF_MOD_PDP480 = 49,  /* Pretec DigiPen-480 */
 };
 
 enum w9968cf_frame_status {
@@ -177,10 +173,9 @@
 };
 
 struct w9968cf_frame_t {
+	#define W9968CF_HW_BUF_SIZE 640*480*2 /* buf.size of original frames */
 	void* buffer;
-	unsigned long size;
 	u32 length;
-	int number;
 	enum w9968cf_frame_status status;
 	struct w9968cf_frame_t* next;
 	u8 queued;
@@ -194,19 +189,12 @@
 	VPP_UYVY_TO_RGBX = 0x08,
 };
 
-static struct w9968cf_vpp_t* w9968cf_vpp;
-static DECLARE_MUTEX(w9968cf_vppmod_lock);
-static DECLARE_WAIT_QUEUE_HEAD(w9968cf_vppmod_wait);
-
-static LIST_HEAD(w9968cf_dev_list); /* head of V4L registered cameras list */
-static DECLARE_MUTEX(w9968cf_devlist_sem); /* semaphore for list traversal */
-
-static DECLARE_RWSEM(w9968cf_disconnect); /* prevent races with open() */
+struct list_head w9968cf_dev_list; /* head of V4L registered cameras list */
+LIST_HEAD(w9968cf_dev_list);
+struct semaphore w9968cf_devlist_sem; /* semaphore for list traversal */
 
 /* Main device driver structure */
 struct w9968cf_device {
-	struct device dev; /* device structure */
-
 	enum w9968cf_model_id id;   /* private device identifier */
 
 	struct video_device* v4ldev; /* -> V4L structure */
@@ -219,10 +207,10 @@
 	u16* data_buffer;                    /* -> data to send to the FSB */
 
 	struct w9968cf_frame_t frame[W9968CF_MAX_BUFFERS];
-	struct w9968cf_frame_t frame_tmp; /* temporary frame */
-	struct w9968cf_frame_t frame_vpp; /* helper frame.*/
+	struct w9968cf_frame_t frame_tmp;  /* temporary frame */
 	struct w9968cf_frame_t* frame_current; /* -> frame being grabbed */
 	struct w9968cf_frame_t* requested_frame[W9968CF_MAX_BUFFERS];
+	void* vpp_buffer; /*-> helper buf.for video post-processing routines */
 
 	u8 max_buffers,   /* number of requested buffers */
 	   force_palette, /* yes=1/no=0 */
@@ -245,7 +233,7 @@
 	    hs_polarity, /* 0=negative sync pulse, 1=positive sync pulse */
 	    vs_polarity, /* 0=negative sync pulse, 1=positive sync pulse */
 	    start_cropx, /* pixels from HS inactive edge to 1st cropped pixel*/
-	    start_cropy; /* pixels from VS inactive edge to 1st cropped pixel*/
+	    start_cropy; /* pixels from VS incative edge to 1st cropped pixel*/
 
 	enum w9968cf_vpp_flag vpp_flag; /* post-processing routines in use */
 
@@ -258,13 +246,13 @@
 
 	u8 sensor_initialized; /* flag: yes=1, no=0 */
 
-	/* Determined by the image sensor type: */
+	/* Determined by CMOS sensor type: */
 	int sensor,       /* type of image sensor chip (CC_*) */
-	    monochrome;   /* image sensor is (probably) monochrome */
-	u16 maxwidth,     /* maximum width supported by the image sensor */
-	    maxheight,    /* maximum height supported by the image sensor */
-	    minwidth,     /* minimum width supported by the image sensor */
-	    minheight;    /* minimum height supported by the image sensor */
+	    monochrome;   /* CMOS sensor is (probably) monochrome */
+	u16 maxwidth,     /* maximum width supported by the CMOS sensor */
+	    maxheight,    /* maximum height supported by the CMOS sensor */
+	    minwidth,     /* minimum width supported by the CMOS sensor */
+	    minheight;    /* minimum height supported by the CMOS sensor */
 	u8  auto_brt,     /* auto brightness enabled flag */
 	    auto_exp,     /* auto exposure enabled flag */
 	    backlight,    /* backlight exposure algorithm flag */
@@ -282,9 +270,8 @@
 	                 fileop_sem; /* for read and ioctl */
 	spinlock_t urb_lock,   /* for submit_urb() and unlink_urb() */
 	           flist_lock; /* for requested frame list accesses */
-	wait_queue_head_t open, wait_queue;
-
 	char command[16]; /* name of the program holding the device */
+	wait_queue_head_t open, wait_queue;
 };
 
 
@@ -293,47 +280,31 @@
  ****************************************************************************/
 
 #undef DBG
-#undef KDBG
 #ifdef W9968CF_DEBUG
-/* For device specific debugging messages */
-#	define DBG(level, fmt, args...)                                       \
-{                                                                             \
-	if ( ((specific_debug) && (debug == (level))) ||                      \
-	     ((!specific_debug) && (debug >= (level))) ) {                    \
-		if ((level) == 1)                                             \
-			dev_err(&cam->dev, fmt "\n", ## args);                \
-		else if ((level) == 2 || (level) == 3)                        \
-			dev_info(&cam->dev, fmt "\n", ## args);               \
-		else if ((level) == 4)                                        \
-			dev_warn(&cam->dev, fmt "\n", ## args);               \
-		else if ((level) >= 5)                                        \
-			dev_info(&cam->dev, "[%s:%d] " fmt "\n",              \
-			         __FUNCTION__, __LINE__ , ## args);           \
-	}                                                                     \
-}
-/* For generic kernel (not device specific) messages */
-#	define KDBG(level, fmt, args...)                                      \
-{                                                                             \
-	if ( ((specific_debug) && (debug == (level))) ||                      \
-	     ((!specific_debug) && (debug >= (level))) ) {                    \
-		if ((level) >= 1 && (level) <= 4)                             \
-			pr_info("w9968cf: " fmt "\n", ## args);               \
-		else if ((level) >= 5)                                        \
-			pr_debug("w9968cf: [%s:%d] " fmt "\n", __FUNCTION__,  \
-			         __LINE__ , ## args);                         \
-	}                                                                     \
+#	define DBG(level, fmt, args...) \
+{ \
+if ( ((specific_debug) && (debug == (level))) || \
+     ((!specific_debug) && (debug >= (level))) ) { \
+	if ((level) == 1) \
+		err(fmt, ## args); \
+	else if ((level) == 2 || (level) == 3) \
+		info(fmt, ## args); \
+	else if ((level) == 4) \
+		warn(fmt, ## args); \
+	else if ((level) >= 5) \
+		info("[%s:%d] " fmt, \
+		     __PRETTY_FUNCTION__, __LINE__ , ## args); \
+} \
 }
 #else
 	/* Not debugging: nothing */
 #	define DBG(level, fmt, args...) do {;} while(0);
-#	define KDBG(level, fmt, args...) do {;} while(0);
 #endif
 
 #undef PDBG
-#define PDBG(fmt, args...)                                                    \
-dev_info(&cam->dev, "[%s:%d] " fmt "\n", __FUNCTION__, __LINE__ , ## args);
-
 #undef PDBGG
+#define PDBG(fmt, args...) info("[%s:%d] "fmt, \
+	                        __PRETTY_FUNCTION__, __LINE__ , ## args);
 #define PDBGG(fmt, args...) do {;} while(0); /* nothing: it's a placeholder */
 
 #endif /* _W9968CF_H_ */
diff -Naur linuxppc-2.6.9/drivers/usb/media/w9968cf_vpp.h linuxppc-2.6.9-dream/drivers/usb/media/w9968cf_vpp.h
--- linuxppc-2.6.9/drivers/usb/media/w9968cf_vpp.h	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/media/w9968cf_vpp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/***************************************************************************
- * Interface for video post-processing functions for the W996[87]CF driver *
- * for Linux.                                                              *
- *                                                                         *
- * Copyright (C) 2002-2004 by Luca Risolia <luca.risolia@studio.unibo.it>  *
- *                                                                         *
- * This program is free software; you can redistribute it and/or modify    *
- * it under the terms of the GNU General Public License as published by    *
- * the Free Software Foundation; either version 2 of the License, or       *
- * (at your option) any later version.                                     *
- *                                                                         *
- * This program is distributed in the hope that it will be useful,         *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
- * GNU General Public License for more details.                            *
- *                                                                         *
- * You should have received a copy of the GNU General Public License       *
- * along with this program; if not, write to the Free Software             *
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
- ***************************************************************************/
-
-#ifndef _W9968CF_VPP_H_
-#define _W9968CF_VPP_H_
-
-#include <linux/module.h>
-#include <asm/types.h>
-
-struct w9968cf_vpp_t {
-	struct module* owner;
-	int (*check_headers)(const unsigned char*, const unsigned long);
-	int (*decode)(const char*, const unsigned long, const unsigned,
-	              const unsigned, char*);
-	void (*swap_yuvbytes)(void*, unsigned long);
-	void (*uyvy_to_rgbx)(u8*, unsigned long, u8*, u16, u8);
-	void (*scale_up)(u8*, u8*, u16, u16, u16, u16, u16);
-
-	u8 busy; /* read-only flag: module is/is not in use */
-};
-
-extern int w9968cf_vppmod_register(struct w9968cf_vpp_t*);
-extern int w9968cf_vppmod_deregister(struct w9968cf_vpp_t*);
-
-#endif /* _W9968CF_VPP_H_ */
diff -Naur linuxppc-2.6.9/drivers/usb/misc/auerswald.c linuxppc-2.6.9-dream/drivers/usb/misc/auerswald.c
--- linuxppc-2.6.9/drivers/usb/misc/auerswald.c	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/auerswald.c	2005-09-19 21:40:05.000000000 +0200
@@ -2,7 +2,7 @@
 /*
  *      auerswald.c  --  Auerswald PBX/System Telephone usb driver.
  *
- *      Copyright (C) 2001  Wolfgang Mes (wolfgang@iksw-muees.de)
+ *      Copyright (C) 2001  Wolfgang Mes (wolfgang@iksw-muees.de)
  *
  *      Very much code of this driver is borrowed from dabusb.c (Deti Fliegl)
  *      and from the USB Skeleton driver (Greg Kroah-Hartman). Thank you.
@@ -50,7 +50,7 @@
 /*-------------------------------------------------------------------*/
 /* Version Information */
 #define DRIVER_VERSION "0.9.11"
-#define DRIVER_AUTHOR  "Wolfgang Mes <wolfgang@iksw-muees.de>"
+#define DRIVER_AUTHOR  "Wolfgang Mes <wolfgang@iksw-muees.de>"
 #define DRIVER_DESC    "Auerswald PBX/System Telephone usb driver"
 
 /*-------------------------------------------------------------------*/
@@ -269,7 +269,7 @@
 /* Forwards */
 static void auerswald_ctrlread_complete (struct urb * urb, struct pt_regs *regs);
 static void auerswald_removeservice (pauerswald_t cp, pauerscon_t scp);
-static struct usb_driver auerswald_driver;
+extern struct usb_driver auerswald_driver;
 
 
 /*-------------------------------------------------------------------*/
@@ -699,7 +699,7 @@
 	dr->wLength = cpu_to_le16 (size);
 
 	usb_fill_control_urb (urb, dev, pipe, (unsigned char*)dr, data, size,    /* build urb */
-		          auerchain_blocking_completion, NULL);
+		          auerchain_blocking_completion,0);
 	ret = auerchain_start_wait_urb (acp, urb, timeout, &length);
 
 	usb_free_urb (urb);
@@ -1037,8 +1037,7 @@
 
         /* now extract the information */
         channelid = cp->intbufp[2];
-        bytecount = (unsigned char)cp->intbufp[3];
-        bytecount |= (unsigned char)cp->intbufp[4] << 8;
+        bytecount = le16_to_cpup (&cp->intbufp[3]);
 
         /* check the channel id */
         if (channelid >= AUH_TYPESIZE) {
@@ -1436,7 +1435,7 @@
 	/* file IO stuff */
 	file->f_pos = 0;
 	file->private_data = ccp;
-	return nonseekable_open(inode, file);
+	return 0;
 
 	/* Error exit */
 ofail:	up (&cp->mutex);
@@ -1453,8 +1452,6 @@
         audevinfo_t devinfo;
         pauerswald_t cp = NULL;
 	unsigned int u;
-	unsigned int __user *user_arg = (unsigned int __user *)arg;
-
         dbg ("ioctl");
 
 	/* get the mutexes */
@@ -1486,14 +1483,14 @@
 		u   = ccp->auerdev
 		   && (ccp->scontext.id != AUH_UNASSIGNED)
 		   && !list_empty (&cp->bufctl.free_buff_list);
-	        ret = put_user (u, user_arg);
+	        ret = put_user (u, (unsigned int *) arg);
 		break;
 
 	/* return != 0 if connected to a service channel */
 	case IOCTL_AU_CONNECT:
 		dbg ("IOCTL_AU_CONNECT");
 		u = (ccp->scontext.id != AUH_UNASSIGNED);
-	        ret = put_user (u, user_arg);
+	        ret = put_user (u, (unsigned int *) arg);
 		break;
 
 	/* return != 0 if Receive Data available */
@@ -1514,14 +1511,14 @@
 				u = 1;
 			}
 		}
-	        ret = put_user (u, user_arg);
+	        ret = put_user (u, (unsigned int *) arg);
 		break;
 
 	/* return the max. buffer length for the device */
 	case IOCTL_AU_BUFLEN:
 		dbg ("IOCTL_AU_BUFLEN");
 		u = cp->maxControlLength;
-	        ret = put_user (u, user_arg);
+	        ret = put_user (u, (unsigned int *) arg);
 		break;
 
 	/* requesting a service channel */
@@ -1530,7 +1527,7 @@
                 /* requesting a service means: release the previous one first */
 		auerswald_removeservice (cp, &ccp->scontext);
 		/* get the channel number */
-		ret = get_user (u, user_arg);
+		ret = get_user (u, (unsigned int *) arg);
 		if (ret) {
 			break;
 		}
@@ -1567,7 +1564,7 @@
         case IOCTL_AU_SLEN:
 		dbg ("IOCTL_AU_SLEN");
 		u = AUSI_DLEN;
-	        ret = put_user (u, user_arg);
+	        ret = put_user (u, (unsigned int *) arg);
 		break;
 
 	default:
@@ -1931,7 +1928,7 @@
 	struct usb_device *usbdev = interface_to_usbdev(intf);
 	pauerswald_t cp = NULL;
 	unsigned int u = 0;
-	__le16 *pbuf;
+	char *pbuf;
 	int ret;
 
 	dbg ("probe: vendor id 0x%x, device id 0x%x",
@@ -1977,7 +1974,8 @@
 	dbg ("Version is %X", cp->version);
 
 	/* allow some time to settle the device */
-	msleep(334);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(HZ/3);
 
 	/* Try to get a suitable textual description of the device */
 	/* Device name:*/
@@ -2003,7 +2001,7 @@
 	info("device is a %s", cp->dev_desc);
 
         /* get the maximum allowed control transfer length */
-        pbuf = (__le16 *) kmalloc (2, GFP_KERNEL);    /* use an allocated buffer because of urb target */
+        pbuf = (char *) kmalloc (2, GFP_KERNEL);    /* use an allocated buffer because of urb target */
         if (!pbuf) {
 		err( "out of memory");
 		goto pfail;
diff -Naur linuxppc-2.6.9/drivers/usb/misc/cytherm.c linuxppc-2.6.9-dream/drivers/usb/misc/cytherm.c
--- linuxppc-2.6.9/drivers/usb/misc/cytherm.c	2004-10-18 23:55:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/cytherm.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,430 +0,0 @@
-/* -*- linux-c -*-
- * Cypress USB Thermometer driver 
- * 
- * Copyright (c) 2004 Erik Rigtorp <erkki@linux.nu> <erik@rigtorp.com>
- * 
- * This driver works with Elektor magazine USB Interface as published in 
- * issue #291. It should also work with the original starter kit/demo board
- * from Cypress.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation, version 2.
- *
- */
-
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/usb.h>
-
-#define DRIVER_VERSION "v1.0"
-#define DRIVER_AUTHOR "Erik Rigtorp"
-#define DRIVER_DESC "Cypress USB Thermometer driver"
-
-#define USB_SKEL_VENDOR_ID	0x04b4
-#define USB_SKEL_PRODUCT_ID	0x0002
-
-static struct usb_device_id id_table [] = {
-	{ USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },
-	{ }
-};
-MODULE_DEVICE_TABLE (usb, id_table);
-
-/* Structure to hold all of our device specific stuff */
-struct usb_cytherm {
-	struct usb_device    *udev;	 /* save off the usb device pointer */
-	struct usb_interface *interface; /* the interface for this device */
-	int brightness;
-};
-
-
-/* local function prototypes */
-static int cytherm_probe(struct usb_interface *interface, 
-			 const struct usb_device_id *id);
-static void cytherm_disconnect(struct usb_interface *interface);
-
-
-/* usb specific object needed to register this driver with the usb subsystem */
-static struct usb_driver cytherm_driver = {
-	.owner =	THIS_MODULE,
-	.name =		"cytherm",
-	.probe =	cytherm_probe,
-	.disconnect =	cytherm_disconnect,
-	.id_table =	id_table,
-};
-
-/* Vendor requests */
-/* They all operate on one byte at a time */
-#define PING       0x00
-#define READ_ROM   0x01 /* Reads form ROM, value = address */
-#define READ_RAM   0x02 /* Reads form RAM, value = address */
-#define WRITE_RAM  0x03 /* Write to RAM, value = address, index = data */
-#define READ_PORT  0x04 /* Reads from port, value = address */
-#define WRITE_PORT 0x05 /* Write to port, value = address, index = data */ 
-
-
-/* Send a vendor command to device */
-static int vendor_command(struct usb_device *dev, unsigned char request, 
-			  unsigned char value, unsigned char index,
-			  void *buf, int size)
-{
-	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
-			       request, 
-			       USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_OTHER,
-			       value, 
-			       index, buf, size,
-			       HZ * USB_CTRL_GET_TIMEOUT);
-}
-
-
-
-#define BRIGHTNESS 0x2c     /* RAM location for brightness value */
-#define BRIGHTNESS_SEM 0x2b /* RAM location for brightness semaphore */
-
-static ssize_t show_brightness(struct device *dev, char *buf)
-{
-	struct usb_interface *intf = to_usb_interface(dev);    
-	struct usb_cytherm *cytherm = usb_get_intfdata(intf);     
-
-	return sprintf(buf, "%i", cytherm->brightness);
-}
-
-static ssize_t set_brightness(struct device *dev, const char *buf, 
-			      size_t count)
-{
-	struct usb_interface *intf = to_usb_interface(dev);
-	struct usb_cytherm *cytherm = usb_get_intfdata(intf);
-
-	unsigned char *buffer;
-	int retval;
-   
-	buffer = kmalloc(8, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&cytherm->udev->dev, "out of memory\n");
-		return 0;
-	}
-
-	cytherm->brightness = simple_strtoul(buf, NULL, 10);
-   
-	if (cytherm->brightness > 0xFF)
-		cytherm->brightness = 0xFF;
-	else if (cytherm->brightness < 0)
-		cytherm->brightness = 0;
-   
-	/* Set brightness */
-	retval = vendor_command(cytherm->udev, WRITE_RAM, BRIGHTNESS, 
-				cytherm->brightness, buffer, 8);
-	if (retval)
-		dev_dbg(&cytherm->udev->dev, "retval = %d\n", retval);
-	/* Inform C that we have changed the brightness setting */
-	retval = vendor_command(cytherm->udev, WRITE_RAM, BRIGHTNESS_SEM,
-				0x01, buffer, 8);
-	if (retval)
-		dev_dbg(&cytherm->udev->dev, "retval = %d\n", retval);
-   
-	kfree(buffer);
-   
-	return count;
-}
-
-static DEVICE_ATTR(brightness, S_IRUGO | S_IWUSR | S_IWGRP, 
-		   show_brightness, set_brightness);
-
-
-#define TEMP 0x33 /* RAM location for temperature */
-#define SIGN 0x34 /* RAM location for temperature sign */
-
-static ssize_t show_temp(struct device *dev, char *buf)
-{
-
-	struct usb_interface *intf = to_usb_interface(dev);
-	struct usb_cytherm *cytherm = usb_get_intfdata(intf);
-
-	int retval;
-	unsigned char *buffer;
-
-	int temp, sign;
-   
-	buffer = kmalloc(8, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&cytherm->udev->dev, "out of memory\n");
-		return 0;
-	}
-
-	/* read temperature */
-	retval = vendor_command(cytherm->udev, READ_RAM, TEMP, 0, buffer, 8);
-	if (retval)
-		dev_dbg(&cytherm->udev->dev, "retval = %d\n", retval);
-	temp = buffer[1];
-   
-	/* read sign */
-	retval = vendor_command(cytherm->udev, READ_RAM, SIGN, 0, buffer, 8);
-	if (retval)
-		dev_dbg(&cytherm->udev->dev, "retval = %d\n", retval);
-	sign = buffer[1];
-
-	kfree(buffer);
-   
-	return sprintf(buf, "%c%i.%i", sign ? '-' : '+', temp >> 1,
-		       5*(temp - ((temp >> 1) << 1)));
-}
-
-
-static ssize_t set_temp(struct device *dev, const char *buf, size_t count)
-{
-	return count;
-}
-
-static DEVICE_ATTR(temp, S_IRUGO, show_temp, set_temp);
-
-
-#define BUTTON 0x7a
-
-static ssize_t show_button(struct device *dev, char *buf)
-{
-
-	struct usb_interface *intf = to_usb_interface(dev);
-	struct usb_cytherm *cytherm = usb_get_intfdata(intf);
-
-	int retval;
-	unsigned char *buffer;
-
-	buffer = kmalloc(8, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&cytherm->udev->dev, "out of memory\n");
-		return 0;
-	}
-
-	/* check button */
-	retval = vendor_command(cytherm->udev, READ_RAM, BUTTON, 0, buffer, 8);
-	if (retval)
-		dev_dbg(&cytherm->udev->dev, "retval = %d\n", retval);
-   
-	retval = buffer[1];
-
-	kfree(buffer);
-
-	if (retval)
-		return sprintf(buf, "1");
-	else
-		return sprintf(buf, "0");
-}
-
-
-static ssize_t set_button(struct device *dev, const char *buf, size_t count)
-{
-	return count;
-}
-
-static DEVICE_ATTR(button, S_IRUGO, show_button, set_button);
-
-
-static ssize_t show_port0(struct device *dev, char *buf)
-{
-	struct usb_interface *intf = to_usb_interface(dev);
-	struct usb_cytherm *cytherm = usb_get_intfdata(intf);
-
-	int retval;
-	unsigned char *buffer;
-
-	buffer = kmalloc(8, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&cytherm->udev->dev, "out of memory\n");
-		return 0;
-	}
-
-	retval = vendor_command(cytherm->udev, READ_PORT, 0, 0, buffer, 8);
-	if (retval)
-		dev_dbg(&cytherm->udev->dev, "retval = %d\n", retval);
-
-	retval = buffer[1];
-
-	kfree(buffer);
-
-	return sprintf(buf, "%d", retval);
-}
-
-
-static ssize_t set_port0(struct device *dev, const char *buf, size_t count)
-{
-	struct usb_interface *intf = to_usb_interface(dev);
-	struct usb_cytherm *cytherm = usb_get_intfdata(intf);
-
-	unsigned char *buffer;
-	int retval;
-	int tmp;
-   
-	buffer = kmalloc(8, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&cytherm->udev->dev, "out of memory\n");
-		return 0;
-	}
-
-	tmp = simple_strtoul(buf, NULL, 10);
-   
-	if (tmp > 0xFF)
-		tmp = 0xFF;
-	else if (tmp < 0)
-		tmp = 0;
-   
-	retval = vendor_command(cytherm->udev, WRITE_PORT, 0,
-				tmp, buffer, 8);
-	if (retval)
-		dev_dbg(&cytherm->udev->dev, "retval = %d\n", retval);
-
-	kfree(buffer);
-
-	return count;
-}
-
-static DEVICE_ATTR(port0, S_IRUGO | S_IWUSR | S_IWGRP, show_port0, set_port0);
-
-static ssize_t show_port1(struct device *dev, char *buf)
-{
-	struct usb_interface *intf = to_usb_interface(dev);
-	struct usb_cytherm *cytherm = usb_get_intfdata(intf);
-
-	int retval;
-	unsigned char *buffer;
-
-	buffer = kmalloc(8, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&cytherm->udev->dev, "out of memory\n");
-		return 0;
-	}
-
-	retval = vendor_command(cytherm->udev, READ_PORT, 1, 0, buffer, 8);
-	if (retval)
-		dev_dbg(&cytherm->udev->dev, "retval = %d\n", retval);
-   
-	retval = buffer[1];
-
-	kfree(buffer);
-
-	return sprintf(buf, "%d", retval);
-}
-
-
-static ssize_t set_port1(struct device *dev, const char *buf, size_t count)
-{
-	struct usb_interface *intf = to_usb_interface(dev);
-	struct usb_cytherm *cytherm = usb_get_intfdata(intf);
-
-	unsigned char *buffer;
-	int retval;
-	int tmp;
-   
-	buffer = kmalloc(8, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&cytherm->udev->dev, "out of memory\n");
-		return 0;
-	}
-
-	tmp = simple_strtoul(buf, NULL, 10);
-   
-	if (tmp > 0xFF)
-		tmp = 0xFF;
-	else if (tmp < 0)
-		tmp = 0;
-   
-	retval = vendor_command(cytherm->udev, WRITE_PORT, 1,
-				tmp, buffer, 8);
-	if (retval)
-		dev_dbg(&cytherm->udev->dev, "retval = %d\n", retval);
-
-	kfree(buffer);
-
-	return count;
-}
-
-static DEVICE_ATTR(port1, S_IRUGO | S_IWUSR | S_IWGRP, show_port1, set_port1);
-
-
-
-static int cytherm_probe(struct usb_interface *interface, 
-			 const struct usb_device_id *id)
-{
-	struct usb_device *udev = interface_to_usbdev(interface);
-	struct usb_cytherm *dev = NULL;
-	int retval = -ENOMEM;
-
-	dev = kmalloc (sizeof(struct usb_cytherm), GFP_KERNEL);
-	if (dev == NULL) {
-		dev_err (&interface->dev, "Out of memory\n");
-		goto error;
-	}
-	memset (dev, 0x00, sizeof (*dev));
-
-	dev->udev = usb_get_dev(udev);
-
-	usb_set_intfdata (interface, dev);
-
-	dev->brightness = 0xFF;
-
-	device_create_file(&interface->dev, &dev_attr_brightness);   
-	device_create_file(&interface->dev, &dev_attr_temp);
-	device_create_file(&interface->dev, &dev_attr_button);
-	device_create_file(&interface->dev, &dev_attr_port0);
-	device_create_file(&interface->dev, &dev_attr_port1);
-
-	dev_info (&interface->dev, 
-		  "Cypress thermometer device now attached\n");
-	return 0;
-
- error:
-	kfree(dev);
-	return retval;
-}
-
-static void cytherm_disconnect(struct usb_interface *interface)
-{
-	struct usb_cytherm *dev;
-
-	dev = usb_get_intfdata (interface);
-	usb_set_intfdata (interface, NULL);
-
-	device_remove_file(&interface->dev, &dev_attr_brightness);
-	device_remove_file(&interface->dev, &dev_attr_temp);
-	device_remove_file(&interface->dev, &dev_attr_button);
-	device_remove_file(&interface->dev, &dev_attr_port0);
-	device_remove_file(&interface->dev, &dev_attr_port1);
-
-	usb_put_dev(dev->udev);
-
-	kfree(dev);
-
-	dev_info(&interface->dev, "Cypress thermometer now disconnected\n");
-}
-
-
-static int __init usb_cytherm_init(void)
-{
-	int result;
-
-	result = usb_register(&cytherm_driver);
-	if (result) 
-	{	
-		err("usb_register failed. Error number %d", result);
-		return result;
-	}
-
-	info(DRIVER_VERSION ":" DRIVER_DESC);
-	return 0;
-}
-
-static void __exit usb_cytherm_exit(void)
-{
-	usb_deregister(&cytherm_driver);
-}
-
-
-module_init (usb_cytherm_init);
-module_exit (usb_cytherm_exit);
-
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
diff -Naur linuxppc-2.6.9/drivers/usb/misc/emi26.c linuxppc-2.6.9-dream/drivers/usb/misc/emi26.c
--- linuxppc-2.6.9/drivers/usb/misc/emi26.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/emi26.c	2005-09-19 21:40:05.000000000 +0200
@@ -194,7 +194,7 @@
 
 	/* return 1 to fail the driver inialization
 	 * and give real driver change to load */
-	err = 1;
+	return 1;
 
 wraperr:
 	kfree(buf);
@@ -226,7 +226,7 @@
 {
 }
 
-static struct usb_driver emi26_driver = {
+struct usb_driver emi26_driver = {
 	.owner		= THIS_MODULE,
 	.name		= "emi26 - firmware loader",
 	.probe		= emi26_probe,
diff -Naur linuxppc-2.6.9/drivers/usb/misc/emi26_fw.h linuxppc-2.6.9-dream/drivers/usb/misc/emi26_fw.h
--- linuxppc-2.6.9/drivers/usb/misc/emi26_fw.h	2004-10-18 23:55:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/emi26_fw.h	2005-09-19 21:40:05.000000000 +0200
@@ -12,16 +12,12 @@
  * and which may not be reproduced, used, sold or transferred to
  * any third party without Emagic's written consent. All Rights Reserved.
  *
- * Permission is hereby granted for the distribution of this firmware 
- * image as part of a Linux or other Open Source operating system kernel 
- * in text or binary form as required. 
- *
  * This firmware may not be modified and may only be used with the
  * Emagic EMI 2|6 Audio Interface. Distribution and/or Modification of
  * any driver which includes this firmware, in whole or in part,
  * requires the inclusion of this statement.
  */
-static INTEL_HEX_RECORD g_bitstream[]={
+INTEL_HEX_RECORD g_bitstream[]={
 {  16, 0x8010, 0, {0xff,0xff,0xff,0xff,0xaa,0x99,0x55,0x66,0x30,0x00,0x80,0x01,0x00,0x00,0x00,0x07 } },
 {  16, 0x8020, 0, {0x30,0x01,0x60,0x01,0x00,0x00,0x00,0x0b,0x30,0x01,0x20,0x01,0x00,0x80,0x3f,0x2d } },
 {  16, 0x8030, 0, {0x30,0x00,0xc0,0x01,0x00,0x00,0x00,0x00,0x30,0x00,0x80,0x01,0x00,0x00,0x00,0x09 } },
@@ -4410,7 +4406,7 @@
  * any driver which includes this firmware, in whole or in part,
  * requires the inclusion of this statement.
  */
-static INTEL_HEX_RECORD g_Firmware[] = {
+INTEL_HEX_RECORD g_Firmware[] = {
 {   3,0x0000,0,{0x02,0x43,0x56} },
 {   3,0x0003,0,{0x02,0x4b,0xcd} },
 {   3,0x000b,0,{0x02,0x4b,0xd2} },
@@ -5673,7 +5669,7 @@
  * any driver which includes this firmware, in whole or in part,
  * requires the inclusion of this statement.
  */
-static INTEL_HEX_RECORD g_Loader[] = {
+INTEL_HEX_RECORD g_Loader[] = {
 {   3,0x0000,0,{0x02,0x03,0x1c} },
 {   3,0x0043,0,{0x02,0x04,0x00} },
 {  16,0x0100,0,{0x90,0x7f,0xe9,0xe0,0x24,0x5b,0x60,0x60,0x24,0x02,0x60,0x03,0x02,0x01,0xbe,0x90} },
diff -Naur linuxppc-2.6.9/drivers/usb/misc/emi62.c linuxppc-2.6.9-dream/drivers/usb/misc/emi62.c
--- linuxppc-2.6.9/drivers/usb/misc/emi62.c	2004-10-18 23:55:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/emi62.c	2005-09-19 21:40:05.000000000 +0200
@@ -229,8 +229,6 @@
 		goto wraperr;
 	}
 
-	kfree(buf);
-
 	/* return 1 to fail the driver inialization
 	 * and give real driver change to load */
 	return 1;
@@ -267,7 +265,7 @@
 {
 }
 
-static struct usb_driver emi62_driver = {
+struct usb_driver emi62_driver = {
 	.owner		= THIS_MODULE,
 	.name		= "emi62 - firmware loader",
 	.probe		= emi62_probe,
diff -Naur linuxppc-2.6.9/drivers/usb/misc/emi62_fw_m.h linuxppc-2.6.9-dream/drivers/usb/misc/emi62_fw_m.h
--- linuxppc-2.6.9/drivers/usb/misc/emi62_fw_m.h	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/emi62_fw_m.h	2005-09-19 21:40:05.000000000 +0200
@@ -3,7 +3,7 @@
  */
 /* generated Tue Jun 3 21:36:11 EEST 2003 */
 
-static INTEL_HEX_RECORD g_emi62bs[]={
+INTEL_HEX_RECORD g_emi62bs[]={
   16, 0x8010, 0, {0xff,0xff,0xff,0xff,0xaa,0x99,0x55,0x66,0x30,0x00,0x80,0x01,0x00,0x00,0x00,0x07 },
   16, 0x8020, 0, {0x30,0x01,0x60,0x01,0x00,0x00,0x00,0x0d,0x30,0x01,0x20,0x01,0x00,0x80,0x3f,0x2d },
   16, 0x8030, 0, {0x30,0x00,0xc0,0x01,0x00,0x00,0x00,0x00,0x30,0x00,0x80,0x01,0x00,0x00,0x00,0x09 },
@@ -6112,7 +6112,7 @@
 };
 // VERSION= 1.0.0.191
 // DATE= 2002oct28
-static INTEL_HEX_RECORD g_HexMidiFw62[] = {
+INTEL_HEX_RECORD g_HexMidiFw62[] = {
    3,0x0000,0,{0x02,0x46,0xb9},
    3,0x0003,0,{0x02,0x0f,0xfd},
    3,0x000b,0,{0x02,0x4e,0x0f},
@@ -8640,8 +8640,7 @@
 /*
 VERSION=1.04.062
 DATE=16.10.2002  
-*/
-static INTEL_HEX_RECORD g_emi62_loader[] = {
+*/INTEL_HEX_RECORD g_emi62_loader[] = {
    3,0x0000,0,{0x02,0x02,0x87},
    3,0x0043,0,{0x02,0x04,0x00},
   16,0x0100,0,{0xe4,0xff,0xfe,0xc2,0x20,0xd2,0xe8,0x43,0xd8,0x20,0x90,0x7f,0xab,0x74,0xff,0xf0},
diff -Naur linuxppc-2.6.9/drivers/usb/misc/emi62_fw_s.h linuxppc-2.6.9-dream/drivers/usb/misc/emi62_fw_s.h
--- linuxppc-2.6.9/drivers/usb/misc/emi62_fw_s.h	2004-10-18 23:53:52.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/emi62_fw_s.h	2005-09-19 21:40:06.000000000 +0200
@@ -3,7 +3,7 @@
  */
 /* generated Tue Apr 15 21:59:42 EEST 2003 */
 
-static INTEL_HEX_RECORD g_emi62bs[]={
+INTEL_HEX_RECORD g_emi62bs[]={
  {16, 0x8010, 0, {0xff,0xff,0xff,0xff,0xaa,0x99,0x55,0x66,0x30,0x00,0x80,0x01,0x00,0x00,0x00,0x07 }},
  {16, 0x8020, 0, {0x30,0x01,0x60,0x01,0x00,0x00,0x00,0x0d,0x30,0x01,0x20,0x01,0x00,0x80,0x3f,0x2d }},
  {16, 0x8030, 0, {0x30,0x00,0xc0,0x01,0x00,0x00,0x00,0x00,0x30,0x00,0x80,0x01,0x00,0x00,0x00,0x09 }},
@@ -6112,7 +6112,7 @@
 };
 // VERSION= 1.0.0.191
 // DATE= 2002oct28
-static INTEL_HEX_RECORD g_HexSpdifFw62[] = {
+INTEL_HEX_RECORD g_HexSpdifFw62[] = {
   {3,0x0000,0,{0x02,0x45,0xf9}},
  { 3,0x0003,0,{0x02,0x0f,0xfd}},
  { 3,0x000b,0,{0x02,0x4d,0x9b}},
@@ -8623,8 +8623,7 @@
 /*
 VERSION=1.04.062
 DATE=16.10.2002  
-*/
-static INTEL_HEX_RECORD g_emi62_loader[] = {
+*/INTEL_HEX_RECORD g_emi62_loader[] = {
  { 3,0x0000,0,{0x02,0x02,0x87}},
  { 3,0x0043,0,{0x02,0x04,0x00}},
  {16,0x0100,0,{0xe4,0xff,0xfe,0xc2,0x20,0xd2,0xe8,0x43,0xd8,0x20,0x90,0x7f,0xab,0x74,0xff,0xf0}},
diff -Naur linuxppc-2.6.9/drivers/usb/misc/Kconfig linuxppc-2.6.9-dream/drivers/usb/misc/Kconfig
--- linuxppc-2.6.9/drivers/usb/misc/Kconfig	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/Kconfig	2005-09-19 21:40:06.000000000 +0200
@@ -108,19 +108,6 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called usbled.
 
-config USB_CYTHERM
-	tristate "Cypress USB thermometer driver support"
-	depends on USB
-	help
-	  Say Y here if you want to connect a Cypress USB thermometer
-	  device to your computer's USB port. This device is also known
-	  as the Cypress USB Starter kit or demo board. The Elektor
-	  magazine published a modified version of this device in issue 
-	  #291.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called cytherm.
-
 config USB_SPEEDTOUCH
 	tristate "Alcatel Speedtouch USB support"
 	depends on USB && ATM
@@ -133,18 +120,6 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called speedtch.
 
-config USB_PHIDGETSERVO
-	tristate "USB PhidgetServo support"
-	depends on USB
-	help
-	  Say Y here if you want to connect an 1 or 4 Motor PhidgetServo 
-	  servo controller version 2.0 or 3.0.
-
-	  Phidgets Inc. has a web page at <http://www.phidgets.com/>.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called phidgetservo.
-
 config USB_TEST
 	tristate "USB testing driver (DEVELOPMENT)"
 	depends on USB && USB_DEVICEFS && EXPERIMENTAL
diff -Naur linuxppc-2.6.9/drivers/usb/misc/legousbtower.c linuxppc-2.6.9-dream/drivers/usb/misc/legousbtower.c
--- linuxppc-2.6.9/drivers/usb/misc/legousbtower.c	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/legousbtower.c	2005-09-19 21:40:06.000000000 +0200
@@ -1,8 +1,8 @@
 /*
  * LEGO USB Tower driver
  *
- * Copyright (C) 2003 David Glance <davidgsf@sourceforge.net>
- *               2001-2004 Juergen Stuber <starblue@users.sourceforge.net>
+ * Copyright (C) 2003 David Glance <davidgsf@sourceforge.net> 
+ *               2001 Juergen Stuber <stuber@loria.fr>
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License as
@@ -33,46 +33,14 @@
  *   - changed to use lego0 rather than tower0
  *   - changed dbg() to use __func__ rather than deprecated __FUNCTION__
  * 2003-01-12 - 0.53 david (david@csse.uwa.edu.au)
- *   - changed read and write to write everything or
- *     timeout (from a patch by Chris Riesen and Brett Thaeler driver)
+ *   - changed read and write to write everything or timeout (from a patch by Chris Riesen and 
+ *     Brett Thaeler driver)
  *   - added ioctl functionality to set timeouts
- * 2003-07-18 - 0.54 davidgsf (david@csse.uwa.edu.au)
+ * 2003-07-18 - 0.54 davidgsf (david@csse.uwa.edu.au) 
  *   - initial import into LegoUSB project
  *   - merge of existing LegoUSB.c driver
- * 2003-07-18 - 0.56 davidgsf (david@csse.uwa.edu.au)
+ * 2003-07-18 - 0.56 davidgsf (david@csse.uwa.edu.au) 
  *   - port to 2.6 style driver
- * 2004-02-29 - 0.6 Juergen Stuber <starblue@users.sourceforge.net>
- *   - fix locking
- *   - unlink read URBs which are no longer needed
- *   - allow increased buffer size, eliminates need for timeout on write
- *   - have read URB running continuously
- *   - added poll
- *   - forbid seeking
- *   - added nonblocking I/O
- *   - changed back __func__ to __FUNCTION__
- *   - read and log tower firmware version
- *   - reset tower on probe, avoids failure of first write
- * 2004-03-09 - 0.7 Juergen Stuber <starblue@users.sourceforge.net>
- *   - timeout read now only after inactivity, shorten default accordingly
- * 2004-03-11 - 0.8 Juergen Stuber <starblue@users.sourceforge.net>
- *   - log major, minor instead of possibly confusing device filename
- *   - whitespace cleanup
- * 2004-03-12 - 0.9 Juergen Stuber <starblue@users.sourceforge.net>
- *   - normalize whitespace in debug messages
- *   - take care about endianness in control message responses
- * 2004-03-13 - 0.91 Juergen Stuber <starblue@users.sourceforge.net>
- *   - make default intervals longer to accommodate current EHCI driver
- * 2004-03-19 - 0.92 Juergen Stuber <starblue@users.sourceforge.net>
- *   - replaced atomic_t by memory barriers
- * 2004-04-21 - 0.93 Juergen Stuber <starblue@users.sourceforge.net>
- *   - wait for completion of write urb in release (needed for remotecontrol)
- *   - corrected poll for write direction (missing negation)
- * 2004-04-22 - 0.94 Juergen Stuber <starblue@users.sourceforge.net>
- *   - make device locking interruptible
- * 2004-04-30 - 0.95 Juergen Stuber <starblue@users.sourceforge.net>
- *   - check for valid udev on resubmitting and unlinking urbs
- * 2004-08-03 - 0.96 Juergen Stuber <starblue@users.sourceforge.net>
- *   - move reset into open to clean out spurious data
  */
 
 #include <linux/config.h>
@@ -85,113 +53,33 @@
 #include <linux/completion.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
-#include <linux/poll.h>
 
 
 #ifdef CONFIG_USB_DEBUG
 	static int debug = 4;
 #else
-	static int debug = 0;
+	static int debug = 1;
 #endif
 
 /* Use our own dbg macro */
 #undef dbg
-#define dbg(lvl, format, arg...) do { if (debug >= lvl) printk(KERN_DEBUG  __FILE__ ": " format "\n", ## arg); } while (0)
+#define dbg(lvl, format, arg...) do { if (debug >= lvl) printk(KERN_DEBUG  __FILE__ " : " format " \n", ## arg); } while (0)
 
 
 /* Version Information */
-#define DRIVER_VERSION "v0.96"
-#define DRIVER_AUTHOR "Juergen Stuber <starblue@sourceforge.net>"
+#define DRIVER_VERSION "v0.56"
+#define DRIVER_AUTHOR "David Glance, davidgsf@sourceforge.net"
 #define DRIVER_DESC "LEGO USB Tower Driver"
 
-/* Module parameters */
-module_param(debug, int, S_IRUGO | S_IWUSR);
+/* Module paramaters */
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
 
-/* The defaults are chosen to work with the latest versions of leJOS and NQC.
- */
-
-/* Some legacy software likes to receive packets in one piece.
- * In this case read_buffer_size should exceed the maximal packet length
- * (417 for datalog uploads), and packet_timeout should be set.
- */
-static int read_buffer_size = 480;
-module_param(read_buffer_size, int, 0);
-MODULE_PARM_DESC(read_buffer_size, "Read buffer size");
-
-/* Some legacy software likes to send packets in one piece.
- * In this case write_buffer_size should exceed the maximal packet length
- * (417 for firmware and program downloads).
- * A problem with long writes is that the following read may time out
- * if the software is not prepared to wait long enough.
- */
-static int write_buffer_size = 480;
-module_param(write_buffer_size, int, 0);
-MODULE_PARM_DESC(write_buffer_size, "Write buffer size");
-
-/* Some legacy software expects reads to contain whole LASM packets.
- * To achieve this, characters which arrive before a packet timeout
- * occurs will be returned in a single read operation.
- * A problem with long reads is that the software may time out
- * if it is not prepared to wait long enough.
- * The packet timeout should be greater than the time between the
- * reception of subsequent characters, which should arrive about
- * every 5ms for the standard 2400 baud.
- * Set it to 0 to disable.
- */
-static int packet_timeout = 50;
-module_param(packet_timeout, int, 0);
-MODULE_PARM_DESC(packet_timeout, "Packet timeout in ms");
-
-/* Some legacy software expects blocking reads to time out.
- * Timeout occurs after the specified time of read and write inactivity.
- * Set it to 0 to disable.
- */
-static int read_timeout = 200;
-module_param(read_timeout, int, 0);
-MODULE_PARM_DESC(read_timeout, "Read timeout in ms");
-
-/* As of kernel version 2.6.4 ehci-hcd uses an
- * "only one interrupt transfer per frame" shortcut
- * to simplify the scheduling of periodic transfers.
- * This conflicts with our standard 1ms intervals for in and out URBs.
- * We use default intervals of 2ms for in and 8ms for out transfers,
- * which is fast enough for 2400 baud and allows a small additional load.
- * Increase the interval to allow more devices that do interrupt transfers,
- * or set to 0 to use the standard interval from the endpoint descriptors.
- */
-static int interrupt_in_interval = 2;
-module_param(interrupt_in_interval, int, 0);
-MODULE_PARM_DESC(interrupt_in_interval, "Interrupt in interval in ms");
-
-static int interrupt_out_interval = 8;
-module_param(interrupt_out_interval, int, 0);
-MODULE_PARM_DESC(interrupt_out_interval, "Interrupt out interval in ms");
 
 /* Define these values to match your device */
 #define LEGO_USB_TOWER_VENDOR_ID	0x0694
 #define LEGO_USB_TOWER_PRODUCT_ID	0x0001
 
-/* Vendor requests */
-#define LEGO_USB_TOWER_REQUEST_RESET		0x04
-#define LEGO_USB_TOWER_REQUEST_GET_VERSION	0xFD
-
-struct tower_reset_reply {
-	__le16 size;		/* little-endian */
-	__u8 err_code;
-	__u8 spare;
-} __attribute__ ((packed));
-
-struct tower_get_version_reply {
-	__le16 size;		/* little-endian */
-	__u8 err_code;
-	__u8 spare;
-	__u8 major;
-	__u8 minor;
-	__le16 build_no;		/* little-endian */
-} __attribute__ ((packed));
-
-
 /* table of devices that work with this driver */
 static struct usb_device_id tower_table [] = {
 	{ USB_DEVICE(LEGO_USB_TOWER_VENDOR_ID, LEGO_USB_TOWER_PRODUCT_ID) },
@@ -202,21 +90,22 @@
 
 #define LEGO_USB_TOWER_MINOR_BASE	160
 
+/* we can have up to this number of device plugged in at once */
+#define MAX_DEVICES		16
+
+#define COMMAND_TIMEOUT		(2*HZ)  /* 2 second timeout for a command */
 
 /* Structure to hold all of our device specific stuff */
 struct lego_usb_tower {
 	struct semaphore	sem;		/* locks this structure */
-	struct usb_device*	udev;		/* save off the usb device pointer */
+	struct usb_device* 	udev;		/* save off the usb device pointer */
+	struct usb_interface*   interface;
 	unsigned char		minor;		/* the starting minor number for this device */
 
 	int			open_count;	/* number of times this port has been opened */
 
 	char*			read_buffer;
-	size_t			read_buffer_length; /* this much came in */
-	size_t			read_packet_length; /* this much will be returned on read */
-	spinlock_t		read_buffer_lock;
-	int			packet_timeout_jiffies;
-	unsigned long		read_last_arrival;
+	int			read_buffer_length;
 
 	wait_queue_head_t	read_wait;
 	wait_queue_head_t	write_wait;
@@ -224,30 +113,27 @@
 	char*			interrupt_in_buffer;
 	struct usb_endpoint_descriptor* interrupt_in_endpoint;
 	struct urb*		interrupt_in_urb;
-	int			interrupt_in_interval;
-	int			interrupt_in_running;
-	int			interrupt_in_done;
 
 	char*			interrupt_out_buffer;
 	struct usb_endpoint_descriptor* interrupt_out_endpoint;
 	struct urb*		interrupt_out_urb;
-	int			interrupt_out_interval;
-	int			interrupt_out_busy;
 
 };
 
+/* Note that no locking is needed:
+ * read_buffer is arbitrated by read_buffer_length == 0
+ * interrupt_out_buffer is arbitrated by interrupt_out_urb->status == -EINPROGRESS
+ * interrupt_in_buffer belongs to urb alone and is overwritten on overflow
+ */
 
 /* local function prototypes */
-static ssize_t tower_read	(struct file *file, char __user *buffer, size_t count, loff_t *ppos);
-static ssize_t tower_write	(struct file *file, const char __user *buffer, size_t count, loff_t *ppos);
+static ssize_t tower_read	(struct file *file, char *buffer, size_t count, loff_t *ppos);
+static ssize_t tower_write	(struct file *file, const char *buffer, size_t count, loff_t *ppos);
 static inline void tower_delete (struct lego_usb_tower *dev);
 static int tower_open		(struct inode *inode, struct file *file);
 static int tower_release	(struct inode *inode, struct file *file);
-static unsigned int tower_poll	(struct file *file, poll_table *wait);
-static loff_t tower_llseek	(struct file *file, loff_t off, int whence);
-
+static int tower_release_internal (struct lego_usb_tower *dev);
 static void tower_abort_transfers (struct lego_usb_tower *dev);
-static void tower_check_for_read_packet (struct lego_usb_tower *dev);
 static void tower_interrupt_in_callback (struct urb *urb, struct pt_regs *regs);
 static void tower_interrupt_out_callback (struct urb *urb, struct pt_regs *regs);
 
@@ -260,16 +146,14 @@
 
 /* file operations needed when we register this driver */
 static struct file_operations tower_fops = {
-	.owner =	THIS_MODULE,
-	.read  =	tower_read,
+	.owner = 	THIS_MODULE,
+	.read  = 	tower_read,
 	.write =	tower_write,
 	.open =		tower_open,
-	.release =	tower_release,
-	.poll =		tower_poll,
-	.llseek =	tower_llseek,
+	.release = 	tower_release,
 };
 
-/*
+/* 
  * usb class driver info in order to get a minor number from the usb core,
  * and to have the device registered with devfs and the driver core
  */
@@ -283,11 +167,11 @@
 
 /* usb specific object needed to register this driver with the usb subsystem */
 static struct usb_driver tower_driver = {
-	.owner =	THIS_MODULE,
-	.name =		"legousbtower",
-	.probe =	tower_probe,
-	.disconnect =	tower_disconnect,
-	.id_table =	tower_table,
+	.owner =        THIS_MODULE,
+	.name =	        "legousbtower",
+	.probe = 	tower_probe,
+	.disconnect = 	tower_disconnect,
+	.id_table = 	tower_table,
 };
 
 
@@ -299,8 +183,8 @@
 	int i;
 
 	if (debug < level)
-		return;
-
+		return; 
+	
 	printk (KERN_DEBUG __FILE__": %s - length = %d, data = ", function, size);
 	for (i = 0; i < size; ++i) {
 		printk ("%.2x ", data[i]);
@@ -314,7 +198,7 @@
  */
 static inline void tower_delete (struct lego_usb_tower *dev)
 {
-	dbg(2, "%s: enter", __FUNCTION__);
+	dbg(2, "%s enter", __func__);
 
 	tower_abort_transfers (dev);
 
@@ -330,7 +214,7 @@
 	kfree (dev->interrupt_out_buffer);
 	kfree (dev);
 
-	dbg(2, "%s: leave", __FUNCTION__);
+	dbg(2, "%s : leave", __func__);
 }
 
 
@@ -343,12 +227,9 @@
 	int subminor;
 	int retval = 0;
 	struct usb_interface *interface;
-	struct tower_reset_reply reset_reply;
-	int result;
 
-	dbg(2, "%s: enter", __FUNCTION__);
+	dbg(2,"%s : enter", __func__);
 
-	nonseekable_open(inode, file);
 	subminor = iminor(inode);
 
 	down (&disconnect_sem);
@@ -359,79 +240,37 @@
 		err ("%s - error, can't find device for minor %d",
 		     __FUNCTION__, subminor);
 		retval = -ENODEV;
-		goto unlock_disconnect_exit;
+		goto exit_no_device;
 	}
 
 	dev = usb_get_intfdata(interface);
 
 	if (!dev) {
 		retval = -ENODEV;
-		goto unlock_disconnect_exit;
+		goto exit_no_device;
 	}
 
 	/* lock this device */
-	if (down_interruptible (&dev->sem)) {
-	        retval = -ERESTARTSYS;
-		goto unlock_disconnect_exit;
-	}
-
-	/* allow opening only once */
-	if (dev->open_count) {
-		retval = -EBUSY;
-		goto unlock_exit;
-	}
-	dev->open_count = 1;
-
-	/* reset the tower */
-	result = usb_control_msg (dev->udev,
-				  usb_rcvctrlpipe(dev->udev, 0),
-				  LEGO_USB_TOWER_REQUEST_RESET,
-				  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,
-				  0,
-				  0,
-				  &reset_reply,
-				  sizeof(reset_reply),
-				  HZ);
-	if (result < 0) {
-		err("LEGO USB Tower reset control request failed");
-		retval = result;
-		goto unlock_exit;
-	}
-
-	/* initialize in direction */
-	dev->read_buffer_length = 0;
-	dev->read_packet_length = 0;
-	usb_fill_int_urb (dev->interrupt_in_urb,
-			  dev->udev,
-			  usb_rcvintpipe(dev->udev, dev->interrupt_in_endpoint->bEndpointAddress),
-			  dev->interrupt_in_buffer,
-			  dev->interrupt_in_endpoint->wMaxPacketSize,
-			  tower_interrupt_in_callback,
-			  dev,
-			  dev->interrupt_in_interval);
-
-	dev->interrupt_in_running = 1;
-	dev->interrupt_in_done = 0;
-	mb();
+	down (&dev->sem);
 
-	retval = usb_submit_urb (dev->interrupt_in_urb, GFP_KERNEL);
-	if (retval) {
-		err("Couldn't submit interrupt_in_urb %d", retval);
-		dev->interrupt_in_running = 0;
-		dev->open_count = 0;
-		goto unlock_exit;
-	}
+	
+	/* increment our usage count for the device */
+	++dev->open_count;
 
 	/* save device in the file's private structure */
 	file->private_data = dev;
 
-unlock_exit:
+
+	/* initialize in direction */
+	dev->read_buffer_length = 0;
+
 	up (&dev->sem);
 
-unlock_disconnect_exit:
+exit_no_device:
+
 	up (&disconnect_sem);
 
-	dbg(2, "%s: leave, return value %d ", __FUNCTION__, retval);
+	dbg(2,"%s : leave, return value %d ", __func__, retval);
 
 	return retval;
 }
@@ -444,227 +283,186 @@
 	struct lego_usb_tower *dev;
 	int retval = 0;
 
-	dbg(2, "%s: enter", __FUNCTION__);
+	dbg(2," %s : enter", __func__);
 
 	dev = (struct lego_usb_tower *)file->private_data;
 
 	if (dev == NULL) {
-		dbg(1, "%s: object is NULL", __FUNCTION__);
+		dbg(1," %s : object is NULL", __func__);
 		retval = -ENODEV;
 		goto exit;
 	}
 
-	if (down_interruptible (&dev->sem)) {
-	        retval = -ERESTARTSYS;
-		goto exit;
-	}
 
-	if (dev->open_count != 1) {
-		dbg(1, "%s: device not opened exactly once", __FUNCTION__);
+	/* lock our device */
+	down (&dev->sem);
+
+ 	if (dev->open_count <= 0) {
+		dbg(1," %s : device not opened", __func__);
 		retval = -ENODEV;
-		goto unlock_exit;
-	}
-	if (dev->udev == NULL) {
-		/* the device was unplugged before the file was released */
-		up (&dev->sem);	/* unlock here as tower_delete frees dev */
-		tower_delete (dev);
 		goto exit;
 	}
 
-	/* wait until write transfer is finished */
-	if (dev->interrupt_out_busy) {
-		wait_event_interruptible_timeout (dev->write_wait, !dev->interrupt_out_busy, 2 * HZ);
-	}
-	tower_abort_transfers (dev);
-	dev->open_count = 0;
-
-unlock_exit:
-	up (&dev->sem);
+	/* do the work */
+	retval = tower_release_internal (dev);
 
 exit:
-	dbg(2, "%s: leave, return value %d", __FUNCTION__, retval);
+	up (&dev->sem);
+	dbg(2," %s : leave, return value %d", __func__, retval);
 	return retval;
 }
 
 
 /**
- *	tower_abort_transfers
- *      aborts transfers and frees associated data structures
+ *	tower_release_internal
  */
-static void tower_abort_transfers (struct lego_usb_tower *dev)
+static int tower_release_internal (struct lego_usb_tower *dev)
 {
-	dbg(2, "%s: enter", __FUNCTION__);
+	int retval = 0;
 
-	if (dev == NULL) {
-		dbg(1, "%s: dev is null", __FUNCTION__);
+	dbg(2," %s : enter", __func__);
+
+	if (dev->udev == NULL) {
+		/* the device was unplugged before the file was released */
+		tower_delete (dev);
 		goto exit;
 	}
 
-	/* shutdown transfer */
-	if (dev->interrupt_in_running) {
-		dev->interrupt_in_running = 0;
-		mb();
-		if (dev->interrupt_in_urb != NULL && dev->udev) {
-			usb_unlink_urb (dev->interrupt_in_urb);
-		}
-	}
-	if (dev->interrupt_out_busy) {
-		if (dev->interrupt_out_urb != NULL && dev->udev) {
-			usb_unlink_urb (dev->interrupt_out_urb);
-		}
+	/* decrement our usage count for the device */
+	--dev->open_count;
+	if (dev->open_count <= 0) {
+		tower_abort_transfers (dev);
+		dev->open_count = 0;
 	}
 
 exit:
-	dbg(2, "%s: leave", __FUNCTION__);
-}
-
-
-/**
- *	tower_check_for_read_packet
- *
- *      To get correct semantics for signals and non-blocking I/O
- *      with packetizing we pretend not to see any data in the read buffer
- *      until it has been there unchanged for at least
- *      dev->packet_timeout_jiffies, or until the buffer is full.
- */
-static void tower_check_for_read_packet (struct lego_usb_tower *dev)
-{
-	spin_lock_irq (&dev->read_buffer_lock);
-	if (!packet_timeout
-	    || time_after(jiffies, dev->read_last_arrival + dev->packet_timeout_jiffies)
-	    || dev->read_buffer_length == read_buffer_size) {
-		dev->read_packet_length = dev->read_buffer_length;
-	}
-	dev->interrupt_in_done = 0;
-	spin_unlock_irq (&dev->read_buffer_lock);
+	dbg(2," %s : leave", __func__);
+	return retval;
 }
 
 
 /**
- *	tower_poll
+ *	tower_abort_transfers
+ *      aborts transfers and frees associated data structures
  */
-static unsigned int tower_poll (struct file *file, poll_table *wait)
+static void tower_abort_transfers (struct lego_usb_tower *dev)
 {
-	struct lego_usb_tower *dev;
-	unsigned int mask = 0;
+	dbg(2," %s : enter", __func__);
 
-	dbg(2, "%s: enter", __FUNCTION__);
-
-	dev = file->private_data;
-
-	poll_wait(file, &dev->read_wait, wait);
-	poll_wait(file, &dev->write_wait, wait);
+	if (dev == NULL) {
+		dbg(1," %s : dev is null", __func__);
+	        goto exit;
+	}
 
-	tower_check_for_read_packet(dev);
-	if (dev->read_packet_length > 0) {
-		mask |= POLLIN | POLLRDNORM;
+	/* shutdown transfer */
+	if (dev->interrupt_in_urb != NULL) {
+		usb_unlink_urb (dev->interrupt_in_urb);
 	}
-	if (!dev->interrupt_out_busy) {
-		mask |= POLLOUT | POLLWRNORM;
+	if (dev->interrupt_out_urb != NULL) {
+		usb_unlink_urb (dev->interrupt_out_urb);
 	}
 
-	dbg(2, "%s: leave, mask = %d", __FUNCTION__, mask);
-
-	return mask;
-}
-
-
-/**
- *	tower_llseek
- */
-static loff_t tower_llseek (struct file *file, loff_t off, int whence)
-{
-	return -ESPIPE;		/* unseekable */
+exit:
+	dbg(2," %s : leave", __func__);
 }
 
 
 /**
  *	tower_read
  */
-static ssize_t tower_read (struct file *file, char __user *buffer, size_t count, loff_t *ppos)
+static ssize_t tower_read (struct file *file, char *buffer, size_t count, loff_t *ppos)
 {
 	struct lego_usb_tower *dev;
+	size_t bytes_read = 0;
 	size_t bytes_to_read;
 	int i;
 	int retval = 0;
-	unsigned long timeout = 0;
+	int timeout = 0;
 
-	dbg(2, "%s: enter, count = %Zd", __FUNCTION__, count);
+	dbg(2," %s : enter, count = %Zd", __func__, count);
 
 	dev = (struct lego_usb_tower *)file->private_data;
-
+	
 	/* lock this object */
-	if (down_interruptible (&dev->sem)) {
-		retval = -ERESTARTSYS;
-		goto exit;
-	}
+	down (&dev->sem);
 
 	/* verify that the device wasn't unplugged */
 	if (dev->udev == NULL) {
 		retval = -ENODEV;
 		err("No device or device unplugged %d", retval);
-		goto unlock_exit;
+		goto exit;
 	}
 
 	/* verify that we actually have some data to read */
 	if (count == 0) {
-		dbg(1, "%s: read request of 0 bytes", __FUNCTION__);
-		goto unlock_exit;
+		dbg(1," %s : read request of 0 bytes", __func__);
+		goto exit;
 	}
 
-	if (read_timeout) {
-		timeout = jiffies + read_timeout * HZ / 1000;
-	}
 
-	/* wait for data */
-	tower_check_for_read_packet (dev);
-	while (dev->read_packet_length == 0) {
-		if (file->f_flags & O_NONBLOCK) {
-			retval = -EAGAIN;
-			goto unlock_exit;
-		}
-		retval = wait_event_interruptible_timeout(dev->read_wait, dev->interrupt_in_done, dev->packet_timeout_jiffies);
-		if (retval < 0) {
-			goto unlock_exit;
-		}
+	timeout = COMMAND_TIMEOUT;
 
-		/* reset read timeout during read or write activity */
-		if (read_timeout
-		    && (dev->read_buffer_length || dev->interrupt_out_busy)) {
-			timeout = jiffies + read_timeout * HZ / 1000;
-		}
-		/* check for read timeout */
-		if (read_timeout && time_after (jiffies, timeout)) {
-			retval = -ETIMEDOUT;
-			goto unlock_exit;
-		}
-		tower_check_for_read_packet (dev);
-	}
+	while (1) {
+		if (dev->read_buffer_length == 0) {
 
-	/* copy the data from read_buffer into userspace */
-	bytes_to_read = min(count, dev->read_packet_length);
+			/* start reading */
+			usb_fill_int_urb (dev->interrupt_in_urb,dev->udev,
+					  usb_rcvintpipe(dev->udev, dev->interrupt_in_endpoint->bEndpointAddress),
+					  dev->interrupt_in_buffer,
+					  dev->interrupt_in_endpoint->wMaxPacketSize,
+					  tower_interrupt_in_callback,
+					  dev,
+					  dev->interrupt_in_endpoint->bInterval);
+			
+			retval = usb_submit_urb (dev->interrupt_in_urb, GFP_KERNEL);
+			
+			if (retval < 0) {
+				err("Couldn't submit interrupt_in_urb");
+				goto exit;
+			}
+
+			if (timeout <= 0) {
+			        retval = -ETIMEDOUT;
+			        goto exit;
+			}
+
+			if (signal_pending(current)) {
+				retval = -EINTR;
+				goto exit;
+			}
+
+			up (&dev->sem);
+			timeout = interruptible_sleep_on_timeout (&dev->read_wait, timeout);
+			down (&dev->sem);
 
-	if (copy_to_user (buffer, dev->read_buffer, bytes_to_read)) {
-		retval = -EFAULT;
-		goto unlock_exit;
-	}
-
-	spin_lock_irq (&dev->read_buffer_lock);
-	dev->read_buffer_length -= bytes_to_read;
-	dev->read_packet_length -= bytes_to_read;
-	for (i=0; i<dev->read_buffer_length; i++) {
-		dev->read_buffer[i] = dev->read_buffer[i+bytes_to_read];
+		} else {
+			/* copy the data from read_buffer into userspace */
+			bytes_to_read = count > dev->read_buffer_length ? dev->read_buffer_length : count;
+			if (copy_to_user (buffer, dev->read_buffer, bytes_to_read) != 0) {
+				retval = -EFAULT;
+				goto exit;
+			}
+			dev->read_buffer_length -= bytes_to_read;
+			for (i=0; i<dev->read_buffer_length; i++) {
+				dev->read_buffer[i] = dev->read_buffer[i+bytes_to_read];
+			}
+
+			buffer += bytes_to_read;
+			count -= bytes_to_read;
+			bytes_read += bytes_to_read;
+			if (count == 0) {
+				break;
+			}
+		}
 	}
-	spin_unlock_irq (&dev->read_buffer_lock);
 
-	retval = bytes_to_read;
+	retval = bytes_read;
 
-unlock_exit:
+exit:
 	/* unlock the device */
 	up (&dev->sem);
 
-exit:
-	dbg(2, "%s: leave, return value %d", __FUNCTION__, retval);
+	dbg(2," %s : leave, return value %d", __func__, retval);
 	return retval;
 }
 
@@ -672,83 +470,110 @@
 /**
  *	tower_write
  */
-static ssize_t tower_write (struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
+static ssize_t tower_write (struct file *file, const char *buffer, size_t count, loff_t *ppos)
 {
 	struct lego_usb_tower *dev;
+	size_t bytes_written = 0;
 	size_t bytes_to_write;
+	size_t buffer_size;
 	int retval = 0;
+	int timeout = 0;
 
-	dbg(2, "%s: enter, count = %Zd", __FUNCTION__, count);
+	dbg(2," %s : enter, count = %Zd", __func__, count);
 
 	dev = (struct lego_usb_tower *)file->private_data;
 
 	/* lock this object */
-	if (down_interruptible (&dev->sem)) {
-		retval = -ERESTARTSYS;
-		goto exit;
-	}
+	down (&dev->sem);
 
 	/* verify that the device wasn't unplugged */
 	if (dev->udev == NULL) {
 		retval = -ENODEV;
 		err("No device or device unplugged %d", retval);
-		goto unlock_exit;
+		goto exit;
 	}
 
 	/* verify that we actually have some data to write */
 	if (count == 0) {
-		dbg(1, "%s: write request of 0 bytes", __FUNCTION__);
-		goto unlock_exit;
+		dbg(1," %s : write request of 0 bytes", __func__);
+		goto exit;
 	}
 
-	/* wait until previous transfer is finished */
-	while (dev->interrupt_out_busy) {
-		if (file->f_flags & O_NONBLOCK) {
-			retval = -EAGAIN;
-			goto unlock_exit;
-		}
-		retval = wait_event_interruptible (dev->write_wait, !dev->interrupt_out_busy);
-		if (retval) {
-			goto unlock_exit;
-		}
-	}
 
-	/* write the data into interrupt_out_buffer from userspace */
-	bytes_to_write = min_t(int, count, write_buffer_size);
-	dbg(4, "%s: count = %Zd, bytes_to_write = %Zd", __FUNCTION__, count, bytes_to_write);
-
-	if (copy_from_user (dev->interrupt_out_buffer, buffer, bytes_to_write)) {
-		retval = -EFAULT;
-		goto unlock_exit;
-	}
-
-	/* send off the urb */
-	usb_fill_int_urb(dev->interrupt_out_urb,
-			 dev->udev,
-			 usb_sndintpipe(dev->udev, dev->interrupt_out_endpoint->bEndpointAddress),
-			 dev->interrupt_out_buffer,
-			 bytes_to_write,
-			 tower_interrupt_out_callback,
-			 dev,
-			 dev->interrupt_out_interval);
+	while (count > 0) {
+		if (dev->interrupt_out_urb->status == -EINPROGRESS) {
+			timeout = COMMAND_TIMEOUT;
+
+			while (timeout > 0) {
+				if (signal_pending(current)) {
+					dbg(1," %s : interrupted", __func__);
+					retval = -EINTR;
+					goto exit;
+				}
+				up (&dev->sem);
+				timeout = interruptible_sleep_on_timeout (&dev->write_wait, timeout);
+				down (&dev->sem);
+				if (timeout > 0) {
+					break;
+				}
+				dbg(1," %s : interrupted timeout: %d", __func__, timeout);
+			}
+
+
+			dbg(1," %s : final timeout: %d", __func__, timeout);
+
+			if (timeout == 0) {
+				dbg(1, "%s - command timed out.", __func__);
+				retval = -ETIMEDOUT;
+				goto exit;
+			}
 
-	dev->interrupt_out_busy = 1;
-	wmb();
+			dbg(4," %s : in progress, count = %Zd", __func__, count);
+		} else {
+			dbg(4," %s : sending, count = %Zd", __func__, count);
 
-	retval = usb_submit_urb (dev->interrupt_out_urb, GFP_KERNEL);
-	if (retval) {
-		dev->interrupt_out_busy = 0;
-		err("Couldn't submit interrupt_out_urb %d", retval);
-		goto unlock_exit;
+			/* write the data into interrupt_out_buffer from userspace */
+			buffer_size = dev->interrupt_out_endpoint->wMaxPacketSize;
+			bytes_to_write = count > buffer_size ? buffer_size : count;
+			dbg(4," %s : buffer_size = %Zd, count = %Zd, bytes_to_write = %Zd", __func__, buffer_size, count, bytes_to_write);
+
+			if (copy_from_user (dev->interrupt_out_buffer, buffer, bytes_to_write) != 0) {
+				retval = -EFAULT;
+				goto exit;
+			}
+
+			/* send off the urb */
+			usb_fill_int_urb(dev->interrupt_out_urb,
+					dev->udev, 
+					usb_sndintpipe(dev->udev, dev->interrupt_out_endpoint->bEndpointAddress),
+					dev->interrupt_out_buffer,
+					bytes_to_write,
+					tower_interrupt_out_callback,
+					dev,
+					dev->interrupt_in_endpoint->bInterval);
+
+			dev->interrupt_out_urb->actual_length = bytes_to_write;
+			retval = usb_submit_urb (dev->interrupt_out_urb, GFP_KERNEL);
+
+			if (retval < 0) {
+				err("Couldn't submit interrupt_out_urb %d", retval);
+				goto exit;
+			}
+
+			buffer += bytes_to_write;
+			count -= bytes_to_write;
+
+			bytes_written += bytes_to_write;
+		}
 	}
-	retval = bytes_to_write;
 
-unlock_exit:
+	retval = bytes_written;
+
+exit:
 	/* unlock the device */
 	up (&dev->sem);
 
-exit:
-	dbg(2, "%s: leave, return value %d", __FUNCTION__, retval);
+	dbg(2," %s : leave, return value %d", __func__, retval);
 
 	return retval;
 }
@@ -760,53 +585,39 @@
 static void tower_interrupt_in_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct lego_usb_tower *dev = (struct lego_usb_tower *)urb->context;
-	int retval;
 
-	dbg(4, "%s: enter, status %d", __FUNCTION__, urb->status);
+	dbg(4," %s : enter, status %d", __func__, urb->status);
 
-	lego_usb_tower_debug_data(5, __FUNCTION__, urb->actual_length, urb->transfer_buffer);
+	lego_usb_tower_debug_data(5,__func__, urb->actual_length, urb->transfer_buffer);
 
-	if (urb->status) {
-		if (urb->status == -ENOENT ||
-		    urb->status == -ECONNRESET ||
-		    urb->status == -ESHUTDOWN) {
-			goto exit;
-		} else {
-			dbg(1, "%s: nonzero status received: %d", __FUNCTION__, urb->status);
-			goto resubmit; /* maybe we can recover */
+	if (urb->status != 0) {
+		if ((urb->status != -ENOENT) && (urb->status != -ECONNRESET)) {
+			dbg(1," %s : nonzero status received: %d", __func__, urb->status);
 		}
+		goto exit;
 	}
 
+	down (&dev->sem);
+
 	if (urb->actual_length > 0) {
-		spin_lock (&dev->read_buffer_lock);
-		if (dev->read_buffer_length + urb->actual_length < read_buffer_size) {
-			memcpy (dev->read_buffer + dev->read_buffer_length,
-				dev->interrupt_in_buffer,
-				urb->actual_length);
+		if (dev->read_buffer_length < (4 * dev->interrupt_in_endpoint->wMaxPacketSize) - (urb->actual_length)) {
+
+			memcpy (dev->read_buffer+dev->read_buffer_length, dev->interrupt_in_buffer, urb->actual_length);
+
 			dev->read_buffer_length += urb->actual_length;
-			dev->read_last_arrival = jiffies;
-			dbg(3, "%s: received %d bytes", __FUNCTION__, urb->actual_length);
+			dbg(1," %s reading  %d ", __func__, urb->actual_length);
+			wake_up_interruptible (&dev->read_wait);
+
 		} else {
-			printk(KERN_WARNING "%s: read_buffer overflow, %d bytes dropped", __FUNCTION__, urb->actual_length);
+			dbg(1," %s : read_buffer overflow", __func__);
 		}
-		spin_unlock (&dev->read_buffer_lock);
 	}
 
-resubmit:
-	/* resubmit if we're still running */
-	if (dev->interrupt_in_running && dev->udev) {
-		retval = usb_submit_urb (dev->interrupt_in_urb, GFP_ATOMIC);
-		if (retval) {
-			err("%s: usb_submit_urb failed (%d)", __FUNCTION__, retval);
-		}
-	}
+	up (&dev->sem);
 
 exit:
-	dev->interrupt_in_done = 1;
-	wake_up_interruptible (&dev->read_wait);
-
-	lego_usb_tower_debug_data(5, __FUNCTION__, urb->actual_length, urb->transfer_buffer);
-	dbg(4, "%s: leave, status %d", __FUNCTION__, urb->status);
+	lego_usb_tower_debug_data(5,__func__, urb->actual_length, urb->transfer_buffer);
+	dbg(4," %s : leave, status %d", __func__, urb->status);
 }
 
 
@@ -817,22 +628,22 @@
 {
 	struct lego_usb_tower *dev = (struct lego_usb_tower *)urb->context;
 
-	dbg(4, "%s: enter, status %d", __FUNCTION__, urb->status);
-	lego_usb_tower_debug_data(5, __FUNCTION__, urb->actual_length, urb->transfer_buffer);
+	dbg(4," %s : enter, status %d", __func__, urb->status);
+	lego_usb_tower_debug_data(5,__func__, urb->actual_length, urb->transfer_buffer);
 
-	/* sync/async unlink faults aren't errors */
-	if (urb->status && !(urb->status == -ENOENT ||
-			     urb->status == -ECONNRESET ||
-			     urb->status == -ESHUTDOWN)) {
-		dbg(1, "%s - nonzero write bulk status received: %d",
-		    __FUNCTION__, urb->status);
-	}
+	if (urb->status != 0) {
+		if ((urb->status != -ENOENT) && 
+		    (urb->status != -ECONNRESET)) {
+			dbg(1, " %s :nonzero status received: %d", __func__, urb->status);
+		}
+		goto exit;
+	}                        
 
-	dev->interrupt_out_busy = 0;
 	wake_up_interruptible(&dev->write_wait);
+exit:
 
-	lego_usb_tower_debug_data(5, __FUNCTION__, urb->actual_length, urb->transfer_buffer);
-	dbg(4, "%s: leave, status %d", __FUNCTION__, urb->status);
+	lego_usb_tower_debug_data(5,__func__, urb->actual_length, urb->transfer_buffer);
+	dbg(4," %s : leave, status %d", __func__, urb->status);
 }
 
 
@@ -848,17 +659,15 @@
 	struct lego_usb_tower *dev = NULL;
 	struct usb_host_interface *iface_desc;
 	struct usb_endpoint_descriptor* endpoint;
-	struct tower_get_version_reply get_version_reply;
 	int i;
 	int retval = -ENOMEM;
-	int result;
 
-	dbg(2, "%s: enter", __FUNCTION__);
+	dbg(2," %s : enter", __func__);
 
 	if (udev == NULL) {
 		info ("udev is NULL.");
 	}
-
+	
 	/* See if the device offered us matches what we can accept */
 	if ((udev->descriptor.idVendor != LEGO_USB_TOWER_VENDOR_ID) ||
 	    (udev->descriptor.idProduct != LEGO_USB_TOWER_PRODUCT_ID)) {
@@ -882,10 +691,6 @@
 
 	dev->read_buffer = NULL;
 	dev->read_buffer_length = 0;
-	dev->read_packet_length = 0;
-	spin_lock_init (&dev->read_buffer_lock);
-	dev->packet_timeout_jiffies = packet_timeout * HZ / 1000;
-	dev->read_last_arrival = jiffies;
 
 	init_waitqueue_head (&dev->read_wait);
 	init_waitqueue_head (&dev->write_wait);
@@ -893,15 +698,13 @@
 	dev->interrupt_in_buffer = NULL;
 	dev->interrupt_in_endpoint = NULL;
 	dev->interrupt_in_urb = NULL;
-	dev->interrupt_in_running = 0;
-	dev->interrupt_in_done = 0;
 
 	dev->interrupt_out_buffer = NULL;
 	dev->interrupt_out_endpoint = NULL;
 	dev->interrupt_out_urb = NULL;
-	dev->interrupt_out_busy = 0;
 
-	iface_desc = interface->cur_altsetting;
+
+	iface_desc = &interface->altsetting[0];
 
 	/* set up the endpoint information */
 	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
@@ -911,7 +714,7 @@
 		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT)) {
 			dev->interrupt_in_endpoint = endpoint;
 		}
-
+		
 		if (((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT) &&
 		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT)) {
 			dev->interrupt_out_endpoint = endpoint;
@@ -926,7 +729,7 @@
 		goto error;
 	}
 
-	dev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL);
+	dev->read_buffer = kmalloc ((4*dev->interrupt_in_endpoint->wMaxPacketSize), GFP_KERNEL);
 	if (!dev->read_buffer) {
 		err("Couldn't allocate read_buffer");
 		goto error;
@@ -941,7 +744,7 @@
 		err("Couldn't allocate interrupt_in_urb");
 		goto error;
 	}
-	dev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL);
+	dev->interrupt_out_buffer = kmalloc (dev->interrupt_out_endpoint->wMaxPacketSize, GFP_KERNEL);
 	if (!dev->interrupt_out_buffer) {
 		err("Couldn't allocate interrupt_out_buffer");
 		goto error;
@@ -950,9 +753,7 @@
 	if (!dev->interrupt_out_urb) {
 		err("Couldn't allocate interrupt_out_urb");
 		goto error;
-	}
-	dev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;
-	dev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;
+	}                
 
 	/* we can register the device now, as it is ready */
 	usb_set_intfdata (interface, dev);
@@ -965,34 +766,16 @@
 		usb_set_intfdata (interface, NULL);
 		goto error;
 	}
+
 	dev->minor = interface->minor;
 
 	/* let the user know what node this device is now attached to */
-	info ("LEGO USB Tower #%d now attached to major %d minor %d", (dev->minor - LEGO_USB_TOWER_MINOR_BASE), USB_MAJOR, dev->minor);
+	info ("LEGO USB Tower device now attached to /dev/usb/lego%d", (dev->minor - LEGO_USB_TOWER_MINOR_BASE));
 
-	/* get the firmware version and log it */
-	result = usb_control_msg (udev,
-				  usb_rcvctrlpipe(udev, 0),
-				  LEGO_USB_TOWER_REQUEST_GET_VERSION,
-				  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,
-				  0,
-				  0,
-				  &get_version_reply,
-				  sizeof(get_version_reply),
-				  HZ);
-	if (result < 0) {
-		err("LEGO USB Tower get version control request failed");
-		retval = result;
-		goto error;
-	}
-	info("LEGO USB Tower firmware version is %d.%d build %d",
-	     get_version_reply.major,
-	     get_version_reply.minor,
-	     le16_to_cpu(get_version_reply.build_no));
 
 
 exit:
-	dbg(2, "%s: leave, return value 0x%.8lx (dev)", __FUNCTION__, (long) dev);
+	dbg(2," %s : leave, return value 0x%.8lx (dev)", __func__, (long) dev);
 
 	return retval;
 
@@ -1012,7 +795,7 @@
 	struct lego_usb_tower *dev;
 	int minor;
 
-	dbg(2, "%s: enter", __FUNCTION__);
+	dbg(2," %s : enter", __func__);
 
 	down (&disconnect_sem);
 
@@ -1040,7 +823,7 @@
 
 	info("LEGO USB Tower #%d now disconnected", (minor - LEGO_USB_TOWER_MINOR_BASE));
 
-	dbg(2, "%s: leave", __FUNCTION__);
+	dbg(2," %s : leave", __func__);
 }
 
 
@@ -1053,7 +836,7 @@
 	int result;
 	int retval = 0;
 
-	dbg(2, "%s: enter", __FUNCTION__);
+	dbg(2," %s : enter", __func__);
 
 	/* register this driver with the USB subsystem */
 	result = usb_register(&tower_driver);
@@ -1066,7 +849,7 @@
 	info(DRIVER_DESC " " DRIVER_VERSION);
 
 exit:
-	dbg(2, "%s: leave, return value %d", __FUNCTION__, retval);
+	dbg(2," %s : leave, return value %d", __func__, retval);
 
 	return retval;
 }
@@ -1077,12 +860,12 @@
  */
 static void __exit lego_usb_tower_exit(void)
 {
-	dbg(2, "%s: enter", __FUNCTION__);
+	dbg(2," %s : enter", __func__);
 
 	/* deregister this driver with the USB subsystem */
 	usb_deregister (&tower_driver);
 
-	dbg(2, "%s: leave", __FUNCTION__);
+	dbg(2," %s : leave", __func__);
 }
 
 module_init (lego_usb_tower_init);
diff -Naur linuxppc-2.6.9/drivers/usb/misc/Makefile linuxppc-2.6.9-dream/drivers/usb/misc/Makefile
--- linuxppc-2.6.9/drivers/usb/misc/Makefile	2004-10-18 23:54:31.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/Makefile	2005-09-19 21:40:06.000000000 +0200
@@ -4,9 +4,8 @@
 #
 
 obj-$(CONFIG_USB_AUERSWALD)	+= auerswald.o
-obj-$(CONFIG_USB_CYTHERM)	+= cytherm.o
-obj-$(CONFIG_USB_EMI26)		+= emi26.o
 obj-$(CONFIG_USB_EMI62)		+= emi62.o
+obj-$(CONFIG_USB_EMI26)		+= emi26.o
 obj-$(CONFIG_USB_LCD)		+= usblcd.o
 obj-$(CONFIG_USB_LED)		+= usbled.o
 obj-$(CONFIG_USB_LEGOTOWER)	+= legousbtower.o
@@ -15,4 +14,3 @@
 obj-$(CONFIG_USB_TEST)		+= usbtest.o
 obj-$(CONFIG_USB_TIGL)		+= tiglusb.o
 obj-$(CONFIG_USB_USS720)	+= uss720.o
-obj-$(CONFIG_USB_PHIDGETSERVO)	+= phidgetservo.o
diff -Naur linuxppc-2.6.9/drivers/usb/misc/phidgetservo.c linuxppc-2.6.9-dream/drivers/usb/misc/phidgetservo.c
--- linuxppc-2.6.9/drivers/usb/misc/phidgetservo.c	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/phidgetservo.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,342 +0,0 @@
-/*
- * USB PhidgetServo driver 1.0
- *
- * Copyright (C) 2004 Sean Young <sean@mess.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This is a driver for the USB PhidgetServo version 2.0 and 3.0 servo 
- * controllers available at: http://www.phidgets.com/ 
- *
- * Note that the driver takes input as: degrees.minutes
- *
- * CAUTION: Generally you should use 0 < degrees < 180 as anything else
- * is probably beyond the range of your servo and may damage it.
- *
- * Jun 16, 2004: Sean Young <sean@mess.org>
- *  - cleanups
- *  - was using memory after kfree()
- * Aug 8, 2004: Sean Young <sean@mess.org>
- *  - set the highest angle as high as the hardware allows, there are 
- *    some odd servos out there
- *
- */
-
-#include <linux/config.h>
-#ifdef CONFIG_USB_DEBUG
-#define DEBUG	1
-#endif
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/usb.h>
-
-#define DRIVER_AUTHOR "Sean Young <sean@mess.org>"
-#define DRIVER_DESC "USB PhidgetServo Driver"
-
-#define VENDOR_ID_GLAB				0x06c2
-#define DEVICE_ID_GLAB_PHIDGETSERVO_QUAD	0x0038
-#define DEVICE_ID_GLAB_PHIDGETSERVO_UNI		0x0039
-
-#define VENDOR_ID_WISEGROUP			0x0925
-#define VENDOR_ID_WISEGROUP_PHIDGETSERVO_QUAD	0x8101
-#define VENDOR_ID_WISEGROUP_PHIDGETSERVO_UNI	0x8104
-
-#define SERVO_VERSION_30			0x01
-#define SERVO_COUNT_QUAD			0x02
-
-static struct usb_device_id id_table[] = {
-	{
-		USB_DEVICE(VENDOR_ID_GLAB, DEVICE_ID_GLAB_PHIDGETSERVO_QUAD), 
-		.driver_info = SERVO_VERSION_30 | SERVO_COUNT_QUAD 
-	},
-	{
-		USB_DEVICE(VENDOR_ID_GLAB, DEVICE_ID_GLAB_PHIDGETSERVO_UNI),
-		.driver_info = SERVO_VERSION_30 
-	},
-	{
-		USB_DEVICE(VENDOR_ID_WISEGROUP, 
-				VENDOR_ID_WISEGROUP_PHIDGETSERVO_QUAD),
-		.driver_info = SERVO_COUNT_QUAD 
-	},
-	{
-		USB_DEVICE(VENDOR_ID_WISEGROUP, 
-				VENDOR_ID_WISEGROUP_PHIDGETSERVO_UNI),
-		.driver_info = 0
-	},
-	{}
-};
-
-MODULE_DEVICE_TABLE(usb, id_table);
-
-struct phidget_servo {
-	struct usb_device *udev;
-	ulong type;
-	int pulse[4];
-	int degrees[4];
-	int minutes[4];
-};
-
-static int
-change_position_v30(struct phidget_servo *servo, int servo_no, int degrees, 
-								int minutes)
-{
-	int retval;
-	unsigned char *buffer;
-
-	if (degrees < -23 || degrees > 362)
-		return -EINVAL;
-
-	buffer = kmalloc(6, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&servo->udev->dev, "%s - out of memory\n",
-			__FUNCTION__);
-		return -ENOMEM;
-	}
-
-	/*
-	 * pulse = 0 - 4095
-	 * angle = 0 - 180 degrees
-	 *
-	 * pulse = angle * 10.6 + 243.8	
-	 */
-	servo->pulse[servo_no] = ((degrees*60 + minutes)*106 + 2438*60)/600;	
-	servo->degrees[servo_no]= degrees;
-	servo->minutes[servo_no]= minutes;	
-
-	/* 
-	 * The PhidgetServo v3.0 is controlled by sending 6 bytes,
-	 * 4 * 12 bits for each servo.
-	 *
-	 * low = lower 8 bits pulse
-	 * high = higher 4 bits pulse
-	 *
-	 * offset     bits
-	 * +---+-----------------+
-	 * | 0 |      low 0      |
-	 * +---+--------+--------+
-	 * | 1 | high 1 | high 0 |
-	 * +---+--------+--------+
-	 * | 2 |      low 1      |
-	 * +---+-----------------+
-	 * | 3 |      low 2      |
-	 * +---+--------+--------+
-	 * | 4 | high 3 | high 2 |
-	 * +---+--------+--------+
-	 * | 5 |      low 3      |
-	 * +---+-----------------+
-	 */
-
-	buffer[0] = servo->pulse[0] & 0xff;
-	buffer[1] = (servo->pulse[0] >> 8 & 0x0f)
-	    | (servo->pulse[1] >> 4 & 0xf0);
-	buffer[2] = servo->pulse[1] & 0xff;
-	buffer[3] = servo->pulse[2] & 0xff;
-	buffer[4] = (servo->pulse[2] >> 8 & 0x0f)
-	    | (servo->pulse[3] >> 4 & 0xf0);
-	buffer[5] = servo->pulse[3] & 0xff;
-
-	dev_dbg(&servo->udev->dev,
-		"data: %02x %02x %02x %02x %02x %02x\n",
-		buffer[0], buffer[1], buffer[2],
-		buffer[3], buffer[4], buffer[5]);
-
-	retval = usb_control_msg(servo->udev,
-				 usb_sndctrlpipe(servo->udev, 0),
-				 0x09, 0x21, 0x0200, 0x0000, buffer, 6, 2 * HZ);
-
-	kfree(buffer);
-
-	return retval;
-}
-
-static int
-change_position_v20(struct phidget_servo *servo, int servo_no, int degrees,
-								int minutes)
-{
-	int retval;
-	unsigned char *buffer;
-
-	if (degrees < -23 || degrees > 278)
-		return -EINVAL;
-
-	buffer = kmalloc(2, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&servo->udev->dev, "%s - out of memory\n",
-			__FUNCTION__);
-		return -ENOMEM;
-	}
-
-	/*
-	 * angle = 0 - 180 degrees
-	 * pulse = angle + 23
-	 */
-	servo->pulse[servo_no]= degrees + 23;
-	servo->degrees[servo_no]= degrees;
-	servo->minutes[servo_no]= 0;
-
-	/*
-	 * The PhidgetServo v2.0 is controlled by sending two bytes. The
-	 * first byte is the servo number xor'ed with 2:
-	 *
-	 * servo 0 = 2
-	 * servo 1 = 3
-	 * servo 2 = 0
-	 * servo 3 = 1
-	 *
-	 * The second byte is the position.
-	 */
-
-	buffer[0] = servo_no ^ 2;
-	buffer[1] = servo->pulse[servo_no];
-
-	dev_dbg(&servo->udev->dev, "data: %02x %02x\n", buffer[0], buffer[1]);
-
-	retval = usb_control_msg(servo->udev,
-				 usb_sndctrlpipe(servo->udev, 0),
-				 0x09, 0x21, 0x0200, 0x0000, buffer, 2, 2 * HZ);
-
-	kfree(buffer);
-
-	return retval;
-}
-
-#define show_set(value)	\
-static ssize_t set_servo##value (struct device *dev,			\
-					const char *buf, size_t count)	\
-{									\
-	int degrees, minutes, retval;					\
-	struct usb_interface *intf = to_usb_interface (dev);		\
-	struct phidget_servo *servo = usb_get_intfdata (intf);		\
-									\
-	minutes = 0;							\
-	/* must at least convert degrees */				\
-	if (sscanf (buf, "%d.%d", &degrees, &minutes) < 1) {		\
-		return -EINVAL;						\
-	}								\
-									\
-	if (minutes < 0 || minutes > 59) 				\
-		return -EINVAL;						\
-									\
-	if (servo->type & SERVO_VERSION_30)				\
-		retval = change_position_v30 (servo, value, degrees, 	\
-							minutes);	\
-	else 								\
-		retval = change_position_v20 (servo, value, degrees, 	\
-							minutes);	\
-									\
-	return retval < 0 ? retval : count;				\
-}									\
-									\
-static ssize_t show_servo##value (struct device *dev, char *buf) 	\
-{									\
-	struct usb_interface *intf = to_usb_interface (dev);		\
-	struct phidget_servo *servo = usb_get_intfdata (intf);		\
-									\
-	return sprintf (buf, "%d.%02d\n", servo->degrees[value],	\
-				servo->minutes[value]);			\
-}									\
-static DEVICE_ATTR(servo##value, S_IWUGO | S_IRUGO,			\
-	  show_servo##value, set_servo##value);
-
-show_set(0);
-show_set(1);
-show_set(2);
-show_set(3);
-
-static int
-servo_probe(struct usb_interface *interface, const struct usb_device_id *id)
-{
-	struct usb_device *udev = interface_to_usbdev(interface);
-	struct phidget_servo *dev;
-
-	dev = kmalloc(sizeof (struct phidget_servo), GFP_KERNEL);
-	if (dev == NULL) {
-		dev_err(&interface->dev, "%s - out of memory\n", __FUNCTION__);
-		return -ENOMEM;
-	}
-	memset(dev, 0x00, sizeof (*dev));
-
-	dev->udev = usb_get_dev(udev);
-	dev->type = id->driver_info;
-	usb_set_intfdata(interface, dev);
-
-	device_create_file(&interface->dev, &dev_attr_servo0);
-	if (dev->type & SERVO_COUNT_QUAD) {
-		device_create_file(&interface->dev, &dev_attr_servo1);
-		device_create_file(&interface->dev, &dev_attr_servo2);
-		device_create_file(&interface->dev, &dev_attr_servo3);
-	}
-
-	dev_info(&interface->dev, "USB %d-Motor PhidgetServo v%d.0 attached\n",
-		dev->type & SERVO_COUNT_QUAD ? 4 : 1,
-		dev->type & SERVO_VERSION_30 ? 3 : 2);
-
-	if(!(dev->type & SERVO_VERSION_30))
-		dev_info(&interface->dev,
-			 "WARNING: v2.0 not tested! Please report if it works.\n");
-
-	return 0;
-}
-
-static void
-servo_disconnect(struct usb_interface *interface)
-{
-	struct phidget_servo *dev;
-
-	dev = usb_get_intfdata(interface);
-	usb_set_intfdata(interface, NULL);
-
-	device_remove_file(&interface->dev, &dev_attr_servo0);
-	if (dev->type & SERVO_COUNT_QUAD) {
-		device_remove_file(&interface->dev, &dev_attr_servo1);
-		device_remove_file(&interface->dev, &dev_attr_servo2);
-		device_remove_file(&interface->dev, &dev_attr_servo3);
-	}
-
-	usb_put_dev(dev->udev);
-
-	dev_info(&interface->dev, "USB %d-Motor PhidgetServo v%d.0 detached\n",
-		dev->type & SERVO_COUNT_QUAD ? 4 : 1,
-		dev->type & SERVO_VERSION_30 ? 3 : 2);
-
-	kfree(dev);
-}
-
-static struct usb_driver servo_driver = {
-	.owner = THIS_MODULE,
-	.name = "phidgetservo",
-	.probe = servo_probe,
-	.disconnect = servo_disconnect,
-	.id_table = id_table
-};
-
-static int __init
-phidget_servo_init(void)
-{
-	int retval;
-
-	retval = usb_register(&servo_driver);
-	if (retval)
-		err("usb_register failed. Error number %d", retval);
-
-	return retval;
-}
-
-static void __exit
-phidget_servo_exit(void)
-{
-	usb_deregister(&servo_driver);
-}
-
-module_init(phidget_servo_init);
-module_exit(phidget_servo_exit);
-
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
diff -Naur linuxppc-2.6.9/drivers/usb/misc/speedtch.c linuxppc-2.6.9-dream/drivers/usb/misc/speedtch.c
--- linuxppc-2.6.9/drivers/usb/misc/speedtch.c	2004-10-18 23:55:35.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/speedtch.c	2005-09-19 21:40:06.000000000 +0200
@@ -84,10 +84,6 @@
 #define VERBOSE_DEBUG
 */
 
-#if !defined (DEBUG) && defined (CONFIG_USB_DEBUG)
-#	define DEBUG
-#endif
-
 #include <linux/usb.h>
 
 #ifdef DEBUG
@@ -106,8 +102,8 @@
 #endif
 
 #define DRIVER_AUTHOR	"Johan Verrept, Duncan Sands <duncan.sands@free.fr>"
-#define DRIVER_VERSION	"1.8"
-#define DRIVER_DESC	"Alcatel SpeedTouch USB driver version " DRIVER_VERSION
+#define DRIVER_DESC	"Alcatel SpeedTouch USB driver"
+#define DRIVER_VERSION	"1.7"
 
 static const char udsl_driver_name [] = "speedtch";
 
@@ -269,7 +265,7 @@
 static void udsl_atm_dev_close (struct atm_dev *dev);
 static int udsl_atm_open (struct atm_vcc *vcc);
 static void udsl_atm_close (struct atm_vcc *vcc);
-static int udsl_atm_ioctl (struct atm_dev *dev, unsigned int cmd, void __user *arg);
+static int udsl_atm_ioctl (struct atm_dev *dev, unsigned int cmd, void *arg);
 static int udsl_atm_send (struct atm_vcc *vcc, struct sk_buff *skb);
 static int udsl_atm_proc_read (struct atm_dev *atm_dev, loff_t *pos, char *page);
 
@@ -299,19 +295,6 @@
 };
 
 
-/***********
-**  misc  **
-***********/
-
-static inline void udsl_pop (struct atm_vcc *vcc, struct sk_buff *skb)
-{
-	if (vcc->pop)
-		vcc->pop (vcc, skb);
-	else
-		dev_kfree_skb (skb);
-}
-
-
 /*************
 **  decode  **
 *************/
@@ -733,7 +716,10 @@
 	if (!UDSL_SKB (skb)->num_cells) {
 		struct atm_vcc *vcc = UDSL_SKB (skb)->atm_data.vcc;
 
-		udsl_pop (vcc, skb);
+		if (vcc->pop)
+			vcc->pop (vcc, skb);
+		else
+			dev_kfree_skb (skb);
 		instance->current_skb = NULL;
 
 		atomic_inc (&vcc->stats->tx);
@@ -752,7 +738,10 @@
 		if (UDSL_SKB (skb)->atm_data.vcc == vcc) {
 			dbg ("udsl_cancel_send: popping skb 0x%p", skb);
 			__skb_unlink (skb, &instance->sndqueue);
-			udsl_pop (vcc, skb);
+			if (vcc->pop)
+				vcc->pop (vcc, skb);
+			else
+				dev_kfree_skb (skb);
 		}
 	spin_unlock_irq (&instance->sndqueue.lock);
 
@@ -760,7 +749,10 @@
 	if ((skb = instance->current_skb) && (UDSL_SKB (skb)->atm_data.vcc == vcc)) {
 		dbg ("udsl_cancel_send: popping current skb (0x%p)", skb);
 		instance->current_skb = NULL;
-		udsl_pop (vcc, skb);
+		if (vcc->pop)
+			vcc->pop (vcc, skb);
+		else
+			dev_kfree_skb (skb);
 	}
 	tasklet_enable (&instance->send_tasklet);
 	dbg ("udsl_cancel_send done");
@@ -769,26 +761,22 @@
 static int udsl_atm_send (struct atm_vcc *vcc, struct sk_buff *skb)
 {
 	struct udsl_instance_data *instance = vcc->dev->dev_data;
-	int err;
 
 	vdbg ("udsl_atm_send called (skb 0x%p, len %u)", skb, skb->len);
 
 	if (!instance || !instance->usb_dev) {
 		dbg ("udsl_atm_send: NULL data!");
-		err = -ENODEV;
-		goto fail;
+		return -ENODEV;
 	}
 
 	if (vcc->qos.aal != ATM_AAL5) {
 		dbg ("udsl_atm_send: unsupported ATM type %d!", vcc->qos.aal);
-		err = -EINVAL;
-		goto fail;
+		return -EINVAL;
 	}
 
 	if (skb->len > ATM_MAX_AAL5_PDU) {
 		dbg ("udsl_atm_send: packet too long (%d vs %d)!", skb->len, ATM_MAX_AAL5_PDU);
-		err = -EINVAL;
-		goto fail;
+		return -EINVAL;
 	}
 
 	PACKETDEBUG (skb->data, skb->len);
@@ -798,10 +786,6 @@
 	tasklet_schedule (&instance->send_tasklet);
 
 	return 0;
-
-fail:
-	udsl_pop (vcc, skb);
-	return err;
 }
 
 
@@ -991,11 +975,11 @@
 	dbg ("udsl_atm_close successful");
 }
 
-static int udsl_atm_ioctl (struct atm_dev *dev, unsigned int cmd, void __user *arg)
+static int udsl_atm_ioctl (struct atm_dev *dev, unsigned int cmd, void *arg)
 {
 	switch (cmd) {
 	case ATM_QUERYLOOP:
-		return put_user (ATM_LM_NONE, (int __user *)arg) ? -EFAULT : 0;
+		return put_user (ATM_LM_NONE, (int *) arg) ? -EFAULT : 0;
 	default:
 		return -ENOIOCTLCMD;
 	}
@@ -1149,7 +1133,7 @@
 	}
 
 	/* ATM init */
-	if (!(instance->atm_dev = atm_dev_register (udsl_driver_name, &udsl_atm_devops, -1, NULL))) {
+	if (!(instance->atm_dev = atm_dev_register (udsl_driver_name, &udsl_atm_devops, -1, 0))) {
 		dbg ("udsl_usb_probe: failed to register ATM device!");
 		goto fail;
 	}
@@ -1347,7 +1331,6 @@
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_DESCRIPTION (DRIVER_DESC);
 MODULE_LICENSE ("GPL");
-MODULE_VERSION (DRIVER_VERSION);
 
 
 /************
diff -Naur linuxppc-2.6.9/drivers/usb/misc/tiglusb.c linuxppc-2.6.9-dream/drivers/usb/misc/tiglusb.c
--- linuxppc-2.6.9/drivers/usb/misc/tiglusb.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/tiglusb.c	2005-09-19 21:40:06.000000000 +0200
@@ -3,14 +3,14 @@
  * tiglusb -- Texas Instruments' USB GraphLink (aka SilverLink) driver.
  * Target: Texas Instruments graphing calculators (http://lpg.ticalc.org).
  *
- * Copyright (C) 2001-2004:
+ * Copyright (C) 2001-2002:
  *   Romain Lievin <roms@lpg.ticalc.org>
  *   Julien BLACHE <jb@technologeek.org>
  * under the terms of the GNU General Public License.
  *
  * Based on dabusb.c, printer.c & scanner.c
  *
- * Please see the file: Documentation/usb/silverlink.txt
+ * Please see the file: linux/Documentation/usb/SilverLink.txt
  * and the website at:  http://lpg.ticalc.org/prj_usb/
  * for more info.
  *
@@ -20,8 +20,6 @@
  *   1.04, Julien: clean-up & fixes; Romain: 2.4 backport.
  *   1.05, Randy Dunlap: bug fix with the timeout parameter (divide-by-zero).
  *   1.06, Romain: synched with 2.5, version/firmware changed (confusing).
- *   1.07, Romain: fixed bad use of usb_clear_halt (invalid argument);
- *          timeout argument checked in ioctl + clean-up.
  */
 
 #include <linux/module.h>
@@ -33,7 +31,6 @@
 #include <linux/usb.h>
 #include <linux/smp_lock.h>
 #include <linux/devfs_fs_kernel.h>
-#include <linux/device.h>
 
 #include <linux/ticable.h>
 #include "tiglusb.h"
@@ -41,8 +38,8 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "1.07"
-#define DRIVER_AUTHOR  "Romain Lievin <roms@tilp.info> & Julien Blache <jb@jblache.org>"
+#define DRIVER_VERSION "1.06"
+#define DRIVER_AUTHOR  "Romain Lievin <roms@lpg.ticalc.org> & Julien Blache <jb@jblache.org>"
 #define DRIVER_DESC    "TI-GRAPH LINK USB (aka SilverLink) driver"
 #define DRIVER_LICENSE "GPL"
 
@@ -50,7 +47,6 @@
 
 static tiglusb_t tiglusb[MAXTIGL];
 static int timeout = TIMAXTIME;	/* timeout in tenth of seconds     */
-static struct class_simple *tiglusb_class;
 
 /*---------- misc functions ------------------------------------------- */
 
@@ -76,15 +72,15 @@
 {
 	unsigned int pipe;
 
-	pipe = usb_sndbulkpipe (dev, 2);
-	if (usb_clear_halt (dev, pipe)) {
-		err ("clear_pipe (w), request failed");
+	pipe = usb_sndbulkpipe (dev, 1);
+	if (usb_clear_halt (dev, usb_pipeendpoint (pipe))) {
+		err ("clear_pipe (r), request failed");
 		return -1;
 	}
 
-	pipe = usb_rcvbulkpipe (dev, 1);
-	if (usb_clear_halt (dev, pipe)) {
-		err ("clear_pipe (r), request failed");
+	pipe = usb_sndbulkpipe (dev, 2);
+	if (usb_clear_halt (dev, usb_pipeendpoint (pipe))) {
+		err ("clear_pipe (w), request failed");
 		return -1;
 	}
 
@@ -132,7 +128,7 @@
 	filp->f_pos = 0;
 	filp->private_data = s;
 
-	return nonseekable_open(inode, filp);
+	return 0;
 }
 
 static int
@@ -185,16 +181,17 @@
 
 	pipe = usb_rcvbulkpipe (s->dev, 1);
 	result = usb_bulk_msg (s->dev, pipe, buffer, bytes_to_read,
-			       &bytes_read, (HZ * timeout) / 10);
+			       &bytes_read, HZ * 10 / timeout);
 	if (result == -ETIMEDOUT) {	/* NAK */
-		if (!bytes_read)
+		ret = result;
+		if (!bytes_read) {
 			dbg ("quirk !");
+		}
 		warn ("tiglusb_read, NAK received.");
-		ret = result;
 		goto out;
 	} else if (result == -EPIPE) {	/* STALL -- shouldn't happen */
 		warn ("clear_halt request to remove STALL condition.");
-		if (usb_clear_halt (s->dev, pipe))
+		if (usb_clear_halt (s->dev, usb_pipeendpoint (pipe)))
 			err ("clear_halt, request failed");
 		clear_device (s->dev);
 		ret = result;
@@ -246,7 +243,7 @@
 
 	pipe = usb_sndbulkpipe (s->dev, 2);
 	result = usb_bulk_msg (s->dev, pipe, buffer, bytes_to_write,
-			       &bytes_written, (HZ * timeout) / 10);
+			       &bytes_written, HZ * 10 / timeout);
 
 	if (result == -ETIMEDOUT) {	/* NAK */
 		warn ("tiglusb_write, NAK received.");
@@ -254,7 +251,7 @@
 		goto out;
 	} else if (result == -EPIPE) {	/* STALL -- shouldn't happen */
 		warn ("clear_halt request to remove STALL condition.");
-		if (usb_clear_halt (s->dev, pipe))
+		if (usb_clear_halt (s->dev, usb_pipeendpoint (pipe)))
 			err ("clear_halt, request failed");
 		clear_device (s->dev);
 		ret = result;
@@ -295,16 +292,15 @@
 
 	switch (cmd) {
 	case IOCTL_TIUSB_TIMEOUT:
-		if (arg > 0)
-			timeout = arg;
-		else
-			ret = -EINVAL;
+		timeout = arg;	// timeout value in tenth of seconds
 		break;
 	case IOCTL_TIUSB_RESET_DEVICE:
+		dbg ("IOCTL_TIGLUSB_RESET_DEVICE");
 		if (clear_device (s->dev))
 			ret = -EIO;
 		break;
 	case IOCTL_TIUSB_RESET_PIPES:
+		dbg ("IOCTL_TIGLUSB_RESET_PIPES");
 		if (clear_pipes (s->dev))
 			ret = -EIO;
 		break;
@@ -338,7 +334,7 @@
 {
 	struct usb_device *dev = interface_to_usbdev(intf);
 	int minor = -1;
-	int i, err = 0;
+	int i;
 	ptiglusb_t s;
 
 	dbg ("probing vendor id 0x%x, device id 0x%x",
@@ -349,23 +345,18 @@
 	 * the TIGL hardware, there's only 1 configuration.
 	 */
 
-	if (dev->descriptor.bNumConfigurations != 1) {
-		err = -ENODEV;
-		goto out;
-	}
+	if (dev->descriptor.bNumConfigurations != 1)
+		return -ENODEV;
 
 	if ((dev->descriptor.idProduct != 0xe001)
-	    && (dev->descriptor.idVendor != 0x451)) {
-		err = -ENODEV;
-		goto out;
-	}
+	    && (dev->descriptor.idVendor != 0x451))
+		return -ENODEV;
 
 	// NOTE:  it's already in this config, this shouldn't be needed.
 	// is this working around some hardware bug?
 	if (usb_reset_configuration (dev) < 0) {
 		err ("tiglusb_probe: reset_configuration failed");
-		err = -ENODEV;
-		goto out;
+		return -ENODEV;
 	}
 
 	/*
@@ -379,10 +370,8 @@
 		}
 	}
 
-	if (minor == -1) {
-		err = -ENODEV;
-		goto out;
-	}
+	if (minor == -1)
+		return -ENODEV;
 
 	s = &tiglusb[minor];
 
@@ -392,28 +381,17 @@
 	up (&s->mutex);
 	dbg ("bound to interface");
 
-	class_simple_device_add(tiglusb_class, MKDEV(TIUSB_MAJOR, TIUSB_MINOR + s->minor),
-			NULL, "usb%d", s->minor);
-	err = devfs_mk_cdev(MKDEV(TIUSB_MAJOR, TIUSB_MINOR) + s->minor,
+	devfs_mk_cdev(MKDEV(TIUSB_MAJOR, TIUSB_MINOR) + s->minor,
 			S_IFCHR | S_IRUGO | S_IWUGO,
 			"ticables/usb/%d", s->minor);
 
-	if (err)
-		goto out_class;
-
 	/* Display firmware version */
 	info ("firmware revision %i.%02x",
 		dev->descriptor.bcdDevice >> 8,
 		dev->descriptor.bcdDevice & 0xff);
 
 	usb_set_intfdata (intf, s);
-	err = 0;
-	goto out;
-
-out_class:
-	class_simple_device_remove(MKDEV(TIUSB_MAJOR, TIUSB_MINOR + s->minor));
-out:
-	return err;
+	return 0;
 }
 
 static void
@@ -443,7 +421,6 @@
 	s->dev = NULL;
 	s->opened = 0;
 
-	class_simple_device_remove(MKDEV(TIUSB_MAJOR, TIUSB_MINOR + s->minor));
 	devfs_remove("ticables/usb/%d", s->minor);
 
 	info ("device %d removed", s->minor);
@@ -470,7 +447,7 @@
 
 #ifndef MODULE
 /*
- * You can use 'tiusb=timeout' to set timeout.
+ * You can use 'tiusb=timeout'
  */
 static int __init
 tiglusb_setup (char *str)
@@ -480,11 +457,10 @@
 	str = get_options (str, ARRAY_SIZE (ints), ints);
 
 	if (ints[0] > 0) {
-		if (ints[1] > 0)
-			timeout = ints[1];
-		else
-			info ("tiglusb: wrong timeout value (0), using default value.");
+		timeout = ints[1];
 	}
+	if (timeout <= 0)
+		timeout = TIMAXTIME;
 
 	return 1;
 }
@@ -494,7 +470,7 @@
 tiglusb_init (void)
 {
 	unsigned u;
-	int result, err = 0;
+	int result;
 
 	/* initialize struct */
 	for (u = 0; u < MAXTIGL; u++) {
@@ -511,41 +487,31 @@
 	/* register device */
 	if (register_chrdev (TIUSB_MAJOR, "tiglusb", &tiglusb_fops)) {
 		err ("unable to get major %d", TIUSB_MAJOR);
-		err = -EIO;
-		goto out;
+		return -EIO;
 	}
 
 	/* Use devfs, tree: /dev/ticables/usb/[0..3] */
 	devfs_mk_dir ("ticables/usb");
 
-	tiglusb_class = class_simple_create(THIS_MODULE, "tiglusb");
-	if (IS_ERR(tiglusb_class)) {
-		err = PTR_ERR(tiglusb_class);
-		goto out_chrdev;
-	}
 	/* register USB module */
 	result = usb_register (&tiglusb_driver);
 	if (result < 0) {
-		err = -1;
-		goto out_chrdev;
+		unregister_chrdev (TIUSB_MAJOR, "tiglusb");
+		return -1;
 	}
 
 	info (DRIVER_DESC ", version " DRIVER_VERSION);
 
-	err = 0;
-	goto out;
+	if (timeout <= 0)
+		timeout = TIMAXTIME;
 
-out_chrdev:
-	unregister_chrdev (TIUSB_MAJOR, "tiglusb");
-out:
-	return err;
+	return 0;
 }
 
 static void __exit
 tiglusb_cleanup (void)
 {
 	usb_deregister (&tiglusb_driver);
-	class_simple_destroy(tiglusb_class);
 	devfs_remove("ticables/usb");
 	unregister_chrdev (TIUSB_MAJOR, "tiglusb");
 }
@@ -560,7 +526,7 @@
 MODULE_DESCRIPTION (DRIVER_DESC);
 MODULE_LICENSE (DRIVER_LICENSE);
 
-module_param(timeout, int, 0);
+MODULE_PARM (timeout, "i");
 MODULE_PARM_DESC (timeout, "Timeout in tenths of seconds (default=1.5 seconds)");
 
 /* --------------------------------------------------------------------- */
diff -Naur linuxppc-2.6.9/drivers/usb/misc/usbtest.c linuxppc-2.6.9-dream/drivers/usb/misc/usbtest.c
--- linuxppc-2.6.9/drivers/usb/misc/usbtest.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/usbtest.c	2005-09-19 21:40:06.000000000 +0200
@@ -121,8 +121,8 @@
 	for (tmp = 0; tmp < intf->num_altsetting; tmp++) {
 		unsigned	ep;
 
-		in = out = NULL;
-		iso_in = iso_out = NULL;
+		in = out = 0;
+		iso_in = iso_out = 0;
 		alt = intf->altsetting + tmp;
 
 		/* take the first altsetting with in-bulk + out-bulk;
@@ -216,11 +216,11 @@
 	struct urb		*urb;
 
 	if (bytes < 0)
-		return NULL;
+		return 0;
 	urb = usb_alloc_urb (0, SLAB_KERNEL);
 	if (!urb)
 		return urb;
-	usb_fill_bulk_urb (urb, udev, pipe, NULL, bytes, simple_callback, NULL);
+	usb_fill_bulk_urb (urb, udev, pipe, 0, bytes, simple_callback, 0);
 	urb->interval = (udev->speed == USB_SPEED_HIGH)
 			? (INTERRUPT_RATE << 3)
 			: INTERRUPT_RATE;
@@ -231,7 +231,7 @@
 			&urb->transfer_dma);
 	if (!urb->transfer_buffer) {
 		usb_free_urb (urb);
-		urb = NULL;
+		urb = 0;
 	} else
 		memset (urb->transfer_buffer, 0, bytes);
 	return urb;
@@ -380,7 +380,7 @@
 
 	sg = kmalloc (nents * sizeof *sg, SLAB_KERNEL);
 	if (!sg)
-		return NULL;
+		return 0;
 	memset (sg, 0, nents * sizeof *sg);
 
 	for (i = 0; i < nents; i++) {
@@ -389,7 +389,7 @@
 		buf = kmalloc (size, SLAB_KERNEL);
 		if (!buf) {
 			free_sglist (sg, i);
-			return NULL;
+			return 0;
 		}
 		memset (buf, 0, size);
 
@@ -459,8 +459,8 @@
  * or remote wakeup (which needs human interaction).
  */
 
-static unsigned realworld = 1;
-module_param (realworld, uint, 0);
+static int realworld = 1;
+MODULE_PARM (realworld, "i");
 MODULE_PARM_DESC (realworld, "clear to demand stricter ch9 compliance");
 
 static int get_altsetting (struct usbtest_dev *dev)
@@ -637,7 +637,7 @@
 
 	/* and sometimes [9.2.6.6] speed dependent descriptors */
 	if (udev->descriptor.bcdUSB == 0x0200) {	/* pre-swapped */
-		struct usb_qualifier_descriptor		*d = NULL;
+		struct usb_qualifier_descriptor		*d = 0;
 
 		/* device qualifier [9.6.2] */
 		retval = usb_get_descriptor (udev,
@@ -802,7 +802,6 @@
 				switch (status) {
 				case -EINPROGRESS:
 				case -EBUSY:
-				case -EIDRM:
 					continue;
 				default:
 					dbg ("urb unlink --> %d", status);
@@ -817,11 +816,11 @@
 		if ((status = usb_submit_urb (urb, SLAB_ATOMIC)) != 0) {
 			dbg ("can't resubmit ctrl %02x.%02x, err %d",
 				reqp->bRequestType, reqp->bRequest, status);
-			urb->dev = NULL;
+			urb->dev = 0;
 		} else
 			ctx->pending++;
 	} else
-		urb->dev = NULL;
+		urb->dev = 0;
 	
 	/* signal completion when nothing's queued */
 	if (ctx->pending == 0)
@@ -1039,6 +1038,8 @@
 	if (!status)
 		status = usb_submit_urb (urb, SLAB_ATOMIC);
 	if (status) {
+		if (status == -ECONNRESET || status == -ENOENT)
+			status = 0;
 		urb->status = status;
 		complete ((struct completion *) urb->context);
 	}
@@ -1054,7 +1055,8 @@
 	urb = simple_alloc_urb (testdev_to_usbdev (dev), pipe, size);
 	if (!urb)
 		return -ENOMEM;
-	urb->transfer_flags |= URB_ASYNC_UNLINK;
+	if (async)
+		urb->transfer_flags |= URB_ASYNC_UNLINK;
 	urb->context = &completion;
 	urb->complete = unlink1_callback;
 
@@ -1072,21 +1074,17 @@
 	/* unlinking that should always work.  variable delay tests more
 	 * hcd states and code paths, even with little other system load.
 	 */
-	msleep (jiffies % (2 * INTERRUPT_RATE));
-	if (async) {
+	wait_ms (jiffies % (2 * INTERRUPT_RATE));
 retry:
-		retval = usb_unlink_urb (urb);
-		if (retval == -EBUSY || retval == -EIDRM) {
-			/* we can't unlink urbs while they're completing.
-			 * or if they've completed, and we haven't resubmitted.
-			 * "normal" drivers would prevent resubmission, but
-			 * since we're testing unlink paths, we can't.
-			 */
-			dev_dbg (&dev->intf->dev, "unlink retry\n");
-			goto retry;
-		}
-	} else
-		usb_kill_urb (urb);
+	retval = usb_unlink_urb (urb);
+	if (retval == -EBUSY) {
+		/* we can't unlink urbs while they're completing.
+		 * "normal" drivers would prevent resubmission, but
+		 * since we're testing unlink paths, we can't.
+		 */
+		dev_dbg (&dev->intf->dev, "unlink retry\n");
+		goto retry;
+	}
 	if (!(retval == 0 || retval == -EINPROGRESS)) {
 		dev_dbg (&dev->intf->dev, "unlink fail %d\n", retval);
 		return retval;
@@ -1097,10 +1095,9 @@
 	simple_free_urb (urb);
 
 	if (async)
-		return (retval == -ECONNRESET) ? 0 : retval - 1000;
+		return (retval != -ECONNRESET) ? -ECONNRESET : 0;
 	else
-		return (retval == -ENOENT || retval == -EPERM) ?
-				0 : retval - 2000;
+		return (retval != -ENOENT) ? -ENOENT : 0;
 }
 
 static int unlink_simple (struct usbtest_dev *dev, int pipe, int len)
@@ -1172,8 +1169,7 @@
 
 	/* set halt (protocol test only), verify it worked */
 	retval = usb_control_msg (urb->dev, usb_sndctrlpipe (urb->dev, 0),
-			USB_REQ_SET_FEATURE, USB_RECIP_ENDPOINT,
-			USB_ENDPOINT_HALT, ep,
+			USB_REQ_SET_FEATURE, USB_RECIP_ENDPOINT, 0, ep,
 			NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
 	if (retval < 0) {
 		dbg ("ep %02x couldn't set halt, %d", ep, retval);
@@ -1371,7 +1367,7 @@
 	unsigned		i, maxp, packets;
 
 	if (bytes < 0 || !desc)
-		return NULL;
+		return 0;
 	maxp = 0x7ff & desc->wMaxPacketSize;
 	maxp *= 1 + (0x3 & (desc->wMaxPacketSize >> 11));
 	packets = (bytes + maxp - 1) / maxp;
@@ -1388,7 +1384,7 @@
 			&urb->transfer_dma);
 	if (!urb->transfer_buffer) {
 		usb_free_urb (urb);
-		return NULL;
+		return 0;
 	}
 	memset (urb->transfer_buffer, 0, bytes);
 	for (i = 0; i < packets; i++) {
@@ -1811,17 +1807,17 @@
 
 /*-------------------------------------------------------------------------*/
 
-static unsigned force_interrupt = 0;
-module_param (force_interrupt, uint, 0);
+static int force_interrupt = 0;
+MODULE_PARM (force_interrupt, "i");
 MODULE_PARM_DESC (force_interrupt, "0 = test default; else interrupt");
 
 #ifdef	GENERIC
-static unsigned short vendor;
-module_param(vendor, ushort, 0);
+static int vendor;
+MODULE_PARM (vendor, "h");
 MODULE_PARM_DESC (vendor, "vendor code (from usb-if)");
 
-static unsigned short product;
-module_param(product, ushort, 0);
+static int product;
+MODULE_PARM (product, "h");
 MODULE_PARM_DESC (product, "product code (from vendor)");
 #endif
 
diff -Naur linuxppc-2.6.9/drivers/usb/misc/uss720.c linuxppc-2.6.9-dream/drivers/usb/misc/uss720.c
--- linuxppc-2.6.9/drivers/usb/misc/uss720.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/misc/uss720.c	2005-09-19 21:40:06.000000000 +0200
@@ -553,7 +553,7 @@
 	i = usb_set_interface(usbdev, intf->altsetting->desc.bInterfaceNumber, 2);
 	printk(KERN_DEBUG "uss720: set inteface result %d\n", i);
 
-	interface = intf->cur_altsetting;
+	interface = &intf->altsetting[2];
 
 	/*
 	 * Allocate parport interface 
diff -Naur linuxppc-2.6.9/drivers/usb/net/catc.c linuxppc-2.6.9-dream/drivers/usb/net/catc.c
--- linuxppc-2.6.9/drivers/usb/net/catc.c	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/net/catc.c	2005-09-19 21:40:06.000000000 +0200
@@ -242,7 +242,7 @@
 
 	do {
 		if(!catc->is_f5u011) {
-			pkt_len = le16_to_cpup((__le16*)pkt_start);
+			pkt_len = le16_to_cpup((u16*)pkt_start);
 			if (pkt_len > urb->actual_length) {
 				catc->stats.rx_length_errors++;
 				catc->stats.rx_errors++;
@@ -303,7 +303,7 @@
 		else if (data[1] & 0x20)
 			linksts = LinkBad;
 	} else {
-		hasdata = (unsigned int)(be16_to_cpup((__be16*)data) & 0x0fff);
+		hasdata = (unsigned int)(be16_to_cpup((u16*)data) & 0x0fff);
 		if (data[0] == 0x90)
 			linksts = LinkGood;
 		else if (data[0] == 0xA0)
@@ -672,7 +672,7 @@
         struct catc *catc = dev->priv;
         u32 cmd;
         
-        if (get_user(cmd, (u32 __user *)useraddr))
+        if (get_user(cmd, (u32 *)useraddr))
                 return -EFAULT;
 
         switch (cmd) {
@@ -726,7 +726,7 @@
 {
         switch(cmd) {
         case SIOCETHTOOL:
-                return netdev_ethtool_ioctl(dev, rq->ifr_data);
+                return netdev_ethtool_ioctl(dev, (void __user *)rq->ifr_data);
         default:
                 return -EOPNOTSUPP;
         }
diff -Naur linuxppc-2.6.9/drivers/usb/net/kaweth.c linuxppc-2.6.9-dream/drivers/usb/net/kaweth.c
--- linuxppc-2.6.9/drivers/usb/net/kaweth.c	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/net/kaweth.c	2005-09-19 21:40:06.000000000 +0200
@@ -62,7 +62,7 @@
 #include <asm/semaphore.h>
 #include <asm/byteorder.h>
 
-#undef DEBUG
+#define DEBUG
 
 #ifdef DEBUG
 #define kaweth_dbg(format, arg...) printk(KERN_DEBUG __FILE__ ": " format "\n" ,##arg)
@@ -123,10 +123,9 @@
 		const struct usb_device_id *id	/* from id_table */
 	);
 static void kaweth_disconnect(struct usb_interface *intf);
-static int kaweth_internal_control_msg(struct usb_device *usb_dev,
-				       unsigned int pipe,
-				       struct usb_ctrlrequest *cmd, void *data,
-				       int len, int timeout);
+int kaweth_internal_control_msg(struct usb_device *usb_dev, unsigned int pipe,
+				struct usb_ctrlrequest *cmd, void *data,
+				int len, int timeout);
 
 /****************************************************************
  *     usb_device_id
@@ -203,7 +202,7 @@
 	__u8 reserved2;
 	eth_addr_t hw_addr;
 	__u32 statistics_mask;
-	__le16 segment_size;
+	__u16 segment_size;
 	__u16 max_multicast_filters;
 	__u8 reserved3;
 } __attribute__ ((packed));
@@ -588,11 +587,11 @@
 	int count = urb->actual_length;
 	int count2 = urb->transfer_buffer_length;
 
-	__u16 pkt_len = le16_to_cpup((__le16 *)kaweth->rx_buf);
+	__u16 pkt_len = le16_to_cpup((u16 *)kaweth->rx_buf);
 
 	struct sk_buff *skb;
 
-	if(unlikely(urb->status == -ECONNRESET || urb->status == -ECONNABORTED || urb->status == -ESHUTDOWN))
+	if(unlikely(urb->status == -ECONNRESET || urb->status == -ECONNABORTED))
 	/* we are killed - set a flag and wake the disconnect handler */
 	{
 		kaweth->end = 1;
@@ -668,7 +667,7 @@
 		INTBUFFERSIZE,
 		int_callback,
 		kaweth,
-		8);
+		HZ/4);
 	kaweth->irq_urb->transfer_dma = kaweth->intbufferhandle;
 	kaweth->irq_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
@@ -737,7 +736,7 @@
 {
 	switch (cmd) {
 	case SIOCETHTOOL:
-		return netdev_ethtool_ioctl(net, rq->ifr_data);
+		return netdev_ethtool_ioctl(net, (void __user *)rq->ifr_data);
 	}
 	return -EOPNOTSUPP;
 }
@@ -763,7 +762,7 @@
 static int kaweth_start_xmit(struct sk_buff *skb, struct net_device *net)
 {
 	struct kaweth_device *kaweth = net->priv;
-	__le16 *private_header;
+	u16 *private_header;
 
 	int res;
 
@@ -794,7 +793,7 @@
 		}
 	}
 
-	private_header = (__le16 *)__skb_push(skb, 2);
+	private_header = (u16 *)__skb_push(skb, 2);
 	*private_header = cpu_to_le16(skb->len-2);
 	kaweth->tx_skb = skb;
 
@@ -1240,21 +1239,20 @@
         init_waitqueue_head(&awd.wqh);
         awd.done = 0;
 
+        set_current_state(TASK_INTERRUPTIBLE);
         add_wait_queue(&awd.wqh, &wait);
         urb->context = &awd;
-        status = usb_submit_urb(urb, GFP_NOIO);
+        status = usb_submit_urb(urb, GFP_ATOMIC);
         if (status) {
                 // something went wrong
                 usb_free_urb(urb);
+                set_current_state(TASK_RUNNING);
                 remove_wait_queue(&awd.wqh, &wait);
                 return status;
         }
 
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	while (timeout && !awd.done) {
+	while (timeout && !awd.done)
 		timeout = schedule_timeout(timeout);
-		set_current_state(TASK_UNINTERRUPTIBLE);
-	}
 
         set_current_state(TASK_RUNNING);
         remove_wait_queue(&awd.wqh, &wait);
@@ -1279,10 +1277,9 @@
 
 /*-------------------------------------------------------------------*/
 // returns status (negative) or length (positive)
-static int kaweth_internal_control_msg(struct usb_device *usb_dev,
-				       unsigned int pipe,
-				       struct usb_ctrlrequest *cmd, void *data,
-				       int len, int timeout)
+int kaweth_internal_control_msg(struct usb_device *usb_dev, unsigned int pipe,
+                            struct usb_ctrlrequest *cmd, void *data, int len,
+			    int timeout)
 {
         struct urb *urb;
         int retv;
@@ -1293,7 +1290,7 @@
                 return -ENOMEM;
 
         usb_fill_control_urb(urb, usb_dev, pipe, (unsigned char*)cmd, data,
-			 len, usb_api_blocking_completion, NULL);
+			 len, usb_api_blocking_completion,0);
 
         retv = usb_start_wait_urb(urb, timeout, &length);
         if (retv < 0) {
@@ -1308,7 +1305,7 @@
 /****************************************************************
  *     kaweth_init
  ****************************************************************/
-static int __init kaweth_init(void)
+int __init kaweth_init(void)
 {
 	kaweth_dbg("Driver loading");
 	return usb_register(&kaweth_driver);
@@ -1317,7 +1314,7 @@
 /****************************************************************
  *     kaweth_exit
  ****************************************************************/
-static void __exit kaweth_exit(void)
+void __exit kaweth_exit(void)
 {
 	usb_deregister(&kaweth_driver);
 }
diff -Naur linuxppc-2.6.9/drivers/usb/net/Kconfig linuxppc-2.6.9-dream/drivers/usb/net/Kconfig
--- linuxppc-2.6.9/drivers/usb/net/Kconfig	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/net/Kconfig	2005-09-19 21:40:06.000000000 +0200
@@ -69,7 +69,7 @@
 
 config USB_PEGASUS
 	tristate "USB Pegasus/Pegasus-II based ethernet device support"
-	depends on USB && NET
+	depends on USB && NET_ETHERNET
 	select MII
 	---help---
 	  Say Y here if you know you have Pegasus or Pegasus-II based adapter.
diff -Naur linuxppc-2.6.9/drivers/usb/net/pegasus.c linuxppc-2.6.9-dream/drivers/usb/net/pegasus.c
--- linuxppc-2.6.9/drivers/usb/net/pegasus.c	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/net/pegasus.c	2005-09-19 21:40:06.000000000 +0200
@@ -78,8 +78,8 @@
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
-module_param(loopback, bool, 0);
-module_param(mii_mode, bool, 0);
+MODULE_PARM(loopback, "i");
+MODULE_PARM(mii_mode, "i");
 MODULE_PARM_DESC(loopback, "Enable MAC loopback mode (bit 0)");
 MODULE_PARM_DESC(mii_mode, "Enable HomePNA mode (bit 0),default=MII mode = 0");
 
@@ -286,7 +286,7 @@
 {
 	int i;
 	__u8 data[4] = { phy, 0, 0, indx };
-	__le16 regdi;
+	__u16 regdi;
 
 	set_register(pegasus, PhyCtrl, 0);
 	set_registers(pegasus, PhyAddr, sizeof (data), data);
@@ -347,7 +347,7 @@
 {
 	int i;
 	__u8 tmp;
-	__le16 retdatai;
+	__u16 retdatai;
 
 	set_register(pegasus, EpromCtrl, 0);
 	set_register(pegasus, EpromOffset, index);
@@ -417,7 +417,7 @@
 
 	for (i = 0; i < 3; i++) {
 		read_eprom_word(pegasus, i, &w16);
-		((__le16 *) id)[i] = cpu_to_le16p(&w16);
+		((__u16 *) id)[i] = cpu_to_le16p(&w16);
 	}
 }
 
@@ -581,7 +581,7 @@
 	if (!count)
 		goto goon;
 
-	rx_status = le32_to_cpu(*(__le32 *) (urb->transfer_buffer + count - 4));
+	rx_status = le32_to_cpu(*(int *) (urb->transfer_buffer + count - 4));
 	if (rx_status & 0x000e0000) {
 		dbg("%s: RX packet error %x", net->name, rx_status & 0xe0000);
 		pegasus->stats.rx_errors++;
@@ -594,7 +594,7 @@
 		goto goon;
 	}
 	if (pegasus->chip == 0x8513) {
-		pkt_len = le32_to_cpu(*(__le32 *)urb->transfer_buffer);
+		pkt_len = le32_to_cpu(*(int *)urb->transfer_buffer);
 		pkt_len &= 0x0fff;
 		pegasus->rx_skb->data += 2;
 	} else {
@@ -774,7 +774,7 @@
 
 	netif_stop_queue(net);
 
-	((__le16 *) pegasus->tx_buff)[0] = cpu_to_le16(l16);
+	((__u16 *) pegasus->tx_buff)[0] = cpu_to_le16(l16);
 	memcpy(pegasus->tx_buff + 2, skb->data, skb->len);
 	usb_fill_bulk_urb(pegasus->tx_urb, pegasus->usb,
 			  usb_sndbulkpipe(pegasus->usb, 2),
@@ -1030,7 +1030,7 @@
 	int cmd;
 
 	pegasus = net->priv;
-	if (get_user(cmd, (int __user *) uaddr))
+	if (get_user(cmd, (int *) uaddr))
 		return -EFAULT;
 	switch (cmd) {
 	case ETHTOOL_GDRVINFO:{
@@ -1107,13 +1107,13 @@
 #endif
 static int pegasus_ioctl(struct net_device *net, struct ifreq *rq, int cmd)
 {
-	__u16 *data = (__u16 *) & rq->ifr_ifru;
+	__u16 *data = (__u16 *) & rq->ifr_data;
 	pegasus_t *pegasus = net->priv;
 	int res;
 
 	switch (cmd) {
 	case SIOCETHTOOL:
-		res = pegasus_ethtool_ioctl(net, rq->ifr_data);
+		res = pegasus_ethtool_ioctl(net, (void __user *)rq->ifr_data);
 		break;
 	case SIOCDEVPRIVATE:
 		data[0] = pegasus->phy;
@@ -1137,6 +1137,8 @@
 {
 	pegasus_t *pegasus = net->priv;
 
+	netif_stop_queue(net);
+
 	if (net->flags & IFF_PROMISC) {
 		pegasus->eth_regs[EthCtrl2] |= RX_PROMISCUOUS;
 		info("%s: Promiscuous mode enabled", net->name);
@@ -1152,6 +1154,8 @@
 
 	pegasus->flags |= ETH_REGS_CHANGE;
 	ctrl_callback(pegasus->ctrl_urb, NULL);
+
+	netif_wake_queue(net);
 }
 
 static __u8 mii_phy_probe(pegasus_t * pegasus)
@@ -1317,13 +1321,13 @@
 	.id_table = pegasus_ids,
 };
 
-static int __init pegasus_init(void)
+int __init pegasus_init(void)
 {
 	info(DRIVER_VERSION ":" DRIVER_DESC);
 	return usb_register(&pegasus_driver);
 }
 
-static void __exit pegasus_exit(void)
+void __exit pegasus_exit(void)
 {
 	usb_deregister(&pegasus_driver);
 }
diff -Naur linuxppc-2.6.9/drivers/usb/net/pegasus.h linuxppc-2.6.9-dream/drivers/usb/net/pegasus.h
--- linuxppc-2.6.9/drivers/usb/net/pegasus.h	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/net/pegasus.h	2005-09-19 21:40:06.000000000 +0200
@@ -121,7 +121,6 @@
 #define	VENDOR_ADMTEK		0x07a6
 #define	VENDOR_AEILAB		0x3334
 #define	VENDOR_ALLIEDTEL	0x07c9
-#define	VENDOR_ATEN		0x0557
 #define	VENDOR_BELKIN		0x050d
 #define	VENDOR_BILLIONTON	0x08dd
 #define	VENDOR_COMPAQ		0x049f
@@ -137,7 +136,6 @@
 #define	VENDOR_LANEED		0x056e
 #define	VENDOR_LINKSYS		0x066b
 #define	VENDOR_MELCO		0x0411
-#define	VENDOR_MICROSOFT	0x045e
 #define	VENDOR_MOBILITY		0x1342
 #define	VENDOR_NETGEAR		0x0846
 #define	VENDOR_OCT		0x0b39
@@ -151,8 +149,6 @@
 
 PEGASUS_DEV( "3Com USB Ethernet 3C460B", VENDOR_3COM, 0x4601,
 		DEFAULT_GPIO_RESET | PEGASUS_II )
-PEGASUS_DEV( "ATEN USB Ethernet UC-110T", VENDOR_ATEN, 0x2007,
-		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "USB HPNA/Ethernet", VENDOR_ABOCOM, 0x110c,
 		DEFAULT_GPIO_RESET | PEGASUS_II | HAS_HOME_PNA )
 PEGASUS_DEV( "USB HPNA/Ethernet", VENDOR_ABOCOM, 0x4104,
@@ -269,8 +265,6 @@
 		DEFAULT_GPIO_RESET )
 PEGASUS_DEV( "MELCO/BUFFALO LUA2-TX", VENDOR_MELCO, 0x0009,
 		DEFAULT_GPIO_RESET | PEGASUS_II )
-PEGASUS_DEV( "Microsoft MN-110", VENDOR_MICROSOFT, 0x007a,
-		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "NETGEAR FA101", VENDOR_NETGEAR, 0x1020,
 		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "OCT Inc.", VENDOR_OCT, 0x0109,
diff -Naur linuxppc-2.6.9/drivers/usb/net/rtl8150.c linuxppc-2.6.9-dream/drivers/usb/net/rtl8150.c
--- linuxppc-2.6.9/drivers/usb/net/rtl8150.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/net/rtl8150.c	2005-09-19 21:40:06.000000000 +0200
@@ -20,7 +20,7 @@
 #include <asm/uaccess.h>
 
 /* Version Information */
-#define DRIVER_VERSION "v0.6.1 (2004/03/13)"
+#define DRIVER_VERSION "v0.5.7 (2002/12/31)"
 #define DRIVER_AUTHOR "Petko Manolov <petkan@users.sourceforge.net>"
 #define DRIVER_DESC "rtl8150 based usb-ethernet driver"
 
@@ -43,8 +43,6 @@
 #define	ANAR			0x0144
 #define	ANLP			0x0146
 #define	AER			0x0148
-#define CSCR			0x014C  /* This one has the link status */
-#define CSCR_LINK_STATUS	(1 << 3)
 
 #define	IDR_EEPROM		0x1202
 
@@ -60,60 +58,6 @@
 #define	RTL8150_REQ_GET_REGS	0x05
 #define	RTL8150_REQ_SET_REGS	0x05
 
-
-/* Transmit status register errors */
-#define TSR_ECOL		(1<<5)
-#define TSR_LCOL		(1<<4)
-#define TSR_LOSS_CRS		(1<<3)
-#define TSR_JBR			(1<<2)
-#define TSR_ERRORS		(TSR_ECOL | TSR_LCOL | TSR_LOSS_CRS | TSR_JBR)
-/* Receive status register errors */
-#define RSR_CRC			(1<<2)
-#define RSR_FAE			(1<<1)
-#define RSR_ERRORS		(RSR_CRC | RSR_FAE)
-
-/* Media status register definitions */
-#define MSR_DUPLEX		(1<<4)
-#define MSR_SPEED		(1<<3)
-#define MSR_LINK		(1<<2)
-
-/* Interrupt pipe data */
-#define INT_TSR			0x00
-#define INT_RSR			0x01
-#define INT_MSR			0x02
-#define INT_WAKSR		0x03
-#define INT_TXOK_CNT		0x04
-#define INT_RXLOST_CNT		0x05
-#define INT_CRERR_CNT		0x06
-#define INT_COL_CNT		0x07
-
-/* Transmit status register errors */
-#define TSR_ECOL		(1<<5)
-#define TSR_LCOL		(1<<4)
-#define TSR_LOSS_CRS		(1<<3)
-#define TSR_JBR			(1<<2)
-#define TSR_ERRORS		(TSR_ECOL | TSR_LCOL | TSR_LOSS_CRS | TSR_JBR)
-/* Receive status register errors */
-#define RSR_CRC			(1<<2)
-#define RSR_FAE			(1<<1)
-#define RSR_ERRORS		(RSR_CRC | RSR_FAE)
-
-/* Media status register definitions */
-#define MSR_DUPLEX		(1<<4)
-#define MSR_SPEED		(1<<3)
-#define MSR_LINK		(1<<2)
-
-/* Interrupt pipe data */
-#define INT_TSR			0x00
-#define INT_RSR			0x01
-#define INT_MSR			0x02
-#define INT_WAKSR		0x03
-#define INT_TXOK_CNT		0x04
-#define INT_RXLOST_CNT		0x05
-#define INT_CRERR_CNT		0x06
-#define INT_COL_CNT		0x07
-
-
 #define	RTL8150_MTU		1540
 #define	RTL8150_TX_TIMEOUT	(HZ)
 #define	RX_SKB_POOL_SIZE	4
@@ -127,13 +71,9 @@
 /* Define these values to match your device */
 #define VENDOR_ID_REALTEK		0x0bda
 #define	VENDOR_ID_MELCO			0x0411
-#define VENDOR_ID_MICRONET		0x3980
-#define	VENDOR_ID_LONGSHINE		0x07b8
 
 #define PRODUCT_ID_RTL8150		0x8150
 #define	PRODUCT_ID_LUAKTX		0x0012
-#define	PRODUCT_ID_LCS8138TX		0x401a
-#define PRODUCT_ID_SP128AR		0x0003
 
 #undef	EEPROM_WRITE
 
@@ -141,8 +81,6 @@
 static struct usb_device_id rtl8150_table[] = {
 	{USB_DEVICE(VENDOR_ID_REALTEK, PRODUCT_ID_RTL8150)},
 	{USB_DEVICE(VENDOR_ID_MELCO, PRODUCT_ID_LUAKTX)},
-	{USB_DEVICE(VENDOR_ID_MICRONET, PRODUCT_ID_SP128AR)},
-	{USB_DEVICE(VENDOR_ID_LONGSHINE, PRODUCT_ID_LCS8138TX)},
 	{}
 };
 
@@ -160,14 +98,14 @@
 	spinlock_t rx_pool_lock;
 	struct usb_ctrlrequest dr;
 	int intr_interval;
-	__le16 rx_creg;
+	u16 rx_creg;
 	u8 *intr_buff;
 	u8 phy;
 };
 
 typedef struct rtl8150 rtl8150_t;
 
-static unsigned long multicast_filter_limit = 32;
+unsigned long multicast_filter_limit = 32;
 
 static void fill_skb_pool(rtl8150_t *);
 static void free_skb_pool(rtl8150_t *);
@@ -265,7 +203,7 @@
 
 	if (i < MII_TIMEOUT) {
 		get_registers(dev, PHYDAT, 2, data);
-		*reg = data[0] | (data[1] << 8);
+		*reg = le16_to_cpup(data);
 		return 0;
 	} else
 		return 1;
@@ -398,21 +336,6 @@
 	usb_unlink_urb(dev->ctrl_urb);
 }
 
-static inline struct sk_buff *pull_skb(rtl8150_t *dev)
-{
-	struct sk_buff *skb;
-	int i;
-
-	for (i = 0; i < RX_SKB_POOL_SIZE; i++) {
-		if (dev->rx_skb_pool[i]) {
-			skb = dev->rx_skb_pool[i];
-			dev->rx_skb_pool[i] = NULL;
-			return skb;
-		}
-	}
-	return NULL;
-}
-
 static void read_bulk_callback(struct urb *urb, struct pt_regs *regs)
 {
 	rtl8150_t *dev;
@@ -445,12 +368,9 @@
 
 	if (!dev->rx_skb)
 		goto resched;
-	/* protect against short packets (tell me why we got some?!?) */
-	if (urb->actual_length < 4)
-		goto goon;
 
 	res = urb->actual_length;
-	rx_stat = le16_to_cpu(*(__le16 *)(urb->transfer_buffer + res - 4));
+	rx_stat = le16_to_cpu(*(short *)(urb->transfer_buffer + res - 4));
 	pkt_len = res - 4;
 
 	skb_put(dev->rx_skb, pkt_len);
@@ -531,10 +451,9 @@
 	netif_wake_queue(dev->netdev);
 }
 
-static void intr_callback(struct urb *urb, struct pt_regs *regs)
+void intr_callback(struct urb *urb, struct pt_regs *regs)
 {
 	rtl8150_t *dev;
-	__u8 *d;
 	int status;
 
 	dev = urb->context;
@@ -553,28 +472,7 @@
 		goto resubmit;
 	}
 
-	d = urb->transfer_buffer;
-	if (d[0] & TSR_ERRORS) {
-		dev->stats.tx_errors++;
-		if (d[INT_TSR] & (TSR_ECOL | TSR_JBR))
-			dev->stats.tx_aborted_errors++;
-		if (d[INT_TSR] & TSR_LCOL)
-			dev->stats.tx_window_errors++;
-		if (d[INT_TSR] & TSR_LOSS_CRS)
-			dev->stats.tx_carrier_errors++;
-	}
-	/* Report link status changes to the network stack */
-	if ((d[INT_MSR] & MSR_LINK) == 0) {
-		if (netif_carrier_ok(dev->netdev)) {
-			netif_carrier_off(dev->netdev);
-			dbg("%s: LINK LOST\n", __func__);
-		}
-	} else {
-		if (!netif_carrier_ok(dev->netdev)) {
-			netif_carrier_on(dev->netdev);
-			dbg("%s: LINK CAME BACK\n", __func__);
-		}
-	}
+	/* FIXME if this doesn't do anything, don't submit the urb! */
 
 resubmit:
 	status = usb_submit_urb (urb, SLAB_ATOMIC);
@@ -584,7 +482,6 @@
 				dev->udev->devpath, status);
 }
 
-
 /*
 **
 **	network related part of the code
@@ -618,6 +515,21 @@
 			dev_kfree_skb(dev->rx_skb_pool[i]);
 }
 
+static inline struct sk_buff *pull_skb(rtl8150_t *dev)
+{
+	struct sk_buff *skb;
+	int i;
+
+	for (i = 0; i < RX_SKB_POOL_SIZE; i++) {
+		if (dev->rx_skb_pool[i]) {
+			skb = dev->rx_skb_pool[i];
+			dev->rx_skb_pool[i] = NULL;
+			return skb;
+		}
+	}
+	return NULL;
+}
+
 static int enable_net_traffic(rtl8150_t * dev)
 {
 	u8 cr, tcr, rcr, msr;
@@ -626,7 +538,7 @@
 		warn("%s - device reset failed", __FUNCTION__);
 	}
 	/* RCR bit7=1 attach Rx info at the end;  =0 HW CRC (which is broken) */
-	rcr = 0x9e;
+	rcr = 0x9e;	/* bit7=1 attach Rx info at the end */
 	dev->rx_creg = cpu_to_le16(rcr);
 	tcr = 0xd8;
 	cr = 0x0c;
@@ -714,19 +626,6 @@
 	return 0;
 }
 
-
-static void set_carrier(struct net_device *netdev)
-{
-	rtl8150_t *dev = netdev->priv;
-	short tmp;
-
-	get_registers(dev, CSCR, 2, &tmp);
-	if (tmp & CSCR_LINK_STATUS)
-		netif_carrier_on(netdev);
-	else
-		netif_carrier_off(netdev);
-}
-
 static int rtl8150_open(struct net_device *netdev)
 {
 	rtl8150_t *dev;
@@ -754,7 +653,6 @@
 		warn("%s: intr_urb submit failed: %d", __FUNCTION__, res);
 	netif_start_queue(netdev);
 	enable_net_traffic(dev);
-	set_carrier(netdev);
 
 	return res;
 }
@@ -782,7 +680,7 @@
 	int cmd;
 
 	dev = netdev->priv;
-	if (get_user(cmd, (int __user *) uaddr))
+	if (get_user(cmd, (int *) uaddr))
 		return -EFAULT;
 
 	switch (cmd) {
@@ -856,12 +754,12 @@
 	int res;
 
 	dev = netdev->priv;
-	data = (u16 *) & rq->ifr_ifru;
+	data = (u16 *) & rq->ifr_data;
 	res = 0;
 
 	switch (cmd) {
 	case SIOCETHTOOL:
-		res = rtl8150_ethtool_ioctl(netdev, rq->ifr_data);
+		res = rtl8150_ethtool_ioctl(netdev, (void __user *)rq->ifr_data);
 		break;
 	case SIOCDEVPRIVATE:
 		data[0] = dev->phy;
@@ -876,7 +774,6 @@
 	default:
 		res = -EOPNOTSUPP;
 	}
-
 	return res;
 }
 
@@ -899,6 +796,7 @@
 		kfree(dev);
 		return -ENOMEM;
 	}
+
 	netdev = alloc_etherdev(0);
 	if (!netdev) {
 		kfree(dev->intr_buff);
@@ -939,6 +837,7 @@
 	info("%s: rtl8150 is detected", netdev->name);
 	
 	usb_set_intfdata(intf, dev);
+
 	SET_NETDEV_DEV(netdev, &intf->dev);
 	if (register_netdev(netdev) != 0) {
 		err("couldn't register the device");
@@ -977,13 +876,13 @@
 	}
 }
 
-static int __init usb_rtl8150_init(void)
+int __init usb_rtl8150_init(void)
 {
 	info(DRIVER_DESC " " DRIVER_VERSION);
 	return usb_register(&rtl8150_driver);
 }
 
-static void __exit usb_rtl8150_exit(void)
+void __exit usb_rtl8150_exit(void)
 {
 	usb_deregister(&rtl8150_driver);
 }
diff -Naur linuxppc-2.6.9/drivers/usb/net/usbnet.c linuxppc-2.6.9-dream/drivers/usb/net/usbnet.c
--- linuxppc-2.6.9/drivers/usb/net/usbnet.c	2004-10-18 23:54:31.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/net/usbnet.c	2005-09-19 21:40:06.000000000 +0200
@@ -104,18 +104,10 @@
  * 		disconnect; other cleanups. (db)  Flush net1080 fifos
  * 		after several sequential framing errors. (Johannes Erdfelt)
  * 22-aug-2003	AX8817X support (Dave Hollis).
- * 14-jun-2004  Trivial patch for AX8817X based Buffalo LUA-U2-KTX in Japan
- *		(Neil Bortnak)
  *
  *-------------------------------------------------------------------------*/
 
-// #define	DEBUG			// error path messages, extra info
-// #define	VERBOSE			// more; success messages
-
 #include <linux/config.h>
-#ifdef	CONFIG_USB_DEBUG
-#   define DEBUG
-#endif
 #include <linux/module.h>
 #include <linux/kmod.h>
 #include <linux/sched.h>
@@ -128,14 +120,24 @@
 #include <linux/mii.h>
 #include <asm/uaccess.h>
 #include <asm/unaligned.h>
+
+
+// #define	DEBUG			// error path messages, extra info
+// #define	VERBOSE			// more; success messages
+#define	REALLY_QUEUE
+
+#if !defined (DEBUG) && defined (CONFIG_USB_DEBUG)
+#   define DEBUG
+#endif
 #include <linux/usb.h>
+
 #include <asm/io.h>
 #include <asm/scatterlist.h>
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
 
-#define DRIVER_VERSION		"25-Aug-2003"
 
+#define DRIVER_VERSION		"25-Aug-2003"
 
 /*-------------------------------------------------------------------------*/
 
@@ -146,8 +148,13 @@
  * For high speed, each frame comfortably fits almost 36 max size
  * Ethernet packets (so queues should be bigger).
  */
+#ifdef REALLY_QUEUE
 #define	RX_QLEN(dev) (((dev)->udev->speed == USB_SPEED_HIGH) ? 60 : 4)
 #define	TX_QLEN(dev) (((dev)->udev->speed == USB_SPEED_HIGH) ? 60 : 4)
+#else
+#define	RX_QLEN(dev)		1
+#define	TX_QLEN(dev)		1
+#endif
 
 // packets are always ethernet inside
 // ... except they can be bigger (limit of 64K with NetChip framing)
@@ -166,7 +173,7 @@
 #define CONTROL_TIMEOUT_JIFFIES ((CONTROL_TIMEOUT_MS * HZ)/1000)
 
 // between wakeups
-#define UNLINK_TIMEOUT_MS	3
+#define UNLINK_TIMEOUT_JIFFIES ((3  /*ms*/ * HZ)/1000)
 
 /*-------------------------------------------------------------------------*/
 
@@ -268,7 +275,7 @@
 
 /* use ethtool to change the level for any given device */
 static int msg_level = 1;
-module_param (msg_level, int, 0);
+MODULE_PARM (msg_level, "i");
 MODULE_PARM_DESC (msg_level, "Initial message level (default = 1)");
 
 
@@ -316,7 +323,7 @@
 	for (tmp = 0; tmp < intf->num_altsetting; tmp++) {
 		unsigned	ep;
 
-		in = out = NULL;
+		in = out = 0;
 		alt = intf->altsetting + tmp;
 
 		/* take the first altsetting with in-bulk + out-bulk;
@@ -454,15 +461,6 @@
 #define AX_MCAST_FILTER_SIZE		8
 #define AX_MAX_MCAST			64
 
-#define AX_INTERRUPT_BUFSIZE		8
-
-/* This structure cannot exceed sizeof(unsigned long [5]) AKA 20 bytes */
-struct ax8817x_data {
-	u8 multi_filter[AX_MCAST_FILTER_SIZE];
-	struct urb *int_urb;
-	u8 *int_buf;
-};
-
 static int ax8817x_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
 			    u16 size, void *data)
 {
@@ -505,30 +503,6 @@
 	usb_free_urb(urb);
 }
 
-static void ax8817x_interrupt_complete(struct urb *urb, struct pt_regs *regs)
-{
-	struct usbnet *dev = (struct usbnet *)urb->context;
-	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
-	int link;
-
-	if (urb->status < 0) {
-		printk(KERN_DEBUG "ax8817x_interrupt_complete() failed with %d",
-			urb->status);
-	} else {
-		if (data->int_buf[5] == 0x90) {
-			link = data->int_buf[2] & 0x01;
-			if (netif_carrier_ok(dev->net) != link) {
-				if (link)
-					netif_carrier_on(dev->net);
-				else
-					netif_carrier_off(dev->net);
-				devdbg(dev, "ax8817x - Link Status is: %d", link);
-			}
-		}
-		usb_submit_urb(data->int_urb, GFP_KERNEL);
-	}
-}
-
 static void ax8817x_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,
 				    u16 size, void *data)
 {
@@ -568,7 +542,6 @@
 static void ax8817x_set_multicast(struct net_device *net)
 {
 	struct usbnet *dev = (struct usbnet *) net->priv;
-	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
 	u8 rx_ctl = 0x8c;
 
 	if (net->flags & IFF_PROMISC) {
@@ -583,24 +556,25 @@
 		 * for our 8 byte filter buffer
 		 * to avoid allocating memory that
 		 * is tricky to free later */
+		u8 *multi_filter = (u8 *)&dev->data;
 		struct dev_mc_list *mc_list = net->mc_list;
 		u32 crc_bits;
 		int i;
 
-		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+		memset(multi_filter, 0, AX_MCAST_FILTER_SIZE);
 
 		/* Build the multicast hash filter. */
 		for (i = 0; i < net->mc_count; i++) {
 			crc_bits =
 			    ether_crc(ETH_ALEN,
 				      mc_list->dmi_addr) >> 26;
-			data->multi_filter[crc_bits >> 3] |=
+			multi_filter[crc_bits >> 3] |=
 			    1 << (crc_bits & 7);
 			mc_list = mc_list->next;
 		}
 
 		ax8817x_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
-				   AX_MCAST_FILTER_SIZE, data->multi_filter);
+				   AX_MCAST_FILTER_SIZE, multi_filter);
 
 		rx_ctl |= 0x10;
 	}
@@ -632,7 +606,7 @@
 	ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, &buf);
 }
 
-static void ax8817x_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
+void ax8817x_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
 {
 	struct usbnet *dev = (struct usbnet *)net->priv;
 	u8 opt;
@@ -652,7 +626,7 @@
 	}
 }
 
-static int ax8817x_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
+int ax8817x_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
 {
 	struct usbnet *dev = (struct usbnet *)net->priv;
 	u8 opt = 0;
@@ -672,8 +646,8 @@
 	return 0;
 }
 
-static int ax8817x_get_eeprom(struct net_device *net,
-			      struct ethtool_eeprom *eeprom, u8 *data)
+int ax8817x_get_eeprom(struct net_device *net, 
+		       struct ethtool_eeprom *eeprom, u8 *data)
 {
 	struct usbnet *dev = (struct usbnet *)net->priv;
 	u16 *ebuf = (u16 *)data;
@@ -702,6 +676,13 @@
 	info->eedump_len = 0x3e;
 }
 
+static u32 ax8817x_get_link (struct net_device *net)
+{
+	struct usbnet *dev = (struct usbnet *)net->priv;
+
+	return (u32)mii_link_ok(&dev->mii);
+}
+
 static int ax8817x_get_settings(struct net_device *net, struct ethtool_cmd *cmd)
 {
 	struct usbnet *dev = (struct usbnet *)net->priv;
@@ -721,7 +702,7 @@
    devices that may be connected at the same time. */
 static struct ethtool_ops ax8817x_ethtool_ops = {
 	.get_drvinfo		= ax8817x_get_drvinfo,
-	.get_link		= ethtool_op_get_link,
+	.get_link		= ax8817x_get_link,
 	.get_msglevel		= usbnet_get_msglevel,
 	.set_msglevel		= usbnet_set_msglevel,
 	.get_wol		= ax8817x_get_wol,
@@ -735,41 +716,20 @@
 {
 	int ret;
 	u8 buf[6];
+	u16 *buf16 = (u16 *) buf;
 	int i;
 	unsigned long gpio_bits = dev->driver_info->data;
-	struct ax8817x_data *data = (struct ax8817x_data *)dev->data;
 
 	dev->in = usb_rcvbulkpipe(dev->udev, 3);
 	dev->out = usb_sndbulkpipe(dev->udev, 2);
 
-	// allocate irq urb
-	if ((data->int_urb = usb_alloc_urb (0, GFP_KERNEL)) == 0) {
-		dbg ("%s: cannot allocate interrupt URB",
-			dev->net->name);
-		return -ENOMEM;
-	}
-	
-	if ((data->int_buf = kmalloc(AX_INTERRUPT_BUFSIZE, GFP_KERNEL)) == NULL) {
-		dbg ("%s: cannot allocate memory for interrupt buffer",
-			dev->net->name);
-		usb_free_urb(data->int_urb);
-		return -ENOMEM;
-	}
-	memset(data->int_buf, 0, AX_INTERRUPT_BUFSIZE);
-
-	usb_fill_int_urb (data->int_urb, dev->udev,
-		usb_rcvintpipe (dev->udev, 1),
-		data->int_buf, AX_INTERRUPT_BUFSIZE,
-		ax8817x_interrupt_complete, dev,
-		dev->udev->speed == USB_SPEED_HIGH ? 8 : 100);
-
 	/* Toggle the GPIOs in a manufacturer/model specific way */
 	for (i = 2; i >= 0; i--) {
 		if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
 					(gpio_bits >> (i * 8)) & 0xff, 0, 0,
 					buf)) < 0)
 			return ret;
-		msleep(5);
+		wait_ms(5);
 	}
 
 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, 0x80, 0, 0, buf)) < 0) {
@@ -803,37 +763,49 @@
 	dev->mii.reg_num_mask = 0x1f;
 	dev->mii.phy_id = buf[1];
 
-	dev->net->set_multicast_list = ax8817x_set_multicast;
-	dev->net->ethtool_ops = &ax8817x_ethtool_ops;
+	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, &buf)) < 0) {
+		dbg("Failed to go to software MII mode: %02x", ret);
+		return ret;
+	}
 
-	ax8817x_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR,
-			cpu_to_le16(BMCR_RESET));
-	ax8817x_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,
-			cpu_to_le16(ADVERTISE_ALL | ADVERTISE_CSMA | 0x0400));
-	mii_nway_restart(&dev->mii);
-
-	if((ret = usb_submit_urb(data->int_urb, GFP_KERNEL)) < 0) {
-		dbg("Failed to submit interrupt URB: %02x", ret);
-		usb_free_urb(data->int_urb);
+	*buf16 = cpu_to_le16(BMCR_RESET);
+	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG,
+				     dev->mii.phy_id, MII_BMCR, 2, buf16)) < 0) {
+		dbg("Failed to write MII reg - MII_BMCR: %02x", ret);
 		return ret;
 	}
 
-	return 0;
-}
+	/* Advertise that we can do full-duplex pause */
+	*buf16 = cpu_to_le16(ADVERTISE_ALL | ADVERTISE_CSMA | 0x0400);
+	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG,
+			   	     dev->mii.phy_id, MII_ADVERTISE, 
+				     2, buf16)) < 0) {
+		dbg("Failed to write MII_REG advertisement: %02x", ret);
+		return ret;
+	}
 
-static void ax8817x_unbind(struct usbnet *dev, struct usb_interface *intf)
-{
-	struct ax8817x_data *data = (struct ax8817x_data *)dev->data;
+	*buf16 = cpu_to_le16(BMCR_ANENABLE | BMCR_ANRESTART);
+	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG,
+			  	     dev->mii.phy_id, MII_BMCR, 
+				     2, buf16)) < 0) {
+		dbg("Failed to write MII reg autonegotiate: %02x", ret);
+		return ret;
+	}
 
-	usb_unlink_urb(data->int_urb);
-	usb_free_urb(data->int_urb);
-	kfree(data->int_buf);
+	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, &buf)) < 0) {
+		dbg("Failed to set hardware MII: %02x", ret);
+		return ret;
+	}
+
+	dev->net->set_multicast_list = ax8817x_set_multicast;
+	dev->net->ethtool_ops = &ax8817x_ethtool_ops;
+
+	return 0;
 }
 
 static const struct driver_info ax8817x_info = {
 	.description = "ASIX AX8817x USB 2.0 Ethernet",
 	.bind = ax8817x_bind,
-	.unbind = ax8817x_unbind,
 	.flags =  FLAG_ETHER,
 	.data = 0x00130103,
 };
@@ -841,7 +813,6 @@
 static const struct driver_info dlink_dub_e100_info = {
 	.description = "DLink DUB-E100 USB Ethernet",
 	.bind = ax8817x_bind,
-	.unbind = ax8817x_unbind,
 	.flags =  FLAG_ETHER,
 	.data = 0x009f9d9f,
 };
@@ -849,7 +820,6 @@
 static const struct driver_info netgear_fa120_info = {
 	.description = "Netgear FA-120 USB Ethernet",
 	.bind = ax8817x_bind,
-	.unbind = ax8817x_unbind,
 	.flags =  FLAG_ETHER,
 	.data = 0x00130103,
 };
@@ -857,7 +827,6 @@
 static const struct driver_info hawking_uf200_info = {
 	.description = "Hawking UF200 USB Ethernet",
 	.bind = ax8817x_bind,
-	.unbind = ax8817x_unbind,
 	.flags =  FLAG_ETHER,
 	.data = 0x001f1d1f,
 };
@@ -937,8 +906,8 @@
 
 	u8	iMACAddress;
 	u32	bmEthernetStatistics;
-	__le16	wMaxSegmentSize;
-	__le16	wNumberMCFilters;
+	u16	wMaxSegmentSize;
+	u16	wNumberMCFilters;
 	u8	bNumberPowerFilters;
 } __attribute__ ((packed));
 
@@ -959,8 +928,8 @@
  */
 static int generic_cdc_bind (struct usbnet *dev, struct usb_interface *intf)
 {
-	u8				*buf = intf->cur_altsetting->extra;
-	int				len = intf->cur_altsetting->extralen;
+	u8				*buf = intf->altsetting->extra;
+	int				len = intf->altsetting->extralen;
 	struct usb_interface_descriptor	*d;
 	struct cdc_state		*info = (void *) &dev->data;
 	int				status;
@@ -986,7 +955,7 @@
 	/* this assumes that if there's a non-RNDIS vendor variant
 	 * of cdc-acm, it'll fail RNDIS requests cleanly.
 	 */
-	rndis = (intf->cur_altsetting->desc.bInterfaceProtocol == 0xff);
+	rndis = (intf->altsetting->desc.bInterfaceProtocol == 0xff);
 
 	memset (info, 0, sizeof *info);
 	info->control = intf;
@@ -1037,7 +1006,7 @@
 			if (!info->control || !info->data) {
 				dev_dbg (&intf->dev,
 					"master #%u/%p slave #%u/%p\n",
-					info->u->bMasterInterface0,
+					info->u->bMasterInterface0
 					info->control,
 					info->u->bSlaveInterface0,
 					info->data);
@@ -1056,7 +1025,7 @@
 			}
 
 			/* a data interface altsetting does the real i/o */
-			d = &info->data->cur_altsetting->desc;
+			d = &info->data->altsetting->desc;
 			if (d->bInterfaceClass != USB_CLASS_CDC_DATA) {
 				dev_dbg (&intf->dev, "slave class %u\n",
 					d->bInterfaceClass);
@@ -1074,7 +1043,7 @@
 					info->u->bLength);
 				goto bad_desc;
 			}
-			dev->net->mtu = le16_to_cpup (
+			dev->net->mtu = cpu_to_le16p (
 						&info->ether->wMaxSegmentSize)
 					- ETH_HLEN;
 			/* because of Zaurus, we may be ignoring the host
@@ -1124,7 +1093,7 @@
 		/* ensure immediate exit from usbnet_disconnect */
 		usb_set_intfdata(info->data, NULL);
 		usb_driver_release_interface (&usbnet_driver, info->data);
-		info->data = NULL;
+		info->data = 0;
 	}
 
 	/* and vice versa (just in case) */
@@ -1132,7 +1101,7 @@
 		/* ensure immediate exit from usbnet_disconnect */
 		usb_set_intfdata(info->control, NULL);
 		usb_driver_release_interface (&usbnet_driver, info->control);
-		info->control = NULL;
+		info->control = 0;
 	}
 }
 
@@ -1173,13 +1142,10 @@
 	unsigned char	buf [13];
 
 	tmp = usb_string (dev->udev, e->iMACAddress, buf, sizeof buf);
-	if (tmp != 12) {
-		dev_dbg (&dev->udev->dev,
-			"bad MAC string %d fetch, %d\n", e->iMACAddress, tmp);
-		if (tmp >= 0)
-			tmp = -EINVAL;
+	if (tmp < 0)
 		return tmp;
-	}
+	else if (tmp != 12)
+		return -EINVAL;
 	for (i = tmp = 0; i < 6; i++, tmp += 2)
 		dev->net->dev_addr [i] =
 			 (nibble (buf [tmp]) << 4) + nibble (buf [tmp + 1]);
@@ -1197,7 +1163,6 @@
 
 	status = get_ethernet_addr (dev, info->ether);
 	if (status < 0) {
-		usb_set_intfdata(info->data, NULL);
 		usb_driver_release_interface (&usbnet_driver, info->data);
 		return status;
 	}
@@ -1679,7 +1644,7 @@
 		req,
 		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
 		value, regnum,
-		NULL, 0,			// data is in setup packet
+		0, 0,			// data is in setup packet
 		CONTROL_TIMEOUT_JIFFIES);
 }
 
@@ -2122,7 +2087,7 @@
 		req,
 		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
 		val, index,
-		NULL, 0,
+		0, 0,
 		CONTROL_TIMEOUT_JIFFIES);
 }
 
@@ -2142,12 +2107,8 @@
 
 static int pl_reset (struct usbnet *dev)
 {
-	/* some units seem to need this reset, others reject it utterly.
-	 * FIXME be more like "naplink" or windows drivers.
-	 */
-	(void) pl_set_QuickLink_features (dev,
+	return pl_set_QuickLink_features (dev,
 		PL_S_EN|PL_RESET_OUT|PL_RESET_IN|PL_PEER_E);
-	return 0;
 }
 
 static const struct driver_info	prolific_info = {
@@ -2456,7 +2417,7 @@
 
 	skb_put (skb, urb->actual_length);
 	entry->state = rx_done;
-	entry->urb = NULL;
+	entry->urb = 0;
 
 	switch (urb_status) {
 	    // success
@@ -2500,7 +2461,7 @@
 block:
 		entry->state = rx_cleanup;
 		entry->urb = urb;
-		urb = NULL;
+		urb = 0;
 		break;
 
 	    // data overrun ... flush fifo?
@@ -2591,10 +2552,11 @@
 	while (skb_queue_len (&dev->rxq)
 			&& skb_queue_len (&dev->txq)
 			&& skb_queue_len (&dev->done)) {
-		msleep(UNLINK_TIMEOUT_MS);
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		schedule_timeout (UNLINK_TIMEOUT_JIFFIES);
 		devdbg (dev, "waited for %d urb completions", temp);
 	}
-	dev->wait = NULL;
+	dev->wait = 0;
 	remove_wait_queue (&unlink_wakeup, &wait); 
 
 	/* deferred work (task, timer, softirq) must also stop.
@@ -2708,7 +2670,9 @@
 	struct usbnet *dev = (struct usbnet *)net->priv;
 
 	if (dev->mii.mdio_read != NULL && dev->mii.mdio_write != NULL)
-		return generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);
+		return generic_mii_ioctl(&dev->mii,
+				(struct mii_ioctl_data *) &rq->ifr_data,
+				cmd, NULL);
 	}
 #endif
 	return -EOPNOTSUPP;
@@ -2753,7 +2717,7 @@
 
 	/* tasklet could resubmit itself forever if memory is tight */
 	if (test_bit (EVENT_RX_MEMORY, &dev->flags)) {
-		struct urb	*urb = NULL;
+		struct urb	*urb = 0;
 
 		if (netif_running (dev->net))
 			urb = usb_alloc_urb (0, GFP_KERNEL);
@@ -2808,7 +2772,7 @@
 		}
 	}
 
-	urb->dev = NULL;
+	urb->dev = 0;
 	entry->state = tx_done;
 	defer_bh (dev, skb);
 }
@@ -2832,13 +2796,13 @@
 	struct usbnet		*dev = (struct usbnet *) net->priv;
 	int			length;
 	int			retval = NET_XMIT_SUCCESS;
-	struct urb		*urb = NULL;
+	struct urb		*urb = 0;
 	struct skb_data		*entry;
 	struct driver_info	*info = dev->driver_info;
 	unsigned long		flags;
 #ifdef	CONFIG_USB_NET1080
-	struct nc_header	*header = NULL;
-	struct nc_trailer	*trailer = NULL;
+	struct nc_header	*header = 0;
+	struct nc_trailer	*trailer = 0;
 #endif	/* CONFIG_USB_NET1080 */
 
 	// some devices want funky USB-level framing, for
@@ -3046,7 +3010,7 @@
 
 // precondition: never called in_interrupt
 
-static int
+int
 usbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod)
 {
 	struct usbnet			*dev;
@@ -3140,7 +3104,7 @@
 
 	}
 	if (status < 0)
-		goto out1;
+		goto out2;
 
 	dev->maxpacket = usb_maxpacket (dev->udev, dev->out, 1);
 	
@@ -3163,6 +3127,7 @@
 out3:
 	if (info->unbind)
 		info->unbind (dev, udev);
+out2:
 	free_netdev(net);
 out1:
 	kfree(dev);
@@ -3237,21 +3202,9 @@
 	USB_DEVICE (0x07b8, 0x420a),
 	.driver_info =  (unsigned long) &hawking_uf200_info,
 }, {
-        // Billionton Systems, USB2AR 
-        USB_DEVICE (0x08dd, 0x90ff),
-        .driver_info =  (unsigned long) &ax8817x_info,
-}, {
 	// ATEN UC210T
 	USB_DEVICE (0x0557, 0x2009),
 	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// Buffalo LUA-U2-KTX
-	USB_DEVICE (0x0411, 0x003d),
-	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// Sitecom LN-029 "USB 2.0 10/100 Ethernet adapter"
-	USB_DEVICE (0x6189, 0x182d),
-	.driver_info =  (unsigned long) &ax8817x_info,
 },
 #endif
 
@@ -3461,7 +3414,9 @@
 			< sizeof (struct cdc_state)));
 #endif
 
-	random_ether_addr(node_id);
+	get_random_bytes (node_id, sizeof node_id);
+	node_id [0] &= 0xfe;	// clear multicast bit
+	node_id [0] |= 0x02;    // set local assignment bit (IEEE802)
 
  	return usb_register(&usbnet_driver);
 }
diff -Naur linuxppc-2.6.9/drivers/usb/serial/belkin_sa.c linuxppc-2.6.9-dream/drivers/usb/serial/belkin_sa.c
--- linuxppc-2.6.9/drivers/usb/serial/belkin_sa.c	2004-10-18 23:54:32.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/belkin_sa.c	2005-09-19 21:40:06.000000000 +0200
@@ -75,11 +75,16 @@
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+ 	static int debug = 1;
+#else
+ 	static int debug;
+#endif
+
 #include "usb-serial.h"
 #include "belkin_sa.h"
 
-static int debug;
-
 /*
  * Version Information
  */
@@ -239,12 +244,23 @@
 
 static void belkin_sa_close (struct usb_serial_port *port, struct file *filp)
 {
+	struct usb_serial *serial;
+
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+
+	serial = get_usb_serial (port, __FUNCTION__);
+	if (!serial)
+		return;
+
 	dbg("%s port %d", __FUNCTION__, port->number);
 
-	/* shutdown our bulk reads and writes */
-	usb_unlink_urb (port->write_urb);
-	usb_unlink_urb (port->read_urb);
-	usb_unlink_urb (port->interrupt_in_urb);
+	if (serial->dev) {
+		/* shutdown our bulk reads and writes */
+		usb_unlink_urb (port->write_urb);
+		usb_unlink_urb (port->read_urb);
+		usb_unlink_urb (port->interrupt_in_urb);
+	}
 } /* belkin_sa_close */
 
 
@@ -252,6 +268,7 @@
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct belkin_sa_private *priv;
+	struct usb_serial *serial;
 	unsigned char *data = urb->transfer_buffer;
 	int retval;
 	unsigned long flags;
@@ -271,7 +288,15 @@
 		goto exit;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+
+	serial = port->serial;
+
+	if (serial_paranoia_check (serial, __FUNCTION__))
+		return;
+	
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	/* Handle known interrupt data */
 	/* ignore data[0] and data[1] */
@@ -609,5 +634,6 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
+
diff -Naur linuxppc-2.6.9/drivers/usb/serial/bus.c linuxppc-2.6.9-dream/drivers/usb/serial/bus.c
--- linuxppc-2.6.9/drivers/usb/serial/bus.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/bus.c	2005-09-19 21:40:06.000000000 +0200
@@ -14,6 +14,13 @@
 #include <linux/tty.h>
 #include <linux/module.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 #include "usb-serial.h"
 
 static int usb_serial_device_match (struct device *dev, struct device_driver *drv)
@@ -71,8 +78,8 @@
 	minor = port->number;
 	tty_register_device (usb_serial_tty_driver, minor, dev);
 	dev_info(&port->serial->dev->dev, 
-		 "%s converter now attached to ttyUSB%d\n",
-		 driver->name, minor);
+		 "%s converter now attached to ttyUSB%d (or usb/tts/%d for devfs)\n",
+		 driver->name, minor, minor);
 
 exit:
 	return retval;
diff -Naur linuxppc-2.6.9/drivers/usb/serial/console.c linuxppc-2.6.9-dream/drivers/usb/serial/console.c
--- linuxppc-2.6.9/drivers/usb/serial/console.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/console.c	2005-09-19 21:40:06.000000000 +0200
@@ -137,7 +137,7 @@
 
 	/* grab the first serial port that happens to be connected */
 	serial = usb_serial_get_by_index(0);
-	if (serial == NULL) {
+	if (serial_paranoia_check (serial, __FUNCTION__)) {
 		/* no device is connected yet, sorry :( */
 		err ("No USB device connected to ttyUSB0");
 		return -ENODEV;
@@ -199,12 +199,11 @@
 {
 	static struct usbcons_info *info = &usbcons_info;
 	struct usb_serial_port *port = info->port;
-	struct usb_serial *serial;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	int retval = -ENODEV;
 
-	if (!port)
+	if (!serial || !port)
 		return;
-	serial = port->serial;
 
 	if (count == 0)
 		return;
diff -Naur linuxppc-2.6.9/drivers/usb/serial/cyberjack.c linuxppc-2.6.9-dream/drivers/usb/serial/cyberjack.c
--- linuxppc-2.6.9/drivers/usb/serial/cyberjack.c	2004-10-18 23:55:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/cyberjack.c	2005-09-19 21:40:06.000000000 +0200
@@ -35,16 +35,21 @@
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
-#include "usb-serial.h"
 
 #define CYBERJACK_LOCAL_BUF_SIZE 32
 
-static int debug;
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
+#include "usb-serial.h"
 
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v1.01"
+#define DRIVER_VERSION "v1.0"
 #define DRIVER_AUTHOR "Matthias Bruestle"
 #define DRIVER_DESC "REINER SCT cyberJack pinpad/e-com USB Chipcard Reader Driver"
 
@@ -104,14 +109,13 @@
 	short		rdtodo;		/* Bytes still to read */
 	unsigned char	wrbuf[5*64];	/* Buffer for collecting data to write */
 	short		wrfilled;	/* Overall data size we already got */
-	short		wrsent;		/* Data already sent */
+	short		wrsent;		/* Data akready sent */
 };
 
 /* do some startup allocations not currently performed by usb_serial_probe() */
 static int cyberjack_startup (struct usb_serial *serial)
 {
 	struct cyberjack_private *priv;
-	int i;
 
 	dbg("%s", __FUNCTION__);
 
@@ -129,16 +133,6 @@
 
 	init_waitqueue_head(&serial->port[0]->write_wait);
 
-	for (i = 0; i < serial->num_ports; ++i) {
-		int result;
-		serial->port[i]->interrupt_in_urb->dev = serial->dev;
-		result = usb_submit_urb(serial->port[i]->interrupt_in_urb, 
-					GFP_KERNEL);
-		if (result)
-			err(" usb_submit_urb(read int) failed");
-		dbg("%s - usb_submit_urb(int urb)", __FUNCTION__);
-	}
-
 	return( 0 );
 }
 
@@ -149,7 +143,6 @@
 	dbg("%s", __FUNCTION__);
 
 	for (i=0; i < serial->num_ports; ++i) {
-		usb_unlink_urb (serial->port[i]->interrupt_in_urb);
 		/* My special items, the standard routines free my urbs */
 		kfree(usb_get_serial_port_data(serial->port[i]));
 		usb_set_serial_port_data(serial->port[i], NULL);
@@ -162,10 +155,15 @@
 	unsigned long flags;
 	int result = 0;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return -ENODEV;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	dbg("%s - usb_clear_halt", __FUNCTION__ );
 	usb_clear_halt(port->serial->dev, port->write_urb->pipe);
+	usb_clear_halt(port->serial->dev, port->read_urb->pipe);
+	usb_clear_halt(port->serial->dev, port->interrupt_in_urb->pipe);
 
 	/* force low_latency on so that our tty_push actually forces
 	 * the data through, otherwise it is scheduled, and with high
@@ -180,6 +178,17 @@
 	priv->wrsent = 0;
 	spin_unlock_irqrestore(&priv->lock, flags);
 
+	/* shutdown any bulk reads that might be going on */
+	usb_unlink_urb (port->write_urb);
+	usb_unlink_urb (port->read_urb);
+	usb_unlink_urb (port->interrupt_in_urb);
+
+	port->interrupt_in_urb->dev = port->serial->dev;
+	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
+	if (result)
+		err(" usb_submit_urb(read int) failed");
+	dbg("%s - usb_submit_urb(int urb)", __FUNCTION__);
+
 	return result;
 }
 
@@ -191,6 +200,11 @@
 		/* shutdown any bulk reads that might be going on */
 		usb_unlink_urb (port->write_urb);
 		usb_unlink_urb (port->read_urb);
+		usb_unlink_urb (port->interrupt_in_urb);
+		dbg("%s - usb_clear_halt", __FUNCTION__ );
+		usb_clear_halt(port->serial->dev, port->write_urb->pipe);
+		usb_clear_halt(port->serial->dev, port->read_urb->pipe);
+		usb_clear_halt(port->serial->dev, port->interrupt_in_urb->pipe);
 	}
 }
 
@@ -201,6 +215,7 @@
 	unsigned long flags;
 	int result;
 	int wrexpected;
+	unsigned char localbuf[CYBERJACK_LOCAL_BUF_SIZE];	/* Buffer for collecting data to write */
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 	dbg("%s - from_user %d", __FUNCTION__, from_user);
@@ -217,24 +232,30 @@
 
 	spin_lock_irqsave(&priv->lock, flags);
 
-	if( (count+priv->wrfilled)>sizeof(priv->wrbuf) ) {
-		/* To much data for buffer. Reset buffer. */
+	if( (count+priv->wrfilled)>sizeof(priv->wrbuf) ||
+		(count>sizeof(localbuf)) ) {
+		/* To much data  for buffer. Reset buffer. */
 		priv->wrfilled=0;
 		spin_unlock_irqrestore(&priv->lock, flags);
 		return (0);
 	}
 
+	spin_unlock_irqrestore(&priv->lock, flags);
+
 	/* Copy data */
 	if (from_user) {
-		if (copy_from_user(priv->wrbuf+priv->wrfilled, buf, count)) {
-			spin_unlock_irqrestore(&priv->lock, flags);
+		if (copy_from_user(localbuf, buf, count)) {
 			return -EFAULT;
 		}
 	} else {
-		memcpy (priv->wrbuf+priv->wrfilled, buf, count);
+		memcpy (localbuf, buf, count);
 	}  
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count,
+	spin_lock_irqsave(&priv->lock, flags);
+
+	memcpy (priv->wrbuf+priv->wrfilled, localbuf, count);
+
+	usb_serial_debug_data (__FILE__, __FUNCTION__, count,
 		priv->wrbuf+priv->wrfilled);
 	priv->wrfilled += count;
 
@@ -300,16 +321,24 @@
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct cyberjack_private *priv = usb_get_serial_port_data(port);
+	struct usb_serial *serial;
 	unsigned char *data = urb->transfer_buffer;
 	int result;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	/* the urb might have been killed. */
 	if (urb->status)
 		return;
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	serial = port->serial;
+	if (serial_paranoia_check (serial, __FUNCTION__))
+		return;
+
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	/* React only to interrupts signaling a bulk_in transfer */
 	if( (urb->actual_length==4) && (data[0]==0x01) ) {
@@ -357,6 +386,7 @@
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct cyberjack_private *priv = usb_get_serial_port_data(port);
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
 	short todo;
@@ -365,17 +395,20 @@
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 	
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
+		usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, urb->transfer_buffer);
 		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
+
 	tty = port->tty;
-	if (!tty) {
-		dbg("%s - ignoring since device not open\n", __FUNCTION__);
-		return;
-	}
 	if (urb->actual_length) {
 		for (i = 0; i < urb->actual_length ; ++i) {
 			/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
@@ -414,9 +447,15 @@
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	struct cyberjack_private *priv = usb_get_serial_port_data(port);
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 	
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 		return;
@@ -444,11 +483,11 @@
 		priv->wrsent+=length;
 
 		/* set up our urb */
-		usb_fill_bulk_urb(port->write_urb, port->serial->dev, 
-			      usb_sndbulkpipe(port->serial->dev, port->bulk_out_endpointAddress),
+		usb_fill_bulk_urb(port->write_urb, serial->dev, 
+			      usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress),
 			      port->write_urb->transfer_buffer, length,
-			      ((port->serial->type->write_bulk_callback) ? 
-			       port->serial->type->write_bulk_callback : 
+			      ((serial->type->write_bulk_callback) ? 
+			       serial->type->write_bulk_callback : 
 			       cyberjack_write_bulk_callback), 
 			      port);
 
@@ -513,5 +552,6 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
+
diff -Naur linuxppc-2.6.9/drivers/usb/serial/digi_acceleport.c linuxppc-2.6.9-dream/drivers/usb/serial/digi_acceleport.c
--- linuxppc-2.6.9/drivers/usb/serial/digi_acceleport.c	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/digi_acceleport.c	2005-09-19 21:40:06.000000000 +0200
@@ -246,8 +246,16 @@
 #include <linux/workqueue.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 #include "usb-serial.h"
 
+
 /* Defines */
 
 /*
@@ -472,8 +480,6 @@
 
 /* Statics */
 
-static int debug;
-
 static struct usb_device_id id_table_combined [] = {
 	{ USB_DEVICE(DIGI_VENDOR_ID, DIGI_2_ID) },
 	{ USB_DEVICE(DIGI_VENDOR_ID, DIGI_4_ID) },
@@ -624,7 +630,14 @@
 	wake_up_interruptible( &port->write_wait );
 
 	/* wake up line discipline */
-	tty_wakeup(tty);
+	if( (tty->flags & (1 << TTY_DO_WRITE_WAKEUP))
+	&& tty->ldisc.write_wakeup )
+		(tty->ldisc.write_wakeup)(tty);
+
+	/* wake up other tty processes */
+	wake_up_interruptible( &tty->write_wait );
+	/* For 2.2.16 backport -- wake_up_interruptible( &tty->poll_wait ); */
+
 }
 
 
@@ -1383,6 +1396,11 @@
 		return;
 	}
 
+	/* further sanity checks */
+	if( port_paranoia_check( port, __FUNCTION__ )
+	|| serial_paranoia_check( serial, __FUNCTION__ ) )
+		return;
+
 	/* try to send any buffered data on this port, if it is open */
 	spin_lock( &priv->dp_port_lock );
 	priv->dp_write_urb_in_use = 0;
@@ -1546,17 +1564,13 @@
 dbg( "digi_close: TOP: port=%d, open_count=%d", priv->dp_port_num, port->open_count );
 
 
-	/* if disconnected, just clear flags */
-	if (!usb_get_intfdata(port->serial->interface))
-		goto exit;
-
 	/* do cleanup only after final close on this port */
 	spin_lock_irqsave( &priv->dp_port_lock, flags );
 	priv->dp_in_close = 1;
 	spin_unlock_irqrestore( &priv->dp_port_lock, flags );
 
 	/* tell line discipline to process only XON/XOFF */
-	tty->closing = 1;
+        tty->closing = 1;
 
 	/* wait for output to drain */
 	if( (filp->f_flags&(O_NDELAY|O_NONBLOCK)) == 0 ) {
@@ -1566,7 +1580,8 @@
 	/* flush driver and line discipline buffers */
 	if( tty->driver->flush_buffer )
 		tty->driver->flush_buffer( tty );
-	tty_ldisc_flush(tty);
+	if( tty->ldisc.flush_buffer )
+		tty->ldisc.flush_buffer( tty );
 
 	if (port->serial->dev) {
 		/* wait for transmit idle */
@@ -1620,7 +1635,6 @@
 
 	tty->closing = 0;
 
-exit:
 	spin_lock_irqsave( &priv->dp_port_lock, flags );
 	priv->dp_write_urb_in_use = 0;
 	priv->dp_in_close = 0;
@@ -1784,6 +1798,7 @@
 		return;
 	}
 	if( port->serial == NULL
+	|| serial_paranoia_check( port->serial, __FUNCTION__ )
 	|| (serial_priv=usb_get_serial_data(port->serial)) == NULL ) {
 		err("%s: serial is bad or serial->private is NULL, status=%d", __FUNCTION__, urb->status );
 		return;
@@ -1836,6 +1851,11 @@
 	unsigned char *data = ((unsigned char *)urb->transfer_buffer)+3;
 	int flag,throttled;
 
+
+	/* sanity check */
+	if( port_paranoia_check( port, __FUNCTION__ ) )
+		return( -1 );
+
 	/* do not process callbacks on closed ports */
 	/* but do continue the read chain */
 	if( port->open_count == 0 )
@@ -1960,8 +1980,9 @@
 
 		port = serial->port[line];
 
-		if ((priv=usb_get_serial_port_data(port)) == NULL )
-			return -1;
+		if( port_paranoia_check( port, __FUNCTION__ )
+		|| (priv=usb_get_serial_port_data(port)) == NULL )
+			return( -1 );
 
 		if( opcode == DIGI_CMD_READ_INPUT_SIGNALS ) {
 
@@ -2059,5 +2080,6 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
+
diff -Naur linuxppc-2.6.9/drivers/usb/serial/empeg.c linuxppc-2.6.9-dream/drivers/usb/serial/empeg.c
--- linuxppc-2.6.9/drivers/usb/serial/empeg.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/empeg.c	2005-09-19 21:40:06.000000000 +0200
@@ -63,9 +63,14 @@
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
-#include "usb-serial.h"
 
-static int debug;
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
+#include "usb-serial.h"
 
 /*
  * Version Information
@@ -152,6 +157,9 @@
 	struct usb_serial *serial = port->serial;
 	int result = 0;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return -ENODEV;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	/* Force default termio settings */
@@ -182,10 +190,21 @@
 
 static void empeg_close (struct usb_serial_port *port, struct file * filp)
 {
+	struct usb_serial *serial;
+
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	/* shutdown our bulk read */
-	usb_unlink_urb (port->read_urb);
+	serial = get_usb_serial (port, __FUNCTION__);
+	if (!serial)
+		return;
+
+	if (serial->dev) {
+		/* shutdown our bulk read */
+		usb_unlink_urb (port->read_urb);
+	}
 	/* Uncomment the following line if you want to see some statistics in your syslog */
 	/* dev_info (&port->dev, "Bytes In = %d  Bytes Out = %d\n", bytes_in, bytes_out); */
 }
@@ -244,7 +263,7 @@
 			memcpy (urb->transfer_buffer, current_position, transfer_size);
 		}
 
-		usb_serial_debug_data(debug, &port->dev, __FUNCTION__, transfer_size, urb->transfer_buffer);
+		usb_serial_debug_data (__FILE__, __FUNCTION__, transfer_size, urb->transfer_buffer);
 
 		/* build up our urb */
 		usb_fill_bulk_urb (
@@ -334,6 +353,9 @@
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (urb->status) {
@@ -348,19 +370,28 @@
 static void empeg_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
 	int i;
 	int result;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	tty = port->tty;
 
@@ -385,8 +416,8 @@
 	/* Continue trying to always read  */
 	usb_fill_bulk_urb(
 		port->read_urb,
-		port->serial->dev, 
-		usb_rcvbulkpipe(port->serial->dev,
+		serial->dev, 
+		usb_rcvbulkpipe(serial->dev,
 			port->bulk_in_endpointAddress),
 		port->read_urb->transfer_buffer,
 		port->read_urb->transfer_buffer_length,
@@ -516,7 +547,11 @@
 	 */
 	port->tty->low_latency = 1;
 
+	/* Notify the tty driver that the termios have changed. */
+	port->tty->ldisc.set_termios(port->tty, NULL);
+
 	return;
+
 }
 
 
@@ -600,5 +635,6 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
+
diff -Naur linuxppc-2.6.9/drivers/usb/serial/ezusb.c linuxppc-2.6.9-dream/drivers/usb/serial/ezusb.c
--- linuxppc-2.6.9/drivers/usb/serial/ezusb.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/ezusb.c	2005-09-19 21:40:06.000000000 +0200
@@ -16,6 +16,13 @@
 #include <linux/tty.h>
 #include <linux/module.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 #include "usb-serial.h"
 
 /* EZ-USB Control and Status Register.  Bit 0 controls 8051 reset */
@@ -28,7 +35,7 @@
 
 	/* dbg("ezusb_writememory %x, %d", address, length); */
 	if (!serial->dev) {
-		err("%s - no physical device present, failing.", __FUNCTION__);
+		dbg("%s - no physical device present, failing.", __FUNCTION__);
 		return -ENODEV;
 	}
 
@@ -45,12 +52,12 @@
 
 int ezusb_set_reset (struct usb_serial *serial, unsigned char reset_bit)
 {
-	int response;
-
-	/* dbg("%s - %d", __FUNCTION__, reset_bit); */
+	int	response;
+	dbg("%s - %d", __FUNCTION__, reset_bit);
 	response = ezusb_writememory (serial, CPUCS_REG, &reset_bit, 1, 0xa0);
-	if (response < 0)
+	if (response < 0) {
 		dev_err(&serial->dev->dev, "%s- %d failed\n", __FUNCTION__, reset_bit);
+	}
 	return response;
 }
 
diff -Naur linuxppc-2.6.9/drivers/usb/serial/ftdi_sio.c linuxppc-2.6.9-dream/drivers/usb/serial/ftdi_sio.c
--- linuxppc-2.6.9/drivers/usb/serial/ftdi_sio.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/ftdi_sio.c	2005-09-19 21:40:06.000000000 +0200
@@ -17,17 +17,6 @@
  * See http://ftdi-usb-sio.sourceforge.net for upto date testing info
  *	and extra documentation
  *
- * (21/Jul/2004) Ian Abbott
- *      Incorporated Steven Turner's code to add support for the FT2232C chip.
- *      The prelimilary port to the 2.6 kernel was by Rus V. Brushkoff.  I have
- *      fixed a couple of things.
- *
- * (27/May/2004) Ian Abbott
- *      Improved throttling code, mostly stolen from the WhiteHEAT driver.
- *
- * (26/Mar/2004) Jan Capek
- *      Added PID's for ICD-U20/ICD-U40 - incircuit PIC debuggers from CCS Inc.
- *
  * (09/Feb/2004) Ian Abbott
  *      Changed full name of USB-UIRT device to avoid "/" character.
  *      Added FTDI's alternate PID (0x6006) for FT232/245 devices.
@@ -258,18 +247,22 @@
 #include <asm/uaccess.h>
 #include <linux/usb.h>
 #include <linux/serial.h>
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 #include "usb-serial.h"
 #include "ftdi_sio.h"
 
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v1.4.1"
+#define DRIVER_VERSION "v1.4.0"
 #define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com>, Bill Ryder <bryder@sgi.com>, Kuba Ober <kuba@mareimbrium.org>"
 #define DRIVER_DESC "USB FTDI Serial Converters Driver"
 
-static int debug;
-
 static struct usb_device_id id_table_sio [] = {
 	{ USB_DEVICE(FTDI_VID, FTDI_SIO_PID) },
 	{ }						/* Terminating entry */
@@ -297,8 +290,6 @@
 	{ USB_DEVICE_VER(FTDI_VID, FTDI_8U232AM_PID, 0, 0x3ff) },
 	{ USB_DEVICE_VER(FTDI_VID, FTDI_8U232AM_ALT_PID, 0, 0x3ff) },
 	{ USB_DEVICE_VER(FTDI_VID, FTDI_RELAIS_PID, 0, 0x3ff) },
-	{ USB_DEVICE(INTERBIOMETRICS_VID, INTERBIOMETRICS_IOBOARD_PID) },
-	{ USB_DEVICE(INTERBIOMETRICS_VID, INTERBIOMETRICS_MINI_IOBOARD_PID) },
 	{ USB_DEVICE_VER(FTDI_NF_RIC_VID, FTDI_NF_RIC_PID, 0, 0x3ff) },
 	{ USB_DEVICE_VER(FTDI_VID, FTDI_XF_632_PID, 0, 0x3ff) },
 	{ USB_DEVICE_VER(FTDI_VID, FTDI_XF_634_PID, 0, 0x3ff) },
@@ -363,11 +354,6 @@
 	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_SPECIAL_3, 0, 0x3ff) },
 	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_SPECIAL_4, 0, 0x3ff) },
 	{ USB_DEVICE_VER(FTDI_VID, FTDI_ELV_UO100_PID, 0, 0x3ff) },
-	{ USB_DEVICE_VER(FTDI_VID, INSIDE_ACCESSO, 0, 0x3ff) },
-	{ USB_DEVICE_VER(INTREPID_VID, INTREPID_VALUECAN_PID, 0, 0x3ff) },
-	{ USB_DEVICE_VER(INTREPID_VID, INTREPID_NEOVI_PID, 0, 0x3ff) },
-	{ USB_DEVICE_VER(FALCOM_VID, FALCOM_TWIST_PID, 0, 0x3ff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_SUUNTO_SPORTS_PID, 0, 0x3ff) },
 	{ }						/* Terminating entry */
 };
 
@@ -449,35 +435,7 @@
 	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_R2X0, 0x400, 0xffff) },
 	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_SPECIAL_3, 0x400, 0xffff) },
 	{ USB_DEVICE_VER(FTDI_VID, PROTEGO_SPECIAL_4, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E808_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E809_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E80A_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E80B_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E80C_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E80D_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E80E_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E80F_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E888_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E889_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E88A_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E88B_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E88C_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E88D_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E88E_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_GUDEADS_E88F_PID, 0x400, 0xffff) },
 	{ USB_DEVICE_VER(FTDI_VID, FTDI_ELV_UO100_PID, 0x400, 0xffff) },
- 	{ USB_DEVICE_VER(FTDI_VID, LINX_SDMUSBQSS_PID, 0x400, 0xffff) },
- 	{ USB_DEVICE_VER(FTDI_VID, LINX_MASTERDEVEL2_PID, 0x400, 0xffff) },
- 	{ USB_DEVICE_VER(FTDI_VID, LINX_FUTURE_0_PID, 0x400, 0xffff) },
- 	{ USB_DEVICE_VER(FTDI_VID, LINX_FUTURE_1_PID, 0x400, 0xffff) },
- 	{ USB_DEVICE_VER(FTDI_VID, LINX_FUTURE_2_PID, 0x400, 0xffff) },
-	{ USB_DEVICE(FTDI_VID, FTDI_CCSICDU20_0_PID) },
-	{ USB_DEVICE(FTDI_VID, FTDI_CCSICDU40_1_PID) },
-	{ USB_DEVICE_VER(FTDI_VID, INSIDE_ACCESSO, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(INTREPID_VID, INTREPID_VALUECAN_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(INTREPID_VID, INTREPID_NEOVI_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FALCOM_VID, FALCOM_TWIST_PID, 0x400, 0xffff) },
-	{ USB_DEVICE_VER(FTDI_VID, FTDI_SUUNTO_SPORTS_PID, 0x400, 0xffff) },
 	{ }						/* Terminating entry */
 };
 
@@ -494,21 +452,12 @@
 };
 
 
-static struct usb_device_id id_table_FT2232C[] = {
-	{ USB_DEVICE(FTDI_VID, FTDI_8U2232C_PID) },
-	{ }						/* Terminating entry */
-};
-
-
 static struct usb_device_id id_table_combined [] = {
 	{ USB_DEVICE(FTDI_VID, FTDI_IRTRANS_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_SIO_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_8U232AM_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_8U232AM_ALT_PID) },
-	{ USB_DEVICE(FTDI_VID, FTDI_8U2232C_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_RELAIS_PID) },
-	{ USB_DEVICE(INTERBIOMETRICS_VID, INTERBIOMETRICS_IOBOARD_PID) },
-	{ USB_DEVICE(INTERBIOMETRICS_VID, INTERBIOMETRICS_MINI_IOBOARD_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_XF_632_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_XF_634_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_XF_547_PID) },
@@ -583,18 +532,6 @@
 	{ USB_DEVICE(FTDI_VID, PROTEGO_SPECIAL_3) },
 	{ USB_DEVICE(FTDI_VID, PROTEGO_SPECIAL_4) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_UO100_PID) },
- 	{ USB_DEVICE_VER(FTDI_VID, LINX_SDMUSBQSS_PID, 0x400, 0xffff) },
- 	{ USB_DEVICE_VER(FTDI_VID, LINX_MASTERDEVEL2_PID, 0x400, 0xffff) },
- 	{ USB_DEVICE_VER(FTDI_VID, LINX_FUTURE_0_PID, 0x400, 0xffff) },
- 	{ USB_DEVICE_VER(FTDI_VID, LINX_FUTURE_1_PID, 0x400, 0xffff) },
- 	{ USB_DEVICE_VER(FTDI_VID, LINX_FUTURE_2_PID, 0x400, 0xffff) },
- 	{ USB_DEVICE(FTDI_VID, FTDI_CCSICDU20_0_PID) },
- 	{ USB_DEVICE(FTDI_VID, FTDI_CCSICDU40_1_PID) },
-	{ USB_DEVICE(FTDI_VID, INSIDE_ACCESSO) },
-	{ USB_DEVICE(INTREPID_VID, INTREPID_VALUECAN_PID) },
-	{ USB_DEVICE(INTREPID_VID, INTREPID_NEOVI_PID) },
-	{ USB_DEVICE(FALCOM_VID, FALCOM_TWIST_PID) },
-	{ USB_DEVICE(FTDI_VID, FTDI_SUUNTO_SPORTS_PID) },
 	{ }						/* Terminating entry */
 };
 
@@ -612,10 +549,6 @@
 #define BUFSZ 512
 #define PKTSZ 64
 
-/* rx_flags */
-#define THROTTLED		0x01
-#define ACTUALLY_THROTTLED	0x02
-
 struct ftdi_private {
 	ftdi_chip_type_t chip_type;
 				/* type of the device, either SIO or FT8U232AM */
@@ -630,10 +563,6 @@
 	unsigned long last_dtr_rts;	/* saved modem control outputs */
         wait_queue_head_t delta_msr_wait; /* Used for TIOCMIWAIT */
  	char prev_status, diff_status;        /* Used for TIOCMIWAIT */
-	__u8 rx_flags;		/* receive state flags (throttling) */
-	spinlock_t rx_lock;	/* spinlock for receive state */
-
-	__u16 interface;	/* FT2232C port interface (0 for FT232/245) */
 
 	int force_baud;		/* if non-zero, force the baud rate to this value */
 	int force_rtscts;	/* if non-zero, force RTS-CTS to always be enabled */
@@ -651,7 +580,6 @@
 static int  ftdi_SIO_startup		(struct usb_serial *serial);
 static int  ftdi_8U232AM_startup	(struct usb_serial *serial);
 static int  ftdi_FT232BM_startup	(struct usb_serial *serial);
-static int  ftdi_FT2232C_startup	(struct usb_serial *serial);
 static int  ftdi_USB_UIRT_startup	(struct usb_serial *serial);
 static int  ftdi_HE_TIRA1_startup	(struct usb_serial *serial);
 static void ftdi_shutdown		(struct usb_serial *serial);
@@ -662,7 +590,6 @@
 static int  ftdi_chars_in_buffer	(struct usb_serial_port *port);
 static void ftdi_write_bulk_callback	(struct urb *urb, struct pt_regs *regs);
 static void ftdi_read_bulk_callback	(struct urb *urb, struct pt_regs *regs);
-static void ftdi_process_read		(struct usb_serial_port *port);
 static void ftdi_set_termios		(struct usb_serial_port *port, struct termios * old);
 static int  ftdi_tiocmget               (struct usb_serial_port *port, struct file *file);
 static int  ftdi_tiocmset		(struct usb_serial_port *port, struct file * file, unsigned int set, unsigned int clear);
@@ -754,32 +681,6 @@
 	.shutdown =		ftdi_shutdown,
 };
 
-static struct usb_serial_device_type ftdi_FT2232C_device = {
-	.owner =		THIS_MODULE,
-	.name =			"FTDI FT2232C Compatible",
-	.id_table =		id_table_FT2232C,
-	.num_interrupt_in =	0,
-	.num_bulk_in =		1,
-	.num_bulk_out =		1,
-	.num_ports =		1,
-	.open =			ftdi_open,
-	.close =		ftdi_close,
-	.throttle =		ftdi_throttle,
-	.unthrottle =		ftdi_unthrottle,
-	.write =		ftdi_write,
-	.write_room =		ftdi_write_room,
-	.chars_in_buffer =	ftdi_chars_in_buffer,
-	.read_bulk_callback =	ftdi_read_bulk_callback,
-	.write_bulk_callback =	ftdi_write_bulk_callback,
-	.tiocmget =             ftdi_tiocmget,
-	.tiocmset =             ftdi_tiocmset,
-	.ioctl =		ftdi_ioctl,
-	.set_termios =		ftdi_set_termios,
-	.break_ctl =		ftdi_break_ctl,
-	.attach =		ftdi_FT2232C_startup,
-	.shutdown =		ftdi_shutdown,
-};
-
 static struct usb_serial_device_type ftdi_USB_UIRT_device = {
 	.owner =		THIS_MODULE,
 	.name =			"USB-UIRT Infrared Tranceiver",
@@ -888,14 +789,8 @@
 static int set_rts(struct usb_serial_port *port, int high_or_low)
 {
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
-	char *buf;
+	char buf[1];
 	unsigned ftdi_high_or_low;
-	int rv;
-	
-	buf = kmalloc(1, GFP_NOIO);
-	if (!buf)
-		return -ENOMEM;
-	
 	if (high_or_low) {
 		ftdi_high_or_low = FTDI_SIO_SET_RTS_HIGH;
 		priv->last_dtr_rts |= TIOCM_RTS;
@@ -903,29 +798,20 @@
 		ftdi_high_or_low = FTDI_SIO_SET_RTS_LOW;
 		priv->last_dtr_rts &= ~TIOCM_RTS;
 	}
-	rv = usb_control_msg(port->serial->dev,
+	return(usb_control_msg(port->serial->dev,
 			       usb_sndctrlpipe(port->serial->dev, 0),
 			       FTDI_SIO_SET_MODEM_CTRL_REQUEST, 
 			       FTDI_SIO_SET_MODEM_CTRL_REQUEST_TYPE,
-			       ftdi_high_or_low, priv->interface, 
-			       buf, 0, WDR_TIMEOUT);
-
-	kfree(buf);
-	return rv;
+			       ftdi_high_or_low, 0, 
+			       buf, 0, WDR_TIMEOUT));
 }
 
 
 static int set_dtr(struct usb_serial_port *port, int high_or_low)
 {
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
-	char *buf;
+	char buf[1];
 	unsigned ftdi_high_or_low;
-	int rv;
-	
-	buf = kmalloc(1, GFP_NOIO);
-	if (!buf)
-		return -ENOMEM;
-
 	if (high_or_low) {
 		ftdi_high_or_low = FTDI_SIO_SET_DTR_HIGH;
 		priv->last_dtr_rts |= TIOCM_DTR;
@@ -933,15 +819,12 @@
 		ftdi_high_or_low = FTDI_SIO_SET_DTR_LOW;
 		priv->last_dtr_rts &= ~TIOCM_DTR;
 	}
-	rv = usb_control_msg(port->serial->dev,
+	return(usb_control_msg(port->serial->dev,
 			       usb_sndctrlpipe(port->serial->dev, 0),
 			       FTDI_SIO_SET_MODEM_CTRL_REQUEST, 
 			       FTDI_SIO_SET_MODEM_CTRL_REQUEST_TYPE,
-			       ftdi_high_or_low, priv->interface, 
-			       buf, 0, WDR_TIMEOUT);
-
-	kfree(buf);
-	return rv;
+			       ftdi_high_or_low, 0, 
+			       buf, 0, WDR_TIMEOUT));
 }
 
 
@@ -950,33 +833,21 @@
 
 static int change_speed(struct usb_serial_port *port)
 {
-	struct ftdi_private *priv = usb_get_serial_port_data(port);
-	char *buf;
+	char buf[1];
         __u16 urb_value;
 	__u16 urb_index;
 	__u32 urb_index_value;
-	int rv;
-
-	buf = kmalloc(1, GFP_NOIO);
-	if (!buf)
-		return -ENOMEM;
 
 	urb_index_value = get_ftdi_divisor(port);
 	urb_value = (__u16)urb_index_value;
 	urb_index = (__u16)(urb_index_value >> 16);
-	if (priv->interface) {	/* FT2232C */
-		urb_index = (__u16)((urb_index << 8) | priv->interface);
-	}
 	
-	rv = usb_control_msg(port->serial->dev,
+	return (usb_control_msg(port->serial->dev,
 			    usb_sndctrlpipe(port->serial->dev, 0),
 			    FTDI_SIO_SET_BAUDRATE_REQUEST,
 			    FTDI_SIO_SET_BAUDRATE_REQUEST_TYPE,
 			    urb_value, urb_index,
-			    buf, 0, 100);
-
-	kfree(buf);
-	return rv;
+			    buf, 0, 100) < 0);
 }
 
 
@@ -1060,12 +931,7 @@
 		}
 		break;
 	case FT232BM: /* FT232BM chip */
-	case FT2232C: /* FT2232C chip */
-		if (priv->chip_type == FT2232C) {
-			chip_name = "FT2232C";
-		} else {
-			chip_name = "FT232BM";
-		}
+		chip_name = "FT232BM";
 		if (baud <= 3000000) {
 			div_value = ftdi_232bm_baud_to_divisor(baud);
 		} else {
@@ -1085,7 +951,7 @@
 }
 
 
-static int get_serial_info(struct usb_serial_port * port, struct serial_struct __user * retinfo)
+static int get_serial_info(struct usb_serial_port * port, struct serial_struct * retinfo)
 {
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
 	struct serial_struct tmp;
@@ -1102,7 +968,7 @@
 } /* get_serial_info */
 
 
-static int set_serial_info(struct usb_serial_port * port, struct serial_struct __user * newinfo)
+static int set_serial_info(struct usb_serial_port * port, struct serial_struct * newinfo)
 { /* set_serial_info */
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
 	struct serial_struct new_serial;
@@ -1183,7 +1049,6 @@
 	}
 	memset(priv, 0, sizeof(*priv));
 
-	spin_lock_init(&priv->rx_lock);
         init_waitqueue_head(&priv->delta_msr_wait);
 	/* This will push the characters through immediately rather
 	   than queue a task to deliver them */
@@ -1281,35 +1146,6 @@
 	return (0);
 } /* ftdi_FT232BM_startup */
 
-/* Startup for the FT2232C chip */
-/* Called from usbserial:serial_probe */
-static int ftdi_FT2232C_startup (struct usb_serial *serial)
-{ /* ftdi_FT2232C_startup */
-	struct ftdi_private *priv;
-	int err;
-	int inter;
-
-	dbg("%s",__FUNCTION__);
-	err = ftdi_common_startup(serial);
-	if (err){
-		return (err);
-	}
-
-	priv = usb_get_serial_port_data(serial->port[0]);
-	priv->chip_type = FT2232C;
-	inter = serial->interface->altsetting->desc.bInterfaceNumber;
-
-	if (inter) {
-		priv->interface = INTERFACE_B;
-	}
-	else  {
-		priv->interface = INTERFACE_A;
-	}
-	priv->baud_base = 48000000 / 2; /* Would be / 16, but FT2232C supports multiple of 0.125 divisor fractions! */
-	
-	return (0);
-} /* ftdi_FT2232C_startup */
-
 /* Startup for the USB-UIRT device, which requires hardwired baudrate (38400 gets mapped to 312500) */
 /* Called from usbserial:serial_probe */
 static int ftdi_USB_UIRT_startup (struct usb_serial *serial)
@@ -1376,8 +1212,8 @@
 	 */
 
 	if (priv) {
-		usb_set_serial_port_data(port, NULL);
 		kfree(priv);
+		usb_set_serial_port_data(port, NULL);
 	}
 } /* ftdi_shutdown */
 
@@ -1385,9 +1221,8 @@
 static int  ftdi_open (struct usb_serial_port *port, struct file *filp)
 { /* ftdi_open */
 	struct termios tmp_termios;
-	struct usb_device *dev = port->serial->dev;
+	struct usb_serial *serial = port->serial;
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
-	unsigned long flags;
 	
 	int result = 0;
 	char buf[1]; /* Needed for the usb_control_msg I think */
@@ -1399,10 +1234,10 @@
 
 	/* No error checking for this (will get errors later anyway) */
 	/* See ftdi_sio.h for description of what is reset */
-	usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+	usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 			FTDI_SIO_RESET_REQUEST, FTDI_SIO_RESET_REQUEST_TYPE, 
 			FTDI_SIO_RESET_SIO, 
-			priv->interface, buf, 0, WDR_TIMEOUT);
+			0, buf, 0, WDR_TIMEOUT);
 
 	/* Termios defaults are set by usb_serial_init. We don't change
 	   port->tty->termios - this would loose speed settings, etc.
@@ -1421,14 +1256,9 @@
 		err("%s Error from RTS HIGH urb", __FUNCTION__);
 	}
 
-	/* Not throttled */
-	spin_lock_irqsave(&priv->rx_lock, flags);
-	priv->rx_flags &= ~(THROTTLED | ACTUALLY_THROTTLED);
-	spin_unlock_irqrestore(&priv->rx_lock, flags);
-
 	/* Start reading from the device */
-	usb_fill_bulk_urb(port->read_urb, dev,
-		      usb_rcvbulkpipe(dev, port->bulk_in_endpointAddress),
+	usb_fill_bulk_urb(port->read_urb, serial->dev, 
+		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
 		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
 		      ftdi_read_bulk_callback, port);
 	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
@@ -1451,44 +1281,46 @@
 
 static void ftdi_close (struct usb_serial_port *port, struct file *filp)
 { /* ftdi_close */
+	struct usb_serial *serial;
 	unsigned int c_cflag = port->tty->termios->c_cflag;
-	struct ftdi_private *priv = usb_get_serial_port_data(port);
 	char buf[1];
 
 	dbg("%s", __FUNCTION__);
 
-	if (c_cflag & HUPCL){
-		/* Disable flow control */
-		if (usb_control_msg(port->serial->dev, 
-				    usb_sndctrlpipe(port->serial->dev, 0),
-				    FTDI_SIO_SET_FLOW_CTRL_REQUEST,
-				    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
-				    0, priv->interface, buf, 0,
-				    WDR_TIMEOUT) < 0) {
-			err("error from flowcontrol urb");
-		}	    
+	serial = get_usb_serial ( port, __FUNCTION__);
+	if (!serial)
+		return;
+
+	if (serial->dev) {
+		if (c_cflag & HUPCL){
+			/* Disable flow control */
+			if (usb_control_msg(serial->dev, 
+					    usb_sndctrlpipe(serial->dev, 0),
+					    FTDI_SIO_SET_FLOW_CTRL_REQUEST,
+					    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
+					    0, 0, buf, 0, WDR_TIMEOUT) < 0) {
+				err("error from flowcontrol urb");
+			}	    
+
+			/* drop DTR */
+			if (set_dtr(port, LOW) < 0){
+				err("Error from DTR LOW urb");
+			}
+			/* drop RTS */
+			if (set_rts(port, LOW) < 0) {
+				err("Error from RTS LOW urb");
+			}	
+			/* shutdown our bulk read */
+			if (port->read_urb) {
+				usb_unlink_urb (port->read_urb);	
+			}
+			/* unlink the running write urbs */
+			
+
+		} /* Note change no line is hupcl is off */
+	} /* if (serial->dev) */
+
 
-		/* drop DTR */
-		if (set_dtr(port, LOW) < 0){
-			err("Error from DTR LOW urb");
-		}
-		/* drop RTS */
-		if (set_rts(port, LOW) < 0) {
-			err("Error from RTS LOW urb");
-		}
-	} /* Note change no line if hupcl is off */
-	
-	/* shutdown our bulk read */
-	if (port->read_urb) {
-		if (usb_unlink_urb (port->read_urb) < 0) {
-			/* Generally, this isn't an error.  If the previous
-			   read bulk callback occurred (or is about to occur)
-			   while the port was being closed or was throtted
-			   (and is still throttled), the read urb will not
-			   have been submitted. */
-			dbg("%s - failed to unlink read urb (generally not an error)", __FUNCTION__);
-		}
-	}
 } /* ftdi_close */
 
 
@@ -1503,6 +1335,7 @@
 static int ftdi_write (struct usb_serial_port *port, int from_user,
 			   const unsigned char *buf, int count)
 { /* ftdi_write */
+	struct usb_serial *serial = get_usb_serial ( port, __FUNCTION__);
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
 	struct urb *urb;
 	unsigned char *buffer;
@@ -1586,11 +1419,11 @@
 		}
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, transfer_size, buffer);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, transfer_size, buffer);
 
 	/* fill the buffer and send it */
-	usb_fill_bulk_urb(urb, port->serial->dev, 
-		      usb_sndbulkpipe(port->serial->dev, port->bulk_out_endpointAddress),
+	usb_fill_bulk_urb(urb, serial->dev, 
+		      usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress),
 		      buffer, transfer_size,
 		      ftdi_write_bulk_callback, port);
 
@@ -1598,7 +1431,6 @@
 	if (status) {
 		err("%s - failed submitting write urb, error %d", __FUNCTION__, status);
 		count = status;
-		kfree (buffer);
 	}
 
 	/* we are done with this urb, so let the host driver
@@ -1619,6 +1451,9 @@
 	/* free up the transfer buffer, as usb_free_urb() does not do this */
 	kfree (urb->transfer_buffer);
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (urb->status) {
@@ -1661,8 +1496,16 @@
 static void ftdi_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 { /* ftdi_read_bulk_callback */
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial;
 	struct tty_struct *tty;
 	struct ftdi_private *priv;
+	char error_flag;
+       	unsigned char *data = urb->transfer_buffer;
+
+	int i;
+	int result;
+	int need_flip;
+	int packet_offset;
 
 	if (urb->number_of_packets > 0) {
 		err("%s transfer_buffer_length %d actual_length %d number of packets %d",__FUNCTION__,
@@ -1670,66 +1513,20 @@
 		err("%s transfer_flags %x ", __FUNCTION__,urb->transfer_flags );
 	}
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
-
-	if (port->open_count <= 0)
-		return;
-
-	tty = port->tty;
-	if (!tty) {
-		dbg("%s - bad tty pointer - exiting",__FUNCTION__);
-		return;
-	}
+	dbg("%s", __FUNCTION__);
 
-	priv = usb_get_serial_port_data(port);
-	if (!priv) {
-		dbg("%s - bad port private data pointer - exiting", __FUNCTION__);
+	if (port_paranoia_check (port, __FUNCTION__)) {
 		return;
 	}
-
-	if (urb != port->read_urb) {
-		err("%s - Not my urb!", __FUNCTION__);
-	}
-
-	if (urb->status) {
-		/* This will happen at close every time so it is a dbg not an err */
-		dbg("(this is ok on close) nonzero read bulk status received: %d", urb->status);
+	if (port->open_count <= 0)
 		return;
-	}
 
-	/* If throttled, delay receive processing until unthrottled. */
-	spin_lock(&priv->rx_lock);
-	if (priv->rx_flags & THROTTLED) {
-		dbg("Deferring read urb processing until unthrottled");
-		priv->rx_flags |= ACTUALLY_THROTTLED;
-		spin_unlock(&priv->rx_lock);
+	serial = get_usb_serial(port,__FUNCTION__);
+	if (!serial){
+		dbg("%s - bad serial pointer - exiting",__FUNCTION__);
 		return;
 	}
-	spin_unlock(&priv->rx_lock);
-
-	ftdi_process_read(port);
-
-} /* ftdi_read_bulk_callback */
-
-
-static void ftdi_process_read (struct usb_serial_port *port)
-{ /* ftdi_process_read */
-	struct urb *urb;
-	struct tty_struct *tty;
-	struct ftdi_private *priv;
-	char error_flag;
-       	unsigned char *data;
-
-	int i;
-	int result;
-	int need_flip;
-	int packet_offset;
-
-	dbg("%s - port %d", __FUNCTION__, port->number);
-
-	if (port->open_count <= 0)
-		return;
-
+	
 	tty = port->tty;
 	if (!tty) {
 		dbg("%s - bad tty pointer - exiting",__FUNCTION__);
@@ -1737,22 +1534,16 @@
 	}
 
 	priv = usb_get_serial_port_data(port);
-	if (!priv) {
-		dbg("%s - bad port private data pointer - exiting", __FUNCTION__);
-		return;
-	}
 
-	urb = port->read_urb;
-	if (!urb) {
-		dbg("%s - bad read_urb pointer - exiting", __FUNCTION__);
+	if (urb->status) {
+		/* This will happen at close every time so it is a dbg not an err */
+		dbg("(this is ok on close) nonzero read bulk status received: %d", urb->status);
 		return;
 	}
 
-	data = urb->transfer_buffer;
-
         /* The first two bytes of every read packet are status */
 	if (urb->actual_length > 2) {
-		usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+		usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 	} else {
                 dbg("Status only: %03oo %03oo",data[0],data[1]);
         }
@@ -1843,8 +1634,8 @@
 	/* if the port is closed stop trying to read */
 	if (port->open_count > 0){
 		/* Continue trying to always read  */
-		usb_fill_bulk_urb(port->read_urb, port->serial->dev, 
-			      usb_rcvbulkpipe(port->serial->dev, port->bulk_in_endpointAddress),
+		usb_fill_bulk_urb(port->read_urb, serial->dev, 
+			      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
 			      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
 			      ftdi_read_bulk_callback, port);
 
@@ -1854,11 +1645,12 @@
 	}
 
 	return;
-} /* ftdi_process_read */
+} /* ftdi_read_bulk_callback */
 
 
 static void ftdi_break_ctl( struct usb_serial_port *port, int break_state )
 {
+	struct usb_serial *serial = port->serial;
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
 	__u16 urb_value = 0; 
 	char buf[1];
@@ -1874,10 +1666,10 @@
 	}
 
 	
-	if (usb_control_msg(port->serial->dev, usb_sndctrlpipe(port->serial->dev, 0),
+	if (usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 			    FTDI_SIO_SET_DATA_REQUEST, 
 			    FTDI_SIO_SET_DATA_REQUEST_TYPE,
-			    urb_value , priv->interface,
+			    urb_value , 0,
 			    buf, 0, WDR_TIMEOUT) < 0) {
 		err("%s FAILED to enable/disable break state (state was %d)", __FUNCTION__,break_state);
 	}	   
@@ -1894,7 +1686,7 @@
 
 static void ftdi_set_termios (struct usb_serial_port *port, struct termios *old_termios)
 { /* ftdi_termios */
-	struct usb_device *dev = port->serial->dev;
+	struct usb_serial *serial = port->serial;
 	unsigned int cflag = port->tty->termios->c_cflag;
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
 	__u16 urb_value; /* will hold the new flags */
@@ -1953,10 +1745,10 @@
 	 *  or'ed with this value  */
 	priv->last_set_data_urb_value = urb_value;
 	
-	if (usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+	if (usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 			    FTDI_SIO_SET_DATA_REQUEST, 
 			    FTDI_SIO_SET_DATA_REQUEST_TYPE,
-			    urb_value , priv->interface,
+			    urb_value , 0,
 			    buf, 0, 100) < 0) {
 		err("%s FAILED to set databits/stopbits/parity", __FUNCTION__);
 	}	   
@@ -1964,10 +1756,10 @@
 	/* Now do the baudrate */
 	if ((cflag & CBAUD) == B0 ) {
 		/* Disable flow control */
-		if (usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+		if (usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 				    FTDI_SIO_SET_FLOW_CTRL_REQUEST, 
 				    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
-				    0, priv->interface, 
+				    0, 0, 
 				    buf, 0, WDR_TIMEOUT) < 0) {
 			err("%s error from disable flowcontrol urb", __FUNCTION__);
 		}	    
@@ -1984,24 +1776,17 @@
 		if (change_speed(port)) {
 			err("%s urb failed to set baurdrate", __FUNCTION__);
 		}
-		/* Ensure  RTS and DTR are raised */
-		else if (set_dtr(port, HIGH) < 0){
-			err("%s Error from DTR HIGH urb", __FUNCTION__);
-		}
-		else if (set_rts(port, HIGH) < 0){
-			err("%s Error from RTS HIGH urb", __FUNCTION__);
-		}	
 	}
 
 	/* Set flow control */
 	/* Note device also supports DTR/CD (ugh) and Xon/Xoff in hardware */
 	if (cflag & CRTSCTS) {
 		dbg("%s Setting to CRTSCTS flow control", __FUNCTION__);
-		if (usb_control_msg(dev, 
-				    usb_sndctrlpipe(dev, 0),
+		if (usb_control_msg(serial->dev, 
+				    usb_sndctrlpipe(serial->dev, 0),
 				    FTDI_SIO_SET_FLOW_CTRL_REQUEST, 
 				    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
-				    0 , (FTDI_SIO_RTS_CTS_HS | priv->interface),
+				    0 , FTDI_SIO_RTS_CTS_HS,
 				    buf, 0, WDR_TIMEOUT) < 0) {
 			err("urb failed to set to rts/cts flow control");
 		}		
@@ -2023,12 +1808,11 @@
 			vstop=port->tty->termios->c_cc[VSTOP];
 			urb_value=(vstop << 8) | (vstart);
 
-			if (usb_control_msg(dev,
-					    usb_sndctrlpipe(dev, 0),
+			if (usb_control_msg(serial->dev,
+					    usb_sndctrlpipe(serial->dev, 0),
 					    FTDI_SIO_SET_FLOW_CTRL_REQUEST,
 					    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
-					    urb_value , (FTDI_SIO_XON_XOFF_HS
-							 | priv->interface),
+					    urb_value , FTDI_SIO_XON_XOFF_HS,
 					    buf, 0, WDR_TIMEOUT) < 0) {
 				err("urb failed to set to xon/xoff flow control");
 			}
@@ -2036,11 +1820,11 @@
 			/* else clause to only run if cfag ! CRTSCTS and iflag ! XOFF */
 			/* CHECKME Assuming XON/XOFF handled by tty stack - not by device */
 			dbg("%s Turning off hardware flow control", __FUNCTION__);
-			if (usb_control_msg(dev, 
-					    usb_sndctrlpipe(dev, 0),
+			if (usb_control_msg(serial->dev, 
+					    usb_sndctrlpipe(serial->dev, 0),
 					    FTDI_SIO_SET_FLOW_CTRL_REQUEST, 
 					    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
-					    0, priv->interface, 
+					    0, 0, 
 					    buf, 0, WDR_TIMEOUT) < 0) {
 				err("urb failed to clear flow control");
 			}				
@@ -2053,6 +1837,7 @@
 
 static int ftdi_tiocmget (struct usb_serial_port *port, struct file *file)
 {
+	struct usb_serial *serial = port->serial;
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
 	unsigned char buf[2];
 	int ret;
@@ -2061,8 +1846,8 @@
 	switch (priv->chip_type) {
 	case SIO:
 		/* Request the status from the device */
-		if ((ret = usb_control_msg(port->serial->dev, 
-					   usb_rcvctrlpipe(port->serial->dev, 0),
+		if ((ret = usb_control_msg(serial->dev, 
+					   usb_rcvctrlpipe(serial->dev, 0),
 					   FTDI_SIO_GET_MODEM_STATUS_REQUEST, 
 					   FTDI_SIO_GET_MODEM_STATUS_REQUEST_TYPE,
 					   0, 0, 
@@ -2074,14 +1859,13 @@
 		break;
 	case FT8U232AM:
 	case FT232BM:
-	case FT2232C:
 		/* the 8U232AM returns a two byte value (the sio is a 1 byte value) - in the same
 		   format as the data returned from the in point */
-		if ((ret = usb_control_msg(port->serial->dev, 
-					   usb_rcvctrlpipe(port->serial->dev, 0),
+		if ((ret = usb_control_msg(serial->dev, 
+					   usb_rcvctrlpipe(serial->dev, 0),
 					   FTDI_SIO_GET_MODEM_STATUS_REQUEST, 
 					   FTDI_SIO_GET_MODEM_STATUS_REQUEST_TYPE,
-					   0, priv->interface, 
+					   0, 0, 
 					   buf, 2, WDR_TIMEOUT)) < 0 ) {
 			err("%s Could not get modem status of device - err: %d", __FUNCTION__,
 			    ret);
@@ -2104,7 +1888,6 @@
 {
 	int ret;
 	
-	dbg("%s TIOCMSET", __FUNCTION__);
 	if (set & TIOCM_DTR){
 		if ((ret = set_dtr(port, HIGH)) < 0) {
 			err("Urb to set DTR failed");
@@ -2147,7 +1930,7 @@
 
 	case TIOCMBIS: /* turns on (Sets) the lines as specified by the mask */
 		dbg("%s TIOCMBIS", __FUNCTION__);
- 	        if (get_user(mask, (unsigned long __user *) arg))
+ 	        if (get_user(mask, (unsigned long *) arg))
 			return -EFAULT;
   	        if (mask & TIOCM_DTR){
 			if ((ret = set_dtr(port, HIGH)) < 0) {
@@ -2166,7 +1949,7 @@
 
 	case TIOCMBIC: /* turns off (Clears) the lines as specified by the mask */
 		dbg("%s TIOCMBIC", __FUNCTION__);
- 	        if (get_user(mask, (unsigned long __user *) arg))
+ 	        if (get_user(mask, (unsigned long *) arg))
 			return -EFAULT;
   	        if (mask & TIOCM_DTR){
 			if ((ret = set_dtr(port, LOW)) < 0){
@@ -2193,10 +1976,10 @@
 		 */
 
 	case TIOCGSERIAL: /* gets serial port data */
-		return get_serial_info(port, (struct serial_struct __user *) arg);
+		return get_serial_info(port, (struct serial_struct *) arg);
 
 	case TIOCSSERIAL: /* sets serial port data */
-		return set_serial_info(port, (struct serial_struct __user *) arg);
+		return set_serial_info(port, (struct serial_struct *) arg);
 
 	/*
 	 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change
@@ -2254,32 +2037,28 @@
 
 static void ftdi_throttle (struct usb_serial_port *port)
 {
-	struct ftdi_private *priv = usb_get_serial_port_data(port);
-	unsigned long flags;
-
 	dbg("%s - port %d", __FUNCTION__, port->number);
-
-	spin_lock_irqsave(&priv->rx_lock, flags);
-	priv->rx_flags |= THROTTLED;
-	spin_unlock_irqrestore(&priv->rx_lock, flags);
+	usb_unlink_urb (port->read_urb);
 }
 
 
 static void ftdi_unthrottle (struct usb_serial_port *port)
 {
-	struct ftdi_private *priv = usb_get_serial_port_data(port);
-	int actually_throttled;
-	unsigned long flags;
+	int result;
+	struct usb_serial *serial = port->serial;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	spin_lock_irqsave(&priv->rx_lock, flags);
-	actually_throttled = priv->rx_flags & ACTUALLY_THROTTLED;
-	priv->rx_flags &= ~(THROTTLED | ACTUALLY_THROTTLED);
-	spin_unlock_irqrestore(&priv->rx_lock, flags);
+	port->read_urb->dev = serial->dev;
+
+	usb_fill_bulk_urb(port->read_urb, serial->dev, 
+		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
+		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
+		      ftdi_read_bulk_callback, port);
 
-	if (actually_throttled)
-		ftdi_process_read(port);
+	result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
+	if (result)
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
 }
 
 static int __init ftdi_init (void)
@@ -2296,9 +2075,6 @@
 	retval = usb_serial_register(&ftdi_FT232BM_device);
 	if (retval)
 		goto failed_FT232BM_register;
-	retval = usb_serial_register(&ftdi_FT2232C_device);
-	if (retval)
-		goto failed_FT2232C_register;
 	retval = usb_serial_register(&ftdi_USB_UIRT_device);
 	if (retval)
 		goto failed_USB_UIRT_register;
@@ -2316,8 +2092,6 @@
 failed_HE_TIRA1_register:
 	usb_serial_deregister(&ftdi_USB_UIRT_device);
 failed_USB_UIRT_register:
-	usb_serial_deregister(&ftdi_FT2232C_device);
-failed_FT2232C_register:
 	usb_serial_deregister(&ftdi_FT232BM_device);
 failed_FT232BM_register:
 	usb_serial_deregister(&ftdi_8U232AM_device);
@@ -2336,7 +2110,6 @@
 	usb_deregister (&ftdi_driver);
 	usb_serial_deregister (&ftdi_HE_TIRA1_device);
 	usb_serial_deregister (&ftdi_USB_UIRT_device);
-	usb_serial_deregister (&ftdi_FT2232C_device);
 	usb_serial_deregister (&ftdi_FT232BM_device);
 	usb_serial_deregister (&ftdi_8U232AM_device);
 	usb_serial_deregister (&ftdi_SIO_device);
@@ -2351,6 +2124,6 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
 
diff -Naur linuxppc-2.6.9/drivers/usb/serial/ftdi_sio.h linuxppc-2.6.9-dream/drivers/usb/serial/ftdi_sio.h
--- linuxppc-2.6.9/drivers/usb/serial/ftdi_sio.h	2004-10-18 23:55:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/ftdi_sio.h	2005-09-19 21:40:06.000000000 +0200
@@ -26,7 +26,6 @@
 #define FTDI_SIO_PID	0x8372	/* Product Id SIO application of 8U100AX  */
 #define FTDI_8U232AM_PID 0x6001 /* Similar device to SIO above */
 #define FTDI_8U232AM_ALT_PID 0x6006 /* FTDI's alternate PID for above */
-#define FTDI_8U2232C_PID 0x6010 /* Dual channel device */
 #define FTDI_RELAIS_PID	0xFA10  /* Relais device from Rudolf Gugler */
 #define FTDI_NF_RIC_VID	0x0DCD	/* Vendor Id */
 #define FTDI_NF_RIC_PID	0x0001	/* Product Id */
@@ -62,12 +61,6 @@
 #define FTDI_MTXORB_5_PID      0xFA05  /* Matrix Orbital Product Id */
 #define FTDI_MTXORB_6_PID      0xFA06  /* Matrix Orbital Product Id */
 
-/* Interbiometrics USB I/O Board */
-/* Developed for Interbiometrics by Rudolf Gugler */
-#define INTERBIOMETRICS_VID              0x1209
-#define INTERBIOMETRICS_IOBOARD_PID      0x1002
-#define INTERBIOMETRICS_MINI_IOBOARD_PID 0x1006
-
 /*
  * The following are the values for the Perle Systems
  * UltraPort USB serial converters
@@ -156,7 +149,6 @@
  */
 #define OCT_VID			0x0B39	/* OCT vendor ID */
 /* Note: OCT US101 is also rebadged as Dick Smith Electronics (NZ) XH6381 */
-/* Also rebadged as SIIG Inc. model US2308 */
 #define OCT_US101_PID		0x0421	/* OCT US101 USB to RS-232 */
 
 /* an infrared receiver for user access control with IR tags */
@@ -168,62 +160,7 @@
 #define PROTEGO_SPECIAL_1	0xFC70	/* special/unknown device */
 #define PROTEGO_R2X0		0xFC71	/* R200-USB TRNG unit (R210, R220, and R230) */
 #define PROTEGO_SPECIAL_3	0xFC72	/* special/unknown device */
-#define PROTEGO_SPECIAL_4	0xFC73	/* special/unknown device */
-
-/*
- * Gude Analog- und Digitalsysteme GmbH
- */
-#define FTDI_GUDEADS_E808_PID    0xE808
-#define FTDI_GUDEADS_E809_PID    0xE809
-#define FTDI_GUDEADS_E80A_PID    0xE80A
-#define FTDI_GUDEADS_E80B_PID    0xE80B
-#define FTDI_GUDEADS_E80C_PID    0xE80C
-#define FTDI_GUDEADS_E80D_PID    0xE80D
-#define FTDI_GUDEADS_E80E_PID    0xE80E
-#define FTDI_GUDEADS_E80F_PID    0xE80F
-#define FTDI_GUDEADS_E888_PID    0xE888  /* Expert ISDN Control USB */
-#define FTDI_GUDEADS_E889_PID    0xE889  /* USB RS-232 OptoBridge */
-#define FTDI_GUDEADS_E88A_PID    0xE88A
-#define FTDI_GUDEADS_E88B_PID    0xE88B
-#define FTDI_GUDEADS_E88C_PID    0xE88C
-#define FTDI_GUDEADS_E88D_PID    0xE88D
-#define FTDI_GUDEADS_E88E_PID    0xE88E
-#define FTDI_GUDEADS_E88F_PID    0xE88F
-
-/*
- * Linx Technologies product ids
- */
-#define LINX_SDMUSBQSS_PID	0xF448	/* Linx SDM-USB-QS-S */
-#define LINX_MASTERDEVEL2_PID   0xF449   /* Linx Master Development 2.0 */
-#define LINX_FUTURE_0_PID   0xF44A   /* Linx future device */
-#define LINX_FUTURE_1_PID   0xF44B   /* Linx future device */
-#define LINX_FUTURE_2_PID   0xF44C   /* Linx future device */
-
-/* CCS Inc. ICDU/ICDU40 product ID - the FT232BM is used in an in-circuit-debugger */
-/* unit for PIC16's/PIC18's */
-#define FTDI_CCSICDU20_0_PID    0xF9D0     
-#define FTDI_CCSICDU40_1_PID    0xF9D1     
-
-/* Inside Accesso contactless reader (http://www.insidefr.com) */
-#define INSIDE_ACCESSO		0xFAD0
-
-/*
- * Intrepid Control Systems (http://www.intrepidcs.com/) ValueCAN and NeoVI
- */
-#define INTREPID_VID		0x093C
-#define INTREPID_VALUECAN_PID	0x0601
-#define INTREPID_NEOVI_PID	0x0701
-
-/*
- * Falcom Wireless Communications GmbH
- */
-#define FALCOM_VID		0x0F94	/* Vendor Id */
-#define FALCOM_TWIST_PID	0x0001	/* Falcom Twist USB GPRS modem */
-
-/*
- * SUUNTO product ids
- */
-#define FTDI_SUUNTO_SPORTS_PID	0xF680	/* Suunto Sports instrument */
+#define PROTEGO_SPECIAL_4	0xFC73	/* special/unknown device */ 
 
 /* Commands */
 #define FTDI_SIO_RESET 		0 /* Reset the port */
@@ -235,21 +172,6 @@
 #define FTDI_SIO_SET_EVENT_CHAR	6 /* Set the event character */
 #define FTDI_SIO_SET_ERROR_CHAR	7 /* Set the error character */
 
-/* Port interface code for FT2232C */
-#define INTERFACE_A		1
-#define INTERFACE_B		2
-
-
-/*
- *   BmRequestType:  1100 0000b
- *   bRequest:       FTDI_E2_READ
- *   wValue:         0
- *   wIndex:         Address of word to read
- *   wLength:        2
- *   Data:           Will return a word of data from E2Address
- *
- */
-
 /* Port Identifier Table */
 #define PIT_DEFAULT 		0 /* SIOA */
 #define PIT_SIOA		1 /* SIOA */
@@ -349,7 +271,6 @@
 	SIO = 1,
 	FT8U232AM = 2,
 	FT232BM = 3,
-	FT2232C = 4,
 } ftdi_chip_type_t;
 
 typedef enum {
diff -Naur linuxppc-2.6.9/drivers/usb/serial/generic.c linuxppc-2.6.9-dream/drivers/usb/serial/generic.c
--- linuxppc-2.6.9/drivers/usb/serial/generic.c	2004-10-18 23:53:13.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/generic.c	2005-09-19 21:40:06.000000000 +0200
@@ -16,21 +16,26 @@
 #include <linux/tty.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
-#include <linux/moduleparam.h>
 #include <linux/usb.h>
 #include <asm/uaccess.h>
-#include "usb-serial.h"
 
-static int debug;
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
 
+#include "usb-serial.h"
+
+	
 #ifdef CONFIG_USB_SERIAL_GENERIC
 static __u16 vendor  = 0x05f9;
 static __u16 product = 0xffff;
 
-module_param(vendor, ushort, 0);
+MODULE_PARM(vendor, "h");
 MODULE_PARM_DESC(vendor, "User specified USB idVendor");
 
-module_param(product, ushort, 0);
+MODULE_PARM(product, "h");
 MODULE_PARM_DESC(product, "User specified USB idProduct");
 
 static struct usb_device_id generic_device_ids[2]; /* Initially all zeroes. */
@@ -47,32 +52,6 @@
 	.num_ports =		1,
 	.shutdown =		usb_serial_generic_shutdown,
 };
-
-/* we want to look at all devices, as the vendor/product id can change
- * depending on the command line argument */
-static struct usb_device_id generic_serial_ids[] = {
-	{.driver_info = 42},
-	{}
-};
-
-static int generic_probe(struct usb_interface *interface,
-			       const struct usb_device_id *id)
-{
-	const struct usb_device_id *id_pattern;
-
-	id_pattern = usb_match_id(interface, generic_device_ids);
-	if (id_pattern != NULL)
-		return usb_serial_probe(interface, id);
-	return -ENODEV;
-}
-
-static struct usb_driver generic_driver = {
-	.owner =	THIS_MODULE,
-	.name =		"usbserial_generic",
-	.probe =	generic_probe,
-	.disconnect =	usb_serial_disconnect,
-	.id_table =	generic_serial_ids,
-};
 #endif
 
 int usb_serial_generic_register (int _debug)
@@ -87,12 +66,6 @@
 
 	/* register our generic driver with ourselves */
 	retval = usb_serial_register (&usb_serial_generic_device);
-	if (retval)
-		goto exit;
-	retval = usb_register(&generic_driver);
-	if (retval)
-		usb_serial_deregister(&usb_serial_generic_device);
-exit:
 #endif
 	return retval;
 }
@@ -101,7 +74,6 @@
 {
 #ifdef CONFIG_USB_SERIAL_GENERIC
 	/* remove our generic driver */
-	usb_deregister(&generic_driver);
 	usb_serial_deregister (&usb_serial_generic_device);
 #endif
 }
@@ -111,6 +83,9 @@
 	struct usb_serial *serial = port->serial;
 	int result = 0;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return -ENODEV;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	/* force low_latency on so that our tty_push actually forces the data through, 
@@ -163,7 +138,6 @@
 {
 	struct usb_serial *serial = port->serial;
 	int result;
-	unsigned char *data;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
@@ -188,8 +162,8 @@
 		else {
 			memcpy (port->write_urb->transfer_buffer, buf, count);
 		}
-		data = port->write_urb->transfer_buffer;
-		usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, data);
+
+		usb_serial_debug_data (__FILE__, __FUNCTION__, count, port->write_urb->transfer_buffer);
 
 		/* set up our urb */
 		usb_fill_bulk_urb (port->write_urb, serial->dev,
@@ -249,7 +223,7 @@
 void usb_serial_generic_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
-	struct usb_serial *serial = port->serial;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
 	int i;
@@ -257,12 +231,17 @@
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	tty = port->tty;
 	if (tty && urb->actual_length) {
@@ -294,9 +273,15 @@
 void usb_serial_generic_write_bulk_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 		return;
diff -Naur linuxppc-2.6.9/drivers/usb/serial/io_edgeport.c linuxppc-2.6.9-dream/drivers/usb/serial/io_edgeport.c
--- linuxppc-2.6.9/drivers/usb/serial/io_edgeport.c	2004-10-18 23:53:11.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/io_edgeport.c	2005-09-19 21:40:06.000000000 +0200
@@ -259,7 +259,15 @@
 #include <linux/ioctl.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 #include "usb-serial.h"
+
 #include "io_edgeport.h"
 #include "io_ionsp.h"		/* info for the iosp messages */
 #include "io_16654.h"		/* 16654 UART defines */
@@ -291,13 +299,19 @@
 #define IMAGE_VERSION_NAME	OperationalCodeImageVersion_GEN2
 #include "io_fw_down2.h"	/* Define array OperationalCodeImage[] */
 
+
 #define MAX_NAME_LEN		64
 
+
 #define CHASE_TIMEOUT		(5*HZ)		/* 5 seconds */
 #define OPEN_TIMEOUT		(5*HZ)		/* 5 seconds */
 #define COMMAND_TIMEOUT		(5*HZ)		/* 5 seconds */
 
-static int debug;
+#ifndef SERIAL_MAGIC
+	#define SERIAL_MAGIC	0x6702
+#endif
+#define PORT_MAGIC		0x7301
+
 
 /* receive port state */
 enum RXSTATE {
@@ -479,7 +493,7 @@
 static void load_application_firmware	(struct edgeport_serial *edge_serial);
 
 
-static void unicode_to_ascii		(char *string, __le16 *unicode, int unicode_size);
+static void unicode_to_ascii		(char *string, short *unicode, int unicode_size);
 
 
 
@@ -504,7 +518,7 @@
 	__u32 BootNewVer;
 	__u8 BootMajorVersion;                  
 	__u8 BootMinorVersion;                  
-	__le16 BootBuildNumber;
+	__u16 BootBuildNumber;
 	__u8 *BootImage;      
 	__u32 BootSize;
 	struct edge_firmware_image_record *record;
@@ -653,7 +667,7 @@
 
 	memset (product_info, 0, sizeof(struct edgeport_product_info));
 
-	product_info->ProductId		= (__u16)(edge_serial->serial->dev->descriptor.idProduct & ~ION_DEVICE_ID_80251_NETCHIP);
+	product_info->ProductId		= (__u16)(edge_serial->serial->dev->descriptor.idProduct & ~ION_DEVICE_ID_GENERATION_2);
 	product_info->NumPorts		= edge_serial->manuf_descriptor.NumPorts;
 	product_info->ProdInfoVer	= 0;
 
@@ -669,7 +683,7 @@
 	memcpy(product_info->ManufactureDescDate, edge_serial->manuf_descriptor.DescDate, sizeof(edge_serial->manuf_descriptor.DescDate));
 
 	// check if this is 2nd generation hardware
-	if (edge_serial->serial->dev->descriptor.idProduct & ION_DEVICE_ID_80251_NETCHIP) {
+	if (edge_serial->serial->dev->descriptor.idProduct & ION_DEVICE_ID_GENERATION_2) {
 		product_info->FirmwareMajorVersion	= OperationalCodeImageVersion_GEN2.MajorVersion;
 		product_info->FirmwareMinorVersion	= OperationalCodeImageVersion_GEN2.MinorVersion;
 		product_info->FirmwareBuildNumber	= cpu_to_le16(OperationalCodeImageVersion_GEN2.BuildNumber);
@@ -762,6 +776,10 @@
 
 	dbg("%s", __FUNCTION__);
 
+	if (serial_paranoia_check (edge_serial->serial, __FUNCTION__)) {
+		return;
+	}
+
 	switch (urb->status) {
 	case 0:
 		/* success */
@@ -779,7 +797,7 @@
 
 	// process this interrupt-read even if there are no ports open
 	if (length) {
-		usb_serial_debug_data(debug, &edge_serial->serial->dev->dev, __FUNCTION__, length, data);
+		usb_serial_debug_data (__FILE__, __FUNCTION__, length, data);
 
 		if (length > 1) {
 			bytes_avail = data[0] | (data[1] << 8);
@@ -807,17 +825,19 @@
 			txCredits = data[position] | (data[position+1] << 8);
 			if (txCredits) {
 				port = edge_serial->serial->port[portNumber];
-				edge_port = usb_get_serial_port_data(port);
-				if (edge_port->open) {
-					edge_port->txCredits += txCredits;
-					dbg("%s - txcredits for port%d = %d", __FUNCTION__, portNumber, edge_port->txCredits);
-
-					/* tell the tty driver that something has changed */
-					if (edge_port->port->tty)
-						wake_up_interruptible(&edge_port->port->tty->write_wait);
+				if (port_paranoia_check (port, __FUNCTION__) == 0) {
+					edge_port = usb_get_serial_port_data(port);
+					if (edge_port->open) {
+						edge_port->txCredits += txCredits;
+						dbg("%s - txcredits for port%d = %d", __FUNCTION__, portNumber, edge_port->txCredits);
+
+						/* tell the tty driver that something has changed */
+						if (edge_port->port->tty)
+							wake_up_interruptible(&edge_port->port->tty->write_wait);
 
-					// Since we have more credit, check if more data can be sent
-					send_more_port_data(edge_serial, edge_port);
+						// Since we have more credit, check if more data can be sent
+						send_more_port_data(edge_serial, edge_port);
+					}
 				}
 			}
 			position += 2;
@@ -847,6 +867,10 @@
 
 	dbg("%s", __FUNCTION__);
 
+	if (serial_paranoia_check (edge_serial->serial, __FUNCTION__)) {
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
@@ -855,7 +879,7 @@
 	if (urb->actual_length) {
 		raw_data_length = urb->actual_length;
 
-		usb_serial_debug_data(debug, &edge_serial->serial->dev->dev, __FUNCTION__, raw_data_length, data);
+		usb_serial_debug_data (__FILE__, __FUNCTION__, raw_data_length, data);
 
 		/* decrement our rxBytes available by the number that we just got */
 		edge_serial->rxBytesAvail -= raw_data_length;
@@ -892,6 +916,10 @@
 
 	dbg("%s", __FUNCTION__);
 
+	if (port_paranoia_check (edge_port->port, __FUNCTION__)) {
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 	}
@@ -900,7 +928,12 @@
 
 	if (tty && edge_port->open) {
 		/* let the tty driver wakeup if it has a special write_wakeup function */
-		tty_wakeup(tty);
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) && tty->ldisc.write_wakeup) {
+			(tty->ldisc.write_wakeup)(tty);
+		}
+
+		/* tell the tty driver that something has changed */
+		wake_up_interruptible(&tty->write_wait);
 	}
 
 	// Release the Write URB
@@ -936,6 +969,10 @@
 	/* Free the command urb */
 	usb_free_urb (urb);
 
+	if (port_paranoia_check (edge_port->port, __FUNCTION__)) {
+		return;
+	}
+
 	if (status) {
 		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, status);
 		return;
@@ -972,6 +1009,9 @@
 	int response;
 	int timeout;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return -ENODEV;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (edge_port == NULL)
@@ -1200,45 +1240,55 @@
  *****************************************************************************/
 static void edge_close (struct usb_serial_port *port, struct file * filp)
 {
+	struct usb_serial *serial;
 	struct edgeport_serial *edge_serial;
 	struct edgeport_port *edge_port;
 	int status;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 			 
-	edge_serial = usb_get_serial_data(port->serial);
+	serial = get_usb_serial (port, __FUNCTION__);
+	if (!serial)
+		return;
+	
+	edge_serial = usb_get_serial_data(serial);
 	edge_port = usb_get_serial_port_data(port);
 	if ((edge_serial == NULL) || (edge_port == NULL))
 		return;
 	
-	// block until tx is empty
-	block_until_tx_empty(edge_port);
-
-	edge_port->closePending = TRUE;
-
-	/* flush and chase */
-	edge_port->chaseResponsePending = TRUE;
+	if (serial->dev) {
+		// block until tx is empty
+		block_until_tx_empty(edge_port);
+
+		edge_port->closePending = TRUE;
+
+		/* flush and chase */
+		edge_port->chaseResponsePending = TRUE;
+
+		dbg("%s - Sending IOSP_CMD_CHASE_PORT", __FUNCTION__);
+		status = send_iosp_ext_cmd (edge_port, IOSP_CMD_CHASE_PORT, 0);
+		if (status == 0) {
+			// block until chase finished
+			block_until_chase_response(edge_port);
+		} else {
+			edge_port->chaseResponsePending = FALSE;
+		}
 
-	dbg("%s - Sending IOSP_CMD_CHASE_PORT", __FUNCTION__);
-	status = send_iosp_ext_cmd (edge_port, IOSP_CMD_CHASE_PORT, 0);
-	if (status == 0) {
-		// block until chase finished
-		block_until_chase_response(edge_port);
-	} else {
-		edge_port->chaseResponsePending = FALSE;
-	}
+		/* close the port */
+		dbg("%s - Sending IOSP_CMD_CLOSE_PORT", __FUNCTION__);
+		send_iosp_ext_cmd (edge_port, IOSP_CMD_CLOSE_PORT, 0);
 
-	/* close the port */
-	dbg("%s - Sending IOSP_CMD_CLOSE_PORT", __FUNCTION__);
-	send_iosp_ext_cmd (edge_port, IOSP_CMD_CLOSE_PORT, 0);
-
-	//port->close = TRUE;
-	edge_port->closePending = FALSE;
-	edge_port->open = FALSE;
-	edge_port->openPending = FALSE;
+		//port->close = TRUE;
+		edge_port->closePending = FALSE;
+		edge_port->open = FALSE;
+		edge_port->openPending = FALSE;
 
-	if (edge_port->write_urb) {
-		usb_unlink_urb (edge_port->write_urb);
+		if (edge_port->write_urb) {
+			usb_unlink_urb (edge_port->write_urb);
+		}
 	}
 
 	if (edge_port->write_urb) {
@@ -1308,7 +1358,7 @@
 	} else {
 		memcpy(&fifo->fifo[fifo->head], data, firsthalf);
 	}  
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, firsthalf, &fifo->fifo[fifo->head]);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, firsthalf, &fifo->fifo[fifo->head]);
 
 	// update the index and size
 	fifo->head  += firsthalf;
@@ -1329,7 +1379,7 @@
 		} else {
 			memcpy(&fifo->fifo[fifo->head], &data[firsthalf], secondhalf);
 		}
-		usb_serial_debug_data(debug, &port->dev, __FUNCTION__, secondhalf, &fifo->fifo[fifo->head]);
+		usb_serial_debug_data (__FILE__, __FUNCTION__, secondhalf, &fifo->fifo[fifo->head]);
 		// update the index and size
 		fifo->count += secondhalf;
 		fifo->head  += secondhalf;
@@ -1384,7 +1434,7 @@
 	//	to bother queueing a write. If it's too small, say a few bytes,
 	//	it's better to wait for more credits so we can do a larger
 	//	write.
-	if (edge_port->txCredits < EDGE_FW_GET_TX_CREDITS_SEND_THRESHOLD(edge_port->maxTxCredits,EDGE_FW_BULK_MAX_PACKET_SIZE)) {
+	if (edge_port->txCredits < EDGE_FW_GET_TX_CREDITS_SEND_THRESHOLD(edge_port->maxTxCredits)) {
 		dbg("%s(%d) Not enough credit - fifo %d TxCredit %d", __FUNCTION__, edge_port->port->number, fifo->count, edge_port->txCredits );
 		return;
 	}
@@ -1405,7 +1455,7 @@
 	count = fifo->count;
 	buffer = kmalloc (count+2, GFP_ATOMIC);
 	if (buffer == NULL) {
-		dev_err(&edge_port->port->dev, "%s - no more kernel memory...\n", __FUNCTION__);
+		dev_err(&edge_serial->serial->dev->dev, "%s - no more kernel memory...\n", __FUNCTION__);
 		edge_port->write_in_progress = FALSE;
 		return;
 	}
@@ -1429,8 +1479,9 @@
 		fifo->count -= secondhalf;
 	}
 
-	if (count)
-		usb_serial_debug_data(debug, &edge_port->port->dev, __FUNCTION__, count, &buffer[2]);
+	if (count) {
+		usb_serial_debug_data (__FILE__, __FUNCTION__, count, &buffer[2]);
+	}
 
 	/* fill up the urb with all of our data and submit it */
 	usb_fill_bulk_urb (urb, edge_serial->serial->dev, 
@@ -1685,7 +1736,7 @@
  * 	    transmit holding register is empty.  This functionality
  * 	    allows an RS485 driver to be written in user space. 
  *****************************************************************************/
-static int get_lsr_info(struct edgeport_port *edge_port, unsigned int __user *value)
+static int get_lsr_info(struct edgeport_port *edge_port, unsigned int *value)
 {
 	unsigned int result = 0;
 
@@ -1700,7 +1751,7 @@
 	return 0;
 }
 
-static int get_number_bytes_avail(struct edgeport_port *edge_port, unsigned int __user *value)
+static int get_number_bytes_avail(struct edgeport_port *edge_port, unsigned int *value)
 {
 	unsigned int result = 0;
 	struct tty_struct *tty = edge_port->port->tty;
@@ -1770,7 +1821,7 @@
 	return result;
 }
 
-static int get_serial_info(struct edgeport_port *edge_port, struct serial_struct __user *retinfo)
+static int get_serial_info(struct edgeport_port *edge_port, struct serial_struct * retinfo)
 {
 	struct serial_struct tmp;
 
@@ -1792,6 +1843,7 @@
 //	tmp.hub6		= state->hub6;
 //	tmp.io_type		= state->io_type;
 
+
 	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
 		return -EFAULT;
 	return 0;
@@ -1817,17 +1869,17 @@
 		// return number of bytes available
 		case TIOCINQ:
 			dbg("%s (%d) TIOCINQ", __FUNCTION__,  port->number);
-			return get_number_bytes_avail(edge_port, (unsigned int __user *) arg);
+			return get_number_bytes_avail(edge_port, (unsigned int *) arg);
 			break;
 
 		case TIOCSERGETLSR:
 			dbg("%s (%d) TIOCSERGETLSR", __FUNCTION__,  port->number);
-			return get_lsr_info(edge_port, (unsigned int __user *) arg);
+			return get_lsr_info(edge_port, (unsigned int *) arg);
 			return 0;
 
 		case TIOCGSERIAL:
 			dbg("%s (%d) TIOCGSERIAL", __FUNCTION__,  port->number);
-			return get_serial_info(edge_port, (struct serial_struct __user *) arg);
+			return get_serial_info(edge_port, (struct serial_struct *) arg);
 
 		case TIOCSSERIAL:
 			dbg("%s (%d) TIOCSSERIAL", __FUNCTION__,  port->number);
@@ -1872,7 +1924,7 @@
 			icount.buf_overrun = cnow.buf_overrun;
 
 			dbg("%s (%d) TIOCGICOUNT RX=%d, TX=%d", __FUNCTION__,  port->number, icount.rx, icount.tx );
-			if (copy_to_user((void __user *)arg, &icount, sizeof(icount)))
+			if (copy_to_user((void *)arg, &icount, sizeof(icount)))
 				return -EFAULT;
 			return 0;
 	}
@@ -2019,22 +2071,24 @@
 				/* spit this data back into the tty driver if this port is open */
 				if (rxLen) {
 					port = edge_serial->serial->port[edge_serial->rxPort];
-					edge_port = usb_get_serial_port_data(port);
-					if (edge_port->open) {
-						tty = edge_port->port->tty;
-						if (tty) {
-							dbg("%s - Sending %d bytes to TTY for port %d", __FUNCTION__, rxLen, edge_serial->rxPort);
-							for (i = 0; i < rxLen ; ++i) {
-								/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
-								if(tty->flip.count >= TTY_FLIPBUF_SIZE) {
-									tty_flip_buffer_push(tty);
+					if (port_paranoia_check (port, __FUNCTION__) == 0) {
+        					edge_port = usb_get_serial_port_data(port);
+						if (edge_port->open) {
+							tty = edge_port->port->tty;
+							if (tty) {
+								dbg("%s - Sending %d bytes to TTY for port %d", __FUNCTION__, rxLen, edge_serial->rxPort);
+								for (i = 0; i < rxLen ; ++i) {
+									/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
+									if(tty->flip.count >= TTY_FLIPBUF_SIZE) {
+										tty_flip_buffer_push(tty);
+									}
+									/* this doesn't actually push the data through unless tty->low_latency is set */
+									tty_insert_flip_char(tty, buffer[i], 0);
 								}
-								/* this doesn't actually push the data through unless tty->low_latency is set */
-								tty_insert_flip_char(tty, buffer[i], 0);
+								tty_flip_buffer_push(tty);
 							}
-							tty_flip_buffer_push(tty);
+							edge_port->icount.rx += rxLen;
 						}
-						edge_port->icount.rx += rxLen;
 					}
 					buffer += rxLen;
 				}
@@ -2070,6 +2124,9 @@
 
 	/* switch the port pointer to the one being currently talked about */
 	port = edge_serial->serial->port[edge_serial->rxPort];
+	if (port_paranoia_check (port, __FUNCTION__)) {
+		return;
+	}
         edge_port = usb_get_serial_port_data(port);
 	if (edge_port == NULL) {
 		dev_err(&edge_serial->serial->dev->dev, "%s - edge_port == NULL for port %d\n", __FUNCTION__, edge_serial->rxPort);
@@ -2423,7 +2480,7 @@
 	struct urb *urb;
 	int timeout;
 
-	usb_serial_debug_data(debug, &edge_port->port->dev, __FUNCTION__, length, buffer);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, length, buffer);
 
 	/* Allocate our next urb */
 	urb = usb_alloc_urb (0, GFP_ATOMIC);
@@ -2742,7 +2799,7 @@
  *	ASCII range, but it's only for debugging...
  *	NOTE: expects the unicode in LE format
  ****************************************************************************/
-static void unicode_to_ascii (char *string, __le16 *unicode, int unicode_size)
+static void unicode_to_ascii (char *string, short *unicode, int unicode_size)
 {
 	int i;
 	for (i = 0; i < unicode_size; ++i) {
@@ -3002,6 +3059,9 @@
 static int __init edgeport_init(void)
 {
 	int retval;
+	retval = usb_serial_register(&edgeport_1port_device);
+	if (retval) 
+		goto failed_1port_device_register;
 	retval = usb_serial_register(&edgeport_2port_device);
 	if (retval)
 		goto failed_2port_device_register;
@@ -3023,6 +3083,8 @@
 failed_4port_device_register:
 	usb_serial_deregister(&edgeport_2port_device);
 failed_2port_device_register:
+	usb_serial_deregister(&edgeport_1port_device);
+failed_1port_device_register:
 	return retval;
 }
 
@@ -3035,6 +3097,7 @@
 static void __exit edgeport_exit (void)
 {
 	usb_deregister (&io_driver);
+	usb_serial_deregister (&edgeport_1port_device);
 	usb_serial_deregister (&edgeport_2port_device);
 	usb_serial_deregister (&edgeport_4port_device);
 	usb_serial_deregister (&edgeport_8port_device);
@@ -3048,5 +3111,6 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
+
diff -Naur linuxppc-2.6.9/drivers/usb/serial/io_edgeport.h linuxppc-2.6.9-dream/drivers/usb/serial/io_edgeport.h
--- linuxppc-2.6.9/drivers/usb/serial/io_edgeport.h	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/io_edgeport.h	2005-09-19 21:40:06.000000000 +0200
@@ -107,11 +107,11 @@
 
 	__u8	BootMajorVersion;		/* Boot Firmware version: xx. */
 	__u8	BootMinorVersion;		/*	   		  yy. */
-	__le16	BootBuildNumber;		/*		      	  zzzz (LE format) */
+	__u16	BootBuildNumber;		/*		      	  zzzz (LE format) */
 
 	__u8	FirmwareMajorVersion;		/* Operational Firmware version:xx. */
 	__u8	FirmwareMinorVersion;		/*				yy. */
-	__le16	FirmwareBuildNumber;		/*				zzzz (LE format) */
+	__u16	FirmwareBuildNumber;		/*				zzzz (LE format) */
 
 	__u8	ManufactureDescDate[3];		/* MM/DD/YY when descriptor template was compiled */
 	__u8	Unused1[1];			/* Available */
diff -Naur linuxppc-2.6.9/drivers/usb/serial/io_fw_down3.h linuxppc-2.6.9-dream/drivers/usb/serial/io_fw_down3.h
--- linuxppc-2.6.9/drivers/usb/serial/io_fw_down3.h	2004-10-18 23:55:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/io_fw_down3.h	2005-09-19 21:40:06.000000000 +0200
@@ -1,11 +1,11 @@
 //**************************************************************
 //* Edgeport Binary Image (for TI based products)
-//* Generated by TIBin2C v2.00 (watchport)
+//* Generated by TIBin2C v1.00
 //* Copyright (C) 2001 Inside Out Networks, All rights reserved.
 //**************************************************************
 
 
-static int IMAGE_SIZE = 12749;
+static int IMAGE_SIZE = 12166;
 
 struct EDGE_FIRMWARE_VERSION_INFO
 {
@@ -16,7 +16,7 @@
 
 static struct EDGE_FIRMWARE_VERSION_INFO IMAGE_VERSION_NAME =
 {
-	4, 10, 0		// Major, Minor, Build
+	4, 1, 0		// Major, Minor, Build
 
 };
 
@@ -27,20 +27,20 @@
 //      WORD    Length;
 //      BYTE    CheckSum;
 //  };
-0xca, 0x31, 
-0xa8, 
+0x83, 0x2f, 
+0x33, 
 
-0x02, 0x26, 0xfe, 0x02, 0x21, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x1e, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x1a, 0x85, 0x3f, 
-0x8c, 0x85, 0x40, 0x8a, 0xc0, 0xe0, 0xc0, 0xd0, 0xc0, 0xf0, 0xc0, 0x82, 0xc0, 0x83, 0xc0, 0x00, 
-0xc0, 0x01, 0xc0, 0x02, 0xc0, 0x03, 0xc0, 0x04, 0xc0, 0x05, 0xc0, 0x06, 0xc0, 0x07, 0xe5, 0x3e, 
-0x24, 0x08, 0xf8, 0xe6, 0x60, 0x2b, 0xe5, 0x3e, 0x24, 0x10, 0xf8, 0xa6, 0x81, 0xe5, 0x3e, 0x75, 
-0xf0, 0x21, 0xa4, 0x24, 0x05, 0xf5, 0x82, 0xe4, 0x34, 0xf8, 0xf5, 0x83, 0x78, 0x8c, 0xe5, 0x81, 
-0x04, 0xc3, 0x98, 0xf9, 0x94, 0x22, 0x40, 0x03, 0x02, 0x11, 0x94, 0xe6, 0xf0, 0x08, 0xa3, 0xd9, 
-0xfa, 0x74, 0x08, 0x25, 0x3e, 0xf8, 0x05, 0x3e, 0x08, 0xe6, 0x54, 0x80, 0x70, 0x0c, 0xe5, 0x3e, 
-0xb4, 0x07, 0xf3, 0x78, 0x08, 0x75, 0x3e, 0x00, 0x80, 0xef, 0xe5, 0x3e, 0x24, 0x10, 0xf8, 0x86, 
-0x81, 0xe5, 0x3e, 0x75, 0xf0, 0x21, 0xa4, 0x24, 0x05, 0xf5, 0x82, 0xe4, 0x34, 0xf8, 0xf5, 0x83, 
-0x78, 0x8c, 0xe5, 0x81, 0x04, 0xc3, 0x98, 0xf9, 0xe0, 0xf6, 0x08, 0xa3, 0xd9, 0xfa, 0xd0, 0x07, 
+0x02, 0x24, 0x84, 0x02, 0x1f, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x1e, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x1a, 0x85, 0x45, 
+0x8c, 0x85, 0x46, 0x8a, 0xc0, 0xe0, 0xc0, 0xd0, 0xc0, 0xf0, 0xc0, 0x82, 0xc0, 0x83, 0xc0, 0x00, 
+0xc0, 0x01, 0xc0, 0x02, 0xc0, 0x03, 0xc0, 0x04, 0xc0, 0x05, 0xc0, 0x06, 0xc0, 0x07, 0xe5, 0x44, 
+0x24, 0x08, 0xf8, 0xe6, 0x60, 0x2b, 0xe5, 0x44, 0x24, 0x10, 0xf8, 0xa6, 0x81, 0xe5, 0x44, 0x75, 
+0xf0, 0x21, 0xa4, 0x24, 0x05, 0xf5, 0x82, 0xe4, 0x34, 0xf8, 0xf5, 0x83, 0x78, 0x92, 0xe5, 0x81, 
+0x04, 0xc3, 0x98, 0xf9, 0x94, 0x22, 0x40, 0x03, 0x02, 0x11, 0x1a, 0xe6, 0xf0, 0x08, 0xa3, 0xd9, 
+0xfa, 0x74, 0x08, 0x25, 0x44, 0xf8, 0x05, 0x44, 0x08, 0xe6, 0x54, 0x80, 0x70, 0x0c, 0xe5, 0x44, 
+0xb4, 0x07, 0xf3, 0x78, 0x08, 0x75, 0x44, 0x00, 0x80, 0xef, 0xe5, 0x44, 0x24, 0x10, 0xf8, 0x86, 
+0x81, 0xe5, 0x44, 0x75, 0xf0, 0x21, 0xa4, 0x24, 0x05, 0xf5, 0x82, 0xe4, 0x34, 0xf8, 0xf5, 0x83, 
+0x78, 0x92, 0xe5, 0x81, 0x04, 0xc3, 0x98, 0xf9, 0xe0, 0xf6, 0x08, 0xa3, 0xd9, 0xfa, 0xd0, 0x07, 
 0xd0, 0x06, 0xd0, 0x05, 0xd0, 0x04, 0xd0, 0x03, 0xd0, 0x02, 0xd0, 0x01, 0xd0, 0x00, 0xd0, 0x83, 
 0xd0, 0x82, 0xd0, 0xf0, 0xd0, 0xd0, 0xd0, 0xe0, 0x32, 0x30, 0x01, 0x4d, 0x30, 0xb4, 0x48, 0x10, 
 0x00, 0x45, 0x90, 0xff, 0x08, 0xe0, 0x54, 0x20, 0xf8, 0x90, 0xff, 0x48, 0xe0, 0x54, 0x20, 0xf9, 
@@ -50,783 +50,747 @@
 0xa3, 0xe0, 0xcb, 0xf0, 0x6b, 0x60, 0x02, 0x7e, 0x04, 0x22, 0xc0, 0xe0, 0xc0, 0xd0, 0xc0, 0xf0, 
 0xc0, 0x82, 0xc0, 0x83, 0xc0, 0x00, 0xc0, 0x01, 0xc0, 0x02, 0xc0, 0x03, 0xc0, 0x04, 0xc0, 0x05, 
 0xc0, 0x06, 0xc0, 0x07, 0x90, 0xff, 0x93, 0x74, 0x01, 0xf0, 0xe5, 0x81, 0x94, 0xfd, 0x40, 0x03, 
-0x02, 0x11, 0x94, 0x85, 0x41, 0x8d, 0x85, 0x42, 0x8b, 0x74, 0xaf, 0xf5, 0x82, 0x74, 0xfa, 0xf5, 
+0x02, 0x11, 0x1a, 0x85, 0x47, 0x8d, 0x85, 0x48, 0x8b, 0x74, 0xae, 0xf5, 0x82, 0x74, 0xfa, 0xf5, 
 0x83, 0xe0, 0xb4, 0x01, 0x1b, 0xc0, 0x82, 0xc0, 0x83, 0x90, 0xff, 0x4a, 0xe0, 0x30, 0xe7, 0x2c, 
 0x90, 0xff, 0x4e, 0xe0, 0x30, 0xe7, 0x25, 0xd0, 0x83, 0xd0, 0x82, 0x74, 0x02, 0xf0, 0x80, 0x20, 
-0xb4, 0x02, 0x1d, 0xc0, 0x82, 0xc0, 0x83, 0x90, 0xff, 0x7a, 0xe0, 0x30, 0xe7, 0x05, 0x12, 0x27, 
-0x8d, 0x80, 0x09, 0xd0, 0x83, 0xd0, 0x82, 0x74, 0x03, 0xf0, 0x80, 0x04, 0xd0, 0x83, 0xd0, 0x82, 
+0xb4, 0x02, 0x1d, 0xc0, 0x82, 0xc0, 0x83, 0x90, 0xff, 0x7a, 0xe0, 0x30, 0xe7, 0x05, 0x12, 0x25, 
+0x13, 0x80, 0x09, 0xd0, 0x83, 0xd0, 0x82, 0x74, 0x03, 0xf0, 0x80, 0x04, 0xd0, 0x83, 0xd0, 0x82, 
 0xa3, 0xe0, 0xb4, 0x01, 0x1b, 0xc0, 0x82, 0xc0, 0x83, 0x90, 0xff, 0x52, 0xe0, 0x30, 0xe7, 0x2c, 
-0x90, 0xff, 0x56, 0xe0, 0x30, 0xe7, 0x25, 0xd0, 0x83, 0xd0, 0x82, 0x74, 0x02, 0xf0, 0x80, 0x25, 
-0xb4, 0x02, 0x22, 0xc0, 0x82, 0xc0, 0x83, 0x90, 0xff, 0x7a, 0xe0, 0x30, 0xe7, 0x05, 0x12, 0x27, 
-0x8d, 0x80, 0x09, 0xd0, 0x83, 0xd0, 0x82, 0x74, 0x03, 0xf0, 0x80, 0x09, 0xd0, 0x83, 0xd0, 0x82, 
-0x80, 0x03, 0x02, 0x02, 0x62, 0x74, 0x15, 0xf5, 0x82, 0x74, 0xf9, 0xf5, 0x83, 0xe0, 0x20, 0x04, 
-0xf1, 0x20, 0x02, 0x03, 0x30, 0x01, 0xeb, 0x74, 0x18, 0xf5, 0x82, 0x74, 0xf9, 0xf5, 0x83, 0xe0, 
-0x14, 0xfc, 0xf0, 0xa3, 0xe0, 0xfd, 0xa3, 0xe0, 0xfe, 0x64, 0x04, 0x70, 0x0f, 0xec, 0x70, 0x62, 
-0x7e, 0x01, 0x12, 0x00, 0xc9, 0x7c, 0x0a, 0x7d, 0xfa, 0x02, 0x02, 0x33, 0x12, 0x00, 0xc9, 0xee, 
-0x64, 0x04, 0x60, 0x1d, 0xec, 0x70, 0x4b, 0x7c, 0x0a, 0xed, 0x14, 0xfd, 0x70, 0x15, 0xee, 0x64, 
-0x02, 0x60, 0x07, 0x7e, 0x02, 0x7d, 0x32, 0x02, 0x02, 0x33, 0x7e, 0x01, 0x7d, 0xfa, 0x02, 0x02, 
-0x33, 0x7c, 0x0a, 0x74, 0x18, 0xf5, 0x82, 0x74, 0xf9, 0xf5, 0x83, 0xec, 0xf0, 0xa3, 0xed, 0xf0, 
-0xa3, 0xee, 0xf0, 0x14, 0x60, 0x18, 0x20, 0xe1, 0x0f, 0x20, 0x01, 0x06, 0xd2, 0xb1, 0xc2, 0xb0, 
-0x80, 0x10, 0xc2, 0xb1, 0xd2, 0xb0, 0x80, 0x0a, 0xc2, 0xb1, 0xc2, 0xb0, 0x80, 0x04, 0xd2, 0xb0, 
-0xd2, 0xb1, 0x78, 0x19, 0x79, 0x09, 0x7a, 0x07, 0xe7, 0x70, 0x04, 0xa6, 0x00, 0x80, 0x0b, 0xe6, 
-0x60, 0x08, 0x16, 0xe6, 0x70, 0x04, 0xe7, 0x44, 0x80, 0xf7, 0x08, 0x09, 0xda, 0xea, 0xe5, 0x3d, 
-0x60, 0x13, 0x14, 0xf5, 0x3d, 0x70, 0x0e, 0xe5, 0x3e, 0x24, 0x08, 0xf8, 0x76, 0x00, 0x12, 0x11, 
-0x0f, 0xd2, 0x8c, 0xd2, 0x8d, 0xd0, 0x07, 0xd0, 0x06, 0xd0, 0x05, 0xd0, 0x04, 0xd0, 0x03, 0xd0, 
-0x02, 0xd0, 0x01, 0xd0, 0x00, 0xd0, 0x83, 0xd0, 0x82, 0xd0, 0xf0, 0xd0, 0xd0, 0xd0, 0xe0, 0x32, 
-0x90, 0xff, 0x04, 0xe0, 0x90, 0xfa, 0xb6, 0xf0, 0x90, 0xff, 0x06, 0xe0, 0xfc, 0xa3, 0xe0, 0xfa, 
-0xec, 0xff, 0xea, 0xfe, 0xef, 0xc3, 0x94, 0x08, 0xee, 0x94, 0x01, 0x50, 0x02, 0x80, 0x04, 0x7e, 
-0x01, 0x7f, 0x08, 0x8e, 0x3b, 0x8f, 0x3c, 0x90, 0xff, 0x02, 0xe0, 0xfc, 0xa3, 0xe0, 0xfa, 0xec, 
-0xff, 0xea, 0x90, 0xfa, 0xba, 0xf0, 0xef, 0xa3, 0xf0, 0x12, 0x1c, 0x30, 0xe4, 0xf5, 0x4d, 0xe5, 
-0x4d, 0xc3, 0x94, 0x02, 0x50, 0x0f, 0x12, 0x1c, 0x11, 0xe4, 0x12, 0x1a, 0x38, 0x05, 0x4d, 0x04, 
-0x12, 0x1c, 0x02, 0x80, 0xea, 0x12, 0x1c, 0x30, 0x90, 0xff, 0x00, 0xe0, 0xff, 0x54, 0x60, 0x24, 
-0xc0, 0x70, 0x03, 0x02, 0x08, 0xc5, 0x24, 0x40, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 0xb6, 
-0xe0, 0xfe, 0x54, 0x0f, 0xf5, 0x4d, 0xee, 0x30, 0xe7, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x92, 0x0a, 
-0x90, 0xff, 0x01, 0xe0, 0x12, 0x1b, 0x4c, 0x03, 0x56, 0x00, 0x04, 0x29, 0x01, 0x05, 0x3c, 0x03, 
-0x06, 0x03, 0x05, 0x06, 0x45, 0x06, 0x07, 0xa7, 0x08, 0x07, 0xef, 0x09, 0x08, 0x4b, 0x0a, 0x08, 
-0x8b, 0x0b, 0x00, 0x00, 0x0f, 0x26, 0xe5, 0x35, 0x20, 0xe7, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 
-0xba, 0xe0, 0x70, 0x02, 0xa3, 0xe0, 0x60, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x3c, 0x64, 0x02, 0x45, 
-0x3b, 0x60, 0x03, 0x02, 0x0f, 0x26, 0xef, 0x54, 0x1f, 0x14, 0x60, 0x2b, 0x14, 0x60, 0x47, 0x24, 
-0x02, 0x60, 0x03, 0x02, 0x0f, 0x26, 0xee, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x12, 0x1c, 0x11, 0x74, 
-0x01, 0x12, 0x1a, 0x38, 0x78, 0x67, 0xe6, 0x30, 0xe0, 0x08, 0x12, 0x1c, 0x11, 0x74, 0x02, 0x12, 
-0x1a, 0x38, 0x7f, 0x02, 0x02, 0x31, 0xb1, 0xe5, 0x35, 0x20, 0xe1, 0x09, 0x90, 0xfa, 0xb6, 0xe0, 
-0x60, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 0xb6, 0xe0, 0xd3, 0x94, 0x01, 0x40, 0x03, 0x02, 0x0f, 
-0x26, 0x7f, 0x02, 0x02, 0x31, 0xb1, 0xe5, 0x35, 0x20, 0xe1, 0x0e, 0x90, 0xfa, 0xb6, 0xe0, 0xff, 
-0x60, 0x07, 0x64, 0x80, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x12, 0x0f, 0xb2, 0x40, 0x03, 0x02, 0x0f, 
-0x26, 0xe5, 0x4d, 0x70, 0x19, 0x30, 0x0a, 0x0b, 0x90, 0xff, 0x80, 0x12, 0x1c, 0x0e, 0x12, 0x1a, 
-0x38, 0x80, 0x24, 0x90, 0xff, 0x82, 0x12, 0x1c, 0x0e, 0x12, 0x1a, 0x38, 0x80, 0x19, 0x15, 0x4d, 
-0x30, 0x0a, 0x0b, 0x12, 0x1c, 0xa5, 0x12, 0x1c, 0x0c, 0x12, 0x1a, 0x38, 0x80, 0x09, 0x12, 0x1c, 
-0xb3, 0x12, 0x1c, 0x0c, 0x12, 0x1a, 0x38, 0x12, 0x1c, 0x11, 0x12, 0x19, 0xf2, 0x60, 0x05, 0x74, 
-0x01, 0x12, 0x1a, 0x38, 0x7f, 0x02, 0x02, 0x31, 0xb1, 0xe5, 0x35, 0x30, 0xe7, 0x03, 0x02, 0x0f, 
-0x26, 0xe5, 0x3c, 0x45, 0x3b, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x12, 0x1c, 0xc9, 0x14, 0x60, 0x2d, 
-0x14, 0x60, 0x59, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 0xba, 0xe0, 0x70, 0x04, 
-0xa3, 0xe0, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x03, 0x02, 
-0x0f, 0x26, 0x78, 0x67, 0xe6, 0x54, 0xfe, 0xf6, 0xe4, 0xff, 0x02, 0x31, 0xb1, 0xe5, 0x35, 0x20, 
-0xe1, 0x06, 0x20, 0xe0, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x35, 0x30, 0xe0, 0x09, 0x90, 0xfa, 0xb6, 
-0xe0, 0x60, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x35, 0x30, 0xe1, 0x0c, 0x90, 0xfa, 0xb6, 0xe0, 0xd3, 
-0x94, 0x01, 0x40, 0x03, 0x02, 0x0f, 0x26, 0xe4, 0xff, 0x02, 0x31, 0xb1, 0x90, 0xfa, 0xba, 0xe0, 
-0x70, 0x02, 0xa3, 0xe0, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x12, 0x0f, 0xb2, 0x40, 0x03, 0x02, 0x0f, 
-0x26, 0xe5, 0x35, 0x20, 0xe1, 0x06, 0x20, 0xe0, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x35, 0x30, 0xe0, 
-0x07, 0xe5, 0x4d, 0x60, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x4d, 0x70, 0x0f, 0x90, 0xff, 0x82, 0xe0, 
-0x54, 0xf7, 0xf0, 0x90, 0xff, 0x80, 0xe0, 0x54, 0xf7, 0xf0, 0x22, 0xe5, 0x4d, 0x24, 0xfe, 0x60, 
-0x20, 0x24, 0xfb, 0x60, 0x34, 0x24, 0x06, 0x70, 0x35, 0x30, 0x0a, 0x0c, 0xa2, 0x0a, 0xe4, 0x33, 
-0xfd, 0x7f, 0x03, 0x12, 0x2d, 0xa8, 0x80, 0x26, 0xe4, 0xfd, 0x7f, 0x03, 0x12, 0x2d, 0xa8, 0x80, 
-0x1d, 0x30, 0x0a, 0x0c, 0xa2, 0x0a, 0xe4, 0x33, 0xfd, 0x7f, 0x04, 0x12, 0x2d, 0xa8, 0x80, 0x0e, 
-0xe4, 0xfd, 0x7f, 0x04, 0x12, 0x2d, 0xa8, 0x80, 0x05, 0x7f, 0x87, 0x12, 0x31, 0x32, 0x15, 0x4d, 
-0x30, 0x0a, 0x0b, 0x12, 0x1c, 0xa5, 0xf5, 0x83, 0xe0, 0x54, 0xf7, 0xf0, 0x80, 0x09, 0x12, 0x1c, 
-0xb3, 0xf5, 0x83, 0xe0, 0x54, 0xf7, 0xf0, 0xe4, 0xff, 0x02, 0x31, 0xb1, 0xe5, 0x35, 0x30, 0xe7, 
-0x03, 0x02, 0x0f, 0x26, 0xe5, 0x3c, 0x45, 0x3b, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x12, 0x1c, 0xc9, 
-0x14, 0x60, 0x2d, 0x14, 0x60, 0x55, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 0xba, 
-0xe0, 0x70, 0x04, 0xa3, 0xe0, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 0xb6, 0xe0, 
-0x60, 0x03, 0x02, 0x0f, 0x26, 0x78, 0x67, 0xe6, 0x44, 0x01, 0xf6, 0xe4, 0xff, 0x02, 0x31, 0xb1, 
-0xe5, 0x35, 0x20, 0xe1, 0x06, 0x20, 0xe0, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x35, 0x30, 0xe0, 0x07, 
-0xe5, 0x4d, 0x60, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x35, 0x30, 0xe1, 0x0a, 0xe5, 0x4d, 0xd3, 0x94, 
-0x01, 0x40, 0x03, 0x02, 0x0f, 0x26, 0xe4, 0xff, 0x02, 0x31, 0xb1, 0x90, 0xfa, 0xba, 0xe0, 0x70, 
-0x02, 0xa3, 0xe0, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 0xb6, 0xe0, 0xff, 0x12, 0x31, 0x82, 
-0x40, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x35, 0x20, 0xe1, 0x06, 0x20, 0xe0, 0x03, 0x02, 0x0f, 0x26, 
-0xe5, 0x4d, 0x70, 0x09, 0x30, 0x0a, 0x03, 0x02, 0x1d, 0x64, 0x02, 0x1d, 0x2f, 0xe5, 0x35, 0x20, 
-0xe1, 0x03, 0x02, 0x0f, 0x26, 0x15, 0x4d, 0x30, 0x0a, 0x0b, 0x12, 0x1c, 0xa5, 0xf5, 0x83, 0xe0, 
-0x44, 0x08, 0xf0, 0x80, 0x09, 0x12, 0x1c, 0xb3, 0xf5, 0x83, 0xe0, 0x44, 0x08, 0xf0, 0xe4, 0xff, 
-0x02, 0x31, 0xb1, 0xe5, 0x35, 0x30, 0xe7, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x3c, 0x45, 0x3b, 0x60, 
-0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x12, 0x1c, 0xc9, 
-0x60, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x35, 0x30, 0xe1, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 0xbb, 
-0xe0, 0x90, 0xff, 0xff, 0xf0, 0xe0, 0x60, 0x05, 0x43, 0x35, 0x01, 0x80, 0x03, 0x53, 0x35, 0xfe, 
-0xe4, 0xff, 0x02, 0x31, 0xb1, 0xe5, 0x35, 0x20, 0xe7, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x3c, 0x45, 
-0x3b, 0x70, 0x03, 0x02, 0x0f, 0x26, 0x12, 0x1c, 0xc9, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 
-0xba, 0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0xec, 0x24, 0xfe, 0x60, 0x3a, 0x14, 0x60, 0x75, 0x24, 0x02, 
-0x60, 0x03, 0x02, 0x0f, 0x26, 0xed, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x12, 0x1c, 0x30, 0x12, 0x1d, 
-0x5d, 0x7d, 0x03, 0x12, 0x0f, 0x6d, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x12, 0x0f, 0x2a, 0x90, 0xfa, 
-0xb3, 0xe0, 0xfd, 0xa3, 0x12, 0x1c, 0x7b, 0x12, 0x0f, 0x89, 0x50, 0x02, 0x80, 0x04, 0xae, 0x3b, 
-0xaf, 0x3c, 0x02, 0x0f, 0xba, 0x12, 0x1c, 0x30, 0x90, 0xf9, 0x15, 0xe0, 0x30, 0xe4, 0x0d, 0x12, 
-0x1d, 0x5d, 0x7d, 0x14, 0x12, 0x0f, 0x6d, 0x60, 0x10, 0x02, 0x0f, 0x26, 0x12, 0x1d, 0x5d, 0x7d, 
-0x04, 0x12, 0x0f, 0xc1, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x12, 0x0f, 0x2a, 0x90, 0xfa, 0xb3, 0xe0, 
-0xfd, 0xa3, 0x12, 0x1c, 0x7b, 0x12, 0x0f, 0x89, 0x50, 0x02, 0x80, 0x04, 0xae, 0x3b, 0xaf, 0x3c, 
-0x02, 0x0f, 0xba, 0x12, 0x1d, 0x5d, 0x7d, 0x05, 0x12, 0x0f, 0xc1, 0x60, 0x03, 0x02, 0x0f, 0x26, 
-0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xb3, 0x12, 0x1c, 0x78, 0x7d, 0x01, 0x12, 0x25, 0xd7, 0x90, 0xfa, 
-0xb4, 0xe4, 0x75, 0xf0, 0x03, 0x12, 0x1a, 0x6c, 0x90, 0xfa, 0xbb, 0xe0, 0x90, 0xfa, 0xb2, 0xf0, 
-0xe4, 0xf5, 0x4c, 0x90, 0xfa, 0xb2, 0xe0, 0xff, 0xe5, 0x4c, 0xc3, 0x9f, 0x50, 0x24, 0x12, 0x1c, 
-0x72, 0x12, 0x0f, 0xcc, 0xff, 0xfd, 0x90, 0xfa, 0xb4, 0xe4, 0x8d, 0xf0, 0x12, 0x1a, 0x6c, 0x90, 
-0xfa, 0xb3, 0xe0, 0xc3, 0x9f, 0xf0, 0xd3, 0x94, 0x00, 0x50, 0x03, 0x02, 0x0f, 0x26, 0x05, 0x4c, 
-0x80, 0xd1, 0x12, 0x1c, 0x72, 0x12, 0x0f, 0xcc, 0x24, 0xfe, 0xff, 0x90, 0xfa, 0xb3, 0xf0, 0xfd, 
-0xa3, 0xe4, 0x75, 0xf0, 0x02, 0x12, 0x1a, 0x6c, 0x7a, 0xf9, 0x79, 0x6f, 0x7b, 0x01, 0x8b, 0x36, 
-0x8a, 0x37, 0x89, 0x38, 0xe9, 0x24, 0x02, 0xf9, 0xe4, 0x3a, 0xfa, 0x12, 0x1c, 0x78, 0x12, 0x25, 
-0xd7, 0x8f, 0x4c, 0x05, 0x4c, 0x05, 0x4c, 0x12, 0x1c, 0x11, 0xe5, 0x4c, 0x12, 0x1a, 0x38, 0x12, 
-0x1c, 0x11, 0x90, 0x00, 0x01, 0x74, 0x03, 0x12, 0x1a, 0x4a, 0xaf, 0x4c, 0x7e, 0x00, 0xc3, 0xef, 
-0x95, 0x3c, 0xee, 0x95, 0x3b, 0x50, 0x02, 0x80, 0x04, 0xae, 0x3b, 0xaf, 0x3c, 0x8e, 0x39, 0x8f, 
-0x3a, 0x02, 0x2c, 0x07, 0x02, 0x0f, 0x26, 0xe5, 0x35, 0x20, 0xe7, 0x03, 0x02, 0x0f, 0x26, 0xe5, 
-0x3c, 0x64, 0x01, 0x45, 0x3b, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x03, 
-0x02, 0x0f, 0x26, 0x90, 0xfa, 0xba, 0xe0, 0x70, 0x02, 0xa3, 0xe0, 0x60, 0x03, 0x02, 0x0f, 0x26, 
-0x12, 0x1c, 0xc9, 0x60, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x35, 0x20, 0xe0, 0x06, 0x20, 0xe1, 0x03, 
-0x02, 0x0f, 0x26, 0x75, 0x36, 0x00, 0x75, 0x37, 0x00, 0x75, 0x38, 0x32, 0x02, 0x0f, 0xa9, 0xe5, 
-0x35, 0x30, 0xe7, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x3c, 0x45, 0x3b, 0x60, 0x03, 0x02, 0x0f, 0x26, 
-0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x03, 0x02, 0x0f, 0x26, 0xd3, 0x90, 0xfa, 0xbb, 0xe0, 0x94, 0x01, 
-0x90, 0xfa, 0xba, 0xe0, 0x94, 0x00, 0x40, 0x03, 0x02, 0x0f, 0x26, 0x12, 0x1c, 0xc9, 0x60, 0x03, 
-0x02, 0x0f, 0x26, 0xe5, 0x35, 0x20, 0xe0, 0x06, 0x20, 0xe1, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 
-0xbb, 0xe0, 0xf5, 0x32, 0xe5, 0x32, 0x70, 0x08, 0x43, 0x35, 0x01, 0x53, 0x35, 0xfd, 0x80, 0x06, 
-0x53, 0x35, 0xfe, 0x43, 0x35, 0x02, 0xe4, 0xff, 0x02, 0x31, 0xb1, 0xe5, 0x35, 0x20, 0xe7, 0x03, 
-0x02, 0x0f, 0x26, 0xe5, 0x3c, 0x64, 0x01, 0x45, 0x3b, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 
-0xb6, 0xe0, 0x60, 0x03, 0x02, 0x0f, 0x26, 0x90, 0xfa, 0xba, 0xe0, 0x70, 0x02, 0xa3, 0xe0, 0x60, 
-0x03, 0x02, 0x0f, 0x26, 0x12, 0x1c, 0xc9, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x35, 
-0x20, 0xe1, 0x03, 0x02, 0x0f, 0x26, 0x7f, 0x01, 0x02, 0x31, 0xb1, 0xe5, 0x35, 0x30, 0xe7, 0x03, 
-0x02, 0x0f, 0x26, 0xe5, 0x3c, 0x45, 0x3b, 0x60, 0x03, 0x02, 0x0f, 0x26, 0xd3, 0x90, 0xfa, 0xbb, 
-0xe0, 0x94, 0x00, 0x90, 0xfa, 0xba, 0xe0, 0x94, 0x00, 0x40, 0x03, 0x02, 0x0f, 0x26, 0x12, 0x1c, 
-0xc9, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0f, 0x26, 0xe5, 0x35, 0x20, 0xe1, 0x03, 0x02, 0x0f, 0x26, 
-0xe4, 0xff, 0x02, 0x31, 0xb1, 0x90, 0xff, 0x01, 0x12, 0x1d, 0x74, 0xef, 0x12, 0x1a, 0x38, 0x90, 
-0xfa, 0xb6, 0x12, 0x1d, 0x74, 0x90, 0x00, 0x01, 0xef, 0x12, 0x1a, 0x4a, 0x90, 0x00, 0x02, 0xe4, 
-0x12, 0x1a, 0x4a, 0x74, 0x03, 0x12, 0x1c, 0x02, 0x90, 0xfa, 0xba, 0xe0, 0xff, 0xa3, 0xe0, 0x85, 
-0x38, 0x82, 0x85, 0x37, 0x83, 0xcf, 0xf0, 0xa3, 0xef, 0xf0, 0x90, 0xff, 0x01, 0xe0, 0x12, 0x1b, 
-0x4c, 0x09, 0x4a, 0x02, 0x09, 0x6c, 0x04, 0x09, 0x8e, 0x05, 0x09, 0xba, 0x06, 0x09, 0xd8, 0x07, 
-0x09, 0xf6, 0x08, 0x0a, 0x14, 0x09, 0x0a, 0x32, 0x0b, 0x0a, 0xe7, 0x80, 0x0d, 0x6f, 0x81, 0x0d, 
-0xa0, 0x82, 0x0b, 0x2e, 0x83, 0x0b, 0x77, 0x84, 0x0b, 0x96, 0x85, 0x0b, 0xdb, 0x86, 0x0c, 0x26, 
-0x87, 0x0c, 0xb7, 0x88, 0x0d, 0x42, 0x89, 0x0a, 0x50, 0x92, 0x0a, 0x50, 0x93, 0x0e, 0x53, 0xc0, 
-0x0e, 0x7f, 0xc1, 0x0e, 0x90, 0xc2, 0x00, 0x00, 0x0f, 0x15, 0xe5, 0x35, 0x20, 0xe7, 0x05, 0x7f, 
-0x05, 0x02, 0x30, 0xec, 0x12, 0x1c, 0xc1, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 
-0x7f, 0x07, 0x02, 0x11, 0x16, 0xe4, 0xfd, 0x7f, 0x07, 0x02, 0x2f, 0x18, 0xe5, 0x35, 0x20, 0xe7, 
-0x05, 0x7f, 0x05, 0x02, 0x30, 0xec, 0x12, 0x1c, 0xc1, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 
-0x7c, 0x00, 0x7f, 0x0c, 0x02, 0x11, 0x16, 0xe4, 0xfd, 0x7f, 0x07, 0x02, 0x2f, 0x18, 0xe5, 0x35, 
-0x30, 0xe7, 0x03, 0x02, 0x0f, 0x29, 0x12, 0x1d, 0x92, 0x50, 0x06, 0xe5, 0x3c, 0x45, 0x3b, 0x70, 
-0x05, 0x7f, 0x02, 0x02, 0x30, 0xec, 0x90, 0xfa, 0xb6, 0xe0, 0x24, 0xfe, 0x24, 0xfd, 0x50, 0x02, 
-0x80, 0x03, 0x02, 0x31, 0x6f, 0x7f, 0x07, 0x02, 0x30, 0xec, 0xe5, 0x35, 0x30, 0xe7, 0x03, 0x02, 
-0x0f, 0x29, 0x12, 0x1c, 0xc1, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x08, 
-0x02, 0x11, 0x16, 0x7f, 0x07, 0x02, 0x30, 0xec, 0xe5, 0x35, 0x30, 0xe7, 0x03, 0x02, 0x0f, 0x29, 
-0x12, 0x1c, 0xc1, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x09, 0x02, 0x11, 
-0x16, 0x7f, 0x07, 0x02, 0x30, 0xec, 0xe5, 0x35, 0x30, 0xe7, 0x03, 0x02, 0x0f, 0x29, 0x12, 0x1c, 
-0xc1, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0a, 0x02, 0x11, 0x16, 0x7f, 
-0x07, 0x02, 0x30, 0xec, 0xe5, 0x35, 0x30, 0xe7, 0x03, 0x02, 0x0f, 0x29, 0x12, 0x1c, 0xc1, 0x60, 
-0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0b, 0x02, 0x11, 0x16, 0x7f, 0x07, 0x02, 
-0x30, 0xec, 0xe5, 0x35, 0x30, 0xe7, 0x03, 0x02, 0x0f, 0x29, 0x12, 0x1c, 0xc1, 0x60, 0x03, 0x04, 
-0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0e, 0x02, 0x11, 0x16, 0x7f, 0x07, 0x02, 0x30, 0xec, 
-0xe5, 0x35, 0x30, 0xe7, 0x56, 0x12, 0x1c, 0xc9, 0x70, 0x4a, 0x90, 0xff, 0x02, 0xe0, 0xf5, 0x4c, 
-0xe5, 0x4c, 0xb4, 0x82, 0x05, 0x75, 0x4c, 0x61, 0x80, 0x12, 0xe5, 0x4c, 0xb4, 0x83, 0x05, 0x75, 
-0x4c, 0x62, 0x80, 0x08, 0xe5, 0x4c, 0xc4, 0x54, 0xf0, 0x04, 0xf5, 0x4c, 0x12, 0x1b, 0x72, 0x12, 
-0x1d, 0x8b, 0x12, 0x25, 0x39, 0x12, 0x1c, 0xd9, 0x12, 0x1a, 0x0b, 0x60, 0x05, 0x12, 0x31, 0xbd, 
-0x80, 0x06, 0x85, 0x33, 0x39, 0x85, 0x34, 0x3a, 0x75, 0x36, 0x01, 0x75, 0x37, 0xf9, 0x75, 0x38, 
-0x72, 0x02, 0x2c, 0x07, 0xe4, 0xfd, 0x7f, 0x05, 0x02, 0x2f, 0x18, 0x12, 0x1c, 0xc9, 0x60, 0x05, 
-0x7f, 0x05, 0x02, 0x30, 0xec, 0x12, 0x1d, 0x92, 0x40, 0x05, 0x7f, 0x03, 0x02, 0x30, 0xec, 0x90, 
-0xff, 0x02, 0xe0, 0xf5, 0x4c, 0xe5, 0x4c, 0xb4, 0x82, 0x05, 0x75, 0x4c, 0x61, 0x80, 0x12, 0xe5, 
-0x4c, 0xb4, 0x83, 0x05, 0x75, 0x4c, 0x62, 0x80, 0x08, 0xe5, 0x4c, 0xc4, 0x54, 0xf0, 0x04, 0xf5, 
-0x4c, 0x12, 0x1b, 0x72, 0x02, 0x31, 0x6f, 0x12, 0x1d, 0x9c, 0x12, 0x2a, 0x06, 0x12, 0x1c, 0x83, 
-0xe0, 0x54, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0xe0, 0x90, 0xfa, 0xb7, 0xf0, 0x78, 0x68, 0x12, 0x1b, 
-0x28, 0x90, 0x00, 0x02, 0x12, 0x1a, 0x0b, 0x30, 0xe7, 0xf2, 0x90, 0x00, 0x02, 0xe4, 0x12, 0x1a, 
-0x4a, 0x90, 0xfa, 0xb7, 0xe0, 0x44, 0x80, 0xff, 0xf0, 0x78, 0x7c, 0xe6, 0xfc, 0x08, 0xe6, 0x8c, 
-0x83, 0x12, 0x1c, 0x8b, 0xef, 0xf0, 0x12, 0x31, 0xc7, 0xe4, 0xff, 0x02, 0x30, 0xec, 0x90, 0xfa, 
-0xb6, 0xe0, 0x64, 0x01, 0x70, 0x1f, 0x90, 0xfa, 0xba, 0xe0, 0xff, 0x7e, 0x00, 0x70, 0x06, 0xa3, 
-0xe0, 0xf5, 0x90, 0x80, 0x2d, 0xc2, 0xaf, 0xef, 0xf4, 0x52, 0x90, 0x90, 0xfa, 0xbb, 0xe0, 0x42, 
-0x90, 0xd2, 0xaf, 0x80, 0x1d, 0x90, 0xfa, 0xba, 0xe0, 0xff, 0x7e, 0x00, 0x70, 0x06, 0xa3, 0xe0, 
-0xf5, 0xb0, 0x80, 0x0e, 0xc2, 0xaf, 0xef, 0xf4, 0x52, 0xb0, 0x90, 0xfa, 0xbb, 0xe0, 0x42, 0xb0, 
-0xd2, 0xaf, 0xe4, 0xff, 0x02, 0x30, 0xec, 0x12, 0x1c, 0x30, 0x90, 0xfa, 0xb6, 0xe0, 0xb4, 0x01, 
-0x0a, 0x12, 0x1c, 0x11, 0xe5, 0x90, 0x12, 0x1a, 0x38, 0x80, 0x08, 0x12, 0x1c, 0x11, 0xe5, 0xb0, 
-0x12, 0x1a, 0x38, 0x02, 0x0f, 0xa9, 0x90, 0xfa, 0xb6, 0xe0, 0xff, 0x24, 0x12, 0x12, 0x1c, 0x41, 
-0x20, 0xe1, 0x33, 0x12, 0x1c, 0xd0, 0xef, 0x24, 0xfc, 0x60, 0x18, 0x04, 0x70, 0x28, 0x90, 0xfa, 
-0xb7, 0xe0, 0x60, 0x09, 0x90, 0xff, 0xa4, 0xe0, 0x44, 0x10, 0xf0, 0x80, 0x19, 0x12, 0x1d, 0xa6, 
-0xf0, 0x80, 0x13, 0x90, 0xfa, 0xb7, 0xe0, 0x60, 0x09, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x10, 0xf0, 
-0x80, 0x04, 0x12, 0x1d, 0xad, 0xf0, 0xe4, 0xff, 0x02, 0x30, 0xec, 0x90, 0xfa, 0xb6, 0xe0, 0xff, 
-0x24, 0x12, 0x12, 0x1c, 0x41, 0x20, 0xe1, 0x39, 0x12, 0x1c, 0xd0, 0xef, 0x24, 0xfc, 0x60, 0x1b, 
-0x04, 0x70, 0x2e, 0x90, 0xfa, 0xb7, 0xe0, 0x60, 0x09, 0x90, 0xff, 0xa4, 0xe0, 0x44, 0x20, 0xf0, 
-0x80, 0x1f, 0x90, 0xff, 0xa4, 0xe0, 0x54, 0xdf, 0xf0, 0x80, 0x16, 0x90, 0xfa, 0xb7, 0xe0, 0x60, 
-0x09, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x07, 0x90, 0xff, 0xb4, 0xe0, 0x54, 0xdf, 
-0xf0, 0xe4, 0xff, 0x02, 0x30, 0xec, 0x12, 0x1c, 0xd0, 0x12, 0x1c, 0xc1, 0x60, 0x4d, 0x04, 0x60, 
-0x03, 0x02, 0x0c, 0xb2, 0x90, 0xfa, 0xb7, 0xe0, 0x60, 0x0f, 0x90, 0xff, 0xa4, 0x12, 0x1c, 0x3a, 
-0x30, 0xe1, 0x6f, 0x12, 0x1d, 0x7c, 0x02, 0x0c, 0xb2, 0x90, 0xff, 0xa4, 0xe0, 0x54, 0xfb, 0x12, 
-0x1c, 0x3d, 0xfe, 0x30, 0xe1, 0x5c, 0x30, 0xe2, 0x11, 0x30, 0xb4, 0x05, 0x12, 0x1d, 0x7c, 0x80, 
-0x51, 0x90, 0xff, 0xa4, 0xe0, 0x54, 0xfd, 0xf0, 0x80, 0x48, 0x30, 0x95, 0x05, 0x12, 0x1d, 0x7c, 
-0x80, 0x40, 0x90, 0xff, 0xa4, 0xe0, 0x54, 0xfd, 0xf0, 0x80, 0x37, 0x90, 0xfa, 0xb7, 0xe0, 0x60, 
-0x12, 0x90, 0xff, 0xb4, 0x12, 0x1c, 0x3a, 0x30, 0xe1, 0x28, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x02, 
-0xf0, 0x80, 0x1f, 0x90, 0xff, 0xb4, 0xe0, 0x54, 0xfb, 0x12, 0x1c, 0x3d, 0x30, 0xe1, 0x13, 0x30, 
-0x93, 0x09, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x80, 0x07, 0x90, 0xff, 0xb4, 0xe0, 0x54, 
-0xfd, 0xf0, 0xe4, 0xff, 0x02, 0x30, 0xec, 0x12, 0x1c, 0xd0, 0x90, 0xfa, 0xb6, 0xe0, 0x24, 0xfc, 
-0x60, 0x40, 0x04, 0x70, 0x78, 0x90, 0xfa, 0xb7, 0xe0, 0x60, 0x1d, 0x90, 0xff, 0xa2, 0xe0, 0x44, 
-0x40, 0xf0, 0xa3, 0xe0, 0xff, 0x30, 0xe7, 0x65, 0xd2, 0x03, 0xa3, 0xe0, 0x54, 0xdf, 0xf0, 0x90, 
-0xff, 0xa3, 0xef, 0x54, 0x7f, 0xf0, 0x80, 0x55, 0x30, 0x03, 0x0e, 0x90, 0xff, 0xa3, 0xe0, 0x44, 
-0x80, 0xf0, 0xc2, 0x03, 0xa3, 0xe0, 0x44, 0x20, 0xf0, 0x90, 0xff, 0xa2, 0xe0, 0x54, 0xbf, 0xf0, 
-0x80, 0x3b, 0x90, 0xfa, 0xb7, 0xe0, 0x60, 0x1d, 0x90, 0xff, 0xb2, 0xe0, 0x44, 0x40, 0xf0, 0xa3, 
-0xe0, 0xff, 0x30, 0xe7, 0x28, 0xd2, 0x04, 0xa3, 0xe0, 0x54, 0xdf, 0xf0, 0x90, 0xff, 0xb3, 0xef, 
-0x54, 0x7f, 0xf0, 0x80, 0x18, 0x30, 0x04, 0x0e, 0x90, 0xff, 0xb3, 0xe0, 0x44, 0x80, 0xf0, 0xc2, 
-0x04, 0xa3, 0xe0, 0x44, 0x20, 0xf0, 0x90, 0xff, 0xb2, 0xe0, 0x54, 0xbf, 0xf0, 0xe4, 0xff, 0x02, 
-0x30, 0xec, 0x12, 0x1c, 0x30, 0x90, 0xfa, 0xb6, 0xe0, 0x24, 0xfc, 0x60, 0x0f, 0x04, 0x70, 0x16, 
-0x90, 0xff, 0xa6, 0xe0, 0x12, 0x1c, 0x11, 0x12, 0x1a, 0x38, 0x80, 0x0a, 0x90, 0xff, 0xb6, 0xe0, 
-0x12, 0x1c, 0x11, 0x12, 0x1a, 0x38, 0x75, 0x39, 0x00, 0x75, 0x3a, 0x01, 0x02, 0x2c, 0x07, 0xe4, 
-0xff, 0x12, 0x30, 0xec, 0x12, 0x1d, 0x37, 0x7f, 0x03, 0x12, 0x12, 0x19, 0x90, 0xf9, 0x15, 0xe0, 
-0x30, 0xe4, 0x08, 0x90, 0xff, 0x93, 0x74, 0x80, 0xf0, 0x80, 0x10, 0x90, 0xff, 0xfc, 0xe0, 0x54, 
-0x7f, 0xf0, 0x7f, 0xff, 0x7e, 0x00, 0x12, 0x30, 0x16, 0xc2, 0x90, 0xc2, 0xaf, 0x00, 0x80, 0xfd, 
-0xe4, 0xf5, 0x4e, 0xf5, 0x4f, 0x90, 0xfa, 0xbc, 0x74, 0x3e, 0xf0, 0xa3, 0xe4, 0xf0, 0x90, 0xfa, 
-0xb4, 0xf0, 0xa3, 0x74, 0x15, 0xf0, 0xe0, 0x54, 0x3f, 0xff, 0xc3, 0x74, 0x40, 0x9f, 0x90, 0xfa, 
-0xb9, 0xf0, 0xd3, 0x94, 0x00, 0xe4, 0x94, 0x3e, 0x40, 0x08, 0x90, 0xfa, 0xbd, 0xe0, 0x90, 0xfa, 
-0xb9, 0xf0, 0x12, 0x0f, 0x50, 0xe5, 0x31, 0x45, 0x30, 0x70, 0x73, 0x12, 0x1c, 0x4a, 0x90, 0xfa, 
-0xbc, 0x12, 0x1d, 0x56, 0x60, 0x27, 0xd3, 0xef, 0x94, 0x40, 0xee, 0x94, 0x00, 0x40, 0x08, 0x90, 
-0xfa, 0xb9, 0x74, 0x40, 0xf0, 0x80, 0x08, 0x90, 0xfa, 0xbd, 0xe0, 0x90, 0xfa, 0xb9, 0xf0, 0x12, 
-0x0f, 0x50, 0xe5, 0x31, 0x45, 0x30, 0x70, 0x46, 0x12, 0x1c, 0x4a, 0x80, 0xd1, 0x75, 0x4c, 0x02, 
-0x90, 0xfa, 0xbc, 0xe4, 0xf0, 0xa3, 0x04, 0xf0, 0x90, 0xfa, 0xb4, 0xe4, 0xf0, 0xa3, 0x74, 0x0f, 
-0xf0, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x4c, 0x90, 0xfa, 0xbd, 0xe0, 0xf5, 0x4a, 0x7d, 0x0f, 0x7c, 
-0x00, 0x12, 0x28, 0x9f, 0x75, 0x30, 0x00, 0x8f, 0x31, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x4c, 0xe4, 
-0xf5, 0x2d, 0xf5, 0x2e, 0x7d, 0x01, 0x12, 0x25, 0xd7, 0xe4, 0xf5, 0x30, 0xf5, 0x31, 0xaf, 0x31, 
-0x02, 0x30, 0xec, 0x12, 0x1c, 0xd0, 0x30, 0xe7, 0x10, 0xe0, 0x54, 0x0f, 0x90, 0xf9, 0x64, 0xf0, 
-0xd3, 0x94, 0x00, 0x40, 0x15, 0xc2, 0x95, 0x80, 0x11, 0x90, 0xfa, 0xb7, 0xe0, 0x54, 0x0f, 0x90, 
-0xf9, 0x63, 0xf0, 0xd3, 0x94, 0x00, 0x40, 0x02, 0xc2, 0x94, 0xe4, 0xff, 0x02, 0x30, 0xec, 0x12, 
-0x1d, 0x9c, 0xbf, 0x01, 0x04, 0xd2, 0x93, 0x80, 0x02, 0xc2, 0x93, 0xe4, 0xff, 0x02, 0x30, 0xec, 
-0x12, 0x1c, 0xd0, 0x54, 0x03, 0x14, 0x60, 0x0a, 0x14, 0x60, 0x0f, 0x14, 0x60, 0x08, 0x24, 0x03, 
-0x70, 0x2b, 0xd2, 0x91, 0x80, 0x27, 0xc2, 0x91, 0x80, 0x23, 0x12, 0x1d, 0xa6, 0x12, 0x0f, 0x78, 
-0x60, 0x04, 0xd2, 0x91, 0x80, 0x17, 0x90, 0xff, 0xa4, 0xe0, 0x44, 0x10, 0x12, 0x0f, 0x78, 0xff, 
-0xbf, 0xa0, 0x04, 0xc2, 0x91, 0x80, 0x02, 0xd2, 0x91, 0x12, 0x1d, 0xa6, 0xf0, 0x90, 0xfa, 0xb7, 
-0xe0, 0x54, 0x0c, 0xff, 0x13, 0x13, 0x54, 0x3f, 0x14, 0x60, 0x0a, 0x14, 0x60, 0x0f, 0x14, 0x60, 
-0x08, 0x24, 0x03, 0x70, 0x2b, 0xd2, 0x92, 0x80, 0x27, 0xc2, 0x92, 0x80, 0x23, 0x12, 0x1d, 0xad, 
-0x12, 0x0f, 0x98, 0x60, 0x04, 0xd2, 0x92, 0x80, 0x17, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x10, 0x12, 
-0x0f, 0x98, 0xff, 0xbf, 0xa0, 0x04, 0xc2, 0x92, 0x80, 0x02, 0xd2, 0x92, 0x12, 0x1d, 0xad, 0xf0, 
-0xe4, 0xff, 0x02, 0x30, 0xec, 0xe5, 0x35, 0x30, 0xe7, 0x07, 0xe4, 0xfd, 0x7f, 0x05, 0x02, 0x2f, 
-0x18, 0x7f, 0x05, 0x02, 0x30, 0xec, 0x12, 0x31, 0xbd, 0x22, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xb3, 
-0x90, 0xfa, 0xb4, 0xe0, 0xf5, 0x2d, 0xa3, 0xe0, 0xf5, 0x2e, 0x7d, 0x01, 0x12, 0x25, 0xd7, 0x90, 
-0xfa, 0xb4, 0xe4, 0x75, 0xf0, 0x03, 0x12, 0x1a, 0x6c, 0xab, 0x36, 0xaa, 0x37, 0xa9, 0x38, 0x22, 
-0xaa, 0x4e, 0xa9, 0x4f, 0x7b, 0xff, 0x90, 0xfa, 0xb4, 0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0x90, 0xfa, 
-0xb9, 0xe0, 0xf5, 0x4a, 0x12, 0x28, 0x9f, 0x75, 0x30, 0x00, 0x8f, 0x31, 0x22, 0x12, 0x22, 0xa0, 
-0x7e, 0x00, 0x8e, 0x30, 0x8f, 0x31, 0xef, 0x22, 0xf0, 0x7f, 0x01, 0x12, 0x12, 0x19, 0x90, 0xff, 
-0xa6, 0xe0, 0x90, 0xfa, 0xb8, 0xf0, 0x54, 0xa0, 0x22, 0x12, 0x25, 0xd7, 0x8f, 0x4c, 0x7e, 0x00, 
-0xc3, 0xef, 0x95, 0x3c, 0xee, 0x95, 0x3b, 0x22, 0xf0, 0x7f, 0x01, 0x12, 0x12, 0x19, 0x90, 0xff, 
-0xb6, 0xe0, 0x90, 0xfa, 0xb8, 0xf0, 0x54, 0xa0, 0x22, 0x75, 0x39, 0x00, 0x75, 0x3a, 0x01, 0x02, 
-0x2c, 0x07, 0x90, 0xfa, 0xb6, 0xe0, 0xff, 0x02, 0x31, 0x82, 0x8e, 0x39, 0x8f, 0x3a, 0x02, 0x2c, 
-0x07, 0x12, 0x22, 0xa0, 0x7e, 0x00, 0x8e, 0x30, 0x8f, 0x31, 0xef, 0x22, 0x7d, 0x01, 0x12, 0x25, 
-0xd7, 0x90, 0xfa, 0xb1, 0xe0, 0x22, 0xef, 0x90, 0xf8, 0x04, 0xf0, 0x22, 0xc0, 0xa8, 0xc2, 0xaf, 
-0xee, 0x60, 0x0a, 0xc0, 0x05, 0x7d, 0x7f, 0xdd, 0xfe, 0xde, 0xfa, 0xd0, 0x05, 0xef, 0xc3, 0x94, 
-0x15, 0x50, 0x03, 0xd0, 0xa8, 0x22, 0x13, 0x70, 0x03, 0xd0, 0xa8, 0x22, 0xff, 0xd5, 0x07, 0xfd, 
-0xd0, 0xa8, 0x22, 0xc0, 0x00, 0xc0, 0x01, 0xc0, 0x02, 0xc0, 0x04, 0xc0, 0x05, 0xe5, 0x3e, 0x24, 
-0x08, 0xf8, 0x86, 0x05, 0x53, 0x05, 0x7f, 0x7c, 0xff, 0x12, 0x10, 0x78, 0x7f, 0x00, 0x7e, 0x00, 
-0xe5, 0x43, 0x60, 0x46, 0xfc, 0x90, 0xf9, 0x1b, 0xe0, 0x54, 0x7f, 0x6d, 0x70, 0x0f, 0xc0, 0x83, 
-0xc0, 0x82, 0xa3, 0xe0, 0xfe, 0xa3, 0xe0, 0xff, 0xa3, 0x15, 0x43, 0x80, 0x07, 0xa3, 0xa3, 0xa3, 
-0xdc, 0xe6, 0x80, 0x26, 0xdc, 0x06, 0xd0, 0x82, 0xd0, 0x83, 0x80, 0x1e, 0xe0, 0xf8, 0xa3, 0xe0, 
-0xf9, 0xa3, 0xe0, 0xfa, 0xd0, 0x82, 0xd0, 0x83, 0xe8, 0xf0, 0xa3, 0xe9, 0xf0, 0xa3, 0xea, 0xf0, 
-0xa3, 0xc0, 0x83, 0xc0, 0x82, 0xa3, 0xa3, 0xa3, 0x80, 0xda, 0x12, 0x11, 0x0f, 0xd0, 0x05, 0xd0, 
-0x04, 0xd0, 0x02, 0xd0, 0x01, 0xd0, 0x00, 0x22, 0x85, 0xa8, 0x44, 0x75, 0xa8, 0x88, 0xec, 0x70, 
-0x02, 0x7c, 0x3f, 0x8c, 0x3d, 0x22, 0xe5, 0x3e, 0x24, 0x08, 0xf8, 0x76, 0x00, 0x12, 0x11, 0x66, 
-0x80, 0xfb, 0xc0, 0x00, 0xc0, 0x01, 0xc0, 0x02, 0xc0, 0x04, 0xc0, 0x06, 0x7c, 0xff, 0x12, 0x10, 
-0x78, 0xe5, 0x43, 0x60, 0x42, 0xfe, 0x90, 0xf9, 0x1b, 0xe0, 0x54, 0x7f, 0x6f, 0x70, 0x0b, 0xc0, 
-0x83, 0xc0, 0x82, 0xa3, 0xa3, 0xa3, 0x15, 0x43, 0x80, 0x07, 0xa3, 0xa3, 0xa3, 0xde, 0xea, 0x80, 
-0x26, 0xde, 0x06, 0xd0, 0x82, 0xd0, 0x83, 0x80, 0xd8, 0xe0, 0xf8, 0xa3, 0xe0, 0xf9, 0xa3, 0xe0, 
-0xfa, 0xd0, 0x82, 0xd0, 0x83, 0xe8, 0xf0, 0xa3, 0xe9, 0xf0, 0xa3, 0xea, 0xf0, 0xa3, 0xc0, 0x83, 
-0xc0, 0x82, 0xa3, 0xa3, 0xa3, 0x80, 0xda, 0x78, 0x08, 0x08, 0x79, 0x18, 0x09, 0x7c, 0x01, 0xe6, 
-0x54, 0x7f, 0x6f, 0x70, 0x06, 0x76, 0x00, 0x77, 0x00, 0x80, 0x06, 0x08, 0x09, 0x0c, 0xbc, 0x08, 
-0xee, 0x12, 0x11, 0x0f, 0xd0, 0x06, 0xd0, 0x04, 0xd0, 0x02, 0xd0, 0x01, 0xd0, 0x00, 0x22, 0x75, 
-0x3d, 0x00, 0x85, 0x44, 0xa8, 0x22, 0xc0, 0xf0, 0xc0, 0x82, 0xc0, 0x83, 0xc3, 0xe5, 0x43, 0x24, 
-0xe8, 0x50, 0x05, 0x12, 0x11, 0x66, 0x80, 0xf4, 0xef, 0x60, 0x31, 0x90, 0x30, 0x54, 0xe4, 0x93, 
-0xc3, 0x9f, 0x40, 0x2f, 0xc0, 0x04, 0x7c, 0xff, 0x12, 0x10, 0x78, 0xd0, 0x04, 0x43, 0x07, 0x80, 
-0xe5, 0x43, 0x75, 0xf0, 0x03, 0xa4, 0x24, 0x1b, 0xf5, 0x82, 0xe4, 0x34, 0xf9, 0xf5, 0x83, 0xef, 
-0xf0, 0xec, 0xa3, 0xf0, 0xed, 0xa3, 0xf0, 0x05, 0x43, 0x12, 0x11, 0x0f, 0xd0, 0x83, 0xd0, 0x82, 
-0xd0, 0xf0, 0x22, 0x02, 0x11, 0x94, 0xc0, 0x04, 0x7c, 0x20, 0xd2, 0x8c, 0xd2, 0x8d, 0xd5, 0x04, 
-0xfd, 0xd0, 0x04, 0x22, 0x75, 0xa8, 0x00, 0x75, 0x88, 0x00, 0x75, 0xb8, 0x00, 0x75, 0xf0, 0x00, 
-0x75, 0xd0, 0x00, 0xe4, 0xf8, 0x90, 0xf8, 0x04, 0xf0, 0x90, 0x00, 0x00, 0xf6, 0x08, 0xb8, 0x00, 
-0xfb, 0x02, 0x00, 0x00, 0xc2, 0xaf, 0xe4, 0x90, 0xff, 0x48, 0xf0, 0x90, 0xff, 0x50, 0xf0, 0x90, 
-0xff, 0x08, 0xf0, 0x90, 0xff, 0x10, 0xf0, 0x90, 0xff, 0x80, 0xf0, 0xa3, 0xa3, 0xf0, 0xd2, 0xb1, 
-0xc2, 0xb0, 0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0xdc, 0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0xdc, 
-0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0xdc, 0xd2, 0xb0, 0xd2, 0xb1, 0x7e, 0xff, 0x7f, 0xff, 0x12, 
-0x0f, 0xdc, 0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0xdc, 0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0xdc, 
-0x80, 0xcc, 0xc3, 0xee, 0x94, 0x02, 0x50, 0x04, 0x7e, 0x03, 0x7f, 0xe8, 0xef, 0xf4, 0xff, 0xee, 
-0xf4, 0xfe, 0x0f, 0xbf, 0x00, 0x01, 0x0e, 0x8f, 0x42, 0x8e, 0x41, 0x22, 0xc3, 0xef, 0x94, 0xbc, 
-0xee, 0x94, 0x02, 0x50, 0x04, 0x7e, 0x07, 0x7f, 0xd0, 0xef, 0xf4, 0xff, 0xee, 0xf4, 0xfe, 0x0f, 
-0xbf, 0x00, 0x01, 0x0e, 0x8f, 0x40, 0x8e, 0x3f, 0x22, 0xef, 0x70, 0x01, 0x22, 0xc0, 0x00, 0xc0, 
-0xa8, 0xc2, 0xaf, 0xe5, 0x3e, 0x24, 0x18, 0xf8, 0xa6, 0x07, 0xe5, 0x3e, 0x24, 0x08, 0xf8, 0xc6, 
-0x54, 0x7f, 0xf6, 0xd0, 0xa8, 0xe6, 0x30, 0xe7, 0x03, 0xd0, 0x00, 0x22, 0x12, 0x11, 0x66, 0x80, 
+0x90, 0xff, 0x56, 0xe0, 0x30, 0xe7, 0x25, 0xd0, 0x83, 0xd0, 0x82, 0x74, 0x02, 0xf0, 0x80, 0x20, 
+0xb4, 0x02, 0x1d, 0xc0, 0x82, 0xc0, 0x83, 0x90, 0xff, 0x7a, 0xe0, 0x30, 0xe7, 0x05, 0x12, 0x25, 
+0x13, 0x80, 0x09, 0xd0, 0x83, 0xd0, 0x82, 0x74, 0x03, 0xf0, 0x80, 0x04, 0xd0, 0x83, 0xd0, 0x82, 
+0x20, 0x02, 0x03, 0x30, 0x01, 0x7b, 0x74, 0x16, 0xf5, 0x82, 0x74, 0xf9, 0xf5, 0x83, 0xe0, 0x14, 
+0xfc, 0xf0, 0xa3, 0xe0, 0xfd, 0xa3, 0xe0, 0xfe, 0x64, 0x04, 0x70, 0x0f, 0xec, 0x70, 0x62, 0x7e, 
+0x01, 0x12, 0x00, 0xc9, 0x7c, 0x0a, 0x7d, 0xfa, 0x02, 0x02, 0x22, 0x12, 0x00, 0xc9, 0xee, 0x64, 
+0x04, 0x60, 0x1d, 0xec, 0x70, 0x4b, 0x7c, 0x0a, 0xed, 0x14, 0xfd, 0x70, 0x15, 0xee, 0x64, 0x02, 
+0x60, 0x07, 0x7e, 0x02, 0x7d, 0x32, 0x02, 0x02, 0x22, 0x7e, 0x01, 0x7d, 0xfa, 0x02, 0x02, 0x22, 
+0x7c, 0x0a, 0x74, 0x16, 0xf5, 0x82, 0x74, 0xf9, 0xf5, 0x83, 0xec, 0xf0, 0xa3, 0xed, 0xf0, 0xa3, 
+0xee, 0xf0, 0x14, 0x60, 0x18, 0x20, 0xe1, 0x0f, 0x20, 0x01, 0x06, 0xd2, 0xb1, 0xc2, 0xb0, 0x80, 
+0x10, 0xc2, 0xb1, 0xd2, 0xb0, 0x80, 0x0a, 0xc2, 0xb1, 0xc2, 0xb0, 0x80, 0x04, 0xd2, 0xb0, 0xd2, 
+0xb1, 0x78, 0x19, 0x79, 0x09, 0x7a, 0x07, 0xe7, 0x70, 0x04, 0xa6, 0x00, 0x80, 0x0b, 0xe6, 0x60, 
+0x08, 0x16, 0xe6, 0x70, 0x04, 0xe7, 0x44, 0x80, 0xf7, 0x08, 0x09, 0xda, 0xea, 0xe5, 0x43, 0x60, 
+0x13, 0x14, 0xf5, 0x43, 0x70, 0x0e, 0xe5, 0x44, 0x24, 0x08, 0xf8, 0x76, 0x00, 0x12, 0x10, 0x95, 
+0xd2, 0x8c, 0xd2, 0x8d, 0xd0, 0x07, 0xd0, 0x06, 0xd0, 0x05, 0xd0, 0x04, 0xd0, 0x03, 0xd0, 0x02, 
+0xd0, 0x01, 0xd0, 0x00, 0xd0, 0x83, 0xd0, 0x82, 0xd0, 0xf0, 0xd0, 0xd0, 0xd0, 0xe0, 0x32, 0x90, 
+0xff, 0x04, 0xe0, 0x90, 0xfa, 0xb5, 0xf0, 0x90, 0xff, 0x06, 0xe0, 0xfc, 0xa3, 0xe0, 0xfa, 0xec, 
+0xff, 0xea, 0xfe, 0xef, 0xc3, 0x94, 0x08, 0xee, 0x94, 0x01, 0x50, 0x02, 0x80, 0x04, 0x7e, 0x01, 
+0x7f, 0x08, 0x8e, 0x34, 0x8f, 0x35, 0x90, 0xff, 0x02, 0xe0, 0xfc, 0xa3, 0xe0, 0xfa, 0xec, 0xff, 
+0xea, 0x90, 0xfa, 0xb9, 0xf0, 0xef, 0xa3, 0xf0, 0x12, 0x18, 0x49, 0x78, 0x24, 0x7c, 0x00, 0x7d, 
+0x00, 0x12, 0x19, 0x6c, 0x7e, 0x00, 0x7f, 0x05, 0x12, 0x13, 0x8f, 0xe4, 0xf5, 0x53, 0xe5, 0x53, 
+0xc3, 0x94, 0x02, 0x50, 0x0f, 0x12, 0x18, 0x2a, 0xe4, 0x12, 0x13, 0xfb, 0x05, 0x53, 0x04, 0x12, 
+0x18, 0x1b, 0x80, 0xea, 0x12, 0x18, 0x49, 0x90, 0xff, 0x00, 0xe0, 0xff, 0x54, 0x60, 0x24, 0xc0, 
+0x70, 0x03, 0x02, 0x08, 0xb8, 0x24, 0x40, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 0xe0, 
+0xfe, 0x54, 0x0f, 0xf5, 0x53, 0xee, 0x30, 0xe7, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x92, 0x0a, 0x90, 
+0xff, 0x01, 0xe0, 0x12, 0x15, 0x0f, 0x03, 0x55, 0x00, 0x04, 0x28, 0x01, 0x05, 0x2f, 0x03, 0x05, 
+0xf6, 0x05, 0x06, 0x38, 0x06, 0x07, 0x9a, 0x08, 0x07, 0xe2, 0x09, 0x08, 0x3e, 0x0a, 0x08, 0x7e, 
+0x0b, 0x00, 0x00, 0x0e, 0xac, 0xe5, 0x2c, 0x20, 0xe7, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb9, 
+0xe0, 0x70, 0x02, 0xa3, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x35, 0x64, 0x02, 0x45, 0x34, 
+0x60, 0x03, 0x02, 0x0e, 0xac, 0xef, 0x54, 0x1f, 0x14, 0x60, 0x2b, 0x14, 0x60, 0x47, 0x24, 0x02, 
+0x60, 0x03, 0x02, 0x0e, 0xac, 0xee, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x18, 0x2a, 0x74, 0x01, 
+0x12, 0x13, 0xfb, 0x78, 0x6d, 0xe6, 0x30, 0xe0, 0x08, 0x12, 0x18, 0x2a, 0x74, 0x02, 0x12, 0x13, 
+0xfb, 0x7f, 0x02, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x20, 0xe1, 0x09, 0x90, 0xfa, 0xb5, 0xe0, 0x60, 
+0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 0xe0, 0xd3, 0x94, 0x01, 0x40, 0x03, 0x02, 0x0e, 0xac, 
+0x7f, 0x02, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x20, 0xe1, 0x0e, 0x90, 0xfa, 0xb5, 0xe0, 0xff, 0x60, 
+0x07, 0x64, 0x80, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x0f, 0x38, 0x40, 0x03, 0x02, 0x0e, 0xac, 
+0xe5, 0x53, 0x70, 0x19, 0x30, 0x0a, 0x0b, 0x90, 0xff, 0x80, 0x12, 0x18, 0x27, 0x12, 0x13, 0xfb, 
+0x80, 0x24, 0x90, 0xff, 0x82, 0x12, 0x18, 0x27, 0x12, 0x13, 0xfb, 0x80, 0x19, 0x15, 0x53, 0x30, 
+0x0a, 0x0b, 0x12, 0x18, 0xbd, 0x12, 0x18, 0x25, 0x12, 0x13, 0xfb, 0x80, 0x09, 0x12, 0x18, 0xcb, 
+0x12, 0x18, 0x25, 0x12, 0x13, 0xfb, 0x12, 0x18, 0x2a, 0x12, 0x13, 0xb5, 0x60, 0x05, 0x74, 0x01, 
+0x12, 0x13, 0xfb, 0x7f, 0x02, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xac, 
+0xe5, 0x35, 0x45, 0x34, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x18, 0xd9, 0x14, 0x60, 0x2d, 0x14, 
+0x60, 0x59, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb9, 0xe0, 0x70, 0x04, 0xa3, 
+0xe0, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 0xe0, 0x60, 0x03, 0x02, 0x0e, 
+0xac, 0x78, 0x6d, 0xe6, 0x54, 0xfe, 0xf6, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x20, 0xe1, 
+0x06, 0x20, 0xe0, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x30, 0xe0, 0x09, 0x90, 0xfa, 0xb5, 0xe0, 
+0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x30, 0xe1, 0x0c, 0x90, 0xfa, 0xb5, 0xe0, 0xd3, 0x94, 
+0x01, 0x40, 0x03, 0x02, 0x0e, 0xac, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0x90, 0xfa, 0xb9, 0xe0, 0x70, 
+0x02, 0xa3, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x0f, 0x38, 0x40, 0x03, 0x02, 0x0e, 0xac, 
+0xe5, 0x2c, 0x20, 0xe1, 0x06, 0x20, 0xe0, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x30, 0xe0, 0x07, 
+0xe5, 0x53, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x53, 0x70, 0x0f, 0x90, 0xff, 0x82, 0xe0, 0x54, 
+0xf7, 0xf0, 0x90, 0xff, 0x80, 0xe0, 0x54, 0xf7, 0xf0, 0x22, 0xe5, 0x53, 0x24, 0xfe, 0x60, 0x1b, 
+0x04, 0x70, 0x2e, 0x30, 0x0a, 0x0c, 0xa2, 0x0a, 0xe4, 0x33, 0xfd, 0x7f, 0x03, 0x12, 0x2a, 0xce, 
+0x80, 0x1f, 0xe4, 0xfd, 0x7f, 0x03, 0x12, 0x2a, 0xce, 0x80, 0x16, 0x30, 0x0a, 0x0c, 0xa2, 0x0a, 
+0xe4, 0x33, 0xfd, 0x7f, 0x04, 0x12, 0x2a, 0xce, 0x80, 0x07, 0xe4, 0xfd, 0x7f, 0x04, 0x12, 0x2a, 
+0xce, 0x15, 0x53, 0x30, 0x0a, 0x0b, 0x12, 0x18, 0xbd, 0xf5, 0x83, 0xe0, 0x54, 0xf7, 0xf0, 0x80, 
+0x09, 0x12, 0x18, 0xcb, 0xf5, 0x83, 0xe0, 0x54, 0xf7, 0xf0, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0xe5, 
+0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x35, 0x45, 0x34, 0x60, 0x03, 0x02, 0x0e, 0xac, 
+0x12, 0x18, 0xd9, 0x14, 0x60, 0x2d, 0x14, 0x60, 0x55, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0e, 0xac, 
+0x90, 0xfa, 0xb9, 0xe0, 0x70, 0x04, 0xa3, 0xe0, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 
+0xfa, 0xb5, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x78, 0x6d, 0xe6, 0x44, 0x01, 0xf6, 0xe4, 0xff, 
+0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x20, 0xe1, 0x06, 0x20, 0xe0, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 
+0x30, 0xe0, 0x07, 0xe5, 0x53, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x30, 0xe1, 0x0a, 0xe5, 
+0x53, 0xd3, 0x94, 0x01, 0x40, 0x03, 0x02, 0x0e, 0xac, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0x90, 0xfa, 
+0xb9, 0xe0, 0x70, 0x02, 0xa3, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 0xe0, 0xff, 
+0x12, 0x2f, 0x3b, 0x40, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x20, 0xe1, 0x06, 0x20, 0xe0, 0x03, 
+0x02, 0x0e, 0xac, 0xe5, 0x53, 0x70, 0x09, 0x30, 0x0a, 0x03, 0x02, 0x19, 0x7a, 0x02, 0x19, 0x3e, 
+0xe5, 0x2c, 0x20, 0xe1, 0x03, 0x02, 0x0e, 0xac, 0x15, 0x53, 0x30, 0x0a, 0x0b, 0x12, 0x18, 0xbd, 
+0xf5, 0x83, 0xe0, 0x44, 0x08, 0xf0, 0x80, 0x09, 0x12, 0x18, 0xcb, 0xf5, 0x83, 0xe0, 0x44, 0x08, 
+0xf0, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x35, 
+0x45, 0x34, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 
+0x12, 0x18, 0xd9, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x30, 0xe1, 0x03, 0x02, 0x0e, 0xac, 
+0x90, 0xfa, 0xba, 0xe0, 0x90, 0xff, 0xff, 0xf0, 0xe0, 0x60, 0x05, 0x43, 0x2c, 0x01, 0x80, 0x03, 
+0x53, 0x2c, 0xfe, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 0x20, 0xe7, 0x03, 0x02, 0x0e, 0xac, 
+0xe5, 0x35, 0x45, 0x34, 0x70, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x18, 0xd9, 0x60, 0x03, 0x02, 0x0e, 
+0xac, 0x90, 0xfa, 0xb9, 0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0xec, 0x24, 0xfe, 0x60, 0x3a, 0x14, 0x60, 
+0x75, 0x24, 0x02, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xed, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x18, 
+0x49, 0x12, 0x19, 0x73, 0x7d, 0x03, 0x12, 0x0e, 0xf3, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x0e, 
+0xb0, 0x90, 0xfa, 0xb2, 0xe0, 0xfd, 0xa3, 0x12, 0x18, 0x93, 0x12, 0x0f, 0x0f, 0x50, 0x02, 0x80, 
+0x04, 0xae, 0x34, 0xaf, 0x35, 0x02, 0x0f, 0x40, 0x12, 0x18, 0x49, 0x90, 0xf9, 0x65, 0xe0, 0x30, 
+0xe4, 0x0d, 0x12, 0x19, 0x73, 0x7d, 0x14, 0x12, 0x0e, 0xf3, 0x60, 0x10, 0x02, 0x0e, 0xac, 0x12, 
+0x19, 0x73, 0x7d, 0x04, 0x12, 0x0f, 0x47, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x0e, 0xb0, 0x90, 
+0xfa, 0xb2, 0xe0, 0xfd, 0xa3, 0x12, 0x18, 0x93, 0x12, 0x0f, 0x0f, 0x50, 0x02, 0x80, 0x04, 0xae, 
+0x34, 0xaf, 0x35, 0x02, 0x0f, 0x40, 0x12, 0x19, 0x73, 0x7d, 0x05, 0x12, 0x0f, 0x47, 0x60, 0x03, 
+0x02, 0x0e, 0xac, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xb2, 0x12, 0x18, 0x90, 0x7d, 0x01, 0x12, 0x23, 
+0xee, 0x90, 0xfa, 0xb3, 0xe4, 0x75, 0xf0, 0x03, 0x12, 0x14, 0x2f, 0x90, 0xfa, 0xba, 0xe0, 0x90, 
+0xfa, 0xb1, 0xf0, 0xe4, 0xf5, 0x52, 0x90, 0xfa, 0xb1, 0xe0, 0xff, 0xe5, 0x52, 0xc3, 0x9f, 0x50, 
+0x24, 0x12, 0x18, 0x8a, 0x12, 0x0f, 0x52, 0xff, 0xfd, 0x90, 0xfa, 0xb3, 0xe4, 0x8d, 0xf0, 0x12, 
+0x14, 0x2f, 0x90, 0xfa, 0xb2, 0xe0, 0xc3, 0x9f, 0xf0, 0xd3, 0x94, 0x00, 0x50, 0x03, 0x02, 0x0e, 
+0xac, 0x05, 0x52, 0x80, 0xd1, 0x12, 0x18, 0x8a, 0x12, 0x0f, 0x52, 0x24, 0xfe, 0xff, 0x90, 0xfa, 
+0xb2, 0xf0, 0xfd, 0xa3, 0xe4, 0x75, 0xf0, 0x02, 0x12, 0x14, 0x2f, 0x7a, 0xf9, 0x79, 0x6e, 0x7b, 
+0x01, 0x8b, 0x2d, 0x8a, 0x2e, 0x89, 0x2f, 0xe9, 0x24, 0x02, 0xf9, 0xe4, 0x3a, 0xfa, 0x12, 0x18, 
+0x90, 0x12, 0x23, 0xee, 0x8f, 0x52, 0x05, 0x52, 0x05, 0x52, 0x12, 0x18, 0x2a, 0xe5, 0x52, 0x12, 
+0x13, 0xfb, 0x12, 0x18, 0x2a, 0x90, 0x00, 0x01, 0x74, 0x03, 0x12, 0x14, 0x0d, 0xaf, 0x52, 0x7e, 
+0x00, 0xc3, 0xef, 0x95, 0x35, 0xee, 0x95, 0x34, 0x50, 0x02, 0x80, 0x04, 0xae, 0x34, 0xaf, 0x35, 
+0x8e, 0x30, 0x8f, 0x31, 0x02, 0x29, 0x2d, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x20, 0xe7, 0x03, 0x02, 
+0x0e, 0xac, 0xe5, 0x35, 0x64, 0x01, 0x45, 0x34, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 
+0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb9, 0xe0, 0x70, 0x02, 0xa3, 0xe0, 0x60, 0x03, 
+0x02, 0x0e, 0xac, 0x12, 0x18, 0xd9, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x20, 0xe0, 0x06, 
+0x20, 0xe1, 0x03, 0x02, 0x0e, 0xac, 0x75, 0x2d, 0x00, 0x75, 0x2e, 0x00, 0x75, 0x2f, 0x29, 0x02, 
+0x0f, 0x2f, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x35, 0x45, 0x34, 0x60, 0x03, 
+0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb5, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xd3, 0x90, 0xfa, 0xba, 
+0xe0, 0x94, 0x01, 0x90, 0xfa, 0xb9, 0xe0, 0x94, 0x00, 0x40, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x18, 
+0xd9, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x20, 0xe0, 0x06, 0x20, 0xe1, 0x03, 0x02, 0x0e, 
+0xac, 0x90, 0xfa, 0xba, 0xe0, 0xf5, 0x29, 0xe5, 0x29, 0x70, 0x08, 0x43, 0x2c, 0x01, 0x53, 0x2c, 
+0xfd, 0x80, 0x06, 0x53, 0x2c, 0xfe, 0x43, 0x2c, 0x02, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 
+0x20, 0xe7, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x35, 0x64, 0x01, 0x45, 0x34, 0x60, 0x03, 0x02, 0x0e, 
+0xac, 0x90, 0xfa, 0xb5, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x90, 0xfa, 0xb9, 0xe0, 0x70, 0x02, 
+0xa3, 0xe0, 0x60, 0x03, 0x02, 0x0e, 0xac, 0x12, 0x18, 0xd9, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0e, 
+0xac, 0xe5, 0x2c, 0x20, 0xe1, 0x03, 0x02, 0x0e, 0xac, 0x7f, 0x01, 0x02, 0x2f, 0x6a, 0xe5, 0x2c, 
+0x30, 0xe7, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x35, 0x45, 0x34, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xd3, 
+0x90, 0xfa, 0xba, 0xe0, 0x94, 0x00, 0x90, 0xfa, 0xb9, 0xe0, 0x94, 0x00, 0x40, 0x03, 0x02, 0x0e, 
+0xac, 0x12, 0x18, 0xd9, 0x64, 0x01, 0x60, 0x03, 0x02, 0x0e, 0xac, 0xe5, 0x2c, 0x20, 0xe1, 0x03, 
+0x02, 0x0e, 0xac, 0xe4, 0xff, 0x02, 0x2f, 0x6a, 0x90, 0xff, 0x01, 0x12, 0x19, 0x8a, 0xef, 0x12, 
+0x13, 0xfb, 0x90, 0xfa, 0xb5, 0x12, 0x19, 0x8a, 0x90, 0x00, 0x01, 0xef, 0x12, 0x14, 0x0d, 0x90, 
+0x00, 0x02, 0xe4, 0x12, 0x14, 0x0d, 0x74, 0x03, 0x12, 0x18, 0x1b, 0x90, 0xfa, 0xb9, 0xe0, 0xff, 
+0xa3, 0xe0, 0x85, 0x2f, 0x82, 0x85, 0x2e, 0x83, 0xcf, 0xf0, 0xa3, 0xef, 0xf0, 0x90, 0xff, 0x01, 
+0xe0, 0x12, 0x15, 0x0f, 0x09, 0x3d, 0x02, 0x09, 0x5f, 0x04, 0x09, 0x81, 0x05, 0x09, 0xad, 0x06, 
+0x09, 0xcb, 0x07, 0x09, 0xe9, 0x08, 0x0a, 0x07, 0x09, 0x0a, 0x25, 0x0b, 0x0a, 0xda, 0x80, 0x0c, 
+0xfa, 0x81, 0x0d, 0x1c, 0x82, 0x0b, 0x21, 0x83, 0x0b, 0x6a, 0x84, 0x0b, 0x89, 0x85, 0x0b, 0xc5, 
+0x86, 0x0c, 0x07, 0x87, 0x0c, 0x95, 0x88, 0x0c, 0xd0, 0x89, 0x0a, 0x43, 0x92, 0x0a, 0x43, 0x93, 
+0x0d, 0xcf, 0xc0, 0x0e, 0x00, 0xc1, 0x0e, 0x11, 0xc2, 0x00, 0x00, 0x0e, 0x9b, 0xe5, 0x2c, 0x20, 
+0xe7, 0x05, 0x7f, 0x05, 0x02, 0x2e, 0xa5, 0x12, 0x18, 0xe0, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 
+0xfd, 0x7c, 0x00, 0x7f, 0x07, 0x02, 0x10, 0x9c, 0xe4, 0xfd, 0x7f, 0x07, 0x02, 0x2c, 0xc0, 0xe5, 
+0x2c, 0x20, 0xe7, 0x05, 0x7f, 0x05, 0x02, 0x2e, 0xa5, 0x12, 0x18, 0xe0, 0x60, 0x03, 0x04, 0x70, 
+0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0c, 0x02, 0x10, 0x9c, 0xe4, 0xfd, 0x7f, 0x07, 0x02, 0x2c, 
+0xc0, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xaf, 0x12, 0x19, 0x99, 0x50, 0x06, 0xe5, 0x35, 
+0x45, 0x34, 0x70, 0x05, 0x7f, 0x02, 0x02, 0x2e, 0xa5, 0x90, 0xfa, 0xb5, 0xe0, 0x24, 0xfe, 0x24, 
+0xfd, 0x50, 0x02, 0x80, 0x03, 0x02, 0x2f, 0x28, 0x7f, 0x07, 0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 
+0xe7, 0x03, 0x02, 0x0e, 0xaf, 0x12, 0x18, 0xe0, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 
+0x00, 0x7f, 0x08, 0x02, 0x10, 0x9c, 0x7f, 0x07, 0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 
+0x02, 0x0e, 0xaf, 0x12, 0x18, 0xe0, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 
+0x09, 0x02, 0x10, 0x9c, 0x7f, 0x07, 0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 
+0xaf, 0x12, 0x18, 0xe0, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0a, 0x02, 
+0x10, 0x9c, 0x7f, 0x07, 0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xaf, 0x12, 
+0x18, 0xe0, 0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0b, 0x02, 0x10, 0x9c, 
+0x7f, 0x07, 0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 0xe7, 0x03, 0x02, 0x0e, 0xaf, 0x12, 0x18, 0xe0, 
+0x60, 0x03, 0x04, 0x70, 0x09, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0e, 0x02, 0x10, 0x9c, 0x7f, 0x07, 
+0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 0xe7, 0x56, 0x12, 0x18, 0xd9, 0x70, 0x4a, 0x90, 0xff, 0x02, 
+0xe0, 0xf5, 0x52, 0xe5, 0x52, 0xb4, 0x82, 0x05, 0x75, 0x52, 0x61, 0x80, 0x12, 0xe5, 0x52, 0xb4, 
+0x83, 0x05, 0x75, 0x52, 0x62, 0x80, 0x08, 0xe5, 0x52, 0xc4, 0x54, 0xf0, 0x04, 0xf5, 0x52, 0x12, 
+0x17, 0x8b, 0x12, 0x19, 0x6c, 0x12, 0x22, 0xb8, 0x12, 0x18, 0xe8, 0x12, 0x13, 0xce, 0x60, 0x05, 
+0x12, 0x2f, 0x76, 0x80, 0x06, 0x85, 0x2a, 0x30, 0x85, 0x2b, 0x31, 0x75, 0x2d, 0x01, 0x75, 0x2e, 
+0xf9, 0x75, 0x2f, 0x71, 0x02, 0x29, 0x2d, 0xe4, 0xfd, 0x7f, 0x05, 0x02, 0x2c, 0xc0, 0x12, 0x18, 
+0xd9, 0x60, 0x05, 0x7f, 0x05, 0x02, 0x2e, 0xa5, 0x12, 0x19, 0x99, 0x40, 0x05, 0x7f, 0x03, 0x02, 
+0x2e, 0xa5, 0x90, 0xff, 0x02, 0xe0, 0xf5, 0x52, 0xe5, 0x52, 0xb4, 0x82, 0x05, 0x75, 0x52, 0x61, 
+0x80, 0x12, 0xe5, 0x52, 0xb4, 0x83, 0x05, 0x75, 0x52, 0x62, 0x80, 0x08, 0xe5, 0x52, 0xc4, 0x54, 
+0xf0, 0x04, 0xf5, 0x52, 0x12, 0x17, 0x8b, 0x02, 0x2f, 0x28, 0x12, 0x19, 0xa3, 0x12, 0x27, 0x19, 
+0x12, 0x18, 0x9b, 0xe0, 0x54, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0xe0, 0x90, 0xfa, 0xb6, 0xf0, 0x78, 
+0x6e, 0x12, 0x14, 0xeb, 0x90, 0x00, 0x02, 0x12, 0x13, 0xce, 0x30, 0xe7, 0xf2, 0x90, 0x00, 0x02, 
+0xe4, 0x12, 0x14, 0x0d, 0x90, 0xfa, 0xb6, 0xe0, 0x44, 0x80, 0xff, 0xf0, 0x78, 0x82, 0xe6, 0xfc, 
+0x08, 0xe6, 0x8c, 0x83, 0x12, 0x18, 0xa3, 0xef, 0xf0, 0x12, 0x2f, 0x80, 0xe4, 0xff, 0x02, 0x2e, 
+0xa5, 0x90, 0xfa, 0xb5, 0xe0, 0x64, 0x01, 0x70, 0x1f, 0x90, 0xfa, 0xb9, 0xe0, 0xff, 0x7e, 0x00, 
+0x70, 0x06, 0xa3, 0xe0, 0xf5, 0x90, 0x80, 0x2d, 0xc2, 0xaf, 0xef, 0xf4, 0x52, 0x90, 0x90, 0xfa, 
+0xba, 0xe0, 0x42, 0x90, 0xd2, 0xaf, 0x80, 0x1d, 0x90, 0xfa, 0xb9, 0xe0, 0xff, 0x7e, 0x00, 0x70, 
+0x06, 0xa3, 0xe0, 0xf5, 0xb0, 0x80, 0x0e, 0xc2, 0xaf, 0xef, 0xf4, 0x52, 0xb0, 0x90, 0xfa, 0xba, 
+0xe0, 0x42, 0xb0, 0xd2, 0xaf, 0xe4, 0xff, 0x02, 0x2e, 0xa5, 0x12, 0x18, 0x49, 0x90, 0xfa, 0xb5, 
+0xe0, 0xb4, 0x01, 0x0a, 0x12, 0x18, 0x2a, 0xe5, 0x90, 0x12, 0x13, 0xfb, 0x80, 0x08, 0x12, 0x18, 
+0x2a, 0xe5, 0xb0, 0x12, 0x13, 0xfb, 0x02, 0x0f, 0x2f, 0x90, 0xf9, 0x65, 0xe0, 0x20, 0xe1, 0x30, 
+0x12, 0x18, 0x53, 0x60, 0x18, 0x04, 0x70, 0x28, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x09, 0x90, 0xff, 
+0xa4, 0xe0, 0x44, 0x10, 0xf0, 0x80, 0x19, 0x12, 0x19, 0xad, 0xf0, 0x80, 0x13, 0x90, 0xfa, 0xb6, 
+0xe0, 0x60, 0x09, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x10, 0xf0, 0x80, 0x04, 0x12, 0x19, 0xb4, 0xf0, 
+0xe4, 0xff, 0x02, 0x2e, 0xa5, 0x90, 0xf9, 0x65, 0xe0, 0x20, 0xe1, 0x36, 0x12, 0x18, 0x53, 0x60, 
+0x1b, 0x04, 0x70, 0x2e, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x09, 0x90, 0xff, 0xa4, 0xe0, 0x44, 0x20, 
+0xf0, 0x80, 0x1f, 0x90, 0xff, 0xa4, 0xe0, 0x54, 0xdf, 0xf0, 0x80, 0x16, 0x90, 0xfa, 0xb6, 0xe0, 
+0x60, 0x09, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x07, 0x90, 0xff, 0xb4, 0xe0, 0x54, 
+0xdf, 0xf0, 0xe4, 0xff, 0x02, 0x2e, 0xa5, 0x12, 0x18, 0x53, 0x60, 0x46, 0x04, 0x60, 0x03, 0x02, 
+0x0c, 0x90, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x17, 0x90, 0xff, 0xa4, 0xe0, 0x44, 0x04, 0xf0, 0x90, 
+0xf9, 0x65, 0xe0, 0x30, 0xe1, 0x6a, 0x90, 0xff, 0xa4, 0xe0, 0x44, 0x02, 0xf0, 0x80, 0x61, 0x90, 
+0xff, 0xa4, 0xe0, 0x54, 0xfb, 0xf0, 0x90, 0xf9, 0x65, 0xe0, 0x30, 0xe1, 0x53, 0x30, 0x95, 0x09, 
+0x90, 0xff, 0xa4, 0xe0, 0x44, 0x02, 0xf0, 0x80, 0x47, 0x90, 0xff, 0xa4, 0xe0, 0x54, 0xfd, 0xf0, 
+0x80, 0x3e, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x17, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x04, 0xf0, 0x90, 
+0xf9, 0x65, 0xe0, 0x30, 0xe1, 0x2a, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x80, 0x21, 0x90, 
+0xff, 0xb4, 0xe0, 0x54, 0xfb, 0xf0, 0x90, 0xf9, 0x65, 0xe0, 0x30, 0xe1, 0x13, 0x30, 0x93, 0x09, 
+0x90, 0xff, 0xb4, 0xe0, 0x44, 0x02, 0xf0, 0x80, 0x07, 0x90, 0xff, 0xb4, 0xe0, 0x54, 0xfd, 0xf0, 
+0xe4, 0xff, 0x02, 0x2e, 0xa5, 0x12, 0x18, 0x53, 0x60, 0x1b, 0x04, 0x70, 0x2e, 0x90, 0xfa, 0xb6, 
+0xe0, 0x60, 0x09, 0x90, 0xff, 0xa2, 0xe0, 0x44, 0x40, 0xf0, 0x80, 0x1f, 0x90, 0xff, 0xa2, 0xe0, 
+0x54, 0xbf, 0xf0, 0x80, 0x16, 0x90, 0xfa, 0xb6, 0xe0, 0x60, 0x09, 0x90, 0xff, 0xb2, 0xe0, 0x44, 
+0x40, 0xf0, 0x80, 0x07, 0x90, 0xff, 0xb2, 0xe0, 0x54, 0xbf, 0xf0, 0xe4, 0xff, 0x02, 0x2e, 0xa5, 
+0x12, 0x18, 0x49, 0x12, 0x18, 0x5b, 0x60, 0x0f, 0x04, 0x70, 0x16, 0x90, 0xff, 0xa4, 0xe0, 0x12, 
+0x18, 0x2a, 0x12, 0x13, 0xfb, 0x80, 0x0a, 0x90, 0xff, 0xb4, 0xe0, 0x12, 0x18, 0x2a, 0x12, 0x13, 
+0xfb, 0x75, 0x30, 0x00, 0x75, 0x31, 0x01, 0x02, 0x29, 0x2d, 0xe4, 0xff, 0x12, 0x2e, 0xa5, 0x12, 
+0x19, 0x46, 0x7f, 0x03, 0x12, 0x11, 0x9f, 0x90, 0xff, 0xfc, 0xe0, 0x54, 0x7f, 0xf0, 0x7f, 0xff, 
+0x7e, 0x00, 0x12, 0x2d, 0xee, 0xc2, 0x90, 0xc2, 0xaf, 0x00, 0x80, 0xfd, 0xe4, 0xf5, 0x54, 0xf5, 
+0x55, 0x90, 0xfa, 0xbb, 0x74, 0x3e, 0xf0, 0xa3, 0xe4, 0xf0, 0x90, 0xfa, 0xb3, 0xf0, 0xa3, 0x74, 
+0x15, 0xf0, 0xe0, 0x54, 0x3f, 0xff, 0xc3, 0x74, 0x40, 0x9f, 0x90, 0xfa, 0xb8, 0xf0, 0xd3, 0x94, 
+0x00, 0xe4, 0x94, 0x3e, 0x40, 0x08, 0x90, 0xfa, 0xbc, 0xe0, 0x90, 0xfa, 0xb8, 0xf0, 0x12, 0x0e, 
+0xd6, 0xe5, 0x23, 0x45, 0x22, 0x70, 0x73, 0x12, 0x18, 0x62, 0x90, 0xfa, 0xbb, 0x12, 0x19, 0x65, 
+0x60, 0x27, 0xd3, 0xef, 0x94, 0x40, 0xee, 0x94, 0x00, 0x40, 0x08, 0x90, 0xfa, 0xb8, 0x74, 0x40, 
+0xf0, 0x80, 0x08, 0x90, 0xfa, 0xbc, 0xe0, 0x90, 0xfa, 0xb8, 0xf0, 0x12, 0x0e, 0xd6, 0xe5, 0x23, 
+0x45, 0x22, 0x70, 0x46, 0x12, 0x18, 0x62, 0x80, 0xd1, 0x75, 0x52, 0x02, 0x90, 0xfa, 0xbb, 0xe4, 
+0xf0, 0xa3, 0x04, 0xf0, 0x90, 0xfa, 0xb3, 0xe4, 0xf0, 0xa3, 0x74, 0x0f, 0xf0, 0x7b, 0x00, 0x7a, 
+0x00, 0x79, 0x52, 0x90, 0xfa, 0xbc, 0xe0, 0xf5, 0x50, 0x7d, 0x0f, 0x7c, 0x00, 0x12, 0x26, 0x25, 
+0x75, 0x22, 0x00, 0x8f, 0x23, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x52, 0xe4, 0xf5, 0x40, 0xf5, 0x41, 
+0x7d, 0x01, 0x12, 0x23, 0xee, 0xe4, 0xf5, 0x22, 0xf5, 0x23, 0xaf, 0x23, 0x02, 0x2e, 0xa5, 0x90, 
+0xfa, 0xba, 0xe0, 0x90, 0xfa, 0xb6, 0xf0, 0x30, 0xe7, 0x10, 0xe0, 0x54, 0x0f, 0x90, 0xf9, 0x62, 
+0xf0, 0xd3, 0x94, 0x00, 0x40, 0x15, 0xc2, 0x95, 0x80, 0x11, 0x90, 0xfa, 0xb6, 0xe0, 0x54, 0x0f, 
+0x90, 0xf9, 0x61, 0xf0, 0xd3, 0x94, 0x00, 0x40, 0x02, 0xc2, 0x94, 0xe4, 0xff, 0x02, 0x2e, 0xa5, 
+0x12, 0x19, 0xa3, 0xbf, 0x01, 0x04, 0xd2, 0x93, 0x80, 0x02, 0xc2, 0x93, 0xe4, 0xff, 0x02, 0x2e, 
+0xa5, 0x90, 0xfa, 0xba, 0xe0, 0x90, 0xfa, 0xb6, 0xf0, 0x54, 0x03, 0x14, 0x60, 0x0a, 0x14, 0x60, 
+0x0f, 0x14, 0x60, 0x08, 0x24, 0x03, 0x70, 0x2b, 0xd2, 0x91, 0x80, 0x27, 0xc2, 0x91, 0x80, 0x23, 
+0x12, 0x19, 0xad, 0x12, 0x0e, 0xfe, 0x60, 0x04, 0xd2, 0x91, 0x80, 0x17, 0x90, 0xff, 0xa4, 0xe0, 
+0x44, 0x10, 0x12, 0x0e, 0xfe, 0xff, 0xbf, 0xa0, 0x04, 0xc2, 0x91, 0x80, 0x02, 0xd2, 0x91, 0x12, 
+0x19, 0xad, 0xf0, 0x90, 0xfa, 0xb6, 0xe0, 0x54, 0x0c, 0xff, 0x13, 0x13, 0x54, 0x3f, 0x14, 0x60, 
+0x0a, 0x14, 0x60, 0x0f, 0x14, 0x60, 0x08, 0x24, 0x03, 0x70, 0x2b, 0xd2, 0x92, 0x80, 0x27, 0xc2, 
+0x92, 0x80, 0x23, 0x12, 0x19, 0xb4, 0x12, 0x0f, 0x1e, 0x60, 0x04, 0xd2, 0x92, 0x80, 0x17, 0x90, 
+0xff, 0xb4, 0xe0, 0x44, 0x10, 0x12, 0x0f, 0x1e, 0xff, 0xbf, 0xa0, 0x04, 0xc2, 0x92, 0x80, 0x02, 
+0xd2, 0x92, 0x12, 0x19, 0xb4, 0xf0, 0xe4, 0xff, 0x02, 0x2e, 0xa5, 0xe5, 0x2c, 0x30, 0xe7, 0x07, 
+0xe4, 0xfd, 0x7f, 0x05, 0x02, 0x2c, 0xc0, 0x7f, 0x05, 0x02, 0x2e, 0xa5, 0x12, 0x2f, 0x76, 0x22, 
+0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xb2, 0x90, 0xfa, 0xb3, 0xe0, 0xf5, 0x40, 0xa3, 0xe0, 0xf5, 0x41, 
+0x7d, 0x01, 0x12, 0x23, 0xee, 0x90, 0xfa, 0xb3, 0xe4, 0x75, 0xf0, 0x03, 0x12, 0x14, 0x2f, 0xab, 
+0x2d, 0xaa, 0x2e, 0xa9, 0x2f, 0x22, 0xaa, 0x54, 0xa9, 0x55, 0x7b, 0xff, 0x90, 0xfa, 0xb3, 0xe0, 
+0xfc, 0xa3, 0xe0, 0xfd, 0x90, 0xfa, 0xb8, 0xe0, 0xf5, 0x50, 0x12, 0x26, 0x25, 0x75, 0x22, 0x00, 
+0x8f, 0x23, 0x22, 0x12, 0x20, 0xc5, 0x7e, 0x00, 0x8e, 0x22, 0x8f, 0x23, 0xef, 0x22, 0xf0, 0x7f, 
+0x01, 0x12, 0x11, 0x9f, 0x90, 0xff, 0xa6, 0xe0, 0x90, 0xfa, 0xb7, 0xf0, 0x54, 0xa0, 0x22, 0x12, 
+0x23, 0xee, 0x8f, 0x52, 0x7e, 0x00, 0xc3, 0xef, 0x95, 0x35, 0xee, 0x95, 0x34, 0x22, 0xf0, 0x7f, 
+0x01, 0x12, 0x11, 0x9f, 0x90, 0xff, 0xb6, 0xe0, 0x90, 0xfa, 0xb7, 0xf0, 0x54, 0xa0, 0x22, 0x75, 
+0x30, 0x00, 0x75, 0x31, 0x01, 0x02, 0x29, 0x2d, 0x90, 0xfa, 0xb5, 0xe0, 0xff, 0x02, 0x2f, 0x3b, 
+0x8e, 0x30, 0x8f, 0x31, 0x02, 0x29, 0x2d, 0x12, 0x20, 0xc5, 0x7e, 0x00, 0x8e, 0x22, 0x8f, 0x23, 
+0xef, 0x22, 0x7d, 0x01, 0x12, 0x23, 0xee, 0x90, 0xfa, 0xb0, 0xe0, 0x22, 0xef, 0x90, 0xf8, 0x04, 
+0xf0, 0x22, 0xc0, 0xa8, 0xc2, 0xaf, 0xee, 0x60, 0x0a, 0xc0, 0x05, 0x7d, 0x7f, 0xdd, 0xfe, 0xde, 
+0xfa, 0xd0, 0x05, 0xef, 0xc3, 0x94, 0x15, 0x50, 0x03, 0xd0, 0xa8, 0x22, 0x13, 0x70, 0x03, 0xd0, 
+0xa8, 0x22, 0xff, 0xd5, 0x07, 0xfd, 0xd0, 0xa8, 0x22, 0xc0, 0x00, 0xc0, 0x01, 0xc0, 0x02, 0xc0, 
+0x04, 0xc0, 0x05, 0xe5, 0x44, 0x24, 0x08, 0xf8, 0x86, 0x05, 0x53, 0x05, 0x7f, 0x7c, 0xff, 0x12, 
+0x0f, 0xfe, 0x7f, 0x00, 0x7e, 0x00, 0xe5, 0x49, 0x60, 0x46, 0xfc, 0x90, 0xf9, 0x19, 0xe0, 0x54, 
+0x7f, 0x6d, 0x70, 0x0f, 0xc0, 0x83, 0xc0, 0x82, 0xa3, 0xe0, 0xfe, 0xa3, 0xe0, 0xff, 0xa3, 0x15, 
+0x49, 0x80, 0x07, 0xa3, 0xa3, 0xa3, 0xdc, 0xe6, 0x80, 0x26, 0xdc, 0x06, 0xd0, 0x82, 0xd0, 0x83, 
+0x80, 0x1e, 0xe0, 0xf8, 0xa3, 0xe0, 0xf9, 0xa3, 0xe0, 0xfa, 0xd0, 0x82, 0xd0, 0x83, 0xe8, 0xf0, 
+0xa3, 0xe9, 0xf0, 0xa3, 0xea, 0xf0, 0xa3, 0xc0, 0x83, 0xc0, 0x82, 0xa3, 0xa3, 0xa3, 0x80, 0xda, 
+0x12, 0x10, 0x95, 0xd0, 0x05, 0xd0, 0x04, 0xd0, 0x02, 0xd0, 0x01, 0xd0, 0x00, 0x22, 0x85, 0xa8, 
+0x4a, 0x75, 0xa8, 0x88, 0xec, 0x70, 0x02, 0x7c, 0x3f, 0x8c, 0x43, 0x22, 0xe5, 0x44, 0x24, 0x08, 
+0xf8, 0x76, 0x00, 0x12, 0x10, 0xec, 0x80, 0xfb, 0xc0, 0x00, 0xc0, 0x01, 0xc0, 0x02, 0xc0, 0x04, 
+0xc0, 0x06, 0x7c, 0xff, 0x12, 0x0f, 0xfe, 0xe5, 0x49, 0x60, 0x42, 0xfe, 0x90, 0xf9, 0x19, 0xe0, 
+0x54, 0x7f, 0x6f, 0x70, 0x0b, 0xc0, 0x83, 0xc0, 0x82, 0xa3, 0xa3, 0xa3, 0x15, 0x49, 0x80, 0x07, 
+0xa3, 0xa3, 0xa3, 0xde, 0xea, 0x80, 0x26, 0xde, 0x06, 0xd0, 0x82, 0xd0, 0x83, 0x80, 0xd8, 0xe0, 
+0xf8, 0xa3, 0xe0, 0xf9, 0xa3, 0xe0, 0xfa, 0xd0, 0x82, 0xd0, 0x83, 0xe8, 0xf0, 0xa3, 0xe9, 0xf0, 
+0xa3, 0xea, 0xf0, 0xa3, 0xc0, 0x83, 0xc0, 0x82, 0xa3, 0xa3, 0xa3, 0x80, 0xda, 0x78, 0x08, 0x08, 
+0x79, 0x18, 0x09, 0x7c, 0x01, 0xe6, 0x54, 0x7f, 0x6f, 0x70, 0x06, 0x76, 0x00, 0x77, 0x00, 0x80, 
+0x06, 0x08, 0x09, 0x0c, 0xbc, 0x08, 0xee, 0x12, 0x10, 0x95, 0xd0, 0x06, 0xd0, 0x04, 0xd0, 0x02, 
+0xd0, 0x01, 0xd0, 0x00, 0x22, 0x75, 0x43, 0x00, 0x85, 0x4a, 0xa8, 0x22, 0xc0, 0xf0, 0xc0, 0x82, 
+0xc0, 0x83, 0xc3, 0xe5, 0x49, 0x24, 0xe8, 0x50, 0x05, 0x12, 0x10, 0xec, 0x80, 0xf4, 0xef, 0x60, 
+0x31, 0x90, 0x2e, 0x2c, 0xe4, 0x93, 0xc3, 0x9f, 0x40, 0x2f, 0xc0, 0x04, 0x7c, 0xff, 0x12, 0x0f, 
+0xfe, 0xd0, 0x04, 0x43, 0x07, 0x80, 0xe5, 0x49, 0x75, 0xf0, 0x03, 0xa4, 0x24, 0x19, 0xf5, 0x82, 
+0xe4, 0x34, 0xf9, 0xf5, 0x83, 0xef, 0xf0, 0xec, 0xa3, 0xf0, 0xed, 0xa3, 0xf0, 0x05, 0x49, 0x12, 
+0x10, 0x95, 0xd0, 0x83, 0xd0, 0x82, 0xd0, 0xf0, 0x22, 0x02, 0x11, 0x1a, 0xc0, 0x04, 0x7c, 0x20, 
+0xd2, 0x8c, 0xd2, 0x8d, 0xd5, 0x04, 0xfd, 0xd0, 0x04, 0x22, 0x75, 0xa8, 0x00, 0x75, 0x88, 0x00, 
+0x75, 0xb8, 0x00, 0x75, 0xf0, 0x00, 0x75, 0xd0, 0x00, 0xe4, 0xf8, 0x90, 0xf8, 0x04, 0xf0, 0x90, 
+0x00, 0x00, 0xf6, 0x08, 0xb8, 0x00, 0xfb, 0x02, 0x00, 0x00, 0xc2, 0xaf, 0xe4, 0x90, 0xff, 0x48, 
+0xf0, 0x90, 0xff, 0x50, 0xf0, 0x90, 0xff, 0x08, 0xf0, 0x90, 0xff, 0x10, 0xf0, 0x90, 0xff, 0x80, 
+0xf0, 0xa3, 0xa3, 0xf0, 0xd2, 0xb1, 0xc2, 0xb0, 0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0x62, 0x7e, 
+0xff, 0x7f, 0xff, 0x12, 0x0f, 0x62, 0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0x62, 0xd2, 0xb0, 0xd2, 
+0xb1, 0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0x62, 0x7e, 0xff, 0x7f, 0xff, 0x12, 0x0f, 0x62, 0x7e, 
+0xff, 0x7f, 0xff, 0x12, 0x0f, 0x62, 0x80, 0xcc, 0xc3, 0xee, 0x94, 0x02, 0x50, 0x04, 0x7e, 0x03, 
+0x7f, 0xe8, 0xef, 0xf4, 0xff, 0xee, 0xf4, 0xfe, 0x0f, 0xbf, 0x00, 0x01, 0x0e, 0x8f, 0x48, 0x8e, 
+0x47, 0x22, 0xc3, 0xef, 0x94, 0xbc, 0xee, 0x94, 0x02, 0x50, 0x04, 0x7e, 0x07, 0x7f, 0xd0, 0xef, 
+0xf4, 0xff, 0xee, 0xf4, 0xfe, 0x0f, 0xbf, 0x00, 0x01, 0x0e, 0x8f, 0x46, 0x8e, 0x45, 0x22, 0xef, 
+0x70, 0x01, 0x22, 0xc0, 0x00, 0xe5, 0x44, 0x24, 0x18, 0xf8, 0xa6, 0x07, 0xe5, 0x44, 0x24, 0x08, 
+0xf8, 0xc6, 0x54, 0x7f, 0xf6, 0xe6, 0x30, 0xe7, 0x03, 0xd0, 0x00, 0x22, 0x12, 0x10, 0xec, 0x80, 
 0xf4, 0xc0, 0x00, 0x7f, 0x01, 0xef, 0x24, 0x08, 0xf8, 0xe6, 0x60, 0x09, 0x0f, 0xbf, 0x08, 0xf5, 
-0x12, 0x11, 0x66, 0x80, 0xee, 0xd0, 0x00, 0x22, 0xc0, 0xf0, 0xc0, 0x82, 0xc0, 0x83, 0xc0, 0x00, 
-0xc0, 0x06, 0xc0, 0x04, 0xed, 0x24, 0x10, 0xf8, 0x76, 0x9a, 0xed, 0x75, 0xf0, 0x21, 0xa4, 0x24, 
+0x12, 0x10, 0xec, 0x80, 0xee, 0xd0, 0x00, 0x22, 0xc0, 0xf0, 0xc0, 0x82, 0xc0, 0x83, 0xc0, 0x00, 
+0xc0, 0x06, 0xc0, 0x04, 0xed, 0x24, 0x10, 0xf8, 0x76, 0xa0, 0xed, 0x75, 0xf0, 0x21, 0xa4, 0x24, 
 0x05, 0xf5, 0x82, 0xe4, 0x34, 0xf8, 0xf5, 0x83, 0xc0, 0x82, 0xc0, 0x83, 0xa3, 0xa3, 0xe4, 0x78, 
-0x0d, 0xf0, 0xa3, 0xd8, 0xfc, 0xef, 0x54, 0x7f, 0x75, 0xf0, 0x02, 0xa4, 0x24, 0x36, 0xf5, 0x82, 
-0xe5, 0xf0, 0x34, 0x30, 0xf5, 0x83, 0xe4, 0x93, 0xfe, 0x74, 0x01, 0x93, 0xfc, 0xd0, 0x83, 0xd0, 
+0x0d, 0xf0, 0xa3, 0xd8, 0xfc, 0xef, 0x54, 0x7f, 0x75, 0xf0, 0x02, 0xa4, 0x24, 0x0e, 0xf5, 0x82, 
+0xe5, 0xf0, 0x34, 0x2e, 0xf5, 0x83, 0xe4, 0x93, 0xfe, 0x74, 0x01, 0x93, 0xfc, 0xd0, 0x83, 0xd0, 
 0x82, 0xec, 0xf0, 0xa3, 0xee, 0xf0, 0xed, 0x24, 0x08, 0xf8, 0xef, 0x44, 0x80, 0xf6, 0xd0, 0x04, 
-0xd0, 0x06, 0xd0, 0x00, 0xd0, 0x83, 0xd0, 0x82, 0xd0, 0xf0, 0x22, 0x75, 0x3e, 0x00, 0x75, 0x43, 
+0xd0, 0x06, 0xd0, 0x00, 0xd0, 0x83, 0xd0, 0x82, 0xd0, 0xf0, 0x22, 0x75, 0x44, 0x00, 0x75, 0x49, 
 0x00, 0x7a, 0x08, 0x79, 0x18, 0x78, 0x08, 0x76, 0x00, 0x77, 0x00, 0x08, 0x09, 0xda, 0xf8, 0x90, 
-0xf8, 0x04, 0xe0, 0xfc, 0x90, 0x30, 0x54, 0xe4, 0x93, 0xc3, 0x9c, 0x50, 0x05, 0xe4, 0x90, 0xf8, 
+0xf8, 0x04, 0xe0, 0xfc, 0x90, 0x2e, 0x2c, 0xe4, 0x93, 0xc3, 0x9c, 0x50, 0x05, 0xe4, 0x90, 0xf8, 
 0x04, 0xf0, 0x78, 0x08, 0x74, 0x80, 0x44, 0x7f, 0xf6, 0x74, 0x01, 0x44, 0x10, 0xf5, 0x89, 0x75, 
-0xb8, 0x00, 0xd2, 0xab, 0xd2, 0xa9, 0x22, 0x75, 0x81, 0x8b, 0xd2, 0x8e, 0xd2, 0x8c, 0xd2, 0xaf, 
-0xe5, 0x43, 0x60, 0x36, 0xff, 0x90, 0xf9, 0x1b, 0xe0, 0x54, 0x80, 0x60, 0x28, 0x78, 0x08, 0x79, 
+0xb8, 0x00, 0xd2, 0xab, 0xd2, 0xa9, 0x22, 0x75, 0x81, 0x91, 0xd2, 0x8e, 0xd2, 0x8c, 0xd2, 0xaf, 
+0xe5, 0x49, 0x60, 0x36, 0xff, 0x90, 0xf9, 0x19, 0xe0, 0x54, 0x80, 0x60, 0x28, 0x78, 0x08, 0x79, 
 0x08, 0xe0, 0x54, 0x7f, 0xfa, 0x7b, 0x00, 0xe6, 0x54, 0x7f, 0xb5, 0x02, 0x02, 0x7b, 0xff, 0x08, 
-0xd9, 0xf5, 0xeb, 0x70, 0x10, 0xea, 0xf0, 0xc0, 0x07, 0x12, 0x12, 0x41, 0xad, 0x07, 0xaf, 0x02, 
-0x12, 0x12, 0x58, 0xd0, 0x07, 0xa3, 0xa3, 0xa3, 0xdf, 0xce, 0x12, 0x11, 0x66, 0x80, 0xc1, 0x8f, 
-0x24, 0x12, 0x2a, 0x06, 0x78, 0x80, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x8e, 0x83, 0x24, 0x08, 0x12, 
-0x21, 0xf3, 0xe0, 0xfd, 0x12, 0x22, 0x8a, 0x8a, 0x83, 0x24, 0x0a, 0x12, 0x21, 0xf3, 0xed, 0xf0, 
-0x12, 0x22, 0x56, 0x24, 0x07, 0x12, 0x21, 0xf3, 0xe0, 0xff, 0x12, 0x22, 0x99, 0x24, 0x09, 0x12, 
-0x21, 0xf3, 0xef, 0xf0, 0x90, 0xf9, 0x15, 0xe0, 0x30, 0xe4, 0x20, 0x08, 0x12, 0x22, 0x09, 0xc0, 
-0x83, 0xc0, 0x82, 0xa3, 0xe0, 0x25, 0xe0, 0xff, 0x05, 0x82, 0xd5, 0x82, 0x02, 0x15, 0x83, 0x15, 
-0x82, 0xe0, 0x33, 0xd0, 0x82, 0xd0, 0x83, 0xf0, 0xa3, 0xef, 0xf0, 0x78, 0x80, 0x12, 0x22, 0x09, 
-0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0xec, 0xff, 0x12, 0x22, 0x8a, 0x8a, 0x83, 0x24, 0x08, 0x12, 0x21, 
-0xf3, 0xef, 0xf0, 0xed, 0x12, 0x22, 0x99, 0x24, 0x07, 0x12, 0x21, 0xf3, 0xed, 0xf0, 0x12, 0x21, 
-0xfb, 0xe0, 0xff, 0x30, 0xe7, 0x19, 0x12, 0x22, 0x6e, 0x12, 0x21, 0xf3, 0xe0, 0x60, 0x09, 0x12, 
-0x21, 0xfb, 0xef, 0x44, 0x02, 0xf0, 0x80, 0x07, 0x12, 0x21, 0xfb, 0xef, 0x54, 0xfd, 0xf0, 0x78, 
-0x7e, 0x12, 0x22, 0x09, 0xa3, 0xa3, 0xe0, 0xff, 0x53, 0x07, 0xc7, 0x08, 0xe6, 0xfc, 0x08, 0xe6, 
-0xfd, 0x12, 0x22, 0x43, 0xa3, 0xe0, 0x30, 0xe3, 0x12, 0x8d, 0x82, 0x8c, 0x83, 0xe5, 0x82, 0x24, 
-0x05, 0x12, 0x21, 0xf3, 0xe0, 0x90, 0x31, 0x94, 0x93, 0x42, 0x07, 0x53, 0x07, 0xfb, 0x78, 0x80, 
-0xe6, 0xfc, 0x08, 0xe6, 0x8c, 0x83, 0x24, 0x06, 0x12, 0x21, 0xf3, 0xe0, 0x60, 0x03, 0x43, 0x07, 
-0x04, 0x53, 0x07, 0xfc, 0x78, 0x80, 0x12, 0x22, 0x7a, 0x24, 0x04, 0x12, 0x21, 0xf3, 0xe0, 0x42, 
-0x07, 0x43, 0x07, 0x80, 0x12, 0x22, 0x8a, 0xf5, 0x82, 0x8a, 0x83, 0xa3, 0xa3, 0xef, 0xf0, 0x12, 
-0x22, 0x99, 0x24, 0x04, 0x12, 0x21, 0xf3, 0xe0, 0xff, 0x8d, 0x82, 0x8c, 0x83, 0xa3, 0xa3, 0xe0, 
-0xfc, 0xa3, 0xe0, 0xfd, 0x30, 0xe1, 0x05, 0x53, 0x07, 0xdf, 0x80, 0x03, 0x43, 0x07, 0x20, 0xec, 
-0x30, 0xe4, 0x05, 0x53, 0x07, 0xef, 0x80, 0x03, 0x43, 0x07, 0x10, 0x12, 0x21, 0xfb, 0xe0, 0xfe, 
-0x54, 0x03, 0x60, 0x73, 0x53, 0x07, 0xdf, 0xee, 0x30, 0xe1, 0x69, 0x78, 0x80, 0x12, 0x22, 0x6f, 
-0x12, 0x21, 0xf3, 0xe0, 0x12, 0x1b, 0x4c, 0x14, 0xa6, 0x00, 0x14, 0xda, 0x01, 0x14, 0xdf, 0x03, 
-0x14, 0xda, 0x05, 0x14, 0xdf, 0x07, 0x14, 0xda, 0x09, 0x14, 0xdf, 0x0b, 0x14, 0xda, 0x0d, 0x14, 
-0xdf, 0x0f, 0x00, 0x00, 0x14, 0xe7, 0xe5, 0x24, 0x64, 0x03, 0x70, 0x21, 0x90, 0xf9, 0x15, 0xe0, 
-0x30, 0xe2, 0x0d, 0x30, 0xb4, 0x05, 0x43, 0x07, 0x02, 0x80, 0x2c, 0x53, 0x07, 0xfd, 0x80, 0x27, 
-0x30, 0x95, 0x05, 0x43, 0x07, 0x02, 0x80, 0x1f, 0x53, 0x07, 0xfd, 0x80, 0x1a, 0x30, 0x93, 0x05, 
-0x43, 0x07, 0x02, 0x80, 0x12, 0x53, 0x07, 0xfd, 0x80, 0x0d, 0x43, 0x07, 0x02, 0x80, 0x08, 0x53, 
-0x07, 0xfd, 0x80, 0x03, 0x53, 0x07, 0xfd, 0x12, 0x22, 0x78, 0x24, 0x04, 0x12, 0x21, 0xf3, 0xef, 
-0xf0, 0x8d, 0x82, 0x8c, 0x83, 0xa3, 0xa3, 0xa3, 0xe0, 0xff, 0x12, 0x21, 0xfb, 0xe0, 0xfe, 0x54, 
-0x03, 0x70, 0x03, 0x02, 0x15, 0xd7, 0xee, 0x20, 0xe1, 0x03, 0x02, 0x15, 0xd4, 0x12, 0x22, 0x6e, 
-0x12, 0x21, 0xf3, 0xe0, 0x12, 0x1b, 0x4c, 0x15, 0x36, 0x00, 0x15, 0x6c, 0x01, 0x15, 0x6c, 0x03, 
-0x15, 0xa0, 0x05, 0x15, 0xa0, 0x07, 0x15, 0x86, 0x09, 0x15, 0x86, 0x0b, 0x15, 0xba, 0x0d, 0x15, 
-0xba, 0x0f, 0x00, 0x00, 0x15, 0xd7, 0xe5, 0x24, 0x64, 0x03, 0x70, 0x23, 0x90, 0xf9, 0x15, 0xe0, 
-0x30, 0xe2, 0x0f, 0x30, 0xb1, 0x06, 0x53, 0x07, 0x7f, 0x02, 0x15, 0xd7, 0x43, 0x07, 0x80, 0x02, 
-0x15, 0xd7, 0x30, 0x94, 0x05, 0x53, 0x07, 0x7f, 0x80, 0x7d, 0x43, 0x07, 0x80, 0x80, 0x78, 0x30, 
-0x92, 0x05, 0x53, 0x07, 0x7f, 0x80, 0x70, 0x43, 0x07, 0x80, 0x80, 0x6b, 0xe5, 0x24, 0xb4, 0x03, 
-0x09, 0x90, 0xff, 0x9e, 0xe0, 0x54, 0xef, 0xf0, 0x80, 0x07, 0x90, 0xff, 0x9e, 0xe0, 0x54, 0xdf, 
-0xf0, 0x53, 0x07, 0x7f, 0x80, 0x51, 0xe5, 0x24, 0xb4, 0x03, 0x09, 0x90, 0xff, 0x9e, 0xe0, 0x44, 
-0x10, 0xf0, 0x80, 0x07, 0x90, 0xff, 0x9e, 0xe0, 0x44, 0x20, 0xf0, 0x53, 0x07, 0x7f, 0x80, 0x37, 
-0xe5, 0x24, 0xb4, 0x03, 0x09, 0x90, 0xff, 0x9e, 0xe0, 0x54, 0xef, 0xf0, 0x80, 0x07, 0x90, 0xff, 
-0x9e, 0xe0, 0x54, 0xdf, 0xf0, 0x43, 0x07, 0x80, 0x80, 0x1d, 0xe5, 0x24, 0xb4, 0x03, 0x09, 0x90, 
-0xff, 0x9e, 0xe0, 0x44, 0x10, 0xf0, 0x80, 0x07, 0x90, 0xff, 0x9e, 0xe0, 0x44, 0x20, 0xf0, 0x43, 
-0x07, 0x80, 0x80, 0x03, 0x53, 0x07, 0x7f, 0x78, 0x80, 0x12, 0x22, 0x3f, 0xe0, 0xfc, 0xa3, 0xe0, 
-0xfd, 0x30, 0xe0, 0x05, 0x43, 0x07, 0x20, 0x80, 0x03, 0x53, 0x07, 0xdf, 0xec, 0x30, 0xe3, 0x05, 
-0x43, 0x07, 0x40, 0x80, 0x03, 0x53, 0x07, 0xbf, 0xec, 0x30, 0xe0, 0x05, 0x43, 0x07, 0x10, 0x80, 
-0x03, 0x53, 0x07, 0xef, 0xed, 0x30, 0xe4, 0x05, 0x43, 0x07, 0x08, 0x80, 0x03, 0x53, 0x07, 0xf7, 
-0xed, 0x30, 0xe5, 0x05, 0x43, 0x07, 0x04, 0x80, 0x03, 0x53, 0x07, 0xfb, 0xed, 0x30, 0xe6, 0x05, 
-0x43, 0x07, 0x01, 0x80, 0x03, 0x53, 0x07, 0xfe, 0xed, 0x30, 0xe7, 0x05, 0x43, 0x07, 0x02, 0x80, 
-0x03, 0x53, 0x07, 0xfd, 0x78, 0x7e, 0x12, 0x22, 0x3f, 0xa3, 0xef, 0xf0, 0x12, 0x31, 0xc7, 0x7f, 
-0x00, 0x22, 0x90, 0xff, 0xfa, 0x74, 0x08, 0xf0, 0xa3, 0x74, 0x16, 0xf0, 0x90, 0xff, 0xf9, 0x74, 
-0x02, 0xf0, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xcc, 0xe4, 0xfd, 0x12, 0x22, 0xa0, 0x90, 0xfa, 0xcc, 
-0xe4, 0x75, 0xf0, 0x03, 0x12, 0x1a, 0x6c, 0x12, 0x18, 0xe2, 0xe5, 0x23, 0x30, 0xe7, 0x02, 0xd2, 
-0x02, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x24, 0x90, 0xfa, 0xcc, 0xe0, 0xf5, 0x2d, 0xa3, 0xe0, 0xf5, 
-0x2e, 0x7d, 0x01, 0x12, 0x25, 0xd7, 0x90, 0xfa, 0xcc, 0xe4, 0xf0, 0xa3, 0x74, 0x0b, 0xf0, 0x7b, 
-0x00, 0x7a, 0x00, 0x79, 0x23, 0x75, 0x2d, 0x00, 0xf5, 0x2e, 0x7d, 0x01, 0x12, 0x25, 0xd7, 0xe5, 
-0x23, 0x24, 0x80, 0x90, 0xff, 0xf8, 0xf0, 0xe5, 0x23, 0x64, 0x07, 0x60, 0x1e, 0xe5, 0x23, 0x64, 
-0x06, 0x60, 0x18, 0xe5, 0x23, 0x64, 0x14, 0x60, 0x12, 0xe5, 0x23, 0x64, 0x41, 0x60, 0x0c, 0xe5, 
-0x23, 0x64, 0x1a, 0x70, 0x46, 0xe5, 0x24, 0x64, 0x02, 0x70, 0x40, 0xe5, 0x23, 0xb4, 0x07, 0x16, 
-0xd2, 0x94, 0xd2, 0x95, 0xd2, 0x92, 0xd2, 0x93, 0x90, 0xf9, 0x15, 0xe0, 0x44, 0x02, 0xf0, 0xa3, 
-0xe0, 0x44, 0x02, 0xf0, 0x80, 0x1e, 0xe5, 0x23, 0xb4, 0x41, 0x12, 0x90, 0xf9, 0x15, 0xe0, 0x44, 
-0x06, 0xf0, 0xa3, 0xe0, 0x44, 0x06, 0xf0, 0xd2, 0xb1, 0xd2, 0xb4, 0x80, 0x07, 0x90, 0xf9, 0x15, 
-0xe0, 0x44, 0x01, 0xf0, 0x90, 0xf9, 0x16, 0xe0, 0x44, 0x01, 0xf0, 0xe5, 0x23, 0x64, 0x42, 0x60, 
-0x05, 0xe5, 0x23, 0xb4, 0x43, 0x0c, 0x90, 0xf9, 0x15, 0xe0, 0x44, 0x80, 0xf0, 0xa3, 0xe0, 0x44, 
-0x80, 0xf0, 0x90, 0xfa, 0xcc, 0xe4, 0xf0, 0xa3, 0x74, 0x0d, 0xf0, 0x12, 0x18, 0xe2, 0x90, 0xff, 
-0xf5, 0xe5, 0x23, 0xf0, 0xe4, 0xf5, 0x35, 0xf5, 0x33, 0xf5, 0x34, 0xf5, 0x32, 0x12, 0x1d, 0x84, 
-0x12, 0x1c, 0x30, 0x12, 0x1d, 0x8b, 0x90, 0xf9, 0x67, 0x12, 0x1b, 0x43, 0x90, 0xf9, 0x6c, 0x12, 
-0x1b, 0x43, 0x90, 0xff, 0xff, 0xe4, 0xf0, 0x90, 0xff, 0x83, 0xe0, 0xe4, 0xf0, 0x90, 0xff, 0x81, 
-0x74, 0x80, 0xf0, 0xa3, 0x74, 0x84, 0xf0, 0x90, 0xff, 0x80, 0xf0, 0xe4, 0xf5, 0x23, 0xe5, 0x23, 
-0x12, 0x1c, 0xa7, 0xf5, 0x83, 0xe4, 0xf0, 0xe5, 0x23, 0x12, 0x1c, 0xb5, 0xf5, 0x83, 0xe4, 0xf0, 
-0x05, 0x23, 0xe5, 0x23, 0xb4, 0x07, 0xe7, 0x78, 0x7a, 0x76, 0xfe, 0x08, 0x76, 0xf0, 0x90, 0x31, 
-0x4d, 0xe4, 0x93, 0xff, 0x78, 0x78, 0xf6, 0xfd, 0xad, 0x07, 0x90, 0x31, 0x5a, 0xe4, 0x93, 0xff, 
-0x08, 0xf6, 0xff, 0xed, 0x54, 0x0f, 0xfd, 0x12, 0x1c, 0x97, 0x74, 0x84, 0xf0, 0xed, 0x75, 0xf0, 
-0x08, 0xa4, 0x24, 0x47, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0xef, 0xf0, 0xc3, 0x74, 0xf0, 
-0x9f, 0x78, 0x7b, 0xf6, 0x74, 0xfe, 0x94, 0x00, 0x18, 0x12, 0x1c, 0x28, 0xce, 0xc3, 0x13, 0xce, 
-0x13, 0xd8, 0xf9, 0xff, 0xed, 0x12, 0x1c, 0xf8, 0xef, 0xf0, 0xed, 0x12, 0x1d, 0x1e, 0xe4, 0xf5, 
-0x23, 0xe5, 0x23, 0x90, 0x31, 0x47, 0x93, 0xff, 0x78, 0x78, 0xf6, 0xfd, 0xe5, 0x23, 0x25, 0xe0, 
-0x24, 0x4e, 0xf5, 0x82, 0xe4, 0x34, 0x31, 0xf5, 0x83, 0xe4, 0x93, 0x08, 0xf6, 0xed, 0x30, 0xe7, 
-0x53, 0x18, 0xe6, 0x54, 0x0f, 0xf9, 0x12, 0x1c, 0x97, 0x12, 0x1d, 0x06, 0x24, 0x47, 0xf5, 0x82, 
-0xe4, 0x34, 0xff, 0x12, 0x1c, 0x18, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xff, 0xe9, 0x12, 
-0x1c, 0xf8, 0xef, 0xf0, 0x12, 0x1c, 0x1f, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x12, 0x1d, 
-0x0b, 0x24, 0x45, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0xef, 0xf0, 0xe9, 0x12, 0x1d, 0x1e, 
-0xe9, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x46, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0x74, 0x80, 
-0xf0, 0x02, 0x18, 0xb7, 0x78, 0x78, 0xe6, 0x54, 0x0f, 0xf9, 0x12, 0x1c, 0xea, 0x12, 0x1d, 0x06, 
-0x24, 0x07, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0x12, 0x1c, 0x18, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 
-0xf9, 0x12, 0x1d, 0x0b, 0x24, 0x01, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0xef, 0xf0, 0x12, 
-0x1c, 0x1f, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x12, 0x1d, 0x0b, 0x24, 0x05, 0xf5, 0x82, 
-0xe4, 0x34, 0xff, 0xf5, 0x83, 0xef, 0xf0, 0xe9, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x02, 0xf5, 0x82, 
-0xe4, 0x34, 0xff, 0xf5, 0x83, 0xe4, 0xf0, 0xe9, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x06, 0xf5, 0x82, 
-0xe4, 0x34, 0xff, 0xf5, 0x83, 0xe4, 0xf0, 0x05, 0x23, 0xe5, 0x23, 0x64, 0x04, 0x60, 0x03, 0x02, 
-0x17, 0xe1, 0x90, 0x31, 0x4c, 0xe4, 0x93, 0xff, 0x78, 0x78, 0xf6, 0x12, 0x1c, 0xe8, 0xe4, 0xf0, 
-0x90, 0x31, 0x4b, 0x93, 0xff, 0xf6, 0x12, 0x1c, 0x95, 0xe4, 0xf0, 0x90, 0xff, 0xfd, 0x74, 0x05, 
-0xf0, 0x22, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x23, 0x90, 0xfa, 0xcc, 0xe4, 0x75, 0xf0, 0x01, 0x12, 
-0x1a, 0x82, 0x85, 0xf0, 0x2e, 0xf5, 0x2d, 0x7d, 0x01, 0x02, 0x25, 0xd7, 0xe7, 0x09, 0xf6, 0x08, 
-0xdf, 0xfa, 0x80, 0x46, 0xe7, 0x09, 0xf2, 0x08, 0xdf, 0xfa, 0x80, 0x3e, 0x88, 0x82, 0x8c, 0x83, 
-0xe7, 0x09, 0xf0, 0xa3, 0xdf, 0xfa, 0x80, 0x32, 0xe3, 0x09, 0xf6, 0x08, 0xdf, 0xfa, 0x80, 0x78, 
-0xe3, 0x09, 0xf2, 0x08, 0xdf, 0xfa, 0x80, 0x70, 0x88, 0x82, 0x8c, 0x83, 0xe3, 0x09, 0xf0, 0xa3, 
-0xdf, 0xfa, 0x80, 0x64, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0xa3, 0xf6, 0x08, 0xdf, 0xfa, 0x80, 0x58, 
-0x89, 0x82, 0x8a, 0x83, 0xe0, 0xa3, 0xf2, 0x08, 0xdf, 0xfa, 0x80, 0x4c, 0x80, 0xd2, 0x80, 0xfa, 
-0x80, 0xc6, 0x80, 0xd4, 0x80, 0x69, 0x80, 0xf2, 0x80, 0x33, 0x80, 0x10, 0x80, 0xa6, 0x80, 0xea, 
-0x80, 0x9a, 0x80, 0xa8, 0x80, 0xda, 0x80, 0xe2, 0x80, 0xca, 0x80, 0x33, 0x89, 0x82, 0x8a, 0x83, 
-0xec, 0xfa, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xcc, 0xc5, 0x83, 0xcc, 0xf0, 0xa3, 0xc8, 
-0xc5, 0x82, 0xc8, 0xcc, 0xc5, 0x83, 0xcc, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0x0d, 0x89, 0x82, 0x8a, 
-0x83, 0xe4, 0x93, 0xa3, 0xf6, 0x08, 0xdf, 0xf9, 0xec, 0xfa, 0xa9, 0xf0, 0xed, 0xfb, 0x22, 0x89, 
-0x82, 0x8a, 0x83, 0xec, 0xfa, 0xe0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xcc, 0xc5, 0x83, 0xcc, 0xf0, 
-0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xcc, 0xc5, 0x83, 0xcc, 0xdf, 0xea, 0xde, 0xe8, 0x80, 0xdb, 0x89, 
-0x82, 0x8a, 0x83, 0xe4, 0x93, 0xa3, 0xf2, 0x08, 0xdf, 0xf9, 0x80, 0xcc, 0x88, 0xf0, 0xef, 0x60, 
-0x01, 0x0e, 0x4e, 0x60, 0xc3, 0x88, 0xf0, 0xed, 0x24, 0x02, 0xb4, 0x04, 0x00, 0x50, 0xb9, 0xf5, 
-0x82, 0xeb, 0x24, 0x02, 0xb4, 0x04, 0x00, 0x50, 0xaf, 0x23, 0x23, 0x45, 0x82, 0x23, 0x90, 0x19, 
-0x4c, 0x73, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02, 0xe7, 0x22, 0xbb, 
-0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x0c, 0xe5, 0x82, 
-0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06, 0xe9, 0x25, 0x82, 0xf8, 
-0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5, 0x82, 0x29, 0xf5, 0x82, 
-0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xf0, 
-0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xf8, 0xbb, 0x01, 0x0d, 0xe5, 0x82, 
-0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe8, 0xf0, 0x22, 0x50, 0x06, 0xe9, 0x25, 0x82, 
-0xc8, 0xf6, 0x22, 0xbb, 0xfe, 0x05, 0xe9, 0x25, 0x82, 0xc8, 0xf2, 0x22, 0xc5, 0xf0, 0xf8, 0xa3, 
-0xe0, 0x28, 0xf0, 0xc5, 0xf0, 0xf8, 0xe5, 0x82, 0x15, 0x82, 0x70, 0x02, 0x15, 0x83, 0xe0, 0x38, 
-0xf0, 0x22, 0xa3, 0xf8, 0xe0, 0xc5, 0xf0, 0x25, 0xf0, 0xf0, 0xe5, 0x82, 0x15, 0x82, 0x70, 0x02, 
-0x15, 0x83, 0xe0, 0xc8, 0x38, 0xf0, 0xe8, 0x22, 0xbb, 0x01, 0x10, 0xe5, 0x82, 0x29, 0xf5, 0x82, 
-0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0xf5, 0xf0, 0xa3, 0xe0, 0x22, 0x50, 0x09, 0xe9, 0x25, 0x82, 
-0xf8, 0x86, 0xf0, 0x08, 0xe6, 0x22, 0xbb, 0xfe, 0x0a, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0xf5, 0xf0, 
-0x08, 0xe2, 0x22, 0xe5, 0x83, 0x2a, 0xf5, 0x83, 0xe9, 0x93, 0xf5, 0xf0, 0xa3, 0xe9, 0x93, 0x22, 
-0xbb, 0x01, 0x0a, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xe5, 0xf0, 0xa3, 0xf0, 0x22, 0x50, 0x06, 0xf7, 
-0x09, 0xa7, 0xf0, 0x19, 0x22, 0xbb, 0xfe, 0x06, 0xf3, 0xe5, 0xf0, 0x09, 0xf3, 0x19, 0x22, 0xf8, 
-0xbb, 0x01, 0x11, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe8, 0xf0, 0xe5, 
-0xf0, 0xa3, 0xf0, 0x22, 0x50, 0x09, 0xe9, 0x25, 0x82, 0xc8, 0xf6, 0x08, 0xa6, 0xf0, 0x22, 0xbb, 
-0xfe, 0x09, 0xe9, 0x25, 0x82, 0xc8, 0xf2, 0xe5, 0xf0, 0x08, 0xf2, 0x22, 0xa4, 0x25, 0x82, 0xf5, 
-0x82, 0xe5, 0xf0, 0x35, 0x83, 0xf5, 0x83, 0x22, 0xe6, 0xfb, 0x08, 0xe6, 0xfa, 0x08, 0xe6, 0xf9, 
-0x22, 0xeb, 0xf6, 0x08, 0xea, 0xf6, 0x08, 0xe9, 0xf6, 0x22, 0xe0, 0xfb, 0xa3, 0xe0, 0xfa, 0xa3, 
-0xe0, 0xf9, 0x22, 0xeb, 0xf0, 0xa3, 0xea, 0xf0, 0xa3, 0xe9, 0xf0, 0x22, 0xd0, 0x83, 0xd0, 0x82, 
-0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 0xf8, 0x74, 0x01, 
-0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 0xa3, 0xa3, 0xa3, 
-0x80, 0xdf, 0xab, 0x36, 0xaa, 0x37, 0xa9, 0x38, 0xe5, 0x4c, 0x12, 0x1a, 0x38, 0x74, 0x01, 0x25, 
-0x38, 0xf5, 0x38, 0xe4, 0x35, 0x37, 0xf5, 0x37, 0xab, 0x36, 0xfa, 0xa9, 0x38, 0x74, 0x11, 0x12, 
-0x1a, 0x38, 0x74, 0x01, 0x25, 0x38, 0xf5, 0x38, 0xe4, 0x35, 0x37, 0xf5, 0x37, 0x90, 0xff, 0x06, 
-0xe0, 0xab, 0x36, 0xaa, 0x37, 0xa9, 0x38, 0x12, 0x1a, 0x38, 0x74, 0x01, 0x25, 0x38, 0xf5, 0x38, 
-0xe4, 0x35, 0x37, 0xf5, 0x37, 0xab, 0x36, 0xfa, 0xa9, 0x38, 0xe4, 0x12, 0x1a, 0x38, 0x04, 0x25, 
-0x38, 0xf5, 0x38, 0xe4, 0x35, 0x37, 0xf5, 0x37, 0xab, 0x36, 0xfa, 0xa9, 0x38, 0xe4, 0x12, 0x1a, 
-0x38, 0x04, 0x25, 0x38, 0xf5, 0x38, 0xe4, 0x35, 0x37, 0xf5, 0x37, 0x90, 0xff, 0x04, 0xe0, 0xab, 
-0x36, 0xaa, 0x37, 0xa9, 0x38, 0x12, 0x1a, 0x38, 0x74, 0x01, 0x25, 0x38, 0xf5, 0x38, 0xe4, 0x35, 
-0x37, 0xf5, 0x37, 0x90, 0xff, 0x05, 0xe0, 0xab, 0x36, 0xaa, 0x37, 0xa9, 0x38, 0x12, 0x1a, 0x38, 
-0x74, 0x01, 0x25, 0x38, 0xf5, 0x38, 0xe4, 0x35, 0x37, 0xf5, 0x37, 0x22, 0xf5, 0x83, 0xe0, 0x54, 
-0x08, 0xab, 0x36, 0xaa, 0x37, 0xa9, 0x38, 0x22, 0xf5, 0x83, 0xef, 0xf0, 0xfd, 0x7c, 0x00, 0xc3, 
-0x78, 0x7b, 0xe6, 0x9d, 0xf6, 0x18, 0xe6, 0x9c, 0xf6, 0xe6, 0xfe, 0x08, 0xe6, 0x78, 0x03, 0x22, 
-0x75, 0x36, 0x01, 0x75, 0x37, 0xf9, 0x75, 0x38, 0x6f, 0x22, 0xe0, 0x44, 0x04, 0xf0, 0x74, 0x12, 
-0x2f, 0xf5, 0x82, 0xe4, 0x34, 0xf9, 0xf5, 0x83, 0xe0, 0x22, 0x90, 0xfa, 0xb9, 0xe0, 0xff, 0x7e, 
-0x00, 0xc3, 0x90, 0xfa, 0xbd, 0xe0, 0x9f, 0xf0, 0x90, 0xfa, 0xbc, 0xe0, 0x9e, 0xf0, 0x90, 0xfa, 
-0xb4, 0xee, 0x8f, 0xf0, 0x12, 0x1a, 0x6c, 0xef, 0x25, 0x4f, 0xf5, 0x4f, 0xee, 0x35, 0x4e, 0xf5, 
-0x4e, 0x22, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xb1, 0x90, 0xfa, 0xb4, 0xe0, 0xf5, 0x2d, 0xa3, 0xe0, 
-0xf5, 0x2e, 0x22, 0x78, 0x7c, 0xe6, 0xfe, 0x08, 0xe6, 0x8e, 0x83, 0x24, 0x04, 0xf5, 0x82, 0xe4, 
-0x35, 0x83, 0xf5, 0x83, 0x22, 0x54, 0x0f, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x40, 0xf5, 0x82, 0xe4, 
-0x34, 0xff, 0xf5, 0x83, 0x22, 0xe5, 0x4d, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x48, 0xf5, 0x82, 0xe4, 
-0x34, 0xff, 0x22, 0xe5, 0x4d, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x08, 0xf5, 0x82, 0xe4, 0x34, 0xff, 
-0x22, 0x90, 0xfa, 0xb6, 0xe0, 0xff, 0x24, 0xfc, 0x22, 0x90, 0xff, 0x00, 0xe0, 0x54, 0x1f, 0x22, 
-0x90, 0xfa, 0xbb, 0xe0, 0x90, 0xfa, 0xb7, 0xf0, 0x22, 0x75, 0x33, 0x00, 0x8f, 0x34, 0x90, 0xf9, 
-0x6c, 0x12, 0x1b, 0x3a, 0x90, 0x00, 0x02, 0x22, 0x54, 0x0f, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x00, 
-0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0x22, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x41, 0xf5, 0x82, 
-0xe4, 0x34, 0xff, 0xf5, 0x83, 0x22, 0x74, 0x80, 0xf0, 0x08, 0xe6, 0xff, 0xe9, 0x75, 0xf0, 0x08, 
-0xa4, 0x22, 0x74, 0xaf, 0x25, 0x22, 0xf5, 0x82, 0xe4, 0x34, 0xfa, 0xf5, 0x83, 0x22, 0x75, 0xf0, 
-0x08, 0xa4, 0x24, 0x42, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0x74, 0x80, 0xf0, 0x22, 0x90, 
-0xff, 0x82, 0xe0, 0x44, 0x08, 0xf0, 0x22, 0x90, 0xff, 0xfe, 0xe0, 0x44, 0x03, 0xf0, 0x90, 0xff, 
-0xfc, 0xe0, 0x54, 0xfd, 0xf0, 0x22, 0x78, 0x67, 0xe6, 0x54, 0xfd, 0xf6, 0x90, 0xff, 0xfd, 0x74, 
-0x65, 0xf0, 0x22, 0x12, 0x1b, 0x1c, 0xe0, 0xfe, 0xa3, 0xe0, 0xff, 0x4e, 0x22, 0x7b, 0x01, 0x7a, 
-0xfa, 0x79, 0xb4, 0x22, 0x90, 0xff, 0x80, 0xe0, 0x44, 0x08, 0xf0, 0x22, 0x90, 0xff, 0x83, 0xe0, 
-0x54, 0x7f, 0xf0, 0x22, 0xe0, 0xff, 0x90, 0xf9, 0x67, 0x02, 0x1b, 0x3a, 0x90, 0xff, 0xa4, 0xe0, 
-0x44, 0x02, 0xf0, 0x22, 0x75, 0x39, 0x01, 0x75, 0x3a, 0x09, 0x22, 0x7b, 0x01, 0x7a, 0xf9, 0x79, 
-0x6f, 0x22, 0xd3, 0xe5, 0x3c, 0x94, 0x08, 0xe5, 0x3b, 0x94, 0x01, 0x22, 0x90, 0xfa, 0xbb, 0xe0, 
-0xff, 0x90, 0xfa, 0xb7, 0xf0, 0x22, 0x90, 0xff, 0xa4, 0xe0, 0x54, 0xef, 0x22, 0x90, 0xff, 0xb4, 
-0xe0, 0x54, 0xef, 0x22, 0x12, 0x10, 0x03, 0x78, 0x88, 0xef, 0xf6, 0x12, 0x2a, 0x06, 0x12, 0x22, 
-0x4a, 0x8e, 0x83, 0x24, 0x09, 0x12, 0x21, 0xf3, 0xe0, 0xfd, 0x12, 0x22, 0x2d, 0x90, 0x00, 0x0a, 
-0x12, 0x22, 0x52, 0x24, 0x0a, 0x12, 0x21, 0xf3, 0xe0, 0x90, 0x00, 0x0b, 0x12, 0x1a, 0x4a, 0x12, 
-0x22, 0x4a, 0xf5, 0x82, 0x8e, 0x83, 0xa3, 0xa3, 0xa3, 0xe0, 0xf5, 0x53, 0x12, 0x22, 0x56, 0x24, 
-0x04, 0x12, 0x21, 0xf3, 0xe0, 0xf5, 0x54, 0x8f, 0x82, 0x8e, 0x83, 0xa3, 0xa3, 0xe0, 0xf5, 0x55, 
-0xe5, 0x53, 0xc4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x78, 0x88, 0xf6, 0xd3, 0x94, 0x00, 0x40, 0x06, 
-0xe5, 0x54, 0x30, 0xe1, 0x01, 0x06, 0x78, 0x88, 0xe6, 0x12, 0x22, 0x2c, 0x90, 0x00, 0x0c, 0xef, 
-0x12, 0x1a, 0x4a, 0x78, 0x80, 0x12, 0x22, 0x09, 0xa3, 0xa3, 0xe0, 0xfe, 0xa3, 0xe0, 0xff, 0x53, 
-0x07, 0x0c, 0x53, 0x06, 0xe6, 0xe5, 0x53, 0x30, 0xe5, 0x03, 0x43, 0x07, 0x01, 0xe5, 0x54, 0x20, 
-0xe5, 0x0e, 0xe5, 0x53, 0x54, 0x7f, 0x70, 0x08, 0xe5, 0x53, 0x20, 0xe7, 0x03, 0x43, 0x07, 0x02, 
-0xe5, 0x53, 0x30, 0xe3, 0x03, 0x43, 0x07, 0x10, 0xe5, 0x53, 0x30, 0xe2, 0x03, 0x43, 0x07, 0x20, 
-0xe5, 0x53, 0x54, 0x03, 0x60, 0x03, 0x43, 0x07, 0x40, 0xe5, 0x53, 0x30, 0xe1, 0x03, 0x43, 0x07, 
-0x80, 0xe5, 0x53, 0x30, 0xe4, 0x03, 0x43, 0x06, 0x01, 0xe5, 0x53, 0x30, 0xe6, 0x03, 0x43, 0x06, 
-0x08, 0xe5, 0x54, 0x20, 0xe4, 0x0e, 0xe5, 0x53, 0x54, 0x7f, 0x70, 0x08, 0xe5, 0x53, 0x20, 0xe7, 
-0x03, 0x43, 0x06, 0x10, 0x53, 0x07, 0xfb, 0x53, 0x06, 0x79, 0x90, 0x00, 0x05, 0xee, 0x8f, 0xf0, 
-0x12, 0x1a, 0xef, 0xe5, 0x55, 0x30, 0xe3, 0x12, 0x54, 0x30, 0xff, 0xc4, 0x54, 0x0f, 0x12, 0x22, 
-0x2c, 0x90, 0x00, 0x08, 0xef, 0x12, 0x1a, 0x4a, 0x80, 0x0a, 0x12, 0x22, 0x2d, 0x90, 0x00, 0x08, 
-0xe4, 0x12, 0x1a, 0x4a, 0xe5, 0x55, 0x54, 0x03, 0x12, 0x22, 0x2c, 0x90, 0x00, 0x07, 0xef, 0x12, 
-0x1a, 0x4a, 0xe5, 0x55, 0x54, 0x04, 0xff, 0xc3, 0x13, 0x90, 0x00, 0x09, 0x12, 0x1a, 0x4a, 0x90, 
-0x00, 0x07, 0x12, 0x1a, 0x0b, 0x70, 0x13, 0x12, 0x22, 0x2d, 0xe9, 0x24, 0x09, 0xf9, 0xe4, 0x3a, 
-0xfa, 0x12, 0x19, 0xf2, 0xff, 0xc3, 0x13, 0x12, 0x1a, 0x38, 0x12, 0x22, 0x78, 0x24, 0x08, 0x12, 
-0x21, 0xf3, 0xe0, 0xfe, 0x8d, 0x82, 0x8c, 0x83, 0xe5, 0x82, 0x24, 0x07, 0x12, 0x21, 0xf3, 0xe0, 
-0xfd, 0xee, 0xed, 0x12, 0x22, 0x2c, 0x90, 0x00, 0x03, 0xee, 0x8f, 0xf0, 0x12, 0x1a, 0xef, 0x12, 
-0x31, 0xc7, 0x7d, 0x0a, 0xe4, 0xff, 0x12, 0x2f, 0x18, 0x02, 0x10, 0x86, 0x90, 0xfa, 0xe3, 0xe0, 
-0xb4, 0x03, 0x06, 0x7e, 0x00, 0x7f, 0x40, 0x80, 0x04, 0x7e, 0x00, 0x7f, 0x08, 0x90, 0xfa, 0xd7, 
-0xee, 0xf0, 0xa3, 0xef, 0xf0, 0x90, 0x00, 0x05, 0x12, 0x1a, 0x0b, 0xff, 0x7e, 0x00, 0x90, 0xfa, 
-0xd3, 0xee, 0xf0, 0xa3, 0xef, 0xf0, 0x70, 0x03, 0x7f, 0x08, 0x22, 0x90, 0x00, 0x08, 0x12, 0x1a, 
-0x98, 0xff, 0x90, 0xfa, 0xd5, 0xe5, 0xf0, 0xf0, 0xa3, 0xef, 0xf0, 0xae, 0x02, 0xaf, 0x01, 0x8e, 
-0x50, 0x8f, 0x51, 0x74, 0x0a, 0x25, 0x51, 0xf5, 0x51, 0xe4, 0x35, 0x50, 0xf5, 0x50, 0x90, 0xfa, 
-0xd8, 0xe0, 0xff, 0x14, 0xfe, 0x90, 0xfa, 0xd6, 0xe0, 0x5e, 0xfe, 0xc3, 0xef, 0x9e, 0xff, 0x90, 
-0xfa, 0xda, 0xf0, 0xc3, 0x90, 0xfa, 0xd4, 0xe0, 0x9f, 0x90, 0xfa, 0xd3, 0xe0, 0x94, 0x00, 0x50, 
-0x06, 0xa3, 0xe0, 0x90, 0xfa, 0xda, 0xf0, 0x12, 0x1f, 0xfb, 0x60, 0x03, 0xe0, 0xff, 0x22, 0x12, 
-0x2d, 0x5a, 0x90, 0xfa, 0xd3, 0xe0, 0xfe, 0xa3, 0xe0, 0xff, 0x4e, 0x60, 0x2b, 0x90, 0xfa, 0xd7, 
-0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0xd3, 0xef, 0x9d, 0xee, 0x9c, 0x40, 0x07, 0xe0, 0x90, 0xfa, 0xda, 
-0xf0, 0x80, 0x08, 0x90, 0xfa, 0xd4, 0xe0, 0x90, 0xfa, 0xda, 0xf0, 0x12, 0x1f, 0xfb, 0x60, 0x03, 
-0xe0, 0xff, 0x22, 0x12, 0x2d, 0x5a, 0x80, 0xca, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x52, 0xe4, 0xf5, 
-0x2d, 0xf5, 0x2e, 0x7d, 0x01, 0x12, 0x25, 0xd7, 0x7f, 0x00, 0x22, 0xaa, 0x50, 0xa9, 0x51, 0x7b, 
-0x01, 0x90, 0xfa, 0xd5, 0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0x90, 0xfa, 0xda, 0xe0, 0xf5, 0x4a, 0x12, 
-0x28, 0x9f, 0x90, 0xfa, 0xd9, 0xef, 0xf0, 0x22, 0xef, 0x24, 0xae, 0x60, 0x52, 0x24, 0xfe, 0x60, 
-0x2e, 0x24, 0xfe, 0x70, 0x03, 0x02, 0x20, 0xbb, 0x24, 0x06, 0x60, 0x03, 0x02, 0x21, 0x03, 0x78, 
-0x71, 0xe6, 0x54, 0xfb, 0xf6, 0x90, 0xff, 0xa5, 0xe0, 0xf5, 0x22, 0x44, 0x0f, 0xf0, 0x74, 0x33, 
-0x90, 0xfa, 0x91, 0xf0, 0xe5, 0x22, 0xa3, 0xf0, 0x90, 0xfa, 0xaf, 0x74, 0x01, 0xf0, 0x22, 0x78, 
-0x72, 0xe6, 0x54, 0xfb, 0xf6, 0x90, 0xff, 0xb5, 0xe0, 0xf5, 0x22, 0x44, 0x0f, 0xf0, 0x74, 0x43, 
-0x90, 0xfa, 0x93, 0xf0, 0xe5, 0x22, 0xa3, 0xf0, 0x90, 0xfa, 0xb0, 0x74, 0x01, 0xf0, 0x22, 0x90, 
-0xfa, 0x9d, 0xe0, 0xa3, 0x20, 0xe5, 0x03, 0x02, 0x21, 0x03, 0x90, 0xff, 0xa6, 0xe0, 0x90, 0xfa, 
-0xca, 0xf0, 0xa3, 0xf0, 0x90, 0xfa, 0xca, 0xe0, 0xff, 0x54, 0x0f, 0xfe, 0x60, 0x10, 0x90, 0xff, 
-0xa6, 0x12, 0x22, 0x5d, 0x90, 0xff, 0xa6, 0xe0, 0x90, 0xfa, 0xca, 0xf0, 0x80, 0xe6, 0x90, 0xfa, 
-0xcb, 0xe0, 0xff, 0x74, 0x34, 0xfe, 0x12, 0x2c, 0xb4, 0xef, 0x70, 0x57, 0x90, 0xfa, 0xcb, 0xe0, 
-0xff, 0x74, 0x34, 0x90, 0xfa, 0x95, 0xf0, 0xef, 0xa3, 0xf0, 0x22, 0x90, 0xfa, 0xa7, 0xe0, 0xa3, 
-0x30, 0xe5, 0x40, 0x90, 0xff, 0xb6, 0xe0, 0x90, 0xfa, 0xca, 0xf0, 0xa3, 0xf0, 0x90, 0xfa, 0xca, 
-0xe0, 0xff, 0x54, 0x0f, 0xfe, 0x60, 0x10, 0x90, 0xff, 0xb6, 0x12, 0x22, 0x5d, 0x90, 0xff, 0xb6, 
-0xe0, 0x90, 0xfa, 0xca, 0xf0, 0x80, 0xe6, 0x90, 0xfa, 0xcb, 0xe0, 0xff, 0x74, 0x44, 0xfe, 0x12, 
-0x2c, 0xb4, 0xef, 0x70, 0x0e, 0x90, 0xfa, 0xcb, 0xe0, 0xff, 0x74, 0x44, 0x90, 0xfa, 0x97, 0xf0, 
-0xef, 0xa3, 0xf0, 0x22, 0xc0, 0xe0, 0xc0, 0xf0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0xd0, 0x75, 0xd0, 
-0x00, 0xc0, 0x00, 0xc0, 0x01, 0xc0, 0x02, 0xc0, 0x03, 0xc0, 0x04, 0xc0, 0x05, 0xc0, 0x06, 0xc0, 
-0x07, 0x90, 0xff, 0x92, 0xe0, 0xff, 0x90, 0xfa, 0xc9, 0xf0, 0x90, 0xff, 0x92, 0xe4, 0xf0, 0xef, 
-0x12, 0x1b, 0x4c, 0x21, 0xbb, 0x26, 0x21, 0xbb, 0x2e, 0x21, 0x5e, 0x30, 0x21, 0x5e, 0x32, 0x21, 
-0x6c, 0x38, 0x21, 0x7e, 0x3a, 0x21, 0xb0, 0x3e, 0x21, 0x9b, 0x44, 0x21, 0x90, 0x46, 0x21, 0xa6, 
-0x50, 0x21, 0xa6, 0x52, 0x21, 0xa6, 0x54, 0x21, 0xa6, 0x56, 0x00, 0x00, 0x21, 0xc0, 0x90, 0xfa, 
-0xc9, 0xe0, 0xfd, 0x7c, 0x00, 0x7f, 0x01, 0x12, 0x11, 0x16, 0x80, 0x62, 0x7c, 0x00, 0x7d, 0x01, 
-0x7f, 0x03, 0x12, 0x11, 0x16, 0x90, 0xff, 0xfe, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x50, 0x7c, 0x00, 
-0x7d, 0x01, 0x7f, 0x02, 0x12, 0x11, 0x16, 0x90, 0xff, 0xfe, 0xe0, 0x44, 0x40, 0xf0, 0x80, 0x3e, 
-0x7c, 0x00, 0x7d, 0x01, 0x7f, 0x05, 0x12, 0x11, 0x16, 0x80, 0x33, 0x7c, 0x00, 0x7d, 0x01, 0x7f, 
-0x06, 0x12, 0x11, 0x16, 0x80, 0x28, 0x90, 0xfa, 0xc9, 0xe0, 0xff, 0x12, 0x20, 0x18, 0x80, 0x1e, 
-0x7c, 0x00, 0x7d, 0x01, 0x7f, 0x04, 0x12, 0x11, 0x16, 0x80, 0x13, 0x12, 0x27, 0x8d, 0x80, 0x0e, 
-0x90, 0xfa, 0xc9, 0xe0, 0x24, 0x00, 0xff, 0xe4, 0x34, 0xff, 0xfe, 0x12, 0x2c, 0xb4, 0xd0, 0x07, 
-0xd0, 0x06, 0xd0, 0x05, 0xd0, 0x04, 0xd0, 0x03, 0xd0, 0x02, 0xd0, 0x01, 0xd0, 0x00, 0xd0, 0xd0, 
-0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xf0, 0xd0, 0xe0, 0x32, 0x78, 0x7c, 0xe6, 0xfe, 0x08, 0xe6, 0x24, 
-0x04, 0x8e, 0x83, 0xf5, 0x82, 0xe4, 0x35, 0x83, 0xf5, 0x83, 0x22, 0x74, 0x12, 0x25, 0x24, 0xf5, 
-0x82, 0xe4, 0x34, 0xf9, 0xf5, 0x83, 0x22, 0x78, 0x7c, 0xe6, 0xfe, 0x08, 0xe6, 0xf5, 0x82, 0x8e, 
-0x83, 0x22, 0x78, 0x80, 0xe6, 0xfe, 0x08, 0xe6, 0xaa, 0x06, 0xf8, 0xac, 0x02, 0x7d, 0x01, 0x7b, 
-0xff, 0x7a, 0x31, 0x79, 0x99, 0x7e, 0x00, 0x7f, 0x0a, 0x02, 0x19, 0xcc, 0xff, 0x90, 0xf9, 0x6c, 
-0x02, 0x1b, 0x3a, 0x90, 0xf9, 0x67, 0x12, 0x1b, 0x3a, 0x90, 0x00, 0x04, 0x02, 0x1a, 0x0b, 0xe6, 
-0xfc, 0x08, 0xe6, 0xf5, 0x82, 0x8c, 0x83, 0xa3, 0xa3, 0x22, 0x78, 0x7e, 0xe6, 0xfe, 0x08, 0xe6, 
-0xff, 0x22, 0xed, 0x12, 0x1a, 0x4a, 0x8f, 0x82, 0x8e, 0x83, 0xe5, 0x82, 0x22, 0xef, 0xf0, 0x90, 
-0xfa, 0xcb, 0xe0, 0x54, 0x0f, 0x4e, 0xfe, 0xf0, 0xef, 0x54, 0xf0, 0x4e, 0xf0, 0x22, 0x08, 0xe6, 
-0xfc, 0x08, 0xe6, 0x8c, 0x83, 0x24, 0x09, 0x22, 0x78, 0x7e, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x8c, 
-0x83, 0x22, 0xa6, 0x07, 0xe6, 0x24, 0x6e, 0xf8, 0xe6, 0x22, 0x78, 0x7e, 0xe6, 0xfa, 0x08, 0xe6, 
-0xfb, 0x22, 0x26, 0xf6, 0x18, 0xee, 0x36, 0xf6, 0x22, 0x8b, 0x82, 0x8a, 0x83, 0xe5, 0x82, 0x22, 
-0x8b, 0x25, 0x8a, 0x26, 0x89, 0x27, 0x8d, 0x28, 0x90, 0xfa, 0xcf, 0xe4, 0xf0, 0xa3, 0x74, 0x02, 
-0xf0, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xce, 0x90, 0xfa, 0xcf, 0xe0, 0xf5, 0x2d, 0xa3, 0xe0, 0xf5, 
-0x2e, 0x7d, 0x01, 0x12, 0x25, 0xd7, 0x90, 0xfa, 0xce, 0xe0, 0x65, 0x28, 0x60, 0x46, 0xa3, 0xe0, 
-0xff, 0xa3, 0xe0, 0xa3, 0xcf, 0xf0, 0xa3, 0xef, 0xf0, 0x12, 0x23, 0x2f, 0x90, 0xfa, 0xce, 0xe0, 
-0xff, 0x90, 0xfa, 0xd1, 0xe4, 0x8f, 0xf0, 0x12, 0x1a, 0x6c, 0x12, 0x23, 0x2f, 0x90, 0xfa, 0xd1, 
-0xe0, 0xff, 0xa3, 0xe0, 0x90, 0xfa, 0xcf, 0xcf, 0xf0, 0xa3, 0xef, 0xf0, 0x90, 0xfa, 0xce, 0xe0, 
-0xa3, 0x75, 0xf0, 0x00, 0x12, 0x1a, 0x6c, 0x90, 0xfa, 0xcf, 0xe4, 0x75, 0xf0, 0x04, 0x12, 0x1a, 
-0x6c, 0x02, 0x22, 0xb1, 0x90, 0xfa, 0xd0, 0xe0, 0x24, 0x01, 0xff, 0x90, 0xfa, 0xcf, 0xe0, 0x34, 
-0x00, 0xab, 0x25, 0xaa, 0x26, 0xa9, 0x27, 0x8f, 0xf0, 0x12, 0x1a, 0xd0, 0x7f, 0x00, 0x22, 0x7b, 
-0x01, 0x7a, 0xfa, 0x79, 0xce, 0x90, 0xfa, 0xcf, 0xe4, 0x75, 0xf0, 0x01, 0x12, 0x1a, 0x6c, 0x85, 
-0xf0, 0x2e, 0xf5, 0x2d, 0x7d, 0x01, 0x02, 0x25, 0xd7, 0x8f, 0x62, 0x12, 0x2a, 0x06, 0x12, 0x22, 
-0x4a, 0x8e, 0x83, 0x24, 0x0b, 0x12, 0x21, 0xf3, 0xe0, 0x54, 0xfb, 0xf0, 0x44, 0x02, 0xf0, 0x08, 
-0x12, 0x22, 0x3f, 0xe0, 0xa3, 0x30, 0xe5, 0x0c, 0x12, 0x22, 0x56, 0x24, 0x0b, 0x12, 0x21, 0xf3, 
-0xe0, 0x44, 0x01, 0xf0, 0x78, 0x7c, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0xf5, 0x82, 0x8e, 0x83, 0xe0, 
-0x54, 0xb8, 0xfd, 0xf0, 0xe5, 0x62, 0x24, 0xfe, 0x44, 0x20, 0xfc, 0x4d, 0xf0, 0xe5, 0x82, 0x24, 
-0x04, 0x12, 0x21, 0xf3, 0xe0, 0x54, 0xb8, 0xf0, 0x4c, 0xf0, 0x8f, 0x82, 0x8e, 0x83, 0xa3, 0x74, 
-0x03, 0xf0, 0x18, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x8e, 0x83, 0x24, 0x05, 0x12, 0x21, 0xf3, 0xc0, 
-0x83, 0xc0, 0x82, 0xe0, 0xfd, 0x74, 0x96, 0x25, 0x62, 0xf5, 0x82, 0xe4, 0x34, 0xfa, 0xf5, 0x83, 
-0xe0, 0x54, 0xfc, 0x44, 0x03, 0xfc, 0xed, 0x4c, 0xd0, 0x82, 0xd0, 0x83, 0xf0, 0x8f, 0x82, 0x8e, 
-0x83, 0xe0, 0x44, 0x80, 0xf0, 0xe5, 0x82, 0x24, 0x04, 0x12, 0x21, 0xf3, 0xe0, 0x44, 0x80, 0xf0, 
-0x12, 0x31, 0xc7, 0x74, 0x6e, 0x25, 0x62, 0xf8, 0x74, 0x04, 0x46, 0xf6, 0x7f, 0x00, 0x22, 0x12, 
-0x10, 0x03, 0x7f, 0x02, 0x12, 0x12, 0x19, 0x78, 0x67, 0xe6, 0x44, 0x02, 0xf6, 0xd2, 0xb0, 0xd2, 
-0xb1, 0x90, 0xf9, 0x15, 0xe0, 0x30, 0xe7, 0x07, 0x90, 0xff, 0x9e, 0xe4, 0xf0, 0x80, 0x36, 0xd2, 
-0xb3, 0x90, 0xff, 0xa4, 0xe0, 0x90, 0xfa, 0x7b, 0xf0, 0x90, 0xff, 0xb4, 0xe0, 0x90, 0xfa, 0x7c, 
-0xf0, 0x90, 0xff, 0xa2, 0xe0, 0x90, 0xfa, 0x79, 0xf0, 0x90, 0xff, 0xb2, 0xe0, 0x90, 0xfa, 0x7a, 
-0xf0, 0x90, 0xff, 0xa4, 0x74, 0x30, 0xf0, 0x90, 0xff, 0xb4, 0xf0, 0x90, 0xff, 0xa2, 0x74, 0x40, 
-0xf0, 0x90, 0xff, 0xb2, 0xf0, 0x90, 0xfa, 0xe4, 0xe5, 0xa8, 0xf0, 0x75, 0xa8, 0x81, 0x90, 0xff, 
-0x92, 0xe0, 0x60, 0x04, 0xe4, 0xf0, 0x80, 0xf6, 0x90, 0xff, 0xfd, 0x74, 0x3a, 0xf0, 0x43, 0x87, 
-0x01, 0x00, 0x00, 0x00, 0x90, 0xfa, 0x7b, 0xe0, 0x90, 0xff, 0xa4, 0xf0, 0x90, 0xfa, 0x7c, 0xe0, 
-0x90, 0xff, 0xb4, 0xf0, 0x90, 0xfa, 0x79, 0xe0, 0x90, 0xff, 0xa2, 0xf0, 0x90, 0xfa, 0x7a, 0xe0, 
-0x90, 0xff, 0xb2, 0xf0, 0x90, 0xf9, 0x17, 0xe0, 0x60, 0x02, 0xc2, 0xb3, 0x90, 0xfa, 0xe4, 0xe0, 
-0xf5, 0xa8, 0x02, 0x10, 0x86, 0x8b, 0x5c, 0x8a, 0x5d, 0x89, 0x5e, 0x12, 0x2d, 0x3c, 0x90, 0xfa, 
-0xc0, 0x12, 0x1b, 0x43, 0xaa, 0x5d, 0xa9, 0x5e, 0x90, 0xfa, 0xc3, 0x12, 0x1b, 0x43, 0x90, 0xfa, 
-0xc4, 0xe4, 0x75, 0xf0, 0x0a, 0x12, 0x1a, 0x6c, 0x90, 0xfa, 0xc3, 0x12, 0x1b, 0x3a, 0xe9, 0x24, 
-0x01, 0xf9, 0xe4, 0x3a, 0xfa, 0x90, 0xfa, 0xc6, 0x12, 0x1b, 0x43, 0xab, 0x5c, 0xaa, 0x5d, 0xa9, 
-0x5e, 0x12, 0x2d, 0x48, 0xe0, 0xff, 0xc3, 0x13, 0xf0, 0xe4, 0x78, 0x82, 0xf6, 0x90, 0xfa, 0xbe, 
-0xe0, 0xff, 0x78, 0x82, 0xe6, 0xc3, 0x9f, 0x50, 0x4a, 0x90, 0xfa, 0xc0, 0x12, 0x2d, 0x1d, 0xff, 
-0x78, 0x83, 0xf6, 0x90, 0xfa, 0xc3, 0x12, 0x2d, 0x1d, 0xfe, 0xf4, 0x5f, 0xff, 0x78, 0x83, 0xf6, 
-0x12, 0x2d, 0x1a, 0x5e, 0x4f, 0xff, 0x78, 0x83, 0xf6, 0x12, 0x2d, 0x23, 0x75, 0xf0, 0x02, 0x12, 
-0x1a, 0x6c, 0x90, 0xfa, 0xc4, 0xe4, 0x75, 0xf0, 0x02, 0x12, 0x1a, 0x6c, 0xab, 0x5c, 0xaa, 0x5d, 
-0xa9, 0x5e, 0x90, 0x00, 0x04, 0x12, 0x1a, 0x0b, 0x30, 0xe4, 0x03, 0x12, 0x2d, 0x32, 0x78, 0x82, 
-0x06, 0x80, 0xaa, 0xe4, 0x90, 0xfa, 0xbf, 0xf0, 0x22, 0x8b, 0x56, 0x8a, 0x57, 0x89, 0x58, 0x90, 
-0xfa, 0xbf, 0x74, 0x06, 0xf0, 0xe4, 0x90, 0xfa, 0xbe, 0xf0, 0x12, 0x19, 0xf2, 0x24, 0x6e, 0x60, 
-0x26, 0x14, 0x70, 0x70, 0x12, 0x2d, 0x09, 0x60, 0x09, 0x24, 0x30, 0x70, 0x12, 0x12, 0x24, 0x95, 
-0x80, 0x62, 0x12, 0x2d, 0x53, 0x12, 0x1f, 0x2c, 0x90, 0xfa, 0xbf, 0xef, 0xf0, 0x80, 0x55, 0x90, 
-0xfa, 0xbf, 0x74, 0x81, 0xf0, 0x80, 0x4d, 0x12, 0x2d, 0x09, 0x60, 0x09, 0x24, 0x30, 0x70, 0x3e, 
-0x12, 0x2c, 0x5f, 0x80, 0x3f, 0xe5, 0x58, 0x24, 0x03, 0xf9, 0xe4, 0x35, 0x57, 0xfa, 0x7b, 0x01, 
-0xc0, 0x03, 0xc0, 0x02, 0xc0, 0x01, 0x12, 0x2d, 0x53, 0x90, 0x00, 0x05, 0x12, 0x1a, 0x0b, 0xfd, 
-0x90, 0x00, 0x08, 0x12, 0x1a, 0x98, 0xf5, 0x2e, 0x85, 0xf0, 0x2d, 0xd0, 0x01, 0xd0, 0x02, 0xd0, 
-0x03, 0x12, 0x25, 0xd7, 0x90, 0xfa, 0xbe, 0xef, 0xf0, 0xe4, 0xa3, 0xf0, 0x80, 0x06, 0x90, 0xfa, 
-0xbf, 0x74, 0x81, 0xf0, 0x90, 0xfa, 0xbf, 0xe0, 0x12, 0x2d, 0x53, 0x90, 0x00, 0x02, 0x12, 0x1a, 
-0x4a, 0x90, 0xfa, 0xbe, 0xe0, 0xff, 0x22, 0x8b, 0x29, 0x8a, 0x2a, 0x89, 0x2b, 0x8d, 0x2c, 0xe5, 
-0x2c, 0x70, 0x03, 0xaf, 0x2c, 0x22, 0x12, 0x2d, 0x82, 0x70, 0x16, 0x12, 0x2d, 0xa1, 0xe5, 0x2d, 
-0x90, 0xff, 0xf1, 0xf0, 0x12, 0x31, 0x1b, 0x50, 0xf2, 0x12, 0x26, 0x64, 0x40, 0x0b, 0x7f, 0x00, 
-0x22, 0x12, 0x2d, 0xa1, 0x12, 0x26, 0x64, 0x50, 0xf8, 0x90, 0xff, 0xf3, 0x74, 0xa1, 0xf0, 0xe5, 
-0x2c, 0xb4, 0x01, 0x07, 0x90, 0xff, 0xf0, 0xe0, 0x44, 0x02, 0xf0, 0x90, 0xff, 0xf1, 0xe4, 0xf0, 
-0xf5, 0x2f, 0xe5, 0x2c, 0x14, 0xff, 0xe5, 0x2f, 0xc3, 0x9f, 0x50, 0x2a, 0x12, 0x31, 0x04, 0x40, 
-0x03, 0xaf, 0x2f, 0x22, 0xc3, 0xe5, 0x2c, 0x95, 0x2f, 0xff, 0xbf, 0x02, 0x07, 0x90, 0xff, 0xf0, 
-0xe0, 0x44, 0x02, 0xf0, 0x12, 0x2d, 0x94, 0x05, 0x2f, 0x74, 0x01, 0x25, 0x2b, 0xf5, 0x2b, 0xe4, 
-0x35, 0x2a, 0xf5, 0x2a, 0x80, 0xcc, 0x12, 0x31, 0x04, 0x40, 0x03, 0x7f, 0x18, 0x22, 0x12, 0x2d, 
-0x94, 0xaf, 0x2c, 0x22, 0x90, 0xff, 0xf1, 0xe5, 0x2e, 0xf0, 0x02, 0x31, 0x1b, 0x12, 0x10, 0x03, 
-0x78, 0x84, 0x12, 0x22, 0x82, 0x30, 0xe1, 0x08, 0x7f, 0x13, 0x12, 0x30, 0xec, 0x02, 0x26, 0xfb, 
-0x78, 0x84, 0xe6, 0xf9, 0x24, 0x12, 0x12, 0x21, 0xff, 0xe0, 0xff, 0x30, 0xe7, 0x40, 0x54, 0x03, 
-0x60, 0x1e, 0xe9, 0xb4, 0x03, 0x0d, 0x90, 0xff, 0x9e, 0xe0, 0x54, 0xfe, 0xf0, 0xe0, 0x44, 0x04, 
-0xf0, 0x80, 0x46, 0x90, 0xff, 0x9e, 0xe0, 0x54, 0xfd, 0xf0, 0xe0, 0x44, 0x08, 0xf0, 0x80, 0x39, 
-0xe9, 0xb4, 0x03, 0x0d, 0x90, 0xff, 0x9e, 0xe0, 0x54, 0xfb, 0xf0, 0xe0, 0x44, 0x01, 0xf0, 0x80, 
-0x28, 0x90, 0xff, 0x9e, 0xe0, 0x54, 0xf7, 0xf0, 0xe0, 0x44, 0x02, 0xf0, 0x80, 0x1b, 0xef, 0x54, 
-0x03, 0x60, 0x14, 0xe9, 0xb4, 0x03, 0x09, 0x90, 0xff, 0xa4, 0xe0, 0x54, 0xdf, 0xf0, 0x80, 0x07, 
-0x90, 0xff, 0xb4, 0xe0, 0x54, 0xdf, 0xf0, 0xc2, 0xb3, 0x90, 0xf9, 0x17, 0xe0, 0x04, 0xf0, 0xaf, 
-0x01, 0x12, 0x22, 0x33, 0xfd, 0x12, 0x2f, 0x49, 0x12, 0x30, 0xec, 0x02, 0x10, 0x86, 0x75, 0xa8, 
-0x40, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0x8b, 0x02, 0x27, 0x48, 0x02, 0x30, 0xcf, 
-0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6, 0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 
-0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 
-0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 
-0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x2b, 0x4c, 0xe4, 0x7e, 0x01, 0x93, 0x60, 
-0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 
-0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 
-0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 
-0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0xe4, 0xf5, 0x22, 
-0x12, 0x1d, 0x12, 0xe0, 0xb4, 0x04, 0x0d, 0xe5, 0x22, 0x24, 0x03, 0xff, 0x12, 0x2f, 0x77, 0x12, 
-0x1d, 0x12, 0xe4, 0xf0, 0x05, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x02, 0x40, 0xe3, 0xe4, 0xf5, 0x22, 
-0x75, 0xf0, 0x02, 0xe5, 0x22, 0x90, 0xfa, 0x91, 0x12, 0x1d, 0x53, 0x60, 0x2c, 0x12, 0x2c, 0xb4, 
-0xef, 0x60, 0x52, 0x75, 0xf0, 0x02, 0xe5, 0x22, 0x90, 0xfa, 0x91, 0x12, 0x1b, 0x1c, 0xe4, 0xf0, 
-0xa3, 0xf0, 0x75, 0xf0, 0x0a, 0xe5, 0x22, 0x90, 0xfa, 0x9d, 0x12, 0x1b, 0x1c, 0xe0, 0xa3, 0x30, 
-0xe6, 0x33, 0x12, 0x1d, 0x12, 0x74, 0x04, 0xf0, 0x22, 0x75, 0xf0, 0x02, 0xe5, 0x22, 0x90, 0xfa, 
-0x95, 0x12, 0x1d, 0x53, 0x60, 0x16, 0x12, 0x2c, 0xb4, 0xef, 0x60, 0x19, 0x75, 0xf0, 0x02, 0xe5, 
-0x22, 0x90, 0xfa, 0x95, 0x12, 0x1b, 0x1c, 0xe4, 0xf0, 0xa3, 0xf0, 0x22, 0x05, 0x22, 0xe5, 0x22, 
-0xc3, 0x94, 0x02, 0x40, 0x9b, 0x22, 0xe4, 0xff, 0x90, 0xff, 0x83, 0xe0, 0x54, 0x0f, 0xfe, 0xef, 
-0xc3, 0x9e, 0x50, 0x17, 0x74, 0xf0, 0x2f, 0xf5, 0x82, 0xe4, 0x34, 0xfe, 0xf5, 0x83, 0xe0, 0x12, 
-0x1c, 0x11, 0x12, 0x1a, 0x38, 0x0f, 0x12, 0x1c, 0x00, 0x80, 0xdd, 0xef, 0xfd, 0xc3, 0xe5, 0x3a, 
-0x9d, 0xf5, 0x3a, 0xe5, 0x39, 0x94, 0x00, 0xf5, 0x39, 0xd3, 0xe5, 0x3a, 0x94, 0x00, 0xe5, 0x39, 
-0x94, 0x00, 0x40, 0x06, 0xe4, 0x90, 0xff, 0x83, 0xf0, 0x22, 0x12, 0x1d, 0x2f, 0x12, 0x1d, 0x84, 
-0x12, 0x1d, 0x76, 0x12, 0x19, 0xf2, 0x24, 0x6e, 0x60, 0x1e, 0x14, 0x60, 0x1b, 0x24, 0x8e, 0x70, 
-0x2d, 0x90, 0x00, 0x01, 0x12, 0x1a, 0x0b, 0xff, 0x24, 0xfc, 0x60, 0x03, 0x04, 0x70, 0x1f, 0xef, 
-0xfd, 0x7c, 0x00, 0x7f, 0x0d, 0x02, 0x11, 0x16, 0x12, 0x1d, 0x8b, 0x12, 0x25, 0x39, 0x12, 0x1c, 
-0xd9, 0x12, 0x1a, 0x0b, 0x60, 0x03, 0x02, 0x31, 0xbd, 0xe4, 0xff, 0x12, 0x31, 0xb1, 0x22, 0x8b, 
-0x45, 0x8a, 0x46, 0x89, 0x47, 0x8c, 0x48, 0x8d, 0x49, 0xd2, 0x00, 0x12, 0x2d, 0x82, 0x70, 0x16, 
-0x12, 0x2d, 0xa1, 0xe5, 0x48, 0x90, 0xff, 0xf1, 0xf0, 0x12, 0x31, 0x1b, 0x50, 0xf2, 0x12, 0x29, 
-0x14, 0x40, 0x0b, 0x7f, 0x18, 0x22, 0x12, 0x2d, 0xa1, 0x12, 0x29, 0x14, 0x50, 0xf8, 0xe4, 0xf5, 
-0x4b, 0xe5, 0x4a, 0x14, 0xff, 0xe5, 0x4b, 0xc3, 0x9f, 0x50, 0x17, 0x12, 0x29, 0x04, 0x40, 0x03, 
-0x7f, 0x18, 0x22, 0x05, 0x4b, 0x74, 0x01, 0x25, 0x47, 0xf5, 0x47, 0xe4, 0x35, 0x46, 0xf5, 0x46, 
-0x80, 0xdf, 0x90, 0xff, 0xf0, 0xe0, 0x44, 0x01, 0xf0, 0x12, 0x29, 0x04, 0x40, 0x03, 0x7f, 0x18, 
-0x22, 0x7f, 0x00, 0x22, 0xab, 0x45, 0xaa, 0x46, 0xa9, 0x47, 0x12, 0x19, 0xf2, 0x90, 0xff, 0xf1, 
-0xf0, 0x02, 0x31, 0x1b, 0x90, 0xff, 0xf1, 0xe5, 0x49, 0xf0, 0x02, 0x31, 0x1b, 0x7b, 0x01, 0x7a, 
-0xfa, 0x79, 0xcc, 0xe4, 0xfd, 0x12, 0x22, 0xa0, 0x90, 0xfa, 0xcc, 0xe4, 0x75, 0xf0, 0x09, 0x12, 
-0x1a, 0x6c, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x23, 0x90, 0xfa, 0xcc, 0xe4, 0x75, 0xf0, 0x01, 0x12, 
-0x1a, 0x82, 0x85, 0xf0, 0x2e, 0xf5, 0x2d, 0x7d, 0x01, 0x12, 0x25, 0xd7, 0x90, 0xff, 0xf7, 0xe5, 
-0x23, 0x12, 0x29, 0x78, 0x90, 0xff, 0xf6, 0xe5, 0x23, 0xf0, 0x90, 0xfa, 0xcc, 0xe4, 0xf0, 0xa3, 
-0x74, 0x06, 0x12, 0x29, 0x78, 0xe5, 0x23, 0x30, 0xe0, 0x07, 0x90, 0xff, 0xfc, 0x74, 0x94, 0xf0, 
-0x22, 0x90, 0xff, 0xfc, 0x74, 0x90, 0xf0, 0x22, 0xf0, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x23, 0x90, 
-0xfa, 0xcc, 0xe4, 0x75, 0xf0, 0x01, 0x12, 0x1a, 0x82, 0x85, 0xf0, 0x2e, 0xf5, 0x2d, 0x7d, 0x01, 
-0x02, 0x25, 0xd7, 0x90, 0xff, 0x93, 0x74, 0x2a, 0xf0, 0x90, 0xff, 0xff, 0xe0, 0x60, 0x06, 0x90, 
-0xff, 0xfc, 0x74, 0x10, 0xf0, 0x90, 0xff, 0x91, 0xe0, 0x44, 0x90, 0xf0, 0xe4, 0x90, 0xf9, 0x15, 
-0xf0, 0xa3, 0xf0, 0x12, 0x2a, 0x78, 0x12, 0x16, 0x42, 0x12, 0x2f, 0xcd, 0x7e, 0x07, 0x7f, 0xd0, 
-0x12, 0x11, 0xe2, 0x7e, 0x0f, 0x7f, 0xa0, 0x12, 0x11, 0xfc, 0xe4, 0x78, 0x77, 0xf6, 0x78, 0x77, 
-0xe6, 0xff, 0xc3, 0x94, 0x06, 0x50, 0x0b, 0x74, 0x6e, 0x2f, 0xf8, 0xe4, 0xf6, 0x78, 0x77, 0x06, 
-0x80, 0xec, 0x7f, 0x03, 0x12, 0x2e, 0xb3, 0x90, 0xf9, 0x15, 0xe0, 0x20, 0xe4, 0x05, 0x7f, 0x04, 
-0x12, 0x2e, 0xb3, 0x90, 0xff, 0x9b, 0xe4, 0xf0, 0x90, 0xff, 0x9a, 0xf0, 0x90, 0xff, 0xe8, 0xe0, 
-0x54, 0x1f, 0xf0, 0xd2, 0xa8, 0x22, 0x15, 0x65, 0xa8, 0x65, 0xa6, 0x07, 0x30, 0x08, 0x05, 0x12, 
-0x11, 0x66, 0x80, 0xf8, 0xd2, 0x08, 0xa8, 0x65, 0xe6, 0xff, 0xb4, 0x03, 0x0f, 0x78, 0x7c, 0x76, 
-0xff, 0x08, 0x76, 0xe0, 0x08, 0x76, 0xff, 0x08, 0x76, 0xa0, 0x80, 0x0d, 0x78, 0x7c, 0x76, 0xff, 
-0x08, 0x76, 0xe2, 0x08, 0x76, 0xff, 0x08, 0x76, 0xb0, 0x78, 0x80, 0x76, 0xfa, 0x08, 0x76, 0x9b, 
-0xef, 0x24, 0xfd, 0x75, 0xf0, 0x0a, 0xa4, 0xae, 0xf0, 0x12, 0x22, 0x92, 0x7b, 0x01, 0x7a, 0xff, 
-0x79, 0x48, 0x78, 0x68, 0x12, 0x1b, 0x31, 0xa8, 0x65, 0xe6, 0x24, 0xfd, 0x75, 0xf0, 0x08, 0xa4, 
-0xff, 0xae, 0xf0, 0x78, 0x6a, 0x12, 0x22, 0x92, 0x79, 0x08, 0x78, 0x6b, 0x12, 0x1b, 0x31, 0x78, 
-0x6d, 0xef, 0x12, 0x22, 0x92, 0x05, 0x65, 0x22, 0x90, 0xff, 0xf0, 0xe0, 0x54, 0xab, 0xf0, 0xe0, 
-0x44, 0x20, 0xf0, 0x90, 0xfa, 0xe3, 0x74, 0x02, 0xf0, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xcc, 0xe4, 
-0xf5, 0x2d, 0xf5, 0x2e, 0x7d, 0x01, 0x12, 0x25, 0xd7, 0x7e, 0x00, 0x90, 0xfa, 0xe1, 0xee, 0xf0, 
-0xa3, 0xef, 0xf0, 0x64, 0x01, 0x70, 0x10, 0x90, 0xfa, 0xcc, 0xe0, 0xb4, 0x52, 0x09, 0x90, 0xf9, 
-0x15, 0xe0, 0x54, 0xef, 0xf0, 0x80, 0x29, 0x90, 0xfa, 0xe1, 0xe0, 0x70, 0x04, 0xa3, 0xe0, 0x64, 
-0x01, 0x70, 0x10, 0x90, 0xfa, 0xcc, 0xe0, 0xb4, 0x10, 0x09, 0x90, 0xf9, 0x15, 0xe0, 0x44, 0x10, 
-0xf0, 0x80, 0x0d, 0x90, 0xfa, 0xe3, 0x74, 0x03, 0xf0, 0x90, 0xf9, 0x15, 0xe0, 0x54, 0xef, 0xf0, 
-0x90, 0xff, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x22, 0x12, 0x10, 0x03, 0x78, 0x8a, 0xef, 0xf6, 0x12, 
-0x2a, 0x06, 0x12, 0x22, 0x33, 0x30, 0xe0, 0x25, 0x12, 0x22, 0x07, 0xe0, 0x54, 0x7f, 0xf0, 0x78, 
-0x6b, 0x12, 0x1b, 0x28, 0x90, 0x00, 0x02, 0x12, 0x1a, 0x0b, 0x30, 0xe7, 0x09, 0x90, 0x00, 0x02, 
-0xe4, 0x12, 0x1a, 0x4a, 0x80, 0xe9, 0x12, 0x22, 0x07, 0xe0, 0x44, 0x80, 0xf0, 0x12, 0x22, 0x33, 
-0x30, 0xe1, 0x1e, 0x12, 0x21, 0xe9, 0xe0, 0x54, 0x7f, 0xf0, 0x12, 0x31, 0x5c, 0x78, 0x68, 0x12, 
-0x1b, 0x28, 0x90, 0x00, 0x02, 0x74, 0x80, 0x12, 0x1a, 0x4a, 0x12, 0x21, 0xe9, 0xe0, 0x44, 0x80, 
-0xf0, 0x12, 0x31, 0xc7, 0xe4, 0xff, 0x12, 0x30, 0xec, 0x02, 0x10, 0x86, 0x03, 0x68, 0x01, 0xff, 
-0x48, 0x03, 0x6b, 0x01, 0xff, 0x08, 0x02, 0x66, 0x00, 0x00, 0x44, 0xfa, 0x95, 0x00, 0x00, 0x00, 
-0x00, 0x44, 0xfa, 0x91, 0x00, 0x00, 0x00, 0x00, 0x42, 0xfa, 0xaf, 0x00, 0x00, 0x42, 0xfa, 0x7b, 
-0x00, 0x00, 0x42, 0xfa, 0x79, 0x00, 0x00, 0x42, 0xf9, 0x6a, 0xff, 0xff, 0x42, 0xfa, 0x77, 0x00, 
-0x00, 0x43, 0xf9, 0x18, 0x0a, 0x32, 0x02, 0x41, 0xf9, 0x65, 0x20, 0x41, 0xf9, 0x66, 0x20, 0x41, 
-0xf9, 0x63, 0x00, 0x41, 0xf9, 0x64, 0x00, 0x44, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0xf9, 
-0x15, 0x00, 0x00, 0x41, 0xf9, 0x17, 0x00, 0x01, 0x20, 0x00, 0x41, 0xf8, 0x04, 0x00, 0x00, 0x12, 
-0x10, 0x03, 0x78, 0x85, 0xef, 0xf6, 0x12, 0x30, 0x93, 0x12, 0x30, 0xec, 0x78, 0x85, 0xe6, 0xff, 
-0x24, 0x12, 0x12, 0x21, 0xff, 0xe0, 0xfe, 0x30, 0xe7, 0x16, 0xef, 0xb4, 0x03, 0x09, 0x90, 0xff, 
-0x9e, 0xe0, 0x54, 0xfa, 0xf0, 0x80, 0x22, 0x90, 0xff, 0x9e, 0xe0, 0x54, 0xf5, 0xf0, 0x80, 0x19, 
-0xee, 0x54, 0x03, 0x60, 0x14, 0xef, 0xb4, 0x03, 0x09, 0x90, 0xff, 0xa4, 0xe0, 0x44, 0x20, 0xf0, 
-0x80, 0x07, 0x90, 0xff, 0xb4, 0xe0, 0x44, 0x20, 0xf0, 0x90, 0xf9, 0x17, 0xe0, 0x14, 0xf0, 0xe0, 
-0x70, 0x02, 0xd2, 0xb3, 0x02, 0x10, 0x86, 0x12, 0x1d, 0x6c, 0xe5, 0x3a, 0x64, 0x09, 0x70, 0x04, 
-0xe5, 0x39, 0x64, 0x01, 0x60, 0x48, 0xc3, 0xe5, 0x3a, 0x94, 0x08, 0xe5, 0x39, 0x94, 0x00, 0x40, 
-0x11, 0x7f, 0x08, 0xef, 0xe5, 0x3a, 0x94, 0x08, 0xf5, 0x3a, 0xe5, 0x39, 0x94, 0x00, 0xf5, 0x39, 
-0x80, 0x05, 0xaf, 0x3a, 0x12, 0x1d, 0x84, 0xe4, 0xfe, 0xee, 0xc3, 0x9f, 0x50, 0x19, 0x12, 0x1c, 
-0x11, 0x12, 0x19, 0xf2, 0xfd, 0x74, 0xf8, 0x2e, 0xf5, 0x82, 0xe4, 0x34, 0xfe, 0xf5, 0x83, 0xed, 
-0xf0, 0x0e, 0x12, 0x1c, 0x00, 0x80, 0xe2, 0xef, 0x54, 0x7f, 0x90, 0xff, 0x81, 0xf0, 0x22, 0x8b, 
-0x59, 0x8a, 0x5a, 0x89, 0x5b, 0x12, 0x2d, 0x48, 0x70, 0x05, 0xa3, 0x74, 0x08, 0xf0, 0x22, 0xab, 
-0x59, 0xaa, 0x5a, 0xa9, 0x5b, 0x12, 0x2d, 0x3c, 0x90, 0xfa, 0xc6, 0x12, 0x1b, 0x43, 0xe5, 0x5b, 
-0x24, 0x03, 0xf9, 0xe4, 0x35, 0x5a, 0xfa, 0x90, 0xfa, 0xc0, 0x12, 0x1b, 0x43, 0xe4, 0x90, 0xfa, 
-0xbf, 0xf0, 0x78, 0x8b, 0xf6, 0x90, 0xfa, 0xbe, 0xe0, 0xff, 0x78, 0x8b, 0xe6, 0xc3, 0x9f, 0x50, 
-0x12, 0x12, 0x2d, 0x1a, 0xff, 0x12, 0x2d, 0x23, 0x12, 0x2d, 0x36, 0x78, 0x8b, 0x06, 0x12, 0x2d, 
-0x32, 0x80, 0xe2, 0x22, 0xad, 0x07, 0xac, 0x06, 0x90, 0x31, 0x4d, 0xe4, 0x93, 0xff, 0x78, 0x74, 
-0xf6, 0x54, 0x0f, 0x12, 0x1c, 0xf8, 0xe0, 0x08, 0x76, 0x00, 0x08, 0xf6, 0x18, 0x12, 0x1c, 0x29, 
-0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0x78, 0x75, 0xee, 0xf6, 0x08, 0xef, 0xf6, 0xee, 
-0x44, 0xf8, 0x18, 0xf6, 0xef, 0x08, 0xf6, 0x90, 0xff, 0x7a, 0xe0, 0x20, 0xe7, 0x03, 0x7f, 0x00, 
-0x22, 0x78, 0x75, 0xe6, 0xfe, 0x08, 0xe6, 0xf5, 0x82, 0x8e, 0x83, 0xec, 0xf0, 0xa3, 0xed, 0xf0, 
-0x90, 0xff, 0x7a, 0x74, 0x02, 0xf0, 0x7f, 0x01, 0x22, 0xab, 0x56, 0xaa, 0x57, 0xa9, 0x58, 0x90, 
-0x00, 0x03, 0x12, 0x1a, 0x0b, 0x54, 0xf0, 0x24, 0xa0, 0x22, 0x90, 0xfa, 0xc6, 0x12, 0x1b, 0x3a, 
-0x02, 0x19, 0xf2, 0x90, 0xfa, 0xc0, 0x12, 0x1b, 0x3a, 0xef, 0x12, 0x1a, 0x38, 0x90, 0xfa, 0xc7, 
-0xe4, 0x22, 0x90, 0xfa, 0xc1, 0xe4, 0x75, 0xf0, 0x01, 0x02, 0x1a, 0x6c, 0x90, 0x00, 0x08, 0x12, 
-0x1a, 0x98, 0xaa, 0xf0, 0xf9, 0x7b, 0x01, 0x22, 0x90, 0x00, 0x05, 0x12, 0x1a, 0x0b, 0x90, 0xfa, 
-0xbe, 0xf0, 0x22, 0xab, 0x56, 0xaa, 0x57, 0xa9, 0x58, 0x22, 0x90, 0xfa, 0xda, 0xe0, 0xff, 0x7e, 
-0x00, 0xc3, 0x90, 0xfa, 0xd4, 0xe0, 0x9f, 0xf0, 0x90, 0xfa, 0xd3, 0xe0, 0x9e, 0xf0, 0x90, 0xfa, 
-0xd5, 0xee, 0x8f, 0xf0, 0x12, 0x1a, 0x6c, 0xef, 0x25, 0x51, 0xf5, 0x51, 0xee, 0x35, 0x50, 0xf5, 
-0x50, 0x22, 0x90, 0xff, 0xf0, 0xe0, 0x54, 0xfe, 0xf0, 0xe0, 0x54, 0xfd, 0xf0, 0x90, 0xfa, 0xe3, 
-0xe0, 0x64, 0x03, 0x22, 0x90, 0xff, 0xf2, 0xe0, 0xab, 0x29, 0xaa, 0x2a, 0xa9, 0x2b, 0x02, 0x1a, 
-0x38, 0x90, 0xff, 0xf3, 0x74, 0xa0, 0xf0, 0x22, 0x8f, 0x64, 0xed, 0x70, 0x0f, 0xe5, 0x64, 0xb4, 
-0x03, 0x05, 0x7f, 0x01, 0x02, 0x31, 0x32, 0x7f, 0x02, 0x02, 0x31, 0x32, 0xaf, 0x64, 0x12, 0x2a, 
-0x06, 0x74, 0x6e, 0x25, 0x64, 0xf8, 0xe6, 0x30, 0xe2, 0x0b, 0xd2, 0x09, 0x12, 0x1c, 0x83, 0xe0, 
-0x54, 0x7f, 0xf0, 0x80, 0x02, 0xc2, 0x09, 0xe5, 0x64, 0xb4, 0x03, 0x07, 0x7f, 0x81, 0x12, 0x31, 
-0x32, 0x80, 0x05, 0x7f, 0x82, 0x12, 0x31, 0x32, 0x30, 0x09, 0x07, 0x12, 0x1c, 0x83, 0xe0, 0x44, 
-0x80, 0xf0, 0x12, 0x31, 0xc7, 0x22, 0x12, 0x10, 0x03, 0x90, 0xff, 0xfd, 0xe0, 0x44, 0x60, 0xf0, 
-0xd2, 0x01, 0x90, 0xff, 0xfc, 0xe0, 0x44, 0x02, 0xf0, 0x90, 0xff, 0x00, 0xe0, 0x30, 0xe7, 0x13, 
-0x90, 0xff, 0x83, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x35, 0x80, 0x90, 0xff, 0xfc, 0xe0, 0x44, 0x01, 
-0xf0, 0x80, 0x0d, 0x12, 0x1d, 0x2f, 0x53, 0x35, 0x7f, 0x90, 0xff, 0xfc, 0xe0, 0x54, 0xfe, 0xf0, 
-0x90, 0xff, 0x81, 0xe0, 0x44, 0x80, 0xf0, 0x12, 0x02, 0xb0, 0x12, 0x1d, 0x37, 0x02, 0x10, 0x86, 
-0x12, 0x10, 0x03, 0x78, 0x89, 0xef, 0xf6, 0xd2, 0x00, 0x12, 0x2a, 0x06, 0x90, 0xf9, 0x67, 0x12, 
-0x1b, 0x3a, 0xe9, 0x24, 0x03, 0xf9, 0xe4, 0x3a, 0xfa, 0xc0, 0x02, 0x78, 0x80, 0xe6, 0xfe, 0x08, 
-0xe6, 0xaa, 0x06, 0xf8, 0xac, 0x02, 0x7d, 0x01, 0xd0, 0x02, 0x12, 0x22, 0x25, 0x12, 0x31, 0xc7, 
-0x78, 0x89, 0xe6, 0xff, 0x12, 0x13, 0x3f, 0x12, 0x30, 0xec, 0x02, 0x10, 0x86, 0x8f, 0x63, 0x12, 
-0x2a, 0x06, 0x12, 0x22, 0x07, 0xe0, 0x54, 0x3f, 0xf0, 0xe5, 0x82, 0x24, 0x04, 0x12, 0x21, 0xf3, 
-0xe0, 0x54, 0x3f, 0xf0, 0x08, 0xe6, 0xfe, 0x08, 0xe6, 0x8e, 0x83, 0x24, 0x0b, 0x12, 0x21, 0xf3, 
-0xe0, 0x54, 0xf8, 0xf0, 0x12, 0x31, 0xc7, 0x74, 0x6e, 0x25, 0x63, 0xf8, 0x74, 0xfb, 0x56, 0xf6, 
-0x7f, 0x00, 0x22, 0x8f, 0x23, 0xc2, 0x08, 0x12, 0x2a, 0x06, 0x12, 0x22, 0x12, 0x78, 0x7e, 0x12, 
-0x21, 0xeb, 0xe0, 0x44, 0x01, 0xf0, 0x12, 0x22, 0x4a, 0x12, 0x21, 0xef, 0xe0, 0x20, 0xe0, 0xf6, 
-0xef, 0x24, 0x0b, 0xf5, 0x82, 0xe4, 0x3e, 0xf5, 0x83, 0xe0, 0x54, 0xf8, 0xf0, 0x12, 0x31, 0xc7, 
-0xaf, 0x23, 0x12, 0x13, 0x3f, 0x22, 0x12, 0x10, 0x03, 0x12, 0x2a, 0x06, 0x12, 0x22, 0x4a, 0x24, 
-0x06, 0x12, 0x21, 0xf1, 0xe0, 0xfd, 0x12, 0x22, 0x2d, 0x90, 0x00, 0x03, 0x12, 0x22, 0x52, 0x24, 
-0x05, 0x12, 0x21, 0xf3, 0xe0, 0x90, 0x00, 0x04, 0x12, 0x1a, 0x4a, 0x12, 0x31, 0xc7, 0x7d, 0x02, 
-0xe4, 0xff, 0x12, 0x2f, 0x18, 0x02, 0x10, 0x86, 0xae, 0x05, 0x12, 0x1c, 0xde, 0xef, 0x12, 0x1a, 
-0x4a, 0x0e, 0x0e, 0x0e, 0xee, 0xd3, 0x95, 0x3c, 0xe4, 0x95, 0x3b, 0x40, 0x02, 0xae, 0x3c, 0xee, 
-0xd3, 0x94, 0x08, 0x74, 0x80, 0x94, 0x81, 0x40, 0x0a, 0x7e, 0x03, 0x90, 0x00, 0x02, 0x74, 0x02, 
-0x12, 0x1a, 0x4a, 0xaf, 0x06, 0x12, 0x31, 0xb1, 0x22, 0xae, 0x07, 0xed, 0x54, 0x03, 0x64, 0x01, 
-0x60, 0x03, 0x7f, 0x10, 0x22, 0xed, 0x54, 0x7c, 0xc3, 0x94, 0x04, 0x50, 0x03, 0x7f, 0x0b, 0x22, 
-0x74, 0x6e, 0x2e, 0xf8, 0x74, 0x02, 0x46, 0xf6, 0x74, 0x96, 0x2e, 0xf5, 0x82, 0xe4, 0x34, 0xfa, 
-0xf5, 0x83, 0xed, 0xf0, 0x7f, 0x00, 0x22, 0xbf, 0x03, 0x06, 0x7c, 0xff, 0x7d, 0xe0, 0x80, 0x04, 
-0x7c, 0xff, 0x7d, 0xe2, 0x8d, 0x82, 0x8c, 0x83, 0xe0, 0x44, 0x80, 0xf0, 0xe5, 0x82, 0x24, 0x04, 
-0x12, 0x21, 0xf3, 0xe0, 0x44, 0x80, 0xf0, 0x74, 0x6e, 0x2f, 0xf8, 0x74, 0x04, 0x46, 0xf6, 0x7f, 
-0x00, 0x22, 0x12, 0x10, 0x03, 0xe5, 0x3a, 0x64, 0x09, 0x70, 0x04, 0xe5, 0x39, 0x64, 0x01, 0x60, 
-0x16, 0x90, 0xff, 0x83, 0xe0, 0x54, 0x0f, 0xff, 0xc3, 0xe5, 0x3a, 0x9f, 0xe5, 0x39, 0x94, 0x00, 
-0x40, 0x05, 0x12, 0x28, 0x16, 0x80, 0x03, 0x12, 0x31, 0xbd, 0x02, 0x10, 0x86, 0x90, 0xff, 0xfc, 
-0xe0, 0x20, 0xe7, 0x1f, 0xc2, 0xaf, 0x7d, 0xff, 0xac, 0x05, 0x1d, 0xec, 0x60, 0x15, 0x7e, 0x04, 
-0x7f, 0x00, 0xef, 0x1f, 0xaa, 0x06, 0x70, 0x01, 0x1e, 0x4a, 0x60, 0xec, 0x90, 0xff, 0x92, 0xe4, 
-0xf0, 0x80, 0xef, 0x22, 0x12, 0x10, 0x03, 0x78, 0x66, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x30, 0xe0, 
-0x12, 0x30, 0xe1, 0x0f, 0x90, 0xff, 0xfc, 0xe0, 0x44, 0x20, 0xf0, 0x7f, 0x04, 0x12, 0x12, 0x19, 
-0x12, 0x1d, 0x46, 0x02, 0x10, 0x86, 0x8e, 0x5f, 0x8f, 0x60, 0xe5, 0x60, 0x15, 0x60, 0xae, 0x5f, 
-0x70, 0x02, 0x15, 0x5f, 0xd3, 0x94, 0x00, 0xee, 0x94, 0x00, 0x40, 0x09, 0x7e, 0x07, 0x7f, 0xd0, 
-0x12, 0x0f, 0xdc, 0x80, 0xe5, 0x22, 0x11, 0x94, 0x2d, 0xf6, 0x23, 0xef, 0x31, 0xa3, 0x2f, 0xf4, 
-0x2f, 0xa2, 0x30, 0xb2, 0x2e, 0xe6, 0x26, 0x6d, 0x2b, 0xaf, 0x30, 0x55, 0x30, 0x74, 0x1d, 0xb4, 
-0x2e, 0x40, 0x2a, 0xe8, 0x0e, 0x12, 0x10, 0x03, 0x78, 0x86, 0x12, 0x22, 0x82, 0x20, 0xe1, 0x07, 
-0x7f, 0x12, 0x12, 0x30, 0xec, 0x80, 0x0a, 0x78, 0x86, 0xe6, 0xff, 0x12, 0x23, 0x49, 0x12, 0x30, 
-0xec, 0x02, 0x10, 0x86, 0x12, 0x10, 0x03, 0x78, 0x87, 0x12, 0x22, 0x82, 0x20, 0xe2, 0x07, 0x7f, 
-0x11, 0x12, 0x30, 0xec, 0x80, 0x0a, 0x78, 0x87, 0xe6, 0xff, 0x12, 0x2e, 0x7d, 0x12, 0x30, 0xec, 
-0x02, 0x10, 0x86, 0x8f, 0x61, 0x12, 0x2e, 0x7d, 0xaf, 0x61, 0x12, 0x2a, 0x06, 0x12, 0x22, 0x12, 
-0x12, 0x31, 0xc7, 0x74, 0x6e, 0x25, 0x61, 0xf8, 0x74, 0xfd, 0x56, 0xf6, 0xaf, 0x61, 0x12, 0x13, 
-0x3f, 0x22, 0x12, 0x10, 0x03, 0xe5, 0x3a, 0x64, 0x09, 0x70, 0x04, 0xe5, 0x39, 0x64, 0x01, 0x60, 
-0x05, 0x12, 0x2c, 0x07, 0x80, 0x06, 0x12, 0x1d, 0x64, 0x12, 0x1d, 0x6c, 0x02, 0x10, 0x86, 0x12, 
-0x29, 0x93, 0x12, 0x12, 0xbb, 0x90, 0xf8, 0x04, 0xe0, 0xff, 0x60, 0x05, 0x7d, 0x01, 0x12, 0x12, 
-0x58, 0x12, 0x29, 0x1d, 0x12, 0x12, 0xf7, 0x12, 0x11, 0x74, 0x80, 0xe3, 0x12, 0x1c, 0xde, 0xef, 
-0x12, 0x1a, 0x4a, 0xe4, 0xf5, 0x33, 0xf5, 0x34, 0xef, 0x60, 0x03, 0x02, 0x31, 0xbd, 0xe4, 0xff, 
-0x12, 0x31, 0xb1, 0x22, 0x90, 0xff, 0xf0, 0xe0, 0xff, 0x54, 0xa0, 0x60, 0xf7, 0xef, 0x30, 0xe5, 
-0x08, 0x90, 0xff, 0xf0, 0x44, 0x20, 0xf0, 0xc3, 0x22, 0xd3, 0x22, 0x90, 0xff, 0xf0, 0xe0, 0xff, 
-0x54, 0x28, 0x60, 0xf7, 0xef, 0x30, 0xe5, 0x08, 0x90, 0xff, 0xf0, 0x44, 0x20, 0xf0, 0xc3, 0x22, 
-0xd3, 0x22, 0xef, 0x30, 0xe7, 0x08, 0x12, 0x1c, 0x95, 0xe0, 0x54, 0xdf, 0xf0, 0x22, 0xef, 0x12, 
-0x1c, 0xe8, 0xe0, 0x54, 0xdf, 0xf0, 0x22, 0x81, 0x01, 0x82, 0x02, 0x83, 0x03, 0x87, 0x40, 0x00, 
-0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x08, 0x00, 0x78, 0x7e, 0x12, 0x22, 
-0x09, 0xa3, 0xa3, 0xe0, 0xff, 0x30, 0xe7, 0x06, 0x54, 0x7f, 0xf0, 0x44, 0x80, 0xf0, 0x22, 0x85, 
-0x3b, 0x39, 0x85, 0x3c, 0x3a, 0x90, 0xff, 0x82, 0xe0, 0x54, 0xf7, 0xf0, 0xa3, 0xe0, 0x54, 0x7f, 
-0xf0, 0x22, 0xe4, 0xfe, 0xee, 0x90, 0x31, 0x47, 0x93, 0xb5, 0x07, 0x02, 0xd3, 0x22, 0x0e, 0xbe, 
-0x07, 0xf2, 0xc3, 0x22, 0x00, 0x08, 0x18, 0x28, 0x38, 0x01, 0x81, 0x10, 0x0a, 0x02, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x12, 0x10, 0x03, 0x7f, 0x02, 0x12, 0x10, 0x92, 0x12, 0x1d, 0x46, 0x02, 0x10, 
-0x86, 0x75, 0x39, 0x00, 0x8f, 0x3a, 0x12, 0x1c, 0x30, 0x12, 0x2c, 0x07, 0x22, 0x12, 0x1d, 0x6c, 
-0x12, 0x1d, 0x2f, 0x12, 0x1d, 0x64, 0x22, 0xc2, 0x08, 0x22, 
+0xd9, 0xf5, 0xeb, 0x70, 0x10, 0xea, 0xf0, 0xc0, 0x07, 0x12, 0x11, 0xc1, 0xad, 0x07, 0xaf, 0x02, 
+0x12, 0x11, 0xd8, 0xd0, 0x07, 0xa3, 0xa3, 0xa3, 0xdf, 0xce, 0x12, 0x10, 0xec, 0x80, 0xc1, 0xe7, 
+0x09, 0xf6, 0x08, 0xdf, 0xfa, 0x80, 0x46, 0xe7, 0x09, 0xf2, 0x08, 0xdf, 0xfa, 0x80, 0x3e, 0x88, 
+0x82, 0x8c, 0x83, 0xe7, 0x09, 0xf0, 0xa3, 0xdf, 0xfa, 0x80, 0x32, 0xe3, 0x09, 0xf6, 0x08, 0xdf, 
+0xfa, 0x80, 0x78, 0xe3, 0x09, 0xf2, 0x08, 0xdf, 0xfa, 0x80, 0x70, 0x88, 0x82, 0x8c, 0x83, 0xe3, 
+0x09, 0xf0, 0xa3, 0xdf, 0xfa, 0x80, 0x64, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0xa3, 0xf6, 0x08, 0xdf, 
+0xfa, 0x80, 0x58, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0xa3, 0xf2, 0x08, 0xdf, 0xfa, 0x80, 0x4c, 0x80, 
+0xd2, 0x80, 0xfa, 0x80, 0xc6, 0x80, 0xd4, 0x80, 0x69, 0x80, 0xf2, 0x80, 0x33, 0x80, 0x10, 0x80, 
+0xa6, 0x80, 0xea, 0x80, 0x9a, 0x80, 0xa8, 0x80, 0xda, 0x80, 0xe2, 0x80, 0xca, 0x80, 0x33, 0x89, 
+0x82, 0x8a, 0x83, 0xec, 0xfa, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xcc, 0xc5, 0x83, 0xcc, 
+0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xcc, 0xc5, 0x83, 0xcc, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0x0d, 
+0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0xa3, 0xf6, 0x08, 0xdf, 0xf9, 0xec, 0xfa, 0xa9, 0xf0, 0xed, 
+0xfb, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xec, 0xfa, 0xe0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xcc, 0xc5, 
+0x83, 0xcc, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xcc, 0xc5, 0x83, 0xcc, 0xdf, 0xea, 0xde, 0xe8, 
+0x80, 0xdb, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0xa3, 0xf2, 0x08, 0xdf, 0xf9, 0x80, 0xcc, 0x88, 
+0xf0, 0xef, 0x60, 0x01, 0x0e, 0x4e, 0x60, 0xc3, 0x88, 0xf0, 0xed, 0x24, 0x02, 0xb4, 0x04, 0x00, 
+0x50, 0xb9, 0xf5, 0x82, 0xeb, 0x24, 0x02, 0xb4, 0x04, 0x00, 0x50, 0xaf, 0x23, 0x23, 0x45, 0x82, 
+0x23, 0x90, 0x13, 0x0f, 0x73, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x02, 
+0xe7, 0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 
+0x0c, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0x22, 0x50, 0x06, 0xe9, 
+0x25, 0x82, 0xf8, 0xe6, 0x22, 0xbb, 0xfe, 0x06, 0xe9, 0x25, 0x82, 0xf8, 0xe2, 0x22, 0xe5, 0x82, 
+0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 
+0x8a, 0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22, 0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xf8, 0xbb, 0x01, 
+0x0d, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe8, 0xf0, 0x22, 0x50, 0x06, 
+0xe9, 0x25, 0x82, 0xc8, 0xf6, 0x22, 0xbb, 0xfe, 0x05, 0xe9, 0x25, 0x82, 0xc8, 0xf2, 0x22, 0xc5, 
+0xf0, 0xf8, 0xa3, 0xe0, 0x28, 0xf0, 0xc5, 0xf0, 0xf8, 0xe5, 0x82, 0x15, 0x82, 0x70, 0x02, 0x15, 
+0x83, 0xe0, 0x38, 0xf0, 0x22, 0xa3, 0xf8, 0xe0, 0xc5, 0xf0, 0x25, 0xf0, 0xf0, 0xe5, 0x82, 0x15, 
+0x82, 0x70, 0x02, 0x15, 0x83, 0xe0, 0xc8, 0x38, 0xf0, 0xe8, 0x22, 0xbb, 0x01, 0x10, 0xe5, 0x82, 
+0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 0xe0, 0xf5, 0xf0, 0xa3, 0xe0, 0x22, 0x50, 0x09, 
+0xe9, 0x25, 0x82, 0xf8, 0x86, 0xf0, 0x08, 0xe6, 0x22, 0xbb, 0xfe, 0x0a, 0xe9, 0x25, 0x82, 0xf8, 
+0xe2, 0xf5, 0xf0, 0x08, 0xe2, 0x22, 0xe5, 0x83, 0x2a, 0xf5, 0x83, 0xe9, 0x93, 0xf5, 0xf0, 0xa3, 
+0xe9, 0x93, 0x22, 0xbb, 0x01, 0x0a, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xe5, 0xf0, 0xa3, 0xf0, 0x22, 
+0x50, 0x06, 0xf7, 0x09, 0xa7, 0xf0, 0x19, 0x22, 0xbb, 0xfe, 0x06, 0xf3, 0xe5, 0xf0, 0x09, 0xf3, 
+0x19, 0x22, 0xf8, 0xbb, 0x01, 0x11, 0xe5, 0x82, 0x29, 0xf5, 0x82, 0xe5, 0x83, 0x3a, 0xf5, 0x83, 
+0xe8, 0xf0, 0xe5, 0xf0, 0xa3, 0xf0, 0x22, 0x50, 0x09, 0xe9, 0x25, 0x82, 0xc8, 0xf6, 0x08, 0xa6, 
+0xf0, 0x22, 0xbb, 0xfe, 0x09, 0xe9, 0x25, 0x82, 0xc8, 0xf2, 0xe5, 0xf0, 0x08, 0xf2, 0x22, 0xa4, 
+0x25, 0x82, 0xf5, 0x82, 0xe5, 0xf0, 0x35, 0x83, 0xf5, 0x83, 0x22, 0xe6, 0xfb, 0x08, 0xe6, 0xfa, 
+0x08, 0xe6, 0xf9, 0x22, 0xeb, 0xf6, 0x08, 0xea, 0xf6, 0x08, 0xe9, 0xf6, 0x22, 0xe0, 0xfb, 0xa3, 
+0xe0, 0xfa, 0xa3, 0xe0, 0xf9, 0x22, 0xeb, 0xf0, 0xa3, 0xea, 0xf0, 0xa3, 0xe9, 0xf0, 0x22, 0xd0, 
+0x83, 0xd0, 0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, 0xa3, 0x93, 
+0xf8, 0x74, 0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xef, 
+0xa3, 0xa3, 0xa3, 0x80, 0xdf, 0x90, 0xff, 0xfa, 0x74, 0x08, 0xf0, 0xa3, 0x74, 0x16, 0xf0, 0x90, 
+0xff, 0xf9, 0x74, 0x02, 0xf0, 0x90, 0xfa, 0xcb, 0xe4, 0xf0, 0xa3, 0x74, 0x0b, 0xf0, 0x7b, 0x00, 
+0x7a, 0x00, 0x79, 0x37, 0x75, 0x40, 0x00, 0xf5, 0x41, 0x7d, 0x01, 0x12, 0x23, 0xee, 0xe5, 0x37, 
+0x24, 0x80, 0x90, 0xff, 0xf8, 0xf0, 0xe5, 0x37, 0x64, 0x07, 0x60, 0x0b, 0xe5, 0x37, 0x64, 0x06, 
+0x60, 0x05, 0xe5, 0x37, 0xb4, 0x14, 0x1b, 0xd2, 0x94, 0xd2, 0x95, 0xd2, 0x92, 0xd2, 0x93, 0xe5, 
+0x37, 0xb4, 0x07, 0x08, 0x90, 0xf9, 0x65, 0x74, 0x02, 0xf0, 0x80, 0x06, 0x90, 0xf9, 0x65, 0x74, 
+0x01, 0xf0, 0x90, 0xfa, 0xcb, 0xe4, 0xf0, 0xa3, 0x74, 0x0d, 0xf0, 0x12, 0x17, 0x71, 0x90, 0xff, 
+0xf5, 0xe5, 0x37, 0xf0, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xcb, 0xe4, 0xfd, 0x12, 0x20, 0xc5, 0x90, 
+0xfa, 0xcb, 0xe4, 0x75, 0xf0, 0x03, 0x12, 0x14, 0x2f, 0x12, 0x17, 0x71, 0xe5, 0x37, 0x30, 0xe7, 
+0x02, 0xd2, 0x02, 0xe4, 0xf5, 0x2c, 0xf5, 0x2a, 0xf5, 0x2b, 0xf5, 0x29, 0x12, 0x19, 0x92, 0x12, 
+0x18, 0x49, 0x12, 0x19, 0x6c, 0x90, 0xf9, 0x66, 0x12, 0x15, 0x06, 0x90, 0xf9, 0x6b, 0x12, 0x15, 
+0x06, 0x90, 0xff, 0xff, 0xe4, 0xf0, 0x90, 0xff, 0x83, 0xe0, 0xe4, 0xf0, 0x90, 0xff, 0x81, 0x74, 
+0x80, 0xf0, 0xa3, 0x74, 0x84, 0xf0, 0x90, 0xff, 0x80, 0xf0, 0xe4, 0xf5, 0x37, 0xe5, 0x37, 0x12, 
+0x18, 0xbf, 0xf5, 0x83, 0xe4, 0xf0, 0xe5, 0x37, 0x12, 0x18, 0xcd, 0xf5, 0x83, 0xe4, 0xf0, 0x05, 
+0x37, 0xe5, 0x37, 0xb4, 0x07, 0xe7, 0x78, 0x80, 0x76, 0xfe, 0x08, 0x76, 0xf0, 0x90, 0x2f, 0x06, 
+0xe4, 0x93, 0xff, 0x78, 0x7e, 0xf6, 0xfd, 0xad, 0x07, 0x90, 0x2f, 0x13, 0xe4, 0x93, 0xff, 0x08, 
+0xf6, 0xff, 0xed, 0x54, 0x0f, 0xfd, 0x12, 0x18, 0xaf, 0x74, 0x84, 0xf0, 0xed, 0x75, 0xf0, 0x08, 
+0xa4, 0x24, 0x47, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0xef, 0xf0, 0xc3, 0x74, 0xf0, 0x9f, 
+0x78, 0x81, 0xf6, 0x74, 0xfe, 0x94, 0x00, 0x18, 0x12, 0x18, 0x41, 0xce, 0xc3, 0x13, 0xce, 0x13, 
+0xd8, 0xf9, 0xff, 0xed, 0x12, 0x19, 0x07, 0xef, 0xf0, 0xed, 0x12, 0x19, 0x2d, 0xe4, 0xf5, 0x37, 
+0xe5, 0x37, 0x90, 0x2f, 0x00, 0x93, 0xff, 0x78, 0x7e, 0xf6, 0xfd, 0xe5, 0x37, 0x25, 0xe0, 0x24, 
+0x07, 0xf5, 0x82, 0xe4, 0x34, 0x2f, 0xf5, 0x83, 0xe4, 0x93, 0x08, 0xf6, 0xed, 0x30, 0xe7, 0x53, 
+0x18, 0xe6, 0x54, 0x0f, 0xf9, 0x12, 0x18, 0xaf, 0x12, 0x19, 0x15, 0x24, 0x47, 0xf5, 0x82, 0xe4, 
+0x34, 0xff, 0x12, 0x18, 0x31, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xff, 0xe9, 0x12, 0x19, 
+0x07, 0xef, 0xf0, 0x12, 0x18, 0x38, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x12, 0x19, 0x1a, 
+0x24, 0x45, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0xef, 0xf0, 0xe9, 0x12, 0x19, 0x2d, 0xe9, 
+0x75, 0xf0, 0x08, 0xa4, 0x24, 0x46, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0x74, 0x80, 0xf0, 
+0x02, 0x17, 0x46, 0x78, 0x7e, 0xe6, 0x54, 0x0f, 0xf9, 0x12, 0x18, 0xf9, 0x12, 0x19, 0x15, 0x24, 
+0x07, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0x12, 0x18, 0x31, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 
+0x12, 0x19, 0x1a, 0x24, 0x01, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0xef, 0xf0, 0x12, 0x18, 
+0x38, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x12, 0x19, 0x1a, 0x24, 0x05, 0xf5, 0x82, 0xe4, 
+0x34, 0xff, 0xf5, 0x83, 0xef, 0xf0, 0xe9, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x02, 0xf5, 0x82, 0xe4, 
+0x34, 0xff, 0xf5, 0x83, 0xe4, 0xf0, 0xe9, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x06, 0xf5, 0x82, 0xe4, 
+0x34, 0xff, 0xf5, 0x83, 0xe4, 0xf0, 0x05, 0x37, 0xe5, 0x37, 0x64, 0x04, 0x60, 0x03, 0x02, 0x16, 
+0x70, 0x90, 0x2f, 0x05, 0xe4, 0x93, 0xff, 0x78, 0x7e, 0xf6, 0x12, 0x18, 0xf7, 0xe4, 0xf0, 0x90, 
+0x2f, 0x04, 0x93, 0xff, 0xf6, 0x12, 0x18, 0xad, 0xe4, 0xf0, 0x90, 0xff, 0xfd, 0x74, 0x05, 0xf0, 
+0x22, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x37, 0x90, 0xfa, 0xcb, 0xe4, 0x75, 0xf0, 0x01, 0x12, 0x14, 
+0x45, 0x85, 0xf0, 0x41, 0xf5, 0x40, 0x7d, 0x01, 0x02, 0x23, 0xee, 0xab, 0x2d, 0xaa, 0x2e, 0xa9, 
+0x2f, 0xe5, 0x52, 0x12, 0x13, 0xfb, 0x74, 0x01, 0x25, 0x2f, 0xf5, 0x2f, 0xe4, 0x35, 0x2e, 0xf5, 
+0x2e, 0xab, 0x2d, 0xfa, 0xa9, 0x2f, 0x74, 0x11, 0x12, 0x13, 0xfb, 0x74, 0x01, 0x25, 0x2f, 0xf5, 
+0x2f, 0xe4, 0x35, 0x2e, 0xf5, 0x2e, 0x90, 0xff, 0x06, 0xe0, 0xab, 0x2d, 0xaa, 0x2e, 0xa9, 0x2f, 
+0x12, 0x13, 0xfb, 0x74, 0x01, 0x25, 0x2f, 0xf5, 0x2f, 0xe4, 0x35, 0x2e, 0xf5, 0x2e, 0xab, 0x2d, 
+0xfa, 0xa9, 0x2f, 0xe4, 0x12, 0x13, 0xfb, 0x04, 0x25, 0x2f, 0xf5, 0x2f, 0xe4, 0x35, 0x2e, 0xf5, 
+0x2e, 0xab, 0x2d, 0xfa, 0xa9, 0x2f, 0xe4, 0x12, 0x13, 0xfb, 0x04, 0x25, 0x2f, 0xf5, 0x2f, 0xe4, 
+0x35, 0x2e, 0xf5, 0x2e, 0x90, 0xff, 0x04, 0xe0, 0xab, 0x2d, 0xaa, 0x2e, 0xa9, 0x2f, 0x12, 0x13, 
+0xfb, 0x74, 0x01, 0x25, 0x2f, 0xf5, 0x2f, 0xe4, 0x35, 0x2e, 0xf5, 0x2e, 0x90, 0xff, 0x05, 0xe0, 
+0xab, 0x2d, 0xaa, 0x2e, 0xa9, 0x2f, 0x12, 0x13, 0xfb, 0x74, 0x01, 0x25, 0x2f, 0xf5, 0x2f, 0xe4, 
+0x35, 0x2e, 0xf5, 0x2e, 0x22, 0xf5, 0x83, 0xe0, 0x54, 0x08, 0xab, 0x2d, 0xaa, 0x2e, 0xa9, 0x2f, 
+0x22, 0xf5, 0x83, 0xef, 0xf0, 0xfd, 0x7c, 0x00, 0xc3, 0x78, 0x81, 0xe6, 0x9d, 0xf6, 0x18, 0xe6, 
+0x9c, 0xf6, 0xe6, 0xfe, 0x08, 0xe6, 0x78, 0x03, 0x22, 0x75, 0x2d, 0x01, 0x75, 0x2e, 0xf9, 0x75, 
+0x2f, 0x6e, 0x22, 0x90, 0xfa, 0xba, 0xe0, 0x90, 0xfa, 0xb6, 0xf0, 0x90, 0xfa, 0xb5, 0xe0, 0x24, 
+0xfc, 0x22, 0x90, 0xfa, 0xb8, 0xe0, 0xff, 0x7e, 0x00, 0xc3, 0x90, 0xfa, 0xbc, 0xe0, 0x9f, 0xf0, 
+0x90, 0xfa, 0xbb, 0xe0, 0x9e, 0xf0, 0x90, 0xfa, 0xb3, 0xee, 0x8f, 0xf0, 0x12, 0x14, 0x2f, 0xef, 
+0x25, 0x55, 0xf5, 0x55, 0xee, 0x35, 0x54, 0xf5, 0x54, 0x22, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xb0, 
+0x90, 0xfa, 0xb3, 0xe0, 0xf5, 0x40, 0xa3, 0xe0, 0xf5, 0x41, 0x22, 0x78, 0x82, 0xe6, 0xfe, 0x08, 
+0xe6, 0x8e, 0x83, 0x24, 0x04, 0xf5, 0x82, 0xe4, 0x35, 0x83, 0xf5, 0x83, 0x22, 0x54, 0x0f, 0x75, 
+0xf0, 0x08, 0xa4, 0x24, 0x40, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0x22, 0xe5, 0x53, 0x75, 
+0xf0, 0x08, 0xa4, 0x24, 0x48, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0x22, 0xe5, 0x53, 0x75, 0xf0, 0x08, 
+0xa4, 0x24, 0x08, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0x22, 0x90, 0xff, 0x00, 0xe0, 0x54, 0x1f, 0x22, 
+0x90, 0xfa, 0xb5, 0xe0, 0xff, 0x24, 0xfc, 0x22, 0x75, 0x2a, 0x00, 0x8f, 0x2b, 0x90, 0xf9, 0x6b, 
+0x12, 0x14, 0xfd, 0x90, 0x00, 0x02, 0x22, 0x54, 0x0f, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x00, 0xf5, 
+0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0x22, 0x75, 0xf0, 0x08, 0xa4, 0x24, 0x41, 0xf5, 0x82, 0xe4, 
+0x34, 0xff, 0xf5, 0x83, 0x22, 0x74, 0x80, 0xf0, 0x08, 0xe6, 0xff, 0xe9, 0x75, 0xf0, 0x08, 0xa4, 
+0x22, 0x74, 0xae, 0x25, 0x36, 0xf5, 0x82, 0xe4, 0x34, 0xfa, 0xf5, 0x83, 0x22, 0x75, 0xf0, 0x08, 
+0xa4, 0x24, 0x42, 0xf5, 0x82, 0xe4, 0x34, 0xff, 0xf5, 0x83, 0x74, 0x80, 0xf0, 0x22, 0x90, 0xff, 
+0x82, 0xe0, 0x44, 0x08, 0xf0, 0x22, 0x90, 0xff, 0xfe, 0xe0, 0x44, 0x03, 0xf0, 0x90, 0xff, 0xfc, 
+0xe0, 0x54, 0xfd, 0xf0, 0x22, 0x78, 0x6d, 0xe6, 0x54, 0xfd, 0xf6, 0x90, 0xff, 0xfd, 0x74, 0x65, 
+0xf0, 0x22, 0x12, 0x14, 0xdf, 0xe0, 0xfe, 0xa3, 0xe0, 0xff, 0x4e, 0x22, 0x7b, 0x01, 0x7a, 0xf9, 
+0x79, 0x6e, 0x22, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xb3, 0x22, 0x90, 0xff, 0x80, 0xe0, 0x44, 0x08, 
+0xf0, 0x22, 0x90, 0xff, 0x83, 0xe0, 0x54, 0x7f, 0xf0, 0x22, 0xe0, 0xff, 0x90, 0xf9, 0x66, 0x02, 
+0x14, 0xfd, 0x75, 0x30, 0x01, 0x75, 0x31, 0x09, 0x22, 0xd3, 0xe5, 0x35, 0x94, 0x08, 0xe5, 0x34, 
+0x94, 0x01, 0x22, 0x90, 0xfa, 0xba, 0xe0, 0xff, 0x90, 0xfa, 0xb6, 0xf0, 0x22, 0x90, 0xff, 0xa4, 
+0xe0, 0x54, 0xef, 0x22, 0x90, 0xff, 0xb4, 0xe0, 0x54, 0xef, 0x22, 0x8f, 0x38, 0x12, 0x27, 0x19, 
+0x78, 0x86, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x8e, 0x83, 0x24, 0x08, 0x12, 0x20, 0x25, 0xe0, 0xfd, 
+0x12, 0x20, 0xa6, 0x8a, 0x83, 0x24, 0x0a, 0x12, 0x20, 0x25, 0xed, 0xf0, 0x12, 0x20, 0x7c, 0x24, 
+0x07, 0x12, 0x20, 0x25, 0xe0, 0xff, 0x12, 0x20, 0xbe, 0x24, 0x09, 0x12, 0x20, 0x25, 0xef, 0xf0, 
+0x90, 0xf9, 0x65, 0xe0, 0x30, 0xe4, 0x20, 0x08, 0x12, 0x20, 0x2f, 0xc0, 0x83, 0xc0, 0x82, 0xa3, 
+0xe0, 0x25, 0xe0, 0xff, 0x05, 0x82, 0xd5, 0x82, 0x02, 0x15, 0x83, 0x15, 0x82, 0xe0, 0x33, 0xd0, 
+0x82, 0xd0, 0x83, 0xf0, 0xa3, 0xef, 0xf0, 0x78, 0x86, 0x12, 0x20, 0x2f, 0xe0, 0xfc, 0xa3, 0xe0, 
+0xfd, 0xec, 0xff, 0x12, 0x20, 0xa6, 0x8a, 0x83, 0x24, 0x08, 0x12, 0x20, 0x25, 0xef, 0xf0, 0xed, 
+0x12, 0x20, 0xbe, 0x24, 0x07, 0x12, 0x20, 0x25, 0xed, 0xf0, 0x8b, 0x82, 0x8a, 0x83, 0xa3, 0xa3, 
+0xe0, 0xff, 0x53, 0x07, 0xc7, 0x08, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x12, 0x20, 0x69, 0xa3, 0xe0, 
+0x30, 0xe3, 0x12, 0x8d, 0x82, 0x8c, 0x83, 0xe5, 0x82, 0x24, 0x05, 0x12, 0x20, 0x25, 0xe0, 0x90, 
+0x2f, 0x4d, 0x93, 0x42, 0x07, 0x53, 0x07, 0xfb, 0x12, 0x20, 0xae, 0x24, 0x06, 0x12, 0x20, 0x25, 
+0xe0, 0x60, 0x03, 0x43, 0x07, 0x04, 0x53, 0x07, 0xfc, 0x78, 0x86, 0x12, 0x20, 0x96, 0x24, 0x04, 
+0x12, 0x20, 0x25, 0xe0, 0x42, 0x07, 0x43, 0x07, 0x80, 0x12, 0x20, 0xa6, 0xf5, 0x82, 0x8a, 0x83, 
+0xa3, 0xa3, 0xef, 0xf0, 0x12, 0x20, 0xbe, 0x24, 0x04, 0x12, 0x20, 0x25, 0xe0, 0xff, 0x8d, 0x82, 
+0x8c, 0x83, 0xa3, 0xa3, 0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0x30, 0xe1, 0x05, 0x53, 0x07, 0xdf, 0x80, 
+0x03, 0x43, 0x07, 0x20, 0xec, 0x30, 0xe4, 0x05, 0x53, 0x07, 0xef, 0x80, 0x03, 0x43, 0x07, 0x10, 
+0x90, 0xf9, 0x65, 0xe0, 0xfe, 0x54, 0x03, 0x60, 0x4c, 0x53, 0x07, 0xdf, 0xee, 0x30, 0xe1, 0x42, 
+0x12, 0x20, 0xae, 0x24, 0x09, 0x12, 0x20, 0x25, 0xe0, 0x14, 0x60, 0x31, 0x14, 0x60, 0x29, 0x14, 
+0x60, 0x26, 0x14, 0x60, 0x28, 0x24, 0x04, 0x70, 0x2c, 0xe5, 0x38, 0xb4, 0x03, 0x0d, 0x30, 0x95, 
+0x05, 0x43, 0x07, 0x02, 0x80, 0x1f, 0x53, 0x07, 0xfd, 0x80, 0x1a, 0x30, 0x93, 0x05, 0x43, 0x07, 
+0x02, 0x80, 0x12, 0x53, 0x07, 0xfd, 0x80, 0x0d, 0x43, 0x07, 0x02, 0x80, 0x08, 0x53, 0x07, 0xfd, 
+0x80, 0x03, 0x53, 0x07, 0xfd, 0x12, 0x20, 0x94, 0x24, 0x04, 0x12, 0x20, 0x25, 0xef, 0xf0, 0x8d, 
+0x82, 0x8c, 0x83, 0xa3, 0xa3, 0xa3, 0xe0, 0xff, 0x90, 0xf9, 0x65, 0xe0, 0xfe, 0x54, 0x03, 0x60, 
+0x4a, 0xee, 0x30, 0xe1, 0x43, 0x08, 0x12, 0x20, 0xb0, 0x24, 0x09, 0x12, 0x20, 0x25, 0xe0, 0x14, 
+0x60, 0x2c, 0x14, 0x60, 0x2e, 0x14, 0x60, 0x26, 0x14, 0x60, 0x28, 0x24, 0x04, 0x70, 0x2c, 0xe5, 
+0x38, 0xb4, 0x03, 0x0d, 0x30, 0x94, 0x05, 0x53, 0x07, 0x7f, 0x80, 0x1f, 0x43, 0x07, 0x80, 0x80, 
+0x1a, 0x30, 0x92, 0x05, 0x53, 0x07, 0x7f, 0x80, 0x12, 0x43, 0x07, 0x80, 0x80, 0x0d, 0x53, 0x07, 
+0x7f, 0x80, 0x08, 0x43, 0x07, 0x80, 0x80, 0x03, 0x53, 0x07, 0x7f, 0x78, 0x86, 0x12, 0x20, 0x65, 
+0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0x30, 0xe0, 0x05, 0x43, 0x07, 0x20, 0x80, 0x03, 0x53, 0x07, 0xdf, 
+0xec, 0x30, 0xe3, 0x05, 0x43, 0x07, 0x40, 0x80, 0x03, 0x53, 0x07, 0xbf, 0xec, 0x30, 0xe0, 0x05, 
+0x43, 0x07, 0x10, 0x80, 0x03, 0x53, 0x07, 0xef, 0xed, 0x30, 0xe4, 0x05, 0x43, 0x07, 0x08, 0x80, 
+0x03, 0x53, 0x07, 0xf7, 0xed, 0x30, 0xe5, 0x05, 0x43, 0x07, 0x04, 0x80, 0x03, 0x53, 0x07, 0xfb, 
+0xed, 0x30, 0xe6, 0x05, 0x43, 0x07, 0x01, 0x80, 0x03, 0x53, 0x07, 0xfe, 0xed, 0x30, 0xe7, 0x05, 
+0x43, 0x07, 0x02, 0x80, 0x03, 0x53, 0x07, 0xfd, 0x78, 0x84, 0x12, 0x20, 0x65, 0xa3, 0xef, 0xf0, 
+0x12, 0x2f, 0x80, 0x7f, 0x00, 0x22, 0x12, 0x0f, 0x89, 0x78, 0x8e, 0xef, 0xf6, 0x12, 0x27, 0x19, 
+0x12, 0x20, 0x70, 0x8e, 0x83, 0x24, 0x09, 0x12, 0x20, 0x25, 0xe0, 0xfd, 0x12, 0x20, 0x53, 0x90, 
+0x00, 0x0a, 0x12, 0x20, 0x78, 0x24, 0x0a, 0x12, 0x20, 0x25, 0xe0, 0x90, 0x00, 0x0b, 0x12, 0x14, 
+0x0d, 0x12, 0x20, 0x70, 0xf5, 0x82, 0x8e, 0x83, 0xa3, 0xa3, 0xa3, 0xe0, 0xf5, 0x59, 0x12, 0x20, 
+0x7c, 0x24, 0x04, 0x12, 0x20, 0x25, 0xe0, 0xf5, 0x5a, 0x8f, 0x82, 0x8e, 0x83, 0xa3, 0xa3, 0xe0, 
+0xf5, 0x5b, 0xe5, 0x59, 0xc4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x78, 0x8e, 0xf6, 0xd3, 0x94, 0x00, 
+0x40, 0x06, 0xe5, 0x5a, 0x30, 0xe1, 0x01, 0x06, 0x78, 0x8e, 0xe6, 0x12, 0x20, 0x52, 0x90, 0x00, 
+0x0c, 0xef, 0x12, 0x14, 0x0d, 0x78, 0x86, 0x12, 0x20, 0x2f, 0xa3, 0xa3, 0xe0, 0xfe, 0xa3, 0xe0, 
+0xff, 0x53, 0x07, 0x0c, 0x53, 0x06, 0xe6, 0xe5, 0x59, 0x30, 0xe5, 0x03, 0x43, 0x07, 0x01, 0xe5, 
+0x5a, 0x20, 0xe5, 0x0e, 0xe5, 0x59, 0x54, 0x7f, 0x70, 0x08, 0xe5, 0x59, 0x20, 0xe7, 0x03, 0x43, 
+0x07, 0x02, 0xe5, 0x59, 0x30, 0xe3, 0x03, 0x43, 0x07, 0x10, 0xe5, 0x59, 0x30, 0xe2, 0x03, 0x43, 
+0x07, 0x20, 0xe5, 0x59, 0x54, 0x03, 0x60, 0x03, 0x43, 0x07, 0x40, 0xe5, 0x59, 0x30, 0xe1, 0x03, 
+0x43, 0x07, 0x80, 0xe5, 0x59, 0x30, 0xe4, 0x03, 0x43, 0x06, 0x01, 0xe5, 0x59, 0x30, 0xe6, 0x03, 
+0x43, 0x06, 0x08, 0xe5, 0x5a, 0x20, 0xe4, 0x0e, 0xe5, 0x59, 0x54, 0x7f, 0x70, 0x08, 0xe5, 0x59, 
+0x20, 0xe7, 0x03, 0x43, 0x06, 0x10, 0x53, 0x07, 0xfb, 0x53, 0x06, 0x79, 0x90, 0x00, 0x05, 0xee, 
+0x8f, 0xf0, 0x12, 0x14, 0xb2, 0xe5, 0x5b, 0x30, 0xe3, 0x12, 0x54, 0x30, 0xff, 0xc4, 0x54, 0x0f, 
+0x12, 0x20, 0x52, 0x90, 0x00, 0x08, 0xef, 0x12, 0x14, 0x0d, 0x80, 0x0a, 0x12, 0x20, 0x53, 0x90, 
+0x00, 0x08, 0xe4, 0x12, 0x14, 0x0d, 0xe5, 0x5b, 0x54, 0x03, 0x12, 0x20, 0x52, 0x90, 0x00, 0x07, 
+0xef, 0x12, 0x14, 0x0d, 0xe5, 0x5b, 0x54, 0x04, 0xff, 0xc3, 0x13, 0x90, 0x00, 0x09, 0x12, 0x14, 
+0x0d, 0x90, 0x00, 0x07, 0x12, 0x13, 0xce, 0x70, 0x13, 0x12, 0x20, 0x53, 0xe9, 0x24, 0x09, 0xf9, 
+0xe4, 0x3a, 0xfa, 0x12, 0x13, 0xb5, 0xff, 0xc3, 0x13, 0x12, 0x13, 0xfb, 0x12, 0x20, 0x94, 0x24, 
+0x08, 0x12, 0x20, 0x25, 0xe0, 0xfe, 0x8d, 0x82, 0x8c, 0x83, 0xe5, 0x82, 0x24, 0x07, 0x12, 0x20, 
+0x25, 0xe0, 0xfd, 0xee, 0xed, 0x12, 0x20, 0x52, 0x90, 0x00, 0x03, 0xee, 0x8f, 0xf0, 0x12, 0x14, 
+0xb2, 0x12, 0x2f, 0x80, 0x7d, 0x0a, 0xe4, 0xff, 0x12, 0x2c, 0xc0, 0x02, 0x10, 0x0c, 0x90, 0xfa, 
+0xe2, 0xe0, 0xb4, 0x03, 0x06, 0x7e, 0x00, 0x7f, 0x40, 0x80, 0x04, 0x7e, 0x00, 0x7f, 0x08, 0x90, 
+0xfa, 0xd6, 0xee, 0xf0, 0xa3, 0xef, 0xf0, 0x90, 0x00, 0x05, 0x12, 0x13, 0xce, 0xff, 0x7e, 0x00, 
+0x90, 0xfa, 0xd2, 0xee, 0xf0, 0xa3, 0xef, 0xf0, 0x70, 0x03, 0x7f, 0x08, 0x22, 0x90, 0x00, 0x08, 
+0x12, 0x14, 0x5b, 0xff, 0x90, 0xfa, 0xd4, 0xe5, 0xf0, 0xf0, 0xa3, 0xef, 0xf0, 0xae, 0x02, 0xaf, 
+0x01, 0x8e, 0x56, 0x8f, 0x57, 0x74, 0x0a, 0x25, 0x57, 0xf5, 0x57, 0xe4, 0x35, 0x56, 0xf5, 0x56, 
+0x90, 0xfa, 0xd7, 0xe0, 0xff, 0x14, 0xfe, 0x90, 0xfa, 0xd5, 0xe0, 0x5e, 0xfe, 0xc3, 0xef, 0x9e, 
+0xff, 0x90, 0xfa, 0xd9, 0xf0, 0xc3, 0x90, 0xfa, 0xd3, 0xe0, 0x9f, 0x90, 0xfa, 0xd2, 0xe0, 0x94, 
+0x00, 0x50, 0x06, 0xa3, 0xe0, 0x90, 0xfa, 0xd9, 0xf0, 0x12, 0x1e, 0x2d, 0x60, 0x03, 0xe0, 0xff, 
+0x22, 0x12, 0x2a, 0x80, 0x90, 0xfa, 0xd2, 0xe0, 0xfe, 0xa3, 0xe0, 0xff, 0x4e, 0x60, 0x2b, 0x90, 
+0xfa, 0xd6, 0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0xd3, 0xef, 0x9d, 0xee, 0x9c, 0x40, 0x07, 0xe0, 0x90, 
+0xfa, 0xd9, 0xf0, 0x80, 0x08, 0x90, 0xfa, 0xd3, 0xe0, 0x90, 0xfa, 0xd9, 0xf0, 0x12, 0x1e, 0x2d, 
+0x60, 0x03, 0xe0, 0xff, 0x22, 0x12, 0x2a, 0x80, 0x80, 0xca, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x58, 
+0xe4, 0xf5, 0x40, 0xf5, 0x41, 0x7d, 0x01, 0x12, 0x23, 0xee, 0x7f, 0x00, 0x22, 0xaa, 0x56, 0xa9, 
+0x57, 0x7b, 0x01, 0x90, 0xfa, 0xd4, 0xe0, 0xfc, 0xa3, 0xe0, 0xfd, 0x90, 0xfa, 0xd9, 0xe0, 0xf5, 
+0x50, 0x12, 0x26, 0x25, 0x90, 0xfa, 0xd8, 0xef, 0xf0, 0x22, 0xef, 0x24, 0xae, 0x60, 0x52, 0x24, 
+0xfe, 0x60, 0x2e, 0x24, 0xfe, 0x70, 0x03, 0x02, 0x1e, 0xed, 0x24, 0x06, 0x60, 0x03, 0x02, 0x1f, 
+0x35, 0x78, 0x77, 0xe6, 0x54, 0xfb, 0xf6, 0x90, 0xff, 0xa5, 0xe0, 0xf5, 0x36, 0x44, 0x0f, 0xf0, 
+0x74, 0x33, 0x90, 0xfa, 0x90, 0xf0, 0xe5, 0x36, 0xa3, 0xf0, 0x90, 0xfa, 0xae, 0x74, 0x01, 0xf0, 
+0x22, 0x78, 0x78, 0xe6, 0x54, 0xfb, 0xf6, 0x90, 0xff, 0xb5, 0xe0, 0xf5, 0x36, 0x44, 0x0f, 0xf0, 
+0x74, 0x43, 0x90, 0xfa, 0x92, 0xf0, 0xe5, 0x36, 0xa3, 0xf0, 0x90, 0xfa, 0xaf, 0x74, 0x01, 0xf0, 
+0x22, 0x90, 0xfa, 0x9c, 0xe0, 0xa3, 0x20, 0xe5, 0x03, 0x02, 0x1f, 0x35, 0x90, 0xff, 0xa6, 0xe0, 
+0x90, 0xfa, 0xc9, 0xf0, 0xa3, 0xf0, 0x90, 0xfa, 0xc9, 0xe0, 0xff, 0x54, 0x0f, 0xfe, 0x60, 0x10, 
+0x90, 0xff, 0xa6, 0x12, 0x20, 0x83, 0x90, 0xff, 0xa6, 0xe0, 0x90, 0xfa, 0xc9, 0xf0, 0x80, 0xe6, 
+0x90, 0xfa, 0xca, 0xe0, 0xff, 0x74, 0x34, 0xfe, 0x12, 0x29, 0xda, 0xef, 0x70, 0x57, 0x90, 0xfa, 
+0xca, 0xe0, 0xff, 0x74, 0x34, 0x90, 0xfa, 0x94, 0xf0, 0xef, 0xa3, 0xf0, 0x22, 0x90, 0xfa, 0xa6, 
+0xe0, 0xa3, 0x30, 0xe5, 0x40, 0x90, 0xff, 0xb6, 0xe0, 0x90, 0xfa, 0xc9, 0xf0, 0xa3, 0xf0, 0x90, 
+0xfa, 0xc9, 0xe0, 0xff, 0x54, 0x0f, 0xfe, 0x60, 0x10, 0x90, 0xff, 0xb6, 0x12, 0x20, 0x83, 0x90, 
+0xff, 0xb6, 0xe0, 0x90, 0xfa, 0xc9, 0xf0, 0x80, 0xe6, 0x90, 0xfa, 0xca, 0xe0, 0xff, 0x74, 0x44, 
+0xfe, 0x12, 0x29, 0xda, 0xef, 0x70, 0x0e, 0x90, 0xfa, 0xca, 0xe0, 0xff, 0x74, 0x44, 0x90, 0xfa, 
+0x96, 0xf0, 0xef, 0xa3, 0xf0, 0x22, 0xc0, 0xe0, 0xc0, 0xf0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, 0xd0, 
+0x75, 0xd0, 0x00, 0xc0, 0x00, 0xc0, 0x01, 0xc0, 0x02, 0xc0, 0x03, 0xc0, 0x04, 0xc0, 0x05, 0xc0, 
+0x06, 0xc0, 0x07, 0x90, 0xff, 0x92, 0xe0, 0xff, 0x90, 0xfa, 0xc8, 0xf0, 0x90, 0xff, 0x92, 0xe4, 
+0xf0, 0xef, 0x12, 0x15, 0x0f, 0x1f, 0xed, 0x26, 0x1f, 0xed, 0x2e, 0x1f, 0x90, 0x30, 0x1f, 0x90, 
+0x32, 0x1f, 0x9e, 0x38, 0x1f, 0xb0, 0x3a, 0x1f, 0xe2, 0x3e, 0x1f, 0xcd, 0x44, 0x1f, 0xc2, 0x46, 
+0x1f, 0xd8, 0x50, 0x1f, 0xd8, 0x52, 0x1f, 0xd8, 0x54, 0x1f, 0xd8, 0x56, 0x00, 0x00, 0x1f, 0xf2, 
+0x90, 0xfa, 0xc8, 0xe0, 0xfd, 0x7c, 0x00, 0x7f, 0x01, 0x12, 0x10, 0x9c, 0x80, 0x62, 0x7c, 0x00, 
+0x7d, 0x01, 0x7f, 0x03, 0x12, 0x10, 0x9c, 0x90, 0xff, 0xfe, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x50, 
+0x7c, 0x00, 0x7d, 0x01, 0x7f, 0x02, 0x12, 0x10, 0x9c, 0x90, 0xff, 0xfe, 0xe0, 0x44, 0x40, 0xf0, 
+0x80, 0x3e, 0x7c, 0x00, 0x7d, 0x01, 0x7f, 0x05, 0x12, 0x10, 0x9c, 0x80, 0x33, 0x7c, 0x00, 0x7d, 
+0x01, 0x7f, 0x06, 0x12, 0x10, 0x9c, 0x80, 0x28, 0x90, 0xfa, 0xc8, 0xe0, 0xff, 0x12, 0x1e, 0x4a, 
+0x80, 0x1e, 0x7c, 0x00, 0x7d, 0x01, 0x7f, 0x04, 0x12, 0x10, 0x9c, 0x80, 0x13, 0x12, 0x25, 0x13, 
+0x80, 0x0e, 0x90, 0xfa, 0xc8, 0xe0, 0x24, 0x00, 0xff, 0xe4, 0x34, 0xff, 0xfe, 0x12, 0x29, 0xda, 
+0xd0, 0x07, 0xd0, 0x06, 0xd0, 0x05, 0xd0, 0x04, 0xd0, 0x03, 0xd0, 0x02, 0xd0, 0x01, 0xd0, 0x00, 
+0xd0, 0xd0, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xf0, 0xd0, 0xe0, 0x32, 0x78, 0x82, 0xe6, 0xfe, 0x08, 
+0xe6, 0x24, 0x04, 0x8e, 0x83, 0xf5, 0x82, 0xe4, 0x35, 0x83, 0xf5, 0x83, 0x22, 0x78, 0x82, 0xe6, 
+0xfe, 0x08, 0xe6, 0xf5, 0x82, 0x8e, 0x83, 0x22, 0x78, 0x86, 0xe6, 0xfe, 0x08, 0xe6, 0xaa, 0x06, 
+0xf8, 0xac, 0x02, 0x7d, 0x01, 0x7b, 0xff, 0x7a, 0x2f, 0x79, 0x52, 0x7e, 0x00, 0x7f, 0x0a, 0x02, 
+0x13, 0x8f, 0xff, 0x90, 0xf9, 0x6b, 0x02, 0x14, 0xfd, 0x90, 0xf9, 0x66, 0x12, 0x14, 0xfd, 0x90, 
+0x00, 0x04, 0x02, 0x13, 0xce, 0xe6, 0xfc, 0x08, 0xe6, 0xf5, 0x82, 0x8c, 0x83, 0xa3, 0xa3, 0x22, 
+0x78, 0x84, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x22, 0xed, 0x12, 0x14, 0x0d, 0x8f, 0x82, 0x8e, 0x83, 
+0xe5, 0x82, 0x22, 0xef, 0xf0, 0x90, 0xfa, 0xca, 0xe0, 0x54, 0x0f, 0x4e, 0xfe, 0xf0, 0xef, 0x54, 
+0xf0, 0x4e, 0xf0, 0x22, 0x78, 0x84, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x8c, 0x83, 0x22, 0xa6, 0x07, 
+0xe6, 0x24, 0x74, 0xf8, 0xe6, 0x22, 0x78, 0x84, 0xe6, 0xfa, 0x08, 0xe6, 0xfb, 0x22, 0x78, 0x86, 
+0xe6, 0xfc, 0x08, 0xe6, 0x8c, 0x83, 0x22, 0x26, 0xf6, 0x18, 0xee, 0x36, 0xf6, 0x22, 0x8b, 0x82, 
+0x8a, 0x83, 0xe5, 0x82, 0x22, 0x8b, 0x38, 0x8a, 0x39, 0x89, 0x3a, 0x8d, 0x3b, 0x90, 0xfa, 0xce, 
+0xe4, 0xf0, 0xa3, 0x74, 0x02, 0xf0, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xcd, 0x90, 0xfa, 0xce, 0xe0, 
+0xf5, 0x40, 0xa3, 0xe0, 0xf5, 0x41, 0x7d, 0x01, 0x12, 0x23, 0xee, 0x90, 0xfa, 0xcd, 0xe0, 0x65, 
+0x3b, 0x60, 0x46, 0xa3, 0xe0, 0xff, 0xa3, 0xe0, 0xa3, 0xcf, 0xf0, 0xa3, 0xef, 0xf0, 0x12, 0x21, 
+0x54, 0x90, 0xfa, 0xcd, 0xe0, 0xff, 0x90, 0xfa, 0xd0, 0xe4, 0x8f, 0xf0, 0x12, 0x14, 0x2f, 0x12, 
+0x21, 0x54, 0x90, 0xfa, 0xd0, 0xe0, 0xff, 0xa3, 0xe0, 0x90, 0xfa, 0xce, 0xcf, 0xf0, 0xa3, 0xef, 
+0xf0, 0x90, 0xfa, 0xcd, 0xe0, 0xa3, 0x75, 0xf0, 0x00, 0x12, 0x14, 0x2f, 0x90, 0xfa, 0xce, 0xe4, 
+0x75, 0xf0, 0x04, 0x12, 0x14, 0x2f, 0x02, 0x20, 0xd6, 0x90, 0xfa, 0xcf, 0xe0, 0x24, 0x01, 0xff, 
+0x90, 0xfa, 0xce, 0xe0, 0x34, 0x00, 0xab, 0x38, 0xaa, 0x39, 0xa9, 0x3a, 0x8f, 0xf0, 0x12, 0x14, 
+0x93, 0x7f, 0x00, 0x22, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xcd, 0x90, 0xfa, 0xce, 0xe4, 0x75, 0xf0, 
+0x01, 0x12, 0x14, 0x2f, 0x85, 0xf0, 0x41, 0xf5, 0x40, 0x7d, 0x01, 0x02, 0x23, 0xee, 0x8f, 0x68, 
+0x12, 0x27, 0x19, 0x12, 0x20, 0x70, 0x8e, 0x83, 0x24, 0x0b, 0x12, 0x20, 0x25, 0xe0, 0x54, 0xfb, 
+0xf0, 0x44, 0x02, 0xf0, 0x08, 0x12, 0x20, 0x65, 0xe0, 0xa3, 0x30, 0xe5, 0x0c, 0x12, 0x20, 0x7c, 
+0x24, 0x0b, 0x12, 0x20, 0x25, 0xe0, 0x44, 0x01, 0xf0, 0x78, 0x82, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 
+0xf5, 0x82, 0x8e, 0x83, 0xe0, 0x54, 0xb8, 0xfd, 0xf0, 0xe5, 0x68, 0x24, 0xfe, 0x44, 0x20, 0xfc, 
+0x4d, 0xf0, 0xe5, 0x82, 0x24, 0x04, 0x12, 0x20, 0x25, 0xe0, 0x54, 0xb8, 0xf0, 0x4c, 0xf0, 0x8f, 
+0x82, 0x8e, 0x83, 0xa3, 0x74, 0x03, 0xf0, 0x18, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x8e, 0x83, 0x24, 
+0x05, 0x12, 0x20, 0x25, 0xc0, 0x83, 0xc0, 0x82, 0xe0, 0xfd, 0x74, 0x95, 0x25, 0x68, 0xf5, 0x82, 
+0xe4, 0x34, 0xfa, 0xf5, 0x83, 0xe0, 0x54, 0xfc, 0x44, 0x03, 0xfc, 0xed, 0x4c, 0xd0, 0x82, 0xd0, 
+0x83, 0xf0, 0x8f, 0x82, 0x8e, 0x83, 0xe0, 0x44, 0x80, 0xf0, 0xe5, 0x82, 0x24, 0x04, 0x12, 0x20, 
+0x25, 0xe0, 0x44, 0x80, 0xf0, 0x12, 0x2f, 0x80, 0x74, 0x74, 0x25, 0x68, 0xf8, 0x74, 0x04, 0x46, 
+0xf6, 0x7f, 0x00, 0x22, 0x8b, 0x62, 0x8a, 0x63, 0x89, 0x64, 0x12, 0x2a, 0x62, 0x90, 0xfa, 0xbf, 
+0x12, 0x15, 0x06, 0xaa, 0x63, 0xa9, 0x64, 0x90, 0xfa, 0xc2, 0x12, 0x15, 0x06, 0x90, 0xfa, 0xc3, 
+0xe4, 0x75, 0xf0, 0x0a, 0x12, 0x14, 0x2f, 0x90, 0xfa, 0xc2, 0x12, 0x14, 0xfd, 0xe9, 0x24, 0x01, 
+0xf9, 0xe4, 0x3a, 0xfa, 0x90, 0xfa, 0xc5, 0x12, 0x15, 0x06, 0xab, 0x62, 0xaa, 0x63, 0xa9, 0x64, 
+0x12, 0x2a, 0x6e, 0xe0, 0xff, 0xc3, 0x13, 0xf0, 0xe4, 0x78, 0x88, 0xf6, 0x90, 0xfa, 0xbd, 0xe0, 
+0xff, 0x78, 0x88, 0xe6, 0xc3, 0x9f, 0x50, 0x4a, 0x90, 0xfa, 0xbf, 0x12, 0x2a, 0x43, 0xff, 0x78, 
+0x89, 0xf6, 0x90, 0xfa, 0xc2, 0x12, 0x2a, 0x43, 0xfe, 0xf4, 0x5f, 0xff, 0x78, 0x89, 0xf6, 0x12, 
+0x2a, 0x40, 0x5e, 0x4f, 0xff, 0x78, 0x89, 0xf6, 0x12, 0x2a, 0x49, 0x75, 0xf0, 0x02, 0x12, 0x14, 
+0x2f, 0x90, 0xfa, 0xc3, 0xe4, 0x75, 0xf0, 0x02, 0x12, 0x14, 0x2f, 0xab, 0x62, 0xaa, 0x63, 0xa9, 
+0x64, 0x90, 0x00, 0x04, 0x12, 0x13, 0xce, 0x30, 0xe4, 0x03, 0x12, 0x2a, 0x58, 0x78, 0x88, 0x06, 
+0x80, 0xaa, 0xe4, 0x90, 0xfa, 0xbe, 0xf0, 0x22, 0x8b, 0x5c, 0x8a, 0x5d, 0x89, 0x5e, 0x90, 0xfa, 
+0xbe, 0x74, 0x06, 0xf0, 0xe4, 0x90, 0xfa, 0xbd, 0xf0, 0x12, 0x13, 0xb5, 0x24, 0x6e, 0x60, 0x26, 
+0x14, 0x70, 0x70, 0x12, 0x2a, 0x2f, 0x60, 0x09, 0x24, 0x30, 0x70, 0x12, 0x12, 0x22, 0x14, 0x80, 
+0x62, 0x12, 0x2a, 0x79, 0x12, 0x1d, 0x5e, 0x90, 0xfa, 0xbe, 0xef, 0xf0, 0x80, 0x55, 0x90, 0xfa, 
+0xbe, 0x74, 0x81, 0xf0, 0x80, 0x4d, 0x12, 0x2a, 0x2f, 0x60, 0x09, 0x24, 0x30, 0x70, 0x3e, 0x12, 
+0x29, 0x85, 0x80, 0x3f, 0xe5, 0x5e, 0x24, 0x03, 0xf9, 0xe4, 0x35, 0x5d, 0xfa, 0x7b, 0x01, 0xc0, 
+0x03, 0xc0, 0x02, 0xc0, 0x01, 0x12, 0x2a, 0x79, 0x90, 0x00, 0x05, 0x12, 0x13, 0xce, 0xfd, 0x90, 
+0x00, 0x08, 0x12, 0x14, 0x5b, 0xf5, 0x41, 0x85, 0xf0, 0x40, 0xd0, 0x01, 0xd0, 0x02, 0xd0, 0x03, 
+0x12, 0x23, 0xee, 0x90, 0xfa, 0xbd, 0xef, 0xf0, 0xe4, 0xa3, 0xf0, 0x80, 0x06, 0x90, 0xfa, 0xbe, 
+0x74, 0x81, 0xf0, 0x90, 0xfa, 0xbe, 0xe0, 0x12, 0x2a, 0x79, 0x90, 0x00, 0x02, 0x12, 0x14, 0x0d, 
+0x90, 0xfa, 0xbd, 0xe0, 0xff, 0x22, 0x12, 0x0f, 0x89, 0x7f, 0x02, 0x12, 0x11, 0x9f, 0x78, 0x6d, 
+0xe6, 0x44, 0x02, 0xf6, 0xd2, 0xb0, 0xd2, 0xb1, 0xd2, 0xb3, 0x90, 0xff, 0xa4, 0xe0, 0x90, 0xfa, 
+0x7a, 0xf0, 0x90, 0xff, 0xb4, 0xe0, 0x90, 0xfa, 0x7b, 0xf0, 0x90, 0xff, 0xa2, 0xe0, 0x90, 0xfa, 
+0x78, 0xf0, 0x90, 0xff, 0xb2, 0xe0, 0x90, 0xfa, 0x79, 0xf0, 0x90, 0xff, 0xa4, 0x74, 0x30, 0xf0, 
+0x90, 0xff, 0xb4, 0xf0, 0x90, 0xff, 0xa2, 0x74, 0x40, 0xf0, 0x90, 0xff, 0xb2, 0xf0, 0x90, 0xfa, 
+0xe3, 0xe5, 0xa8, 0xf0, 0x75, 0xa8, 0x81, 0x90, 0xff, 0x92, 0xe0, 0x60, 0x04, 0xe4, 0xf0, 0x80, 
+0xf6, 0x90, 0xff, 0xfd, 0x74, 0x3a, 0xf0, 0x43, 0x87, 0x01, 0x00, 0x00, 0x00, 0x90, 0xfa, 0x7a, 
+0xe0, 0x90, 0xff, 0xa4, 0xf0, 0x90, 0xfa, 0x7b, 0xe0, 0x90, 0xff, 0xb4, 0xf0, 0x90, 0xfa, 0x78, 
+0xe0, 0x90, 0xff, 0xa2, 0xf0, 0x90, 0xfa, 0x79, 0xe0, 0x90, 0xff, 0xb2, 0xf0, 0x90, 0xf9, 0x15, 
+0xe0, 0x60, 0x02, 0xc2, 0xb3, 0x90, 0xfa, 0xe3, 0xe0, 0xf5, 0xa8, 0x02, 0x10, 0x0c, 0x8b, 0x3c, 
+0x8a, 0x3d, 0x89, 0x3e, 0x8d, 0x3f, 0xe5, 0x3f, 0x70, 0x03, 0xaf, 0x3f, 0x22, 0x12, 0x2a, 0xa8, 
+0x70, 0x16, 0x12, 0x2a, 0xc7, 0xe5, 0x40, 0x90, 0xff, 0xf1, 0xf0, 0x12, 0x2e, 0xd4, 0x50, 0xf2, 
+0x12, 0x24, 0x7b, 0x40, 0x0b, 0x7f, 0x00, 0x22, 0x12, 0x2a, 0xc7, 0x12, 0x24, 0x7b, 0x50, 0xf8, 
+0x90, 0xff, 0xf3, 0x74, 0xa1, 0xf0, 0xe5, 0x3f, 0xb4, 0x01, 0x07, 0x90, 0xff, 0xf0, 0xe0, 0x44, 
+0x02, 0xf0, 0x90, 0xff, 0xf1, 0xe4, 0xf0, 0xf5, 0x42, 0xe5, 0x3f, 0x14, 0xff, 0xe5, 0x42, 0xc3, 
+0x9f, 0x50, 0x2a, 0x12, 0x2e, 0xbd, 0x40, 0x03, 0xaf, 0x42, 0x22, 0xc3, 0xe5, 0x3f, 0x95, 0x42, 
+0xff, 0xbf, 0x02, 0x07, 0x90, 0xff, 0xf0, 0xe0, 0x44, 0x02, 0xf0, 0x12, 0x2a, 0xba, 0x05, 0x42, 
+0x74, 0x01, 0x25, 0x3e, 0xf5, 0x3e, 0xe4, 0x35, 0x3d, 0xf5, 0x3d, 0x80, 0xcc, 0x12, 0x2e, 0xbd, 
+0x40, 0x03, 0x7f, 0x18, 0x22, 0x12, 0x2a, 0xba, 0xaf, 0x3f, 0x22, 0x90, 0xff, 0xf1, 0xe5, 0x41, 
+0xf0, 0x02, 0x2e, 0xd4, 0x75, 0xa8, 0x40, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0x91, 
+0x02, 0x24, 0xce, 0x02, 0x2e, 0x88, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6, 
+0x80, 0x01, 0xf2, 0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c, 
+0xc8, 0xc3, 0x33, 0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01, 
+0x46, 0xf6, 0xdf, 0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x28, 
+0xcb, 0xe4, 0x7e, 0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 
+0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 
+0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 
+0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 
+0xe7, 0x80, 0xbe, 0xe4, 0xf5, 0x36, 0x12, 0x19, 0x21, 0xe0, 0xb4, 0x04, 0x0d, 0xe5, 0x36, 0x24, 
+0x03, 0xff, 0x12, 0x2d, 0x4f, 0x12, 0x19, 0x21, 0xe4, 0xf0, 0x05, 0x36, 0xe5, 0x36, 0xc3, 0x94, 
+0x02, 0x40, 0xe3, 0xe4, 0xf5, 0x36, 0x75, 0xf0, 0x02, 0xe5, 0x36, 0x90, 0xfa, 0x90, 0x12, 0x19, 
+0x62, 0x60, 0x2c, 0x12, 0x29, 0xda, 0xef, 0x60, 0x52, 0x75, 0xf0, 0x02, 0xe5, 0x36, 0x90, 0xfa, 
+0x90, 0x12, 0x14, 0xdf, 0xe4, 0xf0, 0xa3, 0xf0, 0x75, 0xf0, 0x0a, 0xe5, 0x36, 0x90, 0xfa, 0x9c, 
+0x12, 0x14, 0xdf, 0xe0, 0xa3, 0x30, 0xe6, 0x33, 0x12, 0x19, 0x21, 0x74, 0x04, 0xf0, 0x22, 0x75, 
+0xf0, 0x02, 0xe5, 0x36, 0x90, 0xfa, 0x94, 0x12, 0x19, 0x62, 0x60, 0x16, 0x12, 0x29, 0xda, 0xef, 
+0x60, 0x19, 0x75, 0xf0, 0x02, 0xe5, 0x36, 0x90, 0xfa, 0x94, 0x12, 0x14, 0xdf, 0xe4, 0xf0, 0xa3, 
+0xf0, 0x22, 0x05, 0x36, 0xe5, 0x36, 0xc3, 0x94, 0x02, 0x40, 0x9b, 0x22, 0xe4, 0xff, 0x90, 0xff, 
+0x83, 0xe0, 0x54, 0x0f, 0xfe, 0xef, 0xc3, 0x9e, 0x50, 0x17, 0x74, 0xf0, 0x2f, 0xf5, 0x82, 0xe4, 
+0x34, 0xfe, 0xf5, 0x83, 0xe0, 0x12, 0x18, 0x2a, 0x12, 0x13, 0xfb, 0x0f, 0x12, 0x18, 0x19, 0x80, 
+0xdd, 0xef, 0xfd, 0xc3, 0xe5, 0x31, 0x9d, 0xf5, 0x31, 0xe5, 0x30, 0x94, 0x00, 0xf5, 0x30, 0xd3, 
+0xe5, 0x31, 0x94, 0x00, 0xe5, 0x30, 0x94, 0x00, 0x40, 0x06, 0xe4, 0x90, 0xff, 0x83, 0xf0, 0x22, 
+0x12, 0x19, 0x3e, 0x12, 0x19, 0x92, 0x12, 0x19, 0x8c, 0x12, 0x13, 0xb5, 0x24, 0x6e, 0x60, 0x1e, 
+0x14, 0x60, 0x1b, 0x24, 0x8e, 0x70, 0x2d, 0x90, 0x00, 0x01, 0x12, 0x13, 0xce, 0xff, 0x24, 0xfc, 
+0x60, 0x03, 0x04, 0x70, 0x1f, 0xef, 0xfd, 0x7c, 0x00, 0x7f, 0x0d, 0x02, 0x10, 0x9c, 0x12, 0x19, 
+0x6c, 0x12, 0x22, 0xb8, 0x12, 0x18, 0xe8, 0x12, 0x13, 0xce, 0x60, 0x03, 0x02, 0x2f, 0x76, 0xe4, 
+0xff, 0x12, 0x2f, 0x6a, 0x22, 0x8b, 0x4b, 0x8a, 0x4c, 0x89, 0x4d, 0x8c, 0x4e, 0x8d, 0x4f, 0xd2, 
+0x00, 0x12, 0x2a, 0xa8, 0x70, 0x16, 0x12, 0x2a, 0xc7, 0xe5, 0x4e, 0x90, 0xff, 0xf1, 0xf0, 0x12, 
+0x2e, 0xd4, 0x50, 0xf2, 0x12, 0x26, 0x9a, 0x40, 0x0b, 0x7f, 0x18, 0x22, 0x12, 0x2a, 0xc7, 0x12, 
+0x26, 0x9a, 0x50, 0xf8, 0xe4, 0xf5, 0x51, 0xe5, 0x50, 0x14, 0xff, 0xe5, 0x51, 0xc3, 0x9f, 0x50, 
+0x17, 0x12, 0x26, 0x8a, 0x40, 0x03, 0x7f, 0x18, 0x22, 0x05, 0x51, 0x74, 0x01, 0x25, 0x4d, 0xf5, 
+0x4d, 0xe4, 0x35, 0x4c, 0xf5, 0x4c, 0x80, 0xdf, 0x90, 0xff, 0xf0, 0xe0, 0x44, 0x01, 0xf0, 0x12, 
+0x26, 0x8a, 0x40, 0x03, 0x7f, 0x18, 0x22, 0x7f, 0x00, 0x22, 0xab, 0x4b, 0xaa, 0x4c, 0xa9, 0x4d, 
+0x12, 0x13, 0xb5, 0x90, 0xff, 0xf1, 0xf0, 0x02, 0x2e, 0xd4, 0x90, 0xff, 0xf1, 0xe5, 0x4f, 0xf0, 
+0x02, 0x2e, 0xd4, 0x7b, 0x01, 0x7a, 0xfa, 0x79, 0xcb, 0xe4, 0xfd, 0x12, 0x20, 0xc5, 0x90, 0xfa, 
+0xcb, 0xe4, 0x75, 0xf0, 0x09, 0x12, 0x14, 0x2f, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x37, 0x90, 0xfa, 
+0xcb, 0xe4, 0x75, 0xf0, 0x01, 0x12, 0x14, 0x45, 0x85, 0xf0, 0x41, 0xf5, 0x40, 0x7d, 0x01, 0x12, 
+0x23, 0xee, 0x90, 0xff, 0xf7, 0xe5, 0x37, 0x12, 0x26, 0xfe, 0x90, 0xff, 0xf6, 0xe5, 0x37, 0xf0, 
+0x90, 0xfa, 0xcb, 0xe4, 0xf0, 0xa3, 0x74, 0x06, 0x12, 0x26, 0xfe, 0xe5, 0x37, 0x30, 0xe0, 0x07, 
+0x90, 0xff, 0xfc, 0x74, 0x94, 0xf0, 0x22, 0x90, 0xff, 0xfc, 0x74, 0x90, 0xf0, 0x22, 0xf0, 0x7b, 
+0x00, 0x7a, 0x00, 0x79, 0x37, 0x90, 0xfa, 0xcb, 0xe4, 0x75, 0xf0, 0x01, 0x12, 0x14, 0x45, 0x85, 
+0xf0, 0x41, 0xf5, 0x40, 0x7d, 0x01, 0x02, 0x23, 0xee, 0x15, 0x6b, 0xa8, 0x6b, 0xa6, 0x07, 0x30, 
+0x08, 0x05, 0x12, 0x10, 0xec, 0x80, 0xf8, 0xd2, 0x08, 0xa8, 0x6b, 0xe6, 0xff, 0xb4, 0x03, 0x0f, 
+0x78, 0x82, 0x76, 0xff, 0x08, 0x76, 0xe0, 0x08, 0x76, 0xff, 0x08, 0x76, 0xa0, 0x80, 0x0d, 0x78, 
+0x82, 0x76, 0xff, 0x08, 0x76, 0xe2, 0x08, 0x76, 0xff, 0x08, 0x76, 0xb0, 0x78, 0x86, 0x76, 0xfa, 
+0x08, 0x76, 0x9a, 0xef, 0x24, 0xfd, 0x75, 0xf0, 0x0a, 0xa4, 0xae, 0xf0, 0x12, 0x20, 0xb7, 0x7b, 
+0x01, 0x7a, 0xff, 0x79, 0x48, 0x78, 0x6e, 0x12, 0x14, 0xf4, 0xa8, 0x6b, 0xe6, 0x24, 0xfd, 0x75, 
+0xf0, 0x08, 0xa4, 0xff, 0xae, 0xf0, 0x78, 0x70, 0x12, 0x20, 0xb7, 0x79, 0x08, 0x78, 0x71, 0x12, 
+0x14, 0xf4, 0x78, 0x73, 0xef, 0x12, 0x20, 0xb7, 0x05, 0x6b, 0x22, 0x90, 0xff, 0xf0, 0xe0, 0x54, 
+0xab, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x90, 0xfa, 0xe2, 0x74, 0x02, 0xf0, 0x7b, 0x01, 0x7a, 0xfa, 
+0x79, 0xcb, 0xe4, 0xf5, 0x40, 0xf5, 0x41, 0x7d, 0x01, 0x12, 0x23, 0xee, 0x7e, 0x00, 0x90, 0xfa, 
+0xe0, 0xee, 0xf0, 0xa3, 0xef, 0xf0, 0x64, 0x01, 0x70, 0x10, 0x90, 0xfa, 0xcb, 0xe0, 0xb4, 0x52, 
+0x09, 0x90, 0xf9, 0x65, 0xe0, 0x54, 0xef, 0xf0, 0x80, 0x29, 0x90, 0xfa, 0xe0, 0xe0, 0x70, 0x04, 
+0xa3, 0xe0, 0x64, 0x01, 0x70, 0x10, 0x90, 0xfa, 0xcb, 0xe0, 0xb4, 0x10, 0x09, 0x90, 0xf9, 0x65, 
+0xe0, 0x44, 0x10, 0xf0, 0x80, 0x0d, 0x90, 0xfa, 0xe2, 0x74, 0x03, 0xf0, 0x90, 0xf9, 0x65, 0xe0, 
+0x54, 0xef, 0xf0, 0x90, 0xff, 0xf0, 0xe0, 0x44, 0x20, 0xf0, 0x22, 0x90, 0xff, 0x93, 0x74, 0x2a, 
+0xf0, 0x90, 0xff, 0xff, 0xe0, 0x60, 0x06, 0x90, 0xff, 0xfc, 0x74, 0x10, 0xf0, 0x90, 0xff, 0x91, 
+0xe0, 0x44, 0x90, 0xf0, 0x12, 0x27, 0x8b, 0x12, 0x15, 0x35, 0x12, 0x2d, 0xa5, 0x7e, 0x07, 0x7f, 
+0xd0, 0x12, 0x11, 0x68, 0x7e, 0x0f, 0x7f, 0xa0, 0x12, 0x11, 0x82, 0xe4, 0x78, 0x7d, 0xf6, 0x78, 
+0x7d, 0xe6, 0xff, 0xc3, 0x94, 0x06, 0x50, 0x0b, 0x74, 0x74, 0x2f, 0xf8, 0xe4, 0xf6, 0x78, 0x7d, 
+0x06, 0x80, 0xec, 0x7f, 0x03, 0x12, 0x2c, 0x5b, 0x90, 0xf9, 0x65, 0xe0, 0x20, 0xe4, 0x05, 0x7f, 
+0x04, 0x12, 0x2c, 0x5b, 0x90, 0xff, 0x9b, 0xe4, 0xf0, 0x90, 0xff, 0x9a, 0xf0, 0x90, 0xff, 0xe8, 
+0xe0, 0x54, 0x1f, 0xf0, 0xd2, 0xa8, 0x22, 0x12, 0x0f, 0x89, 0x78, 0x90, 0xef, 0xf6, 0x12, 0x27, 
+0x19, 0x12, 0x20, 0x59, 0x30, 0xe0, 0x25, 0x12, 0x20, 0x2d, 0xe0, 0x54, 0x7f, 0xf0, 0x78, 0x71, 
+0x12, 0x14, 0xeb, 0x90, 0x00, 0x02, 0x12, 0x13, 0xce, 0x30, 0xe7, 0x09, 0x90, 0x00, 0x02, 0xe4, 
+0x12, 0x14, 0x0d, 0x80, 0xe9, 0x12, 0x20, 0x2d, 0xe0, 0x44, 0x80, 0xf0, 0x12, 0x20, 0x59, 0x30, 
+0xe1, 0x1e, 0x12, 0x20, 0x1b, 0xe0, 0x54, 0x7f, 0xf0, 0x12, 0x2f, 0x15, 0x78, 0x6e, 0x12, 0x14, 
+0xeb, 0x90, 0x00, 0x02, 0x74, 0x80, 0x12, 0x14, 0x0d, 0x12, 0x20, 0x1b, 0xe0, 0x44, 0x80, 0xf0, 
+0x12, 0x2f, 0x80, 0xe4, 0xff, 0x12, 0x2e, 0xa5, 0x02, 0x10, 0x0c, 0x03, 0x6e, 0x01, 0xff, 0x48, 
+0x03, 0x71, 0x01, 0xff, 0x08, 0x02, 0x6c, 0x00, 0x00, 0x44, 0xfa, 0x94, 0x00, 0x00, 0x00, 0x00, 
+0x44, 0xfa, 0x90, 0x00, 0x00, 0x00, 0x00, 0x42, 0xfa, 0xae, 0x00, 0x00, 0x42, 0xfa, 0x7a, 0x00, 
+0x00, 0x42, 0xfa, 0x78, 0x00, 0x00, 0x42, 0xf9, 0x69, 0xff, 0xff, 0x42, 0xfa, 0x76, 0x00, 0x00, 
+0x43, 0xf9, 0x16, 0x0a, 0x32, 0x02, 0x41, 0xf9, 0x63, 0x20, 0x41, 0xf9, 0x64, 0x20, 0x41, 0xf9, 
+0x61, 0x00, 0x41, 0xf9, 0x62, 0x00, 0x44, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xf9, 0x65, 
+0x00, 0x41, 0xf9, 0x15, 0x00, 0x01, 0x20, 0x00, 0x41, 0xf8, 0x04, 0x00, 0x00, 0x12, 0x19, 0x82, 
+0xe5, 0x31, 0x64, 0x09, 0x70, 0x04, 0xe5, 0x30, 0x64, 0x01, 0x60, 0x48, 0xc3, 0xe5, 0x31, 0x94, 
+0x08, 0xe5, 0x30, 0x94, 0x00, 0x40, 0x11, 0x7f, 0x08, 0xef, 0xe5, 0x31, 0x94, 0x08, 0xf5, 0x31, 
+0xe5, 0x30, 0x94, 0x00, 0xf5, 0x30, 0x80, 0x05, 0xaf, 0x31, 0x12, 0x19, 0x92, 0xe4, 0xfe, 0xee, 
+0xc3, 0x9f, 0x50, 0x19, 0x12, 0x18, 0x2a, 0x12, 0x13, 0xb5, 0xfd, 0x74, 0xf8, 0x2e, 0xf5, 0x82, 
+0xe4, 0x34, 0xfe, 0xf5, 0x83, 0xed, 0xf0, 0x0e, 0x12, 0x18, 0x19, 0x80, 0xe2, 0xef, 0x54, 0x7f, 
+0x90, 0xff, 0x81, 0xf0, 0x22, 0x8b, 0x5f, 0x8a, 0x60, 0x89, 0x61, 0x12, 0x2a, 0x6e, 0x70, 0x05, 
+0xa3, 0x74, 0x08, 0xf0, 0x22, 0xab, 0x5f, 0xaa, 0x60, 0xa9, 0x61, 0x12, 0x2a, 0x62, 0x90, 0xfa, 
+0xc5, 0x12, 0x15, 0x06, 0xe5, 0x61, 0x24, 0x03, 0xf9, 0xe4, 0x35, 0x60, 0xfa, 0x90, 0xfa, 0xbf, 
+0x12, 0x15, 0x06, 0xe4, 0x90, 0xfa, 0xbe, 0xf0, 0x78, 0x91, 0xf6, 0x90, 0xfa, 0xbd, 0xe0, 0xff, 
+0x78, 0x91, 0xe6, 0xc3, 0x9f, 0x50, 0x12, 0x12, 0x2a, 0x40, 0xff, 0x12, 0x2a, 0x49, 0x12, 0x2a, 
+0x5c, 0x78, 0x91, 0x06, 0x12, 0x2a, 0x58, 0x80, 0xe2, 0x22, 0xad, 0x07, 0xac, 0x06, 0x90, 0x2f, 
+0x06, 0xe4, 0x93, 0xff, 0x78, 0x7a, 0xf6, 0x54, 0x0f, 0x12, 0x19, 0x07, 0xe0, 0x08, 0x76, 0x00, 
+0x08, 0xf6, 0x18, 0x12, 0x18, 0x42, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0x78, 0x7b, 
+0xee, 0xf6, 0x08, 0xef, 0xf6, 0xee, 0x44, 0xf8, 0x18, 0xf6, 0xef, 0x08, 0xf6, 0x90, 0xff, 0x7a, 
+0xe0, 0x20, 0xe7, 0x03, 0x7f, 0x00, 0x22, 0x78, 0x7b, 0xe6, 0xfe, 0x08, 0xe6, 0xf5, 0x82, 0x8e, 
+0x83, 0xec, 0xf0, 0xa3, 0xed, 0xf0, 0x90, 0xff, 0x7a, 0x74, 0x02, 0xf0, 0x7f, 0x01, 0x22, 0xab, 
+0x5c, 0xaa, 0x5d, 0xa9, 0x5e, 0x90, 0x00, 0x03, 0x12, 0x13, 0xce, 0x54, 0xf0, 0x24, 0xa0, 0x22, 
+0x90, 0xfa, 0xc5, 0x12, 0x14, 0xfd, 0x02, 0x13, 0xb5, 0x90, 0xfa, 0xbf, 0x12, 0x14, 0xfd, 0xef, 
+0x12, 0x13, 0xfb, 0x90, 0xfa, 0xc6, 0xe4, 0x22, 0x90, 0xfa, 0xc0, 0xe4, 0x75, 0xf0, 0x01, 0x02, 
+0x14, 0x2f, 0x90, 0x00, 0x08, 0x12, 0x14, 0x5b, 0xaa, 0xf0, 0xf9, 0x7b, 0x01, 0x22, 0x90, 0x00, 
+0x05, 0x12, 0x13, 0xce, 0x90, 0xfa, 0xbd, 0xf0, 0x22, 0xab, 0x5c, 0xaa, 0x5d, 0xa9, 0x5e, 0x22, 
+0x90, 0xfa, 0xd9, 0xe0, 0xff, 0x7e, 0x00, 0xc3, 0x90, 0xfa, 0xd3, 0xe0, 0x9f, 0xf0, 0x90, 0xfa, 
+0xd2, 0xe0, 0x9e, 0xf0, 0x90, 0xfa, 0xd4, 0xee, 0x8f, 0xf0, 0x12, 0x14, 0x2f, 0xef, 0x25, 0x57, 
+0xf5, 0x57, 0xee, 0x35, 0x56, 0xf5, 0x56, 0x22, 0x90, 0xff, 0xf0, 0xe0, 0x54, 0xfe, 0xf0, 0xe0, 
+0x54, 0xfd, 0xf0, 0x90, 0xfa, 0xe2, 0xe0, 0x64, 0x03, 0x22, 0x90, 0xff, 0xf2, 0xe0, 0xab, 0x3c, 
+0xaa, 0x3d, 0xa9, 0x3e, 0x02, 0x13, 0xfb, 0x90, 0xff, 0xf3, 0x74, 0xa0, 0xf0, 0x22, 0x8f, 0x6a, 
+0xed, 0x70, 0x0f, 0xe5, 0x6a, 0xb4, 0x03, 0x05, 0x7f, 0x01, 0x02, 0x2e, 0xeb, 0x7f, 0x02, 0x02, 
+0x2e, 0xeb, 0xaf, 0x6a, 0x12, 0x27, 0x19, 0x74, 0x74, 0x25, 0x6a, 0xf8, 0xe6, 0x30, 0xe2, 0x0b, 
+0xd2, 0x09, 0x12, 0x18, 0x9b, 0xe0, 0x54, 0x7f, 0xf0, 0x80, 0x02, 0xc2, 0x09, 0xe5, 0x6a, 0xb4, 
+0x03, 0x07, 0x7f, 0x81, 0x12, 0x2e, 0xeb, 0x80, 0x05, 0x7f, 0x82, 0x12, 0x2e, 0xeb, 0x30, 0x09, 
+0x07, 0x12, 0x18, 0x9b, 0xe0, 0x44, 0x80, 0xf0, 0x12, 0x2f, 0x80, 0x22, 0x12, 0x0f, 0x89, 0x90, 
+0xff, 0xfd, 0xe0, 0x44, 0x60, 0xf0, 0xd2, 0x01, 0x90, 0xff, 0xfc, 0xe0, 0x44, 0x02, 0xf0, 0x90, 
+0xff, 0x00, 0xe0, 0x30, 0xe7, 0x13, 0x90, 0xff, 0x83, 0xe0, 0x44, 0x80, 0xf0, 0x43, 0x2c, 0x80, 
+0x90, 0xff, 0xfc, 0xe0, 0x44, 0x01, 0xf0, 0x80, 0x0d, 0x12, 0x19, 0x3e, 0x53, 0x2c, 0x7f, 0x90, 
+0xff, 0xfc, 0xe0, 0x54, 0xfe, 0xf0, 0x90, 0xff, 0x81, 0xe0, 0x44, 0x80, 0xf0, 0x12, 0x02, 0x9f, 
+0x12, 0x19, 0x46, 0x02, 0x10, 0x0c, 0x12, 0x0f, 0x89, 0x78, 0x8a, 0x12, 0x20, 0x9e, 0x30, 0xe1, 
+0x07, 0x7f, 0x13, 0x12, 0x2e, 0xa5, 0x80, 0x34, 0x90, 0xf9, 0x65, 0xe0, 0x54, 0x03, 0x60, 0x16, 
+0x78, 0x8a, 0xe6, 0xb4, 0x03, 0x09, 0x90, 0xff, 0xa4, 0xe0, 0x54, 0xdf, 0xf0, 0x80, 0x07, 0x90, 
+0xff, 0xb4, 0xe0, 0x54, 0xdf, 0xf0, 0xc2, 0xb3, 0x90, 0xf9, 0x15, 0xe0, 0x04, 0xf0, 0x78, 0x8a, 
+0xe6, 0xff, 0x12, 0x20, 0x59, 0xfd, 0x12, 0x2d, 0x21, 0x12, 0x2e, 0xa5, 0x02, 0x10, 0x0c, 0x12, 
+0x0f, 0x89, 0x78, 0x8f, 0xef, 0xf6, 0xd2, 0x00, 0x12, 0x27, 0x19, 0x90, 0xf9, 0x66, 0x12, 0x14, 
+0xfd, 0xe9, 0x24, 0x03, 0xf9, 0xe4, 0x3a, 0xfa, 0xc0, 0x02, 0x78, 0x86, 0xe6, 0xfe, 0x08, 0xe6, 
+0xaa, 0x06, 0xf8, 0xac, 0x02, 0x7d, 0x01, 0xd0, 0x02, 0x12, 0x20, 0x4b, 0x12, 0x2f, 0x80, 0x78, 
+0x8f, 0xe6, 0xff, 0x12, 0x19, 0xbb, 0x12, 0x2e, 0xa5, 0x02, 0x10, 0x0c, 0x12, 0x0f, 0x89, 0x78, 
+0x8b, 0xef, 0xf6, 0x12, 0x2e, 0x4c, 0x12, 0x2e, 0xa5, 0x90, 0xf9, 0x65, 0xe0, 0x54, 0x03, 0x60, 
+0x16, 0x78, 0x8b, 0xe6, 0xb4, 0x03, 0x09, 0x90, 0xff, 0xa4, 0xe0, 0x44, 0x20, 0xf0, 0x80, 0x07, 
+0x90, 0xff, 0xb4, 0xe0, 0x44, 0x20, 0xf0, 0x90, 0xf9, 0x15, 0xe0, 0x14, 0xf0, 0xe0, 0x70, 0x02, 
+0xd2, 0xb3, 0x02, 0x10, 0x0c, 0x8f, 0x69, 0x12, 0x27, 0x19, 0x12, 0x20, 0x2d, 0xe0, 0x54, 0x3f, 
+0xf0, 0xe5, 0x82, 0x24, 0x04, 0x12, 0x20, 0x25, 0xe0, 0x54, 0x3f, 0xf0, 0x08, 0xe6, 0xfe, 0x08, 
+0xe6, 0x8e, 0x83, 0x24, 0x0b, 0x12, 0x20, 0x25, 0xe0, 0x54, 0xf8, 0xf0, 0x12, 0x2f, 0x80, 0x74, 
+0x74, 0x25, 0x69, 0xf8, 0x74, 0xfb, 0x56, 0xf6, 0x7f, 0x00, 0x22, 0x8f, 0x37, 0xc2, 0x08, 0x12, 
+0x27, 0x19, 0x12, 0x20, 0x38, 0x78, 0x84, 0x12, 0x20, 0x1d, 0xe0, 0x44, 0x01, 0xf0, 0x12, 0x20, 
+0x70, 0x12, 0x20, 0x21, 0xe0, 0x20, 0xe0, 0xf6, 0xef, 0x24, 0x0b, 0xf5, 0x82, 0xe4, 0x3e, 0xf5, 
+0x83, 0xe0, 0x54, 0xf8, 0xf0, 0x12, 0x2f, 0x80, 0xaf, 0x37, 0x12, 0x19, 0xbb, 0x22, 0x12, 0x0f, 
+0x89, 0x12, 0x27, 0x19, 0x12, 0x20, 0x70, 0x24, 0x06, 0x12, 0x20, 0x23, 0xe0, 0xfd, 0x12, 0x20, 
+0x53, 0x90, 0x00, 0x03, 0x12, 0x20, 0x78, 0x24, 0x05, 0x12, 0x20, 0x25, 0xe0, 0x90, 0x00, 0x04, 
+0x12, 0x14, 0x0d, 0x12, 0x2f, 0x80, 0x7d, 0x02, 0xe4, 0xff, 0x12, 0x2c, 0xc0, 0x02, 0x10, 0x0c, 
+0xae, 0x05, 0x12, 0x18, 0xed, 0xef, 0x12, 0x14, 0x0d, 0x0e, 0x0e, 0x0e, 0xee, 0xd3, 0x95, 0x35, 
+0xe4, 0x95, 0x34, 0x40, 0x02, 0xae, 0x35, 0xee, 0xd3, 0x94, 0x08, 0x74, 0x80, 0x94, 0x81, 0x40, 
+0x0a, 0x7e, 0x03, 0x90, 0x00, 0x02, 0x74, 0x02, 0x12, 0x14, 0x0d, 0xaf, 0x06, 0x12, 0x2f, 0x6a, 
+0x22, 0x12, 0x0f, 0x89, 0x78, 0x8c, 0x12, 0x20, 0x9e, 0x30, 0xe2, 0x07, 0x7f, 0x13, 0x12, 0x2e, 
+0xa5, 0x80, 0x1b, 0x78, 0x8c, 0xe6, 0x24, 0x74, 0xf8, 0xe6, 0x20, 0xe1, 0x07, 0x7f, 0x12, 0x12, 
+0x2e, 0xa5, 0x80, 0x0a, 0x78, 0x8c, 0xe6, 0xff, 0x12, 0x21, 0x6e, 0x12, 0x2e, 0xa5, 0x02, 0x10, 
+0x0c, 0xae, 0x07, 0xed, 0x54, 0x03, 0x64, 0x01, 0x60, 0x03, 0x7f, 0x10, 0x22, 0xed, 0x54, 0x7c, 
+0xc3, 0x94, 0x04, 0x50, 0x03, 0x7f, 0x0b, 0x22, 0x74, 0x74, 0x2e, 0xf8, 0x74, 0x02, 0x46, 0xf6, 
+0x74, 0x95, 0x2e, 0xf5, 0x82, 0xe4, 0x34, 0xfa, 0xf5, 0x83, 0xed, 0xf0, 0x7f, 0x00, 0x22, 0xbf, 
+0x03, 0x06, 0x7c, 0xff, 0x7d, 0xe0, 0x80, 0x04, 0x7c, 0xff, 0x7d, 0xe2, 0x8d, 0x82, 0x8c, 0x83, 
+0xe0, 0x44, 0x80, 0xf0, 0xe5, 0x82, 0x24, 0x04, 0x12, 0x20, 0x25, 0xe0, 0x44, 0x80, 0xf0, 0x74, 
+0x74, 0x2f, 0xf8, 0x74, 0x04, 0x46, 0xf6, 0x7f, 0x00, 0x22, 0x12, 0x0f, 0x89, 0xe5, 0x31, 0x64, 
+0x09, 0x70, 0x04, 0xe5, 0x30, 0x64, 0x01, 0x60, 0x16, 0x90, 0xff, 0x83, 0xe0, 0x54, 0x0f, 0xff, 
+0xc3, 0xe5, 0x31, 0x9f, 0xe5, 0x30, 0x94, 0x00, 0x40, 0x05, 0x12, 0x25, 0x9c, 0x80, 0x03, 0x12, 
+0x2f, 0x76, 0x02, 0x10, 0x0c, 0x90, 0xff, 0xfc, 0xe0, 0x20, 0xe7, 0x1f, 0xc2, 0xaf, 0x7d, 0xff, 
+0xac, 0x05, 0x1d, 0xec, 0x60, 0x15, 0x7e, 0x04, 0x7f, 0x00, 0xef, 0x1f, 0xaa, 0x06, 0x70, 0x01, 
+0x1e, 0x4a, 0x60, 0xec, 0x90, 0xff, 0x92, 0xe4, 0xf0, 0x80, 0xef, 0x22, 0x12, 0x0f, 0x89, 0x78, 
+0x6c, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x30, 0xe0, 0x12, 0x30, 0xe1, 0x0f, 0x90, 0xff, 0xfc, 0xe0, 
+0x44, 0x20, 0xf0, 0x7f, 0x04, 0x12, 0x11, 0x9f, 0x12, 0x19, 0x55, 0x02, 0x10, 0x0c, 0x8e, 0x65, 
+0x8f, 0x66, 0xe5, 0x66, 0x15, 0x66, 0xae, 0x65, 0x70, 0x02, 0x15, 0x65, 0xd3, 0x94, 0x00, 0xee, 
+0x94, 0x00, 0x40, 0x09, 0x7e, 0x07, 0x7f, 0xd0, 0x12, 0x0f, 0x62, 0x80, 0xe5, 0x22, 0x11, 0x1a, 
+0x2b, 0x1c, 0x23, 0x56, 0x2f, 0x5c, 0x2d, 0xcc, 0x2d, 0x7a, 0x2e, 0x6b, 0x2c, 0x8e, 0x2b, 0x66, 
+0x2b, 0xec, 0x2c, 0xf1, 0x2e, 0x2d, 0x1b, 0xe6, 0x2b, 0xaf, 0x28, 0x67, 0x0e, 0x12, 0x0f, 0x89, 
+0x78, 0x8d, 0x12, 0x20, 0x9e, 0x20, 0xe2, 0x07, 0x7f, 0x11, 0x12, 0x2e, 0xa5, 0x80, 0x0a, 0x78, 
+0x8d, 0xe6, 0xff, 0x12, 0x2c, 0x25, 0x12, 0x2e, 0xa5, 0x02, 0x10, 0x0c, 0x8f, 0x67, 0x12, 0x2c, 
+0x25, 0xaf, 0x67, 0x12, 0x27, 0x19, 0x12, 0x20, 0x38, 0x12, 0x2f, 0x80, 0x74, 0x74, 0x25, 0x67, 
+0xf8, 0x74, 0xfd, 0x56, 0xf6, 0xaf, 0x67, 0x12, 0x19, 0xbb, 0x22, 0x12, 0x0f, 0x89, 0xe5, 0x31, 
+0x64, 0x09, 0x70, 0x04, 0xe5, 0x30, 0x64, 0x01, 0x60, 0x05, 0x12, 0x29, 0x2d, 0x80, 0x06, 0x12, 
+0x19, 0x7a, 0x12, 0x19, 0x82, 0x02, 0x10, 0x0c, 0x12, 0x27, 0xfb, 0x12, 0x12, 0x3b, 0x90, 0xf8, 
+0x04, 0xe0, 0xff, 0x60, 0x05, 0x7d, 0x01, 0x12, 0x11, 0xd8, 0x12, 0x26, 0xa3, 0x12, 0x12, 0x77, 
+0x12, 0x10, 0xfa, 0x80, 0xe3, 0x12, 0x18, 0xed, 0xef, 0x12, 0x14, 0x0d, 0xe4, 0xf5, 0x2a, 0xf5, 
+0x2b, 0xef, 0x60, 0x03, 0x02, 0x2f, 0x76, 0xe4, 0xff, 0x12, 0x2f, 0x6a, 0x22, 0x90, 0xff, 0xf0, 
+0xe0, 0xff, 0x54, 0xa0, 0x60, 0xf7, 0xef, 0x30, 0xe5, 0x08, 0x90, 0xff, 0xf0, 0x44, 0x20, 0xf0, 
+0xc3, 0x22, 0xd3, 0x22, 0x90, 0xff, 0xf0, 0xe0, 0xff, 0x54, 0x28, 0x60, 0xf7, 0xef, 0x30, 0xe5, 
+0x08, 0x90, 0xff, 0xf0, 0x44, 0x20, 0xf0, 0xc3, 0x22, 0xd3, 0x22, 0xef, 0x30, 0xe7, 0x08, 0x12, 
+0x18, 0xad, 0xe0, 0x54, 0xdf, 0xf0, 0x22, 0xef, 0x12, 0x18, 0xf7, 0xe0, 0x54, 0xdf, 0xf0, 0x22, 
+0x81, 0x01, 0x82, 0x02, 0x83, 0x03, 0x87, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
+0x00, 0x40, 0x00, 0x08, 0x00, 0x78, 0x84, 0x12, 0x20, 0x2f, 0xa3, 0xa3, 0xe0, 0xff, 0x30, 0xe7, 
+0x06, 0x54, 0x7f, 0xf0, 0x44, 0x80, 0xf0, 0x22, 0x85, 0x34, 0x30, 0x85, 0x35, 0x31, 0x90, 0xff, 
+0x82, 0xe0, 0x54, 0xf7, 0xf0, 0xa3, 0xe0, 0x54, 0x7f, 0xf0, 0x22, 0xe4, 0xfe, 0xee, 0x90, 0x2f, 
+0x00, 0x93, 0xb5, 0x07, 0x02, 0xd3, 0x22, 0x0e, 0xbe, 0x07, 0xf2, 0xc3, 0x22, 0x00, 0x08, 0x18, 
+0x38, 0x28, 0x01, 0x81, 0x10, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x0f, 0x89, 0x7f, 
+0x02, 0x12, 0x10, 0x18, 0x12, 0x19, 0x55, 0x02, 0x10, 0x0c, 0x75, 0x30, 0x00, 0x8f, 0x31, 0x12, 
+0x18, 0x49, 0x12, 0x29, 0x2d, 0x22, 0x12, 0x19, 0x82, 0x12, 0x19, 0x3e, 0x12, 0x19, 0x7a, 0x22, 
+0xc2, 0x08, 0x22, 
 };
 
 #undef IMAGE_VERSION_NAME
diff -Naur linuxppc-2.6.9/drivers/usb/serial/io_fw_down.h linuxppc-2.6.9-dream/drivers/usb/serial/io_fw_down.h
--- linuxppc-2.6.9/drivers/usb/serial/io_fw_down.h	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/io_fw_down.h	2005-09-19 21:40:06.000000000 +0200
@@ -17,7 +17,7 @@
 		unsigned short	Addr;
 		unsigned short	Len;
 		unsigned char	Data[0];
-	} __attribute__ ((packed));
+	} __attribute ((packed));
 
 	struct edge_firmware_version_info {
 		unsigned char	MajorVersion;
@@ -36,11 +36,11 @@
 
 // Segment #1, Start Address 00ff0000, Length 6
 0xff,0x00,0x00,0x00,0x06,0x00,
-    0x02, 0x00, 0x80, 0x02, 0x44, 0xb0, 
+    0x02, 0x00, 0x80, 0x02, 0x49, 0x39, 
 
 // Segment #2, Start Address 00ff000b, Length 3
 0xff,0x00,0x0b,0x00,0x03,0x00,
-    0x02, 0x44, 0x72, 
+    0x02, 0x44, 0x1a, 
 
 // Segment #3, Start Address 00ff0013, Length 3
 0xff,0x00,0x13,0x00,0x03,0x00,
@@ -72,11 +72,11 @@
 
 // Segment #10, Start Address 00ff004b, Length 3
 0xff,0x00,0x4b,0x00,0x03,0x00,
-    0x02, 0x6e, 0xc4, 
+    0x02, 0x70, 0xd4, 
 
 // Segment #11, Start Address 00ff0053, Length 3
 0xff,0x00,0x53,0x00,0x03,0x00,
-    0x02, 0x75, 0x8d, 
+    0x02, 0x77, 0x9d, 
 
 // Segment #12, Start Address 00ff007b, Length 3
 0xff,0x00,0x7b,0x00,0x03,0x00,
@@ -86,745 +86,657 @@
 0xff,0x00,0x80,0x00,0x07,0x00,
     0x7e, 0x14, 0x00, 0x00, 0x02, 0x40, 0x51, 
 
-// Segment #14, Start Address 00ff3000, Length 2178
-0xff,0x00,0x00,0x30,0x82,0x08,
-    0x12, 0x37, 0x28, 0x12, 0x30, 0x3e, 0x12, 0x30, 0x54, 0x12, 0x30, 0xe5, 0x12, 0x31, 0x68, 0x12, 
-    0x35, 0x20, 0x12, 0x38, 0x58, 0x12, 0x31, 0x15, 0x12, 0x31, 0x40, 0x12, 0x30, 0xa0, 0x80, 0xe0, 
-    0xe5, 0x23, 0x60, 0x19, 0x7e, 0x14, 0x00, 0x00, 0x09, 0xb1, 0x01, 0xcf, 0xb4, 0x00, 0x02, 0x80, 
-    0x05, 0x14, 0x19, 0xb1, 0x01, 0xcf, 0xa5, 0x0b, 0xbe, 0x31, 0x2f, 0x78, 0xeb, 0x22, 0xc2, 0xaf, 
-    0x7e, 0xb3, 0x3f, 0xf1, 0xb4, 0x01, 0x0a, 0xc0, 0xf1, 0x75, 0xf1, 0x02, 0x12, 0x70, 0xef, 0xd0, 
-    0xf1, 0xd2, 0xaf, 0x22, 0xc2, 0xaf, 0xe5, 0x22, 0x60, 0x43, 0x7e, 0x07, 0x01, 0xe1, 0xbe, 0x04, 
-    0x03, 0x80, 0x38, 0x39, 0x7e, 0x04, 0x80, 0x00, 0x7e, 0x20, 0x00, 0x13, 0x50, 0x21, 0x09, 0xa0, 
-    0x00, 0x04, 0x4e, 0xa0, 0x05, 0x19, 0xa0, 0x00, 0x04, 0x0a, 0x32, 0x09, 0x53, 0x67, 0x8e, 0x5e, 
-    0x51, 0x27, 0x68, 0x0b, 0x09, 0xa0, 0x00, 0x10, 0x4e, 0xa0, 0x01, 0x19, 0xa0, 0x00, 0x10, 0x2e, 
-    0x04, 0x01, 0x00, 0xa5, 0x0a, 0xbe, 0x21, 0x2f, 0x78, 0xd1, 0x75, 0x22, 0x00, 0xd2, 0xaf, 0x22, 
-    0xc2, 0xaf, 0x7e, 0x20, 0x00, 0x7e, 0x30, 0x01, 0x7c, 0xb2, 0x23, 0x0a, 0x2b, 0x49, 0x32, 0x01, 
-    0x8f, 0xbe, 0x34, 0x00, 0x00, 0x68, 0x12, 0x7e, 0xb1, 0x21, 0xa5, 0x4b, 0x7a, 0xb1, 0x21, 0xca, 
-    0x19, 0x49, 0x22, 0x30, 0xd5, 0x99, 0x24, 0xda, 0x19, 0x3e, 0x30, 0xa5, 0x0a, 0xbe, 0x21, 0x2f, 
-    0x78, 0xd6, 0xd2, 0xaf, 0x22, 0x46, 0x0f, 0x49, 0x67, 0x4c, 0xbf, 0x50, 0x17, 0x53, 0x6f, 0x56, 
-    0xc7, 0x5a, 0x1f, 0x5d, 0x77, 0xc2, 0xaf, 0xe5, 0x32, 0x60, 0x14, 0x7e, 0x20, 0x00, 0x13, 0x50, 
-    0x07, 0xca, 0xb8, 0x12, 0x31, 0x02, 0xda, 0xb8, 0xa5, 0x0a, 0xbe, 0x21, 0x2f, 0x78, 0xef, 0xd2, 
-    0xaf, 0x22, 0xca, 0x28, 0x12, 0x67, 0xab, 0xda, 0x28, 0x40, 0x09, 0x0a, 0x22, 0x09, 0xb2, 0x67, 
-    0x8e, 0xf4, 0x52, 0x32, 0x22, 0xc2, 0xaf, 0xe5, 0x34, 0x60, 0x14, 0x7e, 0x20, 0x00, 0x13, 0x50, 
-    0x07, 0xca, 0xb8, 0x12, 0x31, 0x32, 0xda, 0xb8, 0xa5, 0x0a, 0xbe, 0x21, 0x2f, 0x78, 0xef, 0xd2, 
-    0xaf, 0x22, 0xca, 0x28, 0x0a, 0x22, 0x09, 0x42, 0x00, 0x3e, 0x12, 0x69, 0xc2, 0xda, 0x28, 0x22, 
-    0xc2, 0xaf, 0xe5, 0x35, 0x60, 0x14, 0x7e, 0x20, 0x00, 0x13, 0x50, 0x07, 0xca, 0xb8, 0x12, 0x31, 
-    0x5d, 0xda, 0xb8, 0xa5, 0x0a, 0xbe, 0x21, 0x2f, 0x78, 0xef, 0xd2, 0xaf, 0x22, 0xca, 0x28, 0x7e, 
-    0x40, 0x00, 0x12, 0x6c, 0x5b, 0xda, 0x28, 0x22, 0xc2, 0xaf, 0xe5, 0x23, 0x60, 0x14, 0x7e, 0x20, 
-    0x00, 0x13, 0x50, 0x07, 0xca, 0xb8, 0x12, 0x31, 0x85, 0xda, 0xb8, 0xa5, 0x0a, 0xbe, 0x21, 0x2f, 
-    0x78, 0xef, 0xd2, 0xaf, 0x22, 0x7c, 0xb2, 0x23, 0x0a, 0x2b, 0x49, 0x22, 0x31, 0x90, 0x89, 0x24, 
-    0x31, 0xa0, 0x32, 0x10, 0x32, 0x80, 0x32, 0xf0, 0x33, 0x60, 0x33, 0xd0, 0x34, 0x40, 0x34, 0xb0, 
-    0x7e, 0x27, 0x01, 0x8f, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x80, 0x00, 0x09, 0xb2, 
-    0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 
-    0x49, 0x30, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 
-    0x01, 0x9f, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0x9f, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xcf, 0x80, 
-    0x2e, 0x7e, 0x63, 0x01, 0xcf, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 
-    0xa0, 0xc8, 0x12, 0x62, 0xb6, 0x40, 0x18, 0x75, 0x31, 0xb3, 0x12, 0x7c, 0x15, 0xc2, 0x18, 0x6c, 
-    0x00, 0x7a, 0x03, 0x01, 0xcf, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 
-    0x7e, 0x27, 0x01, 0x91, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x81, 0x00, 0x09, 0xb2, 
-    0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 
-    0x4c, 0x88, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 
-    0x01, 0xa1, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0xa1, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xd0, 0x80, 
-    0x2e, 0x7e, 0x63, 0x01, 0xd0, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 
-    0xa0, 0xc8, 0x12, 0x62, 0xb6, 0x40, 0x18, 0x75, 0x31, 0xb3, 0x12, 0x7c, 0x15, 0xc2, 0x19, 0x6c, 
-    0x00, 0x7a, 0x03, 0x01, 0xd0, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 
-    0x7e, 0x27, 0x01, 0x93, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x82, 0x00, 0x09, 0xb2, 
-    0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 
-    0x4f, 0xe0, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 
-    0x01, 0xa3, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0xa3, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xd1, 0x80, 
-    0x2e, 0x7e, 0x63, 0x01, 0xd1, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 
-    0xa0, 0xc8, 0x12, 0x62, 0xb6, 0x40, 0x18, 0x75, 0x31, 0xb3, 0x12, 0x7c, 0x15, 0xc2, 0x1a, 0x6c, 
-    0x00, 0x7a, 0x03, 0x01, 0xd1, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 
-    0x7e, 0x27, 0x01, 0x95, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x83, 0x00, 0x09, 0xb2, 
-    0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 
-    0x53, 0x38, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 
-    0x01, 0xa5, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0xa5, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xd2, 0x80, 
-    0x2e, 0x7e, 0x63, 0x01, 0xd2, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 
-    0xa0, 0xc8, 0x12, 0x62, 0xb6, 0x40, 0x18, 0x75, 0x31, 0xb3, 0x12, 0x7c, 0x15, 0xc2, 0x1b, 0x6c, 
-    0x00, 0x7a, 0x03, 0x01, 0xd2, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 
-    0x7e, 0x27, 0x01, 0x97, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x84, 0x00, 0x09, 0xb2, 
-    0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 
-    0x56, 0x90, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 
-    0x01, 0xa7, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0xa7, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xd3, 0x80, 
-    0x2e, 0x7e, 0x63, 0x01, 0xd3, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 
-    0xa0, 0xc8, 0x12, 0x62, 0xb6, 0x40, 0x18, 0x75, 0x31, 0xb3, 0x12, 0x7c, 0x15, 0xc2, 0x1c, 0x6c, 
-    0x00, 0x7a, 0x03, 0x01, 0xd3, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 
-    0x7e, 0x27, 0x01, 0x99, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x85, 0x00, 0x09, 0xb2, 
-    0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 
-    0x59, 0xe8, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 
-    0x01, 0xa9, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0xa9, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xd4, 0x80, 
-    0x2e, 0x7e, 0x63, 0x01, 0xd4, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 
-    0xa0, 0xc8, 0x12, 0x62, 0xb6, 0x40, 0x18, 0x75, 0x31, 0xb3, 0x12, 0x7c, 0x15, 0xc2, 0x1d, 0x6c, 
-    0x00, 0x7a, 0x03, 0x01, 0xd4, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 
-    0x7e, 0x27, 0x01, 0x9b, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x86, 0x00, 0x09, 0xb2, 
-    0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 
-    0x5d, 0x40, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 
-    0x01, 0xab, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0xab, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xd5, 0x80, 
-    0x2e, 0x7e, 0x63, 0x01, 0xd5, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 
-    0xa0, 0xc8, 0x12, 0x62, 0xb6, 0x40, 0x18, 0x75, 0x31, 0xb3, 0x12, 0x7c, 0x15, 0xc2, 0x1e, 0x6c, 
-    0x00, 0x7a, 0x03, 0x01, 0xd5, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 
-    0x7e, 0x27, 0x01, 0x9d, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x87, 0x00, 0x09, 0xb2, 
-    0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 
-    0x60, 0x98, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 
-    0x01, 0xad, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0xad, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xd6, 0x80, 
-    0x2e, 0x7e, 0x63, 0x01, 0xd6, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 
-    0xa0, 0xc8, 0x12, 0x62, 0xb6, 0x40, 0x18, 0x75, 0x31, 0xb3, 0x12, 0x7c, 0x15, 0xc2, 0x1f, 0x6c, 
-    0x00, 0x7a, 0x03, 0x01, 0xd6, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 
-    0xc2, 0xaf, 0xe5, 0x24, 0x60, 0x14, 0x7e, 0x20, 0x00, 0x13, 0x50, 0x07, 0xca, 0xb8, 0x12, 0x35, 
-    0x3d, 0xda, 0xb8, 0xa5, 0x0a, 0xbe, 0x21, 0x2f, 0x78, 0xef, 0xd2, 0xaf, 0x22, 0x7c, 0xb2, 0x23, 
-    0x0a, 0x2b, 0x49, 0x22, 0x35, 0x48, 0x89, 0x24, 0x35, 0x58, 0x35, 0x92, 0x35, 0xcc, 0x36, 0x06, 
-    0x36, 0x40, 0x36, 0x7a, 0x36, 0xb4, 0x36, 0xee, 0x7e, 0x24, 0x80, 0x00, 0x09, 0xb2, 0x00, 0x14, 
-    0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x49, 0x30, 
-    0x7d, 0x21, 0xda, 0x19, 0x5e, 0xb0, 0x01, 0x7e, 0xa0, 0x90, 0x12, 0x62, 0x93, 0x40, 0x12, 0x75, 
-    0x31, 0xb8, 0x12, 0x7c, 0x15, 0xc2, 0x20, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 
-    0xf1, 0x22, 0x7e, 0x24, 0x81, 0x00, 0x09, 0xb2, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 
-    0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x4c, 0x88, 0x7d, 0x21, 0xda, 0x19, 0x5e, 0xb0, 
-    0x01, 0x7e, 0xa0, 0x90, 0x12, 0x62, 0x93, 0x40, 0x12, 0x75, 0x31, 0xb8, 0x12, 0x7c, 0x15, 0xc2, 
-    0x21, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0x7e, 0x24, 0x82, 0x00, 
-    0x09, 0xb2, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 
-    0x12, 0x12, 0x4f, 0xe0, 0x7d, 0x21, 0xda, 0x19, 0x5e, 0xb0, 0x01, 0x7e, 0xa0, 0x90, 0x12, 0x62, 
-    0x93, 0x40, 0x12, 0x75, 0x31, 0xb8, 0x12, 0x7c, 0x15, 0xc2, 0x22, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 
-    0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0x7e, 0x24, 0x83, 0x00, 0x09, 0xb2, 0x00, 0x14, 0xca, 0xb8, 
-    0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x53, 0x38, 0x7d, 0x21, 
-    0xda, 0x19, 0x5e, 0xb0, 0x01, 0x7e, 0xa0, 0x90, 0x12, 0x62, 0x93, 0x40, 0x12, 0x75, 0x31, 0xb8, 
-    0x12, 0x7c, 0x15, 0xc2, 0x23, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 
-    0x7e, 0x24, 0x84, 0x00, 0x09, 0xb2, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 
-    0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x56, 0x90, 0x7d, 0x21, 0xda, 0x19, 0x5e, 0xb0, 0x01, 0x7e, 
-    0xa0, 0x90, 0x12, 0x62, 0x93, 0x40, 0x12, 0x75, 0x31, 0xb8, 0x12, 0x7c, 0x15, 0xc2, 0x24, 0xc0, 
-    0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0x7e, 0x24, 0x85, 0x00, 0x09, 0xb2, 
-    0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 
-    0x59, 0xe8, 0x7d, 0x21, 0xda, 0x19, 0x5e, 0xb0, 0x01, 0x7e, 0xa0, 0x90, 0x12, 0x62, 0x93, 0x40, 
-    0x12, 0x75, 0x31, 0xb8, 0x12, 0x7c, 0x15, 0xc2, 0x25, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 
-    0xd9, 0xd0, 0xf1, 0x22, 0x7e, 0x24, 0x86, 0x00, 0x09, 0xb2, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 
-    0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x5d, 0x40, 0x7d, 0x21, 0xda, 0x19, 
-    0x5e, 0xb0, 0x01, 0x7e, 0xa0, 0x90, 0x12, 0x62, 0x93, 0x40, 0x12, 0x75, 0x31, 0xb8, 0x12, 0x7c, 
-    0x15, 0xc2, 0x26, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0x7e, 0x24, 
-    0x87, 0x00, 0x09, 0xb2, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 
-    0x19, 0x7d, 0x12, 0x12, 0x60, 0x98, 0x7d, 0x21, 0xda, 0x19, 0x5e, 0xb0, 0x01, 0x7e, 0xa0, 0x90, 
-    0x12, 0x62, 0x93, 0x40, 0x12, 0x75, 0x31, 0xb8, 0x12, 0x7c, 0x15, 0xc2, 0x27, 0xc0, 0xf1, 0x75, 
-    0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0xc2, 0xaf, 0xe5, 0x33, 0x60, 0x14, 0x7e, 0x20, 
-    0x00, 0x13, 0x50, 0x07, 0xca, 0xb8, 0x12, 0x37, 0x45, 0xda, 0xb8, 0xa5, 0x0a, 0xbe, 0x21, 0x2f, 
-    0x78, 0xef, 0xd2, 0xaf, 0x22, 0x7c, 0xb2, 0x23, 0x0a, 0x2b, 0x49, 0x22, 0x37, 0x50, 0x89, 0x24, 
-    0x37, 0x60, 0x37, 0x7f, 0x37, 0x9e, 0x37, 0xbd, 0x37, 0xdc, 0x37, 0xfb, 0x38, 0x1a, 0x38, 0x39, 
-    0x7e, 0x24, 0x80, 0x00, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x48, 0x1b, 0xda, 0x19, 0x10, 0x04, 0x02, 
-    0x80, 0x0c, 0xd2, 0x01, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0x7e, 
-    0x24, 0x81, 0x00, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x4b, 0x73, 0xda, 0x19, 0x10, 0x04, 0x02, 0x80, 
-    0x0c, 0xd2, 0x01, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0x7e, 0x24, 
-    0x82, 0x00, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x4e, 0xcb, 0xda, 0x19, 0x10, 0x04, 0x02, 0x80, 0x0c, 
-    0xd2, 0x01, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0x7e, 0x24, 0x83, 
-    0x00, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x52, 0x23, 0xda, 0x19, 0x10, 0x04, 0x02, 0x80, 0x0c, 0xd2, 
-    0x01, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0x7e, 0x24, 0x84, 0x00, 
-    0xca, 0x19, 0x7d, 0x12, 0x12, 0x55, 0x7b, 0xda, 0x19, 0x10, 0x04, 0x02, 0x80, 0x0c, 0xd2, 0x01, 
-    0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0x7e, 0x24, 0x85, 0x00, 0xca, 
-    0x19, 0x7d, 0x12, 0x12, 0x58, 0xd3, 0xda, 0x19, 0x10, 0x04, 0x02, 0x80, 0x0c, 0xd2, 0x01, 0xc0, 
-    0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0x7e, 0x24, 0x86, 0x00, 0xca, 0x19, 
-    0x7d, 0x12, 0x12, 0x5c, 0x2b, 0xda, 0x19, 0x10, 0x04, 0x02, 0x80, 0x0c, 0xd2, 0x01, 0xc0, 0xf1, 
-    0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0x7e, 0x24, 0x87, 0x00, 0xca, 0x19, 0x7d, 
-    0x12, 0x12, 0x5f, 0x83, 0xda, 0x19, 0x10, 0x04, 0x02, 0x80, 0x0c, 0xd2, 0x01, 0xc0, 0xf1, 0x75, 
-    0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0xc2, 0xaf, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0xa9, 
-    0x32, 0xf2, 0x1a, 0x7e, 0x07, 0x01, 0xe1, 0xbe, 0x04, 0x00, 0x00, 0x78, 0x10, 0xe5, 0xf5, 0x33, 
-    0x82, 0xe7, 0x40, 0x09, 0x85, 0x31, 0x31, 0x12, 0x7c, 0x15, 0x75, 0xf6, 0x00, 0xd0, 0xf1, 0xd2, 
-    0xaf, 0x22, 
-
-// Segment #15, Start Address 00ff4000, Length 15381
-0xff,0x00,0x00,0x40,0x15,0x3c,
+// Segment #14, Start Address 00ff4000, Length 15920
+0xff,0x00,0x00,0x40,0x30,0x3e,
     0x7e, 0x04, 0x00, 0x01, 0x7e, 0x14, 0x7f, 0xf8, 0x7e, 0x24, 0x00, 0xfe, 0x7d, 0x31, 0x0b, 0x1a, 
-    0x50, 0x1b, 0x0a, 0x50, 0x7e, 0x14, 0x40, 0x1b, 0x02, 0x40, 0x6a, 0x7e, 0xf8, 0x00, 0x6f, 0xd2, 
-    0x04, 0xc2, 0x94, 0xd2, 0x95, 0x7e, 0xf4, 0x40, 0x2c, 0x02, 0x40, 0x7c, 0x12, 0x7d, 0x30, 0xf5, 
-    0x2f, 0x7a, 0xa1, 0x30, 0x7a, 0x11, 0x6e, 0x12, 0x75, 0xca, 0x12, 0x40, 0xdc, 0x7e, 0xb3, 0x3f, 
-    0xf1, 0x60, 0x03, 0x12, 0x43, 0xd4, 0x75, 0xf1, 0x00, 0x12, 0x76, 0x6f, 0xd2, 0xaf, 0x02, 0x30, 
-    0x00, 0x7e, 0x04, 0x00, 0xff, 0x7e, 0x18, 0x40, 0x5f, 0x7a, 0x1c, 0x00, 0x01, 0x89, 0x18, 0xa9, 
+    0x50, 0x1b, 0x0a, 0x50, 0x7e, 0x14, 0x40, 0x1b, 0x02, 0x40, 0x6a, 0x7e, 0xf8, 0x00, 0x59, 0xd2, 
+    0x04, 0xc2, 0x94, 0xd2, 0x95, 0x7e, 0xf4, 0x40, 0x2c, 0x02, 0x40, 0x7c, 0x12, 0x7f, 0x3f, 0xf5, 
+    0x2e, 0x7a, 0xa1, 0x2d, 0x7a, 0x11, 0x58, 0x12, 0x77, 0xda, 0x12, 0x40, 0xdc, 0x7e, 0xb3, 0x3f, 
+    0xf1, 0x60, 0x03, 0x12, 0x43, 0x68, 0x75, 0xf1, 0x00, 0x12, 0x78, 0x7f, 0xd2, 0xaf, 0x02, 0x44, 
+    0x06, 0x7e, 0x04, 0x00, 0xff, 0x7e, 0x18, 0x40, 0x5f, 0x7a, 0x1c, 0x00, 0x01, 0x89, 0x18, 0xa9, 
     0x25, 0x87, 0x03, 0xa9, 0xd5, 0x87, 0xd2, 0x93, 0x89, 0x08, 0x7e, 0x04, 0x00, 0xff, 0x7e, 0x18, 
     0x40, 0x78, 0x7a, 0x1c, 0x00, 0x01, 0x89, 0x18, 0xc2, 0x93, 0x89, 0x08, 0x7e, 0x08, 0x00, 0x20, 
-    0x7e, 0x44, 0x04, 0x00, 0x7e, 0x40, 0x00, 0x7e, 0xe4, 0x40, 0x8e, 0x02, 0x7c, 0x30, 0x7e, 0x08, 
-    0x01, 0x6f, 0x7e, 0x44, 0x28, 0x7c, 0x7e, 0x40, 0x00, 0x7e, 0xe4, 0x40, 0xa0, 0x02, 0x7c, 0x30, 
-    0x7e, 0x08, 0x00, 0x6f, 0x7e, 0x44, 0x01, 0x00, 0x7e, 0x40, 0x53, 0x7e, 0xe4, 0x40, 0xb2, 0x02, 
-    0x7c, 0x30, 0x75, 0x6d, 0x20, 0x75, 0x6c, 0x30, 0x7e, 0x04, 0x00, 0x08, 0x75, 0x6a, 0x58, 0x75, 
-    0x6b, 0x08, 0x75, 0x67, 0x08, 0x75, 0x69, 0x01, 0x75, 0x89, 0x01, 0x75, 0x8a, 0x01, 0x75, 0x8c, 
-    0x00, 0xd2, 0x8c, 0x7e, 0x04, 0x00, 0x02, 0x7a, 0x05, 0x58, 0x89, 0xf4, 0x75, 0xb7, 0x7f, 0x75, 
+    0x7e, 0x44, 0x04, 0x00, 0x7e, 0x40, 0x00, 0x7e, 0xe4, 0x40, 0x8e, 0x02, 0x7e, 0x4b, 0x7e, 0x08, 
+    0x01, 0x59, 0x7e, 0x44, 0x28, 0x7c, 0x7e, 0x40, 0x00, 0x7e, 0xe4, 0x40, 0xa0, 0x02, 0x7e, 0x4b, 
+    0x7e, 0x08, 0x00, 0x59, 0x7e, 0x44, 0x01, 0x00, 0x7e, 0x40, 0x53, 0x7e, 0xe4, 0x40, 0xb2, 0x02, 
+    0x7e, 0x4b, 0x75, 0x57, 0x20, 0x75, 0x56, 0x30, 0x7e, 0x04, 0x00, 0x08, 0x75, 0x54, 0x58, 0x75, 
+    0x55, 0x08, 0x75, 0x51, 0x08, 0x75, 0x53, 0x01, 0x75, 0x89, 0x01, 0x75, 0x8a, 0x01, 0x75, 0x8c, 
+    0x00, 0xd2, 0x8c, 0x7e, 0x04, 0x00, 0x02, 0x7a, 0x05, 0x42, 0x89, 0xf4, 0x75, 0xb7, 0x7f, 0x75, 
     0xb8, 0x7f, 0x75, 0xb3, 0x07, 0x75, 0xb2, 0x07, 0xd2, 0xa9, 0x22, 0xd2, 0x92, 0xe4, 0xd5, 0xe0, 
-    0xfd, 0xc2, 0x92, 0x7e, 0x24, 0x80, 0x00, 0x7e, 0x11, 0x2f, 0x7e, 0xa0, 0x08, 0x19, 0xa2, 0x00, 
-    0x10, 0x2e, 0x24, 0x01, 0x00, 0xa5, 0xd9, 0xf2, 0x7e, 0x20, 0x00, 0x12, 0x41, 0x7e, 0x0b, 0x20, 
-    0xbe, 0x21, 0x2f, 0x78, 0xf6, 0x22, 0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 0x74, 0xbf, 0x19, 0xb0, 
+    0xfd, 0xc2, 0x92, 0x7e, 0x24, 0x80, 0x00, 0x7e, 0x11, 0x2e, 0x7e, 0xa0, 0x08, 0x19, 0xa2, 0x00, 
+    0x10, 0x2e, 0x24, 0x01, 0x00, 0xa5, 0xd9, 0xf2, 0x7e, 0x20, 0x00, 0x12, 0x41, 0x72, 0x0b, 0x20, 
+    0xbe, 0x21, 0x2e, 0x78, 0xf6, 0x22, 0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 0x74, 0xbf, 0x19, 0xb0, 
     0x00, 0x0c, 0x74, 0x10, 0x19, 0xb0, 0x00, 0x08, 0x74, 0x80, 0x19, 0xb0, 0x00, 0x0c, 0x7e, 0x54, 
     0x00, 0x02, 0x19, 0xa0, 0x00, 0x04, 0x19, 0xb0, 0x00, 0x00, 0x74, 0x03, 0x19, 0xb0, 0x00, 0x0c, 
-    0x74, 0x07, 0xa9, 0x20, 0x30, 0x0b, 0xa9, 0x35, 0x30, 0x05, 0xbe, 0x20, 0x01, 0x28, 0x02, 0x74, 
-    0x0f, 0x19, 0xb0, 0x00, 0x04, 0xa9, 0x33, 0x30, 0x18, 0x74, 0xbf, 0x19, 0xb0, 0x00, 0x0c, 0x74, 
-    0x28, 0xa9, 0x20, 0x30, 0x02, 0x74, 0x20, 0x19, 0xb0, 0x00, 0x04, 0x74, 0x03, 0x19, 0xb0, 0x00, 
-    0x0c, 0x74, 0xa7, 0x19, 0xb0, 0x00, 0x08, 0x74, 0x0c, 0x19, 0xb0, 0x00, 0x10, 0x22, 0x7e, 0x04, 
-    0x80, 0x00, 0x4c, 0x02, 0xe4, 0x19, 0xb0, 0x00, 0x04, 0x09, 0xb0, 0x00, 0x10, 0x54, 0x08, 0x19, 
-    0xb0, 0x00, 0x10, 0x74, 0xa7, 0x19, 0xb0, 0x00, 0x08, 0x22, 0x7c, 0xb2, 0x23, 0x0a, 0x2b, 0x49, 
-    0x22, 0x41, 0xa5, 0x89, 0x24, 0x41, 0xb5, 0x41, 0xd4, 0x41, 0xf3, 0x42, 0x12, 0x42, 0x31, 0x42, 
-    0x50, 0x42, 0x6f, 0x42, 0x8e, 0xc2, 0x10, 0xc2, 0x18, 0xc2, 0x20, 0xc2, 0x08, 0x7e, 0x04, 0x09, 
-    0xe3, 0x7a, 0x07, 0x01, 0x6f, 0x7a, 0x07, 0x01, 0x7f, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x8f, 0x7a, 
-    0x07, 0x01, 0x9f, 0x22, 0xc2, 0x11, 0xc2, 0x19, 0xc2, 0x21, 0xc2, 0x09, 0x7e, 0x04, 0x0d, 0xe3, 
-    0x7a, 0x07, 0x01, 0x71, 0x7a, 0x07, 0x01, 0x81, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x91, 0x7a, 0x07, 
-    0x01, 0xa1, 0x22, 0xc2, 0x12, 0xc2, 0x1a, 0xc2, 0x22, 0xc2, 0x0a, 0x7e, 0x04, 0x11, 0xe3, 0x7a, 
-    0x07, 0x01, 0x73, 0x7a, 0x07, 0x01, 0x83, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x93, 0x7a, 0x07, 0x01, 
-    0xa3, 0x22, 0xc2, 0x13, 0xc2, 0x1b, 0xc2, 0x23, 0xc2, 0x0b, 0x7e, 0x04, 0x15, 0xe3, 0x7a, 0x07, 
-    0x01, 0x75, 0x7a, 0x07, 0x01, 0x85, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x95, 0x7a, 0x07, 0x01, 0xa5, 
-    0x22, 0xc2, 0x14, 0xc2, 0x1c, 0xc2, 0x24, 0xc2, 0x0c, 0x7e, 0x04, 0x19, 0xe3, 0x7a, 0x07, 0x01, 
-    0x77, 0x7a, 0x07, 0x01, 0x87, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x97, 0x7a, 0x07, 0x01, 0xa7, 0x22, 
-    0xc2, 0x15, 0xc2, 0x1d, 0xc2, 0x25, 0xc2, 0x0d, 0x7e, 0x04, 0x1d, 0xe3, 0x7a, 0x07, 0x01, 0x79, 
-    0x7a, 0x07, 0x01, 0x89, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x99, 0x7a, 0x07, 0x01, 0xa9, 0x22, 0xc2, 
-    0x16, 0xc2, 0x1e, 0xc2, 0x26, 0xc2, 0x0e, 0x7e, 0x04, 0x21, 0xe3, 0x7a, 0x07, 0x01, 0x7b, 0x7a, 
-    0x07, 0x01, 0x8b, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x9b, 0x7a, 0x07, 0x01, 0xab, 0x22, 0xc2, 0x17, 
-    0xc2, 0x1f, 0xc2, 0x27, 0xc2, 0x0f, 0x7e, 0x04, 0x25, 0xe3, 0x7a, 0x07, 0x01, 0x7d, 0x7a, 0x07, 
-    0x01, 0x8d, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x9d, 0x7a, 0x07, 0x01, 0xad, 0x22, 0x7c, 0xb2, 0x23, 
-    0x0a, 0x2b, 0x49, 0x22, 0x42, 0xb8, 0x89, 0x24, 0x42, 0xc8, 0x42, 0xe9, 0x43, 0x0a, 0x43, 0x2b, 
-    0x43, 0x4c, 0x43, 0x6d, 0x43, 0x8e, 0x43, 0xaf, 0x30, 0x50, 0x07, 0x20, 0x68, 0x04, 0xc2, 0x28, 
-    0x80, 0x16, 0x30, 0x40, 0x07, 0x20, 0x60, 0x04, 0xc2, 0x28, 0x80, 0x0c, 0x30, 0x48, 0x07, 0x20, 
-    0x58, 0x04, 0xc2, 0x28, 0x80, 0x02, 0xd2, 0x28, 0x22, 0x30, 0x51, 0x07, 0x20, 0x69, 0x04, 0xc2, 
-    0x29, 0x80, 0x16, 0x30, 0x41, 0x07, 0x20, 0x61, 0x04, 0xc2, 0x29, 0x80, 0x0c, 0x30, 0x49, 0x07, 
-    0x20, 0x59, 0x04, 0xc2, 0x29, 0x80, 0x02, 0xd2, 0x29, 0x22, 0x30, 0x52, 0x07, 0x20, 0x6a, 0x04, 
-    0xc2, 0x2a, 0x80, 0x16, 0x30, 0x42, 0x07, 0x20, 0x62, 0x04, 0xc2, 0x2a, 0x80, 0x0c, 0x30, 0x4a, 
-    0x07, 0x20, 0x5a, 0x04, 0xc2, 0x2a, 0x80, 0x02, 0xd2, 0x2a, 0x22, 0x30, 0x53, 0x07, 0x20, 0x6b, 
-    0x04, 0xc2, 0x2b, 0x80, 0x16, 0x30, 0x43, 0x07, 0x20, 0x63, 0x04, 0xc2, 0x2b, 0x80, 0x0c, 0x30, 
-    0x4b, 0x07, 0x20, 0x5b, 0x04, 0xc2, 0x2b, 0x80, 0x02, 0xd2, 0x2b, 0x22, 0x30, 0x54, 0x07, 0x20, 
-    0x6c, 0x04, 0xc2, 0x2c, 0x80, 0x16, 0x30, 0x44, 0x07, 0x20, 0x64, 0x04, 0xc2, 0x2c, 0x80, 0x0c, 
-    0x30, 0x4c, 0x07, 0x20, 0x5c, 0x04, 0xc2, 0x2c, 0x80, 0x02, 0xd2, 0x2c, 0x22, 0x30, 0x55, 0x07, 
-    0x20, 0x6d, 0x04, 0xc2, 0x2d, 0x80, 0x16, 0x30, 0x45, 0x07, 0x20, 0x65, 0x04, 0xc2, 0x2d, 0x80, 
-    0x0c, 0x30, 0x4d, 0x07, 0x20, 0x5d, 0x04, 0xc2, 0x2d, 0x80, 0x02, 0xd2, 0x2d, 0x22, 0x30, 0x56, 
-    0x07, 0x20, 0x6e, 0x04, 0xc2, 0x2e, 0x80, 0x16, 0x30, 0x46, 0x07, 0x20, 0x66, 0x04, 0xc2, 0x2e, 
-    0x80, 0x0c, 0x30, 0x4e, 0x07, 0x20, 0x5e, 0x04, 0xc2, 0x2e, 0x80, 0x02, 0xd2, 0x2e, 0x22, 0x30, 
-    0x57, 0x07, 0x20, 0x6f, 0x04, 0xc2, 0x2f, 0x80, 0x16, 0x30, 0x47, 0x07, 0x20, 0x67, 0x04, 0xc2, 
-    0x2f, 0x80, 0x0c, 0x30, 0x4f, 0x07, 0x20, 0x5f, 0x04, 0xc2, 0x2f, 0x80, 0x02, 0xd2, 0x2f, 0x22, 
-    0x44, 0x38, 0x43, 0xe5, 0xbe, 0xb0, 0x02, 0x40, 0x01, 0x22, 0x23, 0x0a, 0x5b, 0x49, 0x55, 0x43, 
-    0xd0, 0x99, 0x54, 0xd3, 0x22, 0xa9, 0xc5, 0x87, 0x12, 0x44, 0x43, 0x7e, 0x04, 0x05, 0xe3, 0x7a, 
-    0x07, 0x01, 0xd7, 0x7a, 0x07, 0x01, 0xd9, 0x7e, 0x04, 0x01, 0xe3, 0x7a, 0x07, 0x01, 0xdd, 0x7a, 
-    0x07, 0x01, 0xdf, 0x7e, 0x04, 0x74, 0xad, 0x7a, 0x05, 0x61, 0x75, 0xf1, 0x01, 0x75, 0xe1, 0x1f, 
-    0x75, 0xe4, 0x04, 0x75, 0xf4, 0x04, 0x75, 0xf1, 0x02, 0x75, 0xe1, 0x03, 0x75, 0xe4, 0x04, 0x75, 
-    0xf4, 0x04, 0x43, 0xa2, 0x1c, 0x12, 0x40, 0xeb, 0x7e, 0x20, 0x00, 0x12, 0x41, 0x9a, 0x0b, 0x20, 
-    0xbe, 0x21, 0x2f, 0x78, 0xf6, 0xd2, 0xa8, 0x22, 0xa9, 0xd5, 0x87, 0x12, 0x44, 0x43, 0xd2, 0x92, 
-    0xc2, 0xa8, 0x22, 0x75, 0xa3, 0x00, 0x53, 0xa2, 0x03, 0x75, 0xc1, 0x00, 0x53, 0xc0, 0x03, 0x7e, 
-    0x00, 0x05, 0x7a, 0x01, 0xf1, 0x43, 0xf4, 0x80, 0x43, 0xe4, 0x80, 0xe5, 0xf2, 0x54, 0x7f, 0x44, 
-    0x08, 0xf5, 0xf2, 0xe5, 0xe2, 0x54, 0x7f, 0x44, 0x08, 0xf5, 0xe2, 0x75, 0xe1, 0x10, 0xa5, 0xd8, 
-    0xe1, 0x22, 0xca, 0x09, 0x12, 0x30, 0x20, 0x10, 0x01, 0x12, 0xd5, 0x67, 0x1e, 0x63, 0x69, 0x01, 
-    0x7e, 0x00, 0x6a, 0x2e, 0x01, 0x69, 0xa5, 0xe6, 0xf5, 0x67, 0x80, 0x12, 0x20, 0x02, 0x1e, 0x75, 
-    0x69, 0x00, 0x85, 0x6a, 0x67, 0xd2, 0x02, 0x74, 0x00, 0x80, 0x0d, 0x30, 0x02, 0x0f, 0xc2, 0x02, 
-    0x7e, 0x00, 0x6c, 0x2e, 0x01, 0x69, 0xa5, 0xe6, 0x53, 0x90, 0xcf, 0x42, 0x90, 0xda, 0x09, 0x32, 
-    0xc0, 0xd0, 0xc0, 0xd1, 0xc0, 0xe0, 0xc0, 0xf0, 0xca, 0x0b, 0xca, 0x1b, 0xca, 0x2b, 0xd2, 0x01, 
-    0x75, 0x31, 0x89, 0x12, 0x7c, 0x15, 0x7e, 0x14, 0x80, 0x00, 0x09, 0xb1, 0x00, 0x08, 0x20, 0xe0, 
-    0x03, 0x02, 0x45, 0x4f, 0x20, 0x78, 0x5a, 0xa5, 0x0a, 0x09, 0xb1, 0x00, 0x08, 0x20, 0xe0, 0x03, 
-    0x02, 0x45, 0x67, 0x20, 0x79, 0x4b, 0xa5, 0x0a, 0x09, 0xb1, 0x00, 0x08, 0x20, 0xe0, 0x03, 0x02, 
-    0x45, 0x7f, 0xa5, 0x0a, 0x09, 0xb1, 0x00, 0x08, 0x20, 0xe0, 0x03, 0x02, 0x45, 0x97, 0x20, 0x7a, 
-    0x30, 0xa5, 0x0a, 0x09, 0xb1, 0x00, 0x08, 0x20, 0xe0, 0x03, 0x02, 0x45, 0xaf, 0xa5, 0x0a, 0x09, 
-    0xb1, 0x00, 0x08, 0x20, 0xe0, 0x03, 0x02, 0x45, 0xc7, 0xa5, 0x0a, 0x09, 0xb1, 0x00, 0x08, 0x20, 
-    0xe0, 0x03, 0x02, 0x45, 0xdf, 0xa5, 0x0a, 0x09, 0xb1, 0x00, 0x08, 0x20, 0xe0, 0x03, 0x02, 0x45, 
-    0xf7, 0x30, 0x04, 0x0c, 0xc2, 0x04, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 
-    0xda, 0x2b, 0xda, 0x1b, 0xda, 0x0b, 0xd0, 0xf0, 0xd0, 0xe0, 0xd0, 0xd1, 0xd0, 0xd0, 0x32, 0x75, 
-    0x31, 0x80, 0x12, 0x7c, 0x15, 0x54, 0x3e, 0x0a, 0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 0x63, 
-    0x2b, 0xca, 0x06, 0xc6, 0x44, 0x89, 0x54, 0x75, 0x31, 0x81, 0x12, 0x7c, 0x15, 0x54, 0x3e, 0x0a, 
-    0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 0x63, 0x6b, 0xca, 0x06, 0xc6, 0x44, 0x89, 0x54, 0x75, 
-    0x31, 0x82, 0x12, 0x7c, 0x15, 0x54, 0x3e, 0x0a, 0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 0x63, 
-    0xab, 0xca, 0x06, 0xc6, 0x44, 0x89, 0x54, 0x75, 0x31, 0x83, 0x12, 0x7c, 0x15, 0x54, 0x3e, 0x0a, 
-    0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 0x63, 0xeb, 0xca, 0x06, 0xc6, 0x44, 0x89, 0x54, 0x75, 
-    0x31, 0x84, 0x12, 0x7c, 0x15, 0x54, 0x3e, 0x0a, 0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 0x64, 
-    0x2b, 0xca, 0x06, 0xc6, 0x44, 0x89, 0x54, 0x75, 0x31, 0x85, 0x12, 0x7c, 0x15, 0x54, 0x3e, 0x0a, 
-    0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 0x64, 0x6b, 0xca, 0x06, 0xc6, 0x44, 0x89, 0x54, 0x75, 
-    0x31, 0x86, 0x12, 0x7c, 0x15, 0x54, 0x3e, 0x0a, 0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 0x64, 
-    0xab, 0xca, 0x06, 0xc6, 0x44, 0x89, 0x54, 0x75, 0x31, 0x87, 0x12, 0x7c, 0x15, 0x54, 0x3e, 0x0a, 
-    0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 0x64, 0xeb, 0xca, 0x06, 0xc6, 0x44, 0x89, 0x54, 0x10, 
-    0x08, 0x01, 0x22, 0x20, 0x28, 0x03, 0xd2, 0x08, 0x22, 0x75, 0x31, 0xa0, 0x12, 0x7c, 0x15, 0x7e, 
-    0x14, 0x80, 0x00, 0x80, 0x06, 0x20, 0x28, 0x03, 0xd2, 0x08, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 
-    0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x03, 0x12, 0x49, 0x30, 0x20, 0xe6, 0x03, 0xd2, 0x08, 
-    0x22, 0x30, 0x30, 0x49, 0xd2, 0x70, 0x7e, 0x37, 0x01, 0x8f, 0x7e, 0x27, 0x01, 0xaf, 0x9d, 0x32, 
-    0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 0x48, 0x7a, 0x05, 0x48, 0x7a, 0x37, 0x01, 0x8f, 0x7e, 0x37, 
-    0x01, 0x6f, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x0d, 0xe2, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x6f, 
-    0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x12, 0x65, 0x2b, 0x10, 
-    0x70, 0xc4, 0x22, 0xc2, 0x70, 0x2d, 0x23, 0x68, 0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 
-    0x8f, 0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 0x27, 0x01, 0xaf, 0x28, 0x04, 0x7e, 0x27, 0x01, 
-    0xaf, 0x7e, 0x37, 0x01, 0x8f, 0x9d, 0x32, 0x7d, 0x02, 0x2e, 0x05, 0x48, 0x7a, 0x05, 0x48, 0x7a, 
-    0x37, 0x01, 0x8f, 0x7e, 0x37, 0x01, 0x6f, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x0d, 0xe2, 0x38, 
-    0x13, 0x7a, 0x47, 0x01, 0x6f, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 
-    0x15, 0x02, 0x65, 0x2b, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 
-    0x9e, 0x44, 0x0d, 0xe3, 0x9d, 0x24, 0x12, 0x65, 0x2b, 0x7e, 0x34, 0x09, 0xe3, 0x7d, 0x24, 0x2d, 
-    0x43, 0x7a, 0x47, 0x01, 0x6f, 0x12, 0x65, 0x2b, 0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x46, 0x7f, 
-    0x22, 0xd2, 0x08, 0x7e, 0x04, 0x09, 0xe3, 0x7a, 0x07, 0x01, 0x6f, 0x7a, 0x07, 0x01, 0x7f, 0x75, 
-    0x31, 0x94, 0x12, 0x7c, 0x15, 0x75, 0x31, 0x00, 0x12, 0x7c, 0x15, 0x22, 0x75, 0x31, 0x92, 0x12, 
-    0x7c, 0x15, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 
-    0x7e, 0x37, 0x01, 0xe1, 0x7e, 0x27, 0x01, 0xbf, 0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 
-    0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 0x46, 0x7a, 0x05, 0x46, 0x7a, 0x37, 0x01, 0xe1, 
-    0x7e, 0x37, 0x01, 0xdf, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x05, 0xe2, 0x38, 0x44, 0x7a, 0x47, 
-    0x01, 0xdf, 0x7e, 0x24, 0x00, 0x00, 0x2e, 0x27, 0x01, 0xbf, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 
-    0x51, 0x31, 0x12, 0x7c, 0x15, 0xbe, 0x50, 0x38, 0x78, 0x03, 0x02, 0x66, 0x16, 0x02, 0x65, 0xfb, 
-    0x75, 0x31, 0x99, 0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 
-    0x30, 0x38, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x10, 0x22, 
-    0x80, 0x7d, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x9e, 0x44, 0x05, 0xe3, 0x9d, 0x24, 0x7e, 0x64, 
-    0x00, 0x00, 0x2e, 0x67, 0x01, 0xbf, 0x9e, 0x24, 0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 
-    0x35, 0x12, 0x65, 0xfb, 0x7e, 0x34, 0x01, 0xe3, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xdf, 
-    0x02, 0x65, 0xfb, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 0x01, 0xe3, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 
-    0x44, 0x80, 0xe5, 0x9d, 0x32, 0x7c, 0xb6, 0x54, 0x0f, 0x23, 0x23, 0x23, 0x44, 0x00, 0x7a, 0x69, 
-    0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x31, 0x93, 0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 
-    0x7c, 0x15, 0xbd, 0x04, 0x68, 0x29, 0x7a, 0x07, 0x01, 0xdf, 0x7e, 0x47, 0x01, 0xe1, 0x2d, 0x43, 
-    0x7a, 0x47, 0x01, 0xe1, 0x2e, 0x35, 0x46, 0x7a, 0x35, 0x46, 0x22, 0x09, 0xb1, 0x00, 0x14, 0x20, 
-    0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0x2a, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0x2c, 0x7e, 
-    0x04, 0x01, 0xe3, 0x80, 0xd1, 0xd2, 0x04, 0x7e, 0x07, 0x01, 0xe1, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 
-    0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 0xdf, 0x7e, 0x44, 0x05, 0xe3, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 
-    0x04, 0x68, 0xd0, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xce, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 
-    0x25, 0x40, 0x02, 0x7d, 0x25, 0x7d, 0x32, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 
-    0x01, 0x31, 0xda, 0xb8, 0x7e, 0x19, 0xb0, 0x7a, 0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 
-    0x02, 0x47, 0xe3, 0x75, 0x31, 0x99, 0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 
-    0xb1, 0x00, 0x04, 0x30, 0x38, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 
-    0xd2, 0x10, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x47, 
-    0xe3, 0xda, 0xb8, 0x02, 0x49, 0x30, 0x09, 0xb1, 0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x31, 0x90, 
-    0x12, 0x7c, 0x15, 0xf5, 0x31, 0x12, 0x7c, 0x15, 0xa5, 0xfc, 0x5e, 0xb0, 0xf0, 0xa5, 0xfd, 0x09, 
-    0xb1, 0x00, 0x18, 0x4c, 0x4b, 0x5e, 0xb0, 0xf0, 0xbc, 0xb5, 0x78, 0xf1, 0x5e, 0x40, 0x0f, 0x4c, 
-    0x54, 0x7c, 0xb5, 0x5e, 0x50, 0x0b, 0x68, 0x2a, 0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 
-    0x68, 0x80, 0x02, 0xc2, 0x68, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x60, 0x80, 0x02, 
-    0xc2, 0x60, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x58, 0x80, 0x02, 0xc2, 0x58, 0x12, 
-    0x42, 0xc8, 0x02, 0x62, 0x93, 0x75, 0x31, 0x91, 0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x14, 0x7a, 
-    0xb1, 0x31, 0x12, 0x7c, 0x15, 0x20, 0xe0, 0x08, 0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x62, 0x93, 
-    0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 0x12, 0x62, 0x93, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 
-    0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 0x61, 0x00, 0x00, 0x12, 0x62, 0xb6, 0x09, 0xb1, 
-    0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x48, 0x35, 0x75, 0x31, 0x95, 0x12, 0x7c, 0x15, 0x22, 
-    0x75, 0x31, 0x96, 0x12, 0x7c, 0x15, 0x22, 0x10, 0x09, 0x01, 0x22, 0x20, 0x29, 0x03, 0xd2, 0x09, 
-    0x22, 0x75, 0x31, 0xa1, 0x12, 0x7c, 0x15, 0x7e, 0x14, 0x81, 0x00, 0x80, 0x06, 0x20, 0x29, 0x03, 
-    0xd2, 0x09, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x03, 
-    0x12, 0x4c, 0x88, 0x20, 0xe6, 0x03, 0xd2, 0x09, 0x22, 0x30, 0x31, 0x49, 0xd2, 0x71, 0x7e, 0x37, 
-    0x01, 0x91, 0x7e, 0x27, 0x01, 0xb1, 0x9d, 0x32, 0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 0x4a, 0x7a, 
-    0x05, 0x4a, 0x7a, 0x37, 0x01, 0x91, 0x7e, 0x37, 0x01, 0x71, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 
-    0x11, 0xe2, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x71, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 
-    0x31, 0x12, 0x7c, 0x15, 0x12, 0x65, 0x2b, 0x10, 0x71, 0xc4, 0x22, 0xc2, 0x71, 0x2d, 0x23, 0x68, 
-    0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 0x91, 0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 
-    0x27, 0x01, 0xb1, 0x28, 0x04, 0x7e, 0x27, 0x01, 0xb1, 0x7e, 0x37, 0x01, 0x91, 0x9d, 0x32, 0x7d, 
-    0x02, 0x2e, 0x05, 0x4a, 0x7a, 0x05, 0x4a, 0x7a, 0x37, 0x01, 0x91, 0x7e, 0x37, 0x01, 0x71, 0x7d, 
-    0x43, 0x2d, 0x42, 0xbe, 0x44, 0x11, 0xe2, 0x38, 0x13, 0x7a, 0x47, 0x01, 0x71, 0x75, 0x31, 0x94, 
-    0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x02, 0x65, 0x2b, 0x75, 0x31, 0x94, 0x12, 
-    0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x9e, 0x44, 0x11, 0xe3, 0x9d, 0x24, 0x12, 0x65, 
-    0x2b, 0x7e, 0x34, 0x0d, 0xe3, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0x71, 0x12, 0x65, 0x2b, 
-    0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x49, 0xd7, 0x22, 0xd2, 0x09, 0x7e, 0x04, 0x0d, 0xe3, 0x7a, 
-    0x07, 0x01, 0x71, 0x7a, 0x07, 0x01, 0x81, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x75, 0x31, 0x00, 
-    0x12, 0x7c, 0x15, 0x22, 0x75, 0x31, 0x92, 0x12, 0x7c, 0x15, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 
-    0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 0x7e, 0x37, 0x01, 0xe1, 0x7e, 0x27, 0x01, 0xc1, 
-    0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 
-    0x46, 0x7a, 0x05, 0x46, 0x7a, 0x37, 0x01, 0xe1, 0x7e, 0x37, 0x01, 0xdf, 0x7d, 0x43, 0x2d, 0x42, 
-    0xbe, 0x44, 0x05, 0xe2, 0x38, 0x44, 0x7a, 0x47, 0x01, 0xdf, 0x7e, 0x24, 0x01, 0x00, 0x2e, 0x27, 
-    0x01, 0xc1, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0xbe, 0x50, 0x38, 
-    0x78, 0x03, 0x02, 0x66, 0x16, 0x02, 0x65, 0xfb, 0x75, 0x31, 0x99, 0x12, 0x7c, 0x15, 0x09, 0xb1, 
-    0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x39, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 
-    0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x11, 0x22, 0x80, 0x7d, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 
-    0x9e, 0x44, 0x05, 0xe3, 0x9d, 0x24, 0x7e, 0x64, 0x01, 0x00, 0x2e, 0x67, 0x01, 0xc1, 0x9e, 0x24, 
-    0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 0x35, 0x12, 0x65, 0xfb, 0x7e, 0x34, 0x01, 0xe3, 
-    0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xdf, 0x02, 0x65, 0xfb, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 
-    0x01, 0xe3, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 0x44, 0x80, 0xe5, 0x9d, 0x32, 0x7c, 0xb6, 0x54, 
-    0x0f, 0x23, 0x23, 0x23, 0x44, 0x01, 0x7a, 0x69, 0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x31, 
-    0x93, 0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 0x7c, 0x15, 0xbd, 0x04, 0x68, 0x29, 0x7a, 0x07, 
-    0x01, 0xdf, 0x7e, 0x47, 0x01, 0xe1, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xe1, 0x2e, 0x35, 0x46, 0x7a, 
-    0x35, 0x46, 0x22, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xe3, 0x80, 
-    0x2a, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0x2c, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0xd1, 0xd2, 0x04, 0x7e, 
-    0x07, 0x01, 0xe1, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 0xdf, 0x7e, 
-    0x44, 0x05, 0xe3, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd0, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 
-    0x04, 0x68, 0xce, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 0x25, 0x40, 0x02, 0x7d, 0x25, 0x7d, 0x32, 0x09, 
-    0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 0x01, 0x31, 0xda, 0xb8, 0x7e, 0x19, 0xb0, 0x7a, 
-    0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 0x02, 0x4b, 0x3b, 0x75, 0x31, 0x99, 0x12, 0x7c, 
-    0x15, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x39, 0x0a, 0x09, 0xb1, 
-    0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x11, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 
-    0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x4b, 0x3b, 0xda, 0xb8, 0x02, 0x4c, 0x88, 0x09, 0xb1, 
-    0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x31, 0x90, 0x12, 0x7c, 0x15, 0xf5, 0x31, 0x12, 0x7c, 0x15, 
-    0xa5, 0xfc, 0x5e, 0xb0, 0xf0, 0xa5, 0xfd, 0x09, 0xb1, 0x00, 0x18, 0x4c, 0x4b, 0x5e, 0xb0, 0xf0, 
-    0xbc, 0xb5, 0x78, 0xf1, 0x5e, 0x40, 0x0f, 0x4c, 0x54, 0x7c, 0xb5, 0x5e, 0x50, 0x0b, 0x68, 0x2a, 
-    0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 0x69, 0x80, 0x02, 0xc2, 0x69, 0xa5, 0xfd, 0x5e, 
-    0x50, 0x20, 0x68, 0x04, 0xd2, 0x61, 0x80, 0x02, 0xc2, 0x61, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 
-    0x04, 0xd2, 0x59, 0x80, 0x02, 0xc2, 0x59, 0x12, 0x42, 0xe9, 0x02, 0x62, 0x93, 0x75, 0x31, 0x91, 
-    0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x14, 0x7a, 0xb1, 0x31, 0x12, 0x7c, 0x15, 0x20, 0xe0, 0x08, 
-    0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x62, 0x93, 0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 
-    0x12, 0x62, 0x93, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 
-    0x61, 0x00, 0x00, 0x12, 0x62, 0xb6, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x4b, 
-    0x8d, 0x75, 0x31, 0x95, 0x12, 0x7c, 0x15, 0x22, 0x75, 0x31, 0x96, 0x12, 0x7c, 0x15, 0x22, 0x10, 
-    0x0a, 0x01, 0x22, 0x20, 0x2a, 0x03, 0xd2, 0x0a, 0x22, 0x75, 0x31, 0xa2, 0x12, 0x7c, 0x15, 0x7e, 
-    0x14, 0x82, 0x00, 0x80, 0x06, 0x20, 0x2a, 0x03, 0xd2, 0x0a, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 
-    0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x03, 0x12, 0x4f, 0xe0, 0x20, 0xe6, 0x03, 0xd2, 0x0a, 
-    0x22, 0x30, 0x32, 0x49, 0xd2, 0x72, 0x7e, 0x37, 0x01, 0x93, 0x7e, 0x27, 0x01, 0xb3, 0x9d, 0x32, 
-    0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 0x4c, 0x7a, 0x05, 0x4c, 0x7a, 0x37, 0x01, 0x93, 0x7e, 0x37, 
-    0x01, 0x73, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x15, 0xe2, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x73, 
-    0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x12, 0x65, 0x2b, 0x10, 
-    0x72, 0xc4, 0x22, 0xc2, 0x72, 0x2d, 0x23, 0x68, 0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 
-    0x93, 0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 0x27, 0x01, 0xb3, 0x28, 0x04, 0x7e, 0x27, 0x01, 
-    0xb3, 0x7e, 0x37, 0x01, 0x93, 0x9d, 0x32, 0x7d, 0x02, 0x2e, 0x05, 0x4c, 0x7a, 0x05, 0x4c, 0x7a, 
-    0x37, 0x01, 0x93, 0x7e, 0x37, 0x01, 0x73, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x15, 0xe2, 0x38, 
-    0x13, 0x7a, 0x47, 0x01, 0x73, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 
-    0x15, 0x02, 0x65, 0x2b, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 
-    0x9e, 0x44, 0x15, 0xe3, 0x9d, 0x24, 0x12, 0x65, 0x2b, 0x7e, 0x34, 0x11, 0xe3, 0x7d, 0x24, 0x2d, 
-    0x43, 0x7a, 0x47, 0x01, 0x73, 0x12, 0x65, 0x2b, 0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x4d, 0x2f, 
-    0x22, 0xd2, 0x0a, 0x7e, 0x04, 0x11, 0xe3, 0x7a, 0x07, 0x01, 0x73, 0x7a, 0x07, 0x01, 0x83, 0x75, 
-    0x31, 0x94, 0x12, 0x7c, 0x15, 0x75, 0x31, 0x00, 0x12, 0x7c, 0x15, 0x22, 0x75, 0x31, 0x92, 0x12, 
-    0x7c, 0x15, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 
-    0x7e, 0x37, 0x01, 0xe1, 0x7e, 0x27, 0x01, 0xc3, 0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 
-    0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 0x46, 0x7a, 0x05, 0x46, 0x7a, 0x37, 0x01, 0xe1, 
-    0x7e, 0x37, 0x01, 0xdf, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x05, 0xe2, 0x38, 0x44, 0x7a, 0x47, 
-    0x01, 0xdf, 0x7e, 0x24, 0x02, 0x00, 0x2e, 0x27, 0x01, 0xc3, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 
-    0x51, 0x31, 0x12, 0x7c, 0x15, 0xbe, 0x50, 0x38, 0x78, 0x03, 0x02, 0x66, 0x16, 0x02, 0x65, 0xfb, 
-    0x75, 0x31, 0x99, 0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 
-    0x30, 0x3a, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x12, 0x22, 
-    0x80, 0x7d, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x9e, 0x44, 0x05, 0xe3, 0x9d, 0x24, 0x7e, 0x64, 
-    0x02, 0x00, 0x2e, 0x67, 0x01, 0xc3, 0x9e, 0x24, 0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 
-    0x35, 0x12, 0x65, 0xfb, 0x7e, 0x34, 0x01, 0xe3, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xdf, 
-    0x02, 0x65, 0xfb, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 0x01, 0xe3, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 
-    0x44, 0x80, 0xe5, 0x9d, 0x32, 0x7c, 0xb6, 0x54, 0x0f, 0x23, 0x23, 0x23, 0x44, 0x02, 0x7a, 0x69, 
-    0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x31, 0x93, 0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 
-    0x7c, 0x15, 0xbd, 0x04, 0x68, 0x29, 0x7a, 0x07, 0x01, 0xdf, 0x7e, 0x47, 0x01, 0xe1, 0x2d, 0x43, 
-    0x7a, 0x47, 0x01, 0xe1, 0x2e, 0x35, 0x46, 0x7a, 0x35, 0x46, 0x22, 0x09, 0xb1, 0x00, 0x14, 0x20, 
-    0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0x2a, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0x2c, 0x7e, 
-    0x04, 0x01, 0xe3, 0x80, 0xd1, 0xd2, 0x04, 0x7e, 0x07, 0x01, 0xe1, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 
-    0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 0xdf, 0x7e, 0x44, 0x05, 0xe3, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 
-    0x04, 0x68, 0xd0, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xce, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 
-    0x25, 0x40, 0x02, 0x7d, 0x25, 0x7d, 0x32, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 
-    0x01, 0x31, 0xda, 0xb8, 0x7e, 0x19, 0xb0, 0x7a, 0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 
-    0x02, 0x4e, 0x93, 0x75, 0x31, 0x99, 0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 
-    0xb1, 0x00, 0x04, 0x30, 0x3a, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 
-    0xd2, 0x12, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x4e, 
-    0x93, 0xda, 0xb8, 0x02, 0x4f, 0xe0, 0x09, 0xb1, 0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x31, 0x90, 
-    0x12, 0x7c, 0x15, 0xf5, 0x31, 0x12, 0x7c, 0x15, 0xa5, 0xfc, 0x5e, 0xb0, 0xf0, 0xa5, 0xfd, 0x09, 
-    0xb1, 0x00, 0x18, 0x4c, 0x4b, 0x5e, 0xb0, 0xf0, 0xbc, 0xb5, 0x78, 0xf1, 0x5e, 0x40, 0x0f, 0x4c, 
-    0x54, 0x7c, 0xb5, 0x5e, 0x50, 0x0b, 0x68, 0x2a, 0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 
-    0x6a, 0x80, 0x02, 0xc2, 0x6a, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x62, 0x80, 0x02, 
-    0xc2, 0x62, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x5a, 0x80, 0x02, 0xc2, 0x5a, 0x12, 
-    0x43, 0x0a, 0x02, 0x62, 0x93, 0x75, 0x31, 0x91, 0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x14, 0x7a, 
-    0xb1, 0x31, 0x12, 0x7c, 0x15, 0x20, 0xe0, 0x08, 0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x62, 0x93, 
-    0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 0x12, 0x62, 0x93, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 
-    0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 0x61, 0x00, 0x00, 0x12, 0x62, 0xb6, 0x09, 0xb1, 
-    0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x4e, 0xe5, 0x75, 0x31, 0x95, 0x12, 0x7c, 0x15, 0x22, 
-    0x75, 0x31, 0x96, 0x12, 0x7c, 0x15, 0x22, 0x10, 0x0b, 0x01, 0x22, 0x20, 0x2b, 0x03, 0xd2, 0x0b, 
-    0x22, 0x75, 0x31, 0xa3, 0x12, 0x7c, 0x15, 0x7e, 0x14, 0x83, 0x00, 0x80, 0x06, 0x20, 0x2b, 0x03, 
+    0x74, 0x07, 0x20, 0x68, 0x02, 0x74, 0x0f, 0x19, 0xb0, 0x00, 0x04, 0x30, 0x6b, 0x17, 0x74, 0xbf, 
+    0x19, 0xb0, 0x00, 0x0c, 0x74, 0x28, 0x20, 0x68, 0x02, 0x74, 0x20, 0x19, 0xb0, 0x00, 0x04, 0x74, 
+    0x03, 0x19, 0xb0, 0x00, 0x0c, 0x74, 0xa7, 0x19, 0xb0, 0x00, 0x08, 0x74, 0x0c, 0x19, 0xb0, 0x00, 
+    0x10, 0x22, 0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 0xe4, 0x19, 0xb0, 0x00, 0x04, 0x09, 0xb0, 0x00, 
+    0x10, 0x54, 0x08, 0x19, 0xb0, 0x00, 0x10, 0x74, 0xa7, 0x19, 0xb0, 0x00, 0x08, 0x22, 0x7c, 0xb2, 
+    0x23, 0x0a, 0x2b, 0x49, 0x22, 0x41, 0x99, 0x89, 0x24, 0x41, 0xa9, 0x41, 0xc6, 0x41, 0xe3, 0x42, 
+    0x00, 0x42, 0x1d, 0x42, 0x3a, 0x42, 0x57, 0x42, 0x74, 0xc2, 0x10, 0xc2, 0x18, 0xc2, 0x08, 0x7e, 
+    0x04, 0x09, 0xcd, 0x7a, 0x07, 0x01, 0x59, 0x7a, 0x07, 0x01, 0x69, 0x6d, 0x00, 0x7a, 0x07, 0x01, 
+    0x79, 0x7a, 0x07, 0x01, 0x89, 0x22, 0xc2, 0x11, 0xc2, 0x19, 0xc2, 0x09, 0x7e, 0x04, 0x0d, 0xcd, 
+    0x7a, 0x07, 0x01, 0x5b, 0x7a, 0x07, 0x01, 0x6b, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x7b, 0x7a, 0x07, 
+    0x01, 0x8b, 0x22, 0xc2, 0x12, 0xc2, 0x1a, 0xc2, 0x0a, 0x7e, 0x04, 0x11, 0xcd, 0x7a, 0x07, 0x01, 
+    0x5d, 0x7a, 0x07, 0x01, 0x6d, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x7d, 0x7a, 0x07, 0x01, 0x8d, 0x22, 
+    0xc2, 0x13, 0xc2, 0x1b, 0xc2, 0x0b, 0x7e, 0x04, 0x15, 0xcd, 0x7a, 0x07, 0x01, 0x5f, 0x7a, 0x07, 
+    0x01, 0x6f, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x7f, 0x7a, 0x07, 0x01, 0x8f, 0x22, 0xc2, 0x14, 0xc2, 
+    0x1c, 0xc2, 0x0c, 0x7e, 0x04, 0x19, 0xcd, 0x7a, 0x07, 0x01, 0x61, 0x7a, 0x07, 0x01, 0x71, 0x6d, 
+    0x00, 0x7a, 0x07, 0x01, 0x81, 0x7a, 0x07, 0x01, 0x91, 0x22, 0xc2, 0x15, 0xc2, 0x1d, 0xc2, 0x0d, 
+    0x7e, 0x04, 0x1d, 0xcd, 0x7a, 0x07, 0x01, 0x63, 0x7a, 0x07, 0x01, 0x73, 0x6d, 0x00, 0x7a, 0x07, 
+    0x01, 0x83, 0x7a, 0x07, 0x01, 0x93, 0x22, 0xc2, 0x16, 0xc2, 0x1e, 0xc2, 0x0e, 0x7e, 0x04, 0x21, 
+    0xcd, 0x7a, 0x07, 0x01, 0x65, 0x7a, 0x07, 0x01, 0x75, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x85, 0x7a, 
+    0x07, 0x01, 0x95, 0x22, 0xc2, 0x17, 0xc2, 0x1f, 0xc2, 0x0f, 0x7e, 0x04, 0x25, 0xcd, 0x7a, 0x07, 
+    0x01, 0x67, 0x7a, 0x07, 0x01, 0x77, 0x6d, 0x00, 0x7a, 0x07, 0x01, 0x87, 0x7a, 0x07, 0x01, 0x97, 
+    0x22, 0x7c, 0xb2, 0x23, 0x0a, 0x2b, 0x49, 0x22, 0x42, 0x9c, 0x89, 0x24, 0x42, 0xac, 0x42, 0xc3, 
+    0x42, 0xda, 0x42, 0xf1, 0x43, 0x08, 0x43, 0x1f, 0x43, 0x36, 0x43, 0x4d, 0x30, 0x40, 0x07, 0x20, 
+    0x58, 0x04, 0xc2, 0x28, 0x80, 0x0c, 0x30, 0x48, 0x07, 0x20, 0x50, 0x04, 0xc2, 0x28, 0x80, 0x02, 
+    0xd2, 0x28, 0x22, 0x30, 0x41, 0x07, 0x20, 0x59, 0x04, 0xc2, 0x29, 0x80, 0x0c, 0x30, 0x49, 0x07, 
+    0x20, 0x51, 0x04, 0xc2, 0x29, 0x80, 0x02, 0xd2, 0x29, 0x22, 0x30, 0x42, 0x07, 0x20, 0x5a, 0x04, 
+    0xc2, 0x2a, 0x80, 0x0c, 0x30, 0x4a, 0x07, 0x20, 0x52, 0x04, 0xc2, 0x2a, 0x80, 0x02, 0xd2, 0x2a, 
+    0x22, 0x30, 0x43, 0x07, 0x20, 0x5b, 0x04, 0xc2, 0x2b, 0x80, 0x0c, 0x30, 0x4b, 0x07, 0x20, 0x53, 
+    0x04, 0xc2, 0x2b, 0x80, 0x02, 0xd2, 0x2b, 0x22, 0x30, 0x44, 0x07, 0x20, 0x5c, 0x04, 0xc2, 0x2c, 
+    0x80, 0x0c, 0x30, 0x4c, 0x07, 0x20, 0x54, 0x04, 0xc2, 0x2c, 0x80, 0x02, 0xd2, 0x2c, 0x22, 0x30, 
+    0x45, 0x07, 0x20, 0x5d, 0x04, 0xc2, 0x2d, 0x80, 0x0c, 0x30, 0x4d, 0x07, 0x20, 0x55, 0x04, 0xc2, 
+    0x2d, 0x80, 0x02, 0xd2, 0x2d, 0x22, 0x30, 0x46, 0x07, 0x20, 0x5e, 0x04, 0xc2, 0x2e, 0x80, 0x0c, 
+    0x30, 0x4e, 0x07, 0x20, 0x56, 0x04, 0xc2, 0x2e, 0x80, 0x02, 0xd2, 0x2e, 0x22, 0x30, 0x47, 0x07, 
+    0x20, 0x5f, 0x04, 0xc2, 0x2f, 0x80, 0x0c, 0x30, 0x4f, 0x07, 0x20, 0x57, 0x04, 0xc2, 0x2f, 0x80, 
+    0x02, 0xd2, 0x2f, 0x22, 0x43, 0xcc, 0x43, 0x79, 0xbe, 0xb0, 0x02, 0x40, 0x01, 0x22, 0x23, 0x0a, 
+    0x5b, 0x49, 0x55, 0x43, 0x64, 0x99, 0x54, 0xd3, 0x22, 0xa9, 0xc5, 0x87, 0x12, 0x43, 0xd7, 0x7e, 
+    0x04, 0x05, 0xcd, 0x7a, 0x07, 0x01, 0xc1, 0x7a, 0x07, 0x01, 0xc3, 0x7e, 0x04, 0x01, 0xcd, 0x7a, 
+    0x07, 0x01, 0xc7, 0x7a, 0x07, 0x01, 0xc9, 0x7e, 0x04, 0x76, 0xbd, 0x7a, 0x05, 0x4b, 0x75, 0xf1, 
+    0x01, 0x75, 0xe1, 0x1f, 0x75, 0xe4, 0x04, 0x75, 0xf4, 0x04, 0x75, 0xf1, 0x02, 0x75, 0xe1, 0x03, 
+    0x75, 0xe4, 0x04, 0x75, 0xf4, 0x04, 0x43, 0xa2, 0x1c, 0x12, 0x40, 0xeb, 0x7e, 0x20, 0x00, 0x12, 
+    0x41, 0x8e, 0x0b, 0x20, 0xbe, 0x21, 0x2e, 0x78, 0xf6, 0xd2, 0xa8, 0x22, 0xa9, 0xd5, 0x87, 0x12, 
+    0x43, 0xd7, 0xd2, 0x92, 0xc2, 0xa8, 0x22, 0x75, 0xa3, 0x00, 0x53, 0xa2, 0x03, 0x75, 0xc1, 0x00, 
+    0x53, 0xc0, 0x03, 0x7e, 0x00, 0x05, 0x7a, 0x01, 0xf1, 0x43, 0xf4, 0x80, 0x43, 0xe4, 0x80, 0xe5, 
+    0xf2, 0x54, 0x7f, 0x44, 0x08, 0xf5, 0xf2, 0xe5, 0xe2, 0x54, 0x7f, 0x44, 0x08, 0xf5, 0xe2, 0x75, 
+    0xe1, 0x10, 0xa5, 0xd8, 0xe1, 0x22, 0x12, 0x44, 0x76, 0x12, 0x44, 0x8c, 0x12, 0x45, 0x27, 0x12, 
+    0x45, 0x57, 0x12, 0x49, 0x0f, 0x12, 0x44, 0xd8, 0x80, 0xec, 0xca, 0x09, 0x12, 0x44, 0x58, 0x10, 
+    0x01, 0x12, 0xd5, 0x51, 0x1e, 0x63, 0x53, 0x01, 0x7e, 0x00, 0x54, 0x2e, 0x01, 0x53, 0xa5, 0xe6, 
+    0xf5, 0x51, 0x80, 0x12, 0x20, 0x02, 0x1e, 0x75, 0x53, 0x00, 0x85, 0x54, 0x51, 0xd2, 0x02, 0x74, 
+    0x00, 0x80, 0x0d, 0x30, 0x02, 0x0f, 0xc2, 0x02, 0x7e, 0x00, 0x56, 0x2e, 0x01, 0x53, 0xa5, 0xe6, 
+    0x53, 0x90, 0xcf, 0x42, 0x90, 0xda, 0x09, 0x32, 0xe5, 0x23, 0x60, 0x19, 0x7e, 0x14, 0x00, 0x00, 
+    0x09, 0xb1, 0x01, 0xb9, 0xb4, 0x00, 0x02, 0x80, 0x05, 0x14, 0x19, 0xb1, 0x01, 0xb9, 0xa5, 0x0a, 
+    0xbe, 0x21, 0x2e, 0x78, 0xeb, 0x22, 0xc2, 0xaf, 0x7e, 0xb3, 0x3f, 0xf1, 0xb4, 0x01, 0x0a, 0xc0, 
+    0xf1, 0x75, 0xf1, 0x02, 0x12, 0x72, 0xff, 0xd0, 0xf1, 0xd2, 0xaf, 0x22, 0xc2, 0xaf, 0xe5, 0x22, 
+    0x60, 0x43, 0x7e, 0x07, 0x01, 0xcb, 0xbe, 0x04, 0x03, 0x80, 0x38, 0x39, 0x7e, 0x04, 0x80, 0x00, 
+    0x7e, 0x20, 0x00, 0x13, 0x50, 0x21, 0x09, 0xa0, 0x00, 0x04, 0x4e, 0xa0, 0x05, 0x19, 0xa0, 0x00, 
+    0x04, 0x0a, 0x32, 0x09, 0x53, 0x6a, 0x93, 0x5e, 0x51, 0x27, 0x68, 0x0b, 0x09, 0xa0, 0x00, 0x10, 
+    0x4e, 0xa0, 0x01, 0x19, 0xa0, 0x00, 0x10, 0x2e, 0x04, 0x01, 0x00, 0xa5, 0x0a, 0xbe, 0x21, 0x2e, 
+    0x78, 0xd1, 0x75, 0x22, 0x00, 0xd2, 0xaf, 0x22, 0xc2, 0xaf, 0xe5, 0x26, 0x60, 0x36, 0x7e, 0x20, 
+    0x00, 0x7e, 0x30, 0x01, 0xe5, 0x26, 0xa5, 0x5b, 0x68, 0x21, 0x7c, 0xb2, 0x23, 0x0a, 0x2b, 0x49, 
+    0x32, 0x01, 0x79, 0xbe, 0x34, 0x00, 0x00, 0x68, 0x12, 0x7e, 0xb1, 0x21, 0xa5, 0x4b, 0x7a, 0xb1, 
+    0x21, 0xca, 0x19, 0x49, 0x22, 0x45, 0x17, 0x99, 0x24, 0xda, 0x19, 0x3e, 0x30, 0xa5, 0x0a, 0xbe, 
+    0x21, 0x2e, 0x78, 0xd0, 0xd2, 0xaf, 0x22, 0x4a, 0x98, 0x4d, 0xcd, 0x51, 0x02, 0x54, 0x37, 0x57, 
+    0x6c, 0x5a, 0xa1, 0x5d, 0xd6, 0x61, 0x0b, 0xc2, 0xaf, 0xe5, 0x24, 0x60, 0x14, 0x7e, 0x20, 0x00, 
+    0x13, 0x50, 0x07, 0xca, 0xb8, 0x12, 0x45, 0x44, 0xda, 0xb8, 0xa5, 0x0a, 0xbe, 0x21, 0x2e, 0x78, 
+    0xef, 0xd2, 0xaf, 0x22, 0xca, 0x28, 0x12, 0x6a, 0xac, 0xda, 0x28, 0x40, 0x09, 0x0a, 0x22, 0x09, 
+    0xb2, 0x6a, 0x93, 0xf4, 0x52, 0x24, 0x22, 0xc2, 0xaf, 0xe5, 0x23, 0x60, 0x14, 0x7e, 0x20, 0x00, 
+    0x13, 0x50, 0x07, 0xca, 0xb8, 0x12, 0x45, 0x74, 0xda, 0xb8, 0xa5, 0x0a, 0xbe, 0x21, 0x2e, 0x78, 
+    0xef, 0xd2, 0xaf, 0x22, 0x7c, 0xb2, 0x23, 0x0a, 0x2b, 0x49, 0x22, 0x45, 0x7f, 0x89, 0x24, 0x45, 
+    0x8f, 0x45, 0xff, 0x46, 0x6f, 0x46, 0xdf, 0x47, 0x4f, 0x47, 0xbf, 0x48, 0x2f, 0x48, 0x9f, 0x7e, 
+    0x27, 0x01, 0x79, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x80, 0x00, 0x09, 0xb2, 0x00, 
+    0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x4d, 
+    0x96, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 0x01, 
+    0x89, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0x89, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xb9, 0x80, 0x2e, 
+    0x7e, 0x63, 0x01, 0xb9, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 0xa0, 
+    0xc8, 0x12, 0x65, 0xbf, 0x40, 0x18, 0x75, 0x2f, 0xb3, 0x12, 0x7e, 0x30, 0xc2, 0x18, 0x6c, 0x00, 
+    0x7a, 0x03, 0x01, 0xb9, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x71, 0xe9, 0xd0, 0xf1, 0x22, 0x7e, 
+    0x27, 0x01, 0x7b, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x81, 0x00, 0x09, 0xb2, 0x00, 
+    0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x50, 
+    0xcb, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 0x01, 
+    0x8b, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0x8b, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xba, 0x80, 0x2e, 
+    0x7e, 0x63, 0x01, 0xba, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 0xa0, 
+    0xc8, 0x12, 0x65, 0xbf, 0x40, 0x18, 0x75, 0x2f, 0xb3, 0x12, 0x7e, 0x30, 0xc2, 0x19, 0x6c, 0x00, 
+    0x7a, 0x03, 0x01, 0xba, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x71, 0xe9, 0xd0, 0xf1, 0x22, 0x7e, 
+    0x27, 0x01, 0x7d, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x82, 0x00, 0x09, 0xb2, 0x00, 
+    0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x54, 
+    0x00, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 0x01, 
+    0x8d, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0x8d, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xbb, 0x80, 0x2e, 
+    0x7e, 0x63, 0x01, 0xbb, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 0xa0, 
+    0xc8, 0x12, 0x65, 0xbf, 0x40, 0x18, 0x75, 0x2f, 0xb3, 0x12, 0x7e, 0x30, 0xc2, 0x1a, 0x6c, 0x00, 
+    0x7a, 0x03, 0x01, 0xbb, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x71, 0xe9, 0xd0, 0xf1, 0x22, 0x7e, 
+    0x27, 0x01, 0x7f, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x83, 0x00, 0x09, 0xb2, 0x00, 
+    0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x57, 
+    0x35, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 0x01, 
+    0x8f, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0x8f, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xbc, 0x80, 0x2e, 
+    0x7e, 0x63, 0x01, 0xbc, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 0xa0, 
+    0xc8, 0x12, 0x65, 0xbf, 0x40, 0x18, 0x75, 0x2f, 0xb3, 0x12, 0x7e, 0x30, 0xc2, 0x1b, 0x6c, 0x00, 
+    0x7a, 0x03, 0x01, 0xbc, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x71, 0xe9, 0xd0, 0xf1, 0x22, 0x7e, 
+    0x27, 0x01, 0x81, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x84, 0x00, 0x09, 0xb2, 0x00, 
+    0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x5a, 
+    0x6a, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 0x01, 
+    0x91, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0x91, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xbd, 0x80, 0x2e, 
+    0x7e, 0x63, 0x01, 0xbd, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 0xa0, 
+    0xc8, 0x12, 0x65, 0xbf, 0x40, 0x18, 0x75, 0x2f, 0xb3, 0x12, 0x7e, 0x30, 0xc2, 0x1c, 0x6c, 0x00, 
+    0x7a, 0x03, 0x01, 0xbd, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x71, 0xe9, 0xd0, 0xf1, 0x22, 0x7e, 
+    0x27, 0x01, 0x83, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x85, 0x00, 0x09, 0xb2, 0x00, 
+    0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x5d, 
+    0x9f, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 0x01, 
+    0x93, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0x93, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xbe, 0x80, 0x2e, 
+    0x7e, 0x63, 0x01, 0xbe, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 0xa0, 
+    0xc8, 0x12, 0x65, 0xbf, 0x40, 0x18, 0x75, 0x2f, 0xb3, 0x12, 0x7e, 0x30, 0xc2, 0x1d, 0x6c, 0x00, 
+    0x7a, 0x03, 0x01, 0xbe, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x71, 0xe9, 0xd0, 0xf1, 0x22, 0x7e, 
+    0x27, 0x01, 0x85, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x86, 0x00, 0x09, 0xb2, 0x00, 
+    0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x60, 
+    0xd4, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 0x01, 
+    0x95, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0x95, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xbf, 0x80, 0x2e, 
+    0x7e, 0x63, 0x01, 0xbf, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 0xa0, 
+    0xc8, 0x12, 0x65, 0xbf, 0x40, 0x18, 0x75, 0x2f, 0xb3, 0x12, 0x7e, 0x30, 0xc2, 0x1e, 0x6c, 0x00, 
+    0x7a, 0x03, 0x01, 0xbf, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x71, 0xe9, 0xd0, 0xf1, 0x22, 0x7e, 
+    0x27, 0x01, 0x87, 0xbe, 0x24, 0x00, 0x00, 0x78, 0x24, 0x7e, 0x24, 0x87, 0x00, 0x09, 0xb2, 0x00, 
+    0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x0b, 0xca, 0x19, 0x7d, 0x12, 0x12, 0x64, 
+    0x09, 0x7d, 0x21, 0xda, 0x19, 0x30, 0xe6, 0x18, 0x7e, 0x60, 0x00, 0x80, 0x1e, 0xbe, 0x27, 0x01, 
+    0x97, 0x68, 0x0d, 0x7a, 0x27, 0x01, 0x97, 0x7e, 0x60, 0x9c, 0x7a, 0x63, 0x01, 0xc0, 0x80, 0x2e, 
+    0x7e, 0x63, 0x01, 0xc0, 0xa5, 0xbe, 0x00, 0x26, 0x7e, 0x60, 0x01, 0x7e, 0xb0, 0x00, 0x7e, 0xa0, 
+    0xc8, 0x12, 0x65, 0xbf, 0x40, 0x18, 0x75, 0x2f, 0xb3, 0x12, 0x7e, 0x30, 0xc2, 0x1f, 0x6c, 0x00, 
+    0x7a, 0x03, 0x01, 0xc0, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x71, 0xe9, 0xd0, 0xf1, 0x22, 0xc2, 
+    0xaf, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0xa9, 0x32, 0xf2, 0x1a, 0x7e, 0x07, 0x01, 0xcb, 0xbe, 0x04, 
+    0x00, 0x00, 0x78, 0x10, 0xe5, 0xf5, 0x33, 0x82, 0xe7, 0x40, 0x09, 0x85, 0x31, 0x2f, 0x12, 0x7e, 
+    0x30, 0x75, 0xf6, 0x00, 0xd0, 0xf1, 0xd2, 0xaf, 0x22, 0xc0, 0xd0, 0xc0, 0xd1, 0xc0, 0xe0, 0xc0, 
+    0xf0, 0xca, 0x0b, 0xca, 0x1b, 0xca, 0x2b, 0xd2, 0x01, 0x75, 0x2f, 0x89, 0x12, 0x7e, 0x30, 0x7e, 
+    0x14, 0x80, 0x00, 0x09, 0xb1, 0x00, 0x08, 0x20, 0xe0, 0x03, 0x02, 0x49, 0xd8, 0x20, 0x70, 0x5a, 
+    0xa5, 0x0a, 0x09, 0xb1, 0x00, 0x08, 0x20, 0xe0, 0x03, 0x02, 0x49, 0xf0, 0x20, 0x71, 0x4b, 0xa5, 
+    0x0a, 0x09, 0xb1, 0x00, 0x08, 0x20, 0xe0, 0x03, 0x02, 0x4a, 0x08, 0xa5, 0x0a, 0x09, 0xb1, 0x00, 
+    0x08, 0x20, 0xe0, 0x03, 0x02, 0x4a, 0x20, 0x20, 0x72, 0x30, 0xa5, 0x0a, 0x09, 0xb1, 0x00, 0x08, 
+    0x20, 0xe0, 0x03, 0x02, 0x4a, 0x38, 0xa5, 0x0a, 0x09, 0xb1, 0x00, 0x08, 0x20, 0xe0, 0x03, 0x02, 
+    0x4a, 0x50, 0xa5, 0x0a, 0x09, 0xb1, 0x00, 0x08, 0x20, 0xe0, 0x03, 0x02, 0x4a, 0x68, 0xa5, 0x0a, 
+    0x09, 0xb1, 0x00, 0x08, 0x20, 0xe0, 0x03, 0x02, 0x4a, 0x80, 0x30, 0x04, 0x0c, 0xc2, 0x04, 0xc0, 
+    0xf1, 0x75, 0xf1, 0x01, 0x12, 0x71, 0xe9, 0xd0, 0xf1, 0xda, 0x2b, 0xda, 0x1b, 0xda, 0x0b, 0xd0, 
+    0xf0, 0xd0, 0xe0, 0xd0, 0xd1, 0xd0, 0xd0, 0x32, 0x75, 0x2f, 0x80, 0x12, 0x7e, 0x30, 0x54, 0x3e, 
+    0x0a, 0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 0x66, 0x34, 0xca, 0x06, 0x4f, 0x49, 0x89, 0x54, 
+    0x75, 0x2f, 0x81, 0x12, 0x7e, 0x30, 0x54, 0x3e, 0x0a, 0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 
+    0x66, 0x74, 0xca, 0x06, 0x4f, 0x49, 0x89, 0x54, 0x75, 0x2f, 0x82, 0x12, 0x7e, 0x30, 0x54, 0x3e, 
+    0x0a, 0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 0x66, 0xb4, 0xca, 0x06, 0x4f, 0x49, 0x89, 0x54, 
+    0x75, 0x2f, 0x83, 0x12, 0x7e, 0x30, 0x54, 0x3e, 0x0a, 0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 
+    0x66, 0xf4, 0xca, 0x06, 0x4f, 0x49, 0x89, 0x54, 0x75, 0x2f, 0x84, 0x12, 0x7e, 0x30, 0x54, 0x3e, 
+    0x0a, 0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 0x67, 0x34, 0xca, 0x06, 0x4f, 0x49, 0x89, 0x54, 
+    0x75, 0x2f, 0x85, 0x12, 0x7e, 0x30, 0x54, 0x3e, 0x0a, 0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 
+    0x67, 0x74, 0xca, 0x06, 0x4f, 0x49, 0x89, 0x54, 0x75, 0x2f, 0x86, 0x12, 0x7e, 0x30, 0x54, 0x3e, 
+    0x0a, 0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 0x67, 0xb4, 0xca, 0x06, 0x4f, 0x49, 0x89, 0x54, 
+    0x75, 0x2f, 0x87, 0x12, 0x7e, 0x30, 0x54, 0x3e, 0x0a, 0x5b, 0x7e, 0x44, 0x00, 0xff, 0x69, 0x52, 
+    0x67, 0xf4, 0xca, 0x06, 0x4f, 0x49, 0x89, 0x54, 0x10, 0x08, 0x01, 0x22, 0x20, 0x28, 0x03, 0xd2, 
+    0x08, 0x22, 0x75, 0x2f, 0xa0, 0x12, 0x7e, 0x30, 0x7e, 0x14, 0x80, 0x00, 0x80, 0x06, 0x20, 0x28, 
+    0x03, 0xd2, 0x08, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 
+    0x03, 0x12, 0x4d, 0x96, 0x30, 0x30, 0x06, 0x20, 0xe6, 0x4f, 0xd2, 0x08, 0x22, 0x30, 0xe6, 0x02, 
+    0xd2, 0x60, 0x7e, 0x37, 0x01, 0x79, 0x7e, 0x27, 0x01, 0x99, 0x9d, 0x32, 0x40, 0x31, 0x7d, 0x02, 
+    0x2e, 0x05, 0x32, 0x7a, 0x05, 0x32, 0x7a, 0x37, 0x01, 0x79, 0x7e, 0x37, 0x01, 0x59, 0x7d, 0x43, 
+    0x2d, 0x42, 0xbe, 0x44, 0x0d, 0xcc, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x59, 0x75, 0x2f, 0x94, 0x12, 
+    0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x12, 0x68, 0x34, 0x10, 0x60, 0xc4, 0x22, 0xc2, 
+    0x60, 0x2d, 0x23, 0x68, 0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 0x79, 0xbe, 0x24, 0x00, 
+    0x00, 0x68, 0x6a, 0xbe, 0x27, 0x01, 0x99, 0x28, 0x04, 0x7e, 0x27, 0x01, 0x99, 0x7e, 0x37, 0x01, 
+    0x79, 0x9d, 0x32, 0x7d, 0x02, 0x2e, 0x05, 0x32, 0x7a, 0x05, 0x32, 0x7a, 0x37, 0x01, 0x79, 0x7e, 
+    0x37, 0x01, 0x59, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x0d, 0xcc, 0x38, 0x13, 0x7a, 0x47, 0x01, 
+    0x59, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x02, 0x68, 0x34, 
+    0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x9e, 0x44, 0x0d, 0xcd, 
+    0x9d, 0x24, 0x12, 0x68, 0x34, 0x7e, 0x34, 0x09, 0xcd, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 
+    0x59, 0x12, 0x68, 0x34, 0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x4b, 0x0b, 0x22, 0xd2, 0x08, 0x7e, 
+    0x04, 0x09, 0xcd, 0x7a, 0x07, 0x01, 0x59, 0x7a, 0x07, 0x01, 0x69, 0x75, 0x2f, 0x94, 0x12, 0x7e, 
+    0x30, 0x75, 0x2f, 0x00, 0x12, 0x7e, 0x30, 0x22, 0x75, 0x2f, 0x92, 0x12, 0x7e, 0x30, 0xd2, 0x04, 
+    0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 0x7e, 0x37, 0x01, 0xcb, 
+    0x7e, 0x27, 0x01, 0xa9, 0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 0x04, 0x00, 0x38, 0x3c, 
+    0x7d, 0x02, 0x2e, 0x05, 0x30, 0x7a, 0x05, 0x30, 0x7a, 0x37, 0x01, 0xcb, 0x7e, 0x37, 0x01, 0xc9, 
+    0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x05, 0xcc, 0x38, 0x44, 0x7a, 0x47, 0x01, 0xc9, 0x7e, 0x24, 
+    0x00, 0x00, 0x2e, 0x27, 0x01, 0xa9, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 
+    0x30, 0xbe, 0x50, 0x38, 0x78, 0x03, 0x02, 0x69, 0x1f, 0x02, 0x69, 0x04, 0x75, 0x2f, 0x99, 0x12, 
+    0x7e, 0x30, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x38, 0x0a, 0x09, 
+    0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x10, 0x22, 0x80, 0x7f, 0x7a, 0x51, 
+    0x2f, 0x12, 0x7e, 0x30, 0x9e, 0x44, 0x05, 0xcd, 0x9d, 0x24, 0x7e, 0x64, 0x00, 0x00, 0x2e, 0x67, 
+    0x01, 0xa9, 0x9e, 0x24, 0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 0x35, 0x12, 0x69, 0x04, 
+    0x7e, 0x34, 0x01, 0xcd, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xc9, 0x02, 0x69, 0x04, 0x7a, 
+    0x39, 0xc0, 0x7e, 0x34, 0x01, 0xcd, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 0x44, 0x80, 0xe5, 0x9d, 
+    0x32, 0x7c, 0xb6, 0x54, 0x0f, 0x23, 0x23, 0x23, 0x44, 0x00, 0x7a, 0x69, 0xb0, 0x7a, 0x79, 0x70, 
+    0x0b, 0x35, 0x75, 0x2f, 0x93, 0x12, 0x7e, 0x30, 0x7a, 0x71, 0x2f, 0x12, 0x7e, 0x30, 0xbd, 0x04, 
+    0x68, 0x2b, 0x7a, 0x07, 0x01, 0xc9, 0x7e, 0x47, 0x01, 0xcb, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xcb, 
+    0x2e, 0x35, 0x30, 0x7a, 0x35, 0x30, 0x22, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0x13, 
+    0x22, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0x28, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0x2a, 0x7e, 0x04, 0x01, 
+    0xcd, 0x80, 0xcf, 0x7e, 0x07, 0x01, 0xcb, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 0x20, 0x28, 0x40, 0x7e, 
+    0x07, 0x01, 0xc9, 0x7e, 0x44, 0x05, 0xcd, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd2, 0x7d, 
+    0x70, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd0, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 0x25, 0x40, 0x02, 0x7d, 
+    0x25, 0x7d, 0x32, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 0x01, 0x31, 0xda, 0xb8, 
+    0x7e, 0x19, 0xb0, 0x7a, 0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 0x02, 0x4c, 0x6f, 0x75, 
+    0x2f, 0x99, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 
+    0x38, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x10, 0x22, 0xda, 
+    0xb8, 0x30, 0xe0, 0xd8, 0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x4c, 0x6f, 0xda, 0xb8, 0x02, 
+    0x4d, 0x96, 0x09, 0xb1, 0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x2f, 0x90, 0x12, 0x7e, 0x30, 0xf5, 
+    0x2f, 0x12, 0x7e, 0x30, 0xa5, 0xfd, 0x5e, 0x50, 0x0a, 0x68, 0x1d, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 
+    0x68, 0x04, 0xd2, 0x58, 0x80, 0x02, 0xc2, 0x58, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 
+    0x50, 0x80, 0x02, 0xc2, 0x50, 0x12, 0x42, 0xac, 0x02, 0x65, 0x9c, 0x75, 0x2f, 0x91, 0x12, 0x7e, 
+    0x30, 0x09, 0xb1, 0x00, 0x14, 0x7a, 0xb1, 0x2f, 0x12, 0x7e, 0x30, 0x20, 0xe0, 0x08, 0xd2, 0x04, 
+    0x7e, 0xa0, 0x80, 0x02, 0x65, 0x9c, 0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 0x12, 0x65, 
+    0x9c, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 0x61, 0x00, 
+    0x00, 0x12, 0x65, 0xbf, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x4c, 0xc3, 0x75, 
+    0x2f, 0x95, 0x12, 0x7e, 0x30, 0x22, 0x75, 0x2f, 0x96, 0x12, 0x7e, 0x30, 0x22, 0x10, 0x09, 0x01, 
+    0x22, 0x20, 0x29, 0x03, 0xd2, 0x09, 0x22, 0x75, 0x2f, 0xa1, 0x12, 0x7e, 0x30, 0x7e, 0x14, 0x81, 
+    0x00, 0x80, 0x06, 0x20, 0x29, 0x03, 0xd2, 0x09, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x5e, 
+    0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x03, 0x12, 0x50, 0xcb, 0x30, 0x31, 0x06, 0x20, 0xe6, 0x4f, 0xd2, 
+    0x09, 0x22, 0x30, 0xe6, 0x02, 0xd2, 0x61, 0x7e, 0x37, 0x01, 0x7b, 0x7e, 0x27, 0x01, 0x9b, 0x9d, 
+    0x32, 0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 0x34, 0x7a, 0x05, 0x34, 0x7a, 0x37, 0x01, 0x7b, 0x7e, 
+    0x37, 0x01, 0x5b, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x11, 0xcc, 0x38, 0x68, 0x7a, 0x47, 0x01, 
+    0x5b, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x12, 0x68, 0x34, 
+    0x10, 0x61, 0xc4, 0x22, 0xc2, 0x61, 0x2d, 0x23, 0x68, 0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 
+    0x01, 0x7b, 0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 0x27, 0x01, 0x9b, 0x28, 0x04, 0x7e, 0x27, 
+    0x01, 0x9b, 0x7e, 0x37, 0x01, 0x7b, 0x9d, 0x32, 0x7d, 0x02, 0x2e, 0x05, 0x34, 0x7a, 0x05, 0x34, 
+    0x7a, 0x37, 0x01, 0x7b, 0x7e, 0x37, 0x01, 0x5b, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x11, 0xcc, 
+    0x38, 0x13, 0x7a, 0x47, 0x01, 0x5b, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 
+    0x7e, 0x30, 0x02, 0x68, 0x34, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 
+    0x30, 0x9e, 0x44, 0x11, 0xcd, 0x9d, 0x24, 0x12, 0x68, 0x34, 0x7e, 0x34, 0x0d, 0xcd, 0x7d, 0x24, 
+    0x2d, 0x43, 0x7a, 0x47, 0x01, 0x5b, 0x12, 0x68, 0x34, 0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x4e, 
+    0x40, 0x22, 0xd2, 0x09, 0x7e, 0x04, 0x0d, 0xcd, 0x7a, 0x07, 0x01, 0x5b, 0x7a, 0x07, 0x01, 0x6b, 
+    0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x75, 0x2f, 0x00, 0x12, 0x7e, 0x30, 0x22, 0x75, 0x2f, 0x92, 
+    0x12, 0x7e, 0x30, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 
+    0x70, 0x7e, 0x37, 0x01, 0xcb, 0x7e, 0x27, 0x01, 0xab, 0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 
+    0x34, 0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 0x30, 0x7a, 0x05, 0x30, 0x7a, 0x37, 0x01, 
+    0xcb, 0x7e, 0x37, 0x01, 0xc9, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x05, 0xcc, 0x38, 0x44, 0x7a, 
+    0x47, 0x01, 0xc9, 0x7e, 0x24, 0x01, 0x00, 0x2e, 0x27, 0x01, 0xab, 0x1b, 0x38, 0x20, 0x0b, 0x35, 
+    0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0xbe, 0x50, 0x38, 0x78, 0x03, 0x02, 0x69, 0x1f, 0x02, 0x69, 
+    0x04, 0x75, 0x2f, 0x99, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 
+    0x04, 0x30, 0x39, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x11, 
+    0x22, 0x80, 0x7f, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x9e, 0x44, 0x05, 0xcd, 0x9d, 0x24, 0x7e, 
+    0x64, 0x01, 0x00, 0x2e, 0x67, 0x01, 0xab, 0x9e, 0x24, 0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 
+    0x0b, 0x35, 0x12, 0x69, 0x04, 0x7e, 0x34, 0x01, 0xcd, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 
+    0xc9, 0x02, 0x69, 0x04, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 0x01, 0xcd, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 
+    0x1b, 0x44, 0x80, 0xe5, 0x9d, 0x32, 0x7c, 0xb6, 0x54, 0x0f, 0x23, 0x23, 0x23, 0x44, 0x01, 0x7a, 
+    0x69, 0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x2f, 0x93, 0x12, 0x7e, 0x30, 0x7a, 0x71, 0x2f, 
+    0x12, 0x7e, 0x30, 0xbd, 0x04, 0x68, 0x2b, 0x7a, 0x07, 0x01, 0xc9, 0x7e, 0x47, 0x01, 0xcb, 0x2d, 
+    0x43, 0x7a, 0x47, 0x01, 0xcb, 0x2e, 0x35, 0x30, 0x7a, 0x35, 0x30, 0x22, 0xd2, 0x04, 0x09, 0xb1, 
+    0x00, 0x14, 0x20, 0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0x28, 0x7e, 0x04, 0x01, 0xcd, 
+    0x80, 0x2a, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0xcf, 0x7e, 0x07, 0x01, 0xcb, 0x7e, 0x24, 0x03, 0xfe, 
+    0x9d, 0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 0xc9, 0x7e, 0x44, 0x05, 0xcd, 0x7d, 0x60, 0x0b, 0x04, 
+    0xbd, 0x04, 0x68, 0xd2, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd0, 0x7d, 0x54, 0x9d, 0x50, 
+    0xbd, 0x25, 0x40, 0x02, 0x7d, 0x25, 0x7d, 0x32, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 
+    0xb4, 0x01, 0x31, 0xda, 0xb8, 0x7e, 0x19, 0xb0, 0x7a, 0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 
+    0xe7, 0x02, 0x4f, 0xa4, 0x75, 0x2f, 0x99, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 
+    0x19, 0xb1, 0x00, 0x04, 0x30, 0x39, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 
+    0x10, 0xd2, 0x11, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 
+    0x4f, 0xa4, 0xda, 0xb8, 0x02, 0x50, 0xcb, 0x09, 0xb1, 0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x2f, 
+    0x90, 0x12, 0x7e, 0x30, 0xf5, 0x2f, 0x12, 0x7e, 0x30, 0xa5, 0xfd, 0x5e, 0x50, 0x0a, 0x68, 0x1d, 
+    0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x59, 0x80, 0x02, 0xc2, 0x59, 0xa5, 0xfd, 0x5e, 
+    0x50, 0x80, 0x68, 0x04, 0xd2, 0x51, 0x80, 0x02, 0xc2, 0x51, 0x12, 0x42, 0xc3, 0x02, 0x65, 0x9c, 
+    0x75, 0x2f, 0x91, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x14, 0x7a, 0xb1, 0x2f, 0x12, 0x7e, 0x30, 
+    0x20, 0xe0, 0x08, 0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x65, 0x9c, 0xd2, 0x04, 0x30, 0xe1, 0x06, 
+    0x7e, 0xa0, 0x80, 0x12, 0x65, 0x9c, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 0xda, 0xb8, 0x68, 0x12, 0x7e, 
+    0xa0, 0xc0, 0x09, 0x61, 0x00, 0x00, 0x12, 0x65, 0xbf, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0xdb, 
+    0x22, 0x02, 0x4f, 0xf8, 0x75, 0x2f, 0x95, 0x12, 0x7e, 0x30, 0x22, 0x75, 0x2f, 0x96, 0x12, 0x7e, 
+    0x30, 0x22, 0x10, 0x0a, 0x01, 0x22, 0x20, 0x2a, 0x03, 0xd2, 0x0a, 0x22, 0x75, 0x2f, 0xa2, 0x12, 
+    0x7e, 0x30, 0x7e, 0x14, 0x82, 0x00, 0x80, 0x06, 0x20, 0x2a, 0x03, 0xd2, 0x0a, 0x22, 0x09, 0xb1, 
+    0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x03, 0x12, 0x54, 0x00, 0x30, 0x32, 
+    0x06, 0x20, 0xe6, 0x4f, 0xd2, 0x0a, 0x22, 0x30, 0xe6, 0x02, 0xd2, 0x62, 0x7e, 0x37, 0x01, 0x7d, 
+    0x7e, 0x27, 0x01, 0x9d, 0x9d, 0x32, 0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 0x36, 0x7a, 0x05, 0x36, 
+    0x7a, 0x37, 0x01, 0x7d, 0x7e, 0x37, 0x01, 0x5d, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x15, 0xcc, 
+    0x38, 0x68, 0x7a, 0x47, 0x01, 0x5d, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 
+    0x7e, 0x30, 0x12, 0x68, 0x34, 0x10, 0x62, 0xc4, 0x22, 0xc2, 0x62, 0x2d, 0x23, 0x68, 0x78, 0x6d, 
+    0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 0x7d, 0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 0x27, 0x01, 
+    0x9d, 0x28, 0x04, 0x7e, 0x27, 0x01, 0x9d, 0x7e, 0x37, 0x01, 0x7d, 0x9d, 0x32, 0x7d, 0x02, 0x2e, 
+    0x05, 0x36, 0x7a, 0x05, 0x36, 0x7a, 0x37, 0x01, 0x7d, 0x7e, 0x37, 0x01, 0x5d, 0x7d, 0x43, 0x2d, 
+    0x42, 0xbe, 0x44, 0x15, 0xcc, 0x38, 0x13, 0x7a, 0x47, 0x01, 0x5d, 0x75, 0x2f, 0x94, 0x12, 0x7e, 
+    0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x02, 0x68, 0x34, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 
+    0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x9e, 0x44, 0x15, 0xcd, 0x9d, 0x24, 0x12, 0x68, 0x34, 0x7e, 
+    0x34, 0x11, 0xcd, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0x5d, 0x12, 0x68, 0x34, 0xbe, 0x25, 
+    0x20, 0x78, 0x03, 0x02, 0x51, 0x75, 0x22, 0xd2, 0x0a, 0x7e, 0x04, 0x11, 0xcd, 0x7a, 0x07, 0x01, 
+    0x5d, 0x7a, 0x07, 0x01, 0x6d, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x75, 0x2f, 0x00, 0x12, 0x7e, 
+    0x30, 0x22, 0x75, 0x2f, 0x92, 0x12, 0x7e, 0x30, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 
+    0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 0x7e, 0x37, 0x01, 0xcb, 0x7e, 0x27, 0x01, 0xad, 0x2e, 0x24, 
+    0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 0x30, 0x7a, 
+    0x05, 0x30, 0x7a, 0x37, 0x01, 0xcb, 0x7e, 0x37, 0x01, 0xc9, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 
+    0x05, 0xcc, 0x38, 0x44, 0x7a, 0x47, 0x01, 0xc9, 0x7e, 0x24, 0x02, 0x00, 0x2e, 0x27, 0x01, 0xad, 
+    0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0xbe, 0x50, 0x38, 0x78, 0x03, 
+    0x02, 0x69, 0x1f, 0x02, 0x69, 0x04, 0x75, 0x2f, 0x99, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x04, 
+    0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3a, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 
+    0xb1, 0x00, 0x10, 0xd2, 0x12, 0x22, 0x80, 0x7f, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x9e, 0x44, 
+    0x05, 0xcd, 0x9d, 0x24, 0x7e, 0x64, 0x02, 0x00, 0x2e, 0x67, 0x01, 0xad, 0x9e, 0x24, 0x00, 0x02, 
+    0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 0x35, 0x12, 0x69, 0x04, 0x7e, 0x34, 0x01, 0xcd, 0x7d, 0x24, 
+    0x2d, 0x43, 0x7a, 0x47, 0x01, 0xc9, 0x02, 0x69, 0x04, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 0x01, 0xcd, 
+    0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 0x44, 0x80, 0xe5, 0x9d, 0x32, 0x7c, 0xb6, 0x54, 0x0f, 0x23, 
+    0x23, 0x23, 0x44, 0x02, 0x7a, 0x69, 0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x2f, 0x93, 0x12, 
+    0x7e, 0x30, 0x7a, 0x71, 0x2f, 0x12, 0x7e, 0x30, 0xbd, 0x04, 0x68, 0x2b, 0x7a, 0x07, 0x01, 0xc9, 
+    0x7e, 0x47, 0x01, 0xcb, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xcb, 0x2e, 0x35, 0x30, 0x7a, 0x35, 0x30, 
+    0x22, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xcd, 0x80, 
+    0x28, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0x2a, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0xcf, 0x7e, 0x07, 0x01, 
+    0xcb, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 0xc9, 0x7e, 0x44, 0x05, 
+    0xcd, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd2, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 0x04, 0x68, 
+    0xd0, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 0x25, 0x40, 0x02, 0x7d, 0x25, 0x7d, 0x32, 0x09, 0xb1, 0x00, 
+    0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 0x01, 0x31, 0xda, 0xb8, 0x7e, 0x19, 0xb0, 0x7a, 0x09, 0xb0, 
+    0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 0x02, 0x52, 0xd9, 0x75, 0x2f, 0x99, 0x12, 0x7e, 0x30, 0x09, 
+    0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3a, 0x0a, 0x09, 0xb1, 0x00, 0x10, 
+    0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x12, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 0xbd, 0x32, 
+    0x68, 0x07, 0xca, 0xb8, 0x12, 0x52, 0xd9, 0xda, 0xb8, 0x02, 0x54, 0x00, 0x09, 0xb1, 0x00, 0x18, 
+    0x7e, 0xa0, 0x88, 0x75, 0x2f, 0x90, 0x12, 0x7e, 0x30, 0xf5, 0x2f, 0x12, 0x7e, 0x30, 0xa5, 0xfd, 
+    0x5e, 0x50, 0x0a, 0x68, 0x1d, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x5a, 0x80, 0x02, 
+    0xc2, 0x5a, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x52, 0x80, 0x02, 0xc2, 0x52, 0x12, 
+    0x42, 0xda, 0x02, 0x65, 0x9c, 0x75, 0x2f, 0x91, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x14, 0x7a, 
+    0xb1, 0x2f, 0x12, 0x7e, 0x30, 0x20, 0xe0, 0x08, 0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x65, 0x9c, 
+    0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 0x12, 0x65, 0x9c, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 
+    0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 0x61, 0x00, 0x00, 0x12, 0x65, 0xbf, 0x09, 0xb1, 
+    0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x53, 0x2d, 0x75, 0x2f, 0x95, 0x12, 0x7e, 0x30, 0x22, 
+    0x75, 0x2f, 0x96, 0x12, 0x7e, 0x30, 0x22, 0x10, 0x0b, 0x01, 0x22, 0x20, 0x2b, 0x03, 0xd2, 0x0b, 
+    0x22, 0x75, 0x2f, 0xa3, 0x12, 0x7e, 0x30, 0x7e, 0x14, 0x83, 0x00, 0x80, 0x06, 0x20, 0x2b, 0x03, 
     0xd2, 0x0b, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x03, 
-    0x12, 0x53, 0x38, 0x20, 0xe6, 0x03, 0xd2, 0x0b, 0x22, 0x30, 0x33, 0x49, 0xd2, 0x73, 0x7e, 0x37, 
-    0x01, 0x95, 0x7e, 0x27, 0x01, 0xb5, 0x9d, 0x32, 0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 0x4e, 0x7a, 
-    0x05, 0x4e, 0x7a, 0x37, 0x01, 0x95, 0x7e, 0x37, 0x01, 0x75, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 
-    0x19, 0xe2, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x75, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 
-    0x31, 0x12, 0x7c, 0x15, 0x12, 0x65, 0x2b, 0x10, 0x73, 0xc4, 0x22, 0xc2, 0x73, 0x2d, 0x23, 0x68, 
-    0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 0x95, 0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 
-    0x27, 0x01, 0xb5, 0x28, 0x04, 0x7e, 0x27, 0x01, 0xb5, 0x7e, 0x37, 0x01, 0x95, 0x9d, 0x32, 0x7d, 
-    0x02, 0x2e, 0x05, 0x4e, 0x7a, 0x05, 0x4e, 0x7a, 0x37, 0x01, 0x95, 0x7e, 0x37, 0x01, 0x75, 0x7d, 
-    0x43, 0x2d, 0x42, 0xbe, 0x44, 0x19, 0xe2, 0x38, 0x13, 0x7a, 0x47, 0x01, 0x75, 0x75, 0x31, 0x94, 
-    0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x02, 0x65, 0x2b, 0x75, 0x31, 0x94, 0x12, 
-    0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x9e, 0x44, 0x19, 0xe3, 0x9d, 0x24, 0x12, 0x65, 
-    0x2b, 0x7e, 0x34, 0x15, 0xe3, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0x75, 0x12, 0x65, 0x2b, 
-    0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x50, 0x87, 0x22, 0xd2, 0x0b, 0x7e, 0x04, 0x15, 0xe3, 0x7a, 
-    0x07, 0x01, 0x75, 0x7a, 0x07, 0x01, 0x85, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x75, 0x31, 0x00, 
-    0x12, 0x7c, 0x15, 0x22, 0x75, 0x31, 0x92, 0x12, 0x7c, 0x15, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 
-    0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 0x7e, 0x37, 0x01, 0xe1, 0x7e, 0x27, 0x01, 0xc5, 
-    0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 
-    0x46, 0x7a, 0x05, 0x46, 0x7a, 0x37, 0x01, 0xe1, 0x7e, 0x37, 0x01, 0xdf, 0x7d, 0x43, 0x2d, 0x42, 
-    0xbe, 0x44, 0x05, 0xe2, 0x38, 0x44, 0x7a, 0x47, 0x01, 0xdf, 0x7e, 0x24, 0x03, 0x00, 0x2e, 0x27, 
-    0x01, 0xc5, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0xbe, 0x50, 0x38, 
-    0x78, 0x03, 0x02, 0x66, 0x16, 0x02, 0x65, 0xfb, 0x75, 0x31, 0x99, 0x12, 0x7c, 0x15, 0x09, 0xb1, 
-    0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3b, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 
-    0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x13, 0x22, 0x80, 0x7d, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 
-    0x9e, 0x44, 0x05, 0xe3, 0x9d, 0x24, 0x7e, 0x64, 0x03, 0x00, 0x2e, 0x67, 0x01, 0xc5, 0x9e, 0x24, 
-    0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 0x35, 0x12, 0x65, 0xfb, 0x7e, 0x34, 0x01, 0xe3, 
-    0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xdf, 0x02, 0x65, 0xfb, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 
-    0x01, 0xe3, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 0x44, 0x80, 0xe5, 0x9d, 0x32, 0x7c, 0xb6, 0x54, 
-    0x0f, 0x23, 0x23, 0x23, 0x44, 0x03, 0x7a, 0x69, 0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x31, 
-    0x93, 0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 0x7c, 0x15, 0xbd, 0x04, 0x68, 0x29, 0x7a, 0x07, 
-    0x01, 0xdf, 0x7e, 0x47, 0x01, 0xe1, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xe1, 0x2e, 0x35, 0x46, 0x7a, 
-    0x35, 0x46, 0x22, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xe3, 0x80, 
-    0x2a, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0x2c, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0xd1, 0xd2, 0x04, 0x7e, 
-    0x07, 0x01, 0xe1, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 0xdf, 0x7e, 
-    0x44, 0x05, 0xe3, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd0, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 
-    0x04, 0x68, 0xce, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 0x25, 0x40, 0x02, 0x7d, 0x25, 0x7d, 0x32, 0x09, 
-    0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 0x01, 0x31, 0xda, 0xb8, 0x7e, 0x19, 0xb0, 0x7a, 
-    0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 0x02, 0x51, 0xeb, 0x75, 0x31, 0x99, 0x12, 0x7c, 
-    0x15, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3b, 0x0a, 0x09, 0xb1, 
-    0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x13, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 
-    0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x51, 0xeb, 0xda, 0xb8, 0x02, 0x53, 0x38, 0x09, 0xb1, 
-    0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x31, 0x90, 0x12, 0x7c, 0x15, 0xf5, 0x31, 0x12, 0x7c, 0x15, 
-    0xa5, 0xfc, 0x5e, 0xb0, 0xf0, 0xa5, 0xfd, 0x09, 0xb1, 0x00, 0x18, 0x4c, 0x4b, 0x5e, 0xb0, 0xf0, 
-    0xbc, 0xb5, 0x78, 0xf1, 0x5e, 0x40, 0x0f, 0x4c, 0x54, 0x7c, 0xb5, 0x5e, 0x50, 0x0b, 0x68, 0x2a, 
-    0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 0x6b, 0x80, 0x02, 0xc2, 0x6b, 0xa5, 0xfd, 0x5e, 
-    0x50, 0x20, 0x68, 0x04, 0xd2, 0x63, 0x80, 0x02, 0xc2, 0x63, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 
-    0x04, 0xd2, 0x5b, 0x80, 0x02, 0xc2, 0x5b, 0x12, 0x43, 0x2b, 0x02, 0x62, 0x93, 0x75, 0x31, 0x91, 
-    0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x14, 0x7a, 0xb1, 0x31, 0x12, 0x7c, 0x15, 0x20, 0xe0, 0x08, 
-    0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x62, 0x93, 0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 
-    0x12, 0x62, 0x93, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 
-    0x61, 0x00, 0x00, 0x12, 0x62, 0xb6, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x52, 
-    0x3d, 0x75, 0x31, 0x95, 0x12, 0x7c, 0x15, 0x22, 0x75, 0x31, 0x96, 0x12, 0x7c, 0x15, 0x22, 0x10, 
-    0x0c, 0x01, 0x22, 0x20, 0x2c, 0x03, 0xd2, 0x0c, 0x22, 0x75, 0x31, 0xa4, 0x12, 0x7c, 0x15, 0x7e, 
-    0x14, 0x84, 0x00, 0x80, 0x06, 0x20, 0x2c, 0x03, 0xd2, 0x0c, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 
-    0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x03, 0x12, 0x56, 0x90, 0x20, 0xe6, 0x03, 0xd2, 0x0c, 
-    0x22, 0x30, 0x34, 0x49, 0xd2, 0x74, 0x7e, 0x37, 0x01, 0x97, 0x7e, 0x27, 0x01, 0xb7, 0x9d, 0x32, 
-    0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 0x50, 0x7a, 0x05, 0x50, 0x7a, 0x37, 0x01, 0x97, 0x7e, 0x37, 
-    0x01, 0x77, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x1d, 0xe2, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x77, 
-    0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x12, 0x65, 0x2b, 0x10, 
-    0x74, 0xc4, 0x22, 0xc2, 0x74, 0x2d, 0x23, 0x68, 0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 
-    0x97, 0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 0x27, 0x01, 0xb7, 0x28, 0x04, 0x7e, 0x27, 0x01, 
-    0xb7, 0x7e, 0x37, 0x01, 0x97, 0x9d, 0x32, 0x7d, 0x02, 0x2e, 0x05, 0x50, 0x7a, 0x05, 0x50, 0x7a, 
-    0x37, 0x01, 0x97, 0x7e, 0x37, 0x01, 0x77, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x1d, 0xe2, 0x38, 
-    0x13, 0x7a, 0x47, 0x01, 0x77, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 
-    0x15, 0x02, 0x65, 0x2b, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 
-    0x9e, 0x44, 0x1d, 0xe3, 0x9d, 0x24, 0x12, 0x65, 0x2b, 0x7e, 0x34, 0x19, 0xe3, 0x7d, 0x24, 0x2d, 
-    0x43, 0x7a, 0x47, 0x01, 0x77, 0x12, 0x65, 0x2b, 0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x53, 0xdf, 
-    0x22, 0xd2, 0x0c, 0x7e, 0x04, 0x19, 0xe3, 0x7a, 0x07, 0x01, 0x77, 0x7a, 0x07, 0x01, 0x87, 0x75, 
-    0x31, 0x94, 0x12, 0x7c, 0x15, 0x75, 0x31, 0x00, 0x12, 0x7c, 0x15, 0x22, 0x75, 0x31, 0x92, 0x12, 
-    0x7c, 0x15, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 
-    0x7e, 0x37, 0x01, 0xe1, 0x7e, 0x27, 0x01, 0xc7, 0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 
-    0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 0x46, 0x7a, 0x05, 0x46, 0x7a, 0x37, 0x01, 0xe1, 
-    0x7e, 0x37, 0x01, 0xdf, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x05, 0xe2, 0x38, 0x44, 0x7a, 0x47, 
-    0x01, 0xdf, 0x7e, 0x24, 0x04, 0x00, 0x2e, 0x27, 0x01, 0xc7, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 
-    0x51, 0x31, 0x12, 0x7c, 0x15, 0xbe, 0x50, 0x38, 0x78, 0x03, 0x02, 0x66, 0x16, 0x02, 0x65, 0xfb, 
-    0x75, 0x31, 0x99, 0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 
+    0x12, 0x57, 0x35, 0x30, 0x33, 0x06, 0x20, 0xe6, 0x4f, 0xd2, 0x0b, 0x22, 0x30, 0xe6, 0x02, 0xd2, 
+    0x63, 0x7e, 0x37, 0x01, 0x7f, 0x7e, 0x27, 0x01, 0x9f, 0x9d, 0x32, 0x40, 0x31, 0x7d, 0x02, 0x2e, 
+    0x05, 0x38, 0x7a, 0x05, 0x38, 0x7a, 0x37, 0x01, 0x7f, 0x7e, 0x37, 0x01, 0x5f, 0x7d, 0x43, 0x2d, 
+    0x42, 0xbe, 0x44, 0x19, 0xcc, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x5f, 0x75, 0x2f, 0x94, 0x12, 0x7e, 
+    0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x12, 0x68, 0x34, 0x10, 0x63, 0xc4, 0x22, 0xc2, 0x63, 
+    0x2d, 0x23, 0x68, 0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 0x7f, 0xbe, 0x24, 0x00, 0x00, 
+    0x68, 0x6a, 0xbe, 0x27, 0x01, 0x9f, 0x28, 0x04, 0x7e, 0x27, 0x01, 0x9f, 0x7e, 0x37, 0x01, 0x7f, 
+    0x9d, 0x32, 0x7d, 0x02, 0x2e, 0x05, 0x38, 0x7a, 0x05, 0x38, 0x7a, 0x37, 0x01, 0x7f, 0x7e, 0x37, 
+    0x01, 0x5f, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x19, 0xcc, 0x38, 0x13, 0x7a, 0x47, 0x01, 0x5f, 
+    0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x02, 0x68, 0x34, 0x75, 
+    0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x9e, 0x44, 0x19, 0xcd, 0x9d, 
+    0x24, 0x12, 0x68, 0x34, 0x7e, 0x34, 0x15, 0xcd, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0x5f, 
+    0x12, 0x68, 0x34, 0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x54, 0xaa, 0x22, 0xd2, 0x0b, 0x7e, 0x04, 
+    0x15, 0xcd, 0x7a, 0x07, 0x01, 0x5f, 0x7a, 0x07, 0x01, 0x6f, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 
+    0x75, 0x2f, 0x00, 0x12, 0x7e, 0x30, 0x22, 0x75, 0x2f, 0x92, 0x12, 0x7e, 0x30, 0xd2, 0x04, 0x09, 
+    0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 0x7e, 0x37, 0x01, 0xcb, 0x7e, 
+    0x27, 0x01, 0xaf, 0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 0x04, 0x00, 0x38, 0x3c, 0x7d, 
+    0x02, 0x2e, 0x05, 0x30, 0x7a, 0x05, 0x30, 0x7a, 0x37, 0x01, 0xcb, 0x7e, 0x37, 0x01, 0xc9, 0x7d, 
+    0x43, 0x2d, 0x42, 0xbe, 0x44, 0x05, 0xcc, 0x38, 0x44, 0x7a, 0x47, 0x01, 0xc9, 0x7e, 0x24, 0x03, 
+    0x00, 0x2e, 0x27, 0x01, 0xaf, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 
+    0xbe, 0x50, 0x38, 0x78, 0x03, 0x02, 0x69, 0x1f, 0x02, 0x69, 0x04, 0x75, 0x2f, 0x99, 0x12, 0x7e, 
+    0x30, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3b, 0x0a, 0x09, 0xb1, 
+    0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x13, 0x22, 0x80, 0x7f, 0x7a, 0x51, 0x2f, 
+    0x12, 0x7e, 0x30, 0x9e, 0x44, 0x05, 0xcd, 0x9d, 0x24, 0x7e, 0x64, 0x03, 0x00, 0x2e, 0x67, 0x01, 
+    0xaf, 0x9e, 0x24, 0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 0x35, 0x12, 0x69, 0x04, 0x7e, 
+    0x34, 0x01, 0xcd, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xc9, 0x02, 0x69, 0x04, 0x7a, 0x39, 
+    0xc0, 0x7e, 0x34, 0x01, 0xcd, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 0x44, 0x80, 0xe5, 0x9d, 0x32, 
+    0x7c, 0xb6, 0x54, 0x0f, 0x23, 0x23, 0x23, 0x44, 0x03, 0x7a, 0x69, 0xb0, 0x7a, 0x79, 0x70, 0x0b, 
+    0x35, 0x75, 0x2f, 0x93, 0x12, 0x7e, 0x30, 0x7a, 0x71, 0x2f, 0x12, 0x7e, 0x30, 0xbd, 0x04, 0x68, 
+    0x2b, 0x7a, 0x07, 0x01, 0xc9, 0x7e, 0x47, 0x01, 0xcb, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xcb, 0x2e, 
+    0x35, 0x30, 0x7a, 0x35, 0x30, 0x22, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0x13, 0x22, 
+    0x7e, 0x04, 0x01, 0xcd, 0x80, 0x28, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0x2a, 0x7e, 0x04, 0x01, 0xcd, 
+    0x80, 0xcf, 0x7e, 0x07, 0x01, 0xcb, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 0x20, 0x28, 0x40, 0x7e, 0x07, 
+    0x01, 0xc9, 0x7e, 0x44, 0x05, 0xcd, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd2, 0x7d, 0x70, 
+    0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd0, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 0x25, 0x40, 0x02, 0x7d, 0x25, 
+    0x7d, 0x32, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 0x01, 0x31, 0xda, 0xb8, 0x7e, 
+    0x19, 0xb0, 0x7a, 0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 0x02, 0x56, 0x0e, 0x75, 0x2f, 
+    0x99, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3b, 
+    0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x13, 0x22, 0xda, 0xb8, 
+    0x30, 0xe0, 0xd8, 0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x56, 0x0e, 0xda, 0xb8, 0x02, 0x57, 
+    0x35, 0x09, 0xb1, 0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x2f, 0x90, 0x12, 0x7e, 0x30, 0xf5, 0x2f, 
+    0x12, 0x7e, 0x30, 0xa5, 0xfd, 0x5e, 0x50, 0x0a, 0x68, 0x1d, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 
+    0x04, 0xd2, 0x5b, 0x80, 0x02, 0xc2, 0x5b, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x53, 
+    0x80, 0x02, 0xc2, 0x53, 0x12, 0x42, 0xf1, 0x02, 0x65, 0x9c, 0x75, 0x2f, 0x91, 0x12, 0x7e, 0x30, 
+    0x09, 0xb1, 0x00, 0x14, 0x7a, 0xb1, 0x2f, 0x12, 0x7e, 0x30, 0x20, 0xe0, 0x08, 0xd2, 0x04, 0x7e, 
+    0xa0, 0x80, 0x02, 0x65, 0x9c, 0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 0x12, 0x65, 0x9c, 
+    0xca, 0xb8, 0x5e, 0xb0, 0x1c, 0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 0x61, 0x00, 0x00, 
+    0x12, 0x65, 0xbf, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x56, 0x62, 0x75, 0x2f, 
+    0x95, 0x12, 0x7e, 0x30, 0x22, 0x75, 0x2f, 0x96, 0x12, 0x7e, 0x30, 0x22, 0x10, 0x0c, 0x01, 0x22, 
+    0x20, 0x2c, 0x03, 0xd2, 0x0c, 0x22, 0x75, 0x2f, 0xa4, 0x12, 0x7e, 0x30, 0x7e, 0x14, 0x84, 0x00, 
+    0x80, 0x06, 0x20, 0x2c, 0x03, 0xd2, 0x0c, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 
+    0x1e, 0xda, 0xb8, 0x68, 0x03, 0x12, 0x5a, 0x6a, 0x30, 0x34, 0x06, 0x20, 0xe6, 0x4f, 0xd2, 0x0c, 
+    0x22, 0x30, 0xe6, 0x02, 0xd2, 0x64, 0x7e, 0x37, 0x01, 0x81, 0x7e, 0x27, 0x01, 0xa1, 0x9d, 0x32, 
+    0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 0x3a, 0x7a, 0x05, 0x3a, 0x7a, 0x37, 0x01, 0x81, 0x7e, 0x37, 
+    0x01, 0x61, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x1d, 0xcc, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x61, 
+    0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x12, 0x68, 0x34, 0x10, 
+    0x64, 0xc4, 0x22, 0xc2, 0x64, 0x2d, 0x23, 0x68, 0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 
+    0x81, 0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 0x27, 0x01, 0xa1, 0x28, 0x04, 0x7e, 0x27, 0x01, 
+    0xa1, 0x7e, 0x37, 0x01, 0x81, 0x9d, 0x32, 0x7d, 0x02, 0x2e, 0x05, 0x3a, 0x7a, 0x05, 0x3a, 0x7a, 
+    0x37, 0x01, 0x81, 0x7e, 0x37, 0x01, 0x61, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x1d, 0xcc, 0x38, 
+    0x13, 0x7a, 0x47, 0x01, 0x61, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 
+    0x30, 0x02, 0x68, 0x34, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 
+    0x9e, 0x44, 0x1d, 0xcd, 0x9d, 0x24, 0x12, 0x68, 0x34, 0x7e, 0x34, 0x19, 0xcd, 0x7d, 0x24, 0x2d, 
+    0x43, 0x7a, 0x47, 0x01, 0x61, 0x12, 0x68, 0x34, 0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x57, 0xdf, 
+    0x22, 0xd2, 0x0c, 0x7e, 0x04, 0x19, 0xcd, 0x7a, 0x07, 0x01, 0x61, 0x7a, 0x07, 0x01, 0x71, 0x75, 
+    0x2f, 0x94, 0x12, 0x7e, 0x30, 0x75, 0x2f, 0x00, 0x12, 0x7e, 0x30, 0x22, 0x75, 0x2f, 0x92, 0x12, 
+    0x7e, 0x30, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 
+    0x7e, 0x37, 0x01, 0xcb, 0x7e, 0x27, 0x01, 0xb1, 0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 
+    0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 0x30, 0x7a, 0x05, 0x30, 0x7a, 0x37, 0x01, 0xcb, 
+    0x7e, 0x37, 0x01, 0xc9, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x05, 0xcc, 0x38, 0x44, 0x7a, 0x47, 
+    0x01, 0xc9, 0x7e, 0x24, 0x04, 0x00, 0x2e, 0x27, 0x01, 0xb1, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 
+    0x51, 0x2f, 0x12, 0x7e, 0x30, 0xbe, 0x50, 0x38, 0x78, 0x03, 0x02, 0x69, 0x1f, 0x02, 0x69, 0x04, 
+    0x75, 0x2f, 0x99, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 
     0x30, 0x3c, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x14, 0x22, 
-    0x80, 0x7d, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x9e, 0x44, 0x05, 0xe3, 0x9d, 0x24, 0x7e, 0x64, 
-    0x04, 0x00, 0x2e, 0x67, 0x01, 0xc7, 0x9e, 0x24, 0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 
-    0x35, 0x12, 0x65, 0xfb, 0x7e, 0x34, 0x01, 0xe3, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xdf, 
-    0x02, 0x65, 0xfb, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 0x01, 0xe3, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 
+    0x80, 0x7f, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x9e, 0x44, 0x05, 0xcd, 0x9d, 0x24, 0x7e, 0x64, 
+    0x04, 0x00, 0x2e, 0x67, 0x01, 0xb1, 0x9e, 0x24, 0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 
+    0x35, 0x12, 0x69, 0x04, 0x7e, 0x34, 0x01, 0xcd, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xc9, 
+    0x02, 0x69, 0x04, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 0x01, 0xcd, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 
     0x44, 0x80, 0xe5, 0x9d, 0x32, 0x7c, 0xb6, 0x54, 0x0f, 0x23, 0x23, 0x23, 0x44, 0x04, 0x7a, 0x69, 
-    0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x31, 0x93, 0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 
-    0x7c, 0x15, 0xbd, 0x04, 0x68, 0x29, 0x7a, 0x07, 0x01, 0xdf, 0x7e, 0x47, 0x01, 0xe1, 0x2d, 0x43, 
-    0x7a, 0x47, 0x01, 0xe1, 0x2e, 0x35, 0x46, 0x7a, 0x35, 0x46, 0x22, 0x09, 0xb1, 0x00, 0x14, 0x20, 
-    0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0x2a, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0x2c, 0x7e, 
-    0x04, 0x01, 0xe3, 0x80, 0xd1, 0xd2, 0x04, 0x7e, 0x07, 0x01, 0xe1, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 
-    0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 0xdf, 0x7e, 0x44, 0x05, 0xe3, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 
-    0x04, 0x68, 0xd0, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xce, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 
+    0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x2f, 0x93, 0x12, 0x7e, 0x30, 0x7a, 0x71, 0x2f, 0x12, 
+    0x7e, 0x30, 0xbd, 0x04, 0x68, 0x2b, 0x7a, 0x07, 0x01, 0xc9, 0x7e, 0x47, 0x01, 0xcb, 0x2d, 0x43, 
+    0x7a, 0x47, 0x01, 0xcb, 0x2e, 0x35, 0x30, 0x7a, 0x35, 0x30, 0x22, 0xd2, 0x04, 0x09, 0xb1, 0x00, 
+    0x14, 0x20, 0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0x28, 0x7e, 0x04, 0x01, 0xcd, 0x80, 
+    0x2a, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0xcf, 0x7e, 0x07, 0x01, 0xcb, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 
+    0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 0xc9, 0x7e, 0x44, 0x05, 0xcd, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 
+    0x04, 0x68, 0xd2, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd0, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 
     0x25, 0x40, 0x02, 0x7d, 0x25, 0x7d, 0x32, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 
     0x01, 0x31, 0xda, 0xb8, 0x7e, 0x19, 0xb0, 0x7a, 0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 
-    0x02, 0x55, 0x43, 0x75, 0x31, 0x99, 0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 
+    0x02, 0x59, 0x43, 0x75, 0x2f, 0x99, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 
     0xb1, 0x00, 0x04, 0x30, 0x3c, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 
-    0xd2, 0x14, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x55, 
-    0x43, 0xda, 0xb8, 0x02, 0x56, 0x90, 0x09, 0xb1, 0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x31, 0x90, 
-    0x12, 0x7c, 0x15, 0xf5, 0x31, 0x12, 0x7c, 0x15, 0xa5, 0xfc, 0x5e, 0xb0, 0xf0, 0xa5, 0xfd, 0x09, 
-    0xb1, 0x00, 0x18, 0x4c, 0x4b, 0x5e, 0xb0, 0xf0, 0xbc, 0xb5, 0x78, 0xf1, 0x5e, 0x40, 0x0f, 0x4c, 
-    0x54, 0x7c, 0xb5, 0x5e, 0x50, 0x0b, 0x68, 0x2a, 0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 
-    0x6c, 0x80, 0x02, 0xc2, 0x6c, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x64, 0x80, 0x02, 
-    0xc2, 0x64, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x5c, 0x80, 0x02, 0xc2, 0x5c, 0x12, 
-    0x43, 0x4c, 0x02, 0x62, 0x93, 0x75, 0x31, 0x91, 0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x14, 0x7a, 
-    0xb1, 0x31, 0x12, 0x7c, 0x15, 0x20, 0xe0, 0x08, 0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x62, 0x93, 
-    0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 0x12, 0x62, 0x93, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 
-    0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 0x61, 0x00, 0x00, 0x12, 0x62, 0xb6, 0x09, 0xb1, 
-    0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x55, 0x95, 0x75, 0x31, 0x95, 0x12, 0x7c, 0x15, 0x22, 
-    0x75, 0x31, 0x96, 0x12, 0x7c, 0x15, 0x22, 0x10, 0x0d, 0x01, 0x22, 0x20, 0x2d, 0x03, 0xd2, 0x0d, 
-    0x22, 0x75, 0x31, 0xa5, 0x12, 0x7c, 0x15, 0x7e, 0x14, 0x85, 0x00, 0x80, 0x06, 0x20, 0x2d, 0x03, 
-    0xd2, 0x0d, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x03, 
-    0x12, 0x59, 0xe8, 0x20, 0xe6, 0x03, 0xd2, 0x0d, 0x22, 0x30, 0x35, 0x49, 0xd2, 0x75, 0x7e, 0x37, 
-    0x01, 0x99, 0x7e, 0x27, 0x01, 0xb9, 0x9d, 0x32, 0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 0x52, 0x7a, 
-    0x05, 0x52, 0x7a, 0x37, 0x01, 0x99, 0x7e, 0x37, 0x01, 0x79, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 
-    0x21, 0xe2, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x79, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 
-    0x31, 0x12, 0x7c, 0x15, 0x12, 0x65, 0x2b, 0x10, 0x75, 0xc4, 0x22, 0xc2, 0x75, 0x2d, 0x23, 0x68, 
-    0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 0x99, 0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 
-    0x27, 0x01, 0xb9, 0x28, 0x04, 0x7e, 0x27, 0x01, 0xb9, 0x7e, 0x37, 0x01, 0x99, 0x9d, 0x32, 0x7d, 
-    0x02, 0x2e, 0x05, 0x52, 0x7a, 0x05, 0x52, 0x7a, 0x37, 0x01, 0x99, 0x7e, 0x37, 0x01, 0x79, 0x7d, 
-    0x43, 0x2d, 0x42, 0xbe, 0x44, 0x21, 0xe2, 0x38, 0x13, 0x7a, 0x47, 0x01, 0x79, 0x75, 0x31, 0x94, 
-    0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x02, 0x65, 0x2b, 0x75, 0x31, 0x94, 0x12, 
-    0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x9e, 0x44, 0x21, 0xe3, 0x9d, 0x24, 0x12, 0x65, 
-    0x2b, 0x7e, 0x34, 0x1d, 0xe3, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0x79, 0x12, 0x65, 0x2b, 
-    0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x57, 0x37, 0x22, 0xd2, 0x0d, 0x7e, 0x04, 0x1d, 0xe3, 0x7a, 
-    0x07, 0x01, 0x79, 0x7a, 0x07, 0x01, 0x89, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x75, 0x31, 0x00, 
-    0x12, 0x7c, 0x15, 0x22, 0x75, 0x31, 0x92, 0x12, 0x7c, 0x15, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 
-    0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 0x7e, 0x37, 0x01, 0xe1, 0x7e, 0x27, 0x01, 0xc9, 
-    0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 
-    0x46, 0x7a, 0x05, 0x46, 0x7a, 0x37, 0x01, 0xe1, 0x7e, 0x37, 0x01, 0xdf, 0x7d, 0x43, 0x2d, 0x42, 
-    0xbe, 0x44, 0x05, 0xe2, 0x38, 0x44, 0x7a, 0x47, 0x01, 0xdf, 0x7e, 0x24, 0x05, 0x00, 0x2e, 0x27, 
-    0x01, 0xc9, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0xbe, 0x50, 0x38, 
-    0x78, 0x03, 0x02, 0x66, 0x16, 0x02, 0x65, 0xfb, 0x75, 0x31, 0x99, 0x12, 0x7c, 0x15, 0x09, 0xb1, 
+    0xd2, 0x14, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x59, 
+    0x43, 0xda, 0xb8, 0x02, 0x5a, 0x6a, 0x09, 0xb1, 0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x2f, 0x90, 
+    0x12, 0x7e, 0x30, 0xf5, 0x2f, 0x12, 0x7e, 0x30, 0xa5, 0xfd, 0x5e, 0x50, 0x0a, 0x68, 0x1d, 0xa5, 
+    0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x5c, 0x80, 0x02, 0xc2, 0x5c, 0xa5, 0xfd, 0x5e, 0x50, 
+    0x80, 0x68, 0x04, 0xd2, 0x54, 0x80, 0x02, 0xc2, 0x54, 0x12, 0x43, 0x08, 0x02, 0x65, 0x9c, 0x75, 
+    0x2f, 0x91, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x14, 0x7a, 0xb1, 0x2f, 0x12, 0x7e, 0x30, 0x20, 
+    0xe0, 0x08, 0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x65, 0x9c, 0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 
+    0xa0, 0x80, 0x12, 0x65, 0x9c, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 
+    0xc0, 0x09, 0x61, 0x00, 0x00, 0x12, 0x65, 0xbf, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 
+    0x02, 0x59, 0x97, 0x75, 0x2f, 0x95, 0x12, 0x7e, 0x30, 0x22, 0x75, 0x2f, 0x96, 0x12, 0x7e, 0x30, 
+    0x22, 0x10, 0x0d, 0x01, 0x22, 0x20, 0x2d, 0x03, 0xd2, 0x0d, 0x22, 0x75, 0x2f, 0xa5, 0x12, 0x7e, 
+    0x30, 0x7e, 0x14, 0x85, 0x00, 0x80, 0x06, 0x20, 0x2d, 0x03, 0xd2, 0x0d, 0x22, 0x09, 0xb1, 0x00, 
+    0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x03, 0x12, 0x5d, 0x9f, 0x30, 0x35, 0x06, 
+    0x20, 0xe6, 0x4f, 0xd2, 0x0d, 0x22, 0x30, 0xe6, 0x02, 0xd2, 0x65, 0x7e, 0x37, 0x01, 0x83, 0x7e, 
+    0x27, 0x01, 0xa3, 0x9d, 0x32, 0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 0x3c, 0x7a, 0x05, 0x3c, 0x7a, 
+    0x37, 0x01, 0x83, 0x7e, 0x37, 0x01, 0x63, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x21, 0xcc, 0x38, 
+    0x68, 0x7a, 0x47, 0x01, 0x63, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 
+    0x30, 0x12, 0x68, 0x34, 0x10, 0x65, 0xc4, 0x22, 0xc2, 0x65, 0x2d, 0x23, 0x68, 0x78, 0x6d, 0x33, 
+    0x80, 0x1a, 0x7e, 0x27, 0x01, 0x83, 0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 0x27, 0x01, 0xa3, 
+    0x28, 0x04, 0x7e, 0x27, 0x01, 0xa3, 0x7e, 0x37, 0x01, 0x83, 0x9d, 0x32, 0x7d, 0x02, 0x2e, 0x05, 
+    0x3c, 0x7a, 0x05, 0x3c, 0x7a, 0x37, 0x01, 0x83, 0x7e, 0x37, 0x01, 0x63, 0x7d, 0x43, 0x2d, 0x42, 
+    0xbe, 0x44, 0x21, 0xcc, 0x38, 0x13, 0x7a, 0x47, 0x01, 0x63, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 
+    0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x02, 0x68, 0x34, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 
+    0x51, 0x2f, 0x12, 0x7e, 0x30, 0x9e, 0x44, 0x21, 0xcd, 0x9d, 0x24, 0x12, 0x68, 0x34, 0x7e, 0x34, 
+    0x1d, 0xcd, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0x63, 0x12, 0x68, 0x34, 0xbe, 0x25, 0x20, 
+    0x78, 0x03, 0x02, 0x5b, 0x14, 0x22, 0xd2, 0x0d, 0x7e, 0x04, 0x1d, 0xcd, 0x7a, 0x07, 0x01, 0x63, 
+    0x7a, 0x07, 0x01, 0x73, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x75, 0x2f, 0x00, 0x12, 0x7e, 0x30, 
+    0x22, 0x75, 0x2f, 0x92, 0x12, 0x7e, 0x30, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 
+    0x82, 0xda, 0xb8, 0x78, 0x70, 0x7e, 0x37, 0x01, 0xcb, 0x7e, 0x27, 0x01, 0xb3, 0x2e, 0x24, 0x00, 
+    0x02, 0x2d, 0x32, 0xbe, 0x34, 0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 0x30, 0x7a, 0x05, 
+    0x30, 0x7a, 0x37, 0x01, 0xcb, 0x7e, 0x37, 0x01, 0xc9, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x05, 
+    0xcc, 0x38, 0x44, 0x7a, 0x47, 0x01, 0xc9, 0x7e, 0x24, 0x05, 0x00, 0x2e, 0x27, 0x01, 0xb3, 0x1b, 
+    0x38, 0x20, 0x0b, 0x35, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0xbe, 0x50, 0x38, 0x78, 0x03, 0x02, 
+    0x69, 0x1f, 0x02, 0x69, 0x04, 0x75, 0x2f, 0x99, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x04, 0x54, 
+    0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3d, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 
+    0x00, 0x10, 0xd2, 0x15, 0x22, 0x80, 0x7f, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x9e, 0x44, 0x05, 
+    0xcd, 0x9d, 0x24, 0x7e, 0x64, 0x05, 0x00, 0x2e, 0x67, 0x01, 0xb3, 0x9e, 0x24, 0x00, 0x02, 0x40, 
+    0x17, 0x1b, 0x38, 0x60, 0x0b, 0x35, 0x12, 0x69, 0x04, 0x7e, 0x34, 0x01, 0xcd, 0x7d, 0x24, 0x2d, 
+    0x43, 0x7a, 0x47, 0x01, 0xc9, 0x02, 0x69, 0x04, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 0x01, 0xcd, 0x7a, 
+    0x39, 0xd0, 0x0b, 0x34, 0x1b, 0x44, 0x80, 0xe5, 0x9d, 0x32, 0x7c, 0xb6, 0x54, 0x0f, 0x23, 0x23, 
+    0x23, 0x44, 0x05, 0x7a, 0x69, 0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x2f, 0x93, 0x12, 0x7e, 
+    0x30, 0x7a, 0x71, 0x2f, 0x12, 0x7e, 0x30, 0xbd, 0x04, 0x68, 0x2b, 0x7a, 0x07, 0x01, 0xc9, 0x7e, 
+    0x47, 0x01, 0xcb, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xcb, 0x2e, 0x35, 0x30, 0x7a, 0x35, 0x30, 0x22, 
+    0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0x28, 
+    0x7e, 0x04, 0x01, 0xcd, 0x80, 0x2a, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0xcf, 0x7e, 0x07, 0x01, 0xcb, 
+    0x7e, 0x24, 0x03, 0xfe, 0x9d, 0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 0xc9, 0x7e, 0x44, 0x05, 0xcd, 
+    0x7d, 0x60, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd2, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd0, 
+    0x7d, 0x54, 0x9d, 0x50, 0xbd, 0x25, 0x40, 0x02, 0x7d, 0x25, 0x7d, 0x32, 0x09, 0xb1, 0x00, 0x14, 
+    0xca, 0xb8, 0x54, 0x1f, 0xb4, 0x01, 0x31, 0xda, 0xb8, 0x7e, 0x19, 0xb0, 0x7a, 0x09, 0xb0, 0x0b, 
+    0x04, 0x1b, 0x24, 0x78, 0xe7, 0x02, 0x5c, 0x78, 0x75, 0x2f, 0x99, 0x12, 0x7e, 0x30, 0x09, 0xb1, 
     0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3d, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 
-    0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x15, 0x22, 0x80, 0x7d, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 
-    0x9e, 0x44, 0x05, 0xe3, 0x9d, 0x24, 0x7e, 0x64, 0x05, 0x00, 0x2e, 0x67, 0x01, 0xc9, 0x9e, 0x24, 
-    0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 0x35, 0x12, 0x65, 0xfb, 0x7e, 0x34, 0x01, 0xe3, 
-    0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xdf, 0x02, 0x65, 0xfb, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 
-    0x01, 0xe3, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 0x44, 0x80, 0xe5, 0x9d, 0x32, 0x7c, 0xb6, 0x54, 
-    0x0f, 0x23, 0x23, 0x23, 0x44, 0x05, 0x7a, 0x69, 0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x31, 
-    0x93, 0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 0x7c, 0x15, 0xbd, 0x04, 0x68, 0x29, 0x7a, 0x07, 
-    0x01, 0xdf, 0x7e, 0x47, 0x01, 0xe1, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xe1, 0x2e, 0x35, 0x46, 0x7a, 
-    0x35, 0x46, 0x22, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xe3, 0x80, 
-    0x2a, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0x2c, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0xd1, 0xd2, 0x04, 0x7e, 
-    0x07, 0x01, 0xe1, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 0xdf, 0x7e, 
-    0x44, 0x05, 0xe3, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd0, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 
-    0x04, 0x68, 0xce, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 0x25, 0x40, 0x02, 0x7d, 0x25, 0x7d, 0x32, 0x09, 
-    0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 0x01, 0x31, 0xda, 0xb8, 0x7e, 0x19, 0xb0, 0x7a, 
-    0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 0x02, 0x58, 0x9b, 0x75, 0x31, 0x99, 0x12, 0x7c, 
-    0x15, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3d, 0x0a, 0x09, 0xb1, 
-    0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x15, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 
-    0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x58, 0x9b, 0xda, 0xb8, 0x02, 0x59, 0xe8, 0x09, 0xb1, 
-    0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x31, 0x90, 0x12, 0x7c, 0x15, 0xf5, 0x31, 0x12, 0x7c, 0x15, 
-    0xa5, 0xfc, 0x5e, 0xb0, 0xf0, 0xa5, 0xfd, 0x09, 0xb1, 0x00, 0x18, 0x4c, 0x4b, 0x5e, 0xb0, 0xf0, 
-    0xbc, 0xb5, 0x78, 0xf1, 0x5e, 0x40, 0x0f, 0x4c, 0x54, 0x7c, 0xb5, 0x5e, 0x50, 0x0b, 0x68, 0x2a, 
-    0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 0x6d, 0x80, 0x02, 0xc2, 0x6d, 0xa5, 0xfd, 0x5e, 
-    0x50, 0x20, 0x68, 0x04, 0xd2, 0x65, 0x80, 0x02, 0xc2, 0x65, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 
-    0x04, 0xd2, 0x5d, 0x80, 0x02, 0xc2, 0x5d, 0x12, 0x43, 0x6d, 0x02, 0x62, 0x93, 0x75, 0x31, 0x91, 
-    0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x14, 0x7a, 0xb1, 0x31, 0x12, 0x7c, 0x15, 0x20, 0xe0, 0x08, 
-    0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x62, 0x93, 0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 
-    0x12, 0x62, 0x93, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 
-    0x61, 0x00, 0x00, 0x12, 0x62, 0xb6, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x58, 
-    0xed, 0x75, 0x31, 0x95, 0x12, 0x7c, 0x15, 0x22, 0x75, 0x31, 0x96, 0x12, 0x7c, 0x15, 0x22, 0x10, 
-    0x0e, 0x01, 0x22, 0x20, 0x2e, 0x03, 0xd2, 0x0e, 0x22, 0x75, 0x31, 0xa6, 0x12, 0x7c, 0x15, 0x7e, 
-    0x14, 0x86, 0x00, 0x80, 0x06, 0x20, 0x2e, 0x03, 0xd2, 0x0e, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 
-    0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x03, 0x12, 0x5d, 0x40, 0x20, 0xe6, 0x03, 0xd2, 0x0e, 
-    0x22, 0x30, 0x36, 0x49, 0xd2, 0x76, 0x7e, 0x37, 0x01, 0x9b, 0x7e, 0x27, 0x01, 0xbb, 0x9d, 0x32, 
-    0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 0x54, 0x7a, 0x05, 0x54, 0x7a, 0x37, 0x01, 0x9b, 0x7e, 0x37, 
-    0x01, 0x7b, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x25, 0xe2, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x7b, 
-    0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x12, 0x65, 0x2b, 0x10, 
-    0x76, 0xc4, 0x22, 0xc2, 0x76, 0x2d, 0x23, 0x68, 0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 
-    0x9b, 0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 0x27, 0x01, 0xbb, 0x28, 0x04, 0x7e, 0x27, 0x01, 
-    0xbb, 0x7e, 0x37, 0x01, 0x9b, 0x9d, 0x32, 0x7d, 0x02, 0x2e, 0x05, 0x54, 0x7a, 0x05, 0x54, 0x7a, 
-    0x37, 0x01, 0x9b, 0x7e, 0x37, 0x01, 0x7b, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x25, 0xe2, 0x38, 
-    0x13, 0x7a, 0x47, 0x01, 0x7b, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 
-    0x15, 0x02, 0x65, 0x2b, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 
-    0x9e, 0x44, 0x25, 0xe3, 0x9d, 0x24, 0x12, 0x65, 0x2b, 0x7e, 0x34, 0x21, 0xe3, 0x7d, 0x24, 0x2d, 
-    0x43, 0x7a, 0x47, 0x01, 0x7b, 0x12, 0x65, 0x2b, 0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x5a, 0x8f, 
-    0x22, 0xd2, 0x0e, 0x7e, 0x04, 0x21, 0xe3, 0x7a, 0x07, 0x01, 0x7b, 0x7a, 0x07, 0x01, 0x8b, 0x75, 
-    0x31, 0x94, 0x12, 0x7c, 0x15, 0x75, 0x31, 0x00, 0x12, 0x7c, 0x15, 0x22, 0x75, 0x31, 0x92, 0x12, 
-    0x7c, 0x15, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 
-    0x7e, 0x37, 0x01, 0xe1, 0x7e, 0x27, 0x01, 0xcb, 0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 
-    0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 0x46, 0x7a, 0x05, 0x46, 0x7a, 0x37, 0x01, 0xe1, 
-    0x7e, 0x37, 0x01, 0xdf, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x05, 0xe2, 0x38, 0x44, 0x7a, 0x47, 
-    0x01, 0xdf, 0x7e, 0x24, 0x06, 0x00, 0x2e, 0x27, 0x01, 0xcb, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 
-    0x51, 0x31, 0x12, 0x7c, 0x15, 0xbe, 0x50, 0x38, 0x78, 0x03, 0x02, 0x66, 0x16, 0x02, 0x65, 0xfb, 
-    0x75, 0x31, 0x99, 0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 
-    0x30, 0x3e, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x16, 0x22, 
-    0x80, 0x7d, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x9e, 0x44, 0x05, 0xe3, 0x9d, 0x24, 0x7e, 0x64, 
-    0x06, 0x00, 0x2e, 0x67, 0x01, 0xcb, 0x9e, 0x24, 0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 
-    0x35, 0x12, 0x65, 0xfb, 0x7e, 0x34, 0x01, 0xe3, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xdf, 
-    0x02, 0x65, 0xfb, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 0x01, 0xe3, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 
-    0x44, 0x80, 0xe5, 0x9d, 0x32, 0x7c, 0xb6, 0x54, 0x0f, 0x23, 0x23, 0x23, 0x44, 0x06, 0x7a, 0x69, 
-    0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x31, 0x93, 0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 
-    0x7c, 0x15, 0xbd, 0x04, 0x68, 0x29, 0x7a, 0x07, 0x01, 0xdf, 0x7e, 0x47, 0x01, 0xe1, 0x2d, 0x43, 
-    0x7a, 0x47, 0x01, 0xe1, 0x2e, 0x35, 0x46, 0x7a, 0x35, 0x46, 0x22, 0x09, 0xb1, 0x00, 0x14, 0x20, 
-    0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0x2a, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0x2c, 0x7e, 
-    0x04, 0x01, 0xe3, 0x80, 0xd1, 0xd2, 0x04, 0x7e, 0x07, 0x01, 0xe1, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 
-    0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 0xdf, 0x7e, 0x44, 0x05, 0xe3, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 
-    0x04, 0x68, 0xd0, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xce, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 
-    0x25, 0x40, 0x02, 0x7d, 0x25, 0x7d, 0x32, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 
-    0x01, 0x31, 0xda, 0xb8, 0x7e, 0x19, 0xb0, 0x7a, 0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 
-    0x02, 0x5b, 0xf3, 0x75, 0x31, 0x99, 0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 
-    0xb1, 0x00, 0x04, 0x30, 0x3e, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 
-    0xd2, 0x16, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x5b, 
-    0xf3, 0xda, 0xb8, 0x02, 0x5d, 0x40, 0x09, 0xb1, 0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x31, 0x90, 
-    0x12, 0x7c, 0x15, 0xf5, 0x31, 0x12, 0x7c, 0x15, 0xa5, 0xfc, 0x5e, 0xb0, 0xf0, 0xa5, 0xfd, 0x09, 
-    0xb1, 0x00, 0x18, 0x4c, 0x4b, 0x5e, 0xb0, 0xf0, 0xbc, 0xb5, 0x78, 0xf1, 0x5e, 0x40, 0x0f, 0x4c, 
-    0x54, 0x7c, 0xb5, 0x5e, 0x50, 0x0b, 0x68, 0x2a, 0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 
-    0x6e, 0x80, 0x02, 0xc2, 0x6e, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x66, 0x80, 0x02, 
-    0xc2, 0x66, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x5e, 0x80, 0x02, 0xc2, 0x5e, 0x12, 
-    0x43, 0x8e, 0x02, 0x62, 0x93, 0x75, 0x31, 0x91, 0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x14, 0x7a, 
-    0xb1, 0x31, 0x12, 0x7c, 0x15, 0x20, 0xe0, 0x08, 0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x62, 0x93, 
-    0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 0x12, 0x62, 0x93, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 
-    0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 0x61, 0x00, 0x00, 0x12, 0x62, 0xb6, 0x09, 0xb1, 
-    0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x5c, 0x45, 0x75, 0x31, 0x95, 0x12, 0x7c, 0x15, 0x22, 
-    0x75, 0x31, 0x96, 0x12, 0x7c, 0x15, 0x22, 0x10, 0x0f, 0x01, 0x22, 0x20, 0x2f, 0x03, 0xd2, 0x0f, 
-    0x22, 0x75, 0x31, 0xa7, 0x12, 0x7c, 0x15, 0x7e, 0x14, 0x87, 0x00, 0x80, 0x06, 0x20, 0x2f, 0x03, 
-    0xd2, 0x0f, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x03, 
-    0x12, 0x60, 0x98, 0x20, 0xe6, 0x03, 0xd2, 0x0f, 0x22, 0x30, 0x37, 0x49, 0xd2, 0x77, 0x7e, 0x37, 
-    0x01, 0x9d, 0x7e, 0x27, 0x01, 0xbd, 0x9d, 0x32, 0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 0x56, 0x7a, 
-    0x05, 0x56, 0x7a, 0x37, 0x01, 0x9d, 0x7e, 0x37, 0x01, 0x7d, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 
-    0x29, 0xe2, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x7d, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x7a, 0x51, 
-    0x31, 0x12, 0x7c, 0x15, 0x12, 0x65, 0x2b, 0x10, 0x77, 0xc4, 0x22, 0xc2, 0x77, 0x2d, 0x23, 0x68, 
-    0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 0x9d, 0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 
-    0x27, 0x01, 0xbd, 0x28, 0x04, 0x7e, 0x27, 0x01, 0xbd, 0x7e, 0x37, 0x01, 0x9d, 0x9d, 0x32, 0x7d, 
-    0x02, 0x2e, 0x05, 0x56, 0x7a, 0x05, 0x56, 0x7a, 0x37, 0x01, 0x9d, 0x7e, 0x37, 0x01, 0x7d, 0x7d, 
-    0x43, 0x2d, 0x42, 0xbe, 0x44, 0x29, 0xe2, 0x38, 0x13, 0x7a, 0x47, 0x01, 0x7d, 0x75, 0x31, 0x94, 
-    0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x02, 0x65, 0x2b, 0x75, 0x31, 0x94, 0x12, 
-    0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x9e, 0x44, 0x29, 0xe3, 0x9d, 0x24, 0x12, 0x65, 
-    0x2b, 0x7e, 0x34, 0x25, 0xe3, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0x7d, 0x12, 0x65, 0x2b, 
-    0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x5d, 0xe7, 0x22, 0xd2, 0x0f, 0x7e, 0x04, 0x25, 0xe3, 0x7a, 
-    0x07, 0x01, 0x7d, 0x7a, 0x07, 0x01, 0x8d, 0x75, 0x31, 0x94, 0x12, 0x7c, 0x15, 0x75, 0x31, 0x00, 
-    0x12, 0x7c, 0x15, 0x22, 0x75, 0x31, 0x92, 0x12, 0x7c, 0x15, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 
-    0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 0x7e, 0x37, 0x01, 0xe1, 0x7e, 0x27, 0x01, 0xcd, 
-    0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 
-    0x46, 0x7a, 0x05, 0x46, 0x7a, 0x37, 0x01, 0xe1, 0x7e, 0x37, 0x01, 0xdf, 0x7d, 0x43, 0x2d, 0x42, 
-    0xbe, 0x44, 0x05, 0xe2, 0x38, 0x44, 0x7a, 0x47, 0x01, 0xdf, 0x7e, 0x24, 0x07, 0x00, 0x2e, 0x27, 
-    0x01, 0xcd, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0xbe, 0x50, 0x38, 
-    0x78, 0x03, 0x02, 0x66, 0x16, 0x02, 0x65, 0xfb, 0x75, 0x31, 0x99, 0x12, 0x7c, 0x15, 0x09, 0xb1, 
-    0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3f, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 
-    0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x17, 0x22, 0x80, 0x7d, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 
-    0x9e, 0x44, 0x05, 0xe3, 0x9d, 0x24, 0x7e, 0x64, 0x07, 0x00, 0x2e, 0x67, 0x01, 0xcd, 0x9e, 0x24, 
-    0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 0x35, 0x12, 0x65, 0xfb, 0x7e, 0x34, 0x01, 0xe3, 
-    0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xdf, 0x02, 0x65, 0xfb, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 
-    0x01, 0xe3, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 0x44, 0x80, 0xe5, 0x9d, 0x32, 0x7c, 0xb6, 0x54, 
-    0x0f, 0x23, 0x23, 0x23, 0x44, 0x07, 0x7a, 0x69, 0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x31, 
-    0x93, 0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 0x7c, 0x15, 0xbd, 0x04, 0x68, 0x29, 0x7a, 0x07, 
-    0x01, 0xdf, 0x7e, 0x47, 0x01, 0xe1, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xe1, 0x2e, 0x35, 0x46, 0x7a, 
-    0x35, 0x46, 0x22, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xe3, 0x80, 
-    0x2a, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0x2c, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0xd1, 0xd2, 0x04, 0x7e, 
-    0x07, 0x01, 0xe1, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 0xdf, 0x7e, 
-    0x44, 0x05, 0xe3, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd0, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 
-    0x04, 0x68, 0xce, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 0x25, 0x40, 0x02, 0x7d, 0x25, 0x7d, 0x32, 0x09, 
-    0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 0x01, 0x31, 0xda, 0xb8, 0x7e, 0x19, 0xb0, 0x7a, 
-    0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 0x02, 0x5f, 0x4b, 0x75, 0x31, 0x99, 0x12, 0x7c, 
-    0x15, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3f, 0x0a, 0x09, 0xb1, 
-    0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x17, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 
-    0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x5f, 0x4b, 0xda, 0xb8, 0x02, 0x60, 0x98, 0x09, 0xb1, 
-    0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x31, 0x90, 0x12, 0x7c, 0x15, 0xf5, 0x31, 0x12, 0x7c, 0x15, 
-    0xa5, 0xfc, 0x5e, 0xb0, 0xf0, 0xa5, 0xfd, 0x09, 0xb1, 0x00, 0x18, 0x4c, 0x4b, 0x5e, 0xb0, 0xf0, 
-    0xbc, 0xb5, 0x78, 0xf1, 0x5e, 0x40, 0x0f, 0x4c, 0x54, 0x7c, 0xb5, 0x5e, 0x50, 0x0b, 0x68, 0x2a, 
-    0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 0x6f, 0x80, 0x02, 0xc2, 0x6f, 0xa5, 0xfd, 0x5e, 
-    0x50, 0x20, 0x68, 0x04, 0xd2, 0x67, 0x80, 0x02, 0xc2, 0x67, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 
-    0x04, 0xd2, 0x5f, 0x80, 0x02, 0xc2, 0x5f, 0x12, 0x43, 0xaf, 0x02, 0x62, 0x93, 0x75, 0x31, 0x91, 
-    0x12, 0x7c, 0x15, 0x09, 0xb1, 0x00, 0x14, 0x7a, 0xb1, 0x31, 0x12, 0x7c, 0x15, 0x20, 0xe0, 0x08, 
-    0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x62, 0x93, 0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 
-    0x12, 0x62, 0x93, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 
-    0x61, 0x00, 0x00, 0x12, 0x62, 0xb6, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x5f, 
-    0x9d, 0x75, 0x31, 0x95, 0x12, 0x7c, 0x15, 0x22, 0x75, 0x31, 0x96, 0x12, 0x7c, 0x15, 0x22, 0x7c, 
-    0x02, 0x7e, 0x14, 0x80, 0x00, 0x4c, 0x20, 0x09, 0xb1, 0x00, 0x18, 0xa5, 0xfd, 0x5e, 0x50, 0x10, 
-    0x68, 0x04, 0xd2, 0x68, 0x80, 0x02, 0xc2, 0x68, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 
-    0x60, 0x80, 0x02, 0xc2, 0x60, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x58, 0x80, 0x02, 
-    0xc2, 0x58, 0x02, 0x62, 0x7f, 0x7c, 0x02, 0x7e, 0x14, 0x80, 0x00, 0x4c, 0x20, 0x09, 0xb1, 0x00, 
-    0x18, 0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 0x69, 0x80, 0x02, 0xc2, 0x69, 0xa5, 0xfd, 
-    0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x61, 0x80, 0x02, 0xc2, 0x61, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 
-    0x68, 0x04, 0xd2, 0x59, 0x80, 0x02, 0xc2, 0x59, 0x02, 0x62, 0x7f, 0x7c, 0x02, 0x7e, 0x14, 0x80, 
-    0x00, 0x4c, 0x20, 0x09, 0xb1, 0x00, 0x18, 0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 0x6a, 
-    0x80, 0x02, 0xc2, 0x6a, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x62, 0x80, 0x02, 0xc2, 
-    0x62, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x5a, 0x80, 0x02, 0xc2, 0x5a, 0x02, 0x62, 
-    0x7f, 0x7c, 0x02, 0x7e, 0x14, 0x80, 0x00, 0x4c, 0x20, 0x09, 0xb1, 0x00, 0x18, 0xa5, 0xfd, 0x5e, 
-    0x50, 0x10, 0x68, 0x04, 0xd2, 0x6b, 0x80, 0x02, 0xc2, 0x6b, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 
-    0x04, 0xd2, 0x63, 0x80, 0x02, 0xc2, 0x63, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x5b, 
-    0x80, 0x02, 0xc2, 0x5b, 0x02, 0x62, 0x7f, 0x7c, 0x02, 0x7e, 0x14, 0x80, 0x00, 0x4c, 0x20, 0x09, 
-    0xb1, 0x00, 0x18, 0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 0x6c, 0x80, 0x02, 0xc2, 0x6c, 
-    0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x64, 0x80, 0x02, 0xc2, 0x64, 0xa5, 0xfd, 0x5e, 
-    0x50, 0x80, 0x68, 0x04, 0xd2, 0x5c, 0x80, 0x02, 0xc2, 0x5c, 0x02, 0x62, 0x7f, 0x7c, 0x02, 0x7e, 
-    0x14, 0x80, 0x00, 0x4c, 0x20, 0x09, 0xb1, 0x00, 0x18, 0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 
-    0xd2, 0x6d, 0x80, 0x02, 0xc2, 0x6d, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x65, 0x80, 
-    0x02, 0xc2, 0x65, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x5d, 0x80, 0x02, 0xc2, 0x5d, 
-    0x02, 0x62, 0x7f, 0x7c, 0x02, 0x7e, 0x14, 0x80, 0x00, 0x4c, 0x20, 0x09, 0xb1, 0x00, 0x18, 0xa5, 
-    0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 0x6e, 0x80, 0x02, 0xc2, 0x6e, 0xa5, 0xfd, 0x5e, 0x50, 
-    0x20, 0x68, 0x04, 0xd2, 0x66, 0x80, 0x02, 0xc2, 0x66, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 
-    0xd2, 0x5e, 0x80, 0x02, 0xc2, 0x5e, 0x02, 0x62, 0x7f, 0x7c, 0x02, 0x7e, 0x14, 0x80, 0x00, 0x4c, 
-    0x20, 0x09, 0xb1, 0x00, 0x18, 0xa5, 0xfd, 0x5e, 0x50, 0x10, 0x68, 0x04, 0xd2, 0x6f, 0x80, 0x02, 
-    0xc2, 0x6f, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x67, 0x80, 0x02, 0xc2, 0x67, 0xa5, 
-    0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x5f, 0x80, 0x02, 0xc2, 0x5f, 0x02, 0x62, 0x7f, 0x54, 
-    0xf0, 0xc4, 0xa5, 0xff, 0xc4, 0xa5, 0x4f, 0x75, 0x31, 0x90, 0x12, 0x7c, 0x15, 0xf5, 0x31, 0x12, 
-    0x7c, 0x15, 0x22, 0xca, 0x19, 0x5e, 0x20, 0x07, 0x4c, 0xa2, 0x7e, 0x74, 0x29, 0xe3, 0xca, 0x79, 
-    0x7a, 0x79, 0xa0, 0x0b, 0x74, 0x7a, 0x79, 0xb0, 0x0b, 0x74, 0xda, 0x79, 0x7e, 0x30, 0x02, 0x7e, 
-    0x64, 0x00, 0x02, 0x02, 0x62, 0xde, 0xca, 0x19, 0x5e, 0x20, 0x07, 0x4c, 0xa2, 0x7e, 0x74, 0x29, 
-    0xe3, 0xca, 0x79, 0x7a, 0x79, 0xa0, 0x0b, 0x74, 0x7a, 0x79, 0xb0, 0x0b, 0x74, 0x7a, 0x79, 0x60, 
-    0x0b, 0x74, 0xda, 0x79, 0x7e, 0x30, 0x03, 0x7e, 0x64, 0x00, 0x03, 0x02, 0x62, 0xde, 0xd2, 0x04, 
-    0x7e, 0x27, 0x01, 0xe1, 0x2d, 0x26, 0xbe, 0x24, 0x04, 0x00, 0x38, 0x2e, 0x7e, 0x07, 0x01, 0xdf, 
-    0x7e, 0x44, 0x05, 0xe3, 0x7e, 0x79, 0xa0, 0x7a, 0x09, 0xa0, 0x0b, 0x04, 0x0b, 0x74, 0xbd, 0x04, 
-    0x68, 0x23, 0xa5, 0xdb, 0xef, 0x7a, 0x27, 0x01, 0xe1, 0x7e, 0x25, 0x46, 0x2d, 0x26, 0x7a, 0x25, 
-    0x46, 0x7a, 0x07, 0x01, 0xdf, 0xda, 0x19, 0xc2, 0xd7, 0x22, 0x75, 0x31, 0x9a, 0x12, 0x7c, 0x15, 
-    0xda, 0x19, 0xd2, 0xd7, 0x22, 0x7e, 0x04, 0x01, 0xe3, 0x80, 0xd7, 0x48, 0xb6, 0x46, 0x25, 0x47, 
-    0x1c, 0x49, 0x15, 0x44, 0xc6, 0x44, 0xc6, 0x48, 0x1b, 0x44, 0xc6, 0x49, 0x59, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x49, 0x60, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x4c, 0x0e, 0x49, 0x7d, 0x4a, 
-    0x74, 0x4c, 0x6d, 0x44, 0xc6, 0x44, 0xc6, 0x4b, 0x73, 0x44, 0xc6, 0x4c, 0xb1, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x4c, 0xb8, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x4f, 0x66, 0x4c, 0xd5, 0x4d, 
-    0xcc, 0x4f, 0xc5, 0x44, 0xc6, 0x44, 0xc6, 0x4e, 0xcb, 0x44, 0xc6, 0x50, 0x09, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x50, 0x10, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x52, 0xbe, 0x50, 0x2d, 0x51, 
-    0x24, 0x53, 0x1d, 0x44, 0xc6, 0x44, 0xc6, 0x52, 0x23, 0x44, 0xc6, 0x53, 0x61, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x53, 0x68, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x56, 0x16, 0x53, 0x85, 0x54, 
-    0x7c, 0x56, 0x75, 0x44, 0xc6, 0x44, 0xc6, 0x55, 0x7b, 0x44, 0xc6, 0x56, 0xb9, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x56, 0xc0, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x59, 0x6e, 0x56, 0xdd, 0x57, 
-    0xd4, 0x59, 0xcd, 0x44, 0xc6, 0x44, 0xc6, 0x58, 0xd3, 0x44, 0xc6, 0x5a, 0x11, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x5a, 0x18, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x5c, 0xc6, 0x5a, 0x35, 0x5b, 
-    0x2c, 0x5d, 0x25, 0x44, 0xc6, 0x44, 0xc6, 0x5c, 0x2b, 0x44, 0xc6, 0x5d, 0x69, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x5d, 0x70, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x60, 0x1e, 0x5d, 0x8d, 0x5e, 
-    0x84, 0x60, 0x7d, 0x44, 0xc6, 0x44, 0xc6, 0x5f, 0x83, 0x44, 0xc6, 0x60, 0xc1, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x60, 0xc8, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 
-    0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0x44, 0xc6, 0xca, 0x29, 0x1e, 0x50, 0x40, 
-    0x0d, 0x7e, 0x54, 0x0b, 0x10, 0x9c, 0xb5, 0xa4, 0x2e, 0x54, 0x65, 0x48, 0x89, 0x54, 0x7e, 0x39, 
-    0x00, 0x7a, 0x19, 0x00, 0x0b, 0x34, 0x80, 0xe9, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 
+    0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x15, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 0xbd, 0x32, 0x68, 
+    0x07, 0xca, 0xb8, 0x12, 0x5c, 0x78, 0xda, 0xb8, 0x02, 0x5d, 0x9f, 0x09, 0xb1, 0x00, 0x18, 0x7e, 
+    0xa0, 0x88, 0x75, 0x2f, 0x90, 0x12, 0x7e, 0x30, 0xf5, 0x2f, 0x12, 0x7e, 0x30, 0xa5, 0xfd, 0x5e, 
+    0x50, 0x0a, 0x68, 0x1d, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x5d, 0x80, 0x02, 0xc2, 
+    0x5d, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x55, 0x80, 0x02, 0xc2, 0x55, 0x12, 0x43, 
+    0x1f, 0x02, 0x65, 0x9c, 0x75, 0x2f, 0x91, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x14, 0x7a, 0xb1, 
+    0x2f, 0x12, 0x7e, 0x30, 0x20, 0xe0, 0x08, 0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x65, 0x9c, 0xd2, 
+    0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 0x12, 0x65, 0x9c, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 0xda, 
+    0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 0x61, 0x00, 0x00, 0x12, 0x65, 0xbf, 0x09, 0xb1, 0x00, 
+    0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x5c, 0xcc, 0x75, 0x2f, 0x95, 0x12, 0x7e, 0x30, 0x22, 0x75, 
+    0x2f, 0x96, 0x12, 0x7e, 0x30, 0x22, 0x10, 0x0e, 0x01, 0x22, 0x20, 0x2e, 0x03, 0xd2, 0x0e, 0x22, 
+    0x75, 0x2f, 0xa6, 0x12, 0x7e, 0x30, 0x7e, 0x14, 0x86, 0x00, 0x80, 0x06, 0x20, 0x2e, 0x03, 0xd2, 
+    0x0e, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 0xda, 0xb8, 0x68, 0x03, 0x12, 
+    0x60, 0xd4, 0x30, 0x36, 0x06, 0x20, 0xe6, 0x4f, 0xd2, 0x0e, 0x22, 0x30, 0xe6, 0x02, 0xd2, 0x66, 
+    0x7e, 0x37, 0x01, 0x85, 0x7e, 0x27, 0x01, 0xa5, 0x9d, 0x32, 0x40, 0x31, 0x7d, 0x02, 0x2e, 0x05, 
+    0x3e, 0x7a, 0x05, 0x3e, 0x7a, 0x37, 0x01, 0x85, 0x7e, 0x37, 0x01, 0x65, 0x7d, 0x43, 0x2d, 0x42, 
+    0xbe, 0x44, 0x25, 0xcc, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x65, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 
+    0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x12, 0x68, 0x34, 0x10, 0x66, 0xc4, 0x22, 0xc2, 0x66, 0x2d, 
+    0x23, 0x68, 0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 0x85, 0xbe, 0x24, 0x00, 0x00, 0x68, 
+    0x6a, 0xbe, 0x27, 0x01, 0xa5, 0x28, 0x04, 0x7e, 0x27, 0x01, 0xa5, 0x7e, 0x37, 0x01, 0x85, 0x9d, 
+    0x32, 0x7d, 0x02, 0x2e, 0x05, 0x3e, 0x7a, 0x05, 0x3e, 0x7a, 0x37, 0x01, 0x85, 0x7e, 0x37, 0x01, 
+    0x65, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x25, 0xcc, 0x38, 0x13, 0x7a, 0x47, 0x01, 0x65, 0x75, 
+    0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x02, 0x68, 0x34, 0x75, 0x2f, 
+    0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x9e, 0x44, 0x25, 0xcd, 0x9d, 0x24, 
+    0x12, 0x68, 0x34, 0x7e, 0x34, 0x21, 0xcd, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0x65, 0x12, 
+    0x68, 0x34, 0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x5e, 0x49, 0x22, 0xd2, 0x0e, 0x7e, 0x04, 0x21, 
+    0xcd, 0x7a, 0x07, 0x01, 0x65, 0x7a, 0x07, 0x01, 0x75, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x75, 
+    0x2f, 0x00, 0x12, 0x7e, 0x30, 0x22, 0x75, 0x2f, 0x92, 0x12, 0x7e, 0x30, 0xd2, 0x04, 0x09, 0xb1, 
+    0x00, 0x14, 0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 0x7e, 0x37, 0x01, 0xcb, 0x7e, 0x27, 
+    0x01, 0xb5, 0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 0x04, 0x00, 0x38, 0x3c, 0x7d, 0x02, 
+    0x2e, 0x05, 0x30, 0x7a, 0x05, 0x30, 0x7a, 0x37, 0x01, 0xcb, 0x7e, 0x37, 0x01, 0xc9, 0x7d, 0x43, 
+    0x2d, 0x42, 0xbe, 0x44, 0x05, 0xcc, 0x38, 0x44, 0x7a, 0x47, 0x01, 0xc9, 0x7e, 0x24, 0x06, 0x00, 
+    0x2e, 0x27, 0x01, 0xb5, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0xbe, 
+    0x50, 0x38, 0x78, 0x03, 0x02, 0x69, 0x1f, 0x02, 0x69, 0x04, 0x75, 0x2f, 0x99, 0x12, 0x7e, 0x30, 
+    0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3e, 0x0a, 0x09, 0xb1, 0x00, 
+    0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x16, 0x22, 0x80, 0x7f, 0x7a, 0x51, 0x2f, 0x12, 
+    0x7e, 0x30, 0x9e, 0x44, 0x05, 0xcd, 0x9d, 0x24, 0x7e, 0x64, 0x06, 0x00, 0x2e, 0x67, 0x01, 0xb5, 
+    0x9e, 0x24, 0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 0x35, 0x12, 0x69, 0x04, 0x7e, 0x34, 
+    0x01, 0xcd, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xc9, 0x02, 0x69, 0x04, 0x7a, 0x39, 0xc0, 
+    0x7e, 0x34, 0x01, 0xcd, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 0x44, 0x80, 0xe5, 0x9d, 0x32, 0x7c, 
+    0xb6, 0x54, 0x0f, 0x23, 0x23, 0x23, 0x44, 0x06, 0x7a, 0x69, 0xb0, 0x7a, 0x79, 0x70, 0x0b, 0x35, 
+    0x75, 0x2f, 0x93, 0x12, 0x7e, 0x30, 0x7a, 0x71, 0x2f, 0x12, 0x7e, 0x30, 0xbd, 0x04, 0x68, 0x2b, 
+    0x7a, 0x07, 0x01, 0xc9, 0x7e, 0x47, 0x01, 0xcb, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xcb, 0x2e, 0x35, 
+    0x30, 0x7a, 0x35, 0x30, 0x22, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0x13, 0x22, 0x7e, 
+    0x04, 0x01, 0xcd, 0x80, 0x28, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0x2a, 0x7e, 0x04, 0x01, 0xcd, 0x80, 
+    0xcf, 0x7e, 0x07, 0x01, 0xcb, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 0x20, 0x28, 0x40, 0x7e, 0x07, 0x01, 
+    0xc9, 0x7e, 0x44, 0x05, 0xcd, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd2, 0x7d, 0x70, 0x0b, 
+    0x04, 0xbd, 0x04, 0x68, 0xd0, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 0x25, 0x40, 0x02, 0x7d, 0x25, 0x7d, 
+    0x32, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 0x01, 0x31, 0xda, 0xb8, 0x7e, 0x19, 
+    0xb0, 0x7a, 0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 0x02, 0x5f, 0xad, 0x75, 0x2f, 0x99, 
+    0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 0x3e, 0x0a, 
+    0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x16, 0x22, 0xda, 0xb8, 0x30, 
+    0xe0, 0xd8, 0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x5f, 0xad, 0xda, 0xb8, 0x02, 0x60, 0xd4, 
+    0x09, 0xb1, 0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x2f, 0x90, 0x12, 0x7e, 0x30, 0xf5, 0x2f, 0x12, 
+    0x7e, 0x30, 0xa5, 0xfd, 0x5e, 0x50, 0x0a, 0x68, 0x1d, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 
+    0xd2, 0x5e, 0x80, 0x02, 0xc2, 0x5e, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x56, 0x80, 
+    0x02, 0xc2, 0x56, 0x12, 0x43, 0x36, 0x02, 0x65, 0x9c, 0x75, 0x2f, 0x91, 0x12, 0x7e, 0x30, 0x09, 
+    0xb1, 0x00, 0x14, 0x7a, 0xb1, 0x2f, 0x12, 0x7e, 0x30, 0x20, 0xe0, 0x08, 0xd2, 0x04, 0x7e, 0xa0, 
+    0x80, 0x02, 0x65, 0x9c, 0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 0x80, 0x12, 0x65, 0x9c, 0xca, 
+    0xb8, 0x5e, 0xb0, 0x1c, 0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 0x09, 0x61, 0x00, 0x00, 0x12, 
+    0x65, 0xbf, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 0x60, 0x01, 0x75, 0x2f, 0x95, 
+    0x12, 0x7e, 0x30, 0x22, 0x75, 0x2f, 0x96, 0x12, 0x7e, 0x30, 0x22, 0x10, 0x0f, 0x01, 0x22, 0x20, 
+    0x2f, 0x03, 0xd2, 0x0f, 0x22, 0x75, 0x2f, 0xa7, 0x12, 0x7e, 0x30, 0x7e, 0x14, 0x87, 0x00, 0x80, 
+    0x06, 0x20, 0x2f, 0x03, 0xd2, 0x0f, 0x22, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x5e, 0xb0, 0x1e, 
+    0xda, 0xb8, 0x68, 0x03, 0x12, 0x64, 0x09, 0x30, 0x37, 0x06, 0x20, 0xe6, 0x4f, 0xd2, 0x0f, 0x22, 
+    0x30, 0xe6, 0x02, 0xd2, 0x67, 0x7e, 0x37, 0x01, 0x87, 0x7e, 0x27, 0x01, 0xa7, 0x9d, 0x32, 0x40, 
+    0x31, 0x7d, 0x02, 0x2e, 0x05, 0x40, 0x7a, 0x05, 0x40, 0x7a, 0x37, 0x01, 0x87, 0x7e, 0x37, 0x01, 
+    0x67, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x29, 0xcc, 0x38, 0x68, 0x7a, 0x47, 0x01, 0x67, 0x75, 
+    0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x12, 0x68, 0x34, 0x10, 0x67, 
+    0xc4, 0x22, 0xc2, 0x67, 0x2d, 0x23, 0x68, 0x78, 0x6d, 0x33, 0x80, 0x1a, 0x7e, 0x27, 0x01, 0x87, 
+    0xbe, 0x24, 0x00, 0x00, 0x68, 0x6a, 0xbe, 0x27, 0x01, 0xa7, 0x28, 0x04, 0x7e, 0x27, 0x01, 0xa7, 
+    0x7e, 0x37, 0x01, 0x87, 0x9d, 0x32, 0x7d, 0x02, 0x2e, 0x05, 0x40, 0x7a, 0x05, 0x40, 0x7a, 0x37, 
+    0x01, 0x87, 0x7e, 0x37, 0x01, 0x67, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x29, 0xcc, 0x38, 0x13, 
+    0x7a, 0x47, 0x01, 0x67, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 
+    0x02, 0x68, 0x34, 0x75, 0x2f, 0x94, 0x12, 0x7e, 0x30, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x9e, 
+    0x44, 0x29, 0xcd, 0x9d, 0x24, 0x12, 0x68, 0x34, 0x7e, 0x34, 0x25, 0xcd, 0x7d, 0x24, 0x2d, 0x43, 
+    0x7a, 0x47, 0x01, 0x67, 0x12, 0x68, 0x34, 0xbe, 0x25, 0x20, 0x78, 0x03, 0x02, 0x61, 0x7e, 0x22, 
+    0xd2, 0x0f, 0x7e, 0x04, 0x25, 0xcd, 0x7a, 0x07, 0x01, 0x67, 0x7a, 0x07, 0x01, 0x77, 0x75, 0x2f, 
+    0x94, 0x12, 0x7e, 0x30, 0x75, 0x2f, 0x00, 0x12, 0x7e, 0x30, 0x22, 0x75, 0x2f, 0x92, 0x12, 0x7e, 
+    0x30, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x82, 0xda, 0xb8, 0x78, 0x70, 0x7e, 
+    0x37, 0x01, 0xcb, 0x7e, 0x27, 0x01, 0xb7, 0x2e, 0x24, 0x00, 0x02, 0x2d, 0x32, 0xbe, 0x34, 0x04, 
+    0x00, 0x38, 0x3c, 0x7d, 0x02, 0x2e, 0x05, 0x30, 0x7a, 0x05, 0x30, 0x7a, 0x37, 0x01, 0xcb, 0x7e, 
+    0x37, 0x01, 0xc9, 0x7d, 0x43, 0x2d, 0x42, 0xbe, 0x44, 0x05, 0xcc, 0x38, 0x44, 0x7a, 0x47, 0x01, 
+    0xc9, 0x7e, 0x24, 0x07, 0x00, 0x2e, 0x27, 0x01, 0xb7, 0x1b, 0x38, 0x20, 0x0b, 0x35, 0x7a, 0x51, 
+    0x2f, 0x12, 0x7e, 0x30, 0xbe, 0x50, 0x38, 0x78, 0x03, 0x02, 0x69, 0x1f, 0x02, 0x69, 0x04, 0x75, 
+    0x2f, 0x99, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 0x00, 0x04, 0x30, 
+    0x3f, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 0x17, 0x22, 0x80, 
+    0x7f, 0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x9e, 0x44, 0x05, 0xcd, 0x9d, 0x24, 0x7e, 0x64, 0x07, 
+    0x00, 0x2e, 0x67, 0x01, 0xb7, 0x9e, 0x24, 0x00, 0x02, 0x40, 0x17, 0x1b, 0x38, 0x60, 0x0b, 0x35, 
+    0x12, 0x69, 0x04, 0x7e, 0x34, 0x01, 0xcd, 0x7d, 0x24, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xc9, 0x02, 
+    0x69, 0x04, 0x7a, 0x39, 0xc0, 0x7e, 0x34, 0x01, 0xcd, 0x7a, 0x39, 0xd0, 0x0b, 0x34, 0x1b, 0x44, 
+    0x80, 0xe5, 0x9d, 0x32, 0x7c, 0xb6, 0x54, 0x0f, 0x23, 0x23, 0x23, 0x44, 0x07, 0x7a, 0x69, 0xb0, 
+    0x7a, 0x79, 0x70, 0x0b, 0x35, 0x75, 0x2f, 0x93, 0x12, 0x7e, 0x30, 0x7a, 0x71, 0x2f, 0x12, 0x7e, 
+    0x30, 0xbd, 0x04, 0x68, 0x2b, 0x7a, 0x07, 0x01, 0xc9, 0x7e, 0x47, 0x01, 0xcb, 0x2d, 0x43, 0x7a, 
+    0x47, 0x01, 0xcb, 0x2e, 0x35, 0x30, 0x7a, 0x35, 0x30, 0x22, 0xd2, 0x04, 0x09, 0xb1, 0x00, 0x14, 
+    0x20, 0xe0, 0x13, 0x22, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0x28, 0x7e, 0x04, 0x01, 0xcd, 0x80, 0x2a, 
+    0x7e, 0x04, 0x01, 0xcd, 0x80, 0xcf, 0x7e, 0x07, 0x01, 0xcb, 0x7e, 0x24, 0x03, 0xfe, 0x9d, 0x20, 
+    0x28, 0x40, 0x7e, 0x07, 0x01, 0xc9, 0x7e, 0x44, 0x05, 0xcd, 0x7d, 0x60, 0x0b, 0x04, 0xbd, 0x04, 
+    0x68, 0xd2, 0x7d, 0x70, 0x0b, 0x04, 0xbd, 0x04, 0x68, 0xd0, 0x7d, 0x54, 0x9d, 0x50, 0xbd, 0x25, 
+    0x40, 0x02, 0x7d, 0x25, 0x7d, 0x32, 0x09, 0xb1, 0x00, 0x14, 0xca, 0xb8, 0x54, 0x1f, 0xb4, 0x01, 
+    0x31, 0xda, 0xb8, 0x7e, 0x19, 0xb0, 0x7a, 0x09, 0xb0, 0x0b, 0x04, 0x1b, 0x24, 0x78, 0xe7, 0x02, 
+    0x62, 0xe2, 0x75, 0x2f, 0x99, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x04, 0x54, 0xfa, 0x19, 0xb1, 
+    0x00, 0x04, 0x30, 0x3f, 0x0a, 0x09, 0xb1, 0x00, 0x10, 0x54, 0xfe, 0x19, 0xb1, 0x00, 0x10, 0xd2, 
+    0x17, 0x22, 0xda, 0xb8, 0x30, 0xe0, 0xd8, 0xbd, 0x32, 0x68, 0x07, 0xca, 0xb8, 0x12, 0x62, 0xe2, 
+    0xda, 0xb8, 0x02, 0x64, 0x09, 0x09, 0xb1, 0x00, 0x18, 0x7e, 0xa0, 0x88, 0x75, 0x2f, 0x90, 0x12, 
+    0x7e, 0x30, 0xf5, 0x2f, 0x12, 0x7e, 0x30, 0xa5, 0xfd, 0x5e, 0x50, 0x0a, 0x68, 0x1d, 0xa5, 0xfd, 
+    0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x5f, 0x80, 0x02, 0xc2, 0x5f, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 
+    0x68, 0x04, 0xd2, 0x57, 0x80, 0x02, 0xc2, 0x57, 0x12, 0x43, 0x4d, 0x02, 0x65, 0x9c, 0x75, 0x2f, 
+    0x91, 0x12, 0x7e, 0x30, 0x09, 0xb1, 0x00, 0x14, 0x7a, 0xb1, 0x2f, 0x12, 0x7e, 0x30, 0x20, 0xe0, 
+    0x08, 0xd2, 0x04, 0x7e, 0xa0, 0x80, 0x02, 0x65, 0x9c, 0xd2, 0x04, 0x30, 0xe1, 0x06, 0x7e, 0xa0, 
+    0x80, 0x12, 0x65, 0x9c, 0xca, 0xb8, 0x5e, 0xb0, 0x1c, 0xda, 0xb8, 0x68, 0x12, 0x7e, 0xa0, 0xc0, 
+    0x09, 0x61, 0x00, 0x00, 0x12, 0x65, 0xbf, 0x09, 0xb1, 0x00, 0x14, 0x20, 0xe0, 0xdb, 0x22, 0x02, 
+    0x63, 0x36, 0x75, 0x2f, 0x95, 0x12, 0x7e, 0x30, 0x22, 0x75, 0x2f, 0x96, 0x12, 0x7e, 0x30, 0x22, 
+    0x7c, 0x02, 0x7e, 0x14, 0x80, 0x00, 0x4c, 0x20, 0x09, 0xb1, 0x00, 0x18, 0xa5, 0xfd, 0x5e, 0x50, 
+    0x20, 0x68, 0x04, 0xd2, 0x58, 0x80, 0x02, 0xc2, 0x58, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 
+    0xd2, 0x50, 0x80, 0x02, 0xc2, 0x50, 0x02, 0x65, 0x88, 0x7c, 0x02, 0x7e, 0x14, 0x80, 0x00, 0x4c, 
+    0x20, 0x09, 0xb1, 0x00, 0x18, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x59, 0x80, 0x02, 
+    0xc2, 0x59, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x51, 0x80, 0x02, 0xc2, 0x51, 0x02, 
+    0x65, 0x88, 0x7c, 0x02, 0x7e, 0x14, 0x80, 0x00, 0x4c, 0x20, 0x09, 0xb1, 0x00, 0x18, 0xa5, 0xfd, 
+    0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x5a, 0x80, 0x02, 0xc2, 0x5a, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 
+    0x68, 0x04, 0xd2, 0x52, 0x80, 0x02, 0xc2, 0x52, 0x02, 0x65, 0x88, 0x7c, 0x02, 0x7e, 0x14, 0x80, 
+    0x00, 0x4c, 0x20, 0x09, 0xb1, 0x00, 0x18, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x5b, 
+    0x80, 0x02, 0xc2, 0x5b, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x53, 0x80, 0x02, 0xc2, 
+    0x53, 0x02, 0x65, 0x88, 0x7c, 0x02, 0x7e, 0x14, 0x80, 0x00, 0x4c, 0x20, 0x09, 0xb1, 0x00, 0x18, 
+    0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x5c, 0x80, 0x02, 0xc2, 0x5c, 0xa5, 0xfd, 0x5e, 
+    0x50, 0x80, 0x68, 0x04, 0xd2, 0x54, 0x80, 0x02, 0xc2, 0x54, 0x02, 0x65, 0x88, 0x7c, 0x02, 0x7e, 
+    0x14, 0x80, 0x00, 0x4c, 0x20, 0x09, 0xb1, 0x00, 0x18, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 
+    0xd2, 0x5d, 0x80, 0x02, 0xc2, 0x5d, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x55, 0x80, 
+    0x02, 0xc2, 0x55, 0x02, 0x65, 0x88, 0x7c, 0x02, 0x7e, 0x14, 0x80, 0x00, 0x4c, 0x20, 0x09, 0xb1, 
+    0x00, 0x18, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 0x68, 0x04, 0xd2, 0x5e, 0x80, 0x02, 0xc2, 0x5e, 0xa5, 
+    0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 0x56, 0x80, 0x02, 0xc2, 0x56, 0x02, 0x65, 0x88, 0x7c, 
+    0x02, 0x7e, 0x14, 0x80, 0x00, 0x4c, 0x20, 0x09, 0xb1, 0x00, 0x18, 0xa5, 0xfd, 0x5e, 0x50, 0x20, 
+    0x68, 0x04, 0xd2, 0x5f, 0x80, 0x02, 0xc2, 0x5f, 0xa5, 0xfd, 0x5e, 0x50, 0x80, 0x68, 0x04, 0xd2, 
+    0x57, 0x80, 0x02, 0xc2, 0x57, 0x02, 0x65, 0x88, 0x54, 0xf0, 0xc4, 0xa5, 0xff, 0xc4, 0xa5, 0x4f, 
+    0x75, 0x2f, 0x90, 0x12, 0x7e, 0x30, 0xf5, 0x2f, 0x12, 0x7e, 0x30, 0x22, 0xca, 0x19, 0x5e, 0x20, 
+    0x07, 0x4c, 0xa2, 0x7e, 0x74, 0x29, 0xcd, 0xca, 0x79, 0x7a, 0x79, 0xa0, 0x0b, 0x74, 0x7a, 0x79, 
+    0xb0, 0x0b, 0x74, 0xda, 0x79, 0x7e, 0x30, 0x02, 0x7e, 0x64, 0x00, 0x02, 0x02, 0x65, 0xe7, 0xca, 
+    0x19, 0x5e, 0x20, 0x07, 0x4c, 0xa2, 0x7e, 0x74, 0x29, 0xcd, 0xca, 0x79, 0x7a, 0x79, 0xa0, 0x0b, 
+    0x74, 0x7a, 0x79, 0xb0, 0x0b, 0x74, 0x7a, 0x79, 0x60, 0x0b, 0x74, 0xda, 0x79, 0x7e, 0x30, 0x03, 
+    0x7e, 0x64, 0x00, 0x03, 0x02, 0x65, 0xe7, 0xd2, 0x04, 0x7e, 0x27, 0x01, 0xcb, 0x2d, 0x26, 0xbe, 
+    0x24, 0x04, 0x00, 0x38, 0x2e, 0x7e, 0x07, 0x01, 0xc9, 0x7e, 0x44, 0x05, 0xcd, 0x7e, 0x79, 0xa0, 
+    0x7a, 0x09, 0xa0, 0x0b, 0x04, 0x0b, 0x74, 0xbd, 0x04, 0x68, 0x23, 0xa5, 0xdb, 0xef, 0x7a, 0x27, 
+    0x01, 0xcb, 0x7e, 0x25, 0x30, 0x2d, 0x26, 0x7a, 0x25, 0x30, 0x7a, 0x07, 0x01, 0xc9, 0xda, 0x19, 
+    0xc2, 0xd7, 0x22, 0x75, 0x2f, 0x9a, 0x12, 0x7e, 0x30, 0xda, 0x19, 0xd2, 0xd7, 0x22, 0x7e, 0x04, 
+    0x01, 0xcd, 0x80, 0xd7, 0x4d, 0x42, 0x4a, 0xae, 0x4b, 0xa8, 0x4d, 0x7b, 0x49, 0x4f, 0x49, 0x4f, 
+    0x4c, 0xa7, 0x49, 0x4f, 0x4d, 0xbf, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x4d, 0xc6, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x50, 0x77, 0x4d, 0xe3, 0x4e, 0xdd, 0x50, 0xb0, 0x49, 0x4f, 0x49, 0x4f, 
+    0x4f, 0xdc, 0x49, 0x4f, 0x50, 0xf4, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x50, 0xfb, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x53, 0xac, 0x51, 0x18, 0x52, 0x12, 0x53, 0xe5, 0x49, 0x4f, 0x49, 0x4f, 
+    0x53, 0x11, 0x49, 0x4f, 0x54, 0x29, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x54, 0x30, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x56, 0xe1, 0x54, 0x4d, 0x55, 0x47, 0x57, 0x1a, 0x49, 0x4f, 0x49, 0x4f, 
+    0x56, 0x46, 0x49, 0x4f, 0x57, 0x5e, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x57, 0x65, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x5a, 0x16, 0x57, 0x82, 0x58, 0x7c, 0x5a, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x59, 0x7b, 0x49, 0x4f, 0x5a, 0x93, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x5a, 0x9a, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x5d, 0x4b, 0x5a, 0xb7, 0x5b, 0xb1, 0x5d, 0x84, 0x49, 0x4f, 0x49, 0x4f, 
+    0x5c, 0xb0, 0x49, 0x4f, 0x5d, 0xc8, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x5d, 0xcf, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x60, 0x80, 0x5d, 0xec, 0x5e, 0xe6, 0x60, 0xb9, 0x49, 0x4f, 0x49, 0x4f, 
+    0x5f, 0xe5, 0x49, 0x4f, 0x60, 0xfd, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x61, 0x04, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x63, 0xb5, 0x61, 0x21, 0x62, 0x1b, 0x63, 0xee, 0x49, 0x4f, 0x49, 0x4f, 
+    0x63, 0x1a, 0x49, 0x4f, 0x64, 0x32, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x64, 0x39, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 0x49, 0x4f, 
+    0x49, 0x4f, 0x49, 0x4f, 0xca, 0x29, 0x1e, 0x50, 0x40, 0x0d, 0x7e, 0x54, 0x0b, 0x10, 0x9c, 0xb5, 
+    0xa4, 0x2e, 0x54, 0x68, 0x51, 0x89, 0x54, 0x7e, 0x39, 0x00, 0x7a, 0x19, 0x00, 0x0b, 0x34, 0x80, 
+    0xe9, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 
+    0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 
+    0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 
+    0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 
     0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 
     0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 
     0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 
@@ -832,12 +744,12 @@
     0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 
     0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 0x19, 
     0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 
-    0x35, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 
-    0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 
-    0x0b, 0x35, 0x0b, 0x38, 0x00, 0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0x0b, 0x38, 0x00, 
-    0x7a, 0x19, 0x00, 0x7a, 0x19, 0x10, 0x0b, 0x35, 0xda, 0x29, 0x22, 0x1e, 0x50, 0x40, 0x0d, 0x7e, 
-    0x54, 0x0b, 0x1c, 0x9c, 0xb5, 0xa4, 0x2e, 0x54, 0x66, 0x16, 0x89, 0x54, 0x7e, 0x19, 0x00, 0x7a, 
-    0x39, 0x00, 0x0b, 0x34, 0x80, 0xe9, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 
+    0x35, 0xda, 0x29, 0x22, 0x1e, 0x50, 0x40, 0x0d, 0x7e, 0x54, 0x0b, 0x1c, 0x9c, 0xb5, 0xa4, 0x2e, 
+    0x54, 0x69, 0x1f, 0x89, 0x54, 0x7e, 0x19, 0x00, 0x7a, 0x39, 0x00, 0x0b, 0x34, 0x80, 0xe9, 0x7e, 
+    0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 
+    0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 
+    0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 
+    0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 
     0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 
     0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 
     0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 
@@ -853,176 +765,157 @@
     0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 
     0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 
     0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 
-    0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 
-    0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 
-    0x38, 0x00, 0x0b, 0x35, 0x7e, 0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x7e, 
-    0x19, 0x00, 0x7e, 0x19, 0x10, 0x1b, 0x38, 0x00, 0x0b, 0x35, 0x22, 0x67, 0x96, 0x69, 0x63, 0x69, 
-    0x7b, 0x6a, 0x49, 0x6a, 0xe4, 0x6b, 0x8e, 0x6b, 0xa9, 0x6c, 0x3b, 0x6b, 0xc4, 0x6c, 0x05, 0x69, 
-    0x96, 0x69, 0xaa, 0x7c, 0xb3, 0xbe, 0xb0, 0x0b, 0x28, 0x14, 0x75, 0x31, 0x09, 0x12, 0x7c, 0x15, 
-    0x75, 0x6d, 0x10, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x43, 0xe1, 0xc0, 0xd0, 0xf1, 0x22, 0xc0, 0xa8, 
-    0xc2, 0xaf, 0x23, 0x6c, 0xaa, 0x2e, 0x54, 0x67, 0x4b, 0x0b, 0x58, 0x50, 0x89, 0x54, 0x01, 0x02, 
-    0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x75, 0x31, 0xb0, 0x12, 0x7c, 0x15, 0x0a, 0x32, 0x09, 0xb3, 
-    0x67, 0x8e, 0x42, 0x32, 0x19, 0x43, 0x00, 0x36, 0xd0, 0xa8, 0x22, 0x7c, 0xb2, 0x23, 0x0a, 0x3b, 
-    0x49, 0x33, 0x67, 0xcb, 0x0a, 0x22, 0x09, 0x32, 0x00, 0x36, 0x09, 0xb2, 0x67, 0x8e, 0xa5, 0xbb, 
-    0x00, 0x05, 0xf4, 0x52, 0x33, 0x80, 0x02, 0x42, 0x33, 0x89, 0x34, 0x67, 0xdb, 0x68, 0x09, 0x68, 
-    0x37, 0x68, 0x65, 0x68, 0x93, 0x68, 0xc1, 0x68, 0xef, 0x69, 0x1d, 0x12, 0x41, 0xb5, 0xd2, 0x28, 
-    0xd2, 0x08, 0xc2, 0x40, 0xc2, 0x48, 0xc2, 0x38, 0xc2, 0x30, 0x6d, 0x00, 0x7a, 0x03, 0x01, 0xcf, 
-    0x7e, 0x04, 0x00, 0x20, 0x7a, 0x07, 0x01, 0xaf, 0x7e, 0x04, 0x00, 0x38, 0x7a, 0x07, 0x01, 0xbf, 
-    0x12, 0x41, 0x16, 0x12, 0x60, 0xcf, 0x02, 0x69, 0x4b, 0x12, 0x41, 0xd4, 0xd2, 0x29, 0xd2, 0x09, 
-    0xc2, 0x41, 0xc2, 0x49, 0xc2, 0x39, 0xc2, 0x31, 0x6d, 0x00, 0x7a, 0x03, 0x01, 0xd0, 0x7e, 0x04, 
-    0x00, 0x20, 0x7a, 0x07, 0x01, 0xb1, 0x7e, 0x04, 0x00, 0x38, 0x7a, 0x07, 0x01, 0xc1, 0x12, 0x41, 
-    0x16, 0x12, 0x61, 0x05, 0x02, 0x69, 0x4b, 0x12, 0x41, 0xf3, 0xd2, 0x2a, 0xd2, 0x0a, 0xc2, 0x42, 
-    0xc2, 0x4a, 0xc2, 0x3a, 0xc2, 0x32, 0x6d, 0x00, 0x7a, 0x03, 0x01, 0xd1, 0x7e, 0x04, 0x00, 0x20, 
-    0x7a, 0x07, 0x01, 0xb3, 0x7e, 0x04, 0x00, 0x38, 0x7a, 0x07, 0x01, 0xc3, 0x12, 0x41, 0x16, 0x12, 
-    0x61, 0x3b, 0x02, 0x69, 0x4b, 0x12, 0x42, 0x12, 0xd2, 0x2b, 0xd2, 0x0b, 0xc2, 0x43, 0xc2, 0x4b, 
-    0xc2, 0x3b, 0xc2, 0x33, 0x6d, 0x00, 0x7a, 0x03, 0x01, 0xd2, 0x7e, 0x04, 0x00, 0x20, 0x7a, 0x07, 
-    0x01, 0xb5, 0x7e, 0x04, 0x00, 0x38, 0x7a, 0x07, 0x01, 0xc5, 0x12, 0x41, 0x16, 0x12, 0x61, 0x71, 
-    0x02, 0x69, 0x4b, 0x12, 0x42, 0x31, 0xd2, 0x2c, 0xd2, 0x0c, 0xc2, 0x44, 0xc2, 0x4c, 0xc2, 0x3c, 
-    0xc2, 0x34, 0x6d, 0x00, 0x7a, 0x03, 0x01, 0xd3, 0x7e, 0x04, 0x00, 0x20, 0x7a, 0x07, 0x01, 0xb7, 
-    0x7e, 0x04, 0x00, 0x38, 0x7a, 0x07, 0x01, 0xc7, 0x12, 0x41, 0x16, 0x12, 0x61, 0xa7, 0x02, 0x69, 
-    0x4b, 0x12, 0x42, 0x50, 0xd2, 0x2d, 0xd2, 0x0d, 0xc2, 0x45, 0xc2, 0x4d, 0xc2, 0x3d, 0xc2, 0x35, 
-    0x6d, 0x00, 0x7a, 0x03, 0x01, 0xd4, 0x7e, 0x04, 0x00, 0x20, 0x7a, 0x07, 0x01, 0xb9, 0x7e, 0x04, 
-    0x00, 0x38, 0x7a, 0x07, 0x01, 0xc9, 0x12, 0x41, 0x16, 0x12, 0x61, 0xdd, 0x02, 0x69, 0x4b, 0x12, 
-    0x42, 0x6f, 0xd2, 0x2e, 0xd2, 0x0e, 0xc2, 0x46, 0xc2, 0x4e, 0xc2, 0x3e, 0xc2, 0x36, 0x6d, 0x00, 
-    0x7a, 0x03, 0x01, 0xd5, 0x7e, 0x04, 0x00, 0x20, 0x7a, 0x07, 0x01, 0xbb, 0x7e, 0x04, 0x00, 0x38, 
-    0x7a, 0x07, 0x01, 0xcb, 0x12, 0x41, 0x16, 0x12, 0x62, 0x13, 0x02, 0x69, 0x4b, 0x12, 0x42, 0x8e, 
-    0xd2, 0x2f, 0xd2, 0x0f, 0xc2, 0x47, 0xc2, 0x4f, 0xc2, 0x3f, 0xc2, 0x37, 0x6d, 0x00, 0x7a, 0x03, 
-    0x01, 0xd6, 0x7e, 0x04, 0x00, 0x20, 0x7a, 0x07, 0x01, 0xbd, 0x7e, 0x04, 0x00, 0x38, 0x7a, 0x07, 
-    0x01, 0xcd, 0x12, 0x41, 0x16, 0x12, 0x62, 0x49, 0x02, 0x69, 0x4b, 0x7e, 0xa0, 0xd0, 0x7e, 0x60, 
-    0x0f, 0x12, 0x62, 0xb6, 0x40, 0x0c, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 
-    0xc2, 0xd7, 0x22, 0x75, 0x31, 0xb1, 0x12, 0x7c, 0x15, 0x0a, 0x52, 0x23, 0x6d, 0x00, 0x59, 0x05, 
-    0x00, 0x48, 0x12, 0x41, 0x7e, 0x12, 0x41, 0x9a, 0xd0, 0xa8, 0x22, 0x75, 0x31, 0xb2, 0x12, 0x7c, 
-    0x15, 0x0a, 0x22, 0x09, 0xb2, 0x67, 0x8e, 0x42, 0x23, 0x7e, 0xb0, 0x9c, 0x19, 0xb2, 0x01, 0xcf, 
-    0x12, 0x31, 0x85, 0xd0, 0xa8, 0x22, 0x75, 0x31, 0xb7, 0x12, 0x7c, 0x15, 0x0a, 0x22, 0x09, 0xb2, 
-    0x67, 0x8e, 0x42, 0x24, 0x12, 0x35, 0x3d, 0xd0, 0xa8, 0x22, 0x75, 0x31, 0xb9, 0x12, 0x7c, 0x15, 
-    0x0a, 0x32, 0x09, 0xb3, 0x67, 0x8e, 0x42, 0x34, 0x19, 0x43, 0x00, 0x3e, 0x12, 0x69, 0xc2, 0xd0, 
-    0xa8, 0x22, 0x7c, 0xb2, 0x23, 0x0a, 0x0b, 0x7c, 0xb4, 0x20, 0xe0, 0x04, 0x6d, 0x33, 0x80, 0x04, 
-    0x49, 0x30, 0x01, 0x8f, 0x7e, 0xa0, 0xd8, 0xa5, 0xef, 0xca, 0x0b, 0xca, 0x29, 0x12, 0x62, 0xb6, 
-    0xda, 0x29, 0xda, 0x0b, 0x40, 0x62, 0x75, 0x31, 0xba, 0x12, 0x7c, 0x15, 0x7c, 0xb4, 0x30, 0xe0, 
-    0x1e, 0x6d, 0x33, 0x59, 0x30, 0x01, 0x8f, 0x7e, 0x34, 0x09, 0xe3, 0x0a, 0x82, 0x7e, 0x94, 0x04, 
-    0x00, 0xad, 0x89, 0x2d, 0x39, 0x59, 0x30, 0x01, 0x6f, 0x59, 0x30, 0x01, 0x7f, 0x7c, 0xb4, 0x30, 
-    0xe1, 0x10, 0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 0x09, 0xb0, 0x00, 0x08, 0x44, 0x04, 0x19, 0xb0, 
-    0x00, 0x08, 0x0a, 0x02, 0x09, 0xb0, 0x67, 0x8e, 0x42, 0x21, 0xf4, 0x52, 0x34, 0x7c, 0xb2, 0x23, 
-    0x0a, 0x0b, 0xca, 0x19, 0x49, 0x00, 0x30, 0xd5, 0x99, 0x04, 0xda, 0x19, 0xc0, 0xf1, 0x75, 0xf1, 
-    0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0xc2, 0xd7, 0x22, 0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 0x09, 
-    0x30, 0x00, 0x0c, 0x74, 0xbf, 0x19, 0xb0, 0x00, 0x0c, 0x09, 0xb0, 0x00, 0x08, 0x19, 0x30, 0x00, 
-    0x0c, 0x7c, 0x74, 0x5e, 0x70, 0x01, 0x68, 0x12, 0x44, 0x40, 0xca, 0xb8, 0x09, 0xb0, 0x00, 0x10, 
-    0x44, 0x02, 0x19, 0xb0, 0x00, 0x10, 0xda, 0xb8, 0x80, 0x02, 0x54, 0xbf, 0x7c, 0x74, 0x5e, 0x70, 
-    0x08, 0x68, 0x04, 0x44, 0x08, 0x80, 0x02, 0x54, 0xf7, 0x09, 0x30, 0x00, 0x0c, 0xca, 0xb8, 0x74, 
-    0xbf, 0x19, 0xb0, 0x00, 0x0c, 0xda, 0xb8, 0x19, 0xb0, 0x00, 0x08, 0x19, 0x30, 0x00, 0x0c, 0x0a, 
-    0x62, 0x09, 0xb6, 0x67, 0x8e, 0x3e, 0x20, 0x0a, 0x62, 0x7c, 0x74, 0x5e, 0x70, 0x02, 0x68, 0x20, 
-    0x42, 0x27, 0xca, 0xb8, 0x74, 0x61, 0x19, 0xb0, 0x00, 0x08, 0x7e, 0x44, 0x00, 0x10, 0x59, 0x46, 
-    0x01, 0xbf, 0x09, 0xb0, 0x00, 0x10, 0x44, 0x01, 0x19, 0xb0, 0x00, 0x10, 0xda, 0xb8, 0x80, 0x11, 
-    0xf4, 0x52, 0x27, 0x74, 0xa1, 0x19, 0xb0, 0x00, 0x08, 0x7e, 0x44, 0x00, 0x38, 0x59, 0x46, 0x01, 
-    0xbf, 0xd0, 0xa8, 0x22, 0x7c, 0x74, 0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 0x0a, 0x62, 0x09, 0xb6, 
-    0x67, 0x8e, 0xa5, 0xfd, 0xf4, 0xa5, 0xfe, 0xca, 0x28, 0x3e, 0x20, 0x0a, 0x62, 0xa5, 0xee, 0x52, 
-    0x26, 0x7e, 0x44, 0x00, 0x20, 0x59, 0x46, 0x01, 0xaf, 0xda, 0x28, 0x09, 0x30, 0x00, 0x0c, 0x74, 
-    0xbf, 0x19, 0xb0, 0x00, 0x0c, 0x09, 0xb0, 0x00, 0x08, 0x7c, 0x74, 0x5e, 0x70, 0x01, 0x68, 0x0c, 
-    0x44, 0x80, 0xca, 0xb8, 0xa5, 0xed, 0x42, 0x2a, 0xda, 0xb8, 0x80, 0x0a, 0x54, 0x7f, 0xca, 0xb8, 
-    0xa5, 0xee, 0x52, 0x2a, 0xda, 0xb8, 0x7c, 0x74, 0x5e, 0x70, 0x08, 0x68, 0x04, 0x44, 0x02, 0x80, 
-    0x02, 0x54, 0xfd, 0x19, 0xb0, 0x00, 0x08, 0x19, 0x30, 0x00, 0x0c, 0x7c, 0x74, 0x5e, 0x70, 0x02, 
-    0x68, 0x10, 0xa5, 0xed, 0x42, 0x28, 0x42, 0x26, 0x7e, 0x44, 0x00, 0x08, 0x59, 0x46, 0x01, 0xaf, 
-    0x80, 0x04, 0xa5, 0xee, 0x52, 0x28, 0x7c, 0x74, 0x5e, 0x70, 0x04, 0x68, 0x10, 0xa5, 0xed, 0x42, 
-    0x29, 0x42, 0x26, 0x7e, 0x44, 0x00, 0x08, 0x59, 0x46, 0x01, 0xaf, 0x80, 0x0b, 0xa5, 0xee, 0x52, 
-    0x29, 0x7c, 0x74, 0x5e, 0x70, 0x02, 0x78, 0x00, 0x12, 0x42, 0xad, 0xd0, 0xa8, 0x22, 0x7e, 0x04, 
-    0x80, 0x00, 0x4c, 0x02, 0x09, 0x30, 0x00, 0x0c, 0x74, 0xbf, 0x19, 0xb0, 0x00, 0x0c, 0x19, 0x40, 
-    0x00, 0x10, 0x19, 0x30, 0x00, 0x0c, 0xd0, 0xa8, 0x22, 0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 0x09, 
-    0x30, 0x00, 0x0c, 0x74, 0xbf, 0x19, 0xb0, 0x00, 0x0c, 0x19, 0x40, 0x00, 0x18, 0x19, 0x30, 0x00, 
-    0x0c, 0xd0, 0xa8, 0x22, 0x75, 0x31, 0xb5, 0x12, 0x7c, 0x15, 0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 
-    0x09, 0xb0, 0x00, 0x0c, 0x44, 0x40, 0x19, 0xb0, 0x00, 0x0c, 0xe5, 0x6e, 0xb4, 0x07, 0x23, 0x09, 
-    0xb0, 0x00, 0x10, 0x4e, 0xb0, 0x02, 0x19, 0xb0, 0x00, 0x10, 0x09, 0x30, 0x00, 0x0c, 0x74, 0xbf, 
-    0x19, 0xb0, 0x00, 0x0c, 0x09, 0xb0, 0x00, 0x04, 0x54, 0xf7, 0x19, 0xb0, 0x00, 0x04, 0x19, 0x30, 
-    0x00, 0x0c, 0xd0, 0xa8, 0x22, 0x75, 0x31, 0xb6, 0x12, 0x7c, 0x15, 0x7e, 0x04, 0x80, 0x00, 0x4c, 
-    0x02, 0xe5, 0x6e, 0xb4, 0x07, 0x18, 0x09, 0x30, 0x00, 0x0c, 0x74, 0xbf, 0x19, 0xb0, 0x00, 0x0c, 
-    0x09, 0xb0, 0x00, 0x04, 0x44, 0x08, 0x19, 0xb0, 0x00, 0x04, 0x19, 0x30, 0x00, 0x0c, 0x09, 0xb0, 
-    0x00, 0x0c, 0x54, 0xbf, 0x19, 0xb0, 0x00, 0x0c, 0xd0, 0xa8, 0x22, 0x75, 0x31, 0xb4, 0x12, 0x7c, 
-    0x15, 0x7a, 0x21, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x41, 0x31, 0x12, 0x7c, 0x15, 0x0a, 0x32, 0x09, 
-    0xb3, 0x67, 0x8e, 0x42, 0x35, 0x12, 0x6c, 0x5b, 0xd0, 0xa8, 0x22, 0x7e, 0xb0, 0x01, 0x7e, 0xa0, 
-    0xc8, 0x7c, 0x64, 0x12, 0x62, 0xb6, 0x40, 0x13, 0x0a, 0x32, 0x09, 0xb3, 0x67, 0x8e, 0xf4, 0x52, 
-    0x35, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x6f, 0xd9, 0xd0, 0xf1, 0x22, 0x6c, 0x8c, 0x6c, 0xd3, 
-    0x6d, 0x1a, 0x6d, 0x61, 0x6d, 0xa8, 0x6d, 0xef, 0x6e, 0x36, 0x6e, 0x7d, 0x75, 0x31, 0x55, 0x12, 
-    0x7c, 0x15, 0x75, 0x31, 0x00, 0x12, 0x7c, 0x15, 0x7a, 0x61, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x71, 
-    0x31, 0x12, 0x7c, 0x15, 0x7e, 0x17, 0x01, 0x7f, 0x7e, 0x27, 0x01, 0x8f, 0x2d, 0x23, 0x7e, 0x09, 
-    0xb0, 0x0b, 0x04, 0x7a, 0x19, 0xb0, 0x0b, 0x14, 0xbe, 0x14, 0x0d, 0xe2, 0x38, 0x0f, 0x1b, 0x34, 
-    0x78, 0xec, 0x7a, 0x17, 0x01, 0x7f, 0x7a, 0x27, 0x01, 0x8f, 0x02, 0x46, 0x0f, 0x7e, 0x14, 0x09, 
-    0xe3, 0x80, 0xeb, 0x75, 0x31, 0x55, 0x12, 0x7c, 0x15, 0x75, 0x31, 0x01, 0x12, 0x7c, 0x15, 0x7a, 
-    0x61, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 0x7c, 0x15, 0x7e, 0x17, 0x01, 0x81, 0x7e, 
-    0x27, 0x01, 0x91, 0x2d, 0x23, 0x7e, 0x09, 0xb0, 0x0b, 0x04, 0x7a, 0x19, 0xb0, 0x0b, 0x14, 0xbe, 
-    0x14, 0x11, 0xe2, 0x38, 0x0f, 0x1b, 0x34, 0x78, 0xec, 0x7a, 0x17, 0x01, 0x81, 0x7a, 0x27, 0x01, 
-    0x91, 0x02, 0x49, 0x67, 0x7e, 0x14, 0x0d, 0xe3, 0x80, 0xeb, 0x75, 0x31, 0x55, 0x12, 0x7c, 0x15, 
-    0x75, 0x31, 0x02, 0x12, 0x7c, 0x15, 0x7a, 0x61, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 
-    0x7c, 0x15, 0x7e, 0x17, 0x01, 0x83, 0x7e, 0x27, 0x01, 0x93, 0x2d, 0x23, 0x7e, 0x09, 0xb0, 0x0b, 
-    0x04, 0x7a, 0x19, 0xb0, 0x0b, 0x14, 0xbe, 0x14, 0x15, 0xe2, 0x38, 0x0f, 0x1b, 0x34, 0x78, 0xec, 
-    0x7a, 0x17, 0x01, 0x83, 0x7a, 0x27, 0x01, 0x93, 0x02, 0x4c, 0xbf, 0x7e, 0x14, 0x11, 0xe3, 0x80, 
-    0xeb, 0x75, 0x31, 0x55, 0x12, 0x7c, 0x15, 0x75, 0x31, 0x03, 0x12, 0x7c, 0x15, 0x7a, 0x61, 0x31, 
-    0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 0x7c, 0x15, 0x7e, 0x17, 0x01, 0x85, 0x7e, 0x27, 0x01, 
-    0x95, 0x2d, 0x23, 0x7e, 0x09, 0xb0, 0x0b, 0x04, 0x7a, 0x19, 0xb0, 0x0b, 0x14, 0xbe, 0x14, 0x19, 
-    0xe2, 0x38, 0x0f, 0x1b, 0x34, 0x78, 0xec, 0x7a, 0x17, 0x01, 0x85, 0x7a, 0x27, 0x01, 0x95, 0x02, 
-    0x50, 0x17, 0x7e, 0x14, 0x15, 0xe3, 0x80, 0xeb, 0x75, 0x31, 0x55, 0x12, 0x7c, 0x15, 0x75, 0x31, 
-    0x04, 0x12, 0x7c, 0x15, 0x7a, 0x61, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 0x7c, 0x15, 
-    0x7e, 0x17, 0x01, 0x87, 0x7e, 0x27, 0x01, 0x97, 0x2d, 0x23, 0x7e, 0x09, 0xb0, 0x0b, 0x04, 0x7a, 
-    0x19, 0xb0, 0x0b, 0x14, 0xbe, 0x14, 0x1d, 0xe2, 0x38, 0x0f, 0x1b, 0x34, 0x78, 0xec, 0x7a, 0x17, 
-    0x01, 0x87, 0x7a, 0x27, 0x01, 0x97, 0x02, 0x53, 0x6f, 0x7e, 0x14, 0x19, 0xe3, 0x80, 0xeb, 0x75, 
-    0x31, 0x55, 0x12, 0x7c, 0x15, 0x75, 0x31, 0x05, 0x12, 0x7c, 0x15, 0x7a, 0x61, 0x31, 0x12, 0x7c, 
-    0x15, 0x7a, 0x71, 0x31, 0x12, 0x7c, 0x15, 0x7e, 0x17, 0x01, 0x89, 0x7e, 0x27, 0x01, 0x99, 0x2d, 
-    0x23, 0x7e, 0x09, 0xb0, 0x0b, 0x04, 0x7a, 0x19, 0xb0, 0x0b, 0x14, 0xbe, 0x14, 0x21, 0xe2, 0x38, 
-    0x0f, 0x1b, 0x34, 0x78, 0xec, 0x7a, 0x17, 0x01, 0x89, 0x7a, 0x27, 0x01, 0x99, 0x02, 0x56, 0xc7, 
-    0x7e, 0x14, 0x1d, 0xe3, 0x80, 0xeb, 0x75, 0x31, 0x55, 0x12, 0x7c, 0x15, 0x75, 0x31, 0x06, 0x12, 
-    0x7c, 0x15, 0x7a, 0x61, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x71, 0x31, 0x12, 0x7c, 0x15, 0x7e, 0x17, 
-    0x01, 0x8b, 0x7e, 0x27, 0x01, 0x9b, 0x2d, 0x23, 0x7e, 0x09, 0xb0, 0x0b, 0x04, 0x7a, 0x19, 0xb0, 
-    0x0b, 0x14, 0xbe, 0x14, 0x25, 0xe2, 0x38, 0x0f, 0x1b, 0x34, 0x78, 0xec, 0x7a, 0x17, 0x01, 0x8b, 
-    0x7a, 0x27, 0x01, 0x9b, 0x02, 0x5a, 0x1f, 0x7e, 0x14, 0x21, 0xe3, 0x80, 0xeb, 0x75, 0x31, 0x55, 
-    0x12, 0x7c, 0x15, 0x75, 0x31, 0x07, 0x12, 0x7c, 0x15, 0x7a, 0x61, 0x31, 0x12, 0x7c, 0x15, 0x7a, 
-    0x71, 0x31, 0x12, 0x7c, 0x15, 0x7e, 0x17, 0x01, 0x8d, 0x7e, 0x27, 0x01, 0x9d, 0x2d, 0x23, 0x7e, 
-    0x09, 0xb0, 0x0b, 0x04, 0x7a, 0x19, 0xb0, 0x0b, 0x14, 0xbe, 0x14, 0x29, 0xe2, 0x38, 0x0f, 0x1b, 
-    0x34, 0x78, 0xec, 0x7a, 0x17, 0x01, 0x8d, 0x7a, 0x27, 0x01, 0x9d, 0x02, 0x5d, 0x77, 0x7e, 0x14, 
-    0x25, 0xe3, 0x80, 0xeb, 0xca, 0xb8, 0xc0, 0xf1, 0x75, 0x31, 0x02, 0x12, 0x7c, 0x15, 0xe5, 0xc0, 
-    0x54, 0x03, 0x68, 0x05, 0x12, 0x75, 0xcd, 0x80, 0xf5, 0x30, 0xc2, 0x08, 0x75, 0xf1, 0x01, 0x12, 
-    0x6f, 0xd9, 0x80, 0x14, 0x30, 0xc3, 0x08, 0x75, 0xf1, 0x01, 0x12, 0x6e, 0xfd, 0x80, 0x09, 0x30, 
-    0xc4, 0x06, 0x75, 0xf1, 0x02, 0x12, 0x70, 0xe9, 0xd0, 0xf1, 0xda, 0xb8, 0x32, 0x75, 0x31, 0x10, 
-    0x12, 0x7c, 0x15, 0xca, 0x0b, 0xca, 0x39, 0xca, 0x59, 0xc2, 0xc3, 0xa9, 0x21, 0xe2, 0x5c, 0xe5, 
-    0xe5, 0x54, 0xc0, 0x68, 0x4f, 0xe5, 0xe6, 0x6c, 0xaa, 0x7e, 0x37, 0x01, 0xdb, 0x2d, 0x35, 0xbe, 
-    0x34, 0x04, 0x00, 0x38, 0x4a, 0x7a, 0x37, 0x01, 0xdb, 0x7e, 0x37, 0x01, 0xd9, 0x7d, 0x43, 0x2d, 
-    0x45, 0xbe, 0x44, 0x09, 0xe2, 0x38, 0x40, 0x7a, 0x47, 0x01, 0xd9, 0x75, 0x31, 0x11, 0x12, 0x7c, 
-    0x15, 0x7a, 0xb1, 0x31, 0x12, 0x7c, 0x15, 0x12, 0x71, 0xb8, 0xa9, 0x21, 0xe5, 0x1f, 0xa9, 0xd4, 
+    0x00, 0x0b, 0x35, 0x22, 0x6a, 0x9b, 0x6c, 0x4f, 0x6c, 0x67, 0x6c, 0x82, 0x6d, 0x1d, 0x6d, 0xb5, 
+    0x6d, 0xd0, 0x6e, 0x62, 0x6d, 0xeb, 0x6e, 0x2c, 0x7c, 0xb3, 0xbe, 0xb0, 0x09, 0x28, 0x14, 0x75, 
+    0x2f, 0x09, 0x12, 0x7e, 0x30, 0x75, 0x57, 0x10, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x43, 0xe1, 0xc0, 
+    0xd0, 0xf1, 0x22, 0xc0, 0xa8, 0xc2, 0xaf, 0x23, 0x6c, 0xaa, 0x2e, 0x54, 0x6a, 0x54, 0x0b, 0x58, 
+    0x50, 0x89, 0x54, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x75, 0x2f, 0xb0, 0x12, 0x7e, 
+    0x30, 0x0a, 0x22, 0x09, 0xb2, 0x6a, 0x93, 0x42, 0x24, 0xd0, 0xa8, 0x22, 0x7c, 0xb2, 0x23, 0x0a, 
+    0x3b, 0x49, 0x33, 0x6a, 0xb7, 0x89, 0x34, 0x6a, 0xc7, 0x6a, 0xf5, 0x6b, 0x23, 0x6b, 0x51, 0x6b, 
+    0x7f, 0x6b, 0xad, 0x6b, 0xdb, 0x6c, 0x09, 0x12, 0x41, 0xa9, 0xd2, 0x28, 0xd2, 0x08, 0xc2, 0x40, 
+    0xc2, 0x48, 0xc2, 0x38, 0xc2, 0x30, 0x6d, 0x00, 0x7a, 0x03, 0x01, 0xb9, 0x7e, 0x04, 0x00, 0x20, 
+    0x7a, 0x07, 0x01, 0x99, 0x7e, 0x04, 0x00, 0x38, 0x7a, 0x07, 0x01, 0xa9, 0x12, 0x41, 0x16, 0x12, 
+    0x64, 0x40, 0x02, 0x6c, 0x37, 0x12, 0x41, 0xc6, 0xd2, 0x29, 0xd2, 0x09, 0xc2, 0x41, 0xc2, 0x49, 
+    0xc2, 0x39, 0xc2, 0x31, 0x6d, 0x00, 0x7a, 0x03, 0x01, 0xba, 0x7e, 0x04, 0x00, 0x20, 0x7a, 0x07, 
+    0x01, 0x9b, 0x7e, 0x04, 0x00, 0x38, 0x7a, 0x07, 0x01, 0xab, 0x12, 0x41, 0x16, 0x12, 0x64, 0x69, 
+    0x02, 0x6c, 0x37, 0x12, 0x41, 0xe3, 0xd2, 0x2a, 0xd2, 0x0a, 0xc2, 0x42, 0xc2, 0x4a, 0xc2, 0x3a, 
+    0xc2, 0x32, 0x6d, 0x00, 0x7a, 0x03, 0x01, 0xbb, 0x7e, 0x04, 0x00, 0x20, 0x7a, 0x07, 0x01, 0x9d, 
+    0x7e, 0x04, 0x00, 0x38, 0x7a, 0x07, 0x01, 0xad, 0x12, 0x41, 0x16, 0x12, 0x64, 0x92, 0x02, 0x6c, 
+    0x37, 0x12, 0x42, 0x00, 0xd2, 0x2b, 0xd2, 0x0b, 0xc2, 0x43, 0xc2, 0x4b, 0xc2, 0x3b, 0xc2, 0x33, 
+    0x6d, 0x00, 0x7a, 0x03, 0x01, 0xbc, 0x7e, 0x04, 0x00, 0x20, 0x7a, 0x07, 0x01, 0x9f, 0x7e, 0x04, 
+    0x00, 0x38, 0x7a, 0x07, 0x01, 0xaf, 0x12, 0x41, 0x16, 0x12, 0x64, 0xbb, 0x02, 0x6c, 0x37, 0x12, 
+    0x42, 0x1d, 0xd2, 0x2c, 0xd2, 0x0c, 0xc2, 0x44, 0xc2, 0x4c, 0xc2, 0x3c, 0xc2, 0x34, 0x6d, 0x00, 
+    0x7a, 0x03, 0x01, 0xbd, 0x7e, 0x04, 0x00, 0x20, 0x7a, 0x07, 0x01, 0xa1, 0x7e, 0x04, 0x00, 0x38, 
+    0x7a, 0x07, 0x01, 0xb1, 0x12, 0x41, 0x16, 0x12, 0x64, 0xe4, 0x02, 0x6c, 0x37, 0x12, 0x42, 0x3a, 
+    0xd2, 0x2d, 0xd2, 0x0d, 0xc2, 0x45, 0xc2, 0x4d, 0xc2, 0x3d, 0xc2, 0x35, 0x6d, 0x00, 0x7a, 0x03, 
+    0x01, 0xbe, 0x7e, 0x04, 0x00, 0x20, 0x7a, 0x07, 0x01, 0xa3, 0x7e, 0x04, 0x00, 0x38, 0x7a, 0x07, 
+    0x01, 0xb3, 0x12, 0x41, 0x16, 0x12, 0x65, 0x0d, 0x02, 0x6c, 0x37, 0x12, 0x42, 0x57, 0xd2, 0x2e, 
+    0xd2, 0x0e, 0xc2, 0x46, 0xc2, 0x4e, 0xc2, 0x3e, 0xc2, 0x36, 0x6d, 0x00, 0x7a, 0x03, 0x01, 0xbf, 
+    0x7e, 0x04, 0x00, 0x20, 0x7a, 0x07, 0x01, 0xa5, 0x7e, 0x04, 0x00, 0x38, 0x7a, 0x07, 0x01, 0xb5, 
+    0x12, 0x41, 0x16, 0x12, 0x65, 0x36, 0x02, 0x6c, 0x37, 0x12, 0x42, 0x74, 0xd2, 0x2f, 0xd2, 0x0f, 
+    0xc2, 0x47, 0xc2, 0x4f, 0xc2, 0x3f, 0xc2, 0x37, 0x6d, 0x00, 0x7a, 0x03, 0x01, 0xc0, 0x7e, 0x04, 
+    0x00, 0x20, 0x7a, 0x07, 0x01, 0xa7, 0x7e, 0x04, 0x00, 0x38, 0x7a, 0x07, 0x01, 0xb7, 0x12, 0x41, 
+    0x16, 0x12, 0x65, 0x5f, 0x02, 0x6c, 0x37, 0x7e, 0xa0, 0xd0, 0x7e, 0x60, 0x0f, 0x12, 0x65, 0xbf, 
+    0x40, 0x0c, 0xc0, 0xf1, 0x75, 0xf1, 0x01, 0x12, 0x71, 0xe9, 0xd0, 0xf1, 0xc2, 0xd7, 0x22, 0x75, 
+    0x2f, 0xb1, 0x12, 0x7e, 0x30, 0x0a, 0x52, 0x23, 0x6d, 0x00, 0x59, 0x05, 0x00, 0x32, 0x12, 0x41, 
+    0x72, 0x12, 0x41, 0x8e, 0xd0, 0xa8, 0x22, 0x75, 0x2f, 0xb2, 0x12, 0x7e, 0x30, 0x0a, 0x22, 0x09, 
+    0xb2, 0x6a, 0x93, 0x42, 0x23, 0x7e, 0xb0, 0x9c, 0x19, 0xb2, 0x01, 0xb9, 0x12, 0x45, 0x74, 0xd0, 
+    0xa8, 0x22, 0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 0x09, 0x30, 0x00, 0x0c, 0x74, 0xbf, 0x19, 0xb0, 
+    0x00, 0x0c, 0x09, 0xb0, 0x00, 0x08, 0x19, 0x30, 0x00, 0x0c, 0x7c, 0x74, 0x5e, 0x70, 0x01, 0x68, 
+    0x12, 0x44, 0x40, 0xca, 0xb8, 0x09, 0xb0, 0x00, 0x10, 0x44, 0x02, 0x19, 0xb0, 0x00, 0x10, 0xda, 
+    0xb8, 0x80, 0x02, 0x54, 0xbf, 0x7c, 0x74, 0x5e, 0x70, 0x08, 0x68, 0x04, 0x44, 0x08, 0x80, 0x02, 
+    0x54, 0xf7, 0x09, 0x30, 0x00, 0x0c, 0xca, 0xb8, 0x74, 0xbf, 0x19, 0xb0, 0x00, 0x0c, 0xda, 0xb8, 
+    0x19, 0xb0, 0x00, 0x08, 0x19, 0x30, 0x00, 0x0c, 0x0a, 0x62, 0x09, 0xb6, 0x6a, 0x93, 0x3e, 0x20, 
+    0x0a, 0x62, 0x7c, 0x74, 0x5e, 0x70, 0x02, 0x68, 0x20, 0x42, 0x27, 0xca, 0xb8, 0x74, 0x61, 0x19, 
+    0xb0, 0x00, 0x08, 0x7e, 0x44, 0x00, 0x10, 0x59, 0x46, 0x01, 0xa9, 0x09, 0xb0, 0x00, 0x10, 0x44, 
+    0x01, 0x19, 0xb0, 0x00, 0x10, 0xda, 0xb8, 0x80, 0x11, 0xf4, 0x52, 0x27, 0x74, 0xa1, 0x19, 0xb0, 
+    0x00, 0x08, 0x7e, 0x44, 0x00, 0x38, 0x59, 0x46, 0x01, 0xa9, 0xd0, 0xa8, 0x22, 0x7c, 0x74, 0x7e, 
+    0x04, 0x80, 0x00, 0x4c, 0x02, 0x09, 0x30, 0x00, 0x0c, 0x74, 0xbf, 0x19, 0xb0, 0x00, 0x0c, 0x09, 
+    0xb0, 0x00, 0x08, 0x7c, 0x74, 0x5e, 0x70, 0x01, 0x68, 0x04, 0x44, 0x80, 0x80, 0x02, 0x54, 0x7f, 
+    0x7c, 0x74, 0x5e, 0x70, 0x08, 0x68, 0x04, 0x44, 0x02, 0x80, 0x02, 0x54, 0xfd, 0x19, 0xb0, 0x00, 
+    0x08, 0x19, 0x30, 0x00, 0x0c, 0x0a, 0x62, 0x09, 0xb6, 0x6a, 0x93, 0xa5, 0xfd, 0xf4, 0xa5, 0xfe, 
+    0xca, 0x28, 0x3e, 0x20, 0x0a, 0x62, 0xda, 0x28, 0x7c, 0x74, 0x5e, 0x70, 0x02, 0x68, 0x10, 0xa5, 
+    0xed, 0x42, 0x28, 0x42, 0x26, 0x7e, 0x44, 0x00, 0x08, 0x59, 0x46, 0x01, 0x99, 0x80, 0x04, 0xa5, 
+    0xee, 0x52, 0x28, 0x7c, 0x74, 0x5e, 0x70, 0x04, 0x68, 0x10, 0xa5, 0xed, 0x42, 0x29, 0x42, 0x26, 
+    0x7e, 0x44, 0x00, 0x08, 0x59, 0x46, 0x01, 0x99, 0x80, 0x15, 0xa5, 0xee, 0x52, 0x29, 0x7c, 0x74, 
+    0x5e, 0x70, 0x02, 0x78, 0x0a, 0x52, 0x26, 0x7e, 0x44, 0x00, 0x20, 0x59, 0x46, 0x01, 0x99, 0x12, 
+    0x42, 0x91, 0xd0, 0xa8, 0x22, 0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 0x09, 0x30, 0x00, 0x0c, 0x74, 
+    0xbf, 0x19, 0xb0, 0x00, 0x0c, 0x19, 0x40, 0x00, 0x10, 0x19, 0x30, 0x00, 0x0c, 0xd0, 0xa8, 0x22, 
+    0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 0x09, 0x30, 0x00, 0x0c, 0x74, 0xbf, 0x19, 0xb0, 0x00, 0x0c, 
+    0x19, 0x40, 0x00, 0x18, 0x19, 0x30, 0x00, 0x0c, 0xd0, 0xa8, 0x22, 0x75, 0x2f, 0xb5, 0x12, 0x7e, 
+    0x30, 0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 0x09, 0xb0, 0x00, 0x0c, 0x44, 0x40, 0x19, 0xb0, 0x00, 
+    0x0c, 0xe5, 0x58, 0xb4, 0x07, 0x23, 0x09, 0xb0, 0x00, 0x10, 0x4e, 0xb0, 0x02, 0x19, 0xb0, 0x00, 
+    0x10, 0x09, 0x30, 0x00, 0x0c, 0x74, 0xbf, 0x19, 0xb0, 0x00, 0x0c, 0x09, 0xb0, 0x00, 0x04, 0x54, 
+    0xf7, 0x19, 0xb0, 0x00, 0x04, 0x19, 0x30, 0x00, 0x0c, 0xd0, 0xa8, 0x22, 0x75, 0x2f, 0xb6, 0x12, 
+    0x7e, 0x30, 0x7e, 0x04, 0x80, 0x00, 0x4c, 0x02, 0xe5, 0x58, 0xb4, 0x07, 0x18, 0x09, 0x30, 0x00, 
+    0x0c, 0x74, 0xbf, 0x19, 0xb0, 0x00, 0x0c, 0x09, 0xb0, 0x00, 0x04, 0x44, 0x08, 0x19, 0xb0, 0x00, 
+    0x04, 0x19, 0x30, 0x00, 0x0c, 0x09, 0xb0, 0x00, 0x0c, 0x54, 0xbf, 0x19, 0xb0, 0x00, 0x0c, 0xd0, 
+    0xa8, 0x22, 0x75, 0x2f, 0xb4, 0x12, 0x7e, 0x30, 0x7a, 0x21, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x41, 
+    0x2f, 0x12, 0x7e, 0x30, 0x7e, 0xb0, 0x01, 0x7e, 0xa0, 0xc8, 0x7c, 0x64, 0x12, 0x65, 0xbf, 0xc0, 
+    0xf1, 0x75, 0xf1, 0x01, 0x12, 0x71, 0xe9, 0xd0, 0xf1, 0xd0, 0xa8, 0x22, 0x6e, 0x9c, 0x6e, 0xe3, 
+    0x6f, 0x2a, 0x6f, 0x71, 0x6f, 0xb8, 0x6f, 0xff, 0x70, 0x46, 0x70, 0x8d, 0x75, 0x2f, 0x55, 0x12, 
+    0x7e, 0x30, 0x75, 0x2f, 0x00, 0x12, 0x7e, 0x30, 0x7a, 0x61, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x71, 
+    0x2f, 0x12, 0x7e, 0x30, 0x7e, 0x17, 0x01, 0x69, 0x7e, 0x27, 0x01, 0x79, 0x2d, 0x23, 0x7e, 0x09, 
+    0xb0, 0x0b, 0x04, 0x7a, 0x19, 0xb0, 0x0b, 0x14, 0xbe, 0x14, 0x0d, 0xcc, 0x38, 0x0f, 0x1b, 0x34, 
+    0x78, 0xec, 0x7a, 0x17, 0x01, 0x69, 0x7a, 0x27, 0x01, 0x79, 0x02, 0x4a, 0x98, 0x7e, 0x14, 0x09, 
+    0xcd, 0x80, 0xeb, 0x75, 0x2f, 0x55, 0x12, 0x7e, 0x30, 0x75, 0x2f, 0x01, 0x12, 0x7e, 0x30, 0x7a, 
+    0x61, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x71, 0x2f, 0x12, 0x7e, 0x30, 0x7e, 0x17, 0x01, 0x6b, 0x7e, 
+    0x27, 0x01, 0x7b, 0x2d, 0x23, 0x7e, 0x09, 0xb0, 0x0b, 0x04, 0x7a, 0x19, 0xb0, 0x0b, 0x14, 0xbe, 
+    0x14, 0x11, 0xcc, 0x38, 0x0f, 0x1b, 0x34, 0x78, 0xec, 0x7a, 0x17, 0x01, 0x6b, 0x7a, 0x27, 0x01, 
+    0x7b, 0x02, 0x4d, 0xcd, 0x7e, 0x14, 0x0d, 0xcd, 0x80, 0xeb, 0x75, 0x2f, 0x55, 0x12, 0x7e, 0x30, 
+    0x75, 0x2f, 0x02, 0x12, 0x7e, 0x30, 0x7a, 0x61, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x71, 0x2f, 0x12, 
+    0x7e, 0x30, 0x7e, 0x17, 0x01, 0x6d, 0x7e, 0x27, 0x01, 0x7d, 0x2d, 0x23, 0x7e, 0x09, 0xb0, 0x0b, 
+    0x04, 0x7a, 0x19, 0xb0, 0x0b, 0x14, 0xbe, 0x14, 0x15, 0xcc, 0x38, 0x0f, 0x1b, 0x34, 0x78, 0xec, 
+    0x7a, 0x17, 0x01, 0x6d, 0x7a, 0x27, 0x01, 0x7d, 0x02, 0x51, 0x02, 0x7e, 0x14, 0x11, 0xcd, 0x80, 
+    0xeb, 0x75, 0x2f, 0x55, 0x12, 0x7e, 0x30, 0x75, 0x2f, 0x03, 0x12, 0x7e, 0x30, 0x7a, 0x61, 0x2f, 
+    0x12, 0x7e, 0x30, 0x7a, 0x71, 0x2f, 0x12, 0x7e, 0x30, 0x7e, 0x17, 0x01, 0x6f, 0x7e, 0x27, 0x01, 
+    0x7f, 0x2d, 0x23, 0x7e, 0x09, 0xb0, 0x0b, 0x04, 0x7a, 0x19, 0xb0, 0x0b, 0x14, 0xbe, 0x14, 0x19, 
+    0xcc, 0x38, 0x0f, 0x1b, 0x34, 0x78, 0xec, 0x7a, 0x17, 0x01, 0x6f, 0x7a, 0x27, 0x01, 0x7f, 0x02, 
+    0x54, 0x37, 0x7e, 0x14, 0x15, 0xcd, 0x80, 0xeb, 0x75, 0x2f, 0x55, 0x12, 0x7e, 0x30, 0x75, 0x2f, 
+    0x04, 0x12, 0x7e, 0x30, 0x7a, 0x61, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x71, 0x2f, 0x12, 0x7e, 0x30, 
+    0x7e, 0x17, 0x01, 0x71, 0x7e, 0x27, 0x01, 0x81, 0x2d, 0x23, 0x7e, 0x09, 0xb0, 0x0b, 0x04, 0x7a, 
+    0x19, 0xb0, 0x0b, 0x14, 0xbe, 0x14, 0x1d, 0xcc, 0x38, 0x0f, 0x1b, 0x34, 0x78, 0xec, 0x7a, 0x17, 
+    0x01, 0x71, 0x7a, 0x27, 0x01, 0x81, 0x02, 0x57, 0x6c, 0x7e, 0x14, 0x19, 0xcd, 0x80, 0xeb, 0x75, 
+    0x2f, 0x55, 0x12, 0x7e, 0x30, 0x75, 0x2f, 0x05, 0x12, 0x7e, 0x30, 0x7a, 0x61, 0x2f, 0x12, 0x7e, 
+    0x30, 0x7a, 0x71, 0x2f, 0x12, 0x7e, 0x30, 0x7e, 0x17, 0x01, 0x73, 0x7e, 0x27, 0x01, 0x83, 0x2d, 
+    0x23, 0x7e, 0x09, 0xb0, 0x0b, 0x04, 0x7a, 0x19, 0xb0, 0x0b, 0x14, 0xbe, 0x14, 0x21, 0xcc, 0x38, 
+    0x0f, 0x1b, 0x34, 0x78, 0xec, 0x7a, 0x17, 0x01, 0x73, 0x7a, 0x27, 0x01, 0x83, 0x02, 0x5a, 0xa1, 
+    0x7e, 0x14, 0x1d, 0xcd, 0x80, 0xeb, 0x75, 0x2f, 0x55, 0x12, 0x7e, 0x30, 0x75, 0x2f, 0x06, 0x12, 
+    0x7e, 0x30, 0x7a, 0x61, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x71, 0x2f, 0x12, 0x7e, 0x30, 0x7e, 0x17, 
+    0x01, 0x75, 0x7e, 0x27, 0x01, 0x85, 0x2d, 0x23, 0x7e, 0x09, 0xb0, 0x0b, 0x04, 0x7a, 0x19, 0xb0, 
+    0x0b, 0x14, 0xbe, 0x14, 0x25, 0xcc, 0x38, 0x0f, 0x1b, 0x34, 0x78, 0xec, 0x7a, 0x17, 0x01, 0x75, 
+    0x7a, 0x27, 0x01, 0x85, 0x02, 0x5d, 0xd6, 0x7e, 0x14, 0x21, 0xcd, 0x80, 0xeb, 0x75, 0x2f, 0x55, 
+    0x12, 0x7e, 0x30, 0x75, 0x2f, 0x07, 0x12, 0x7e, 0x30, 0x7a, 0x61, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 
+    0x71, 0x2f, 0x12, 0x7e, 0x30, 0x7e, 0x17, 0x01, 0x77, 0x7e, 0x27, 0x01, 0x87, 0x2d, 0x23, 0x7e, 
+    0x09, 0xb0, 0x0b, 0x04, 0x7a, 0x19, 0xb0, 0x0b, 0x14, 0xbe, 0x14, 0x29, 0xcc, 0x38, 0x0f, 0x1b, 
+    0x34, 0x78, 0xec, 0x7a, 0x17, 0x01, 0x77, 0x7a, 0x27, 0x01, 0x87, 0x02, 0x61, 0x0b, 0x7e, 0x14, 
+    0x25, 0xcd, 0x80, 0xeb, 0xca, 0xb8, 0xc0, 0xf1, 0x75, 0x2f, 0x02, 0x12, 0x7e, 0x30, 0xe5, 0xc0, 
+    0x54, 0x03, 0x68, 0x05, 0x12, 0x77, 0xdd, 0x80, 0xf5, 0x30, 0xc2, 0x08, 0x75, 0xf1, 0x01, 0x12, 
+    0x71, 0xe9, 0x80, 0x14, 0x30, 0xc3, 0x08, 0x75, 0xf1, 0x01, 0x12, 0x71, 0x0d, 0x80, 0x09, 0x30, 
+    0xc4, 0x06, 0x75, 0xf1, 0x02, 0x12, 0x72, 0xf9, 0xd0, 0xf1, 0xda, 0xb8, 0x32, 0x75, 0x2f, 0x10, 
+    0x12, 0x7e, 0x30, 0xca, 0x0b, 0xca, 0x39, 0xca, 0x59, 0xc2, 0xc3, 0xa9, 0x21, 0xe2, 0x5c, 0xe5, 
+    0xe5, 0x54, 0xc0, 0x68, 0x4f, 0xe5, 0xe6, 0x6c, 0xaa, 0x7e, 0x37, 0x01, 0xc5, 0x2d, 0x35, 0xbe, 
+    0x34, 0x04, 0x00, 0x38, 0x4a, 0x7a, 0x37, 0x01, 0xc5, 0x7e, 0x37, 0x01, 0xc3, 0x7d, 0x43, 0x2d, 
+    0x45, 0xbe, 0x44, 0x09, 0xcc, 0x38, 0x40, 0x7a, 0x47, 0x01, 0xc3, 0x75, 0x2f, 0x11, 0x12, 0x7e, 
+    0x30, 0x7a, 0xb1, 0x2f, 0x12, 0x7e, 0x30, 0x12, 0x73, 0xc8, 0xa9, 0x21, 0xe5, 0x1f, 0xa9, 0xd4, 
     0xe4, 0xa9, 0x24, 0xe4, 0xfc, 0xc2, 0xc3, 0xa9, 0x21, 0xe2, 0x3b, 0xe5, 0xe5, 0x54, 0xc0, 0x78, 
-    0xb4, 0x12, 0x74, 0x5a, 0xda, 0x59, 0xda, 0x39, 0xda, 0x0b, 0x22, 0x80, 0x29, 0x80, 0x58, 0x75, 
-    0x31, 0x16, 0x12, 0x7c, 0x15, 0x80, 0xed, 0x75, 0x31, 0x12, 0x12, 0x7c, 0x15, 0x7a, 0xb1, 0x31, 
-    0x12, 0x7c, 0x15, 0x9e, 0x44, 0x09, 0xe3, 0x9d, 0x54, 0x12, 0x71, 0xb8, 0x7e, 0x34, 0x05, 0xe3, 
-    0x7d, 0x54, 0x2d, 0x43, 0x80, 0xa1, 0xe5, 0xe5, 0x54, 0x03, 0x78, 0x12, 0x75, 0x31, 0x13, 0x12, 
-    0x7c, 0x15, 0x7e, 0x0f, 0x29, 0xff, 0x0b, 0x0c, 0x7a, 0x0f, 0x29, 0xff, 0x80, 0xa7, 0x75, 0x31, 
-    0x14, 0x12, 0x7c, 0x15, 0x7e, 0x0f, 0x2a, 0x03, 0x0b, 0x0c, 0x7a, 0x0f, 0x2a, 0x03, 0xa9, 0xd7, 
-    0xe4, 0xa9, 0x27, 0xe4, 0xfc, 0x80, 0x9d, 0x75, 0x31, 0x15, 0x12, 0x7c, 0x15, 0x7e, 0x0f, 0x2a, 
-    0x07, 0x0b, 0x0c, 0x7a, 0x0f, 0x2a, 0x07, 0x80, 0xe5, 0x75, 0x31, 0x18, 0x12, 0x7c, 0x15, 0xca, 
+    0xb4, 0x12, 0x76, 0x6a, 0xda, 0x59, 0xda, 0x39, 0xda, 0x0b, 0x22, 0x80, 0x29, 0x80, 0x58, 0x75, 
+    0x2f, 0x16, 0x12, 0x7e, 0x30, 0x80, 0xed, 0x75, 0x2f, 0x12, 0x12, 0x7e, 0x30, 0x7a, 0xb1, 0x2f, 
+    0x12, 0x7e, 0x30, 0x9e, 0x44, 0x09, 0xcd, 0x9d, 0x54, 0x12, 0x73, 0xc8, 0x7e, 0x34, 0x05, 0xcd, 
+    0x7d, 0x54, 0x2d, 0x43, 0x80, 0xa1, 0xe5, 0xe5, 0x54, 0x03, 0x78, 0x12, 0x75, 0x2f, 0x13, 0x12, 
+    0x7e, 0x30, 0x7e, 0x0f, 0x29, 0xe9, 0x0b, 0x0c, 0x7a, 0x0f, 0x29, 0xe9, 0x80, 0xa7, 0x75, 0x2f, 
+    0x14, 0x12, 0x7e, 0x30, 0x7e, 0x0f, 0x29, 0xed, 0x0b, 0x0c, 0x7a, 0x0f, 0x29, 0xed, 0xa9, 0xd7, 
+    0xe4, 0xa9, 0x27, 0xe4, 0xfc, 0x80, 0x9d, 0x75, 0x2f, 0x15, 0x12, 0x7e, 0x30, 0x7e, 0x0f, 0x29, 
+    0xf1, 0x0b, 0x0c, 0x7a, 0x0f, 0x29, 0xf1, 0x80, 0xe5, 0x75, 0x2f, 0x18, 0x12, 0x7e, 0x30, 0xca, 
     0x09, 0xca, 0x39, 0xca, 0x2b, 0xc2, 0xc2, 0xa9, 0x21, 0xf2, 0x52, 0xe5, 0xf5, 0x33, 0x82, 0xe7, 
-    0x40, 0x44, 0x7e, 0x37, 0x01, 0xe1, 0x7e, 0x54, 0x00, 0x40, 0x9d, 0x35, 0x40, 0x43, 0x7a, 0x37, 
-    0x01, 0xe1, 0x7e, 0x37, 0x01, 0xdd, 0x7d, 0x43, 0x2d, 0x45, 0xbe, 0x44, 0x05, 0xe2, 0x38, 0x52, 
-    0x7a, 0x47, 0x01, 0xdd, 0x7d, 0x45, 0x12, 0x73, 0x16, 0xa9, 0x20, 0xf5, 0x22, 0x75, 0x31, 0x19, 
-    0x12, 0x7c, 0x15, 0x7a, 0x91, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x81, 0xf7, 0x7a, 0x91, 0xf6, 0xe5, 
+    0x40, 0x44, 0x7e, 0x37, 0x01, 0xcb, 0x7e, 0x54, 0x00, 0x40, 0x9d, 0x35, 0x40, 0x43, 0x7a, 0x37, 
+    0x01, 0xcb, 0x7e, 0x37, 0x01, 0xc7, 0x7d, 0x43, 0x2d, 0x45, 0xbe, 0x44, 0x05, 0xcc, 0x38, 0x52, 
+    0x7a, 0x47, 0x01, 0xc7, 0x7d, 0x45, 0x12, 0x75, 0x26, 0xa9, 0x20, 0xf5, 0x22, 0x75, 0x2f, 0x19, 
+    0x12, 0x7e, 0x30, 0x7a, 0x91, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x81, 0xf7, 0x7a, 0x91, 0xf6, 0xe5, 
     0xf5, 0x33, 0x82, 0xe7, 0x50, 0xbc, 0xda, 0x2b, 0xda, 0x39, 0xda, 0x09, 0x22, 0x80, 0x41, 0x80, 
-    0x64, 0x2d, 0x53, 0x6d, 0x33, 0x70, 0xb7, 0x7e, 0x04, 0x01, 0xe3, 0x7a, 0x07, 0x01, 0xdf, 0x7a, 
-    0x07, 0x01, 0xdd, 0xa9, 0x32, 0xf2, 0xdf, 0x85, 0x30, 0x31, 0x12, 0x7c, 0x15, 0x75, 0xf6, 0x00, 
-    0x80, 0xd4, 0xca, 0x59, 0x9e, 0x44, 0x05, 0xe3, 0x9d, 0x54, 0x12, 0x73, 0x16, 0x7e, 0x34, 0x01, 
-    0xe3, 0x7d, 0x54, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xdd, 0x12, 0x73, 0x16, 0xda, 0x49, 0x80, 0x99, 
-    0xe5, 0xf5, 0x54, 0x03, 0x78, 0x1f, 0x7e, 0x0f, 0x29, 0xef, 0x0b, 0x0c, 0x7a, 0x0f, 0x29, 0xef, 
-    0x80, 0x9d, 0x7e, 0x0f, 0x29, 0xf7, 0x0b, 0x0c, 0x7a, 0x0f, 0x29, 0xf7, 0xa9, 0xd7, 0xf4, 0xa9, 
-    0x27, 0xf4, 0xfc, 0x80, 0x8a, 0x7e, 0x0f, 0x29, 0xf3, 0x0b, 0x0c, 0x7a, 0x0f, 0x29, 0xf3, 0x80, 
-    0xeb, 0xe5, 0xf5, 0x54, 0x03, 0x78, 0x1f, 0x7e, 0x2f, 0x2a, 0x0f, 0x0b, 0x2c, 0x7a, 0x2f, 0x2a, 
-    0x0f, 0x80, 0x34, 0x7e, 0x2f, 0x2a, 0x17, 0x0b, 0x2c, 0x7a, 0x2f, 0x2a, 0x17, 0xa9, 0xd7, 0xf4, 
-    0xa9, 0x27, 0xf4, 0xfc, 0x80, 0x21, 0x7e, 0x2f, 0x2a, 0x13, 0x0b, 0x2c, 0x7a, 0x2f, 0x2a, 0x13, 
-    0x80, 0xeb, 0xda, 0x2b, 0xda, 0x1b, 0xda, 0x0b, 0x22, 0x75, 0x31, 0x28, 0x12, 0x7c, 0x15, 0xca, 
+    0x64, 0x2d, 0x53, 0x6d, 0x33, 0x70, 0xb7, 0x7e, 0x04, 0x01, 0xcd, 0x7a, 0x07, 0x01, 0xc9, 0x7a, 
+    0x07, 0x01, 0xc7, 0xa9, 0x32, 0xf2, 0xdf, 0x85, 0x30, 0x2f, 0x12, 0x7e, 0x30, 0x75, 0xf6, 0x00, 
+    0x80, 0xd4, 0xca, 0x59, 0x9e, 0x44, 0x05, 0xcd, 0x9d, 0x54, 0x12, 0x75, 0x26, 0x7e, 0x34, 0x01, 
+    0xcd, 0x7d, 0x54, 0x2d, 0x43, 0x7a, 0x47, 0x01, 0xc7, 0x12, 0x75, 0x26, 0xda, 0x49, 0x80, 0x99, 
+    0xe5, 0xf5, 0x54, 0x03, 0x78, 0x1f, 0x7e, 0x0f, 0x29, 0xd9, 0x0b, 0x0c, 0x7a, 0x0f, 0x29, 0xd9, 
+    0x80, 0x9d, 0x7e, 0x0f, 0x29, 0xe1, 0x0b, 0x0c, 0x7a, 0x0f, 0x29, 0xe1, 0xa9, 0xd7, 0xf4, 0xa9, 
+    0x27, 0xf4, 0xfc, 0x80, 0x8a, 0x7e, 0x0f, 0x29, 0xdd, 0x0b, 0x0c, 0x7a, 0x0f, 0x29, 0xdd, 0x80, 
+    0xeb, 0xe5, 0xf5, 0x54, 0x03, 0x78, 0x1f, 0x7e, 0x2f, 0x29, 0xf9, 0x0b, 0x2c, 0x7a, 0x2f, 0x29, 
+    0xf9, 0x80, 0x34, 0x7e, 0x2f, 0x2a, 0x01, 0x0b, 0x2c, 0x7a, 0x2f, 0x2a, 0x01, 0xa9, 0xd7, 0xf4, 
+    0xa9, 0x27, 0xf4, 0xfc, 0x80, 0x21, 0x7e, 0x2f, 0x29, 0xfd, 0x0b, 0x2c, 0x7a, 0x2f, 0x29, 0xfd, 
+    0x80, 0xeb, 0xda, 0x2b, 0xda, 0x1b, 0xda, 0x0b, 0x22, 0x75, 0x2f, 0x28, 0x12, 0x7e, 0x30, 0xca, 
     0x0b, 0xca, 0x1b, 0xca, 0x2b, 0xc2, 0xc4, 0xa9, 0x21, 0xf2, 0xb6, 0xe5, 0xf5, 0x33, 0x72, 0xe7, 
-    0x40, 0xe0, 0x7e, 0x0d, 0x46, 0x7e, 0x1d, 0x4a, 0x7e, 0x2d, 0x4e, 0x7e, 0x3d, 0x52, 0x7e, 0x85, 
-    0x56, 0x7d, 0x90, 0x4d, 0x91, 0x4d, 0x92, 0x4d, 0x93, 0x4d, 0x94, 0x4d, 0x95, 0x4d, 0x96, 0x4d, 
+    0x40, 0xe0, 0x7e, 0x0d, 0x30, 0x7e, 0x1d, 0x34, 0x7e, 0x2d, 0x38, 0x7e, 0x3d, 0x3c, 0x7e, 0x85, 
+    0x40, 0x7d, 0x90, 0x4d, 0x91, 0x4d, 0x92, 0x4d, 0x93, 0x4d, 0x94, 0x4d, 0x95, 0x4d, 0x96, 0x4d, 
     0x97, 0x4d, 0x98, 0x68, 0x72, 0x7a, 0x11, 0xf3, 0x7a, 0x01, 0xf3, 0x7a, 0x31, 0xf3, 0x7a, 0x21, 
     0xf3, 0x7a, 0x51, 0xf3, 0x7a, 0x41, 0xf3, 0x7a, 0x71, 0xf3, 0x7a, 0x61, 0xf3, 0x7a, 0x91, 0xf3, 
-    0x7a, 0x81, 0xf3, 0x30, 0x7b, 0x1a, 0x7a, 0xb1, 0xf3, 0x7a, 0xa1, 0xf3, 0x7a, 0xd1, 0xf3, 0x7a, 
+    0x7a, 0x81, 0xf3, 0x30, 0x73, 0x1a, 0x7a, 0xb1, 0xf3, 0x7a, 0xa1, 0xf3, 0x7a, 0xd1, 0xf3, 0x7a, 
     0xc1, 0xf3, 0x7a, 0xf1, 0xf3, 0x7a, 0xe1, 0xf3, 0x7d, 0x78, 0x7a, 0xf1, 0xf3, 0x7a, 0xe1, 0xf3, 
-    0xa9, 0x30, 0xf5, 0x03, 0x02, 0x70, 0xd6, 0x75, 0x31, 0x29, 0x12, 0x7c, 0x15, 0x20, 0x7b, 0x0b, 
-    0x75, 0x31, 0x0a, 0x12, 0x7c, 0x15, 0x75, 0xf6, 0x0a, 0x80, 0x09, 0x75, 0x31, 0x12, 0x12, 0x7c, 
-    0x15, 0x75, 0xf6, 0x12, 0x6d, 0x00, 0x7d, 0x10, 0x7a, 0x0d, 0x46, 0x7a, 0x0d, 0x4a, 0x7a, 0x0d, 
-    0x4e, 0x7a, 0x0d, 0x52, 0x7a, 0x05, 0x56, 0xda, 0x2b, 0xda, 0x1b, 0xda, 0x0b, 0x22, 0x1e, 0xb0, 
-    0x40, 0x0c, 0x7e, 0xa0, 0x0a, 0xa4, 0x7e, 0x04, 0x72, 0xfb, 0x9d, 0x05, 0x89, 0x04, 0x7e, 0xa1, 
+    0xa9, 0x30, 0xf5, 0x03, 0x02, 0x72, 0xe6, 0x75, 0x2f, 0x29, 0x12, 0x7e, 0x30, 0x20, 0x73, 0x0b, 
+    0x75, 0x2f, 0x0a, 0x12, 0x7e, 0x30, 0x75, 0xf6, 0x0a, 0x80, 0x09, 0x75, 0x2f, 0x12, 0x12, 0x7e, 
+    0x30, 0x75, 0xf6, 0x12, 0x6d, 0x00, 0x7d, 0x10, 0x7a, 0x0d, 0x30, 0x7a, 0x0d, 0x34, 0x7a, 0x0d, 
+    0x38, 0x7a, 0x0d, 0x3c, 0x7a, 0x05, 0x40, 0xda, 0x2b, 0xda, 0x1b, 0xda, 0x0b, 0x22, 0x1e, 0xb0, 
+    0x40, 0x0c, 0x7e, 0xa0, 0x0a, 0xa4, 0x7e, 0x04, 0x75, 0x0b, 0x9d, 0x05, 0x89, 0x04, 0x7e, 0xa1, 
     0xe3, 0x7a, 0x39, 0xa0, 0x0b, 0x34, 0x80, 0xea, 0xb4, 0x40, 0xe3, 0x7e, 0xa1, 0xe3, 0xe5, 0xe3, 
     0x1b, 0x38, 0x50, 0x0b, 0x35, 0x7e, 0xa1, 0xe3, 0xe5, 0xe3, 0x1b, 0x38, 0x50, 0x0b, 0x35, 0x7e, 
     0xa1, 0xe3, 0xe5, 0xe3, 0x1b, 0x38, 0x50, 0x0b, 0x35, 0x7e, 0xa1, 0xe3, 0xe5, 0xe3, 0x1b, 0x38, 
@@ -1044,7 +937,7 @@
     0x50, 0x0b, 0x35, 0x7e, 0xa1, 0xe3, 0xe5, 0xe3, 0x1b, 0x38, 0x50, 0x0b, 0x35, 0x7e, 0xa1, 0xe3, 
     0xe5, 0xe3, 0x1b, 0x38, 0x50, 0x0b, 0x35, 0x7e, 0xa1, 0xe3, 0xe5, 0xe3, 0x1b, 0x38, 0x50, 0x0b, 
     0x35, 0x7e, 0xa1, 0xe3, 0xe5, 0xe3, 0x1b, 0x38, 0x50, 0x0b, 0x35, 0x22, 0x1e, 0xb0, 0x40, 0x0c, 
-    0x7e, 0xa0, 0x0a, 0xa4, 0x7e, 0x04, 0x74, 0x59, 0x9d, 0x05, 0x89, 0x04, 0x7e, 0x39, 0xa0, 0x7a, 
+    0x7e, 0xa0, 0x0a, 0xa4, 0x7e, 0x04, 0x76, 0x69, 0x9d, 0x05, 0x89, 0x04, 0x7e, 0x39, 0xa0, 0x7a, 
     0xa1, 0xf3, 0x0b, 0x34, 0x80, 0xea, 0xb4, 0x40, 0xe3, 0x0b, 0x38, 0x50, 0x7a, 0xa1, 0xf3, 0xf5, 
     0xf3, 0x0b, 0x35, 0x0b, 0x38, 0x50, 0x7a, 0xa1, 0xf3, 0xf5, 0xf3, 0x0b, 0x35, 0x0b, 0x38, 0x50, 
     0x7a, 0xa1, 0xf3, 0xf5, 0xf3, 0x0b, 0x35, 0x0b, 0x38, 0x50, 0x7a, 0xa1, 0xf3, 0xf5, 0xf3, 0x0b, 
@@ -1065,144 +958,144 @@
     0x7a, 0xa1, 0xf3, 0xf5, 0xf3, 0x0b, 0x35, 0x0b, 0x38, 0x50, 0x7a, 0xa1, 0xf3, 0xf5, 0xf3, 0x0b, 
     0x35, 0x0b, 0x38, 0x50, 0x7a, 0xa1, 0xf3, 0xf5, 0xf3, 0x0b, 0x35, 0x0b, 0x38, 0x50, 0x7a, 0xa1, 
     0xf3, 0xf5, 0xf3, 0x0b, 0x35, 0x0b, 0x38, 0x50, 0x7a, 0xa1, 0xf3, 0xf5, 0xf3, 0x0b, 0x35, 0x0b, 
-    0x38, 0x50, 0x7a, 0xa1, 0xf3, 0xf5, 0xf3, 0x0b, 0x35, 0x22, 0xc2, 0xaf, 0x7e, 0x37, 0x01, 0xdb, 
-    0x4d, 0x33, 0x68, 0x3b, 0x7e, 0x07, 0x01, 0xd7, 0x7e, 0x54, 0x09, 0xe3, 0x9d, 0x50, 0xbd, 0x35, 
-    0x40, 0x02, 0x7d, 0x35, 0xca, 0x39, 0x7e, 0x65, 0x61, 0x99, 0x64, 0xda, 0x39, 0x7e, 0x07, 0x01, 
-    0xdb, 0x9d, 0x03, 0x7a, 0x07, 0x01, 0xdb, 0x2e, 0x37, 0x01, 0xd7, 0x7a, 0x37, 0x01, 0xd7, 0xbe, 
-    0x34, 0x09, 0xe2, 0x28, 0xc7, 0x7e, 0x34, 0x05, 0xe3, 0x7a, 0x37, 0x01, 0xd7, 0x80, 0xbd, 0xd2, 
-    0xaf, 0x22, 0x75, 0x31, 0x53, 0x12, 0x7c, 0x15, 0x7e, 0x15, 0x63, 0x80, 0x11, 0x75, 0x31, 0x51, 
-    0x12, 0x7c, 0x15, 0x0b, 0x08, 0x10, 0x0b, 0x05, 0x9e, 0x34, 0x00, 0x02, 0x28, 0x4d, 0x7c, 0xb2, 
-    0x20, 0xe7, 0x27, 0x54, 0x07, 0x23, 0x0a, 0x2b, 0x49, 0x22, 0x6c, 0x7c, 0x7c, 0xb2, 0x54, 0x78, 
-    0x03, 0x03, 0x03, 0x7c, 0x2b, 0x9d, 0x13, 0x40, 0x1a, 0x68, 0x12, 0x7a, 0x15, 0x63, 0x7a, 0x25, 
-    0x65, 0x7e, 0x64, 0x75, 0x37, 0x7a, 0x65, 0x61, 0x89, 0x24, 0x02, 0x75, 0x45, 0x7e, 0x64, 0x74, 
-    0xad, 0x80, 0xf2, 0x2d, 0x13, 0x9d, 0x31, 0xca, 0x39, 0x7d, 0x31, 0x2d, 0x10, 0xca, 0x19, 0xca, 
-    0x29, 0x99, 0x24, 0xda, 0x29, 0xda, 0x09, 0xda, 0x39, 0x80, 0xa2, 0x7a, 0x15, 0x63, 0x7e, 0x64, 
-    0x75, 0x23, 0x4d, 0x33, 0x78, 0x09, 0x7c, 0xb2, 0x20, 0xe7, 0x2a, 0x7e, 0x64, 0x74, 0xa2, 0x7a, 
-    0x65, 0x61, 0x22, 0x75, 0x31, 0x52, 0x12, 0x7c, 0x15, 0x7e, 0x21, 0x63, 0x7e, 0x09, 0x30, 0x0b, 
-    0x04, 0x1b, 0x34, 0x78, 0x89, 0x80, 0xd4, 0x75, 0x31, 0x54, 0x12, 0x7c, 0x15, 0x7e, 0x15, 0x63, 
-    0x7e, 0x25, 0x65, 0x80, 0x90, 0x5e, 0x20, 0x07, 0x54, 0x78, 0x7e, 0x44, 0x75, 0xc1, 0x30, 0xe6, 
-    0x16, 0x4d, 0x33, 0x68, 0x26, 0x1b, 0x34, 0x7e, 0x09, 0x40, 0x0b, 0x04, 0x7e, 0x44, 0x67, 0x63, 
-    0x20, 0xe3, 0x04, 0x7e, 0x44, 0x75, 0xc9, 0xca, 0x09, 0xca, 0x39, 0x99, 0x44, 0xda, 0x39, 0xda, 
-    0x09, 0x7e, 0x64, 0x74, 0xad, 0x4d, 0x33, 0x68, 0xa6, 0x89, 0x64, 0x7a, 0x15, 0x63, 0xf5, 0x65, 
-    0x7e, 0x64, 0x75, 0x86, 0x80, 0x99, 0x7e, 0x15, 0x63, 0xe5, 0x65, 0x80, 0xc4, 0xc0, 0xd0, 0xc0, 
-    0xd1, 0xc0, 0xe0, 0xca, 0x19, 0xa9, 0x20, 0xdf, 0x12, 0xa9, 0x21, 0xdf, 0x1b, 0x75, 0x31, 0x01, 
-    0x12, 0x7c, 0x15, 0x53, 0xdf, 0xf7, 0x12, 0x40, 0xdc, 0x80, 0x0d, 0x75, 0x31, 0xfe, 0x12, 0x7c, 
-    0x15, 0x7e, 0x14, 0x00, 0x53, 0x02, 0x40, 0x51, 0xda, 0x19, 0xd0, 0xe0, 0xd0, 0xd1, 0xd0, 0xd0, 
-    0x32, 0x03, 0xa5, 0xcb, 0x19, 0xb1, 0x80, 0x00, 0x22, 0x22, 0x02, 0x76, 0x42, 0xca, 0x0b, 0xca, 
+    0x38, 0x50, 0x7a, 0xa1, 0xf3, 0xf5, 0xf3, 0x0b, 0x35, 0x22, 0xc2, 0xaf, 0x7e, 0x37, 0x01, 0xc5, 
+    0x4d, 0x33, 0x68, 0x3b, 0x7e, 0x07, 0x01, 0xc1, 0x7e, 0x54, 0x09, 0xcd, 0x9d, 0x50, 0xbd, 0x35, 
+    0x40, 0x02, 0x7d, 0x35, 0xca, 0x39, 0x7e, 0x65, 0x4b, 0x99, 0x64, 0xda, 0x39, 0x7e, 0x07, 0x01, 
+    0xc5, 0x9d, 0x03, 0x7a, 0x07, 0x01, 0xc5, 0x2e, 0x37, 0x01, 0xc1, 0x7a, 0x37, 0x01, 0xc1, 0xbe, 
+    0x34, 0x09, 0xcc, 0x28, 0xc7, 0x7e, 0x34, 0x05, 0xcd, 0x7a, 0x37, 0x01, 0xc1, 0x80, 0xbd, 0xd2, 
+    0xaf, 0x22, 0x75, 0x2f, 0x53, 0x12, 0x7e, 0x30, 0x7e, 0x15, 0x4d, 0x80, 0x11, 0x75, 0x2f, 0x51, 
+    0x12, 0x7e, 0x30, 0x0b, 0x08, 0x10, 0x0b, 0x05, 0x9e, 0x34, 0x00, 0x02, 0x28, 0x4d, 0x7c, 0xb2, 
+    0x20, 0xe7, 0x27, 0x54, 0x07, 0x23, 0x0a, 0x2b, 0x49, 0x22, 0x6e, 0x8c, 0x7c, 0xb2, 0x54, 0x78, 
+    0x03, 0x03, 0x03, 0x7c, 0x2b, 0x9d, 0x13, 0x40, 0x1a, 0x68, 0x12, 0x7a, 0x15, 0x4d, 0x7a, 0x25, 
+    0x4f, 0x7e, 0x64, 0x77, 0x47, 0x7a, 0x65, 0x4b, 0x89, 0x24, 0x02, 0x77, 0x55, 0x7e, 0x64, 0x76, 
+    0xbd, 0x80, 0xf2, 0x2d, 0x13, 0x9d, 0x31, 0xca, 0x39, 0x7d, 0x31, 0x2d, 0x10, 0xca, 0x19, 0xca, 
+    0x29, 0x99, 0x24, 0xda, 0x29, 0xda, 0x09, 0xda, 0x39, 0x80, 0xa2, 0x7a, 0x15, 0x4d, 0x7e, 0x64, 
+    0x77, 0x33, 0x4d, 0x33, 0x78, 0x09, 0x7c, 0xb2, 0x20, 0xe7, 0x2a, 0x7e, 0x64, 0x76, 0xb2, 0x7a, 
+    0x65, 0x4b, 0x22, 0x75, 0x2f, 0x52, 0x12, 0x7e, 0x30, 0x7e, 0x21, 0x4d, 0x7e, 0x09, 0x30, 0x0b, 
+    0x04, 0x1b, 0x34, 0x78, 0x89, 0x80, 0xd4, 0x75, 0x2f, 0x54, 0x12, 0x7e, 0x30, 0x7e, 0x15, 0x4d, 
+    0x7e, 0x25, 0x4f, 0x80, 0x90, 0x5e, 0x20, 0x07, 0x54, 0x78, 0x7e, 0x44, 0x77, 0xd1, 0x30, 0xe6, 
+    0x16, 0x4d, 0x33, 0x68, 0x26, 0x1b, 0x34, 0x7e, 0x09, 0x40, 0x0b, 0x04, 0x7e, 0x44, 0x6a, 0x68, 
+    0x20, 0xe3, 0x04, 0x7e, 0x44, 0x77, 0xd9, 0xca, 0x09, 0xca, 0x39, 0x99, 0x44, 0xda, 0x39, 0xda, 
+    0x09, 0x7e, 0x64, 0x76, 0xbd, 0x4d, 0x33, 0x68, 0xa6, 0x89, 0x64, 0x7a, 0x15, 0x4d, 0xf5, 0x4f, 
+    0x7e, 0x64, 0x77, 0x96, 0x80, 0x99, 0x7e, 0x15, 0x4d, 0xe5, 0x4f, 0x80, 0xc4, 0xc0, 0xd0, 0xc0, 
+    0xd1, 0xc0, 0xe0, 0xca, 0x19, 0xa9, 0x20, 0xdf, 0x12, 0xa9, 0x21, 0xdf, 0x1b, 0x75, 0x2f, 0x01, 
+    0x12, 0x7e, 0x30, 0x53, 0xdf, 0xf7, 0x12, 0x40, 0xdc, 0x80, 0x0d, 0x75, 0x2f, 0xfe, 0x12, 0x7e, 
+    0x30, 0x7e, 0x14, 0x00, 0x53, 0x02, 0x40, 0x51, 0xda, 0x19, 0xd0, 0xe0, 0xd0, 0xd1, 0xd0, 0xd0, 
+    0x32, 0x03, 0xa5, 0xcb, 0x19, 0xb1, 0x80, 0x00, 0x22, 0x22, 0x02, 0x78, 0x52, 0xca, 0x0b, 0xca, 
     0x1b, 0xca, 0x2b, 0xca, 0x3b, 0xca, 0x4b, 0xca, 0x5b, 0xca, 0x6b, 0xca, 0x7b, 0xca, 0xeb, 0xc0, 
-    0xf1, 0x7e, 0xb3, 0x2a, 0x33, 0xb4, 0x00, 0x02, 0x80, 0x19, 0xb4, 0x01, 0x16, 0x30, 0xc0, 0x08, 
-    0x75, 0xf1, 0x00, 0x12, 0x76, 0x2c, 0x80, 0x1f, 0x30, 0xc1, 0x1c, 0x75, 0xf1, 0x00, 0x12, 0x76, 
-    0xbd, 0x80, 0x14, 0x30, 0xc1, 0x08, 0x75, 0xf1, 0x00, 0x12, 0x76, 0xbd, 0x80, 0x09, 0x30, 0xc0, 
-    0x06, 0x75, 0xf1, 0x00, 0x12, 0x76, 0x2c, 0xd0, 0xf1, 0xda, 0xeb, 0xda, 0x7b, 0xda, 0x6b, 0xda, 
+    0xf1, 0x7e, 0xb3, 0x2a, 0x1d, 0xb4, 0x00, 0x02, 0x80, 0x19, 0xb4, 0x01, 0x16, 0x30, 0xc0, 0x08, 
+    0x75, 0xf1, 0x00, 0x12, 0x78, 0x3c, 0x80, 0x1f, 0x30, 0xc1, 0x1c, 0x75, 0xf1, 0x00, 0x12, 0x78, 
+    0xcd, 0x80, 0x14, 0x30, 0xc1, 0x08, 0x75, 0xf1, 0x00, 0x12, 0x78, 0xcd, 0x80, 0x09, 0x30, 0xc0, 
+    0x06, 0x75, 0xf1, 0x00, 0x12, 0x78, 0x3c, 0xd0, 0xf1, 0xda, 0xeb, 0xda, 0x7b, 0xda, 0x6b, 0xda, 
     0x5b, 0xda, 0x4b, 0xda, 0x3b, 0xda, 0x2b, 0xda, 0x1b, 0xda, 0x0b, 0x22, 0xc2, 0xc0, 0x7e, 0xb3, 
-    0x2a, 0x33, 0xb4, 0x02, 0x07, 0x12, 0x76, 0x4e, 0x02, 0x76, 0x42, 0x22, 0xb4, 0x01, 0xfc, 0x02, 
-    0x76, 0x88, 0x7e, 0x00, 0x00, 0x7a, 0x03, 0x2a, 0x33, 0x7a, 0x03, 0x2a, 0x34, 0x22, 0x7e, 0xb3, 
-    0x2a, 0x2b, 0x54, 0x60, 0x60, 0x05, 0xb4, 0x40, 0x15, 0x80, 0x13, 0x7e, 0xb3, 0x2a, 0x2c, 0xb4, 
-    0x05, 0x0c, 0x75, 0x31, 0x71, 0x12, 0x7c, 0x15, 0x7e, 0xb3, 0x2a, 0x2e, 0xf5, 0x8f, 0x22, 0x75, 
-    0xf6, 0x00, 0x22, 0xbe, 0x57, 0x2a, 0x31, 0x28, 0x04, 0x7e, 0x57, 0x2a, 0x31, 0x7a, 0x0f, 0x2a, 
-    0x36, 0x7a, 0x57, 0x2a, 0x3a, 0x02, 0x76, 0x88, 0x7e, 0xef, 0x2a, 0x36, 0x7e, 0xf7, 0x2a, 0x3a, 
-    0x7e, 0x07, 0x2a, 0x3a, 0x4d, 0x00, 0x68, 0x21, 0x7e, 0x00, 0x00, 0x7e, 0xeb, 0xb0, 0xf5, 0xf3, 
-    0xa3, 0xa5, 0x08, 0x1b, 0xf4, 0x68, 0x04, 0xa5, 0xb8, 0x08, 0xf0, 0x7a, 0xef, 0x2a, 0x36, 0x7a, 
-    0xf7, 0x2a, 0x3a, 0x75, 0x31, 0x06, 0x12, 0x7c, 0x15, 0x7a, 0x01, 0xf6, 0x22, 0xc2, 0xc1, 0x75, 
-    0x31, 0x03, 0x12, 0x7c, 0x15, 0xa9, 0x36, 0xe2, 0x16, 0xe5, 0xf5, 0x54, 0xc0, 0x68, 0x07, 0xa9, 
-    0xd7, 0xf4, 0xa9, 0x27, 0xf4, 0xfc, 0x53, 0xe1, 0x3f, 0x43, 0xf2, 0x88, 0x02, 0x77, 0x29, 0x7e, 
-    0xb3, 0x2a, 0x34, 0xb4, 0x02, 0x04, 0xa9, 0xd4, 0xe4, 0x22, 0xb4, 0x01, 0x39, 0x7e, 0x21, 0xe6, 
-    0x7c, 0x32, 0x7e, 0x13, 0x2a, 0x35, 0x2c, 0x21, 0x7a, 0x23, 0x2a, 0x35, 0x7e, 0x00, 0x00, 0x2e, 
-    0x04, 0x2a, 0x3c, 0xe5, 0xe3, 0x7a, 0x09, 0xb0, 0x0b, 0x04, 0xa5, 0xdb, 0xf6, 0xa9, 0xd4, 0xe4, 
-    0x75, 0x31, 0x70, 0x12, 0x7c, 0x15, 0x7e, 0xb3, 0x2a, 0x35, 0x7e, 0xa3, 0x2a, 0x32, 0xbc, 0xab, 
-    0x78, 0x03, 0x12, 0x77, 0xc0, 0x22, 0x02, 0x7b, 0x29, 0xe5, 0xe6, 0xb4, 0x08, 0x65, 0xa9, 0xc4, 
-    0xe2, 0x7e, 0x01, 0xe3, 0x7e, 0x11, 0xe3, 0x7e, 0x31, 0xe3, 0x7e, 0x21, 0xe3, 0x7e, 0x51, 0xe3, 
-    0x7e, 0x41, 0xe3, 0x7e, 0x71, 0xe3, 0x7e, 0x61, 0xe3, 0x7a, 0x0f, 0x2a, 0x2b, 0x7a, 0x1f, 0x2a, 
-    0x2f, 0x75, 0x31, 0x04, 0x12, 0x7c, 0x15, 0x7a, 0x01, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x11, 0x31, 
-    0x12, 0x7c, 0x15, 0x7a, 0x21, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x31, 0x31, 0x12, 0x7c, 0x15, 0x7a, 
-    0x41, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x51, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x61, 0x31, 0x12, 0x7c, 
-    0x15, 0x7a, 0x71, 0x31, 0x12, 0x7c, 0x15, 0xa9, 0xd4, 0xe4, 0xa9, 0xd7, 0xf4, 0xa9, 0xc6, 0xe2, 
-    0x12, 0x77, 0x94, 0x22, 0x6d, 0x00, 0x7e, 0x14, 0x01, 0x02, 0x7a, 0x07, 0x2a, 0x3a, 0x7a, 0x03, 
-    0x2a, 0x35, 0x7e, 0xb3, 0x2a, 0x2b, 0x20, 0xe7, 0x0f, 0x7a, 0x23, 0x2a, 0x34, 0x7a, 0x33, 0x2a, 
-    0x33, 0xbe, 0x07, 0x2a, 0x31, 0x68, 0x09, 0x22, 0x7a, 0x33, 0x2a, 0x34, 0x7a, 0x23, 0x2a, 0x33, 
-    0x7e, 0xb3, 0x2a, 0x2b, 0x54, 0xe3, 0x23, 0x23, 0x30, 0xe0, 0x02, 0xd2, 0xe5, 0x30, 0xe7, 0x02, 
-    0xd2, 0xe4, 0x30, 0xe5, 0x06, 0x30, 0xe4, 0x03, 0x02, 0x7b, 0x29, 0x54, 0x3e, 0xf5, 0xf0, 0x03, 
-    0x54, 0x1f, 0xc3, 0x25, 0xf0, 0x90, 0x77, 0xec, 0x75, 0x84, 0xff, 0x73, 0x02, 0x79, 0x40, 0x02, 
-    0x78, 0x34, 0x02, 0x79, 0xdd, 0x02, 0x79, 0xf8, 0x02, 0x78, 0xd9, 0x02, 0x78, 0x9a, 0x02, 0x7a, 
-    0x11, 0x02, 0x7a, 0x11, 0x02, 0x7a, 0x14, 0x02, 0x7a, 0x14, 0x02, 0x7a, 0x14, 0x02, 0x7a, 0x14, 
-    0x02, 0x7a, 0x14, 0x02, 0x7a, 0x14, 0x02, 0x7a, 0x14, 0x02, 0x7a, 0x14, 0x02, 0x7a, 0x1a, 0x02, 
-    0x7a, 0xce, 0x02, 0x7a, 0x17, 0x02, 0x7a, 0x17, 0x02, 0x7a, 0x17, 0x02, 0x7a, 0x17, 0x02, 0x7a, 
-    0x17, 0x02, 0x7a, 0x17, 0x7e, 0xb3, 0x2a, 0x2c, 0xb4, 0x06, 0x2a, 0x7e, 0xb3, 0x2a, 0x2d, 0x60, 
-    0x56, 0x7c, 0x0b, 0x7e, 0x13, 0x2a, 0x2e, 0x7e, 0x17, 0x2a, 0x2f, 0x75, 0x31, 0x72, 0x12, 0x7c, 
-    0x15, 0x7a, 0x01, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x11, 0x31, 0x12, 0x7c, 0x15, 0x12, 0x7b, 0x33, 
-    0x40, 0x35, 0x02, 0x76, 0x73, 0xb4, 0x08, 0x10, 0x75, 0x31, 0x74, 0x12, 0x7c, 0x15, 0x7e, 0xb3, 
-    0x3f, 0xf1, 0xf5, 0xf3, 0x75, 0xf6, 0x01, 0x22, 0xb4, 0x00, 0x1c, 0x75, 0x31, 0x75, 0x12, 0x7c, 
-    0x15, 0x7e, 0xb3, 0x3f, 0xf2, 0x30, 0xe0, 0x05, 0x75, 0xf3, 0x02, 0x80, 0x03, 0x75, 0xf3, 0x00, 
-    0x75, 0xf3, 0x00, 0x75, 0xf6, 0x02, 0x22, 0x02, 0x7b, 0x29, 0x7e, 0xb3, 0x2a, 0x2c, 0xb4, 0x00, 
-    0x35, 0x75, 0x31, 0x76, 0x12, 0x7c, 0x15, 0x7e, 0xb3, 0x2a, 0x30, 0x54, 0x0f, 0xf5, 0xf1, 0x7e, 
-    0xb3, 0x2a, 0x30, 0x20, 0xe7, 0x09, 0xe5, 0xe1, 0x30, 0xe7, 0x0d, 0x74, 0x01, 0x80, 0x0b, 0xe5, 
-    0xe1, 0x30, 0xe6, 0x04, 0x74, 0x01, 0x80, 0x02, 0x74, 0x00, 0x53, 0xf1, 0x80, 0xf5, 0xf3, 0x75, 
-    0xf3, 0x00, 0x75, 0xf6, 0x02, 0x22, 0x02, 0x7b, 0x29, 0xc0, 0xf1, 0x7e, 0xb3, 0x2a, 0x30, 0x54, 
-    0x0f, 0x42, 0xf1, 0x7e, 0xb3, 0x2a, 0x2e, 0xb4, 0x00, 0x45, 0x7e, 0xb3, 0x2a, 0x2c, 0xb4, 0x01, 
-    0x24, 0x75, 0x31, 0x77, 0x12, 0x7c, 0x15, 0x7e, 0xb3, 0x2a, 0x30, 0x54, 0x0f, 0x78, 0x05, 0x53, 
-    0xe1, 0x3f, 0x80, 0x37, 0x7e, 0xb3, 0x2a, 0x30, 0x20, 0xe7, 0x05, 0x53, 0xe1, 0x7f, 0x80, 0x2b, 
-    0x53, 0xe1, 0xbf, 0x80, 0x26, 0xb4, 0x03, 0x17, 0x75, 0x31, 0x78, 0x12, 0x7c, 0x15, 0x7e, 0xb3, 
-    0x2a, 0x30, 0x20, 0xe7, 0x05, 0x43, 0xe1, 0x80, 0x80, 0x11, 0x43, 0xe1, 0x40, 0x80, 0x0c, 0x43, 
-    0xe1, 0xc0, 0xd0, 0xf1, 0x75, 0x31, 0x07, 0x12, 0x7c, 0x15, 0x22, 0xd0, 0xf1, 0x02, 0x76, 0x6f, 
-    0x7e, 0xb3, 0x2a, 0x2c, 0xb4, 0x09, 0x23, 0x75, 0x31, 0x79, 0x12, 0x7c, 0x15, 0x7e, 0xb3, 0x2a, 
-    0x2e, 0xbe, 0xb3, 0x3f, 0xf1, 0x68, 0x11, 0xca, 0xb8, 0xc0, 0xf1, 0x12, 0x43, 0xd4, 0xd0, 0xf1, 
-    0xda, 0xb8, 0x50, 0x76, 0x7a, 0xb3, 0x3f, 0xf1, 0x80, 0x6d, 0xb4, 0x05, 0x08, 0x75, 0x31, 0x7a, 
-    0x12, 0x7c, 0x15, 0x80, 0x62, 0xb4, 0x03, 0x19, 0x75, 0x31, 0x7b, 0x12, 0x7c, 0x15, 0x7e, 0xb3, 
-    0x2a, 0x2e, 0xb4, 0x01, 0x55, 0x7e, 0xb3, 0x3f, 0xf2, 0x44, 0x01, 0x7a, 0xb3, 0x3f, 0xf2, 0x80, 
-    0x46, 0xb4, 0x01, 0x19, 0x75, 0x31, 0x7c, 0x12, 0x7c, 0x15, 0x7e, 0xb3, 0x2a, 0x2e, 0xb4, 0x01, 
-    0x39, 0x7e, 0xb3, 0x3f, 0xf2, 0x54, 0xfe, 0x7a, 0xb3, 0x3f, 0xf2, 0x80, 0x2a, 0xb4, 0x07, 0x2a, 
-    0x7e, 0xb3, 0x2a, 0x2d, 0x60, 0x24, 0x7c, 0x0b, 0x7e, 0x13, 0x2a, 0x2e, 0x7e, 0x17, 0x2a, 0x2f, 
-    0x75, 0x31, 0x73, 0x12, 0x7c, 0x15, 0x7a, 0x01, 0x31, 0x12, 0x7c, 0x15, 0x7a, 0x11, 0x31, 0x12, 
-    0x7c, 0x15, 0x12, 0x7b, 0x5f, 0x40, 0x03, 0x02, 0x76, 0x6f, 0x02, 0x7b, 0x29, 0x7e, 0xb3, 0x2a, 
-    0x2c, 0xb4, 0x0b, 0xf6, 0x75, 0x31, 0x7d, 0x12, 0x7c, 0x15, 0x7e, 0xb3, 0x2a, 0x2e, 0x7e, 0xa3, 
-    0x2a, 0x30, 0x4c, 0xab, 0x78, 0xe4, 0x80, 0xdf, 0x7e, 0xb3, 0x2a, 0x2c, 0xb4, 0x0a, 0xdb, 0x75, 
-    0x31, 0x7e, 0x12, 0x7c, 0x15, 0x7e, 0xb3, 0x2a, 0x2e, 0x70, 0xcf, 0xf5, 0xf3, 0x75, 0xf6, 0x01, 
-    0x22, 0x02, 0x7b, 0x29, 0x02, 0x7b, 0x29, 0x02, 0x7b, 0x29, 0x7e, 0xb3, 0x2a, 0x2c, 0xb4, 0x04, 
-    0x20, 0x75, 0x31, 0xc3, 0x12, 0x7c, 0x15, 0x7e, 0x04, 0x00, 0x01, 0x7e, 0x17, 0x2a, 0x2d, 0x7e, 
-    0x18, 0x2a, 0x3c, 0x7a, 0x1c, 0x00, 0x00, 0x7e, 0x47, 0x2a, 0x31, 0x12, 0x7c, 0x21, 0x02, 0x7a, 
-    0xc8, 0xb4, 0x06, 0x3a, 0x75, 0x31, 0xc1, 0x12, 0x7c, 0x15, 0x7e, 0x58, 0x00, 0x00, 0x7a, 0x5c, 
-    0x00, 0xfe, 0x7d, 0xca, 0x7e, 0xd7, 0x2a, 0x2d, 0x7e, 0x78, 0x2a, 0x3c, 0x7a, 0x7c, 0x00, 0x00, 
-    0x7e, 0x77, 0x2a, 0x31, 0x75, 0x31, 0xc1, 0x12, 0x7c, 0x15, 0xc0, 0xa8, 0xc0, 0x87, 0xc2, 0xaf, 
-    0xa9, 0xd5, 0x87, 0x12, 0x7c, 0x5a, 0xd0, 0x87, 0xd0, 0xa8, 0x40, 0x4f, 0x80, 0x4a, 0xb4, 0x00, 
-    0x1c, 0xc2, 0xaf, 0xa9, 0xd5, 0x87, 0x12, 0x76, 0x6f, 0xe4, 0x8d, 0xef, 0x8d, 0xef, 0x8d, 0xef, 
-    0xd5, 0xe0, 0xf7, 0xc0, 0xd1, 0xca, 0x02, 0xff, 0xca, 0x06, 0x00, 0x00, 0x32, 0xb4, 0x09, 0x12, 
-    0x7e, 0x57, 0x2a, 0x2d, 0x4d, 0x55, 0x68, 0x05, 0xa9, 0xd2, 0xb1, 0x80, 0x03, 0xa9, 0xc2, 0xb1, 
-    0x80, 0x16, 0xb4, 0x07, 0x16, 0xc2, 0xaf, 0x7e, 0x07, 0x2a, 0x2f, 0x7e, 0x17, 0x2a, 0x2d, 0xc0, 
-    0xd1, 0xca, 0x18, 0xca, 0x38, 0xca, 0x28, 0x32, 0x02, 0x76, 0x6f, 0x02, 0x7b, 0x29, 0x7e, 0xb3, 
-    0x2a, 0x2c, 0xb4, 0x03, 0x15, 0x75, 0x31, 0xc2, 0x12, 0x7c, 0x15, 0x7e, 0x04, 0x00, 0x01, 0x7e, 
-    0x17, 0x2a, 0x2d, 0x7e, 0x57, 0x2a, 0x31, 0x02, 0x76, 0x73, 0xb4, 0x05, 0x39, 0x75, 0x31, 0xc0, 
-    0x12, 0x7c, 0x15, 0xc0, 0xa8, 0xc0, 0x87, 0xc2, 0xaf, 0xa9, 0xd5, 0x87, 0x7e, 0x08, 0x2a, 0x3c, 
-    0x7a, 0x0c, 0x00, 0x00, 0x7e, 0x24, 0x00, 0xfe, 0x7e, 0x37, 0x2a, 0x2d, 0x7e, 0x47, 0x2a, 0x31, 
-    0x12, 0x7c, 0x21, 0xd0, 0x87, 0xd0, 0xa8, 0x7e, 0x08, 0x2a, 0x3c, 0x7a, 0x0c, 0x00, 0x00, 0x7e, 
-    0x57, 0x2a, 0x31, 0x02, 0x76, 0x73, 0x02, 0x7b, 0x29, 0x75, 0x31, 0x07, 0x12, 0x7c, 0x15, 0x43, 
-    0xe1, 0xc0, 0x22, 0xc0, 0xa8, 0xc0, 0x87, 0xc2, 0xaf, 0xa9, 0xd5, 0x87, 0x12, 0x7b, 0x9e, 0x40, 
-    0x19, 0x7e, 0x08, 0x2a, 0x3c, 0x7a, 0x0c, 0x00, 0x00, 0xca, 0x0b, 0xca, 0x49, 0x12, 0x7c, 0x21, 
-    0xda, 0x59, 0xda, 0x0b, 0xd0, 0x87, 0xd0, 0xa8, 0xc3, 0x22, 0xd0, 0x87, 0xd0, 0xa8, 0x22, 0xc0, 
-    0xa8, 0xc0, 0x87, 0xc2, 0xaf, 0xa9, 0xd5, 0x87, 0x12, 0x7b, 0x9e, 0x40, 0x2b, 0x7e, 0x58, 0x00, 
-    0x00, 0x7a, 0x5c, 0x00, 0xfe, 0x7f, 0x61, 0x7e, 0x78, 0x2a, 0x3c, 0x7a, 0x7c, 0x00, 0x00, 0x7e, 
-    0x77, 0x2a, 0x31, 0xbd, 0x74, 0x78, 0x11, 0x75, 0x31, 0xc1, 0x12, 0x7c, 0x15, 0x12, 0x7c, 0x5a, 
-    0x40, 0x06, 0xd0, 0x87, 0xd0, 0xa8, 0xc3, 0x22, 0xd0, 0x87, 0xd0, 0xa8, 0xd3, 0x22, 0x7e, 0x24, 
-    0x00, 0xfe, 0x7e, 0x34, 0x7f, 0xca, 0x0b, 0x1a, 0x50, 0xc5, 0xf0, 0x7d, 0x62, 0x7d, 0x75, 0x7d, 
-    0x87, 0x7e, 0x34, 0x7f, 0xc2, 0x7e, 0x1b, 0xb0, 0x7e, 0x34, 0x7f, 0x03, 0xb4, 0x01, 0x04, 0x7e, 
-    0x34, 0x7f, 0xcc, 0x7e, 0x1b, 0xb0, 0xbc, 0x0b, 0x50, 0x49, 0x3e, 0x00, 0x3e, 0x00, 0x0a, 0x50, 
-    0x2d, 0x75, 0x0b, 0x3a, 0x30, 0x69, 0x53, 0x00, 0x02, 0xbd, 0x38, 0x50, 0x02, 0x2d, 0x38, 0xbc, 
-    0x1b, 0x50, 0x30, 0x3e, 0x10, 0x3e, 0x10, 0x0a, 0x51, 0x2d, 0x35, 0x69, 0x41, 0x00, 0x02, 0x0b, 
-    0x1a, 0x30, 0xbd, 0x38, 0x50, 0x02, 0x2d, 0x38, 0xbe, 0x44, 0xff, 0xff, 0x78, 0x05, 0x7e, 0x1b, 
-    0x90, 0x0a, 0x49, 0x4d, 0x44, 0x68, 0x0c, 0xbe, 0x44, 0x00, 0xff, 0x28, 0x04, 0x7e, 0x44, 0x00, 
-    0xff, 0xc3, 0x22, 0xd3, 0x22, 
+    0x2a, 0x1d, 0xb4, 0x02, 0x07, 0x12, 0x78, 0x5e, 0x02, 0x78, 0x52, 0x22, 0xb4, 0x01, 0xfc, 0x02, 
+    0x78, 0x98, 0x7e, 0x00, 0x00, 0x7a, 0x03, 0x2a, 0x1d, 0x7a, 0x03, 0x2a, 0x1e, 0x22, 0x7e, 0xb3, 
+    0x2a, 0x15, 0x54, 0x60, 0x60, 0x05, 0xb4, 0x40, 0x15, 0x80, 0x13, 0x7e, 0xb3, 0x2a, 0x16, 0xb4, 
+    0x05, 0x0c, 0x75, 0x2f, 0x71, 0x12, 0x7e, 0x30, 0x7e, 0xb3, 0x2a, 0x18, 0xf5, 0x8f, 0x22, 0x75, 
+    0xf6, 0x00, 0x22, 0xbe, 0x57, 0x2a, 0x1b, 0x28, 0x04, 0x7e, 0x57, 0x2a, 0x1b, 0x7a, 0x0f, 0x2a, 
+    0x20, 0x7a, 0x57, 0x2a, 0x24, 0x02, 0x78, 0x98, 0x7e, 0xef, 0x2a, 0x20, 0x7e, 0xf7, 0x2a, 0x24, 
+    0x7e, 0x07, 0x2a, 0x24, 0x4d, 0x00, 0x68, 0x21, 0x7e, 0x00, 0x00, 0x7e, 0xeb, 0xb0, 0xf5, 0xf3, 
+    0xa3, 0xa5, 0x08, 0x1b, 0xf4, 0x68, 0x04, 0xa5, 0xb8, 0x08, 0xf0, 0x7a, 0xef, 0x2a, 0x20, 0x7a, 
+    0xf7, 0x2a, 0x24, 0x75, 0x2f, 0x06, 0x12, 0x7e, 0x30, 0x7a, 0x01, 0xf6, 0x22, 0xc2, 0xc1, 0x75, 
+    0x2f, 0x03, 0x12, 0x7e, 0x30, 0xa9, 0x36, 0xe2, 0x16, 0xe5, 0xf5, 0x54, 0xc0, 0x68, 0x07, 0xa9, 
+    0xd7, 0xf4, 0xa9, 0x27, 0xf4, 0xfc, 0x53, 0xe1, 0x3f, 0x43, 0xf2, 0x88, 0x02, 0x79, 0x44, 0x7e, 
+    0xb3, 0x2a, 0x1e, 0xb4, 0x02, 0x0f, 0xa9, 0xd4, 0xe4, 0x7e, 0xb0, 0x00, 0x7a, 0xb3, 0x2a, 0x1e, 
+    0x7a, 0xb3, 0x2a, 0x1d, 0x22, 0xb4, 0x01, 0x39, 0x7e, 0x21, 0xe6, 0x7c, 0x32, 0x7e, 0x13, 0x2a, 
+    0x1f, 0x2c, 0x21, 0x7a, 0x23, 0x2a, 0x1f, 0x7e, 0x00, 0x00, 0x2e, 0x04, 0x2a, 0x26, 0xe5, 0xe3, 
+    0x7a, 0x09, 0xb0, 0x0b, 0x04, 0xa5, 0xdb, 0xf6, 0xa9, 0xd4, 0xe4, 0x75, 0x2f, 0x70, 0x12, 0x7e, 
+    0x30, 0x7e, 0xb3, 0x2a, 0x1f, 0x7e, 0xa3, 0x2a, 0x1c, 0xbc, 0xab, 0x78, 0x03, 0x12, 0x79, 0xdb, 
+    0x22, 0x02, 0x7d, 0x44, 0xe5, 0xe6, 0xb4, 0x08, 0x65, 0xa9, 0xc4, 0xe2, 0x7e, 0x01, 0xe3, 0x7e, 
+    0x11, 0xe3, 0x7e, 0x31, 0xe3, 0x7e, 0x21, 0xe3, 0x7e, 0x51, 0xe3, 0x7e, 0x41, 0xe3, 0x7e, 0x71, 
+    0xe3, 0x7e, 0x61, 0xe3, 0x7a, 0x0f, 0x2a, 0x15, 0x7a, 0x1f, 0x2a, 0x19, 0x75, 0x2f, 0x04, 0x12, 
+    0x7e, 0x30, 0x7a, 0x01, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x11, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x21, 
+    0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x31, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x41, 0x2f, 0x12, 0x7e, 0x30, 
+    0x7a, 0x51, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x61, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x71, 0x2f, 0x12, 
+    0x7e, 0x30, 0xa9, 0xd4, 0xe4, 0xa9, 0xd7, 0xf4, 0xa9, 0xc6, 0xe2, 0x12, 0x79, 0xaf, 0x22, 0x6d, 
+    0x00, 0x7e, 0x14, 0x01, 0x02, 0x7a, 0x07, 0x2a, 0x24, 0x7a, 0x03, 0x2a, 0x1f, 0x7e, 0xb3, 0x2a, 
+    0x15, 0x20, 0xe7, 0x0f, 0x7a, 0x23, 0x2a, 0x1e, 0x7a, 0x33, 0x2a, 0x1d, 0xbe, 0x07, 0x2a, 0x1b, 
+    0x68, 0x09, 0x22, 0x7a, 0x33, 0x2a, 0x1e, 0x7a, 0x23, 0x2a, 0x1d, 0x7e, 0xb3, 0x2a, 0x15, 0x54, 
+    0xe3, 0x23, 0x23, 0x30, 0xe0, 0x02, 0xd2, 0xe5, 0x30, 0xe7, 0x02, 0xd2, 0xe4, 0x30, 0xe5, 0x06, 
+    0x30, 0xe4, 0x03, 0x02, 0x7d, 0x44, 0x54, 0x3e, 0xf5, 0xf0, 0x03, 0x54, 0x1f, 0xc3, 0x25, 0xf0, 
+    0x90, 0x7a, 0x07, 0x75, 0x84, 0xff, 0x73, 0x02, 0x7b, 0x5b, 0x02, 0x7a, 0x4f, 0x02, 0x7b, 0xf8, 
+    0x02, 0x7c, 0x13, 0x02, 0x7a, 0xf4, 0x02, 0x7a, 0xb5, 0x02, 0x7c, 0x2c, 0x02, 0x7c, 0x2c, 0x02, 
+    0x7c, 0x2f, 0x02, 0x7c, 0x2f, 0x02, 0x7c, 0x2f, 0x02, 0x7c, 0x2f, 0x02, 0x7c, 0x2f, 0x02, 0x7c, 
+    0x2f, 0x02, 0x7c, 0x2f, 0x02, 0x7c, 0x2f, 0x02, 0x7c, 0x35, 0x02, 0x7c, 0xe9, 0x02, 0x7c, 0x32, 
+    0x02, 0x7c, 0x32, 0x02, 0x7c, 0x32, 0x02, 0x7c, 0x32, 0x02, 0x7c, 0x32, 0x02, 0x7c, 0x32, 0x7e, 
+    0xb3, 0x2a, 0x16, 0xb4, 0x06, 0x2a, 0x7e, 0xb3, 0x2a, 0x17, 0x60, 0x56, 0x7c, 0x0b, 0x7e, 0x13, 
+    0x2a, 0x18, 0x7e, 0x17, 0x2a, 0x19, 0x75, 0x2f, 0x72, 0x12, 0x7e, 0x30, 0x7a, 0x01, 0x2f, 0x12, 
+    0x7e, 0x30, 0x7a, 0x11, 0x2f, 0x12, 0x7e, 0x30, 0x12, 0x7d, 0x4e, 0x40, 0x35, 0x02, 0x78, 0x83, 
+    0xb4, 0x08, 0x10, 0x75, 0x2f, 0x74, 0x12, 0x7e, 0x30, 0x7e, 0xb3, 0x3f, 0xf1, 0xf5, 0xf3, 0x75, 
+    0xf6, 0x01, 0x22, 0xb4, 0x00, 0x1c, 0x75, 0x2f, 0x75, 0x12, 0x7e, 0x30, 0x7e, 0xb3, 0x3f, 0xf2, 
+    0x30, 0xe0, 0x05, 0x75, 0xf3, 0x02, 0x80, 0x03, 0x75, 0xf3, 0x00, 0x75, 0xf3, 0x00, 0x75, 0xf6, 
+    0x02, 0x22, 0x02, 0x7d, 0x44, 0x7e, 0xb3, 0x2a, 0x16, 0xb4, 0x00, 0x35, 0x75, 0x2f, 0x76, 0x12, 
+    0x7e, 0x30, 0x7e, 0xb3, 0x2a, 0x1a, 0x54, 0x0f, 0xf5, 0xf1, 0x7e, 0xb3, 0x2a, 0x1a, 0x20, 0xe7, 
+    0x09, 0xe5, 0xe1, 0x30, 0xe7, 0x0d, 0x74, 0x01, 0x80, 0x0b, 0xe5, 0xe1, 0x30, 0xe6, 0x04, 0x74, 
+    0x01, 0x80, 0x02, 0x74, 0x00, 0x53, 0xf1, 0x80, 0xf5, 0xf3, 0x75, 0xf3, 0x00, 0x75, 0xf6, 0x02, 
+    0x22, 0x02, 0x7d, 0x44, 0xc0, 0xf1, 0x7e, 0xb3, 0x2a, 0x1a, 0x54, 0x0f, 0x42, 0xf1, 0x7e, 0xb3, 
+    0x2a, 0x18, 0xb4, 0x00, 0x45, 0x7e, 0xb3, 0x2a, 0x16, 0xb4, 0x01, 0x24, 0x75, 0x2f, 0x77, 0x12, 
+    0x7e, 0x30, 0x7e, 0xb3, 0x2a, 0x1a, 0x54, 0x0f, 0x78, 0x05, 0x53, 0xe1, 0x3f, 0x80, 0x37, 0x7e, 
+    0xb3, 0x2a, 0x1a, 0x20, 0xe7, 0x05, 0x53, 0xe1, 0x7f, 0x80, 0x2b, 0x53, 0xe1, 0xbf, 0x80, 0x26, 
+    0xb4, 0x03, 0x17, 0x75, 0x2f, 0x78, 0x12, 0x7e, 0x30, 0x7e, 0xb3, 0x2a, 0x1a, 0x20, 0xe7, 0x05, 
+    0x43, 0xe1, 0x80, 0x80, 0x11, 0x43, 0xe1, 0x40, 0x80, 0x0c, 0x43, 0xe1, 0xc0, 0xd0, 0xf1, 0x75, 
+    0x2f, 0x07, 0x12, 0x7e, 0x30, 0x22, 0xd0, 0xf1, 0x02, 0x78, 0x7f, 0x7e, 0xb3, 0x2a, 0x16, 0xb4, 
+    0x09, 0x23, 0x75, 0x2f, 0x79, 0x12, 0x7e, 0x30, 0x7e, 0xb3, 0x2a, 0x18, 0xbe, 0xb3, 0x3f, 0xf1, 
+    0x68, 0x11, 0xca, 0xb8, 0xc0, 0xf1, 0x12, 0x43, 0x68, 0xd0, 0xf1, 0xda, 0xb8, 0x50, 0x76, 0x7a, 
+    0xb3, 0x3f, 0xf1, 0x80, 0x6d, 0xb4, 0x05, 0x08, 0x75, 0x2f, 0x7a, 0x12, 0x7e, 0x30, 0x80, 0x62, 
+    0xb4, 0x03, 0x19, 0x75, 0x2f, 0x7b, 0x12, 0x7e, 0x30, 0x7e, 0xb3, 0x2a, 0x18, 0xb4, 0x01, 0x55, 
+    0x7e, 0xb3, 0x3f, 0xf2, 0x44, 0x01, 0x7a, 0xb3, 0x3f, 0xf2, 0x80, 0x46, 0xb4, 0x01, 0x19, 0x75, 
+    0x2f, 0x7c, 0x12, 0x7e, 0x30, 0x7e, 0xb3, 0x2a, 0x18, 0xb4, 0x01, 0x39, 0x7e, 0xb3, 0x3f, 0xf2, 
+    0x54, 0xfe, 0x7a, 0xb3, 0x3f, 0xf2, 0x80, 0x2a, 0xb4, 0x07, 0x2a, 0x7e, 0xb3, 0x2a, 0x17, 0x60, 
+    0x24, 0x7c, 0x0b, 0x7e, 0x13, 0x2a, 0x18, 0x7e, 0x17, 0x2a, 0x19, 0x75, 0x2f, 0x73, 0x12, 0x7e, 
+    0x30, 0x7a, 0x01, 0x2f, 0x12, 0x7e, 0x30, 0x7a, 0x11, 0x2f, 0x12, 0x7e, 0x30, 0x12, 0x7d, 0x7a, 
+    0x40, 0x03, 0x02, 0x78, 0x7f, 0x02, 0x7d, 0x44, 0x7e, 0xb3, 0x2a, 0x16, 0xb4, 0x0b, 0xf6, 0x75, 
+    0x2f, 0x7d, 0x12, 0x7e, 0x30, 0x7e, 0xb3, 0x2a, 0x18, 0x7e, 0xa3, 0x2a, 0x1a, 0x4c, 0xab, 0x78, 
+    0xe4, 0x80, 0xdf, 0x7e, 0xb3, 0x2a, 0x16, 0xb4, 0x0a, 0xdb, 0x75, 0x2f, 0x7e, 0x12, 0x7e, 0x30, 
+    0x7e, 0xb3, 0x2a, 0x18, 0x70, 0xcf, 0xf5, 0xf3, 0x75, 0xf6, 0x01, 0x22, 0x02, 0x7d, 0x44, 0x02, 
+    0x7d, 0x44, 0x02, 0x7d, 0x44, 0x7e, 0xb3, 0x2a, 0x16, 0xb4, 0x04, 0x20, 0x75, 0x2f, 0xc3, 0x12, 
+    0x7e, 0x30, 0x7e, 0x04, 0x00, 0x01, 0x7e, 0x17, 0x2a, 0x17, 0x7e, 0x18, 0x2a, 0x26, 0x7a, 0x1c, 
+    0x00, 0x00, 0x7e, 0x47, 0x2a, 0x1b, 0x12, 0x7e, 0x3c, 0x02, 0x7c, 0xe3, 0xb4, 0x06, 0x3a, 0x75, 
+    0x2f, 0xc1, 0x12, 0x7e, 0x30, 0x7e, 0x58, 0x00, 0x00, 0x7a, 0x5c, 0x00, 0xfe, 0x7d, 0xca, 0x7e, 
+    0xd7, 0x2a, 0x17, 0x7e, 0x78, 0x2a, 0x26, 0x7a, 0x7c, 0x00, 0x00, 0x7e, 0x77, 0x2a, 0x1b, 0x75, 
+    0x2f, 0xc1, 0x12, 0x7e, 0x30, 0xc0, 0xa8, 0xc0, 0x87, 0xc2, 0xaf, 0xa9, 0xd5, 0x87, 0x12, 0x7e, 
+    0x75, 0xd0, 0x87, 0xd0, 0xa8, 0x40, 0x4f, 0x80, 0x4a, 0xb4, 0x00, 0x1c, 0xc2, 0xaf, 0xa9, 0xd5, 
+    0x87, 0x12, 0x78, 0x7f, 0xe4, 0x8d, 0xef, 0x8d, 0xef, 0x8d, 0xef, 0xd5, 0xe0, 0xf7, 0xc0, 0xd1, 
+    0xca, 0x02, 0xff, 0xca, 0x06, 0x00, 0x00, 0x32, 0xb4, 0x09, 0x12, 0x7e, 0x57, 0x2a, 0x17, 0x4d, 
+    0x55, 0x68, 0x05, 0xa9, 0xd2, 0xb1, 0x80, 0x03, 0xa9, 0xc2, 0xb1, 0x80, 0x16, 0xb4, 0x07, 0x16, 
+    0xc2, 0xaf, 0x7e, 0x07, 0x2a, 0x19, 0x7e, 0x17, 0x2a, 0x17, 0xc0, 0xd1, 0xca, 0x18, 0xca, 0x38, 
+    0xca, 0x28, 0x32, 0x02, 0x78, 0x7f, 0x02, 0x7d, 0x44, 0x7e, 0xb3, 0x2a, 0x16, 0xb4, 0x03, 0x15, 
+    0x75, 0x2f, 0xc2, 0x12, 0x7e, 0x30, 0x7e, 0x04, 0x00, 0x01, 0x7e, 0x17, 0x2a, 0x17, 0x7e, 0x57, 
+    0x2a, 0x1b, 0x02, 0x78, 0x83, 0xb4, 0x05, 0x39, 0x75, 0x2f, 0xc0, 0x12, 0x7e, 0x30, 0xc0, 0xa8, 
+    0xc0, 0x87, 0xc2, 0xaf, 0xa9, 0xd5, 0x87, 0x7e, 0x08, 0x2a, 0x26, 0x7a, 0x0c, 0x00, 0x00, 0x7e, 
+    0x24, 0x00, 0xfe, 0x7e, 0x37, 0x2a, 0x17, 0x7e, 0x47, 0x2a, 0x1b, 0x12, 0x7e, 0x3c, 0xd0, 0x87, 
+    0xd0, 0xa8, 0x7e, 0x08, 0x2a, 0x26, 0x7a, 0x0c, 0x00, 0x00, 0x7e, 0x57, 0x2a, 0x1b, 0x02, 0x78, 
+    0x83, 0x02, 0x7d, 0x44, 0x75, 0x2f, 0x07, 0x12, 0x7e, 0x30, 0x43, 0xe1, 0xc0, 0x22, 0xc0, 0xa8, 
+    0xc0, 0x87, 0xc2, 0xaf, 0xa9, 0xd5, 0x87, 0x12, 0x7d, 0xb9, 0x40, 0x19, 0x7e, 0x08, 0x2a, 0x26, 
+    0x7a, 0x0c, 0x00, 0x00, 0xca, 0x0b, 0xca, 0x49, 0x12, 0x7e, 0x3c, 0xda, 0x59, 0xda, 0x0b, 0xd0, 
+    0x87, 0xd0, 0xa8, 0xc3, 0x22, 0xd0, 0x87, 0xd0, 0xa8, 0x22, 0xc0, 0xa8, 0xc0, 0x87, 0xc2, 0xaf, 
+    0xa9, 0xd5, 0x87, 0x12, 0x7d, 0xb9, 0x40, 0x2b, 0x7e, 0x58, 0x00, 0x00, 0x7a, 0x5c, 0x00, 0xfe, 
+    0x7f, 0x61, 0x7e, 0x78, 0x2a, 0x26, 0x7a, 0x7c, 0x00, 0x00, 0x7e, 0x77, 0x2a, 0x1b, 0xbd, 0x74, 
+    0x78, 0x11, 0x75, 0x2f, 0xc1, 0x12, 0x7e, 0x30, 0x12, 0x7e, 0x75, 0x40, 0x06, 0xd0, 0x87, 0xd0, 
+    0xa8, 0xc3, 0x22, 0xd0, 0x87, 0xd0, 0xa8, 0xd3, 0x22, 0x7e, 0x24, 0x00, 0xfe, 0x7e, 0x34, 0x7f, 
+    0xca, 0x0b, 0x1a, 0x50, 0xc5, 0xf0, 0x7d, 0x62, 0x7d, 0x75, 0x7d, 0x87, 0x7e, 0x34, 0x7f, 0xc2, 
+    0x7e, 0x1b, 0xb0, 0x7e, 0x34, 0x7f, 0x03, 0xb4, 0x01, 0x04, 0x7e, 0x34, 0x7f, 0xcc, 0x7e, 0x1b, 
+    0xb0, 0xbc, 0x0b, 0x50, 0x49, 0x3e, 0x00, 0x3e, 0x00, 0x0a, 0x50, 0x2d, 0x75, 0x0b, 0x3a, 0x30, 
+    0x69, 0x53, 0x00, 0x02, 0xbd, 0x38, 0x50, 0x02, 0x2d, 0x38, 0xbc, 0x1b, 0x50, 0x30, 0x3e, 0x10, 
+    0x3e, 0x10, 0x0a, 0x51, 0x2d, 0x35, 0x69, 0x41, 0x00, 0x02, 0x0b, 0x1a, 0x30, 0xbd, 0x38, 0x50, 
+    0x02, 0x2d, 0x38, 0xbe, 0x44, 0xff, 0xff, 0x78, 0x05, 0x7e, 0x1b, 0x90, 0x0a, 0x49, 0x4d, 0x44, 
+    0x68, 0x0c, 0xbe, 0x44, 0x00, 0xff, 0x28, 0x04, 0x7e, 0x44, 0x00, 0xff, 0xc3, 0x22, 0xd3, 0x22, 
 
-// Segment #16, Start Address 00ff7fc6, Length 4
+// Segment #15, Start Address 00ff7fc6, Length 4
 0xff,0x00,0xc6,0x7f,0x04,0x00,
-    0x01, 0x10, 0x04, 0x00, 
+    0x01, 0x0c, 0x03, 0x00, 
 
-// Segment #17, Start Address 00ff7c15, Length 330
-0xff,0x00,0x15,0x7c,0x4a,0x01,
-    0xca, 0x08, 0x7e, 0x01, 0x31, 0x7a, 0x03, 0x3f, 0xf0, 0xda, 0x08, 0x22, 0x7e, 0x1b, 0xc0, 0x7a, 
+// Segment #16, Start Address 00ff7e30, Length 315
+0xff,0x00,0x30,0x7e,0x3b,0x01,
+    0xca, 0x08, 0x7e, 0x01, 0x2f, 0x7a, 0x03, 0x3f, 0xf0, 0xda, 0x08, 0x22, 0x7e, 0x1b, 0xc0, 0x7a, 
     0x0b, 0xc0, 0x0b, 0x14, 0x0b, 0x34, 0x1b, 0x44, 0x78, 0xf2, 0x22, 0x7f, 0x6f, 0x7f, 0xf0, 0x1b, 
     0xfc, 0x7c, 0x54, 0x7d, 0x32, 0x80, 0x08, 0xca, 0x1b, 0xca, 0x1b, 0xca, 0x1b, 0xca, 0x1b, 0x9e, 
     0x44, 0x00, 0x10, 0x50, 0xf2, 0x2e, 0x44, 0x00, 0x10, 0x68, 0x06, 0xca, 0x48, 0x1b, 0x44, 0x78, 
     0xfa, 0x7f, 0xf6, 0x89, 0xe4, 0xca, 0x6b, 0x5e, 0xd4, 0x00, 0x3f, 0x68, 0x20, 0x7e, 0x84, 0x00, 
-    0x40, 0x9d, 0x8d, 0xda, 0x6b, 0xbd, 0x87, 0x38, 0x16, 0xca, 0x79, 0x7d, 0x78, 0x12, 0x7c, 0x84, 
+    0x40, 0x9d, 0x8d, 0xda, 0x6b, 0xbd, 0x87, 0x38, 0x16, 0xca, 0x79, 0x7d, 0x78, 0x12, 0x7e, 0x9f, 
     0xda, 0x79, 0x40, 0x08, 0x9d, 0x78, 0x68, 0x02, 0x80, 0x05, 0xc2, 0xd7, 0x22, 0xda, 0x6b, 0x43, 
     0x90, 0x30, 0x74, 0xaa, 0x39, 0xb5, 0x55, 0x55, 0x74, 0x55, 0x39, 0xb5, 0x2a, 0xaa, 0x74, 0xa0, 
     0x39, 0xb5, 0x55, 0x55, 0x7e, 0x04, 0x00, 0x40, 0x9d, 0x70, 0x50, 0x06, 0x2d, 0x70, 0x7d, 0x07, 
@@ -1211,17 +1104,16 @@
     0x1b, 0x54, 0x78, 0xf5, 0x80, 0x2c, 0x6d, 0x00, 0x7c, 0x20, 0x7f, 0x16, 0x9f, 0x10, 0x7f, 0x27, 
     0x9f, 0x20, 0x7e, 0x2b, 0x00, 0x7e, 0x1b, 0x10, 0xbc, 0x01, 0x78, 0x16, 0x0b, 0x2c, 0x0b, 0x1c, 
     0xa5, 0xdb, 0xef, 0x7c, 0xb6, 0x20, 0xe0, 0x03, 0x63, 0x90, 0x30, 0x4d, 0x77, 0x78, 0x93, 0xc2, 
-    0xd7, 0x22, 0xd2, 0xd7, 0x22, 0x00, 0x04, 0x00, 0x04, 0x42, 0x08, 0x06, 0x04, 0x02, 0x04, 0x00, 
-    0x02, 0x01, 0x04, 0x01, 0x02, 0x82, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 
-    0x02, 0x02, 0x04, 0x02, 0x08, 0x10, 0x02, 0x10, 0x04, 0x02, 0x08, 0x00, 0x01, 0x01, 0x08, 0x00, 
-    0x01, 0x00, 0x02, 0x00, 0x02, 0x02, 0x08, 0x02, 0x04, 0x20, 0x04, 0x7e, 0x18, 0x7f, 0xbd, 0x7a, 
-    0x1c, 0x00, 0xfe, 0x0b, 0x1a, 0x00, 0x5e, 0x10, 0x1f, 0xbe, 0x10, 0x1a, 0x38, 0x1a, 0x0a, 0x51, 
-    0x23, 0x7e, 0x18, 0x7c, 0xfa, 0x7a, 0x1c, 0x00, 0xff, 0x2d, 0x35, 0x0b, 0x1a, 0x50, 0x60, 0x08, 
-    0xa5, 0xb8, 0x02, 0x03, 0x4e, 0xa0, 0x08, 0x22, 0x80, 0xfe, 
+    0xd7, 0x22, 0xd2, 0xd7, 0x22, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x06, 0x04, 0x02, 0x04, 0x00, 
+    0x02, 0x01, 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 
+    0x02, 0x02, 0x04, 0x00, 0x08, 0x10, 0x02, 0x10, 0x04, 0x02, 0x08, 0x00, 0x01, 0x01, 0x08, 0x7e, 
+    0x18, 0x7f, 0xbd, 0x7a, 0x1c, 0x00, 0xfe, 0x0b, 0x1a, 0x00, 0xbe, 0x10, 0x14, 0x38, 0x1a, 0x0a, 
+    0x51, 0x23, 0x7e, 0x18, 0x7f, 0x15, 0x7a, 0x1c, 0x00, 0xff, 0x2d, 0x35, 0x0b, 0x1a, 0x50, 0x60, 
+    0x08, 0xa5, 0xb8, 0x02, 0x03, 0x4e, 0xa0, 0x08, 0x22, 0x80, 0xfe, 
 };
 
 static struct edge_firmware_version_info IMAGE_VERSION_NAME = {
-	1, 16, 4 };		// Major, Minor, Build
+	1, 12, 3 };		// Major, Minor, Build
 
 #undef IMAGE_VERSION_NAME
 
diff -Naur linuxppc-2.6.9/drivers/usb/serial/io_tables.h linuxppc-2.6.9-dream/drivers/usb/serial/io_tables.h
--- linuxppc-2.6.9/drivers/usb/serial/io_tables.h	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/io_tables.h	2005-09-19 21:40:06.000000000 +0200
@@ -14,12 +14,22 @@
 #ifndef IO_TABLES_H
 #define IO_TABLES_H
 
+static struct usb_device_id edgeport_1port_id_table [] = {
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_PARALLEL_PORT) },
+	{ }
+};
+
 static struct usb_device_id edgeport_2port_id_table [] = {
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_2) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_2I) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_421) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_21) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_2_DIN) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_2) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_2I) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_421) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_21) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_2_DIN) },
 	{ }
 };
 
@@ -31,9 +41,12 @@
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_4I) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8_DUAL_CPU) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_4_DIN) },
-	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_22I) },
-	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_412_4) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_COMPATIBLE) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_4) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_4T) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_4I) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_8_DUAL_CPU) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_4_DIN) },
 	{ }
 };
 
@@ -41,9 +54,9 @@
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_16_DUAL_CPU) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8I) },
-	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8R) },
-	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8RR) },
-	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_412_8) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_8) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_16_DUAL_CPU) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_8I) },
 	{ }
 };
 
@@ -56,6 +69,7 @@
 	{ USB_DEVICE(USB_VENDOR_ID_ION,	ION_DEVICE_ID_EDGEPORT_2) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION,	ION_DEVICE_ID_EDGEPORT_4I) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION,	ION_DEVICE_ID_EDGEPORT_2I) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION,	ION_DEVICE_ID_EDGEPORT_PARALLEL_PORT) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION,	ION_DEVICE_ID_EDGEPORT_421) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION,	ION_DEVICE_ID_EDGEPORT_21) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION,	ION_DEVICE_ID_EDGEPORT_8_DUAL_CPU) },
@@ -63,18 +77,51 @@
 	{ USB_DEVICE(USB_VENDOR_ID_ION,	ION_DEVICE_ID_EDGEPORT_2_DIN) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION,	ION_DEVICE_ID_EDGEPORT_4_DIN) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION,	ION_DEVICE_ID_EDGEPORT_16_DUAL_CPU) },
-	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_22I) },
-	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_412_4) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION,	ION_DEVICE_ID_EDGEPORT_COMPATIBLE) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION,	ION_DEVICE_ID_EDGEPORT_8I) },
-	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8R) },
-	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8RR) },
-	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_412_8) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_2) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_2I) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_421) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_21) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_2_DIN) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_4) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_4T) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_4I) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_8_DUAL_CPU) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_4_DIN) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_8) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_16_DUAL_CPU) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_BB_EDGEPORT_8I) },
 	{ }							/* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE (usb, id_table_combined);
 
+static struct usb_serial_device_type edgeport_1port_device = {
+	.owner			= THIS_MODULE,
+	.name			= "Edgeport 1 port adapter",
+	.short_name		= "edgeport_1",
+	.id_table		= edgeport_1port_id_table,
+	.num_interrupt_in	= 1,
+	.num_bulk_in		= 1,
+	.num_bulk_out		= 1,
+	.num_ports		= 1,
+	.open			= edge_open,
+	.close			= edge_close,
+	.throttle		= edge_throttle,
+	.unthrottle		= edge_unthrottle,
+	.attach			= edge_startup,
+	.shutdown		= edge_shutdown,
+	.ioctl			= edge_ioctl,
+	.set_termios		= edge_set_termios,
+	.tiocmget		= edge_tiocmget,
+	.tiocmset		= edge_tiocmset,
+	.write			= edge_write,
+	.write_room		= edge_write_room,
+	.chars_in_buffer	= edge_chars_in_buffer,
+	.break_ctl		= edge_break,
+};
+
 static struct usb_serial_device_type edgeport_2port_device = {
 	.owner			= THIS_MODULE,
 	.name			= "Edgeport 2 port adapter",
diff -Naur linuxppc-2.6.9/drivers/usb/serial/io_ti.c linuxppc-2.6.9-dream/drivers/usb/serial/io_ti.c
--- linuxppc-2.6.9/drivers/usb/serial/io_ti.c	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/io_ti.c	2005-09-19 21:40:06.000000000 +0200
@@ -35,13 +35,19 @@
 #include <linux/ioctl.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 #include "usb-serial.h"
+
 #include "io_16654.h"
 #include "io_usbvend.h"
 #include "io_ti.h"
 
-static int debug;
-
 /*
  * Version Information
  */
@@ -124,11 +130,15 @@
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2C) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2I) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421_BOOT) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421_DOWN) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21_BOOT) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21_DOWN) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_42) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4I) },
-	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22I) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22) },
 	{ }
 };
 
@@ -139,11 +149,15 @@
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2C) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_2I) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421_BOOT) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_421_DOWN) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21_BOOT) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_21_DOWN) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_42) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4) },
 	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_4I) },
-	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22I) },
+	{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_TI_EDGEPORT_22) },
 	{ }
 };
 
@@ -260,17 +274,17 @@
 /**
  * TIReadDownloadMemory - Read edgeport memory from TI chip
  * @dev: usb device pointer
- * @start_address: Device CPU address at which to read
+ * @address: Device CPU address at which to read
  * @length: Length of above data
  * @address_type: Can read both XDATA and I2C
  * @buffer: pointer to input data buffer
  */
-static int TIReadDownloadMemory(struct usb_device *dev, int start_address,
-				int length, __u8 address_type, __u8 *buffer)
+int TIReadDownloadMemory (struct usb_device *dev, int start_address, int length,
+			  __u8 address_type, __u8 *buffer)
 {
 	int status = 0;
 	__u8 read_length;
-	__be16 be_start_address;
+	__u16 be_start_address;
 	
 	dbg ("%s - @ %x for %d", __FUNCTION__, start_address, length);
 
@@ -301,8 +315,8 @@
 		}
 
 		if (read_length > 1) {
-			usb_serial_debug_data(debug, &dev->dev, __FUNCTION__,
-					      read_length, buffer);
+			usb_serial_debug_data (__FILE__, __FUNCTION__,
+					       read_length, buffer);
 		}
 
 		/* Update pointers/length */
@@ -314,7 +328,7 @@
 	return status;
 }
 
-static int TIReadRam (struct usb_device *dev, int start_address, int length, __u8 *buffer)
+int TIReadRam (struct usb_device *dev, int start_address, int length, __u8 *buffer)
 {
 	return TIReadDownloadMemory (dev,
 				     start_address,
@@ -343,7 +357,7 @@
 	}
 
 	dbg ("%s - start_address = %x, length = %d", __FUNCTION__, start_address, length);
-	usb_serial_debug_data(debug, &serial->serial->dev->dev, __FUNCTION__, length, buffer);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, length, buffer);
 
 	serial->TiReadI2C = 1;
 
@@ -376,7 +390,7 @@
 	}
 
   	dbg ("%s - start_sddr = %x, length = %d", __FUNCTION__, start_address, length);
-	usb_serial_debug_data(debug, &serial->serial->dev->dev, __FUNCTION__, length, buffer);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, length, buffer);
 
 	return status;
 }
@@ -387,7 +401,7 @@
 {
 	int status = 0;
 	int write_length;
-	__be16 be_start_address;
+	__u16 be_start_address;
 
 	/* We can only send a maximum of 1 aligned byte page at a time */
 	
@@ -398,7 +412,7 @@
 		write_length = length;
 
 	dbg ("%s - BytesInFirstPage Addr = %x, length = %d", __FUNCTION__, start_address, write_length);
-	usb_serial_debug_data(debug, &serial->serial->dev->dev, __FUNCTION__, write_length, buffer);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, write_length, buffer);
 
 	/* Write first page */
 	be_start_address = cpu_to_be16 (start_address);
@@ -425,7 +439,7 @@
 			write_length = length;
 
 		dbg ("%s - Page Write Addr = %x, length = %d", __FUNCTION__, start_address, write_length);
-		usb_serial_debug_data(debug, &serial->serial->dev->dev, __FUNCTION__, write_length, buffer);
+		usb_serial_debug_data (__FILE__, __FUNCTION__, write_length, buffer);
 
 		/* Write next page */
 		be_start_address = cpu_to_be16 (start_address);
@@ -538,7 +552,7 @@
 			break;
 
 		/* Block the thread for 10ms */
-		msleep(10);
+		wait_ms (10);
 
 		if (last_count == port->tx.count) {
 			/* No activity.. count down. */
@@ -567,7 +581,7 @@
 		/* This function takes 4 ms; */
 		if (!TIIsTxActive (port)) {
 			/* Delay a few char times */
-			msleep(50);
+			wait_ms (50);
 			dbg ("%s - Empty", __FUNCTION__);
 			return;
 		}
@@ -598,7 +612,7 @@
 	return 0;
 }
 
-static int TIReadRom (struct edgeport_serial *serial, int start_address, int length, __u8 *buffer)
+int TIReadRom (struct edgeport_serial *serial, int start_address, int length, __u8 *buffer)
 {
 	int status;
 
@@ -618,7 +632,7 @@
 	return status;
 }
 
-static int TIWriteRom (struct edgeport_serial *serial, int start_address, int length, __u8 *buffer)
+int TIWriteRom (struct edgeport_serial *serial, int start_address, int length, __u8 *buffer)
 {
 	if (serial->product_info.TiMode == TI_MODE_BOOT)
 		return TIWriteBootMemory (serial,
@@ -981,7 +995,7 @@
 	if (status)
 		return status;
 
-	interface = &serial->serial->interface->cur_altsetting->desc;
+	interface = &serial->serial->dev->config->interface[0]->altsetting->desc;
 	if (!interface) {
 		dev_err (&serial->serial->dev->dev, "%s - no interface set, error!", __FUNCTION__);
 		return -ENODEV;
@@ -1635,6 +1649,10 @@
 
 	dbg("%s", __FUNCTION__);
 
+	if (serial_paranoia_check (edge_serial->serial, __FUNCTION__)) {
+		return;
+	}
+
 	switch (urb->status) {
 	case 0:
 		/* success */
@@ -1655,7 +1673,7 @@
 		goto exit;
 	}
 		
-	usb_serial_debug_data(debug, &edge_serial->serial->dev->dev, __FUNCTION__, length, data);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, length, data);
 		
 	if (length != 2) {
 		dbg ("%s - expecting packet of size 2, got %d", __FUNCTION__, length);
@@ -1667,6 +1685,11 @@
 	dbg ("%s - port_number %d, function %d, info 0x%x",
 	     __FUNCTION__, port_number, function, data[1]);
 	port = edge_serial->serial->port[port_number];
+	if (port_paranoia_check (port, __FUNCTION__)) {
+		dbg ("%s - change found for port that is not present",
+		     __FUNCTION__);
+		return;
+	}
 	edge_port = usb_get_serial_port_data(port);
 	if (!edge_port) {
 		dbg ("%s - edge_port not found", __FUNCTION__);
@@ -1721,6 +1744,9 @@
 
 	dbg("%s", __FUNCTION__);
 
+	if (port_paranoia_check (edge_port->port, __FUNCTION__))
+		return;
+
 	if (urb->status) {
 		dbg ("%s - nonzero read bulk status received: %d",
 		     __FUNCTION__, urb->status);
@@ -1747,7 +1773,7 @@
 
 	tty = edge_port->port->tty;
 	if (tty && urb->actual_length) {
-		usb_serial_debug_data(debug, &edge_port->port->dev, __FUNCTION__, urb->actual_length, data);
+		usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 		if (edge_port->close_pending) {
 			dbg ("%s - close is pending, dropping data on the floor.", __FUNCTION__);
@@ -1778,17 +1804,23 @@
 static void edge_bulk_out_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	struct tty_struct *tty;
 
 	dbg ("%s - port %d", __FUNCTION__, port->number);
 
+	if (!serial) {
+		dbg ("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
 		dbg ("%s - nonzero write bulk status received: %d",
 		     __FUNCTION__, urb->status);
 
 		if (urb->status == -EPIPE) {
 			/* clear any problem that might have happened on this pipe */
-			usb_clear_halt (port->serial->dev, urb->pipe);
+			usb_clear_halt (serial->dev, urb->pipe);
 		}
 		return;
 	}
@@ -1796,7 +1828,12 @@
 	tty = port->tty;
 	if (tty) {
 		/* let the tty driver wakeup if it has a special write_wakeup function */
-		tty_wakeup(tty);
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) && tty->ldisc.write_wakeup) {
+			(tty->ldisc.write_wakeup)(tty);
+		}
+
+		/* tell the tty driver that something has changed */
+		wake_up_interruptible(&tty->write_wait);
 	}
 }
 
@@ -1811,6 +1848,9 @@
 	u16 open_settings;
 	u8 transaction_timeout;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return -ENODEV;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (edge_port == NULL)
@@ -1953,50 +1993,61 @@
 
 static void edge_close (struct usb_serial_port *port, struct file * filp)
 {
+	struct usb_serial *serial;
 	struct edgeport_serial *edge_serial;
 	struct edgeport_port *edge_port;
 	int port_number;
 	int status;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 			 
-	edge_serial = usb_get_serial_data(port->serial);
+	serial = get_usb_serial (port, __FUNCTION__);
+	if (!serial)
+		return;
+	
+	edge_serial = usb_get_serial_data(serial);
 	edge_port = usb_get_serial_port_data(port);
 	if ((edge_serial == NULL) || (edge_port == NULL))
 		return;
 	
-	/* The bulkreadcompletion routine will check 
-	 * this flag and dump add read data */
-	edge_port->close_pending = 1;
-
-	/* chase the port close */
-	TIChasePort (edge_port);
-
-	usb_unlink_urb (port->read_urb);
-
-	/* assuming we can still talk to the device,
-	 * send a close port command to it */
-	dbg("%s - send umpc_close_port", __FUNCTION__);
-	port_number = port->number - port->serial->minor;
-	status = TIWriteCommandSync (port->serial->dev,
-				     UMPC_CLOSE_PORT,
-				     (__u8)(UMPM_UART1_PORT + port_number),
-				     0,
-				     NULL,
-				     0);
-	--edge_port->edge_serial->num_ports_open;
-	if (edge_port->edge_serial->num_ports_open <= 0) {
-		/* last port is now closed, let's shut down our interrupt urb */
-		usb_unlink_urb (port->serial->port[0]->interrupt_in_urb);
-		edge_port->edge_serial->num_ports_open = 0;
-	}
+	if (serial->dev) {
+		/* The bulkreadcompletion routine will check 
+		 * this flag and dump add read data */
+		edge_port->close_pending = 1;
+
+		/* chase the port close */
+		TIChasePort (edge_port);
+
+		usb_unlink_urb (port->read_urb);
+
+		/* assuming we can still talk to the device,
+		 * send a close port command to it */
+		dbg("%s - send umpc_close_port", __FUNCTION__);
+		port_number = port->number - port->serial->minor;
+		status = TIWriteCommandSync (port->serial->dev,
+					     UMPC_CLOSE_PORT,
+					     (__u8)(UMPM_UART1_PORT + port_number),
+					     0,
+					     NULL,
+					     0);
+		--edge_port->edge_serial->num_ports_open;
+		if (edge_port->edge_serial->num_ports_open <= 0) {
+			/* last port is now closed, let's shut down our interrupt urb */
+			usb_unlink_urb (serial->port[0]->interrupt_in_urb);
+			edge_port->edge_serial->num_ports_open = 0;
+		}
 	edge_port->close_pending = 0;
+	}
 
 	dbg("%s - exited", __FUNCTION__);
 }
 
 static int edge_write (struct usb_serial_port *port, int from_user, const unsigned char *data, int count)
 {
+	struct usb_serial *serial = port->serial;
 	struct edgeport_port *edge_port = usb_get_serial_port_data(port);
 	int result;
 
@@ -2026,11 +2077,11 @@
 		memcpy (port->write_urb->transfer_buffer, data, count);
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, port->write_urb->transfer_buffer);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, count, port->write_urb->transfer_buffer);
 
 	/* set up our urb */
-	usb_fill_bulk_urb (port->write_urb, port->serial->dev,
-			   usb_sndbulkpipe (port->serial->dev,
+	usb_fill_bulk_urb (port->write_urb, serial->dev,
+			   usb_sndbulkpipe (serial->dev,
 					    port->bulk_out_endpointAddress),
 			   port->write_urb->transfer_buffer, count,
 			   edge_bulk_out_callback,
@@ -2409,7 +2460,7 @@
 	return result;
 }
 
-static int get_serial_info (struct edgeport_port *edge_port, struct serial_struct __user *retinfo)
+static int get_serial_info (struct edgeport_port *edge_port, struct serial_struct * retinfo)
 {
 	struct serial_struct tmp;
 
@@ -2458,7 +2509,7 @@
 
 		case TIOCGSERIAL:
 			dbg("%s - (%d) TIOCGSERIAL", __FUNCTION__, port->number);
-			return get_serial_info(edge_port, (struct serial_struct __user *) arg);
+			return get_serial_info(edge_port, (struct serial_struct *) arg);
 			break;
 
 		case TIOCSSERIAL:
@@ -2491,7 +2542,7 @@
 		case TIOCGICOUNT:
 			dbg ("%s - (%d) TIOCGICOUNT RX=%d, TX=%d", __FUNCTION__,
 			     port->number, edge_port->icount.rx, edge_port->icount.tx);
-			if (copy_to_user((void __user *)arg, &edge_port->icount, sizeof(edge_port->icount)))
+			if (copy_to_user((void *)arg, &edge_port->icount, sizeof(edge_port->icount)))
 				return -EFAULT;
 			return 0;
 	}
@@ -2665,9 +2716,9 @@
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
 
-module_param(ignore_cpu_rev, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(ignore_cpu_rev, "i");
 MODULE_PARM_DESC(ignore_cpu_rev, "Ignore the cpu revision when connecting to a device");
 
diff -Naur linuxppc-2.6.9/drivers/usb/serial/io_usbvend.h linuxppc-2.6.9-dream/drivers/usb/serial/io_usbvend.h
--- linuxppc-2.6.9/drivers/usb/serial/io_usbvend.h	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/io_usbvend.h	2005-09-19 21:40:06.000000000 +0200
@@ -18,6 +18,14 @@
 #if !defined(_USBVEND_H)
 #define	_USBVEND_H
 
+#ifndef __KERNEL__
+#include "ionprag.h"	/* Extra I/O Networks pragmas */
+
+#include <usbdi.h>
+
+#include "iondef.h"	/* Standard I/O Networks definitions */
+#endif
+
 /************************************************************************
  *
  *		D e f i n e s   /   T y p e d e f s
@@ -29,7 +37,6 @@
 // 
 
 #define	USB_VENDOR_ID_ION	0x1608		// Our VID
-#define	USB_VENDOR_ID_TI	0x0451		// TI VID
 
 //
 // Definitions of USB product IDs (PID)
@@ -41,41 +48,36 @@
 
 // ION-device OEM IDs
 #define	ION_OEM_ID_ION		0		// 00h Inside Out Networks
-#define	ION_OEM_ID_NLYNX	1		// 01h NLynx Systems
+#define	ION_OEM_ID_NLYNX	1		// 01h NLynx Systems	  
 #define	ION_OEM_ID_GENERIC	2		// 02h Generic OEM
 #define	ION_OEM_ID_MAC		3		// 03h Mac Version
 #define	ION_OEM_ID_MEGAWOLF	4		// 04h Lupusb OEM Mac version (MegaWolf)
 #define	ION_OEM_ID_MULTITECH	5		// 05h Multitech Rapidports
-#define	ION_OEM_ID_AGILENT	6		// 06h AGILENT board
-
 
+	
 // ION-device Device IDs
-// Product IDs - assigned to match middle digit of serial number (No longer true)
+// Product IDs - assigned to match middle digit of serial number
 
-#define ION_DEVICE_ID_80251_NETCHIP	0x020	// This bit is set in the PID if this edgeport hardware$
-						// is based on the 80251+Netchip.  
 
-#define ION_DEVICE_ID_GENERATION_1	0x00	// Value for 930 based edgeports
-#define ION_DEVICE_ID_GENERATION_2	0x01	// Value for 80251+Netchip.
-#define ION_DEVICE_ID_GENERATION_3	0x02	// Value for Texas Instruments TUSB5052 chip
-#define ION_DEVICE_ID_GENERATION_4	0x03	// Watchport Family of products
-#define ION_GENERATION_MASK		0x03
-
-#define ION_DEVICE_ID_HUB_MASK		0x0080	// This bit in the PID designates a HUB device
-						// for example 8C would be a 421 4 port hub
-						// and 8D would be a 2 port embedded hub
+// The ION_DEVICE_ID_GENERATION_2 bit (0x20) will be ORed into the existing edgeport
+// PIDs to identify 80251+Netchip hardware.  This will guarantee that if a second
+// generation edgeport device is plugged into a PC with an older (pre 2.0) driver,
+// it will not enumerate.
 
-#define EDGEPORT_DEVICE_ID_MASK			0x0ff	// Not including OEM or GENERATION fields
+#define ION_DEVICE_ID_GENERATION_2	0x020	// This bit is set in the PID if this edgeport hardware
+															// is based on the 80251+Netchip.  
+
+#define EDGEPORT_DEVICE_ID_MASK			0x3df	// Not including GEN_2 bit
 
 #define	ION_DEVICE_ID_UNCONFIGURED_EDGE_DEVICE	0x000	// In manufacturing only
 #define ION_DEVICE_ID_EDGEPORT_4		0x001	// Edgeport/4 RS232
-#define	ION_DEVICE_ID_EDGEPORT_8R		0x002	// Edgeport with RJ45 no Ring
+//	ION_DEVICE_ID_HUBPORT_7			0x002	// Hubport/7 (Placeholder, not used by software)
 #define ION_DEVICE_ID_RAPIDPORT_4		0x003	// Rapidport/4
 #define ION_DEVICE_ID_EDGEPORT_4T		0x004	// Edgeport/4 RS232 for Telxon (aka "Fleetport")
 #define ION_DEVICE_ID_EDGEPORT_2		0x005	// Edgeport/2 RS232
 #define ION_DEVICE_ID_EDGEPORT_4I		0x006	// Edgeport/4 RS422
 #define ION_DEVICE_ID_EDGEPORT_2I		0x007	// Edgeport/2 RS422/RS485
-#define	ION_DEVICE_ID_EDGEPORT_8RR		0x008	// Edgeport with RJ45 with Data and RTS/CTS only
+//	ION_DEVICE_ID_HUBPORT_4			0x008	// Hubport/4 (Placeholder, not used by software)
 //	ION_DEVICE_ID_EDGEPORT_8_HANDBUILT	0x009	// Hand-built Edgeport/8 (Placeholder, used in middle digit of serial number only!)
 //	ION_DEVICE_ID_MULTIMODEM_4X56		0x00A	// MultiTech version of RP/4 (Placeholder, used in middle digit of serial number only!)
 #define	ION_DEVICE_ID_EDGEPORT_PARALLEL_PORT	0x00B	// Edgeport/(4)21 Parallel port (USS720)
@@ -88,134 +90,41 @@
 #define ION_DEVICE_ID_EDGEPORT_16_DUAL_CPU	0x012	// Half of an Edgeport/16 (the kind with 2 EP/8s)
 #define ION_DEVICE_ID_EDGEPORT_COMPATIBLE	0x013	// Edgeport Compatible, for NCR, Axiohm etc. testing
 #define ION_DEVICE_ID_EDGEPORT_8I		0x014	// Edgeport/8 RS422 (single-CPU)
-#define ION_DEVICE_ID_EDGEPORT_1		0x015	// Edgeport/1 RS232
-#define ION_DEVICE_ID_EPOS44			0x016	// Half of an EPOS/44 (TIUMP BASED)
-#define ION_DEVICE_ID_EDGEPORT_42		0x017	// Edgeport/42
-#define ION_DEVICE_ID_EDGEPORT_412_8		0x018	// Edgeport/412 8 port part
-#define ION_DEVICE_ID_EDGEPORT_412_4		0x019	// Edgeport/412	4 port part
-#define ION_DEVICE_ID_EDGEPORT_22I		0x01A	// Edgeport/22I is an Edgeport/4 with ports 1&2 RS422 and ports 3&4 RS232
-
-// Compact Form factor TI based devices  2c, 21c, 22c, 221c
-#define ION_DEVICE_ID_EDGEPORT_2C		0x01B	// Edgeport/2c is a TI based Edgeport/2 - Small I2c
-#define ION_DEVICE_ID_EDGEPORT_221C		0x01C	// Edgeport/221c is a TI based Edgeport/2 with lucent chip and
-							// 2 external hub ports - Large I2C
-#define ION_DEVICE_ID_EDGEPORT_22C		0x01D	// Edgeport/22c is a TI based Edgeport/2 with
-							// 2 external hub ports - Large I2C
-#define ION_DEVICE_ID_EDGEPORT_21C		0x01E	// Edgeport/21c is a TI based Edgeport/2 with lucent chip
-							// Small I2C
-
-
-/*
- *  DANGER DANGER The 0x20 bit was used to indicate a 8251/netchip GEN 2 device.
- *  Since the MAC, Linux, and Optimal drivers still used the old code
- *  I suggest that you skip the 0x20 bit when creating new PIDs
- */
-
-
-// Generation 3 devices -- 3410 based edgport/1 (256 byte I2C)
-#define ION_DEVICE_ID_TI3410_EDGEPORT_1		0x040	// Edgeport/1 RS232
-#define ION_DEVICE_ID_TI3410_EDGEPORT_1I	0x041	// Edgeport/1i- RS422 model
-
-// Ti based software switchable RS232/RS422/RS485 devices
-#define ION_DEVICE_ID_EDGEPORT_4S		0x042	// Edgeport/4s - software switchable model
-#define ION_DEVICE_ID_EDGEPORT_8S		0x043	// Edgeport/8s - software switchable model
-
-// Usb to Ethernet dongle
-#define ION_DEVICE_ID_EDGEPORT_E		0x0E0	// Edgeport/E Usb to Ethernet
-
-// Edgeport TI based devices
-#define ION_DEVICE_ID_TI_EDGEPORT_4		0x0201	// Edgeport/4 RS232
-#define ION_DEVICE_ID_TI_EDGEPORT_2		0x0205	// Edgeport/2 RS232
-#define ION_DEVICE_ID_TI_EDGEPORT_4I		0x0206	// Edgeport/4i RS422
-#define ION_DEVICE_ID_TI_EDGEPORT_2I		0x0207	// Edgeport/2i RS422/RS485
-#define ION_DEVICE_ID_TI_EDGEPORT_421		0x020C	// Edgeport/421 4 hub 2 RS232 + Parallel (lucent on a different hub port)
-#define ION_DEVICE_ID_TI_EDGEPORT_21		0x020D	// Edgeport/21 2 RS232 + Parallel (lucent on a different hub port)
-#define ION_DEVICE_ID_TI_EDGEPORT_8		0x020F	// Edgeport/8 (single-CPU)
-#define ION_DEVICE_ID_TI_EDGEPORT_1		0x0215	// Edgeport/1 RS232
-#define ION_DEVICE_ID_TI_EDGEPORT_42		0x0217	// Edgeport/42 4 hub 2 RS232
-#define ION_DEVICE_ID_TI_EDGEPORT_22I  		0x021A	// Edgeport/22I is an Edgeport/4 with ports 1&2 RS422 and ports 3&4 RS232
-#define ION_DEVICE_ID_TI_EDGEPORT_2C		0x021B	// Edgeport/2c RS232
-#define ION_DEVICE_ID_TI_EDGEPORT_221C		0x021C	// Edgeport/221c is a TI based Edgeport/2 with lucent chip and
-							// 2 external hub ports - Large I2C
-#define ION_DEVICE_ID_TI_EDGEPORT_22C		0x021D	// Edgeport/22c is a TI based Edgeport/2 with
-							// 2 external hub ports - Large I2C
-#define ION_DEVICE_ID_TI_EDGEPORT_21C		0x021E	// Edgeport/21c is a TI based Edgeport/2 with lucent chip
-
-// Generation 3 devices -- 3410 based edgport/1 (256 byte I2C) 
-#define ION_DEVICE_ID_TI_TI3410_EDGEPORT_1	0x240	// Edgeport/1 RS232
-#define ION_DEVICE_ID_TI_TI3410_EDGEPORT_1I	0x241	// Edgeport/1i- RS422 model
-
-// Ti based software switchable RS232/RS422/RS485 devices
-#define ION_DEVICE_ID_TI_EDGEPORT_4S		0x242	// Edgeport/4s - software switchable model
-#define ION_DEVICE_ID_IT_EDGEPORT_8S		0x243	// Edgeport/8s - software switchable model
-
-
-/************************************************************************
- *
- *                        Generation 4 devices
- *
- ************************************************************************/
-
-// Watchport based on 3410 both 1-wire and binary products (16K I2C)
-#define ION_DEVICE_ID_WP_UNSERIALIZED		0x300	// Watchport based on 3410 both 1-wire and binary products
-#define ION_DEVICE_ID_WP_PROXIMITY		0x301	// Watchport/P Discontinued
-#define ION_DEVICE_ID_WP_MOTION			0x302	// Watchport/M
-#define ION_DEVICE_ID_WP_MOISTURE		0x303	// Watchport/W
-#define ION_DEVICE_ID_WP_TEMPERATURE		0x304	// Watchport/T
-#define ION_DEVICE_ID_WP_HUMIDITY		0x305	// Watchport/H
-
-#define ION_DEVICE_ID_WP_POWER			0x306	// Watchport
-#define ION_DEVICE_ID_WP_LIGHT			0x307	// Watchport
-#define ION_DEVICE_ID_WP_RADIATION		0x308	// Watchport
-#define ION_DEVICE_ID_WP_ACCELERATION		0x309	// Watchport/A
-#define ION_DEVICE_ID_WP_DISTANCE		0x30A	// Watchport/D Discontinued
-#define ION_DEVICE_ID_WP_PROX_DIST		0x30B	// Watchport/D uses distance sensor
-							// Default to /P function
-
-#define ION_DEVICE_ID_PLUS_PWR_HP4CD		0x30C	// 5052 Plus Power HubPort/4CD+ (for Dell)
-#define ION_DEVICE_ID_PLUS_PWR_HP4C		0x30D	// 5052 Plus Power HubPort/4C+ 
-#define ION_DEVICE_ID_PLUS_PWR_PCI		0x30E	// 3410 Plus Power PCI Host Controller 4 port
-
-
-//
-// Definitions for AXIOHM USB product IDs
-//
-#define	USB_VENDOR_ID_AXIOHM			0x05D9	// Axiohm VID
-
-#define AXIOHM_DEVICE_ID_MASK			0xffff
-#define AXIOHM_DEVICE_ID_EPIC_A758		0xA758
-#define AXIOHM_DEVICE_ID_EPIC_A794		0xA794
-#define AXIOHM_DEVICE_ID_EPIC_A225		0xA225
-
-
-//
-// Definitions for NCR USB product IDs
-//
-#define	USB_VENDOR_ID_NCR			0x0404	// NCR VID
-
-#define NCR_DEVICE_ID_MASK			0xffff
-#define NCR_DEVICE_ID_EPIC_0202			0x0202
-#define NCR_DEVICE_ID_EPIC_0203			0x0203
-#define NCR_DEVICE_ID_EPIC_0310			0x0310
-#define NCR_DEVICE_ID_EPIC_0311			0x0311
-#define NCR_DEVICE_ID_EPIC_0312			0x0312
-
-
-//
-// Definitions for SYMBOL USB product IDs
-//
-#define USB_VENDOR_ID_SYMBOL			0x05E0	// Symbol VID
-#define SYMBOL_DEVICE_ID_MASK			0xffff
-#define SYMBOL_DEVICE_ID_KEYFOB			0x0700
-
-
-//
-// Definitions for other product IDs
 #define ION_DEVICE_ID_MT4X56USB			0x1403	// OEM device
 
+// BlackBox OEM devices
+#define ION_DEVICE_ID_BB_EDGEPORT_4		0x001	// Edgeport/4 RS232
+#define ION_DEVICE_ID_BB_EDGEPORT_4T		0x004	// Edgeport/4 RS232 for Telxon (aka "Fleetport")
+#define ION_DEVICE_ID_BB_EDGEPORT_2		0x005	// Edgeport/2 RS232
+#define ION_DEVICE_ID_BB_EDGEPORT_4I		0x006	// Edgeport/4 RS422
+#define ION_DEVICE_ID_BB_EDGEPORT_2I		0x007	// Edgeport/2 RS422/RS485
+#define	ION_DEVICE_ID_BB_EDGEPORT_421		0x00C	// Edgeport/421 Hub+RS232+Parallel
+#define	ION_DEVICE_ID_BB_EDGEPORT_21		0x00D	// Edgeport/21  RS232+Parallel
+#define ION_DEVICE_ID_BB_EDGEPORT_8_DUAL_CPU	0x00E	// Half of an Edgeport/8 (the kind with 2 EP/4s on 1 PCB)
+#define ION_DEVICE_ID_BB_EDGEPORT_8		0x00F	// Edgeport/8 (single-CPU)
+#define ION_DEVICE_ID_BB_EDGEPORT_2_DIN		0x010	// Edgeport/2 RS232 with Apple DIN connector
+#define ION_DEVICE_ID_BB_EDGEPORT_4_DIN		0x011	// Edgeport/4 RS232 with Apple DIN connector
+#define ION_DEVICE_ID_BB_EDGEPORT_16_DUAL_CPU	0x012	// Half of an Edgeport/16 (the kind with 2 EP/8s)
+#define ION_DEVICE_ID_BB_EDGEPORT_8I		0x014	// Edgeport/8 RS422 (single-CPU)
+
+
+/* Edgeport TI based devices */
+#define ION_DEVICE_ID_TI_EDGEPORT_4		0x0201	/* Edgeport/4 RS232 */
+#define ION_DEVICE_ID_TI_EDGEPORT_2		0x0205	/* Edgeport/2 RS232 */
+#define ION_DEVICE_ID_TI_EDGEPORT_4I		0x0206	/* Edgeport/4i RS422 */
+#define ION_DEVICE_ID_TI_EDGEPORT_2I		0x0207	/* Edgeport/2i RS422/RS485 */
+#define ION_DEVICE_ID_TI_EDGEPORT_421		0x020C	/* Edgeport/421 4 hub 2 RS232 + Parallel (lucent on a different hub port) */
+#define ION_DEVICE_ID_TI_EDGEPORT_21		0x020D	/* Edgeport/21 2 RS232 + Parallel (lucent on a different hub port) */
+#define ION_DEVICE_ID_TI_EDGEPORT_1		0x0215	/* Edgeport/1 RS232 */
+#define ION_DEVICE_ID_TI_EDGEPORT_42		0x0217	/* Edgeport/42 4 hub 2 RS232 */
+#define ION_DEVICE_ID_TI_EDGEPORT_22		0x021A	/* Edgeport/22  Edgeport/22I is an Edgeport/4 with ports 1&2 RS422 and ports 3&4 RS232 */
+#define ION_DEVICE_ID_TI_EDGEPORT_2C		0x021B	/* Edgeport/2c RS232 */
+
+#define ION_DEVICE_ID_TI_EDGEPORT_421_BOOT	0x0240	/* Edgeport/421 in boot mode */
+#define ION_DEVICE_ID_TI_EDGEPORT_421_DOWN	0x0241	/* Edgeport/421 in download mode first interface is 2 RS232 (Note that the second interface of this multi interface device should be a standard USB class 7 printer port) */
+#define ION_DEVICE_ID_TI_EDGEPORT_21_BOOT	0x0242	/* Edgeport/21 in boot mode */
+#define ION_DEVICE_ID_TI_EDGEPORT_21_DOWN	0x0243	/*Edgeport/42 in download mode: first interface is 2 RS232 (Note that the second interface of this multi interface device should be a standard USB class 7 printer port) */
 
-#define	GENERATION_ID_FROM_USB_PRODUCT_ID( ProductId )				\
-			( (__u16) ((ProductId >> 8) & (ION_GENERATION_MASK)) )
 
 #define	MAKE_USB_PRODUCT_ID( OemId, DeviceId )					\
 			( (__u16) (((OemId) << 10) || (DeviceId)) )
@@ -234,7 +143,7 @@
 
 // TxCredits value below which driver won't bother sending (to prevent too many small writes).
 // Send only if above 25%
-#define EDGE_FW_GET_TX_CREDITS_SEND_THRESHOLD(InitialCredit, MaxPacketSize) (max( ((InitialCredit) / 4), (MaxPacketSize) ))
+#define EDGE_FW_GET_TX_CREDITS_SEND_THRESHOLD(InitialCredit)	(max(((InitialCredit) / 4), EDGE_FW_BULK_MAX_PACKET_SIZE))
 
 #define	EDGE_FW_BULK_MAX_PACKET_SIZE		64	// Max Packet Size for Bulk In Endpoint (EP1)
 #define EDGE_FW_BULK_READ_BUFFER_SIZE		1024	// Size to use for Bulk reads
@@ -249,8 +158,8 @@
 // Definitions of I/O Networks vendor-specific requests
 // for default endpoint
 //
-//	bmRequestType = 01000000	Set vendor-specific, to device
-//	bmRequestType = 11000000	Get vendor-specific, to device
+//	bmRequestType = 00100000	Set vendor-specific, to device
+//	bmRequestType = 10100000	Get vendor-specific, to device
 //
 // These are the definitions for the bRequest field for the
 // above bmRequestTypes.
@@ -275,87 +184,11 @@
 #define USB_REQUEST_ION_ENABLE_SUSPEND	9	// Enable/Disable suspend feature
 						// (wValue != 0: Enable; wValue = 0: Disable)
 
-#define USB_REQUEST_ION_SEND_IOSP	10	// Send an IOSP command to the edgeport over the control pipe	
-#define USB_REQUEST_ION_RECV_IOSP	11	// Receive an IOSP command from the edgeport over the control pipe
-
-
-#define USB_REQUEST_ION_DIS_INT_TIMER	0x80	// Sent to Axiohm to enable/ disable
-						// interrupt token timer
-						// wValue = 1, enable (default)
-						// wValue = 0, disable
 
 //
 // Define parameter values for our vendor-specific commands
 //
 
-//
-// Edgeport Compatiblity Descriptor
-//
-// This descriptor is only returned by Edgeport-compatible devices
-// supporting the EPiC spec. True ION devices do not return this
-// descriptor, but instead return STALL on receipt of the
-// GET_EPIC_DESC command. The driver interprets a STALL to mean that
-// this is a "real" Edgeport.
-//
-
-struct edge_compatibility_bits
-{
-	// This __u32 defines which Vendor-specific commands/functionality
-	// the device supports on the default EP0 pipe.
-
-	__u32	VendEnableSuspend	:  1;	// 0001 Set if device supports ION_ENABLE_SUSPEND
-	__u32	VendUnused		: 31;	// Available for future expansion, must be 0
-
-	// This __u32 defines which IOSP commands are supported over the
-	// bulk pipe EP1.
-
-											// xxxx Set if device supports:
-	__u32	IOSPOpen		:  1;	// 0001	OPEN / OPEN_RSP (Currently must be 1)
-	__u32	IOSPClose		:  1;	// 0002	CLOSE
-	__u32	IOSPChase		:  1;	// 0004	CHASE / CHASE_RSP
-	__u32	IOSPSetRxFlow		:  1;	// 0008	SET_RX_FLOW
-	__u32	IOSPSetTxFlow		:  1;	// 0010	SET_TX_FLOW
-	__u32	IOSPSetXChar		:  1;	// 0020	SET_XON_CHAR/SET_XOFF_CHAR
-	__u32	IOSPRxCheck		:  1;	// 0040	RX_CHECK_REQ/RX_CHECK_RSP
-	__u32	IOSPSetClrBreak		:  1;	// 0080	SET_BREAK/CLEAR_BREAK
-	__u32	IOSPWriteMCR		:  1;	// 0100	MCR register writes (set/clr DTR/RTS)
-	__u32	IOSPWriteLCR		:  1;	// 0200	LCR register writes (wordlen/stop/parity)
-	__u32	IOSPSetBaudRate		:  1;	// 0400	setting Baud rate (writes to LCR.80h and DLL/DLM register)
-	__u32	IOSPDisableIntPipe	:  1;	// 0800 Do not use the interrupt pipe for TxCredits or RxButesAvailable
-	__u32	IOSPRxDataAvail		:  1;   // 1000 Return status of RX Fifo (Data available in Fifo)
-	__u32	IOSPTxPurge		:  1;	// 2000 Purge TXBuffer and/or Fifo in Edgeport hardware
-	__u32	IOSPUnused		: 18;	// Available for future expansion, must be 0
-
-	// This __u32 defines which 'general' features are supported
-
-	__u32	TrueEdgeport		:  1;	// 0001	Set if device is a 'real' Edgeport
-											// (Used only by driver, NEVER set by an EPiC device)
-	__u32	GenUnused		: 31;	// Available for future expansion, must be 0
-
-};
-
-struct edge_compatibility_descriptor
-{
-	__u8	Length;				// Descriptor Length (per USB spec)
-	__u8	DescType;			// Descriptor Type (per USB spec, =DEVICE type)
-	__u8	EpicVer;			// Version of EPiC spec supported
-											// (Currently must be 1)
-	__u8	NumPorts;			// Number of serial ports supported
-	__u8	iDownloadFile;			// Index of string containing download code filename
-											// 0=no download, FF=download compiled into driver.
-	__u8	Unused[ 3 ];			// Available for future expansion, must be 0
-											// (Currently must be 0).
-	__u8	MajorVersion;			// Firmware version: xx.
-	__u8	MinorVersion;			//  yy.
-	__le16	BuildNumber;			//  zzzz (LE format)
-
-	// The following structure contains __u32s, with each bit
-	// specifying whether the EPiC device supports the given
-	// command or functionality.
-
-	struct edge_compatibility_bits	Supports;
-
-};
 
 // Values for iDownloadFile
 #define	EDGE_DOWNLOAD_FILE_NONE		0	// No download requested
@@ -439,30 +272,30 @@
 
 	__u8	NumPorts;				// F08 Number of ports
 	__u8	DescDate[3];				// F09 MM/DD/YY when descriptor template was compiler,
-							//     so host can track changes to USB-only descriptors.
+							//	   so host can track changes to USB-only descriptors.
 
 	__u8	SerNumLength;				// F0C USB string descriptor len
 	__u8	SerNumDescType;				// F0D USB descriptor type (=STRING type)
-	__le16	SerialNumber[MAX_SERIALNUMBER_LEN];	// F0E "01-01-000100" Unicode Serial Number
+	__u16	SerialNumber[MAX_SERIALNUMBER_LEN];	// F0E "01-01-000100" Unicode Serial Number
 
 	__u8	AssemblyNumLength;			// F26 USB string descriptor len
 	__u8	AssemblyNumDescType;			// F27 USB descriptor type (=STRING type)
-	__le16	AssemblyNumber[MAX_ASSEMBLYNUMBER_LEN];	// F28 "350-1000-01-A " assembly number
+	__u16	AssemblyNumber[MAX_ASSEMBLYNUMBER_LEN];	// F28 "350-1000-01-A " assembly number
 
 	__u8	OemAssyNumLength;			// F44 USB string descriptor len
 	__u8	OemAssyNumDescType;			// F45 USB descriptor type (=STRING type)
-	__le16	OemAssyNumber[MAX_ASSEMBLYNUMBER_LEN];	// F46 "xxxxxxxxxxxxxx" OEM assembly number
+	__u16	OemAssyNumber[MAX_ASSEMBLYNUMBER_LEN];	// F46 "xxxxxxxxxxxxxx" OEM assembly number
 
 	__u8	ManufDateLength;			// F62 USB string descriptor len
 	__u8	ManufDateDescType;			// F63 USB descriptor type (=STRING type)
-	__le16	ManufDate[6];				// F64 "MMDDYY" manufacturing date
+	__u16	ManufDate[6];				// F64 "MMDDYY" manufacturing date
 
 	__u8	Reserved3[0x4D];			// F70 -- unused, set to 0 --
 
 	__u8	UartType;				// FBD Uart Type
 	__u8	IonPid;					// FBE Product ID, == LSB of USB DevDesc.PID
-							//      (Note: Edgeport/4s before 11/98 will have
-							//       00 here instead of 01)
+							//     (Note: Edgeport/4s before 11/98 will have
+							//		00 here instead of 01)
 	__u8	IonConfig;				// FBF Config byte for ION manufacturing use
 							// FBF end of structure, total len = 3C0h
 
@@ -479,7 +312,7 @@
 // both 00 and 01 values mean '654.
 #define MANUF_UART_EXAR_654_EARLY	0	// Exar 16C654 in Edgeport/4s before 11/98
 #define MANUF_UART_EXAR_654		1	// Exar 16C654
-#define MANUF_UART_EXAR_2852		2	// Exar 16C2852
+#define MANUF_UART_EXAR_2852		2	// Exar 16C2852 
 
 //
 // Note: The CpuRev and BoardRev values do not conform to manufacturing
@@ -501,22 +334,25 @@
 #define MANUF_BOARD_REV_GENERATION_2	0x20	// Second generaiton edgeport
 
 
+
+
 // Values of bottom 5 bits of CpuRev & BoardRev for
 // Implementation 1 (ie, 251+Netchip-based)
 #define	MANUF_CPU_REV_1			1	// C251TB Rev 1 (Need actual Intel rev here)
 
 #define MANUF_BOARD_REV_A		1	// First rev of 251+Netchip design
 
+
+
 #define	MANUF_SERNUM_LENGTH		sizeof(((struct edge_manuf_descriptor *)0)->SerialNumber)
 #define	MANUF_ASSYNUM_LENGTH		sizeof(((struct edge_manuf_descriptor *)0)->AssemblyNumber)
 #define	MANUF_OEMASSYNUM_LENGTH		sizeof(((struct edge_manuf_descriptor *)0)->OemAssyNumber)
 #define	MANUF_MANUFDATE_LENGTH		sizeof(((struct edge_manuf_descriptor *)0)->ManufDate)
 
-#define	MANUF_ION_CONFIG_DIAG_NO_LOOP	0x20	// As below but no ext loopback test
-#define	MANUF_ION_CONFIG_DIAG		0x40	// 930 based device: 1=Run h/w diags, 0=norm
-						// TIUMP Device    : 1=IONSERIAL needs to run Final Test
-#define	MANUF_ION_CONFIG_MASTER		0x80	// 930 based device:  1=Master mode, 0=Normal
-						// TIUMP Device    :  1=First device on a multi TIUMP Device
+#define	MANUF_ION_CONFIG_MASTER		0x80	// 1=Master mode, 0=Normal
+#define	MANUF_ION_CONFIG_DIAG		0x40	// 1=Run h/w diags, 0=norm
+#define	MANUF_ION_CONFIG_DIAG_NO_LOOP	0x20	// As above but no ext loopback test
+
 
 //
 // This structure describes parameters for the boot code, and
@@ -532,19 +368,19 @@
 	__u8		DescVer;		// C2 Desc version/format
 	__u8		Reserved1;		// C3 -- unused, set to 0 --
 
-	__le16		BootCodeLength;		// C4 Boot code goes from FF:0000 to FF:(len-1)
+	__u16		BootCodeLength;		// C4 Boot code goes from FF:0000 to FF:(len-1)
 						//	  (LE format)
 
 	__u8		MajorVersion;		// C6 Firmware version: xx.
 	__u8		MinorVersion;		// C7			yy.
-	__le16		BuildNumber;		// C8			zzzz (LE format)
+	__u16		BuildNumber;		// C8			zzzz (LE format)
 	
 	__u16		EnumRootDescTable;	// CA Root of ROM-based descriptor table
 	__u8		NumDescTypes;		// CC Number of supported descriptor types
 
 	__u8		Reserved4;		// CD Fix Compiler Packing
 
-	__le16		Capabilities;		// CE-CF Capabilities flags (LE format)
+	__u16		Capabilities;		// CE-CF Capabilities flags (LE format)
 	__u8		Reserved2[0x28];	// D0 -- unused, set to 0 --
 	__u8		UConfig0;		// F8 930-defined CPU configuration byte 0
 	__u8		UConfig1;		// F9 930-defined CPU configuration byte 1
@@ -562,29 +398,23 @@
 #define	BOOT_CAP_RESET_CMD	0x0001	// If set, boot correctly supports ION_RESET_DEVICE
 
 
+
 /************************************************************************
                  T I   U M P   D E F I N I T I O N S
  ***********************************************************************/
 
-// Chip definitions in I2C
-#define UMP5152			0x52
-#define UMP3410			0x10
-
-
 //************************************************************************
 //	TI I2C Format Definitions
 //************************************************************************
-#define I2C_DESC_TYPE_INFO_BASIC	0x01
-#define I2C_DESC_TYPE_FIRMWARE_BASIC	0x02
-#define I2C_DESC_TYPE_DEVICE		0x03
-#define I2C_DESC_TYPE_CONFIG		0x04
-#define I2C_DESC_TYPE_STRING		0x05
-#define I2C_DESC_TYPE_FIRMWARE_AUTO	0x07	// for 3410 download
-#define I2C_DESC_TYPE_CONFIG_KLUDGE	0x14	// for 3410
-#define I2C_DESC_TYPE_WATCHPORT_VERSION	0x15	// firmware version number for watchport
-#define I2C_DESC_TYPE_WATCHPORT_CALIBRATION_DATA 0x16	// Watchport Calibration Data
+#define I2C_DESC_TYPE_INFO_BASIC	1
+#define I2C_DESC_TYPE_FIRMWARE_BASIC	2
+#define I2C_DESC_TYPE_DEVICE		3
+#define I2C_DESC_TYPE_CONFIG		4
+#define I2C_DESC_TYPE_STRING		5
+#define I2C_DESC_TYPE_FIRMWARE_BLANK 	0xf2
 
-#define I2C_DESC_TYPE_FIRMWARE_BLANK	0xf2
+#define I2C_DESC_TYPE_MAX		5
+// 3410 may define types 6, 7 for other firmware downloads
 
 // Special section defined by ION
 #define I2C_DESC_TYPE_ION		0	// Not defined by TI
@@ -598,9 +428,7 @@
 	__u8	Data[0];		// Data starts here
 }__attribute__((packed));
 
-// for 5152 devices only (type 2 record)
-// for 3410 the version is stored in the WATCHPORT_FIRMWARE_VERSION descriptor
-struct ti_i2c_firmware_rec
+struct ti_i2c_firmware_rec 
 {
 	__u8	Ver_Major;		// Firmware Major version number
 	__u8	Ver_Minor;		// Firmware Minor version number
@@ -608,14 +436,6 @@
 }__attribute__((packed));
 
 
-struct watchport_firmware_version
-{
-// Added 2 bytes for version number
-	__u8	Version_Major;		//  Download Version (for Watchport)
-	__u8	Version_Minor;
-}__attribute__((packed));
-
-
 // Structure of header of download image in fw_down.h
 struct ti_i2c_image_header
 {
@@ -641,15 +461,6 @@
 } __attribute__((packed));
 
 
-// CPU / Board Rev Definitions
-#define TI_CPU_REV_5052			2	// 5052 based edgeports
-#define TI_CPU_REV_3410			3	// 3410 based edgeports
-
-#define TI_BOARD_REV_TI_EP		0	// Basic ti based edgeport
-#define TI_BOARD_REV_COMPACT		1	// Compact board
-#define TI_BOARD_REV_WATCHPORT		2	// Watchport
-
-
 #define TI_GET_CPU_REVISION(x)		(__u8)((((x)>>4)&0x0f))
 #define TI_GET_BOARD_REVISION(x)	(__u8)(((x)&0x0f))
 
@@ -658,30 +469,20 @@
 
 #define TI_MAX_I2C_SIZE			( 16 * 1024 )
 
-#define TI_MANUF_VERSION_0		0	
-
-// IonConig2 flags
-#define TI_CONFIG2_RS232		0x01
-#define TI_CONFIG2_RS422		0x02
-#define TI_CONFIG2_RS485		0x04
-#define TI_CONFIG2_SWITCHABLE		0x08
-
-#define TI_CONFIG2_WATCHPORT		0x10
-
-
+/* TI USB 5052 definitions */
 struct edge_ti_manuf_descriptor
 {
 	__u8 IonConfig;		//  Config byte for ION manufacturing use
 	__u8 IonConfig2;	//  Expansion
-	__u8 Version;		//  Version
+	__u8 Version;		//  Verqsion
 	__u8 CpuRev_BoardRev;	//  CPU revision level (0xF0) and Board Rev Level (0x0F)
 	__u8 NumPorts;		//  Number of ports	for this UMP
 	__u8 NumVirtualPorts;	//  Number of Virtual ports
 	__u8 HubConfig1;	//  Used to configure the Hub
 	__u8 HubConfig2;	//  Used to configure the Hub
 	__u8 TotalPorts;	//  Total Number of Com Ports for the entire device (All UMPs)
-	__u8 Reserved;		//  Reserved
+	__u8 Reserved;
 }__attribute__((packed));
 
 
-#endif		// if !defined(_USBVEND_H)
+#endif		// if !defined()
diff -Naur linuxppc-2.6.9/drivers/usb/serial/ipaq.c linuxppc-2.6.9-dream/drivers/usb/serial/ipaq.c
--- linuxppc-2.6.9/drivers/usb/serial/ipaq.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/ipaq.c	2005-09-19 21:40:06.000000000 +0200
@@ -56,6 +56,13 @@
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug = 0;
+#endif
+
 #include "usb-serial.h"
 #include "ipaq.h"
 
@@ -69,8 +76,7 @@
 #define DRIVER_AUTHOR "Ganesh Varadarajan <ganesh@veritas.com>"
 #define DRIVER_DESC "USB PocketPC PDA driver"
 
-static __u16 product, vendor;
-static int debug;
+static int	product, vendor;
 
 /* Function prototypes for an ipaq */
 static int  ipaq_open (struct usb_serial_port *port, struct file *filp);
@@ -127,10 +133,8 @@
 	{ USB_DEVICE(TOSHIBA_VENDOR_ID, TOSHIBA_E740_ID) },
 	{ USB_DEVICE(TOSHIBA_VENDOR_ID, TOSHIBA_E335_ID) },
 	{ USB_DEVICE(HTC_VENDOR_ID, HTC_PRODUCT_ID) },
-	{ USB_DEVICE(HTC_VENDOR_ID, HTC_HIMALAYA_ID) },
 	{ USB_DEVICE(NEC_VENDOR_ID, NEC_PRODUCT_ID) },
 	{ USB_DEVICE(ASUS_VENDOR_ID, ASUS_A600_PRODUCT_ID) },
-	{ USB_DEVICE(ASUS_VENDOR_ID, ASUS_A620_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 
@@ -146,7 +150,7 @@
 
 
 /* All of the device info needed for the Compaq iPAQ */
-static struct usb_serial_device_type ipaq_device = {
+struct usb_serial_device_type ipaq_device = {
 	.owner =		THIS_MODULE,
 	.name =			"PocketPC PDA",
 	.id_table =		ipaq_id_table,
@@ -177,6 +181,10 @@
 	int			i, result = 0;
 	int			retries = KP_RETRIES;
 
+	if (port_paranoia_check(port, __FUNCTION__)) {
+		return -ENODEV;
+	}
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	bytes_in = 0;
@@ -189,7 +197,6 @@
 	usb_set_serial_port_data(port, priv);
 	priv->active = 0;
 	priv->queue_len = 0;
-	priv->free_len = 0;
 	INIT_LIST_HEAD(&priv->queue);
 	INIT_LIST_HEAD(&priv->freelist);
 
@@ -281,13 +288,23 @@
 
 static void ipaq_close(struct usb_serial_port *port, struct file *filp)
 {
+	struct usb_serial	*serial;
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);
 
+	if (port_paranoia_check(port, __FUNCTION__)) {
+		return; 
+	}
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 			 
+	serial = get_usb_serial(port, __FUNCTION__);
+	if (!serial)
+		return;
+
 	/*
 	 * shut down bulk read and write
 	 */
+
 	usb_unlink_urb(port->write_urb);
 	usb_unlink_urb(port->read_urb);
 	ipaq_destroy_lists(port);
@@ -301,18 +318,27 @@
 static void ipaq_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port	*port = (struct usb_serial_port *)urb->context;
+	struct usb_serial	*serial = get_usb_serial (port, __FUNCTION__);
 	struct tty_struct	*tty;
 	unsigned char		*data = urb->transfer_buffer;
 	int			i, result;
 
+	if (port_paranoia_check(port, __FUNCTION__))
+		return;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	tty = port->tty;
 	if (tty && urb->actual_length) {
@@ -329,8 +355,8 @@
 	}
 
 	/* Continue trying to always read  */
-	usb_fill_bulk_urb(port->read_urb, port->serial->dev, 
-		      usb_rcvbulkpipe(port->serial->dev, port->bulk_in_endpointAddress),
+	usb_fill_bulk_urb(port->read_urb, serial->dev, 
+		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
 		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
 		      ipaq_read_bulk_callback, port);
 	result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
@@ -393,7 +419,7 @@
 	} else {
 		memcpy(pkt->data, buf, count);
 	}
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, pkt->data);
+	usb_serial_debug_data(__FILE__, __FUNCTION__, count, pkt->data);
 
 	pkt->len = count;
 	pkt->written = 0;
@@ -462,6 +488,10 @@
 	unsigned long		flags;
 	int			result;
 
+	if (port_paranoia_check (port, __FUNCTION__)) {
+		return;
+	}
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (urb->status) {
@@ -576,11 +606,11 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
 
-module_param(vendor, ushort, 0);
+MODULE_PARM(vendor, "h");
 MODULE_PARM_DESC(vendor, "User specified USB idVendor");
 
-module_param(product, ushort, 0);
+MODULE_PARM(product, "h");
 MODULE_PARM_DESC(product, "User specified USB idProduct");
diff -Naur linuxppc-2.6.9/drivers/usb/serial/ipaq.h linuxppc-2.6.9-dream/drivers/usb/serial/ipaq.h
--- linuxppc-2.6.9/drivers/usb/serial/ipaq.h	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/ipaq.h	2005-09-19 21:40:06.000000000 +0200
@@ -78,7 +78,6 @@
 
 #define HTC_VENDOR_ID		0x0bb4
 #define HTC_PRODUCT_ID		0x00ce
-#define HTC_HIMALAYA_ID		0x0a02
 
 #define NEC_VENDOR_ID		0x0409
 #define NEC_PRODUCT_ID		0x00d5
@@ -86,9 +85,6 @@
 #define ASUS_VENDOR_ID		0x0b05
 #define ASUS_A600_PRODUCT_ID	0x4201
 
-#define ASUS_VENDOR_ID		0x0b05
-#define ASUS_A620_PRODUCT_ID	0x4202
-
 /*
  * Since we can't queue our bulk write urbs (don't know why - it just
  * doesn't work), we can send down only one write urb at a time. The simplistic
diff -Naur linuxppc-2.6.9/drivers/usb/serial/ir-usb.c linuxppc-2.6.9-dream/drivers/usb/serial/ir-usb.c
--- linuxppc-2.6.9/drivers/usb/serial/ir-usb.c	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/ir-usb.c	2005-09-19 21:40:06.000000000 +0200
@@ -58,6 +58,13 @@
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 #include "usb-serial.h"
 
 /*
@@ -94,11 +101,9 @@
 	u8	bMaxUnicastList;
 } __attribute__ ((packed));
 
-static int debug;
-
 /* if overridden by the user, then use their value for the size of the read and
  * write urbs */
-static int buffer_size;
+static int buffer_size = 0;
 /* if overridden by the user, then use the specified number of XBOFs */
 static int xbof = -1;
 
@@ -133,7 +138,7 @@
 };
 
 
-static struct usb_serial_device_type ir_device = {
+struct usb_serial_device_type ir_device = {
 	.owner =		THIS_MODULE,
 	.name =			"IR Dongle",
 	.id_table =		id_table,
@@ -274,9 +279,13 @@
 
 static int ir_open (struct usb_serial_port *port, struct file *filp)
 {
+	struct usb_serial *serial = port->serial;
 	char *buffer;
 	int result = 0;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return -ENODEV;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (buffer_size) {
@@ -304,8 +313,8 @@
 	/* Start reading from the device */
 	usb_fill_bulk_urb (
 		port->read_urb,
-		port->serial->dev, 
-		usb_rcvbulkpipe(port->serial->dev, port->bulk_in_endpointAddress),
+		serial->dev, 
+		usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
 		port->read_urb->transfer_buffer,
 		port->read_urb->transfer_buffer_length,
 		ir_read_bulk_callback,
@@ -319,10 +328,21 @@
 
 static void ir_close (struct usb_serial_port *port, struct file * filp)
 {
+	struct usb_serial *serial;
+
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 			 
-	/* shutdown our bulk read */
-	usb_unlink_urb (port->read_urb);
+	serial = get_usb_serial (port, __FUNCTION__);
+	if (!serial)
+		return;
+	
+	if (serial->dev) {
+		/* shutdown our bulk read */
+		usb_unlink_urb (port->read_urb);
+	}
 }
 
 static int ir_write (struct usb_serial_port *port, int from_user, const unsigned char *buf, int count)
@@ -391,6 +411,9 @@
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (urb->status) {
@@ -399,8 +422,7 @@
 	}
 
 	usb_serial_debug_data (
-		debug,
-		&port->dev,
+		__FILE__,
 		__FUNCTION__,
 		urb->actual_length,
 		urb->transfer_buffer);
@@ -411,12 +433,21 @@
 static void ir_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
 	int result;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (!port->open_count) {
 		dbg("%s - port closed.", __FUNCTION__);
 		return;
@@ -435,8 +466,7 @@
 				ir_baud = *data & 0x0f;
 
 			usb_serial_debug_data (
-				debug,
-				&port->dev,
+				__FILE__,
 				__FUNCTION__,
 				urb->actual_length,
 				data);
@@ -449,10 +479,6 @@
 			 */
 			tty = port->tty;
 
-			/*
-			 *	FIXME: must not do this in IRQ context,
-			 *	must honour TTY_DONT_FLIP
-			 */
 			tty->ldisc.receive_buf(
 				tty,
 				data+1,
@@ -470,8 +496,8 @@
 			/* Continue trying to always read */
 			usb_fill_bulk_urb (
 				port->read_urb,
-				port->serial->dev, 
-				usb_rcvbulkpipe(port->serial->dev,
+				serial->dev, 
+				usb_rcvbulkpipe(serial->dev,
 					port->bulk_in_endpointAddress),
 				port->read_urb->transfer_buffer,
 				port->read_urb->transfer_buffer_length,
@@ -615,10 +641,10 @@
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
-module_param(xbof, int, 0);
+MODULE_PARM(xbof, "i");
 MODULE_PARM_DESC(xbof, "Force specific number of XBOFs");
-module_param(buffer_size, int, 0);
+MODULE_PARM(buffer_size, "i");
 MODULE_PARM_DESC(buffer_size, "Size of the transfer buffers");
 
diff -Naur linuxppc-2.6.9/drivers/usb/serial/Kconfig linuxppc-2.6.9-dream/drivers/usb/serial/Kconfig
--- linuxppc-2.6.9/drivers/usb/serial/Kconfig	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/Kconfig	2005-09-19 21:40:06.000000000 +0200
@@ -20,6 +20,13 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called usbserial.
 
+config USB_SERIAL_DEBUG
+	bool "USB Serial Converter verbose debug"
+	depends on USB_SERIAL=y
+	help
+	  Say Y here if you want verbose debug messages from the USB Serial
+	  Drivers sent to the kernel debug log.
+
 config USB_SERIAL_CONSOLE
 	bool "USB Serial Console device support (EXPERIMENTAL)"
 	depends on USB_SERIAL=y && EXPERIMENTAL
@@ -307,8 +314,8 @@
 	  module will be called kl5kusb105.
 
 config USB_SERIAL_KOBIL_SCT
-        tristate "USB KOBIL chipcard reader"
-        depends on USB_SERIAL
+        tristate "USB KOBIL chipcard reader (EXPERIMENTAL)"
+        depends on USB_SERIAL && EXPERIMENTAL
         ---help---
           Say Y here if you want to use one of the following KOBIL USB chipcard
           readers:
diff -Naur linuxppc-2.6.9/drivers/usb/serial/keyspan.c linuxppc-2.6.9-dream/drivers/usb/serial/keyspan.c
--- linuxppc-2.6.9/drivers/usb/serial/keyspan.c	2004-10-18 23:53:21.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/keyspan.c	2005-09-19 21:40:06.000000000 +0200
@@ -107,12 +107,20 @@
 #include <linux/module.h>
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+	#define DEBUG
+#else
+	static int debug;
+	#undef DEBUG
+#endif
+
 #include <linux/usb.h>
+
 #include "usb-serial.h"
 #include "keyspan.h"
 
-static int debug;
-
 /*
  * Version Information
  */
@@ -125,6 +133,9 @@
 
 	/* Per device and per port private data */
 struct keyspan_serial_private {
+	/* number of active ports */
+	atomic_t	active_count;
+
 	const struct keyspan_device_details	*device_details;
 
 	struct urb	*instat_urb;
@@ -1133,10 +1144,14 @@
 static void keyspan_close(struct usb_serial_port *port, struct file *filp)
 {
 	int			i;
-	struct usb_serial	*serial = port->serial;
+	struct usb_serial	*serial;
 	struct keyspan_serial_private 	*s_priv;
 	struct keyspan_port_private 	*p_priv;
 
+	serial = get_usb_serial (port, __FUNCTION__);
+	if (!serial)
+		return;
+
 	dbg("%s", __FUNCTION__);
 	s_priv = usb_get_serial_data(serial);
 	p_priv = usb_get_serial_port_data(port);
@@ -1167,7 +1182,7 @@
 			stop_urb(p_priv->out_urbs[i]);
 		}
 	}
-	port->tty = NULL;
+	port->tty = 0;
 }
 
 
@@ -2354,6 +2369,6 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
 
diff -Naur linuxppc-2.6.9/drivers/usb/serial/keyspan.h linuxppc-2.6.9-dream/drivers/usb/serial/keyspan.h
--- linuxppc-2.6.9/drivers/usb/serial/keyspan.h	2004-10-18 23:54:39.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/keyspan.h	2005-09-19 21:40:06.000000000 +0200
@@ -326,22 +326,6 @@
 	.baudclk		= KEYSPAN_USA19_BAUDCLK,
 };
 
-static const struct keyspan_device_details mpr_device_details = {
-	.product_id		= keyspan_mpr_product_id,
-	.msg_format		= msg_usa28,
-	.num_ports		= 1,
-	.indat_endp_flip	= 1,
-	.outdat_endp_flip	= 1,
-	.indat_endpoints	= {0x81},
-	.outdat_endpoints	= {0x01},
-	.inack_endpoints	= {0x83},
-	.outcont_endpoints	= {0x03},
-	.instat_endpoint	= 0x84,
-	.glocont_endpoint	= -1,
-	.calculate_baud_rate	= keyspan_usa28_calc_baud,
-	.baudclk		= KEYSPAN_USA19_BAUDCLK,
-};
-
 static const struct keyspan_device_details usa19qw_device_details = {
 	.product_id		= keyspan_usa19qw_product_id,
 	.msg_format		= msg_usa26,
@@ -476,7 +460,6 @@
 	&usa18x_device_details,
 	&usa19_device_details,
 	&usa19qi_device_details,
-	&mpr_device_details,
 	&usa19qw_device_details,
 	&usa19w_device_details,
 	&usa19hs_device_details,
@@ -552,7 +535,7 @@
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qw_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19w_product_id) },
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19hs_product_id) },
-	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_mpr_product_id) },
+	{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_mpr_pre_product_id) },
 	{ } /* Terminating entry */
 };
 
diff -Naur linuxppc-2.6.9/drivers/usb/serial/keyspan_pda.c linuxppc-2.6.9-dream/drivers/usb/serial/keyspan_pda.c
--- linuxppc-2.6.9/drivers/usb/serial/keyspan_pda.c	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/keyspan_pda.c	2005-09-19 21:40:06.000000000 +0200
@@ -80,7 +80,12 @@
 #include <asm/uaccess.h>
 #include <linux/usb.h>
 
-static int debug;
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 
 struct ezusb_hex_record {
 	__u16 address;
@@ -186,7 +191,13 @@
 	wake_up_interruptible( &port->write_wait );
 
 	/* wake up line discipline */
-	tty_wakeup(tty);
+	if( (tty->flags & (1 << TTY_DO_WRITE_WAKEUP))
+	&& tty->ldisc.write_wakeup )
+		(tty->ldisc.write_wakeup)(tty);
+
+	/* wake up other tty processes */
+	wake_up_interruptible( &tty->write_wait );
+	/* For 2.2.16 backport -- wake_up_interruptible( &tty->poll_wait ); */
 }
 
 static void keyspan_pda_request_unthrottle( struct usb_serial *serial )
@@ -215,7 +226,8 @@
 static void keyspan_pda_rx_interrupt (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
-       	struct tty_struct *tty = port->tty;
+	struct usb_serial *serial;
+       	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
 	int i;
 	int status;
@@ -237,11 +249,22 @@
 		goto exit;
 	}
 
+	
+	if (port_paranoia_check (port, "keyspan_pda_rx_interrupt")) {
+		return;
+	}
+
+	serial = port->serial;
+	if (serial_paranoia_check (serial, "keyspan_pda_rx_interrupt")) {
+		return;
+	}
+	
  	/* see if the message is data or a status interrupt */
 	switch (data[0]) {
 	case 0:
 		/* rest of message is rx data */
 		if (urb->actual_length) {
+			tty = serial->port[0]->tty;
 			for (i = 1; i < urb->actual_length ; ++i) {
 				tty_insert_flip_char(tty, data[i], 0);
 			}
@@ -255,6 +278,7 @@
 		case 1: /* modemline change */
 			break;
 		case 2: /* tx unthrottle interrupt */
+			tty = serial->port[0]->tty;
 			priv->tx_throttled = 0;
 			/* queue up a wakeup at scheduler time */
 			schedule_work(&priv->wakeup_work);
@@ -609,10 +633,20 @@
 static void keyspan_pda_write_bulk_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial;
 	struct keyspan_pda_private *priv;
 
 	priv = usb_get_serial_port_data(port);
 
+	if (port_paranoia_check (port, "keyspan_pda_rx_interrupt")) {
+		return;
+	}
+
+	serial = port->serial;
+	if (serial_paranoia_check (serial, "keyspan_pda_rx_interrupt")) {
+		return;
+	}
+	
 	/* queue up a wakeup at scheduler time */
 	schedule_work(&priv->wakeup_work);
 }
@@ -770,7 +804,7 @@
 	usb_set_serial_port_data(serial->port[0], priv);
 	init_waitqueue_head(&serial->port[0]->write_wait);
 	INIT_WORK(&priv->wakeup_work, (void *)keyspan_pda_wakeup_write,
-			(void *)(serial->port[0]));
+			(void *)(&serial->port[0]));
 	INIT_WORK(&priv->unthrottle_work,
 			(void *)keyspan_pda_request_unthrottle,
 			(void *)(serial));
@@ -898,6 +932,6 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
 
diff -Naur linuxppc-2.6.9/drivers/usb/serial/kl5kusb105.c linuxppc-2.6.9-dream/drivers/usb/serial/kl5kusb105.c
--- linuxppc-2.6.9/drivers/usb/serial/kl5kusb105.c	2004-10-18 23:54:32.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/kl5kusb105.c	2005-09-19 21:40:06.000000000 +0200
@@ -56,10 +56,16 @@
 #include <linux/module.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+ 	static int debug = 1;
+#else
+ 	static int debug;
+#endif
+
 #include "usb-serial.h"
 #include "kl5kusb105.h"
 
-static int debug;
 
 /*
  * Version Information
@@ -181,13 +187,12 @@
 
 #define KLSI_TIMEOUT	 (HZ * 5 ) /* default urb timeout */
 
-static int klsi_105_chg_port_settings(struct usb_serial_port *port,
+static int klsi_105_chg_port_settings(struct usb_serial *serial,
 				      struct klsi_105_port_settings *settings)
 {
 	int rc;
 
-        rc = usb_control_msg(port->serial->dev,
-			     usb_sndctrlpipe(port->serial->dev, 0),
+        rc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 			     KL5KUSB105A_SIO_SET_DATA,
                              USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_INTERFACE,
 			     0, /* value */
@@ -222,7 +227,7 @@
  */
 /* It seems that the status buffer has always only 2 bytes length */
 #define KLSI_STATUSBUF_LEN	2
-static int klsi_105_get_line_state(struct usb_serial_port *port,
+static int klsi_105_get_line_state(struct usb_serial *serial,
 				   unsigned long *line_state_p)
 {
 	int rc;
@@ -230,8 +235,7 @@
 	__u16 status;
 
 	info("%s - sending SIO Poll request", __FUNCTION__);
-        rc = usb_control_msg(port->serial->dev,
-			     usb_rcvctrlpipe(port->serial->dev, 0),
+        rc = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
 			     KL5KUSB105A_SIO_POLL,
                              USB_TYPE_VENDOR | USB_DIR_IN,
 			     0, /* value */
@@ -358,6 +362,7 @@
 
 static int  klsi_105_open (struct usb_serial_port *port, struct file *filp)
 {
+	struct usb_serial *serial = port->serial;
 	struct klsi_105_private *priv = usb_get_serial_port_data(port);
 	int retval = 0;
 	int rc;
@@ -384,7 +389,7 @@
 	cfg.databits = kl5kusb105a_dtb_8;
 	cfg.unknown1 = 0;
 	cfg.unknown2 = 1;
-	klsi_105_chg_port_settings(port, &cfg);
+	klsi_105_chg_port_settings(serial, &cfg);
 	
 	/* set up termios structure */
 	spin_lock_irqsave (&priv->lock, flags);
@@ -402,8 +407,8 @@
 	spin_unlock_irqrestore (&priv->lock, flags);
 
 	/* READ_ON and urb submission */
-	usb_fill_bulk_urb(port->read_urb, port->serial->dev, 
-		      usb_rcvbulkpipe(port->serial->dev,
+	usb_fill_bulk_urb(port->read_urb, serial->dev, 
+		      usb_rcvbulkpipe(serial->dev,
 				      port->bulk_in_endpointAddress),
 		      port->read_urb->transfer_buffer,
 		      port->read_urb->transfer_buffer_length,
@@ -417,8 +422,7 @@
 		goto exit;
 	}
 
-	rc = usb_control_msg(port->serial->dev,
-			     usb_sndctrlpipe(port->serial->dev,0),
+	rc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev,0),
 			     KL5KUSB105A_SIO_CONFIGURE,
 			     USB_TYPE_VENDOR|USB_DIR_OUT|USB_RECIP_INTERFACE,
 			     KL5KUSB105A_SIO_CONFIGURE_READ_ON,
@@ -432,7 +436,7 @@
 	} else 
 		dbg("%s - enabled reading", __FUNCTION__);
 
-	rc = klsi_105_get_line_state(port, &line_state);
+	rc = klsi_105_get_line_state(serial, &line_state);
 	if (rc >= 0) {
 		spin_lock_irqsave (&priv->lock, flags);
 		priv->line_state = line_state;
@@ -449,14 +453,20 @@
 
 static void klsi_105_close (struct usb_serial_port *port, struct file *filp)
 {
+	struct usb_serial *serial;
 	struct klsi_105_private *priv = usb_get_serial_port_data(port);
 	int rc;
 
 	dbg("%s port %d", __FUNCTION__, port->number);
 
+	serial = get_usb_serial (port, __FUNCTION__);
+
+	if(!serial)
+		return;
+
 	/* send READ_OFF */
-	rc = usb_control_msg (port->serial->dev,
-			      usb_sndctrlpipe(port->serial->dev, 0),
+	rc = usb_control_msg (serial->dev,
+			      usb_sndctrlpipe(serial->dev, 0),
 			      KL5KUSB105A_SIO_CONFIGURE,
 			      USB_TYPE_VENDOR | USB_DIR_OUT,
 			      KL5KUSB105A_SIO_CONFIGURE_READ_OFF,
@@ -487,6 +497,7 @@
 static int klsi_105_write (struct usb_serial_port *port, int from_user,
 			   const unsigned char *buf, int count)
 {
+	struct usb_serial *serial = port->serial;
 	struct klsi_105_private *priv = usb_get_serial_port_data(port);
 	int result, size;
 	int bytes_sent=0;
@@ -540,8 +551,8 @@
 		((__u8 *)urb->transfer_buffer)[1] = (__u8) ((size & 0xFF00)>>8);
 
 		/* set up our urb */
-		usb_fill_bulk_urb(urb, port->serial->dev,
-			      usb_sndbulkpipe(port->serial->dev,
+		usb_fill_bulk_urb(urb, serial->dev,
+			      usb_sndbulkpipe(serial->dev,
 					      port->bulk_out_endpointAddress),
 			      urb->transfer_buffer,
 			      URB_TRANSFER_BUFFER_SIZE,
@@ -568,9 +579,15 @@
 static void klsi_105_write_bulk_callback ( struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial = port->serial;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 	
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__,
 		    urb->status);
@@ -629,6 +646,7 @@
 static void klsi_105_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial = port->serial;
 	struct klsi_105_private *priv = usb_get_serial_port_data(port);
 	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
@@ -642,6 +660,10 @@
 		    urb->status);
                 return;
         }
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
 	
 	/* The data received is again preceded by a length double-byte in LSB-
 	 * first order (see klsi_105_write() )
@@ -653,8 +675,7 @@
 	} else if (urb->actual_length <= 2) {
 		dbg("%s - size %d URB not understood", __FUNCTION__,
 		    urb->actual_length);
-		usb_serial_debug_data(debug, &port->dev, __FUNCTION__,
-				      urb->actual_length, data);
+		usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 	} else {
 		int i;
 		int bytes_sent = ((__u8 *) data)[0] +
@@ -666,8 +687,8 @@
 		 * intermixed tty_flip_buffer_push()s
 		 * FIXME
 		 */ 
-		usb_serial_debug_data(debug, &port->dev, __FUNCTION__,
-				      urb->actual_length, data);
+		usb_serial_debug_data (__FILE__, __FUNCTION__,
+				       urb->actual_length, data);
 
 		if (bytes_sent + 2 > urb->actual_length) {
 			dbg("%s - trying to read more data than available"
@@ -693,8 +714,8 @@
 		priv->bytes_in += bytes_sent;
 	}
 	/* Continue trying to always read  */
-	usb_fill_bulk_urb(port->read_urb, port->serial->dev, 
-		      usb_rcvbulkpipe(port->serial->dev,
+	usb_fill_bulk_urb(port->read_urb, serial->dev, 
+		      usb_rcvbulkpipe(serial->dev,
 				      port->bulk_in_endpointAddress),
 		      port->read_urb->transfer_buffer,
 		      port->read_urb->transfer_buffer_length,
@@ -709,6 +730,7 @@
 static void klsi_105_set_termios (struct usb_serial_port *port,
 				  struct termios *old_termios)
 {
+	struct usb_serial *serial = port->serial;
 	struct klsi_105_private *priv = usb_get_serial_port_data(port);
 	unsigned int iflag = port->tty->termios->c_iflag;
 	unsigned int old_iflag = old_termios->c_iflag;
@@ -846,7 +868,7 @@
 	spin_unlock_irqrestore (&priv->lock, flags);
 	
 	/* now commit changes to device */
-	klsi_105_chg_port_settings(port, &cfg);
+	klsi_105_chg_port_settings(serial, &cfg);
 } /* klsi_105_set_termios */
 
 
@@ -868,13 +890,14 @@
 
 static int klsi_105_tiocmget (struct usb_serial_port *port, struct file *file)
 {
+	struct usb_serial *serial = port->serial;
 	struct klsi_105_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 	int rc;
 	unsigned long line_state;
 	dbg("%s - request, just guessing", __FUNCTION__);
 
-	rc = klsi_105_get_line_state(port, &line_state);
+	rc = klsi_105_get_line_state(serial, &line_state);
 	if (rc < 0) {
 		err("Reading line control failed (error = %d)", rc);
 		/* better return value? EAGAIN? */
@@ -921,7 +944,6 @@
 			   unsigned int cmd, unsigned long arg)
 {
 	struct klsi_105_private *priv = usb_get_serial_port_data(port);
-	void __user *user_arg = (void __user *)arg;
 	
 	dbg("%scmd=0x%x", __FUNCTION__, cmd);
 
@@ -944,12 +966,13 @@
 
 	     dbg("%s - TCGETS data faked/incomplete", __FUNCTION__);
 
-	     retval = verify_area(VERIFY_WRITE, user_arg,
+	     retval = verify_area(VERIFY_WRITE, (void *)arg,
 				  sizeof(struct termios));
+
 	     if (retval)
-			 return retval;
+			 return(retval);
 
-	     if (kernel_termios_to_user_termios((struct termios __user *)arg,
+	     if (kernel_termios_to_user_termios((struct termios *)arg,  
 						&priv->termios))
 		     return -EFAULT;
 	     return(0);
@@ -960,13 +983,14 @@
 
 		dbg("%s - TCSETS not handled", __FUNCTION__);
 
-		retval = verify_area(VERIFY_READ, user_arg,
+		retval = verify_area(VERIFY_READ, (void *)arg,
 				     sizeof(struct termios));
+
 		if (retval)
-			    return retval;
+			    return(retval);
 
 		if (user_termios_to_kernel_termios(&priv->termios,
-						  (struct termios __user *)arg))
+						  (struct termios *)arg))
 			return -EFAULT;
 		klsi_105_set_termios(port, &priv->termios);
 		return(0);
@@ -1046,7 +1070,11 @@
 MODULE_LICENSE("GPL"); 
 
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "enable extensive debugging messages");
+/* FIXME: implement
+MODULE_PARM(num_urbs, "i");
+MODULE_PARM_DESC(num_urbs, "number of URBs to use in write pool");
+*/
 
 /* vim: set sts=8 ts=8 sw=8: */
diff -Naur linuxppc-2.6.9/drivers/usb/serial/kobil_sct.c linuxppc-2.6.9-dream/drivers/usb/serial/kobil_sct.c
--- linuxppc-2.6.9/drivers/usb/serial/kobil_sct.c	2004-10-18 23:55:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/kobil_sct.c	2005-09-19 21:40:06.000000000 +0200
@@ -21,9 +21,6 @@
  * Supported readers: USB TWIN, KAAN Standard Plus and SecOVID Reader Plus
  * (Adapter K), B1 Professional and KAAN Professional (Adapter B)
  * 
- * (21/05/2004) tw
- *      Fix bug with P'n'P readers
- *
  * (28/05/2003) tw
  *      Add support for KAAN SIM
  *
@@ -48,13 +45,21 @@
 #include <asm/uaccess.h>
 #include <linux/usb.h>
 #include <linux/ioctl.h>
-#include "usb-serial.h"
+
+
 #include "kobil_sct.h"
+//#include "../core/usb-debug.c"
 
-static int debug;
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
+#include "usb-serial.h"
 
 /* Version Information */
-#define DRIVER_VERSION "21/05/2004"
+#define DRIVER_VERSION "28/05/2003"
 #define DRIVER_AUTHOR "KOBIL Systems GmbH - http://www.kobil.com"
 #define DRIVER_DESC "KOBIL USB Smart Card Terminal Driver (experimental)"
 
@@ -105,7 +110,7 @@
 };
 
 
-static struct usb_serial_device_type kobil_device = {
+struct usb_serial_device_type kobil_device = {
 	.owner =		THIS_MODULE,
 	.name =			"KOBIL USB smart card terminal",
 	.id_table =		id_table,
@@ -178,7 +183,7 @@
 	pdev = serial->dev;
  	actconfig = pdev->actconfig;
  	interface = actconfig->interface[0];
-	altsetting = interface->cur_altsetting;
+	altsetting = interface->altsetting;
  	endpoint = altsetting->endpoint;
   
  	for (i = 0; i < altsetting->desc.bNumEndpoints; i++) {
@@ -225,6 +230,9 @@
 	priv = usb_get_serial_port_data(port);
 	priv->line_state = 0;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return -ENODEV;
+
 	// someone sets the dev to 0 if the close method has been called
 	port->interrupt_in_urb->dev = port->serial->dev;
 
@@ -254,7 +262,7 @@
 	// allocate memory for transfer buffer
 	transfer_buffer = (unsigned char *) kmalloc(transfer_buffer_length, GFP_KERNEL);  
 	if (! transfer_buffer) {
-		return -ENOMEM;
+		return -1;
 	} else {
 		memset(transfer_buffer, 0, transfer_buffer_length);
 	}
@@ -266,7 +274,7 @@
 		if (!port->write_urb) {
 			dbg("%s - port %d usb_alloc_urb failed", __FUNCTION__, port->number);
 			kfree(transfer_buffer);
-			return -ENOMEM;
+			return -1;
 		}
 	}
 
@@ -274,9 +282,7 @@
 	port->write_urb->transfer_buffer = (unsigned char *) kmalloc(write_urb_transfer_buffer_length, GFP_KERNEL);
 	if (! port->write_urb->transfer_buffer) {
 		kfree(transfer_buffer);
-		usb_free_urb(port->write_urb);
-		port->write_urb = NULL;
-		return -ENOMEM;
+		return -1;
 	} 
 
 	// get hardware version
@@ -334,12 +340,6 @@
 			);
 		dbg("%s - port %d Send reset_all_queues URB returns: %i", __FUNCTION__, port->number, result);
 	}
-	if (priv->device_type == KOBIL_USBTWIN_PRODUCT_ID || priv->device_type == KOBIL_ADAPTER_B_PRODUCT_ID ||
-	    priv->device_type == KOBIL_KAAN_SIM_PRODUCT_ID) {
-		// start reading (Adapter B 'cause PNP string)
-		result = usb_submit_urb( port->interrupt_in_urb, GFP_ATOMIC  ); 
-		dbg("%s - port %d Send read URB returns: %i", __FUNCTION__, port->number, result);
-	}
 
 	kfree(transfer_buffer);
 	return 0;
@@ -353,7 +353,7 @@
 	if (port->write_urb){
 		usb_unlink_urb( port->write_urb );
 		usb_free_urb( port->write_urb );
-		port->write_urb = NULL;
+		port->write_urb = 0;
 	}
 	if (port->interrupt_in_urb){
 		usb_unlink_urb (port->interrupt_in_urb);
@@ -448,7 +448,7 @@
 		memcpy (priv->buf + priv->filled, buf, count);
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, priv->buf + priv->filled);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, count, priv->buf + priv->filled);
 
 	priv->filled = priv->filled + count;
 
@@ -457,11 +457,6 @@
 	if ( ((priv->device_type != KOBIL_ADAPTER_B_PRODUCT_ID) && (priv->filled > 2) && (priv->filled >= (priv->buf[1] + 3))) || 
 	     ((priv->device_type == KOBIL_ADAPTER_B_PRODUCT_ID) && (priv->filled > 3) && (priv->filled >= (priv->buf[2] + 4))) ) {
 		
-		// stop reading (except TWIN and KAAN SIM)
-		if ( (priv->device_type == KOBIL_ADAPTER_B_PRODUCT_ID) || (priv->device_type == KOBIL_ADAPTER_K_PRODUCT_ID) ) {
-			usb_unlink_urb( port->interrupt_in_urb );
-		}
-
 		todo = priv->filled - priv->cur_pos;
 
 		while(todo > 0) {
@@ -469,23 +464,25 @@
 			length = (todo < 8) ? todo : 8;
 			// copy data to transfer buffer
 			memcpy(port->write_urb->transfer_buffer, priv->buf + priv->cur_pos, length );
-			usb_fill_int_urb( port->write_urb,
-					  port->serial->dev,
-					  usb_sndintpipe(port->serial->dev, priv->write_int_endpoint_address),
-					  port->write_urb->transfer_buffer,
-					  length,
-					  kobil_write_callback,
-					  port,
-					  8
+			
+			usb_fill_bulk_urb( port->write_urb,
+					   port->serial->dev,
+					   usb_sndbulkpipe( port->serial->dev, priv->write_int_endpoint_address),
+					   port->write_urb->transfer_buffer,
+					   length,
+					   kobil_write_callback,
+					   port
 				);
 
 			priv->cur_pos = priv->cur_pos + length;
-			result = usb_submit_urb( port->write_urb, GFP_NOIO );
+			result = usb_submit_urb( port->write_urb, GFP_ATOMIC );
 			dbg("%s - port %d Send write URB returns: %i", __FUNCTION__, port->number, result);
 			todo = priv->filled - priv->cur_pos;
 
 			if (todo > 0) {
-				msleep(24);
+				//mdelay(16);
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				schedule_timeout(24 * HZ / 1000);
 			}
 
 		} // end while
@@ -496,14 +493,9 @@
 		// someone sets the dev to 0 if the close method has been called
 		port->interrupt_in_urb->dev = port->serial->dev;
 		
-		// start reading (except TWIN and KAAN SIM)
-		if ( (priv->device_type == KOBIL_ADAPTER_B_PRODUCT_ID) || (priv->device_type == KOBIL_ADAPTER_K_PRODUCT_ID) ) {
-			// someone sets the dev to 0 if the close method has been called
-			port->interrupt_in_urb->dev = port->serial->dev;
-			
-			result = usb_submit_urb( port->interrupt_in_urb, GFP_NOIO ); 
-			dbg("%s - port %d Send read URB returns: %i", __FUNCTION__, port->number, result);
-		}
+		// start reading
+		result = usb_submit_urb( port->interrupt_in_urb, GFP_ATOMIC ); 
+		dbg("%s - port %d Send read URB returns: %i", __FUNCTION__, port->number, result);
 	}
 	return count;
 }
@@ -511,7 +503,7 @@
 
 static int kobil_write_room (struct usb_serial_port *port)
 {
-	//dbg("%s - port %d", __FUNCTION__, port->number);
+	//dbg(__FUNCTION__ " - port %d", port->number);
 	return 8;
 }
 
@@ -635,7 +627,6 @@
 	unsigned char *transfer_buffer;
 	int transfer_buffer_length = 8;
 	char *settings;
-	void __user *user_arg = (void __user *)arg;
 
 	priv = usb_get_serial_port_data(port);
 	if ((priv->device_type == KOBIL_USBTWIN_PRODUCT_ID) || (priv->device_type == KOBIL_KAAN_SIM_PRODUCT_ID)) {
@@ -645,12 +636,12 @@
 
 	switch (cmd) {
 	case TCGETS:   // 0x5401
-		result = verify_area(VERIFY_WRITE, user_arg, sizeof(struct termios));
+		result = verify_area(VERIFY_WRITE, (void *)arg, sizeof(struct termios));
 		if (result) {
 			dbg("%s - port %d Error in verify_area", __FUNCTION__, port->number);
 			return(result);
 		}
-		if (kernel_termios_to_user_termios((struct termios __user *)arg,
+		if (kernel_termios_to_user_termios((struct termios *)arg,
 						   &priv->internal_termios))
 			return -EFAULT;
 		return 0;
@@ -660,13 +651,13 @@
 			dbg("%s - port %d Error: port->tty->termios is NULL", __FUNCTION__, port->number);
 			return -ENOTTY;
 		}
-		result = verify_area(VERIFY_READ, user_arg, sizeof(struct termios));
+		result = verify_area(VERIFY_READ, (void *)arg, sizeof(struct termios));
 		if (result) {
 			dbg("%s - port %d Error in verify_area", __FUNCTION__, port->number);
 			return result;
 		}
 		if (user_termios_to_kernel_termios(&priv->internal_termios,
-						   (struct termios __user *)arg))
+						   (struct termios *)arg))
 			return -EFAULT;
 		
 		settings = (unsigned char *) kmalloc(50, GFP_KERNEL);  
@@ -780,5 +771,5 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE( "GPL" );
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
diff -Naur linuxppc-2.6.9/drivers/usb/serial/Makefile linuxppc-2.6.9-dream/drivers/usb/serial/Makefile
--- linuxppc-2.6.9/drivers/usb/serial/Makefile	2004-10-18 23:53:22.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/Makefile	2005-09-19 21:40:06.000000000 +0200
@@ -9,26 +9,25 @@
 usbserial-obj-$(CONFIG_USB_SERIAL_CONSOLE)	+= console.o
 usbserial-obj-$(CONFIG_USB_EZUSB)		+= ezusb.o
 
-usbserial-objs	:= usb-serial.o generic.o bus.o $(usbserial-obj-y)
-
-obj-$(CONFIG_USB_SERIAL_BELKIN)			+= belkin_sa.o
-obj-$(CONFIG_USB_SERIAL_CYBERJACK)		+= cyberjack.o
+obj-$(CONFIG_USB_SERIAL_VISOR)			+= visor.o
+obj-$(CONFIG_USB_SERIAL_IPAQ)			+= ipaq.o
+obj-$(CONFIG_USB_SERIAL_WHITEHEAT)		+= whiteheat.o
+obj-$(CONFIG_USB_SERIAL_FTDI_SIO)		+= ftdi_sio.o
+obj-$(CONFIG_USB_SERIAL_KEYSPAN_PDA)		+= keyspan_pda.o
+obj-$(CONFIG_USB_SERIAL_XIRCOM)			+= keyspan_pda.o
+obj-$(CONFIG_USB_SERIAL_KEYSPAN)		+= keyspan.o
+obj-$(CONFIG_USB_SERIAL_OMNINET)		+= omninet.o
 obj-$(CONFIG_USB_SERIAL_DIGI_ACCELEPORT)	+= digi_acceleport.o
+obj-$(CONFIG_USB_SERIAL_BELKIN)			+= belkin_sa.o
+obj-$(CONFIG_USB_SERIAL_EMPEG)			+= empeg.o
+obj-$(CONFIG_USB_SERIAL_MCT_U232)		+= mct_u232.o
 obj-$(CONFIG_USB_SERIAL_EDGEPORT)		+= io_edgeport.o
 obj-$(CONFIG_USB_SERIAL_EDGEPORT_TI)		+= io_ti.o
-obj-$(CONFIG_USB_SERIAL_EMPEG)			+= empeg.o
-obj-$(CONFIG_USB_SERIAL_FTDI_SIO)		+= ftdi_sio.o
-obj-$(CONFIG_USB_SERIAL_IPAQ)			+= ipaq.o
+obj-$(CONFIG_USB_SERIAL_PL2303)			+= pl2303.o
+obj-$(CONFIG_USB_SERIAL_KOBIL_SCT)		+= kobil_sct.o
+obj-$(CONFIG_USB_SERIAL_CYBERJACK)		+= cyberjack.o
 obj-$(CONFIG_USB_SERIAL_IR)			+= ir-usb.o
-obj-$(CONFIG_USB_SERIAL_KEYSPAN)		+= keyspan.o
-obj-$(CONFIG_USB_SERIAL_KEYSPAN_PDA)		+= keyspan_pda.o
 obj-$(CONFIG_USB_SERIAL_KLSI)			+= kl5kusb105.o
-obj-$(CONFIG_USB_SERIAL_KOBIL_SCT)		+= kobil_sct.o
-obj-$(CONFIG_USB_SERIAL_MCT_U232)		+= mct_u232.o
-obj-$(CONFIG_USB_SERIAL_OMNINET)		+= omninet.o
-obj-$(CONFIG_USB_SERIAL_PL2303)			+= pl2303.o
 obj-$(CONFIG_USB_SERIAL_SAFE)			+= safe_serial.o
-obj-$(CONFIG_USB_SERIAL_VISOR)			+= visor.o
-obj-$(CONFIG_USB_SERIAL_WHITEHEAT)		+= whiteheat.o
-obj-$(CONFIG_USB_SERIAL_XIRCOM)			+= keyspan_pda.o
 
+usbserial-objs	:= usb-serial.o generic.o bus.o $(usbserial-obj-y)
diff -Naur linuxppc-2.6.9/drivers/usb/serial/mct_u232.c linuxppc-2.6.9-dream/drivers/usb/serial/mct_u232.c
--- linuxppc-2.6.9/drivers/usb/serial/mct_u232.c	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/mct_u232.c	2005-09-19 21:40:06.000000000 +0200
@@ -76,9 +76,17 @@
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+ 	static int debug = 1;
+#else
+ 	static int debug;
+#endif
+
 #include "usb-serial.h"
 #include "mct_u232.h"
 
+
 /*
  * Version Information
  */
@@ -97,8 +105,6 @@
 static int write_blocking; /* disabled by default */
 #endif
 
-static int debug;
-
 /*
  * Function prototypes
  */
@@ -517,7 +523,7 @@
 	while (count > 0) {
 		size = (count > port->bulk_out_size) ? port->bulk_out_size : count;
 		
-		usb_serial_debug_data(debug, &port->dev, __FUNCTION__, size, buf);
+		usb_serial_debug_data (__FILE__, __FUNCTION__, size, buf);
 		
 		if (from_user) {
 			if (copy_from_user(port->write_urb->transfer_buffer, buf, size)) {
@@ -579,7 +585,11 @@
 
 	if (write_blocking) {
 		wake_up_interruptible(&port->write_wait);
-		tty_wakeup(tty);
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+		    tty->ldisc.write_wakeup)
+			(tty->ldisc.write_wakeup)(tty);
+		wake_up_interruptible(&tty->write_wait);
+		
 	} else {
 		/* from generic_write_bulk_callback */
 		schedule_work(&port->work);
@@ -621,7 +631,7 @@
 		return;
 	}
 	
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	/*
 	 * Work-a-round: handle the 'usual' bulk-in pipe here
@@ -902,11 +912,11 @@
 MODULE_LICENSE("GPL");
 
 #ifdef FIX_WRITE_RETURN_CODE_PROBLEM
-module_param(write_blocking, int, 0);
+MODULE_PARM(write_blocking, "i");
 MODULE_PARM_DESC(write_blocking, 
 		 "The write function will block to write out all data");
 #endif
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
 
diff -Naur linuxppc-2.6.9/drivers/usb/serial/omninet.c linuxppc-2.6.9-dream/drivers/usb/serial/omninet.c
--- linuxppc-2.6.9/drivers/usb/serial/omninet.c	2004-10-18 23:55:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/omninet.c	2005-09-19 21:40:06.000000000 +0200
@@ -47,20 +47,25 @@
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 #include "usb-serial.h"
 
-static int debug;
 
 /*
  * Version Information
  */
 #define DRIVER_VERSION "v1.1"
-#define DRIVER_AUTHOR "Alessandro Zummo"
+#define DRIVER_AUTHOR "Anonymous"
 #define DRIVER_DESC "USB ZyXEL omni.net LCD PLUS Driver"
 
 #define ZYXEL_VENDOR_ID		0x0586
 #define ZYXEL_OMNINET_ID	0x1000
-#define BT_IGNITIONPRO_ID	0x2000  /* This one seems to be a re-branded ZyXEL device */
 
 /* function prototypes */
 static int  omninet_open		(struct usb_serial_port *port, struct file *filp);
@@ -73,7 +78,6 @@
 
 static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(ZYXEL_VENDOR_ID, ZYXEL_OMNINET_ID) },
-	{ USB_DEVICE(ZYXEL_VENDOR_ID, BT_IGNITIONPRO_ID) },
 	{ }						/* Terminating entry */
 };
 
@@ -145,13 +149,20 @@
 
 static int omninet_open (struct usb_serial_port *port, struct file *filp)
 {
-	struct usb_serial	*serial = port->serial;
+	struct usb_serial	*serial;
 	struct usb_serial_port	*wport;
 	struct omninet_data	*od;
 	int			result = 0;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return -ENODEV;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
+	serial = get_usb_serial (port, __FUNCTION__);
+	if (!serial)
+		return -ENODEV;
+
 	od = kmalloc( sizeof(struct omninet_data), GFP_KERNEL );
 	if( !od ) {
 		err("%s- kmalloc(%Zd) failed.", __FUNCTION__, sizeof(struct omninet_data));
@@ -176,15 +187,24 @@
 
 static void omninet_close (struct usb_serial_port *port, struct file * filp)
 {
-	struct usb_serial 	*serial = port->serial;
+	struct usb_serial 	*serial;
 	struct usb_serial_port 	*wport;
 	struct omninet_data 	*od;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	wport = serial->port[1];
-	usb_unlink_urb(wport->write_urb);
-	usb_unlink_urb(port->read_urb);
+	serial = get_usb_serial (port, __FUNCTION__);
+	if (!serial)
+		return;
+
+	if (serial->dev) {
+		wport = serial->port[1];
+		usb_unlink_urb (wport->write_urb);
+		usb_unlink_urb (port->read_urb);
+	}
 
 	od = usb_get_serial_port_data(port);
 	if (od)
@@ -199,6 +219,8 @@
 static void omninet_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port 	*port 	= (struct usb_serial_port *)urb->context;
+	struct usb_serial	*serial = get_usb_serial (port, __FUNCTION__);
+
 	unsigned char 		*data 	= urb->transfer_buffer;
 	struct omninet_header 	*header = (struct omninet_header *) &data[0];
 
@@ -207,6 +229,11 @@
 
 //	dbg("omninet_read_bulk_callback");
 
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
@@ -230,8 +257,8 @@
 	}
 
 	/* Continue trying to always read  */
-	usb_fill_bulk_urb(urb, port->serial->dev, 
-		      usb_rcvbulkpipe(port->serial->dev, port->bulk_in_endpointAddress),
+	usb_fill_bulk_urb(urb, serial->dev, 
+		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
 		      urb->transfer_buffer, urb->transfer_buffer_length,
 		      omninet_read_bulk_callback, port);
 	result = usb_submit_urb(urb, GFP_ATOMIC);
@@ -274,7 +301,7 @@
 		memcpy (wport->write_urb->transfer_buffer + OMNINET_DATAOFFSET, buf, count);
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, wport->write_urb->transfer_buffer);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, count, wport->write_urb->transfer_buffer);
 
 	header->oh_seq 	= od->od_outseq++;
 	header->oh_len 	= count;
@@ -315,9 +342,20 @@
 {
 /*	struct omninet_header	*header = (struct omninet_header  *) urb->transfer_buffer; */
 	struct usb_serial_port 	*port   = (struct usb_serial_port *) urb->context;
+	struct usb_serial 	*serial;
 
 //	dbg("omninet_write_bulk_callback, port %0x\n", port);
 
+
+	if (port_paranoia_check (port, __FUNCTION__)) {
+		return;
+	}
+
+	serial = port->serial;
+	if (serial_paranoia_check (serial, __FUNCTION__)) {
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 		return;
@@ -367,5 +405,6 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
+
diff -Naur linuxppc-2.6.9/drivers/usb/serial/pl2303.c linuxppc-2.6.9-dream/drivers/usb/serial/pl2303.c
--- linuxppc-2.6.9/drivers/usb/serial/pl2303.c	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/pl2303.c	2005-09-19 21:40:06.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Prolific PL2303 USB to serial adaptor driver
  *
- * Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001-2003 Greg Kroah-Hartman (greg@kroah.com)
  * Copyright (C) 2003 IBM Corp.
  *
  * Original driver for 2.2.x by anonymous
@@ -45,20 +45,26 @@
 #include <linux/tty_flip.h>
 #include <linux/serial.h>
 #include <linux/module.h>
-#include <linux/moduleparam.h>
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 #include "usb-serial.h"
 #include "pl2303.h"
 
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v0.11"
+#define DRIVER_VERSION "v0.10"
 #define DRIVER_DESC "Prolific PL2303 USB to serial adaptor driver"
 
-static int debug;
+
 
 static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
@@ -74,8 +80,6 @@
 	{ USB_DEVICE(RADIOSHACK_VENDOR_ID, RADIOSHACK_PRODUCT_ID) },
 	{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },
 	{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },
-	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },
-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 
@@ -112,7 +116,6 @@
 #define VENDOR_READ_REQUEST		0x01
 
 #define UART_STATE			0x08
-#define UART_STATE_TRANSIENT_MASK	0x74
 #define UART_DCD			0x01
 #define UART_DSR			0x02
 #define UART_BREAK_ERROR		0x04
@@ -166,38 +169,20 @@
 	.shutdown =		pl2303_shutdown,
 };
 
-enum pl2303_type {
-	type_0,		/* don't know the difference between type 0 and */
-	type_1,		/* type 1, until someone from prolific tells us... */
-	HX,		/* HX version of the pl2303 chip */
-};
-
 struct pl2303_private {
 	spinlock_t lock;
 	wait_queue_head_t delta_msr_wait;
 	u8 line_control;
 	u8 line_status;
 	u8 termios_initialized;
-	enum pl2303_type type;
 };
 
 
 static int pl2303_startup (struct usb_serial *serial)
 {
 	struct pl2303_private *priv;
-	enum pl2303_type type = type_0;
 	int i;
 
-	if (serial->dev->descriptor.bDeviceClass == 0x02)
-		type = type_0;
-	else if (serial->dev->descriptor.bMaxPacketSize0 == 0x40)
-		type = HX;
-	else if (serial->dev->descriptor.bDeviceClass == 0x00)
-		type = type_1;
-	else if (serial->dev->descriptor.bDeviceClass == 0xFF)
-		type = type_1;
-	dbg("device type: %d", type);
-
 	for (i = 0; i < serial->num_ports; ++i) {
 		priv = kmalloc (sizeof (struct pl2303_private), GFP_KERNEL);
 		if (!priv)
@@ -205,7 +190,6 @@
 		memset (priv, 0x00, sizeof (struct pl2303_private));
 		spin_lock_init(&priv->lock);
 		init_waitqueue_head(&priv->delta_msr_wait);
-		priv->type = type;
 		usb_set_serial_port_data(serial->port[i], priv);
 	}
 	return 0;
@@ -228,9 +212,6 @@
 
 	dbg("%s - port %d, %d bytes", __FUNCTION__, port->number, count);
 
-	if (!count)
-		return count;
-
 	if (port->write_urb->status == -EINPROGRESS) {
 		dbg("%s - already writing", __FUNCTION__);
 		return 0;
@@ -244,7 +225,7 @@
 		memcpy (port->write_urb->transfer_buffer, buf, count);
 	}
 	
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, port->write_urb->transfer_buffer);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, count, port->write_urb->transfer_buffer);
 
 	port->write_urb->transfer_buffer_length = count;
 	port->write_urb->dev = port->serial->dev;
@@ -408,30 +389,26 @@
 	     buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
 
 	if (cflag & CRTSCTS) {
-		__u16 index;
-		if (priv->type == HX)
-			index = 0x61;
-		else
-			index = 0x41;
-		i = usb_control_msg(serial->dev, 
-				    usb_sndctrlpipe(serial->dev, 0),
-				    VENDOR_WRITE_REQUEST,
-				    VENDOR_WRITE_REQUEST_TYPE,
-				    0x0, index, NULL, 0, 100);
-		dbg ("0x40:0x1:0x0:0x%x  %d", index, i);
+		i = usb_control_msg (serial->dev, usb_sndctrlpipe (serial->dev, 0),
+				     VENDOR_WRITE_REQUEST, VENDOR_WRITE_REQUEST_TYPE,
+				     0x0, 0x41, NULL, 0, 100);
+		dbg ("0x40:0x1:0x0:0x41  %d", i);
 	}
 
 	kfree (buf);
-} 
+}       
+
 
 static int pl2303_open (struct usb_serial_port *port, struct file *filp)
 {
 	struct termios tmp_termios;
 	struct usb_serial *serial = port->serial;
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned char *buf;
 	int result;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return -ENODEV;
+		
 	dbg("%s -  port %d", __FUNCTION__, port->number);
 
 	usb_clear_halt(serial->dev, port->write_urb->pipe);
@@ -459,18 +436,6 @@
 	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0x0404, 1);
 	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
 	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8383, 0);
-	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0, 1);
-	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 1, 0);
- 
-	if (priv->type == HX) {
-		/* HX chip */
-		SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 2, 0x44);
-		/* reset upstream data pipes */
-          	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 8, 0);
-        	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 9, 0);
-	} else {
-		SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 2, 0x24);
-	}
 
 	kfree(buf);
 
@@ -504,11 +469,18 @@
 
 static void pl2303_close (struct usb_serial_port *port, struct file *filp)
 {
+	struct usb_serial *serial;
 	struct pl2303_private *priv;
 	unsigned long flags;
 	unsigned int c_cflag;
 	int result;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+	serial = get_usb_serial (port, __FUNCTION__);
+	if (!serial)
+		return;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	/* shutdown our urbs */
@@ -659,7 +631,7 @@
 		state = BREAK_OFF;
 	else
 		state = BREAK_ON;
-	dbg("%s - turning break %s", __FUNCTION__, state==BREAK_OFF ? "off" : "on");
+	dbg("%s - turning break %s", state==BREAK_OFF ? "off" : "on", __FUNCTION__);
 
 	result = usb_control_msg (serial->dev, usb_sndctrlpipe (serial->dev, 0),
 				  BREAK_REQUEST, BREAK_REQUEST_TYPE, state, 
@@ -685,11 +657,11 @@
 static void pl2303_read_int_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned char *data = urb->transfer_buffer;
 	unsigned long flags;
 	int status;
-	u8 uart_state;
 
 	dbg("%s (%d)", __FUNCTION__, port->number);
 
@@ -708,17 +680,18 @@
 		goto exit;
 	}
 
+	if (!serial) {
+		return;
+	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, urb->transfer_buffer);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, urb->transfer_buffer);
 
 	if (urb->actual_length < UART_STATE)
 		goto exit;
 
 	/* Save off the uart status for others to look at */
-	uart_state = data[UART_STATE];
 	spin_lock_irqsave(&priv->lock, flags);
-	uart_state |= (priv->line_status & UART_STATE_TRANSIENT_MASK);
-	priv->line_status = uart_state;
+	priv->line_status = data[UART_STATE];
 	spin_unlock_irqrestore(&priv->lock, flags);
 		
 exit:
@@ -732,6 +705,7 @@
 static void pl2303_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
@@ -741,8 +715,16 @@
 	u8 status;
 	char tty_flag;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - urb->status = %d", __FUNCTION__, urb->status);
 		if (!port->open_count) {
@@ -753,7 +735,7 @@
 			/* PL2303 mysteriously fails with -EPROTO reschedule the read */
 			dbg("%s - caught -EPROTO, resubmitting the urb", __FUNCTION__);
 			urb->status = 0;
-			urb->dev = port->serial->dev;
+			urb->dev = serial->dev;
 			result = usb_submit_urb(urb, GFP_ATOMIC);
 			if (result)
 				dev_err(&urb->dev->dev, "%s - failed resubmitting read urb, error %d\n", __FUNCTION__, result);
@@ -763,14 +745,13 @@
 		return;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	/* get tty_flag from status */
 	tty_flag = TTY_NORMAL;
 
 	spin_lock_irqsave(&priv->lock, flags);
 	status = priv->line_status;
-	priv->line_status &= ~UART_STATE_TRANSIENT_MASK;
 	spin_unlock_irqrestore(&priv->lock, flags);
 	wake_up_interruptible (&priv->delta_msr_wait);
 
@@ -801,7 +782,7 @@
 
 	/* Schedule the next read _if_ we are still open */
 	if (port->open_count) {
-		urb->dev = port->serial->dev;
+		urb->dev = serial->dev;
 		result = usb_submit_urb(urb, GFP_ATOMIC);
 		if (result)
 			dev_err(&urb->dev->dev, "%s - failed resubmitting read urb, error %d\n", __FUNCTION__, result);
@@ -817,10 +798,16 @@
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
 	int result;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (urb->status) {
 		/* error in the urb, so we have to resubmit it */
+		if (serial_paranoia_check (port->serial, __FUNCTION__)) {
+			return;
+		}
 		dbg("%s - Overflow in write", __FUNCTION__);
 		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 		port->write_urb->transfer_buffer_length = 1;
@@ -867,6 +854,6 @@
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
 
diff -Naur linuxppc-2.6.9/drivers/usb/serial/pl2303.h linuxppc-2.6.9-dream/drivers/usb/serial/pl2303.h
--- linuxppc-2.6.9/drivers/usb/serial/pl2303.h	2004-10-18 23:54:31.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/pl2303.h	2005-09-19 21:40:06.000000000 +0200
@@ -41,12 +41,3 @@
 
 #define SITECOM_VENDOR_ID	0x6189
 #define SITECOM_PRODUCT_ID	0x2068
-
-/* Alcatel OT535/735 USB cable */
-#define ALCATEL_VENDOR_ID	0x11f7
-#define ALCATEL_PRODUCT_ID	0x02df
-
-/* Samsung I330 phone cradle */
-#define SAMSUNG_VENDOR_ID       0x04e8
-#define SAMSUNG_PRODUCT_ID      0x8001
-
diff -Naur linuxppc-2.6.9/drivers/usb/serial/safe_serial.c linuxppc-2.6.9-dream/drivers/usb/serial/safe_serial.c
--- linuxppc-2.6.9/drivers/usb/serial/safe_serial.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/safe_serial.c	2005-09-19 21:40:06.000000000 +0200
@@ -72,14 +72,18 @@
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
-#include "usb-serial.h"
 
 
+#ifndef CONFIG_USB_SERIAL_DEBUG
+#define CONFIG_USB_SERIAL_DEBUG 0
+#endif
 #ifndef CONFIG_USB_SAFE_PADDED
 #define CONFIG_USB_SAFE_PADDED 0
 #endif
 
-static int debug;
+static int debug = CONFIG_USB_SERIAL_DEBUG;
+#include "usb-serial.h"		// must follow the declaration of debug
+
 static int safe = 1;
 static int padded = CONFIG_USB_SAFE_PADDED;
 
@@ -98,20 +102,19 @@
 #if ! defined(CONFIG_USBD_SAFE_SERIAL_VENDOR)
 static __u16 vendor;		// no default
 static __u16 product;		// no default
-module_param(vendor, ushort, 0);
-MODULE_PARM_DESC(vendor, "User specified USB idVendor (required)");
-module_param(product, ushort, 0);
-MODULE_PARM_DESC(product, "User specified USB idProduct (required)");
+MODULE_PARM (vendor, "i");
+MODULE_PARM (product, "i");
+MODULE_PARM_DESC (vendor, "User specified USB idVendor (required)");
+MODULE_PARM_DESC (product, "User specified USB idProduct (required)");
 #endif
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(debug, "Debug enabled or not");
-
-module_param(safe, bool, 0);
-MODULE_PARM_DESC(safe, "Turn Safe Encapsulation On/Off");
-
-module_param(padded, bool, 0);
-MODULE_PARM_DESC(padded, "Pad to full wMaxPacketSize On/Off");
+MODULE_PARM (debug, "i");
+MODULE_PARM (safe, "i");
+MODULE_PARM (padded, "i");
+
+MODULE_PARM_DESC (debug, "Debug enabled or not");
+MODULE_PARM_DESC (safe, "Turn Safe Encapsulation On/Off");
+MODULE_PARM_DESC (padded, "Pad to full wMaxPacketSize On/Off");
 
 #define CDC_DEVICE_CLASS                        0x02
 
@@ -208,6 +211,7 @@
 static void safe_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	unsigned char *data = urb->transfer_buffer;
 	unsigned char length = urb->actual_length;
 	int i;
@@ -215,6 +219,11 @@
 
 	dbg ("%s", __FUNCTION__);
 
+	if (!serial) {
+		dbg ("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
 		dbg ("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
@@ -263,8 +272,8 @@
 	}
 
 	/* Continue trying to always read  */
-	usb_fill_bulk_urb (urb, port->serial->dev,
-		       usb_rcvbulkpipe (port->serial->dev, port->bulk_in_endpointAddress),
+	usb_fill_bulk_urb (urb, serial->dev,
+		       usb_rcvbulkpipe (serial->dev, port->bulk_in_endpointAddress),
 		       urb->transfer_buffer, urb->transfer_buffer_length,
 		       safe_read_bulk_callback, port);
 
@@ -275,6 +284,7 @@
 
 static int safe_write (struct usb_serial_port *port, int from_user, const unsigned char *buf, int count)
 {
+	struct usb_serial *serial = port->serial;
 	unsigned char *data;
 	int result;
 	int i;
@@ -343,7 +353,7 @@
 		port->write_urb->transfer_buffer_length = count;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, port->write_urb->transfer_buffer);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, count, port->write_urb->transfer_buffer);
 #ifdef ECHO_TX
 	{
 		int i;
@@ -357,7 +367,7 @@
 		printk ("\n");
 	}
 #endif
-	port->write_urb->dev = port->serial->dev;
+	port->write_urb->dev = serial->dev;
 	if ((result = usb_submit_urb (port->write_urb, GFP_KERNEL))) {
 		err ("%s - failed submitting write urb, error %d", __FUNCTION__, result);
 		return 0;
@@ -385,7 +395,7 @@
 
 static int safe_startup (struct usb_serial *serial)
 {
-	switch (serial->interface->cur_altsetting->desc.bInterfaceProtocol) {
+	switch (serial->interface->altsetting->desc.bInterfaceProtocol) {
 	case LINEO_SAFESERIAL_CRC:
 		break;
 	case LINEO_SAFESERIAL_CRC_PADDED:
diff -Naur linuxppc-2.6.9/drivers/usb/serial/usb-serial.c linuxppc-2.6.9-dream/drivers/usb/serial/usb-serial.c
--- linuxppc-2.6.9/drivers/usb/serial/usb-serial.c	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/usb-serial.c	2005-09-19 21:40:06.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * USB Serial Converter driver
  *
- * Copyright (C) 1999 - 2004 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 1999 - 2003 Greg Kroah-Hartman (greg@kroah.com)
  * Copyright (C) 2000 Peter Berger (pberger@brimson.com)
  * Copyright (C) 2000 Al Borchers (borchers@steinerpoint.com)
  *
@@ -330,12 +330,19 @@
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
-#include <linux/moduleparam.h>
 #include <linux/spinlock.h>
 #include <linux/list.h>
 #include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
+
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 #include "usb-serial.h"
 #include "pl2303.h"
 
@@ -346,12 +353,26 @@
 #define DRIVER_AUTHOR "Greg Kroah-Hartman, greg@kroah.com, http://www.kroah.com/linux/"
 #define DRIVER_DESC "USB Serial Driver core"
 
+
+#ifdef CONFIG_USB_SERIAL_GENERIC
+/* we want to look at all devices, as the vendor/product id can change
+ * depending on the command line argument */
+static struct usb_device_id generic_serial_ids[] = {
+	{.driver_info = 42},
+	{}
+};
+
+#endif /* CONFIG_USB_SERIAL_GENERIC */
+
 /* Driver structure we register with the USB core */
 static struct usb_driver usb_serial_driver = {
 	.owner =	THIS_MODULE,
 	.name =		"usbserial",
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
+#ifdef CONFIG_USB_SERIAL_GENERIC
+	.id_table =	generic_serial_ids,
+#endif
 };
 
 /* There is no MODULE_DEVICE_TABLE for usbserial.c.  Instead
@@ -361,10 +382,10 @@
    drivers depend on it.
 */
 
-static int debug;
-static struct usb_serial *serial_table[SERIAL_TTY_MINORS];	/* initially all NULL */
+static struct usb_serial	*serial_table[SERIAL_TTY_MINORS];	/* initially all NULL */
 static LIST_HEAD(usb_serial_driver_list);
 
+
 struct usb_serial *usb_serial_get_by_index(unsigned index)
 {
 	struct usb_serial *serial = serial_table[index];
@@ -395,7 +416,8 @@
 			}
 		if (good_spot == 0)
 			continue;
-
+			
+		serial->magic = USB_SERIAL_MAGIC;
 		*minor = i;
 		dbg("%s - minor base = %d", __FUNCTION__, *minor);
 		for (i = *minor; (i < (*minor + num_ports)) && (i < SERIAL_TTY_MINORS); ++i)
@@ -421,63 +443,6 @@
 	return;
 }
 
-static void destroy_serial(struct kref *kref)
-{
-	struct usb_serial *serial;
-	struct usb_serial_port *port;
-	int i;
-
-	serial = to_usb_serial(kref);
-
-	dbg ("%s - %s", __FUNCTION__, serial->type->name);
-
-	serial->type->shutdown(serial);
-
-	/* return the minor range that this device had */
-	return_serial(serial);
-
-	for (i = 0; i < serial->num_ports; ++i)
-		serial->port[i]->open_count = 0;
-
-	/* the ports are cleaned up and released in port_release() */
-	for (i = 0; i < serial->num_ports; ++i)
-		if (serial->port[i]->dev.parent != NULL) {
-			device_unregister(&serial->port[i]->dev);
-			serial->port[i] = NULL;
-		}
-
-	/* If this is a "fake" port, we have to clean it up here, as it will
-	 * not get cleaned up in port_release() as it was never registered with
-	 * the driver core */
-	if (serial->num_ports < serial->num_port_pointers) {
-		for (i = serial->num_ports; i < serial->num_port_pointers; ++i) {
-			port = serial->port[i];
-			if (!port)
-				continue;
-			if (port->read_urb) {
-				usb_unlink_urb(port->read_urb);
-				usb_free_urb(port->read_urb);
-			}
-			if (port->write_urb) {
-				usb_unlink_urb(port->write_urb);
-				usb_free_urb(port->write_urb);
-			}
-			if (port->interrupt_in_urb) {
-				usb_unlink_urb(port->interrupt_in_urb);
-				usb_free_urb(port->interrupt_in_urb);
-			}
-			kfree(port->bulk_in_buffer);
-			kfree(port->bulk_out_buffer);
-			kfree(port->interrupt_in_buffer);
-		}
-	}
-
-	usb_put_dev(serial->dev);
-
-	/* free up any memory that we allocated */
-	kfree (serial);
-}
-
 /*****************************************************************************
  * Driver tty interface functions
  *****************************************************************************/
@@ -495,10 +460,9 @@
 
 	/* get the serial object associated with this tty pointer */
 	serial = usb_serial_get_by_index(tty->index);
-	if (!serial) {
-		retval = -ENODEV;
-		goto bailout;
-	}
+
+	if (serial_paranoia_check (serial, __FUNCTION__))
+		return -ENODEV;
 
 	/* set up our port structure making the tty driver remember our port object, and us it */
 	portNumber = tty->index - serial->minor;
@@ -522,7 +486,7 @@
 		if (retval) {
 			port->open_count = 0;
 			module_put(serial->type->owner);
-			kref_put(&serial->kref, destroy_serial);
+			kref_put(&serial->kref);
 		}
 	}
 bailout:
@@ -532,8 +496,9 @@
 static void serial_close(struct tty_struct *tty, struct file * filp)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 
-	if (!port)
+	if (!serial)
 		return;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
@@ -553,14 +518,18 @@
 	}
 
 	module_put(port->serial->type->owner);
-	kref_put(&port->serial->kref, destroy_serial);
+	kref_put(&port->serial->kref);
 }
 
 static int serial_write (struct tty_struct * tty, int from_user, const unsigned char *buf, int count)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	int retval = -EINVAL;
 
+	if (!serial)
+		return -ENODEV;
+
 	dbg("%s - port %d, %d byte(s)", __FUNCTION__, port->number, count);
 
 	if (!port->open_count) {
@@ -569,7 +538,7 @@
 	}
 
 	/* pass on to the driver specific version of this function */
-	retval = port->serial->type->write(port, from_user, buf, count);
+	retval = serial->type->write(port, from_user, buf, count);
 
 exit:
 	return retval;
@@ -578,8 +547,12 @@
 static int serial_write_room (struct tty_struct *tty) 
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	int retval = -EINVAL;
 
+	if (!serial)
+		return -ENODEV;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (!port->open_count) {
@@ -588,7 +561,7 @@
 	}
 
 	/* pass on to the driver specific version of this function */
-	retval = port->serial->type->write_room(port);
+	retval = serial->type->write_room(port);
 
 exit:
 	return retval;
@@ -597,8 +570,12 @@
 static int serial_chars_in_buffer (struct tty_struct *tty) 
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	int retval = -EINVAL;
 
+	if (!serial)
+		return -ENODEV;
+
 	dbg("%s = port %d", __FUNCTION__, port->number);
 
 	if (!port->open_count) {
@@ -607,7 +584,7 @@
 	}
 
 	/* pass on to the driver specific version of this function */
-	retval = port->serial->type->chars_in_buffer(port);
+	retval = serial->type->chars_in_buffer(port);
 
 exit:
 	return retval;
@@ -616,6 +593,10 @@
 static void serial_throttle (struct tty_struct * tty)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
+
+	if (!serial)
+		return;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
@@ -625,8 +606,8 @@
 	}
 
 	/* pass on to the driver specific version of this function */
-	if (port->serial->type->throttle)
-		port->serial->type->throttle(port);
+	if (serial->type->throttle)
+		serial->type->throttle(port);
 
 exit:
 	;
@@ -635,6 +616,10 @@
 static void serial_unthrottle (struct tty_struct * tty)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
+
+	if (!serial)
+		return;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
@@ -644,8 +629,8 @@
 	}
 
 	/* pass on to the driver specific version of this function */
-	if (port->serial->type->unthrottle)
-		port->serial->type->unthrottle(port);
+	if (serial->type->unthrottle)
+		serial->type->unthrottle(port);
 
 exit:
 	;
@@ -654,8 +639,12 @@
 static int serial_ioctl (struct tty_struct *tty, struct file * file, unsigned int cmd, unsigned long arg)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	int retval = -ENODEV;
 
+	if (!serial)
+		return -ENODEV;
+
 	dbg("%s - port %d, cmd 0x%.4x", __FUNCTION__, port->number, cmd);
 
 	if (!port->open_count) {
@@ -664,8 +653,8 @@
 	}
 
 	/* pass on to the driver specific version of this function if it is available */
-	if (port->serial->type->ioctl)
-		retval = port->serial->type->ioctl(port, file, cmd, arg);
+	if (serial->type->ioctl)
+		retval = serial->type->ioctl(port, file, cmd, arg);
 	else
 		retval = -ENOIOCTLCMD;
 
@@ -676,6 +665,10 @@
 static void serial_set_termios (struct tty_struct *tty, struct termios * old)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
+
+	if (!serial)
+		return;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
@@ -685,8 +678,8 @@
 	}
 
 	/* pass on to the driver specific version of this function if it is available */
-	if (port->serial->type->set_termios)
-		port->serial->type->set_termios(port, old);
+	if (serial->type->set_termios)
+		serial->type->set_termios(port, old);
 
 exit:
 	;
@@ -695,6 +688,10 @@
 static void serial_break (struct tty_struct *tty, int break_state)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
+
+	if (!serial)
+		return;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
@@ -704,13 +701,20 @@
 	}
 
 	/* pass on to the driver specific version of this function if it is available */
-	if (port->serial->type->break_ctl)
-		port->serial->type->break_ctl(port, break_state);
+	if (serial->type->break_ctl)
+		serial->type->break_ctl(port, break_state);
 
 exit:
 	;
 }
 
+static void serial_shutdown (struct usb_serial *serial)
+{
+	dbg ("%s", __FUNCTION__);
+
+	serial->type->shutdown(serial);
+}
+
 static int serial_read_proc (char *page, char **start, off_t off, int count, int *eof, void *data)
 {
 	struct usb_serial *serial;
@@ -744,7 +748,7 @@
 			begin += length;
 			length = 0;
 		}
-		kref_put(&serial->kref, destroy_serial);
+		kref_put(&serial->kref);
 	}
 	*eof = 1;
 done:
@@ -757,6 +761,10 @@
 static int serial_tiocmget (struct tty_struct *tty, struct file *file)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
+
+	if (!serial)
+		goto exit;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
@@ -765,8 +773,8 @@
 		goto exit;
 	}
 
-	if (port->serial->type->tiocmget)
-		return port->serial->type->tiocmget(port, file);
+	if (serial->type->tiocmget)
+		return serial->type->tiocmget(port, file);
 
 exit:
 	return -EINVAL;
@@ -776,6 +784,10 @@
 			    unsigned int set, unsigned int clear)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
+
+	if (!serial)
+		goto exit;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
@@ -784,8 +796,8 @@
 		goto exit;
 	}
 
-	if (port->serial->type->tiocmset)
-		return port->serial->type->tiocmset(port, file, set, clear);
+	if (serial->type->tiocmset)
+		return serial->type->tiocmset(port, file, set, clear);
 
 exit:
 	return -EINVAL;
@@ -794,6 +806,7 @@
 void usb_serial_port_softint(void *private)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)private;
+	struct usb_serial *serial;
 	struct tty_struct *tty;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
@@ -801,11 +814,76 @@
 	if (!port)
 		return;
 
+	serial = get_usb_serial (port, __FUNCTION__);
+	if (!serial)
+		return;
+
 	tty = port->tty;
 	if (!tty)
 		return;
 
-	tty_wakeup(tty);
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) && tty->ldisc.write_wakeup) {
+		dbg("%s - write wakeup call.", __FUNCTION__);
+		(tty->ldisc.write_wakeup)(tty);
+	}
+
+	wake_up_interruptible(&tty->write_wait);
+}
+
+static void destroy_serial(struct kref *kref)
+{
+	struct usb_serial *serial;
+	struct usb_serial_port *port;
+	int i;
+
+	serial = to_usb_serial(kref);
+
+	dbg ("%s - %s", __FUNCTION__, serial->type->name);
+	serial_shutdown (serial);
+
+	/* return the minor range that this device had */
+	return_serial(serial);
+
+	for (i = 0; i < serial->num_ports; ++i)
+		serial->port[i]->open_count = 0;
+
+	/* the ports are cleaned up and released in port_release() */
+	for (i = 0; i < serial->num_ports; ++i)
+		if (serial->port[i]->dev.parent != NULL) {
+			device_unregister(&serial->port[i]->dev);
+			serial->port[i] = NULL;
+		}
+
+	/* If this is a "fake" port, we have to clean it up here, as it will
+	 * not get cleaned up in port_release() as it was never registered with
+	 * the driver core */
+	if (serial->num_ports < serial->num_port_pointers) {
+		for (i = serial->num_ports; i < serial->num_port_pointers; ++i) {
+			port = serial->port[i];
+			if (!port)
+				continue;
+			if (port->read_urb) {
+				usb_unlink_urb(port->read_urb);
+				usb_free_urb(port->read_urb);
+			}
+			if (port->write_urb) {
+				usb_unlink_urb(port->write_urb);
+				usb_free_urb(port->write_urb);
+			}
+			if (port->interrupt_in_urb) {
+				usb_unlink_urb(port->interrupt_in_urb);
+				usb_free_urb(port->interrupt_in_urb);
+			}
+			kfree(port->bulk_in_buffer);
+			kfree(port->bulk_out_buffer);
+			kfree(port->interrupt_in_buffer);
+		}
+	}
+
+	usb_put_dev(serial->dev);
+
+	/* free up any memory that we allocated */
+	kfree (serial);
 }
 
 static void port_release(struct device *dev)
@@ -848,7 +926,7 @@
 	serial->interface = interface;
 	serial->vendor = dev->descriptor.idVendor;
 	serial->product = dev->descriptor.idProduct;
-	kref_init(&serial->kref);
+	kref_init(&serial->kref, destroy_serial);
 
 	return serial;
 }
@@ -959,7 +1037,7 @@
 	     (dev->descriptor.idProduct == ATEN_PRODUCT_ID))) {
 		if (interface != dev->actconfig->interface[0]) {
 			/* check out the endpoints of the other interface*/
-			iface_desc = dev->actconfig->interface[0]->cur_altsetting;
+			iface_desc = &dev->actconfig->interface[0]->altsetting[0];
 			for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
 				endpoint = &iface_desc->endpoint[i].desc;
 				if ((endpoint->bEndpointAddress & 0x80) &&
@@ -1039,6 +1117,7 @@
 		memset(port, 0x00, sizeof(struct usb_serial_port));
 		port->number = i + serial->minor;
 		port->serial = serial;
+		port->magic = USB_SERIAL_PORT_MAGIC;
 		INIT_WORK(&port->work, usb_serial_port_softint, port);
 		serial->port[i] = port;
 	}
@@ -1198,7 +1277,7 @@
 	if (serial) {
 		/* let the last holder of this object 
 		 * cause it to be cleaned up */
-		kref_put(&serial->kref, destroy_serial);
+		kref_put(&serial->kref);
 	}
 	dev_info(dev, "device disconnected\n");
 }
@@ -1350,9 +1429,22 @@
 
 void usb_serial_deregister(struct usb_serial_device_type *device)
 {
+	struct usb_serial *serial;
+	int i;
+
 	info("USB Serial deregistering driver %s", device->name);
+
+	/* clear out the serial_table if the device is attached to a port */
+	for(i = 0; i < SERIAL_TTY_MINORS; ++i) {
+		serial = serial_table[i];
+		if ((serial != NULL) && (serial->type == device)) {
+			usb_driver_release_interface (&usb_serial_driver, serial->interface);
+			usb_serial_disconnect (serial->interface);
+		}
+	}
+
 	list_del(&device->driver_list);
-	usb_serial_bus_deregister(device);
+	usb_serial_bus_deregister (device);
 }
 
 
@@ -1371,5 +1463,5 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
diff -Naur linuxppc-2.6.9/drivers/usb/serial/usb-serial.h linuxppc-2.6.9-dream/drivers/usb/serial/usb-serial.h
--- linuxppc-2.6.9/drivers/usb/serial/usb-serial.h	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/usb-serial.h	2005-09-19 21:40:06.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * USB Serial Converter driver
  *
- *	Copyright (C) 1999 - 2004
+ *	Copyright (C) 1999 - 2003
  *	    Greg Kroah-Hartman (greg@kroah.com)
  *
  *	This program is free software; you can redistribute it and/or modify
@@ -62,11 +62,15 @@
 
 #define MAX_NUM_PORTS		8	/* The maximum number of ports one device can grab at once */
 
+#define USB_SERIAL_MAGIC	0x6702	/* magic number for usb_serial struct */
+#define USB_SERIAL_PORT_MAGIC	0x7301	/* magic number for usb_serial_port struct */
+
 /* parity check flag */
 #define RELEVANT_IFLAG(iflag)	(iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
 
 /**
  * usb_serial_port: structure for the specific ports of a device.
+ * @magic: magic number for internal validity of this pointer.
  * @serial: pointer back to the struct usb_serial owner of this port.
  * @tty: pointer to the corresponding tty for this port.
  * @number: the number of the port (the minor number).
@@ -91,7 +95,8 @@
  * ports of a device.
  */
 struct usb_serial_port {
-	struct usb_serial *	serial;
+	int			magic;
+	struct usb_serial	*serial;
 	struct tty_struct *	tty;
 	unsigned char		number;
 
@@ -128,6 +133,7 @@
 
 /**
  * usb_serial - structure used by the usb-serial core for a device
+ * @magic: magic number for internal validity of this pointer.
  * @dev: pointer to the struct usb_device for this device
  * @type: pointer to the struct usb_serial_device_type for this device
  * @interface: pointer to the struct usb_interface for this device
@@ -145,6 +151,7 @@
  *	usb_set_serial_data() to access this.
  */
 struct usb_serial {
+	int				magic;
 	struct usb_device *		dev;
 	struct usb_serial_device_type *	type;
 	struct usb_interface *		interface;
@@ -294,21 +301,75 @@
 extern struct bus_type usb_serial_bus_type;
 extern struct tty_driver *usb_serial_tty_driver;
 
-static inline void usb_serial_debug_data(int debug,
-					 struct device *dev,
-					 const char *function, int size,
-					 const unsigned char *data)
+/* Inline functions to check the sanity of a pointer that is passed to us */
+static inline int serial_paranoia_check (struct usb_serial *serial, const char *function)
+{
+	if (!serial) {
+		dbg("%s - serial == NULL", function);
+		return -1;
+	}
+	if (serial->magic != USB_SERIAL_MAGIC) {
+		dbg("%s - bad magic number for serial", function);
+		return -1;
+	}
+	if (!serial->type) {
+		dbg("%s - serial->type == NULL!", function);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static inline int port_paranoia_check (struct usb_serial_port *port, const char *function)
+{
+	if (!port) {
+		dbg("%s - port == NULL", function);
+		return -1;
+	}
+	if (port->magic != USB_SERIAL_PORT_MAGIC) {
+		dbg("%s - bad magic number for port", function);
+		return -1;
+	}
+	if (!port->serial) {
+		dbg("%s - port->serial == NULL", function);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static inline struct usb_serial* get_usb_serial (struct usb_serial_port *port, const char *function) 
+{ 
+	/* if no port was specified, or it fails a paranoia check */
+	if (!port || 
+		port_paranoia_check (port, function) ||
+		serial_paranoia_check (port->serial, function)) {
+		/* then say that we don't have a valid usb_serial thing, which will
+		 * end up genrating -ENODEV return values */ 
+		return NULL;
+	}
+
+	return port->serial;
+}
+
+
+static inline void usb_serial_debug_data (const char *file, const char *function, int size, const unsigned char *data)
 {
 	int i;
 
-	if (debug) {
-		dev_printk(KERN_DEBUG, dev, "%s - length = %d, data = ", function, size);
-		for (i = 0; i < size; ++i)
-			printk ("%.2x ", data[i]);
-		printk ("\n");
+	if (!debug)
+		return;
+	
+	printk (KERN_DEBUG "%s: %s - length = %d, data = ", file, function, size);
+	for (i = 0; i < size; ++i) {
+		printk ("%.2x ", data[i]);
 	}
+	printk ("\n");
 }
 
+
 /* Use our own dbg macro */
 #undef dbg
 #define dbg(format, arg...) do { if (debug) printk(KERN_DEBUG "%s: " format "\n" , __FILE__ , ## arg); } while (0)
diff -Naur linuxppc-2.6.9/drivers/usb/serial/visor.c linuxppc-2.6.9-dream/drivers/usb/serial/visor.c
--- linuxppc-2.6.9/drivers/usb/serial/visor.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/visor.c	2005-09-19 21:40:06.000000000 +0200
@@ -2,7 +2,7 @@
  * USB HandSpring Visor, Palm m50x, and Sony Clie driver
  * (supports all of the Palm OS USB devices)
  *
- *	Copyright (C) 1999 - 2004
+ *	Copyright (C) 1999 - 2003
  *	    Greg Kroah-Hartman (greg@kroah.com)
  *
  *	This program is free software; you can redistribute it and/or modify
@@ -151,10 +151,16 @@
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
-#include <linux/moduleparam.h>
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 #include "usb-serial.h"
 #include "visor.h"
 
@@ -183,14 +189,12 @@
 static void visor_read_int_callback	(struct urb *urb, struct pt_regs *regs);
 static int  clie_3_5_startup	(struct usb_serial *serial);
 static int  treo_attach		(struct usb_serial *serial);
-static int clie_5_attach (struct usb_serial *serial);
 static int palm_os_3_probe (struct usb_serial *serial, const struct usb_device_id *id);
 static int palm_os_4_probe (struct usb_serial *serial, const struct usb_device_id *id);
 
 /* Parameters that may be passed into the module. */
-static int debug;
-static __u16 vendor;
-static __u16 product;
+static int vendor = -1;
+static int product = -1;
 
 static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_VISOR_ID),
@@ -217,8 +221,6 @@
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_Z_ID),
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
-	{ USB_DEVICE(PALM_VENDOR_ID, PALM_ZIRE31_ID),
-		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_ZIRE_ID),
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_0_ID),
@@ -229,6 +231,8 @@
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NX60_ID),
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
+	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_UX50_ID),
+		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NZ90V_ID),
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_TJ25_ID),
@@ -241,15 +245,6 @@
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ USB_DEVICE(ACEECA_VENDOR_ID, ACEECA_MEZ1000_ID),
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
-	{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_7135_ID),
-		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
-	{ },					/* optional parameter entry */
-	{ }					/* Terminating entry */
-};
-
-static struct usb_device_id clie_id_5_table [] = {
-	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_UX50_ID),
-		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ },					/* optional parameter entry */
 	{ }					/* Terminating entry */
 };
@@ -272,7 +267,6 @@
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_M130_ID) },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_T_ID) },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_Z_ID) },
-	{ USB_DEVICE(PALM_VENDOR_ID, PALM_ZIRE31_ID) },
 	{ USB_DEVICE(PALM_VENDOR_ID, PALM_ZIRE_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_3_5_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_0_ID) },
@@ -286,7 +280,6 @@
 	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SPH_I500_ID) },
 	{ USB_DEVICE(GARMIN_VENDOR_ID, GARMIN_IQUE_3600_ID) },
 	{ USB_DEVICE(ACEECA_VENDOR_ID, ACEECA_MEZ1000_ID) },
-	{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_7135_ID) },
 	{ },					/* optional parameter entry */
 	{ }					/* Terminating entry */
 };
@@ -329,34 +322,6 @@
 	.read_int_callback =	visor_read_int_callback,
 };
 
-/* All of the device info needed for the Clie UX50, TH55 Palm 5.0 devices */
-static struct usb_serial_device_type clie_5_device = {
-	.owner =		THIS_MODULE,
-	.name =			"Sony Clie 5.0",
-	.short_name =		"clie_5",
-	.id_table =		clie_id_5_table,
-	.num_interrupt_in =	NUM_DONT_CARE,
-	.num_bulk_in =		2,
-	.num_bulk_out =		2,
-	.num_ports =		2,
-	.open =			visor_open,
-	.close =		visor_close,
-	.throttle =		visor_throttle,
-	.unthrottle =		visor_unthrottle,
-	.attach =		clie_5_attach,
-	.probe =		visor_probe,
-	.calc_num_ports =	visor_calc_num_ports,
-	.shutdown =		visor_shutdown,
-	.ioctl =		visor_ioctl,
-	.set_termios =		visor_set_termios,
-	.write =		visor_write,
-	.write_room =		visor_write_room,
-	.chars_in_buffer =	visor_chars_in_buffer,
-	.write_bulk_callback =	visor_write_bulk_callback,
-	.read_bulk_callback =	visor_read_bulk_callback,
-	.read_int_callback =	visor_read_int_callback,
-};
-
 /* device info for the Sony Clie OS version 3.5 */
 static struct usb_serial_device_type clie_3_5_device = {
 	.owner =		THIS_MODULE,
@@ -394,6 +359,9 @@
 	struct usb_serial *serial = port->serial;
 	int result = 0;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return -ENODEV;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	if (!port->read_urb) {
@@ -441,10 +409,18 @@
 
 static void visor_close (struct usb_serial_port *port, struct file * filp)
 {
+	struct usb_serial *serial;
 	unsigned char *transfer_buffer;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 			 
+	serial = get_usb_serial (port, __FUNCTION__);
+	if (!serial)
+		return;
+	
 	/* shutdown our urbs */
 	usb_unlink_urb (port->read_urb);
 	if (port->interrupt_in_urb)
@@ -453,8 +429,8 @@
 	/* Try to send shutdown message, if the device is gone, this will just fail. */
 	transfer_buffer =  kmalloc (0x12, GFP_KERNEL);
 	if (transfer_buffer) {
-		usb_control_msg (port->serial->dev,
-				 usb_rcvctrlpipe(port->serial->dev, 0),
+		usb_control_msg (serial->dev,
+				 usb_rcvctrlpipe(serial->dev, 0),
 				 VISOR_CLOSE_NOTIFICATION, 0xc2,
 				 0x0000, 0x0000, 
 				 transfer_buffer, 0x12, 300);
@@ -498,7 +474,7 @@
 		memcpy (buffer, buf, count);
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, buffer);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, count, buffer);
 
 	usb_fill_bulk_urb (urb, serial->dev,
 			   usb_sndbulkpipe (serial->dev,
@@ -512,7 +488,6 @@
 		dev_err(&port->dev, "%s - usb_submit_urb(write bulk) failed with status = %d\n",
 			__FUNCTION__, status);
 		count = status;
-		kfree (buffer);
 	} else {
 		bytes_out += count;
 	}
@@ -559,6 +534,9 @@
 	/* free up the transfer buffer, as usb_free_urb() does not do this */
 	kfree (urb->transfer_buffer);
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+	
 	dbg("%s - port %d", __FUNCTION__, port->number);
 	
 	if (urb->status)
@@ -572,19 +550,28 @@
 static void visor_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
 	int i;
 	int result;
 
+	if (port_paranoia_check (port, __FUNCTION__))
+		return;
+
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		return;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	tty = port->tty;
 	if (tty && urb->actual_length) {
@@ -601,9 +588,9 @@
 	bytes_in += urb->actual_length;
 
 	/* Continue trying to always read  */
-	usb_fill_bulk_urb (port->read_urb, port->serial->dev,
-			   usb_rcvbulkpipe(port->serial->dev,
-					   port->bulk_in_endpointAddress),
+	usb_fill_bulk_urb (port->read_urb, serial->dev,
+			   usb_rcvbulkpipe (serial->dev,
+					    port->bulk_in_endpointAddress),
 			   port->read_urb->transfer_buffer,
 			   port->read_urb->transfer_buffer_length,
 			   visor_read_bulk_callback, port);
@@ -615,7 +602,6 @@
 
 static void visor_read_int_callback (struct urb *urb, struct pt_regs *regs)
 {
-	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
 	int result;
 
 	switch (urb->status) {
@@ -642,8 +628,8 @@
 	 * Rumor has it this endpoint is used to notify when data
 	 * is ready to be read from the bulk ones.
 	 */
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__,
-			      urb->actual_length, urb->transfer_buffer);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length,
+			       urb->transfer_buffer);
 
 exit:
 	result = usb_submit_urb (urb, GFP_ATOMIC);
@@ -679,7 +665,7 @@
 	char *string;
 	int retval = 0;
 	int i;
-	int num_ports = 0;
+	int num_ports;
 
 	dbg("%s", __FUNCTION__);
 
@@ -701,50 +687,41 @@
 			__FUNCTION__, retval);
 		goto exit;
 	}
+		
+	connection_info = (struct visor_connection_info *)transfer_buffer;
 
-	if (retval == sizeof(*connection_info)) {
-	        connection_info = (struct visor_connection_info *)transfer_buffer;
-
-		le16_to_cpus(&connection_info->num_ports);
-		num_ports = connection_info->num_ports;
+	le16_to_cpus(&connection_info->num_ports);
+	num_ports = connection_info->num_ports;
+	/* handle devices that report invalid stuff here */
+	if (num_ports > 2)
+		num_ports = 2;
+	dev_info(dev, "%s: Number of ports: %d\n", serial->type->name,
+		connection_info->num_ports);
 
-		for (i = 0; i < num_ports; ++i) {
-			switch (connection_info->connections[i].port_function_id) {
-				case VISOR_FUNCTION_GENERIC:
-					string = "Generic";
-					break;
-				case VISOR_FUNCTION_DEBUGGER:
-					string = "Debugger";
-					break;
-				case VISOR_FUNCTION_HOTSYNC:
-					string = "HotSync";
-					break;
-				case VISOR_FUNCTION_CONSOLE:
-					string = "Console";
-					break;
-				case VISOR_FUNCTION_REMOTE_FILE_SYS:
-					string = "Remote File System";
-					break;
-				default:
-					string = "unknown";
-					break;
-			}
-			dev_info(dev, "%s: port %d, is for %s use\n",
-				serial->type->name,
-				connection_info->connections[i].port, string);
+	for (i = 0; i < num_ports; ++i) {
+		switch (connection_info->connections[i].port_function_id) {
+			case VISOR_FUNCTION_GENERIC:
+				string = "Generic";
+				break;
+			case VISOR_FUNCTION_DEBUGGER:
+				string = "Debugger";
+				break;
+			case VISOR_FUNCTION_HOTSYNC:
+				string = "HotSync";
+				break;
+			case VISOR_FUNCTION_CONSOLE:
+				string = "Console";
+				break;
+			case VISOR_FUNCTION_REMOTE_FILE_SYS:
+				string = "Remote File System";
+				break;
+			default:
+				string = "unknown";
+				break;	
 		}
+		dev_info(dev, "%s: port %d, is for %s use\n", serial->type->name,
+			 connection_info->connections[i].port, string);
 	}
-	/*
-	* Handle devices that report invalid stuff here.
-	*/
-	if (num_ports == 0 || num_ports > 2) {
-		dev_warn (dev, "%s: No valid connect info available\n",
-			serial->type->name);
-		num_ports = 2;
-	}
-  
-	dev_info(dev, "%s: Number of ports: %d\n", serial->type->name,
-		num_ports);
 
 	/*
 	 * save off our num_ports info so that we can use it in the
@@ -794,8 +771,7 @@
 		dev_err(dev, "%s - error %d getting connection info\n",
 			__FUNCTION__, retval);
 	else
-		usb_serial_debug_data(debug, &serial->dev->dev, __FUNCTION__,
-				      retval, transfer_buffer);
+		usb_serial_debug_data (__FILE__, __FUNCTION__, 0x14, transfer_buffer);
 
 	kfree (transfer_buffer);
 	return 0;
@@ -877,60 +853,42 @@
  
 static int treo_attach (struct usb_serial *serial)
 {
-	struct usb_serial_port *swap_port;
+	struct usb_serial_port *port;
+	int i;
 
 	/* Only do this endpoint hack for the Handspring devices with
 	 * interrupt in endpoints, which for now are the Treo devices. */
-	if (!((serial->dev->descriptor.idVendor == HANDSPRING_VENDOR_ID) ||
-	      (serial->dev->descriptor.idVendor == KYOCERA_VENDOR_ID)) ||
+	if ((serial->dev->descriptor.idVendor != HANDSPRING_VENDOR_ID) ||
 	    (serial->num_interrupt_in == 0))
 		return 0;
 
 	dbg("%s", __FUNCTION__);
 
-	/*
-	* It appears that Treos and Kyoceras want to use the 
-	* 1st bulk in endpoint to communicate with the 2nd bulk out endpoint, 
-	* so let's swap the 1st and 2nd bulk in and interrupt endpoints.  
-	* Note that swapping the bulk out endpoints would break lots of 
-	* apps that want to communicate on the second port.
-	*/
-#define COPY_PORT(dest, src)						\
-	dest->read_urb = src->read_urb;					\
-	dest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;	\
-	dest->bulk_in_buffer = src->bulk_in_buffer;			\
-	dest->interrupt_in_urb = src->interrupt_in_urb;			\
-	dest->interrupt_in_endpointAddress = src->interrupt_in_endpointAddress;	\
-	dest->interrupt_in_buffer = src->interrupt_in_buffer;
-
-	swap_port = kmalloc(sizeof(*swap_port), GFP_KERNEL);
-	if (!swap_port)
-		return -ENOMEM;
-	COPY_PORT(swap_port, serial->port[0]);
-	COPY_PORT(serial->port[0], serial->port[1]);
-	COPY_PORT(serial->port[1], swap_port);
-	kfree(swap_port);
-
-	return 0;
-}
-
-static int clie_5_attach (struct usb_serial *serial)
-{
-	dbg("%s", __FUNCTION__);
-
-	/* TH55 registers 2 ports. 
-	   Communication in from the UX50/TH55 uses bulk_in_endpointAddress from port 0 
-	   Communication out to the UX50/TH55 uses bulk_out_endpointAddress from port 1 
-	   
-	   Lets do a quick and dirty mapping
-	 */
-	
-	/* some sanity check */
-	if (serial->num_ports < 2)
-		return -1;
-		
-	/* port 0 now uses the modified endpoint Address */
-	serial->port[0]->bulk_out_endpointAddress = serial->port[1]->bulk_out_endpointAddress;
+	/* Ok, this is pretty ugly, but these devices want to use the
+	 * interrupt endpoint as paired up with a bulk endpoint for a
+	 * "virtual serial port".  So let's force the endpoints to be
+	 * where we want them to be. */
+	for (i = serial->num_bulk_in; i < serial->num_ports; ++i) {
+		port = serial->port[i];
+		port->read_urb = serial->port[0]->read_urb;
+		port->bulk_in_endpointAddress = serial->port[0]->bulk_in_endpointAddress;
+		port->bulk_in_buffer = serial->port[0]->bulk_in_buffer;
+	}
+
+	for (i = serial->num_bulk_out; i < serial->num_ports; ++i) {
+		port = serial->port[i];
+		port->write_urb = serial->port[0]->write_urb;
+		port->bulk_out_size = serial->port[0]->bulk_out_size;
+		port->bulk_out_endpointAddress = serial->port[0]->bulk_out_endpointAddress;
+		port->bulk_out_buffer = serial->port[0]->bulk_out_buffer;
+	}
+
+	for (i = serial->num_interrupt_in; i < serial->num_ports; ++i) {
+		port = serial->port[i];
+		port->interrupt_in_urb = serial->port[0]->interrupt_in_urb;
+		port->interrupt_in_endpointAddress = serial->port[0]->interrupt_in_endpointAddress;
+		port->interrupt_in_buffer = serial->port[0]->interrupt_in_buffer;
+	}
 
 	return 0;
 }
@@ -1050,9 +1008,6 @@
 	retval = usb_serial_register(&clie_3_5_device);
 	if (retval)
 		goto failed_clie_3_5_register;
-	retval = usb_serial_register(&clie_5_device);
-	if (retval)
-		goto failed_clie_5_register;
 	retval = usb_register(&visor_driver);
 	if (retval) 
 		goto failed_usb_register;
@@ -1060,8 +1015,6 @@
 
 	return 0;
 failed_usb_register:
-	usb_serial_deregister(&clie_5_device);
-failed_clie_5_register:
 	usb_serial_deregister(&clie_3_5_device);
 failed_clie_3_5_register:
 	usb_serial_deregister(&handspring_device);
@@ -1075,7 +1028,6 @@
 	usb_deregister (&visor_driver);
 	usb_serial_deregister (&handspring_device);
 	usb_serial_deregister (&clie_3_5_device);
-	usb_serial_deregister (&clie_5_device);
 }
 
 
@@ -1086,10 +1038,10 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
 
-module_param(vendor, ushort, 0);
+MODULE_PARM(vendor, "i");
 MODULE_PARM_DESC(vendor, "User specified vendor ID");
-module_param(product, ushort, 0);
+MODULE_PARM(product, "i");
 MODULE_PARM_DESC(product, "User specified product ID");
diff -Naur linuxppc-2.6.9/drivers/usb/serial/visor.h linuxppc-2.6.9-dream/drivers/usb/serial/visor.h
--- linuxppc-2.6.9/drivers/usb/serial/visor.h	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/visor.h	2005-09-19 21:40:06.000000000 +0200
@@ -31,7 +31,6 @@
 #define PALM_M130_ID			0x0050
 #define PALM_TUNGSTEN_T_ID		0x0060
 #define PALM_TUNGSTEN_Z_ID		0x0031
-#define PALM_ZIRE31_ID			0x0061
 #define PALM_ZIRE_ID			0x0070
 #define PALM_M100_ID			0x0080
 
@@ -55,9 +54,6 @@
 #define ACEECA_VENDOR_ID		0x4766
 #define ACEECA_MEZ1000_ID		0x0001
 
-#define KYOCERA_VENDOR_ID		0x0C88
-#define KYOCERA_7135_ID			0x0021 
-
 /****************************************************************************
  * Handspring Visor Vendor specific request codes (bRequest values)
  * A big thank you to Handspring for providing the following information.
diff -Naur linuxppc-2.6.9/drivers/usb/serial/whiteheat.c linuxppc-2.6.9-dream/drivers/usb/serial/whiteheat.c
--- linuxppc-2.6.9/drivers/usb/serial/whiteheat.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/serial/whiteheat.c	2005-09-19 21:40:06.000000000 +0200
@@ -80,16 +80,17 @@
 #include <linux/usb.h>
 #include <linux/serial_reg.h>
 #include <linux/serial.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
 #include "usb-serial.h"
 #include "whiteheat_fw.h"		/* firmware for the ConnectTech WhiteHEAT device */
 #include "whiteheat.h"			/* WhiteHEAT specific commands */
 
-static int debug;
-
-#ifndef CMSPAR
-#define CMSPAR 0
-#endif
-
 /*
  * Version Information
  */
@@ -668,7 +669,8 @@
 
 	if (port->tty->driver->flush_buffer)
 		port->tty->driver->flush_buffer(port->tty);
-	tty_ldisc_flush(port->tty);
+	if (port->tty->ldisc.flush_buffer)
+		port->tty->ldisc.flush_buffer(port->tty);
 
 	firm_report_tx_done(port);
 
@@ -741,7 +743,7 @@
 			memcpy (urb->transfer_buffer, buf + sent, bytes);
 		}
 
-		usb_serial_debug_data(debug, &port->dev, __FUNCTION__, bytes, urb->transfer_buffer);
+		usb_serial_debug_data (__FILE__, __FUNCTION__, bytes, urb->transfer_buffer);
 
 		urb->dev = serial->dev;
 		urb->transfer_buffer_length = bytes;
@@ -829,7 +831,6 @@
 static int whiteheat_ioctl (struct usb_serial_port *port, struct file * file, unsigned int cmd, unsigned long arg)
 {
 	struct serial_struct serstruct;
-	void __user *user_arg = (void __user *)arg;
 
 	dbg("%s - port %d, cmd 0x%.4x", __FUNCTION__, port->number, cmd);
 
@@ -846,13 +847,13 @@
 			serstruct.close_delay = CLOSING_DELAY;
 			serstruct.closing_wait = CLOSING_DELAY;
 
-			if (copy_to_user(user_arg, &serstruct, sizeof(serstruct)))
+			if (copy_to_user((void *)arg, &serstruct, sizeof(serstruct)))
 				return -EFAULT;
 
 			break;
 
 		case TIOCSSERIAL:
-			if (copy_from_user(&serstruct, user_arg, sizeof(serstruct)))
+			if (copy_from_user(&serstruct, (void *)arg, sizeof(serstruct)))
 				return -EFAULT;
 
 			/*
@@ -969,12 +970,17 @@
 		dbg ("nonzero urb status: %d", urb->status);
 		return;
 	}
+
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, urb->transfer_buffer);
+
+	return;
 }
 
 
 static void command_port_read_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *command_port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial = get_usb_serial (command_port, __FUNCTION__);
 	struct whiteheat_command_private *command_info;
 	unsigned char *data = urb->transfer_buffer;
 	int result;
@@ -987,7 +993,12 @@
 		return;
 	}
 
-	usb_serial_debug_data(debug, &command_port->dev, __FUNCTION__, urb->actual_length, data);
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+	
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	command_info = usb_get_serial_port_data(command_port);
 	if (!command_info) {
@@ -1014,7 +1025,7 @@
 	}
 	
 	/* Continue trying to always read */
-	command_port->read_urb->dev = command_port->serial->dev;
+	command_port->read_urb->dev = serial->dev;
 	result = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);
 	spin_unlock_irqrestore(&command_info->lock, flags);
 	if (result)
@@ -1025,6 +1036,7 @@
 static void whiteheat_read_callback(struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	struct whiteheat_urb_wrap *wrap;
 	unsigned char *data = urb->transfer_buffer;
 	struct whiteheat_private *info = usb_get_serial_port_data(port);
@@ -1041,6 +1053,14 @@
 	list_del(&wrap->list);
 	spin_unlock(&info->lock);
 
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		spin_lock(&info->lock);
+		list_add(&wrap->list, &info->rx_urbs_free);
+		spin_unlock(&info->lock);
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
 		spin_lock(&info->lock);
@@ -1049,7 +1069,7 @@
 		return;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	usb_serial_debug_data (__FILE__, __FUNCTION__, urb->actual_length, data);
 
 	spin_lock(&info->lock);
 	list_add_tail(&wrap->list, &info->rx_urb_q);
@@ -1067,6 +1087,7 @@
 static void whiteheat_write_callback(struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
 	struct whiteheat_private *info = usb_get_serial_port_data(port);
 	struct whiteheat_urb_wrap *wrap;
 
@@ -1083,6 +1104,11 @@
 	list_add(&wrap->list, &info->tx_urbs_free);
 	spin_unlock(&info->lock);
 
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
 	if (urb->status) {
 		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 		return;
@@ -1102,6 +1128,7 @@
 	struct usb_serial_port *command_port;
 	struct whiteheat_command_private *command_info;
 	struct whiteheat_private *info;
+	int timeout;
 	__u8 *transfer_buffer;
 	int retval = 0;
 	unsigned long flags;
@@ -1126,8 +1153,10 @@
 	}
 
 	/* wait for the command to complete */
-	wait_event_interruptible_timeout(command_info->wait_command, 
-		(command_info->command_finished != FALSE), COMMAND_TIMEOUT);
+	timeout = COMMAND_TIMEOUT;
+	while (timeout && (command_info->command_finished == FALSE)) {
+		timeout = interruptible_sleep_on_timeout (&command_info->wait_command, timeout);
+	}
 
 	spin_lock_irqsave(&command_info->lock, flags);
 
@@ -1509,8 +1538,8 @@
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
-module_param(urb_pool_size, int, 0);
+MODULE_PARM(urb_pool_size, "i");
 MODULE_PARM_DESC(urb_pool_size, "Number of urbs to use for buffering");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM(debug, "i");
 MODULE_PARM_DESC(debug, "Debug enabled or not");
diff -Naur linuxppc-2.6.9/drivers/usb/storage/datafab.c linuxppc-2.6.9-dream/drivers/usb/storage/datafab.c
--- linuxppc-2.6.9/drivers/usb/storage/datafab.c	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/datafab.c	2005-09-19 21:40:06.000000000 +0200
@@ -50,19 +50,16 @@
  * in that routine.
  */
 
-#include <linux/sched.h>
-#include <linux/errno.h>
-#include <linux/slab.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-
 #include "transport.h"
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
 #include "datafab.h"
 
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+
 static int datafab_determine_lun(struct us_data *us,
 				 struct datafab_info *info);
 
@@ -324,7 +321,7 @@
 			goto leave;
 		}
 
-		msleep(20);
+		wait_ms(20);
 	}
 
 	rc = USB_STOR_TRANSPORT_ERROR;
@@ -391,7 +388,7 @@
 
 
 static int datafab_handle_mode_sense(struct us_data *us,
-				     struct scsi_cmnd * srb, 
+				     Scsi_Cmnd * srb, 
 				     int sense_6)
 {
 	static unsigned char rw_err_page[12] = {
@@ -486,13 +483,13 @@
 	if (sense_6)
 		ptr[0] = i - 1;
 	else
-		((__be16 *) ptr)[0] = cpu_to_be16(i - 2);
+		((u16 *) ptr)[0] = cpu_to_be16(i - 2);
 	usb_stor_set_xfer_buf(ptr, i, srb);
 
 	return USB_STOR_TRANSPORT_GOOD;
 }
 
-static void datafab_info_destructor(void *extra)
+void datafab_info_destructor(void *extra)
 {
 	// this routine is a placeholder...
 	// currently, we don't allocate any extra memory so we're okay
@@ -501,7 +498,7 @@
 
 // Transport for the Datafab MDCFE-B
 //
-int datafab_transport(struct scsi_cmnd * srb, struct us_data *us)
+int datafab_transport(Scsi_Cmnd * srb, struct us_data *us)
 {
 	struct datafab_info *info;
 	int rc;
@@ -542,9 +539,9 @@
 			  info->sectors, info->ssize);
 
 		// build the reply
-		// we need the last sector, not the number of sectors
-		((__be32 *) ptr)[0] = cpu_to_be32(info->sectors - 1);
-		((__be32 *) ptr)[1] = cpu_to_be32(info->ssize);
+		//
+		((u32 *) ptr)[0] = cpu_to_be32(info->sectors);
+		((u32 *) ptr)[1] = cpu_to_be32(info->ssize);
 		usb_stor_set_xfer_buf(ptr, 8, srb);
 
 		return USB_STOR_TRANSPORT_GOOD;
@@ -628,12 +625,12 @@
 
 	if (srb->cmnd[0] == MODE_SENSE) {
 		US_DEBUGP("datafab_transport:  MODE_SENSE_6 detected\n");
-		return datafab_handle_mode_sense(us, srb, 1);
+		return datafab_handle_mode_sense(us, srb, TRUE);
 	}
 
 	if (srb->cmnd[0] == MODE_SENSE_10) {
 		US_DEBUGP("datafab_transport:  MODE_SENSE_10 detected\n");
-		return datafab_handle_mode_sense(us, srb, 0);
+		return datafab_handle_mode_sense(us, srb, FALSE);
 	}
 
 	if (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {
diff -Naur linuxppc-2.6.9/drivers/usb/storage/datafab.h linuxppc-2.6.9-dream/drivers/usb/storage/datafab.h
--- linuxppc-2.6.9/drivers/usb/storage/datafab.h	2004-10-18 23:54:54.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/datafab.h	2005-09-19 21:40:06.000000000 +0200
@@ -24,7 +24,7 @@
 #ifndef _USB_DATAFAB_MDCFE_B_H
 #define _USB_DATAFAB_MDCFE_B_H
 
-extern int datafab_transport(struct scsi_cmnd *srb, struct us_data *us);
+extern int datafab_transport(Scsi_Cmnd *srb, struct us_data *us);
 
 struct datafab_info {
 	unsigned long   sectors;	// total sector count
diff -Naur linuxppc-2.6.9/drivers/usb/storage/debug.c linuxppc-2.6.9-dream/drivers/usb/storage/debug.c
--- linuxppc-2.6.9/drivers/usb/storage/debug.c	2004-10-18 23:53:21.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/debug.c	2005-09-19 21:40:06.000000000 +0200
@@ -44,15 +44,9 @@
  * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include <linux/cdrom.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-
 #include "debug.h"
-#include "scsi.h"
-
 
-void usb_stor_show_command(struct scsi_cmnd *srb)
+void usb_stor_show_command(Scsi_Cmnd *srb)
 {
 	char *what = NULL;
 	int i;
diff -Naur linuxppc-2.6.9/drivers/usb/storage/debug.h linuxppc-2.6.9-dream/drivers/usb/storage/debug.h
--- linuxppc-2.6.9/drivers/usb/storage/debug.h	2004-10-18 23:55:36.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/debug.h	2005-09-19 21:40:06.000000000 +0200
@@ -46,13 +46,13 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-
-struct scsi_cmnd;
+#include <linux/cdrom.h>
+#include "usb.h"
 
 #define USB_STORAGE "usb-storage: "
 
 #ifdef CONFIG_USB_STORAGE_DEBUG
-void usb_stor_show_command(struct scsi_cmnd *srb);
+void usb_stor_show_command(Scsi_Cmnd *srb);
 void usb_stor_show_sense( unsigned char key,
 		unsigned char asc, unsigned char ascq );
 #define US_DEBUGP(x...) printk( KERN_DEBUG USB_STORAGE x )
diff -Naur linuxppc-2.6.9/drivers/usb/storage/dpcm.c linuxppc-2.6.9-dream/drivers/usb/storage/dpcm.c
--- linuxppc-2.6.9/drivers/usb/storage/dpcm.c	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/dpcm.c	2005-09-19 21:40:06.000000000 +0200
@@ -30,10 +30,6 @@
  */
 
 #include <linux/config.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_device.h>
-
 #include "transport.h"
 #include "protocol.h"
 #include "usb.h"
@@ -45,7 +41,7 @@
  * Transport for the Microtech DPCM-USB
  *
  */
-int dpcm_transport(struct scsi_cmnd *srb, struct us_data *us)
+int dpcm_transport(Scsi_Cmnd *srb, struct us_data *us)
 {
   int ret;
 
@@ -60,8 +56,7 @@
     /*
      * LUN 0 corresponds to the CompactFlash card reader.
      */
-    ret = usb_stor_CB_transport(srb, us);
-    break;
+    return usb_stor_CB_transport(srb, us);
 
 #ifdef CONFIG_USB_STORAGE_SDDR09
   case 1:
@@ -76,14 +71,12 @@
     srb->device->lun = 0; us->srb->device->lun = 0;
     ret = sddr09_transport(srb, us);
     srb->device->lun = 1; us->srb->device->lun = 1;
-    break;
 
+    return ret;
 #endif
 
   default:
     US_DEBUGP("dpcm_transport: Invalid LUN %d\n", srb->device->lun);
-    ret = USB_STOR_TRANSPORT_ERROR;
-    break;
+    return USB_STOR_TRANSPORT_ERROR;
   }
-  return ret;
 }
diff -Naur linuxppc-2.6.9/drivers/usb/storage/dpcm.h linuxppc-2.6.9-dream/drivers/usb/storage/dpcm.h
--- linuxppc-2.6.9/drivers/usb/storage/dpcm.h	2004-10-18 23:53:45.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/dpcm.h	2005-09-19 21:40:06.000000000 +0200
@@ -29,6 +29,6 @@
 #ifndef _MICROTECH_DPCM_USB_H
 #define _MICROTECH_DPCM_USB_H
 
-extern int dpcm_transport(struct scsi_cmnd *srb, struct us_data *us);
+extern int dpcm_transport(Scsi_Cmnd *srb, struct us_data *us);
 
 #endif
diff -Naur linuxppc-2.6.9/drivers/usb/storage/freecom.c linuxppc-2.6.9-dream/drivers/usb/storage/freecom.c
--- linuxppc-2.6.9/drivers/usb/storage/freecom.c	2004-10-18 23:55:29.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/freecom.c	2005-09-19 21:40:06.000000000 +0200
@@ -29,16 +29,12 @@
  */
 
 #include <linux/config.h>
-#include <linux/hdreg.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-
 #include "transport.h"
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
 #include "freecom.h"
+#include "linux/hdreg.h"
 
 #ifdef CONFIG_USB_STORAGE_DEBUG
 static void pdump (void *, int);
@@ -59,14 +55,14 @@
 struct freecom_xfer_wrap {
 	u8    Type;		/* Command type. */
 	u8    Timeout;		/* Timeout in seconds. */
-	__le32   Count;		/* Number of bytes to transfer. */
+	u32   Count;		/* Number of bytes to transfer. */
 	u8    Pad[58];
 } __attribute__ ((packed));
 
 struct freecom_ide_out {
 	u8    Type;		/* Type + IDE register. */
 	u8    Pad;
-	__le16   Value;		/* Value to write. */
+	u16   Value;		/* Value to write. */
 	u8    Pad2[60];
 };
 
@@ -78,7 +74,7 @@
 struct freecom_status {
 	u8    Status;
 	u8    Reason;
-	__le16   Count;
+	u16   Count;
 	u8    Pad[60];
 };
 
@@ -109,7 +105,7 @@
 #define FCM_STATUS_PACKET_LENGTH	4
 
 static int
-freecom_readdata (struct scsi_cmnd *srb, struct us_data *us,
+freecom_readdata (Scsi_Cmnd *srb, struct us_data *us,
 		unsigned int ipipe, unsigned int opipe, int count)
 {
 	struct freecom_xfer_wrap *fxfr =
@@ -143,7 +139,7 @@
 }
 
 static int
-freecom_writedata (struct scsi_cmnd *srb, struct us_data *us,
+freecom_writedata (Scsi_Cmnd *srb, struct us_data *us,
 		int unsigned ipipe, unsigned int opipe, int count)
 {
 	struct freecom_xfer_wrap *fxfr =
@@ -180,7 +176,7 @@
  * Transport for the Freecom USB/IDE adaptor.
  *
  */
-int freecom_transport(struct scsi_cmnd *srb, struct us_data *us)
+int freecom_transport(Scsi_Cmnd *srb, struct us_data *us)
 {
 	struct freecom_cb_wrap *fcb;
 	struct freecom_status  *fst;
@@ -306,7 +302,7 @@
 	 * move in. */
 
 	switch (us->srb->sc_data_direction) {
-	case DMA_FROM_DEVICE:
+	case SCSI_DATA_READ:
 		/* catch bogus "read 0 length" case */
 		if (!length)
 			break;
@@ -338,7 +334,7 @@
 		US_DEBUGP("Transfer happy\n");
 		break;
 
-	case DMA_TO_DEVICE:
+	case SCSI_DATA_WRITE:
 		/* catch bogus "write 0 length" case */
 		if (!length)
 			break;
@@ -368,7 +364,7 @@
 		break;
 
 
-	case DMA_NONE:
+	case SCSI_DATA_NONE:
 		/* Easy, do nothing. */
 		break;
 
diff -Naur linuxppc-2.6.9/drivers/usb/storage/freecom.h linuxppc-2.6.9-dream/drivers/usb/storage/freecom.h
--- linuxppc-2.6.9/drivers/usb/storage/freecom.h	2004-10-18 23:53:44.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/freecom.h	2005-09-19 21:40:06.000000000 +0200
@@ -29,7 +29,7 @@
 #ifndef _FREECOM_USB_H
 #define _FREECOM_USB_H
 
-extern int freecom_transport(struct scsi_cmnd *srb, struct us_data *us);
+extern int freecom_transport(Scsi_Cmnd *srb, struct us_data *us);
 extern int usb_stor_freecom_reset(struct us_data *us);
 extern int freecom_init (struct us_data *us);
 
diff -Naur linuxppc-2.6.9/drivers/usb/storage/isd200.c linuxppc-2.6.9-dream/drivers/usb/storage/isd200.c
--- linuxppc-2.6.9/drivers/usb/storage/isd200.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/isd200.c	2005-09-19 21:40:06.000000000 +0200
@@ -44,16 +44,6 @@
 
 /* Include files */
 
-#include <linux/jiffies.h>
-#include <linux/errno.h>
-#include <linux/slab.h>
-#include <linux/hdreg.h>
-#include <linux/ide.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_device.h>
-
 #include "transport.h"
 #include "protocol.h"
 #include "usb.h"
@@ -61,6 +51,11 @@
 #include "scsiglue.h"
 #include "isd200.h"
 
+#include <linux/jiffies.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/hdreg.h>
+#include <linux/ide.h>
 
 /* Timeout defines (in Seconds) */
 
@@ -295,8 +290,8 @@
  */
 
 struct read_capacity_data {
-	__be32 LogicalBlockAddress;
-	__be32 BytesPerBlock;
+	unsigned long LogicalBlockAddress;
+	unsigned long BytesPerBlock;
 };
 
 /*
@@ -354,7 +349,7 @@
  * RETURNS:
  *    void
  */
-static void isd200_build_sense(struct us_data *us, struct scsi_cmnd *srb)
+void isd200_build_sense(struct us_data *us, Scsi_Cmnd *srb)
 {
 	struct isd200_info *info = (struct isd200_info *)us->extra;
 	struct sense_data *buf = (struct sense_data *) &srb->sense_buffer[0];
@@ -432,7 +427,7 @@
 		ata.generic.RegisterSelect =
 		  REG_CYLINDER_LOW | REG_CYLINDER_HIGH |
 		  REG_STATUS | REG_ERROR;
-		srb->sc_data_direction = DMA_FROM_DEVICE;
+		srb->sc_data_direction = SCSI_DATA_READ;
 		srb->request_buffer = pointer;
 		srb->request_bufflen = value;
 		break;
@@ -444,7 +439,7 @@
 					   ACTION_SELECT_5;
 		ata.generic.RegisterSelect = REG_DEVICE_HEAD;
 		ata.write.DeviceHeadByte = value;
-		srb->sc_data_direction = DMA_NONE;
+		srb->sc_data_direction = SCSI_DATA_NONE;
 		break;
 
 	case ACTION_RESET:
@@ -453,7 +448,7 @@
 					   ACTION_SELECT_3|ACTION_SELECT_4;
 		ata.generic.RegisterSelect = REG_DEVICE_CONTROL;
 		ata.write.DeviceControlByte = ATA_DC_RESET_CONTROLLER;
-		srb->sc_data_direction = DMA_NONE;
+		srb->sc_data_direction = SCSI_DATA_NONE;
 		break;
 
 	case ACTION_REENABLE:
@@ -462,7 +457,7 @@
 					   ACTION_SELECT_3|ACTION_SELECT_4;
 		ata.generic.RegisterSelect = REG_DEVICE_CONTROL;
 		ata.write.DeviceControlByte = ATA_DC_REENABLE_CONTROLLER;
-		srb->sc_data_direction = DMA_NONE;
+		srb->sc_data_direction = SCSI_DATA_NONE;
 		break;
 
 	case ACTION_SOFT_RESET:
@@ -471,14 +466,14 @@
 		ata.generic.RegisterSelect = REG_DEVICE_HEAD | REG_COMMAND;
 		ata.write.DeviceHeadByte = info->DeviceHead;
 		ata.write.CommandByte = WIN_SRST;
-		srb->sc_data_direction = DMA_NONE;
+		srb->sc_data_direction = SCSI_DATA_NONE;
 		break;
 
 	case ACTION_IDENTIFY:
 		US_DEBUGP("   isd200_action(IDENTIFY)\n");
 		ata.generic.RegisterSelect = REG_COMMAND;
 		ata.write.CommandByte = WIN_IDENTIFY;
-		srb->sc_data_direction = DMA_FROM_DEVICE;
+		srb->sc_data_direction = SCSI_DATA_READ;
 		srb->request_buffer = (void *) info->id;
 		srb->request_bufflen = sizeof(struct hd_driveid);
 		break;
@@ -510,7 +505,7 @@
  * RETURNS:
  *    ISD status code
  */
-static int isd200_read_regs( struct us_data *us )
+int isd200_read_regs( struct us_data *us )
 {
 	struct isd200_info *info = (struct isd200_info *)us->extra;
 	int retStatus = ISD200_GOOD;
@@ -539,8 +534,8 @@
  * This is used by the protocol layers to actually send the message to
  * the device and receive the response.
  */
-static void isd200_invoke_transport( struct us_data *us, 
-			      struct scsi_cmnd *srb, 
+void isd200_invoke_transport( struct us_data *us, 
+			      Scsi_Cmnd *srb, 
 			      union ata_cdb *ataCdb )
 {
 	int need_auto_sense = 0;
@@ -682,7 +677,7 @@
  * RETURNS:
  *    ISD status code
  */
-static int isd200_write_config( struct us_data *us ) 
+int isd200_write_config( struct us_data *us ) 
 {
 	struct isd200_info *info = (struct isd200_info *)us->extra;
 	int retStatus = ISD200_GOOD;
@@ -725,7 +720,7 @@
  * RETURNS:
  *    ISD status code
  */
-static int isd200_read_config( struct us_data *us ) 
+int isd200_read_config( struct us_data *us ) 
 {
 	struct isd200_info *info = (struct isd200_info *)us->extra;
 	int retStatus = ISD200_GOOD;
@@ -770,7 +765,7 @@
  * RETURNS:
  *    NT status code
  */
-static int isd200_atapi_soft_reset( struct us_data *us ) 
+int isd200_atapi_soft_reset( struct us_data *us ) 
 {
 	int retStatus = ISD200_GOOD;
 	int transferStatus;
@@ -796,7 +791,7 @@
  * RETURNS:
  *    ISD status code
  */
-static int isd200_srst( struct us_data *us ) 
+int isd200_srst( struct us_data *us ) 
 {
 	int retStatus = ISD200_GOOD;
 	int transferStatus;
@@ -811,7 +806,7 @@
 		retStatus = ISD200_ERROR;
 	} else {
 		/* delay 10ms to give the drive a chance to see it */
-		msleep(10);
+		wait_ms(10);
 
 		transferStatus = isd200_action( us, ACTION_REENABLE, NULL, 0 );
 		if (transferStatus != ISD200_TRANSPORT_GOOD) {
@@ -819,7 +814,7 @@
 			retStatus = ISD200_ERROR;
 		} else {
 			/* delay 50ms to give the drive a chance to recover after SRST */
-			msleep(50);
+			wait_ms(50);
 		}
 	}
 
@@ -844,7 +839,7 @@
 	unsigned long endTime;
 	struct isd200_info *info = (struct isd200_info *)us->extra;
 	unsigned char *regs = info->RegsBuf;
-	int recheckAsMaster = 0;
+	int recheckAsMaster = FALSE;
 
 	if ( detect )
 		endTime = jiffies + ISD200_ENUM_DETECT_TIMEOUT * HZ;
@@ -852,7 +847,7 @@
 		endTime = jiffies + ISD200_ENUM_BSY_TIMEOUT * HZ;
 
 	/* loop until we detect !BSY or timeout */
-	while(1) {
+	while(TRUE) {
 #ifdef CONFIG_USB_STORAGE_DEBUG
 		char* mstr = master_slave == ATA_ADDRESS_DEVHEAD_STD ?
 			"Master" : "Slave";
@@ -904,9 +899,9 @@
 			   itself okay as a master also
 			*/
 			if ((master_slave & ATA_ADDRESS_DEVHEAD_SLAVE) &&
-			    !recheckAsMaster) {
+			    (recheckAsMaster == FALSE)) {
 				US_DEBUGP("   Identified ATAPI device as slave.  Rechecking again as master\n");
-				recheckAsMaster = 1;
+				recheckAsMaster = TRUE;
 				master_slave = ATA_ADDRESS_DEVHEAD_STD;
 			} else {
 				US_DEBUGP("   Identified ATAPI device\n");
@@ -942,7 +937,7 @@
  * RETURNS:
  *    ISD status code
  */
-static int isd200_manual_enum(struct us_data *us)
+int isd200_manual_enum(struct us_data *us)
 {
 	struct isd200_info *info = (struct isd200_info *)us->extra;
 	int retStatus = ISD200_GOOD;
@@ -953,15 +948,15 @@
 	if (retStatus == ISD200_GOOD) {
 		int isslave;
 		/* master or slave? */
-		retStatus = isd200_try_enum( us, ATA_ADDRESS_DEVHEAD_STD, 0);
+		retStatus = isd200_try_enum( us, ATA_ADDRESS_DEVHEAD_STD, FALSE );
 		if (retStatus == ISD200_GOOD)
-			retStatus = isd200_try_enum( us, ATA_ADDRESS_DEVHEAD_SLAVE, 0);
+			retStatus = isd200_try_enum( us, ATA_ADDRESS_DEVHEAD_SLAVE, FALSE );
 
 		if (retStatus == ISD200_GOOD) {
 			retStatus = isd200_srst(us);
 			if (retStatus == ISD200_GOOD)
 				/* ata or atapi? */
-				retStatus = isd200_try_enum( us, ATA_ADDRESS_DEVHEAD_STD, 1);
+				retStatus = isd200_try_enum( us, ATA_ADDRESS_DEVHEAD_STD, TRUE );
 		}
 
 		isslave = (info->DeviceHead & ATA_ADDRESS_DEVHEAD_SLAVE) ? 1 : 0;
@@ -986,7 +981,7 @@
  * RETURNS:
  *    ISD status code
  */
-static int isd200_get_inquiry_data( struct us_data *us )
+int isd200_get_inquiry_data( struct us_data *us )
 {
 	struct isd200_info *info = (struct isd200_info *)us->extra;
 	int retStatus = ISD200_GOOD;
@@ -1016,8 +1011,7 @@
 			} else {
 				/* ATA Command Identify successful */
 				int i;
-				__be16 *src;
-				__u16 *dest;
+				__u16 *src, *dest;
 				ide_fix_driveid(id);
 
 				US_DEBUGP("   Identify Data Structure:\n");
@@ -1069,17 +1063,17 @@
 				}
 
 				/* Fill in vendor identification fields */
-				src = (__be16*)id->model;
+				src = (__u16*)id->model;
 				dest = (__u16*)info->InquiryData.VendorId;
 				for (i=0;i<4;i++)
 					dest[i] = be16_to_cpu(src[i]);
 
-				src = (__be16*)(id->model+8);
+				src = (__u16*)(id->model+8);
 				dest = (__u16*)info->InquiryData.ProductId;
 				for (i=0;i<8;i++)
 					dest[i] = be16_to_cpu(src[i]);
 
-				src = (__be16*)id->fw_rev;
+				src = (__u16*)id->fw_rev;
 				dest = (__u16*)info->InquiryData.ProductRevisionLevel;
 				for (i=0;i<2;i++)
 					dest[i] = be16_to_cpu(src[i]);
@@ -1127,15 +1121,15 @@
  * Translate SCSI commands to ATA commands.
  *
  * RETURNS:
- *    1 if the command needs to be sent to the transport layer
- *    0 otherwise
+ *    TRUE if the command needs to be sent to the transport layer
+ *    FALSE otherwise
  */
-static int isd200_scsi_to_ata(struct scsi_cmnd *srb, struct us_data *us,
-			      union ata_cdb * ataCdb)
+int isd200_scsi_to_ata(Scsi_Cmnd *srb, struct us_data *us, 
+		       union ata_cdb * ataCdb)
 {
 	struct isd200_info *info = (struct isd200_info *)us->extra;
 	struct hd_driveid *id = info->id;
-	int sendToTransport = 1;
+	int sendToTransport = TRUE;
 	unsigned char sectnum, head;
 	unsigned short cylinder;
 	unsigned long lba;
@@ -1153,7 +1147,7 @@
 		usb_stor_set_xfer_buf((unsigned char *) &info->InquiryData,
 				sizeof(info->InquiryData), srb);
 		srb->result = SAM_STAT_GOOD;
-		sendToTransport = 0;
+		sendToTransport = FALSE;
 		break;
 
 	case MODE_SENSE:
@@ -1173,7 +1167,7 @@
 		} else {
 			US_DEBUGP("   Media Status not supported, just report okay\n");
 			srb->result = SAM_STAT_GOOD;
-			sendToTransport = 0;
+			sendToTransport = FALSE;
 		}
 		break;
 
@@ -1191,7 +1185,7 @@
 		} else {
 			US_DEBUGP("   Media Status not supported, just report okay\n");
 			srb->result = SAM_STAT_GOOD;
-			sendToTransport = 0;
+			sendToTransport = FALSE;
 		}
 		break;
 
@@ -1215,14 +1209,15 @@
 		usb_stor_set_xfer_buf((unsigned char *) &readCapacityData,
 				sizeof(readCapacityData), srb);
 		srb->result = SAM_STAT_GOOD;
-		sendToTransport = 0;
+		sendToTransport = FALSE;
 	}
 	break;
 
 	case READ_10:
 		US_DEBUGP("   ATA OUT - SCSIOP_READ\n");
 
-		lba = be32_to_cpu(*(__be32 *)&srb->cmnd[2]);
+		lba = *(unsigned long *)&srb->cmnd[2]; 
+		lba = cpu_to_be32(lba);
 		blockCount = (unsigned long)srb->cmnd[7]<<8 | (unsigned long)srb->cmnd[8];
 
 		if (id->capability & CAPABILITY_LBA) {
@@ -1254,7 +1249,8 @@
 	case WRITE_10:
 		US_DEBUGP("   ATA OUT - SCSIOP_WRITE\n");
 
-		lba = be32_to_cpu(*(__be32 *)&srb->cmnd[2]);
+		lba = *(unsigned long *)&srb->cmnd[2]; 
+		lba = cpu_to_be32(lba);
 		blockCount = (unsigned long)srb->cmnd[7]<<8 | (unsigned long)srb->cmnd[8];
 
 		if (id->capability & CAPABILITY_LBA) {
@@ -1297,7 +1293,7 @@
 		} else {
 			US_DEBUGP("   Not removeable media, just report okay\n");
 			srb->result = SAM_STAT_GOOD;
-			sendToTransport = 0;
+			sendToTransport = FALSE;
 		}
 		break;
 
@@ -1323,14 +1319,14 @@
 		} else {
 			US_DEBUGP("   Nothing to do, just report okay\n");
 			srb->result = SAM_STAT_GOOD;
-			sendToTransport = 0;
+			sendToTransport = FALSE;
 		}
 		break;
 
 	default:
 		US_DEBUGP("Unsupported SCSI command - 0x%X\n", srb->cmnd[0]);
 		srb->result = DID_ERROR << 16;
-		sendToTransport = 0;
+		sendToTransport = FALSE;
 		break;
 	}
 
@@ -1343,7 +1339,7 @@
  *
  * Frees the driver structure.
  */
-static void isd200_free_info_ptrs(void *info_)
+void isd200_free_info_ptrs(void *info_)
 {
 	struct isd200_info *info = (struct isd200_info *) info_;
 
@@ -1361,7 +1357,7 @@
  * RETURNS:
  *    ISD status code
  */
-static int isd200_init_info(struct us_data *us)
+int isd200_init_info(struct us_data *us)
 {
 	int retStatus = ISD200_GOOD;
 	struct isd200_info *info;
@@ -1428,9 +1424,9 @@
  *
  */
 
-void isd200_ata_command(struct scsi_cmnd *srb, struct us_data *us)
+void isd200_ata_command(Scsi_Cmnd *srb, struct us_data *us)
 {
-	int sendToTransport = 1;
+	int sendToTransport = TRUE;
 	union ata_cdb ataCdb;
 
 	/* Make sure driver was initialized */
diff -Naur linuxppc-2.6.9/drivers/usb/storage/isd200.h linuxppc-2.6.9-dream/drivers/usb/storage/isd200.h
--- linuxppc-2.6.9/drivers/usb/storage/isd200.h	2004-10-18 23:53:22.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/isd200.h	2005-09-19 21:40:06.000000000 +0200
@@ -25,7 +25,7 @@
 #ifndef _USB_ISD200_H
 #define _USB_ISD200_H
 
-extern void isd200_ata_command(struct scsi_cmnd *srb, struct us_data *us);
+extern void isd200_ata_command(Scsi_Cmnd *srb, struct us_data *us);
 extern int isd200_Initialization(struct us_data *us);
 
 #endif
diff -Naur linuxppc-2.6.9/drivers/usb/storage/jumpshot.c linuxppc-2.6.9-dream/drivers/usb/storage/jumpshot.c
--- linuxppc-2.6.9/drivers/usb/storage/jumpshot.c	2004-10-18 23:53:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/jumpshot.c	2005-09-19 21:40:06.000000000 +0200
@@ -47,19 +47,15 @@
   * in that routine.
   */
 
-#include <linux/sched.h>
-#include <linux/errno.h>
-#include <linux/slab.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-
 #include "transport.h"
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
 #include "jumpshot.h"
 
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
 
 static inline int jumpshot_bulk_read(struct us_data *us,
 				     unsigned char *data, 
@@ -257,7 +253,7 @@
 			if (result != USB_STOR_TRANSPORT_GOOD) {
 				// I have not experimented to find the smallest value.
 				//
-				msleep(50); 
+				wait_ms(50); 
 			}
 		} while ((result != USB_STOR_TRANSPORT_GOOD) && (waitcount < 10));
 
@@ -323,7 +319,7 @@
 }
 
 static int jumpshot_handle_mode_sense(struct us_data *us,
-				      struct scsi_cmnd * srb, 
+				      Scsi_Cmnd * srb, 
 				      int sense_6)
 {
 	static unsigned char rw_err_page[12] = {
@@ -413,14 +409,14 @@
 	if (sense_6)
 		ptr[0] = i - 1;
 	else
-		((__be16 *) ptr)[0] = cpu_to_be16(i - 2);
+		((u16 *) ptr)[0] = cpu_to_be16(i - 2);
 	usb_stor_set_xfer_buf(ptr, i, srb);
 
 	return USB_STOR_TRANSPORT_GOOD;
 }
 
 
-static void jumpshot_info_destructor(void *extra)
+void jumpshot_info_destructor(void *extra)
 {
 	// this routine is a placeholder...
 	// currently, we don't allocate any extra blocks so we're okay
@@ -430,7 +426,7 @@
 
 // Transport for the Lexar 'Jumpshot'
 //
-int jumpshot_transport(struct scsi_cmnd * srb, struct us_data *us)
+int jumpshot_transport(Scsi_Cmnd * srb, struct us_data *us)
 {
 	struct jumpshot_info *info;
 	int rc;
@@ -475,8 +471,8 @@
 
 		// build the reply
 		//
-		((__be32 *) ptr)[0] = cpu_to_be32(info->sectors - 1);
-		((__be32 *) ptr)[1] = cpu_to_be32(info->ssize);
+		((u32 *) ptr)[0] = cpu_to_be32(info->sectors);
+		((u32 *) ptr)[1] = cpu_to_be32(info->ssize);
 		usb_stor_set_xfer_buf(ptr, 8, srb);
 
 		return USB_STOR_TRANSPORT_GOOD;
@@ -555,12 +551,12 @@
 
 	if (srb->cmnd[0] == MODE_SENSE) {
 		US_DEBUGP("jumpshot_transport:  MODE_SENSE_6 detected\n");
-		return jumpshot_handle_mode_sense(us, srb, 1);
+		return jumpshot_handle_mode_sense(us, srb, TRUE);
 	}
 
 	if (srb->cmnd[0] == MODE_SENSE_10) {
 		US_DEBUGP("jumpshot_transport:  MODE_SENSE_10 detected\n");
-		return jumpshot_handle_mode_sense(us, srb, 0);
+		return jumpshot_handle_mode_sense(us, srb, FALSE);
 	}
 
 	if (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {
diff -Naur linuxppc-2.6.9/drivers/usb/storage/jumpshot.h linuxppc-2.6.9-dream/drivers/usb/storage/jumpshot.h
--- linuxppc-2.6.9/drivers/usb/storage/jumpshot.h	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/jumpshot.h	2005-09-19 21:40:06.000000000 +0200
@@ -24,7 +24,7 @@
 #ifndef _USB_JUMPSHOT_H
 #define _USB_JUMPSHOT_H
 
-extern int jumpshot_transport(struct scsi_cmnd *srb, struct us_data *us);
+extern int jumpshot_transport(Scsi_Cmnd *srb, struct us_data *us);
 
 struct jumpshot_info {
    unsigned long   sectors;     // total sector count
diff -Naur linuxppc-2.6.9/drivers/usb/storage/Kconfig linuxppc-2.6.9-dream/drivers/usb/storage/Kconfig
--- linuxppc-2.6.9/drivers/usb/storage/Kconfig	2004-10-18 23:55:28.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/Kconfig	2005-09-19 21:40:06.000000000 +0200
@@ -23,28 +23,6 @@
 	  Say Y here in order to have the USB Mass Storage code generate
 	  verbose debugging messages.
 
-config USB_STORAGE_RW_DETECT
-	bool "USB Mass Storage Write-Protected Media Detection (EXPERIMENTAL)"
-	depends on USB_STORAGE && EXPERIMENTAL
-	help
-	  Say Y here in order to have the USB Mass Storage code indicate to
-	  the SCSI layer that using MODE SENSE(6) and MODE SENSE(10) to
-	  determine if the media is write-protected is a good thing to do.
-
-	  Many devices have historically had trouble with these commands,
-	  hence the default 2.6.x behavior has been to suppress their use.
-	  2.4.x used these commands with (at best) mixed results, often
-	  crashing the firmware of the device.  However, the SCSI layer now
-	  issues these commands in a manner more consistent with other
-	  "popular" OSes, in an attempt to improve compatibility.
-
-	  Saying Y here allows these commands to be sent to a USB device.
-	  If you find a device this doesn't work for, switch to N and let
-	  us know at usb-storage@lists.one-eyed-alien.net
-
-	  If you say N here, the kernel will assume that all disk-like USB
-	  devices are write-enabled.
-
 config USB_STORAGE_DATAFAB
 	bool "Datafab Compact Flash Reader support (EXPERIMENTAL)"
 	depends on USB_STORAGE && EXPERIMENTAL
diff -Naur linuxppc-2.6.9/drivers/usb/storage/protocol.c linuxppc-2.6.9-dream/drivers/usb/storage/protocol.c
--- linuxppc-2.6.9/drivers/usb/storage/protocol.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/protocol.c	2005-09-19 21:40:06.000000000 +0200
@@ -45,8 +45,6 @@
  */
 
 #include <linux/highmem.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
@@ -61,7 +59,7 @@
  * Fix-up the return data from an INQUIRY command to show 
  * ANSI SCSI rev 2 so we don't confuse the SCSI layers above us
  */
-static void fix_inquiry_data(struct scsi_cmnd *srb)
+static void fix_inquiry_data(Scsi_Cmnd *srb)
 {
 	unsigned char databuf[3];
 	unsigned int index, offset;
@@ -93,10 +91,10 @@
  * Fix-up the return data from a READ CAPACITY command. My Feiya reader
  * returns a value that is 1 too large.
  */
-static void fix_read_capacity(struct scsi_cmnd *srb)
+static void fix_read_capacity(Scsi_Cmnd *srb)
 {
 	unsigned int index, offset;
-	__be32 c;
+	u32 c;
 	unsigned long capacity;
 
 	/* verify that it's a READ CAPACITY command */
@@ -122,11 +120,11 @@
  * Protocol routines
  ***********************************************************************/
 
-void usb_stor_qic157_command(struct scsi_cmnd *srb, struct us_data *us)
+void usb_stor_qic157_command(Scsi_Cmnd *srb, struct us_data *us)
 {
 	/* Pad the ATAPI command with zeros 
 	 *
-	 * NOTE: This only works because a scsi_cmnd struct field contains
+	 * NOTE: This only works because a Scsi_Cmnd struct field contains
 	 * a unsigned char cmnd[16], so we know we have storage available
 	 */
 	for (; srb->cmd_len<12; srb->cmd_len++)
@@ -143,11 +141,11 @@
 	}
 }
 
-void usb_stor_ATAPI_command(struct scsi_cmnd *srb, struct us_data *us)
+void usb_stor_ATAPI_command(Scsi_Cmnd *srb, struct us_data *us)
 {
 	/* Pad the ATAPI command with zeros 
 	 *
-	 * NOTE: This only works because a scsi_cmnd struct field contains
+	 * NOTE: This only works because a Scsi_Cmnd struct field contains
 	 * a unsigned char cmnd[16], so we know we have storage available
 	 */
 
@@ -168,12 +166,12 @@
 }
 
 
-void usb_stor_ufi_command(struct scsi_cmnd *srb, struct us_data *us)
+void usb_stor_ufi_command(Scsi_Cmnd *srb, struct us_data *us)
 {
 	/* fix some commands -- this is a form of mode translation
 	 * UFI devices only accept 12 byte long commands 
 	 *
-	 * NOTE: This only works because a scsi_cmnd struct field contains
+	 * NOTE: This only works because a Scsi_Cmnd struct field contains
 	 * a unsigned char cmnd[16], so we know we have storage available
 	 */
 
@@ -215,8 +213,7 @@
 	}
 }
 
-void usb_stor_transparent_scsi_command(struct scsi_cmnd *srb,
-				       struct us_data *us)
+void usb_stor_transparent_scsi_command(Scsi_Cmnd *srb, struct us_data *us)
 {
 	/* send the command to the transport layer */
 	usb_stor_invoke_transport(srb, us);
@@ -244,7 +241,7 @@
  * pick up from where this one left off. */
 
 unsigned int usb_stor_access_xfer_buf(unsigned char *buffer,
-	unsigned int buflen, struct scsi_cmnd *srb, unsigned int *index,
+	unsigned int buflen, Scsi_Cmnd *srb, unsigned int *index,
 	unsigned int *offset, enum xfer_buf_dir dir)
 {
 	unsigned int cnt;
@@ -330,7 +327,7 @@
 /* Store the contents of buffer into srb's transfer buffer and set the
  * SCSI residue. */
 void usb_stor_set_xfer_buf(unsigned char *buffer,
-	unsigned int buflen, struct scsi_cmnd *srb)
+	unsigned int buflen, Scsi_Cmnd *srb)
 {
 	unsigned int index = 0, offset = 0;
 
diff -Naur linuxppc-2.6.9/drivers/usb/storage/protocol.h linuxppc-2.6.9-dream/drivers/usb/storage/protocol.h
--- linuxppc-2.6.9/drivers/usb/storage/protocol.h	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/protocol.h	2005-09-19 21:40:06.000000000 +0200
@@ -41,8 +41,9 @@
 #ifndef _PROTOCOL_H_
 #define _PROTOCOL_H_
 
-struct scsi_cmnd;
-struct us_data;
+#include <linux/blkdev.h>
+#include "scsi.h"
+#include "usb.h"
 
 /* Sub Classes */
 
@@ -59,19 +60,18 @@
 #define US_SC_DEVICE	0xff		/* Use device's value */
 
 /* Protocol handling routines */
-extern void usb_stor_ATAPI_command(struct scsi_cmnd*, struct us_data*);
-extern void usb_stor_qic157_command(struct scsi_cmnd*, struct us_data*);
-extern void usb_stor_ufi_command(struct scsi_cmnd*, struct us_data*);
-extern void usb_stor_transparent_scsi_command(struct scsi_cmnd*,
-		struct us_data*);
+extern void usb_stor_ATAPI_command(Scsi_Cmnd*, struct us_data*);
+extern void usb_stor_qic157_command(Scsi_Cmnd*, struct us_data*);
+extern void usb_stor_ufi_command(Scsi_Cmnd*, struct us_data*);
+extern void usb_stor_transparent_scsi_command(Scsi_Cmnd*, struct us_data*);
 
-/* struct scsi_cmnd transfer buffer access utilities */
+/* Scsi_Cmnd transfer buffer access utilities */
 enum xfer_buf_dir	{TO_XFER_BUF, FROM_XFER_BUF};
 
 extern unsigned int usb_stor_access_xfer_buf(unsigned char *buffer,
-	unsigned int buflen, struct scsi_cmnd *srb, unsigned int *index,
+	unsigned int buflen, Scsi_Cmnd *srb, unsigned int *index,
 	unsigned int *offset, enum xfer_buf_dir dir);
 
 extern void usb_stor_set_xfer_buf(unsigned char *buffer,
-	unsigned int buflen, struct scsi_cmnd *srb);
+	unsigned int buflen, Scsi_Cmnd *srb);
 #endif
diff -Naur linuxppc-2.6.9/drivers/usb/storage/scsiglue.c linuxppc-2.6.9-dream/drivers/usb/storage/scsiglue.c
--- linuxppc-2.6.9/drivers/usb/storage/scsiglue.c	2004-10-18 23:54:08.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/scsiglue.c	2005-09-19 21:40:19.000000000 +0200
@@ -44,22 +44,16 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
+#include "scsiglue.h"
+#include "usb.h"
+#include "debug.h"
+#include "transport.h"
 
 #include <linux/slab.h>
 #include <linux/module.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_devinfo.h>
-#include <scsi/scsi_device.h>
-#include <scsi/scsi_eh.h>
 #include <scsi/scsi_host.h>
 
-#include "scsiglue.h"
-#include "usb.h"
-#include "debug.h"
-#include "transport.h"
-#include "protocol.h"
 
 /***********************************************************************
  * Host functions 
@@ -70,20 +64,6 @@
 	return "SCSI emulation for USB Mass Storage devices";
 }
 
-static int slave_alloc (struct scsi_device *sdev)
-{
-	/*
-	 * Set default bflags. These can be overridden for individual
-	 * models and vendors via the scsi devinfo mechanism.  The only
-	 * flag we need is to force 36-byte INQUIRYs; we don't use any
-	 * of the extra data and many devices choke if asked for more or
-	 * less than 36 bytes.
-	 */
-	sdev->sdev_bflags = BLIST_INQUIRY_36;
-
-	return 0;
-}
-
 static int slave_configure(struct scsi_device *sdev)
 {
 	struct us_data *us = (struct us_data *) sdev->host->hostdata[0];
@@ -98,60 +78,24 @@
 	 * the end, scatter-gather buffers follow page boundaries. */
 	blk_queue_dma_alignment(sdev->request_queue, (512 - 1));
 
-	/* According to the technical support people at Genesys Logic,
-	 * devices using their chips have problems transferring more than
-	 * 32 KB at a time.  In practice people have found that 64 KB
-	 * works okay and that's what Windows does.  But we'll be
-	 * conservative; people can always use the sysfs interface to
-	 * increase max_sectors. */
-	if (us->pusb_dev->descriptor.idVendor == USB_VENDOR_ID_GENESYS &&
-			sdev->request_queue->max_sectors > 64)
-		blk_queue_max_sectors(sdev->request_queue, 64);
-
-	/* We can't put these settings in slave_alloc() because that gets
-	 * called before the device type is known.  Consequently these
-	 * settings can't be overridden via the scsi devinfo mechanism. */
-	if (sdev->type == TYPE_DISK) {
-
-		/* Disk-type devices use MODE SENSE(6) if the protocol
-		 * (SubClass) is Transparent SCSI, otherwise they use
-		 * MODE SENSE(10). */
-		if (us->subclass != US_SC_SCSI)
-			sdev->use_10_for_ms = 1;
-
-		/* Many disks only accept MODE SENSE transfer lengths of
-		 * 192 bytes (that's what Windows uses). */
-		sdev->use_192_bytes_for_3f = 1;
-
-		/* A number of devices have problems with MODE SENSE for
-		 * page x08, so we will skip it. */
-		sdev->skip_ms_page_8 = 1;
-
-#ifndef CONFIG_USB_STORAGE_RW_DETECT
-		/* Some devices may not like MODE SENSE with page=0x3f.
-		 * Now that we're using 192-byte transfers this may no
-		 * longer be a problem.  So this will be a configuration
-		 * option. */
-		sdev->skip_ms_page_3f = 1;
-#endif
+	/* Devices using Genesys Logic chips cause a lot of trouble for
+	 * high-speed transfers; they die unpredictably when given more
+	 * than 64 KB of data at a time.  If we detect such a device,
+	 * reduce the maximum transfer size to 64 KB = 128 sectors. */
 
-	} else {
-
-		/* Non-disk-type devices don't need to blacklist any pages
-		 * or to force 192-byte transfer lengths for MODE SENSE.
-		 * But they do need to use MODE SENSE(10). */
-		sdev->use_10_for_ms = 1;
-	}
+#define USB_VENDOR_ID_GENESYS	0x05e3		// Needs a standard location
+	if (us->pusb_dev->descriptor.idVendor == USB_VENDOR_ID_GENESYS &&
+			us->pusb_dev->speed == USB_SPEED_HIGH)
+		blk_queue_max_sectors(sdev->request_queue, 128);
 
-	/* this is to satisfy the compiler, tho I don't think the 
+	/* this is to satisify the compiler, tho I don't think the 
 	 * return code is ever checked anywhere. */
 	return 0;
 }
 
 /* queue a command */
 /* This is always called with scsi_lock(srb->host) held */
-static int queuecommand(struct scsi_cmnd *srb,
-			void (*done)(struct scsi_cmnd *))
+static int queuecommand( Scsi_Cmnd *srb , void (*done)(Scsi_Cmnd *))
 {
 	struct us_data *us = (struct us_data *)srb->device->host->hostdata[0];
 
@@ -181,7 +125,7 @@
 
 /* Command abort */
 /* This is always called with scsi_lock(srb->host) held */
-static int command_abort(struct scsi_cmnd *srb )
+static int command_abort( Scsi_Cmnd *srb )
 {
 	struct Scsi_Host *host = srb->device->host;
 	struct us_data *us = (struct us_data *) host->hostdata[0];
@@ -228,7 +172,7 @@
 /* This invokes the transport reset mechanism to reset the state of the
  * device */
 /* This is always called with scsi_lock(srb->host) held */
-static int device_reset(struct scsi_cmnd *srb)
+static int device_reset( Scsi_Cmnd *srb )
 {
 	struct us_data *us = (struct us_data *)srb->device->host->hostdata[0];
 	int result;
@@ -263,7 +207,7 @@
 /* It refuses to work if there's more than one interface in
  * the device, so that other users are not affected. */
 /* This is always called with scsi_lock(srb->host) held */
-static int bus_reset(struct scsi_cmnd *srb)
+static int bus_reset( Scsi_Cmnd *srb )
 {
 	struct us_data *us = (struct us_data *)srb->device->host->hostdata[0];
 	int result;
@@ -436,7 +380,6 @@
 	/* unknown initiator id */
 	.this_id =			-1,
 
-	.slave_alloc =			slave_alloc,
 	.slave_configure =		slave_configure,
 
 	/* lots of sg segments can be handled */
@@ -449,17 +392,18 @@
 	 * periodically someone should test to see which setting is more
 	 * optimal.
 	 */
-	.use_clustering =		1,
+	.use_clustering =		TRUE,
 
 	/* emulated HBA */
-	.emulated =			1,
-
-	/* we do our own delay after a device or bus reset */
-	.skip_settle_delay =		1,
+	.emulated =			TRUE,
 
 	/* sysfs device attributes */
 	.sdev_attrs =			sysfs_device_attr_list,
 
+	/* modify scsi_device bits on probe */
+//	.flags = (BLIST_MS_SKIP_PAGE_08 | BLIST_MS_SKIP_PAGE_3F |
+//		  BLIST_USE_10_BYTE_MS),
+
 	/* module management */
 	.module =			THIS_MODULE
 };
diff -Naur linuxppc-2.6.9/drivers/usb/storage/scsiglue.h linuxppc-2.6.9-dream/drivers/usb/storage/scsiglue.h
--- linuxppc-2.6.9/drivers/usb/storage/scsiglue.h	2004-10-18 23:54:31.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/scsiglue.h	2005-09-19 21:40:06.000000000 +0200
@@ -41,15 +41,17 @@
 #ifndef _SCSIGLUE_H_
 #define _SCSIGLUE_H_
 
-#include <scsi/scsi_host.h>
-
-struct us_data;
-struct scsi_cmnd;
+#include <linux/blkdev.h>
+#include "scsi.h"
+#include "hosts.h"
+#include "usb.h"
 
 extern void usb_stor_report_device_reset(struct us_data *us);
 
 extern unsigned char usb_stor_sense_notready[18];
 extern unsigned char usb_stor_sense_invalidCDB[18];
 extern struct scsi_host_template usb_stor_host_template;
+extern int usb_stor_scsiSense10to6(Scsi_Cmnd*);
+extern int usb_stor_scsiSense6to10(Scsi_Cmnd*);
 
 #endif
diff -Naur linuxppc-2.6.9/drivers/usb/storage/sddr09.c linuxppc-2.6.9-dream/drivers/usb/storage/sddr09.c
--- linuxppc-2.6.9/drivers/usb/storage/sddr09.c	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/sddr09.c	2005-09-19 21:40:06.000000000 +0200
@@ -41,19 +41,16 @@
  * EF: compute checksum (?)
  */
 
-#include <linux/sched.h>
-#include <linux/errno.h>
-#include <linux/slab.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-
 #include "transport.h"
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
 #include "sddr09.h"
 
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
 
 #define short_pack(lsb,msb) ( ((u16)(lsb)) | ( ((u16)(msb))<<8 ) )
 #define LSB_of(s) ((s)&0xFF)
@@ -1092,7 +1089,7 @@
 	if (result != USB_STOR_TRANSPORT_GOOD) {
 		US_DEBUGP("Result of read_deviceID is %d\n", result);
 		printk("sddr09: could not read card info\n");
-		return NULL;
+		return 0;
 	}
 
 	sprintf(blurbtxt, "sddr09: Found Flash card, ID = %02X %02X %02X %02X",
@@ -1404,7 +1401,7 @@
 /*
  * Transport for the Sandisk SDDR-09
  */
-int sddr09_transport(struct scsi_cmnd *srb, struct us_data *us)
+int sddr09_transport(Scsi_Cmnd *srb, struct us_data *us)
 {
 	static unsigned char sensekey = 0, sensecode = 0;
 	static unsigned char havefakesense = 0;
@@ -1489,11 +1486,11 @@
 
 		capacity = (info->lbact << info->blockshift) - 1;
 
-		((__be32 *) ptr)[0] = cpu_to_be32(capacity);
+		((u32 *) ptr)[0] = cpu_to_be32(capacity);
 
 		// Report page size
 
-		((__be32 *) ptr)[1] = cpu_to_be32(info->pagesize);
+		((u32 *) ptr)[1] = cpu_to_be32(info->pagesize);
 		usb_stor_set_xfer_buf(ptr, 8, srb);
 
 		return USB_STOR_TRANSPORT_GOOD;
@@ -1510,7 +1507,7 @@
 				  "mode page 0x%x\n", modepage);
 
 			memcpy(ptr, mode_page_01, sizeof(mode_page_01));
-			((__be16*)ptr)[0] = cpu_to_be16(sizeof(mode_page_01) - 2);
+			((u16*)ptr)[0] = cpu_to_be16(sizeof(mode_page_01) - 2);
 			ptr[3] = (info->flags & SDDR09_WP) ? 0x80 : 0;
 			usb_stor_set_xfer_buf(ptr, sizeof(mode_page_01), srb);
 			return USB_STOR_TRANSPORT_GOOD;
@@ -1584,13 +1581,13 @@
 	if (srb->request_bufflen == 0)
 		return USB_STOR_TRANSPORT_GOOD;
 
-	if (srb->sc_data_direction == DMA_TO_DEVICE ||
-	    srb->sc_data_direction == DMA_FROM_DEVICE) {
-		unsigned int pipe = (srb->sc_data_direction == DMA_TO_DEVICE)
+	if (srb->sc_data_direction == SCSI_DATA_WRITE ||
+	    srb->sc_data_direction == SCSI_DATA_READ) {
+		unsigned int pipe = (srb->sc_data_direction == SCSI_DATA_WRITE)
 				? us->send_bulk_pipe : us->recv_bulk_pipe;
 
 		US_DEBUGP("SDDR09: %s %d bytes\n",
-			  (srb->sc_data_direction == DMA_TO_DEVICE) ?
+			  (srb->sc_data_direction == SCSI_DATA_WRITE) ?
 			  "sending" : "receiving",
 			  srb->request_bufflen);
 
diff -Naur linuxppc-2.6.9/drivers/usb/storage/sddr09.h linuxppc-2.6.9-dream/drivers/usb/storage/sddr09.h
--- linuxppc-2.6.9/drivers/usb/storage/sddr09.h	2004-10-18 23:53:43.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/sddr09.h	2005-09-19 21:40:06.000000000 +0200
@@ -29,7 +29,7 @@
 
 /* Sandisk SDDR-09 stuff */
 
-extern int sddr09_transport(struct scsi_cmnd *srb, struct us_data *us);
+extern int sddr09_transport(Scsi_Cmnd *srb, struct us_data *us);
 
 struct sddr09_card_info {
 	unsigned long	capacity;	/* Size of card in bytes */
diff -Naur linuxppc-2.6.9/drivers/usb/storage/sddr55.c linuxppc-2.6.9-dream/drivers/usb/storage/sddr55.c
--- linuxppc-2.6.9/drivers/usb/storage/sddr55.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/sddr55.c	2005-09-19 21:40:06.000000000 +0200
@@ -24,19 +24,15 @@
  * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include <linux/jiffies.h>
-#include <linux/errno.h>
-#include <linux/slab.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-
 #include "transport.h"
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
 #include "sddr55.h"
 
+#include <linux/jiffies.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
 
 #define short_pack(lsb,msb) ( ((u16)(lsb)) | ( ((u16)(msb))<<8 ) )
 #define LSB_of(s) ((s)&0xFF)
@@ -78,7 +74,7 @@
 sddr55_bulk_transport(struct us_data *us, int direction,
 		      unsigned char *data, unsigned int len) {
 	struct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;
-	unsigned int pipe = (direction == DMA_FROM_DEVICE) ?
+	unsigned int pipe = (direction == SCSI_DATA_READ) ?
 			us->recv_bulk_pipe : us->send_bulk_pipe;
 
 	if (!len)
@@ -103,7 +99,7 @@
 	command[5] = 0xB0;
 	command[7] = 0x80;
 	result = sddr55_bulk_transport(us,
-		DMA_TO_DEVICE, command, 8);
+		SCSI_DATA_WRITE, command, 8);
 
 	US_DEBUGP("Result for send_command in status %d\n",
 		result);
@@ -114,7 +110,7 @@
 	}
 
 	result = sddr55_bulk_transport(us,
-		DMA_FROM_DEVICE, status,	4);
+		SCSI_DATA_READ, status,	4);
 
 	/* expect to get short transfer if no card fitted */
 	if (result == USB_STOR_XFER_SHORT || result == USB_STOR_XFER_STALLED) {
@@ -143,7 +139,7 @@
 
 	/* now read status */
 	result = sddr55_bulk_transport(us,
-		DMA_FROM_DEVICE, status,	2);
+		SCSI_DATA_READ, status,	2);
 
 	if (result != USB_STOR_XFER_GOOD) {
 		set_sense_info (4, 0, 0);	/* hardware error */
@@ -219,7 +215,7 @@
 
 			/* send command */
 			result = sddr55_bulk_transport(us,
-				DMA_TO_DEVICE, command, 8);
+				SCSI_DATA_WRITE, command, 8);
 
 			US_DEBUGP("Result for send_command in read_data %d\n",
 				result);
@@ -231,7 +227,7 @@
 
 			/* read data */
 			result = sddr55_bulk_transport(us,
-				DMA_FROM_DEVICE, buffer, len);
+				SCSI_DATA_READ, buffer, len);
 
 			if (result != USB_STOR_XFER_GOOD) {
 				result = USB_STOR_TRANSPORT_ERROR;
@@ -240,7 +236,7 @@
 
 			/* now read status */
 			result = sddr55_bulk_transport(us,
-				DMA_FROM_DEVICE, status, 2);
+				SCSI_DATA_READ, status, 2);
 
 			if (result != USB_STOR_XFER_GOOD) {
 				result = USB_STOR_TRANSPORT_ERROR;
@@ -394,7 +390,7 @@
 
 		/* send command */
 		result = sddr55_bulk_transport(us,
-			DMA_TO_DEVICE, command, 8);
+			SCSI_DATA_WRITE, command, 8);
 
 		if (result != USB_STOR_XFER_GOOD) {
 			US_DEBUGP("Result for send_command in write_data %d\n",
@@ -408,7 +404,7 @@
 
 		/* send the data */
 		result = sddr55_bulk_transport(us,
-			DMA_TO_DEVICE, buffer, len);
+			SCSI_DATA_WRITE, buffer, len);
 
 		if (result != USB_STOR_XFER_GOOD) {
 			US_DEBUGP("Result for send_data in write_data %d\n",
@@ -421,7 +417,7 @@
 		}
 
 		/* now read status */
-		result = sddr55_bulk_transport(us, DMA_FROM_DEVICE, status, 6);
+		result = sddr55_bulk_transport(us, SCSI_DATA_READ, status, 6);
 
 		if (result != USB_STOR_XFER_GOOD) {
 			US_DEBUGP("Result for get_status in write_data %d\n",
@@ -487,7 +483,7 @@
 	memset(command, 0, 8);
 	command[5] = 0xB0;
 	command[7] = 0x84;
-	result = sddr55_bulk_transport(us, DMA_TO_DEVICE, command, 8);
+	result = sddr55_bulk_transport(us, SCSI_DATA_WRITE, command, 8);
 
 	US_DEBUGP("Result of send_control for device ID is %d\n",
 		result);
@@ -496,7 +492,7 @@
 		return USB_STOR_TRANSPORT_ERROR;
 
 	result = sddr55_bulk_transport(us,
-		DMA_FROM_DEVICE, content, 4);
+		SCSI_DATA_READ, content, 4);
 
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_ERROR;
@@ -506,7 +502,7 @@
 
 	if (content[0] != 0xff)	{
     		result = sddr55_bulk_transport(us,
-			DMA_FROM_DEVICE, content, 2);
+			SCSI_DATA_READ, content, 2);
 	}
 
 	return USB_STOR_TRANSPORT_GOOD;
@@ -628,21 +624,21 @@
 	command[6] = numblocks * 2 / 256;
 	command[7] = 0x8A;
 
-	result = sddr55_bulk_transport(us, DMA_TO_DEVICE, command, 8);
+	result = sddr55_bulk_transport(us, SCSI_DATA_WRITE, command, 8);
 
 	if ( result != USB_STOR_XFER_GOOD) {
 		kfree (buffer);
 		return -1;
 	}
 
-	result = sddr55_bulk_transport(us, DMA_FROM_DEVICE, buffer, numblocks * 2);
+	result = sddr55_bulk_transport(us, SCSI_DATA_READ, buffer, numblocks * 2);
 
 	if ( result != USB_STOR_XFER_GOOD) {
 		kfree (buffer);
 		return -1;
 	}
 
-	result = sddr55_bulk_transport(us, DMA_FROM_DEVICE, command, 2);
+	result = sddr55_bulk_transport(us, SCSI_DATA_READ, command, 2);
 
 	if ( result != USB_STOR_XFER_GOOD) {
 		kfree (buffer);
@@ -738,7 +734,7 @@
 /*
  * Transport for the Sandisk SDDR-55
  */
-int sddr55_transport(struct scsi_cmnd *srb, struct us_data *us)
+int sddr55_transport(Scsi_Cmnd *srb, struct us_data *us)
 {
 	int result;
 	static unsigned char inquiry_response[8] = {
@@ -838,8 +834,8 @@
 		capacity /= PAGESIZE;
 		capacity--;
 
-		((__be32 *) ptr)[0] = cpu_to_be32(capacity);
-		((__be32 *) ptr)[1] = cpu_to_be32(PAGESIZE);
+		((u32 *) ptr)[0] = cpu_to_be32(capacity);
+		((u32 *) ptr)[1] = cpu_to_be32(PAGESIZE);
 		usb_stor_set_xfer_buf(ptr, 8, srb);
 
 		sddr55_read_map(us);
diff -Naur linuxppc-2.6.9/drivers/usb/storage/sddr55.h linuxppc-2.6.9-dream/drivers/usb/storage/sddr55.h
--- linuxppc-2.6.9/drivers/usb/storage/sddr55.h	2004-10-18 23:54:40.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/sddr55.h	2005-09-19 21:40:06.000000000 +0200
@@ -28,7 +28,7 @@
 
 /* Sandisk SDDR-55 stuff */
 
-extern int sddr55_transport(struct scsi_cmnd *srb, struct us_data *us);
+extern int sddr55_transport(Scsi_Cmnd *srb, struct us_data *us);
 extern int sddr55_reset(struct us_data *us);
 
 #endif
diff -Naur linuxppc-2.6.9/drivers/usb/storage/shuttle_usbat.c linuxppc-2.6.9-dream/drivers/usb/storage/shuttle_usbat.c
--- linuxppc-2.6.9/drivers/usb/storage/shuttle_usbat.c	2004-10-18 23:53:06.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/shuttle_usbat.c	2005-09-19 21:40:06.000000000 +0200
@@ -39,31 +39,27 @@
  * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include <linux/sched.h>
-#include <linux/errno.h>
-#include <linux/slab.h>
-#include <linux/cdrom.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-
 #include "transport.h"
 #include "protocol.h"
 #include "usb.h"
 #include "debug.h"
 #include "shuttle_usbat.h"
 
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+
 #define short_pack(LSB,MSB) ( ((u16)(LSB)) | ( ((u16)(MSB))<<8 ) )
 #define LSB_of(s) ((s)&0xFF)
 #define MSB_of(s) ((s)>>8)
 
 int transferred = 0;
 
-static int usbat_read(struct us_data *us,
-		      unsigned char access,
-		      unsigned char reg,
-		      unsigned char *content)
-{
+int usbat_read(struct us_data *us,
+	     unsigned char access,
+	     unsigned char reg, 
+	     unsigned char *content) {
+
 	int result;
 
 	result = usb_stor_ctrl_transfer(us,
@@ -78,11 +74,11 @@
 	return result;
 }
 
-static int usbat_write(struct us_data *us,
-		       unsigned char access,
-		       unsigned char reg,
-		       unsigned char content)
-{
+int usbat_write(struct us_data *us,
+	     unsigned char access,
+	     unsigned char reg, 
+	     unsigned char content) {
+
 	int result;
 
 	result = usb_stor_ctrl_transfer(us,
@@ -97,14 +93,14 @@
 	return result;
 }
 
-static int usbat_set_shuttle_features(struct us_data *us,
-				      unsigned char external_trigger,
-				      unsigned char epp_control,
-				      unsigned char mask_byte,
-				      unsigned char test_pattern,
-				      unsigned char subcountH,
-				      unsigned char subcountL)
-{
+int usbat_set_shuttle_features(struct us_data *us,
+	     unsigned char external_trigger,
+	     unsigned char epp_control, 
+	     unsigned char mask_byte, 
+	     unsigned char test_pattern, 
+	     unsigned char subcountH, 
+	     unsigned char subcountL) {
+
 	int result;
 	unsigned char *command = us->iobuf;
 
@@ -129,13 +125,13 @@
 	return result;
 }
 
-static int usbat_read_block(struct us_data *us,
-			    unsigned char access,
-			    unsigned char reg,
-			    unsigned char *content,
-			    unsigned short len,
-			    int use_sg)
-{
+int usbat_read_block(struct us_data *us,
+	     unsigned char access,
+	     unsigned char reg, 
+	     unsigned char *content,
+	     unsigned short len,
+	     int use_sg) {
+
 	int result;
 	unsigned char *command = us->iobuf;
 
@@ -175,8 +171,8 @@
  * an error condition.
  */
 
-static int usbat_wait_not_busy(struct us_data *us, int minutes)
-{
+int usbat_wait_not_busy(struct us_data *us, int minutes) {
+
 	int i;
 	int result;
 	unsigned char *status = us->iobuf;
@@ -206,13 +202,13 @@
 		}
 
 		if (i<500)
-			msleep(10); // 5 seconds
+			wait_ms(10); // 5 seconds
 		else if (i<700)
-			msleep(50); // 10 seconds
+			wait_ms(50); // 10 seconds
 		else if (i<1200)
-			msleep(100); // 50 seconds
+			wait_ms(100); // 50 seconds
 		else
-			msleep(1000); // X minutes
+			wait_ms(1000); // X minutes
 	}
 
 	US_DEBUGP("Waited not busy for %d minutes, timing out.\n",
@@ -220,13 +216,14 @@
 	return USB_STOR_TRANSPORT_FAILED;
 }
 
-static int usbat_write_block(struct us_data *us,
-			     unsigned char access, 
-			     unsigned char reg,
-			     unsigned char *content,
-			     unsigned short len,
-			     int use_sg, int minutes)
-{
+int usbat_write_block(struct us_data *us,
+	     unsigned char access,
+	     unsigned char reg, 
+	     unsigned char *content,
+	     unsigned short len,
+	     int use_sg,
+	     int minutes) {
+
 	int result;
 	unsigned char *command = us->iobuf;
 
@@ -263,23 +260,23 @@
 	return usbat_wait_not_busy(us, minutes);
 }
 
-static int usbat_rw_block_test(struct us_data *us,
-			       unsigned char access,
-			       unsigned char *registers,
-			       unsigned char *data_out,
-			       unsigned short num_registers,
-			       unsigned char data_reg,
-			       unsigned char status_reg,
-			       unsigned char timeout,
-			       unsigned char qualifier,
-			       int direction,
-			       unsigned char *content,
-			       unsigned short len,
-			       int use_sg,
-			       int minutes)
-{
+int usbat_rw_block_test(struct us_data *us,
+	     unsigned char access,
+	     unsigned char *registers,
+	     unsigned char *data_out,
+	     unsigned short num_registers,
+	     unsigned char data_reg, 
+	     unsigned char status_reg, 
+	     unsigned char timeout, 
+	     unsigned char qualifier, 
+	     int direction,
+	     unsigned char *content,
+	     unsigned short len,
+	     int use_sg,
+	     int minutes) {
+
 	int result;
-	unsigned int pipe = (direction == DMA_FROM_DEVICE) ?
+	unsigned int pipe = (direction == SCSI_DATA_READ) ?
 			us->recv_bulk_pipe : us->send_bulk_pipe;
 
 	// Not really sure the 0x07, 0x17, 0xfc, 0xe7 is necessary here,
@@ -319,9 +316,9 @@
 		} else
 			cmdlen = 8;
 
-		command[cmdlen-8] = (direction==DMA_TO_DEVICE ? 0x40 : 0xC0);
+		command[cmdlen-8] = (direction==SCSI_DATA_WRITE ? 0x40 : 0xC0);
 		command[cmdlen-7] = access |
-				(direction==DMA_TO_DEVICE ? 0x05 : 0x04);
+				(direction==SCSI_DATA_WRITE ? 0x05 : 0x04);
 		command[cmdlen-6] = data_reg;
 		command[cmdlen-5] = status_reg;
 		command[cmdlen-4] = timeout;
@@ -359,7 +356,7 @@
 
 
 		//US_DEBUGP("Transfer %s %d bytes, sg buffers %d\n",
-		//	direction == DMA_TO_DEVICE ? "out" : "in",
+		//	direction == SCSI_DATA_WRITE ? "out" : "in",
 		//	len, use_sg);
 
 		result = usb_stor_bulk_transfer_sg(us,
@@ -392,7 +389,7 @@
 			 * the bulk output pipe only the first time.
 			 */
 
-			if (direction==DMA_FROM_DEVICE && i==0) {
+			if (direction==SCSI_DATA_READ && i==0) {
 				if (usb_stor_clear_halt(us,
 						us->send_bulk_pipe) < 0)
 					return USB_STOR_TRANSPORT_ERROR;
@@ -403,7 +400,7 @@
 			 */
 
  			result = usbat_read(us, USBAT_ATA, 
-				direction==DMA_TO_DEVICE ? 0x17 : 0x0E, 
+				direction==SCSI_DATA_WRITE ? 0x17 : 0x0E, 
 				status);
 
 			if (result!=USB_STOR_XFER_GOOD)
@@ -414,7 +411,7 @@
 				return USB_STOR_TRANSPORT_FAILED;
 
 			US_DEBUGP("Redoing %s\n",
-			  direction==DMA_TO_DEVICE ? "write" : "read");
+			  direction==SCSI_DATA_WRITE ? "write" : "read");
 
 		} else if (result != USB_STOR_XFER_GOOD)
 			return USB_STOR_TRANSPORT_ERROR;
@@ -424,7 +421,7 @@
 	}
 
 	US_DEBUGP("Bummer! %s bulk data 20 times failed.\n",
-		direction==DMA_TO_DEVICE ? "Writing" : "Reading");
+		direction==SCSI_DATA_WRITE ? "Writing" : "Reading");
 
 	return USB_STOR_TRANSPORT_FAILED;
 }
@@ -434,12 +431,12 @@
  * transfers of data!
  */
 
-static int usbat_multiple_write(struct us_data *us,
-				unsigned char access,
-				unsigned char *registers,
-				unsigned char *data_out,
-				unsigned short num_registers)
-{
+int usbat_multiple_write(struct us_data *us, 
+			unsigned char access,
+			unsigned char *registers,
+			unsigned char *data_out,
+			unsigned short num_registers) {
+
 	int result;
 	unsigned char *data = us->iobuf;
 	int i;
@@ -482,8 +479,9 @@
 	return usbat_wait_not_busy(us, 0);
 }
 
-static int usbat_read_user_io(struct us_data *us, unsigned char *data_flags)
-{
+int usbat_read_user_io(struct us_data *us,
+		unsigned char *data_flags) {
+
 	int result;
 
 	result = usb_stor_ctrl_transfer(us,
@@ -498,10 +496,10 @@
 	return result;
 }
 
-static int usbat_write_user_io(struct us_data *us,
-			       unsigned char enable_flags,
-			       unsigned char data_flags)
-{
+int usbat_write_user_io(struct us_data *us,
+		unsigned char enable_flags,
+		unsigned char data_flags) {
+
 	int result;
 
 	result = usb_stor_ctrl_transfer(us,
@@ -521,11 +519,11 @@
  * a little ( <= 65535 byte) ATAPI pipe
  */
 
-static int usbat_handle_read10(struct us_data *us,
-			       unsigned char *registers,
-			       unsigned char *data,
-			       struct scsi_cmnd *srb)
-{
+int usbat_handle_read10(struct us_data *us,
+		unsigned char *registers,
+		unsigned char *data,
+		Scsi_Cmnd *srb) {
+
 	int result = USB_STOR_TRANSPORT_GOOD;
 	unsigned char *buffer;
 	unsigned int len;
@@ -541,7 +539,7 @@
 		result = usbat_rw_block_test(us, USBAT_ATA, 
 			registers, data, 19,
 			0x10, 0x17, 0xFD, 0x30,
-			DMA_FROM_DEVICE,
+			SCSI_DATA_READ,
 			srb->request_buffer, 
 			srb->request_bufflen, srb->use_sg, 1);
 
@@ -610,7 +608,7 @@
 		result = usbat_rw_block_test(us, USBAT_ATA, 
 			registers, data, 19,
 			0x10, 0x17, 0xFD, 0x30,
-			DMA_FROM_DEVICE,
+			SCSI_DATA_READ,
 			buffer,
 			len, 0, 1);
 
@@ -632,8 +630,8 @@
 	return result;
 }
 
-static int hp_8200e_select_and_test_registers(struct us_data *us)
-{
+static int hp_8200e_select_and_test_registers(struct us_data *us) {
+
 	int selector;
 	unsigned char *status = us->iobuf;
 
@@ -681,8 +679,8 @@
 	return USB_STOR_TRANSPORT_GOOD;
 }
 
-int init_8200e(struct us_data *us)
-{
+int init_8200e(struct us_data *us) {
+
 	int result;
 	unsigned char *status = us->iobuf;
 
@@ -695,7 +693,7 @@
 
 	US_DEBUGP("INIT 1\n");
 
-	msleep(2000);
+	wait_ms(2000);
 
 	if (usbat_read_user_io(us, status) !=
 			USB_STOR_XFER_GOOD)
@@ -729,7 +727,7 @@
 
 	US_DEBUGP("INIT 5\n");
 
-	msleep(250);
+	wait_ms(250);
 
 	// Write 0x80 to ISA port 0x3F
 
@@ -780,7 +778,7 @@
 
 	US_DEBUGP("INIT 12\n");
 
-	msleep(1400);
+	wait_ms(1400);
 
 	if (usbat_read_user_io(us, status) !=
 			USB_STOR_XFER_GOOD)
@@ -807,7 +805,7 @@
 /*
  * Transport for the HP 8200e
  */
-int hp8200e_transport(struct scsi_cmnd *srb, struct us_data *us)
+int hp8200e_transport(Scsi_Cmnd *srb, struct us_data *us)
 {
 	int result;
 	unsigned char *status = us->iobuf;
@@ -851,12 +849,12 @@
 	if (srb->cmnd[0] == TEST_UNIT_READY)
 		transferred = 0;
 
-	if (srb->sc_data_direction == DMA_TO_DEVICE) {
+	if (srb->sc_data_direction == SCSI_DATA_WRITE) {
 
 		result = usbat_rw_block_test(us, USBAT_ATA, 
 			registers, data, 19,
 			0x10, 0x17, 0xFD, 0x30,
-			DMA_TO_DEVICE,
+			SCSI_DATA_WRITE,
 			srb->request_buffer, 
 			len, srb->use_sg, 10);
 
@@ -904,7 +902,7 @@
 	// If there is response data to be read in 
 	// then do it here.
 
-	if (len != 0 && (srb->sc_data_direction == DMA_FROM_DEVICE)) {
+	if (len != 0 && (srb->sc_data_direction == SCSI_DATA_READ)) {
 
 		// How many bytes to read in? Check cylL register
 
diff -Naur linuxppc-2.6.9/drivers/usb/storage/shuttle_usbat.h linuxppc-2.6.9-dream/drivers/usb/storage/shuttle_usbat.h
--- linuxppc-2.6.9/drivers/usb/storage/shuttle_usbat.h	2004-10-18 23:53:13.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/shuttle_usbat.h	2005-09-19 21:40:06.000000000 +0200
@@ -52,8 +52,28 @@
 #define USBAT_UIO_OE0		0x10 // I/O 0 set=output/clr=input
 #define USBAT_UIO_ADPRST	0x01 // Reset SCM chip
 
+/* USBAT-specific commands */
+
+extern int usbat_read(struct us_data *us, unsigned char access,
+	unsigned char reg, unsigned char *content);
+extern int usbat_write(struct us_data *us, unsigned char access,
+	unsigned char reg, unsigned char content);
+extern int usbat_read_block(struct us_data *us, unsigned char access,
+	unsigned char reg, unsigned char *content, unsigned short len,
+	int use_sg);
+extern int usbat_write_block(struct us_data *us, unsigned char access,
+	unsigned char reg, unsigned char *content, unsigned short len,
+	int use_sg, int minutes);
+extern int usbat_multiple_write(struct us_data *us, unsigned char access,
+	unsigned char *registers, unsigned char *data_out,
+	unsigned short num_registers);
+extern int usbat_read_user_io(struct us_data *us, unsigned char *data_flags);
+extern int usbat_write_user_io(struct us_data *us,
+	unsigned char enable_flags, unsigned char data_flags);
+
 /* HP 8200e stuff */
-extern int hp8200e_transport(struct scsi_cmnd *srb, struct us_data *us);
+
+extern int hp8200e_transport(Scsi_Cmnd *srb, struct us_data *us);
 extern int init_8200e(struct us_data *us);
 
 #endif
diff -Naur linuxppc-2.6.9/drivers/usb/storage/transport.c linuxppc-2.6.9-dream/drivers/usb/storage/transport.c
--- linuxppc-2.6.9/drivers/usb/storage/transport.c	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/transport.c	2005-09-19 21:40:20.000000000 +0200
@@ -46,20 +46,15 @@
  */
 
 #include <linux/config.h>
-#include <linux/sched.h>
-#include <linux/errno.h>
-#include <linux/slab.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_device.h>
-
 #include "transport.h"
 #include "protocol.h"
 #include "scsiglue.h"
 #include "usb.h"
 #include "debug.h"
 
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
 
 /***********************************************************************
  * Data transfer routines
@@ -261,11 +256,12 @@
 		endp |= USB_DIR_IN;
 
 	result = usb_stor_control_msg(us, us->send_ctrl_pipe,
-		USB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT,
-		USB_ENDPOINT_HALT, endp,
-		NULL, 0, 3*HZ);
+		USB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT, 0,
+		endp, NULL, 0, 3*HZ);
 
-	/* reset the endpoint toggle */
+	/* reset the toggles and endpoint flags */
+	usb_endpoint_running(us->pusb_dev, usb_pipeendpoint(pipe),
+		usb_pipeout(pipe));
 	usb_settoggle(us->pusb_dev, usb_pipeendpoint(pipe),
 		usb_pipeout(pipe), 0);
 
@@ -525,7 +521,7 @@
  * This is used by the protocol layers to actually send the message to
  * the device and receive the response.
  */
-void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
+void usb_stor_invoke_transport(Scsi_Cmnd *srb, struct us_data *us)
 {
 	int need_auto_sense;
 	int result;
@@ -572,7 +568,7 @@
 	 * can signal most data-in errors by stalling the bulk-in pipe.
 	 */
 	if ((us->protocol == US_PR_CB || us->protocol == US_PR_DPCM_USB) &&
-			srb->sc_data_direction != DMA_FROM_DEVICE) {
+			srb->sc_data_direction != SCSI_DATA_READ) {
 		US_DEBUGP("-- CB transport device requiring auto-sense\n");
 		need_auto_sense = 1;
 	}
@@ -632,7 +628,7 @@
 
 		/* set the transfer direction */
 		old_sc_data_direction = srb->sc_data_direction;
-		srb->sc_data_direction = DMA_FROM_DEVICE;
+		srb->sc_data_direction = SCSI_DATA_READ;
 
 		/* use the new buffer we have */
 		old_request_buffer = srb->request_buffer;
@@ -711,12 +707,6 @@
 			srb->sense_buffer[0] = 0x0;
 		}
 	}
-
-	/* Did we transfer less than the minimum amount required? */
-	if (srb->result == SAM_STAT_GOOD &&
-			srb->request_bufflen - srb->resid < srb->underflow)
-		srb->result = (DID_ERROR << 16) | (SUGGEST_RETRY << 24);
-
 	return;
 
 	/* abort processing: the bulk-only transport requires a reset
@@ -752,7 +742,7 @@
  * Control/Bulk/Interrupt transport
  */
 
-int usb_stor_CBI_transport(struct scsi_cmnd *srb, struct us_data *us)
+int usb_stor_CBI_transport(Scsi_Cmnd *srb, struct us_data *us)
 {
 	unsigned int transfer_length = srb->request_bufflen;
 	unsigned int pipe = 0;
@@ -781,7 +771,7 @@
 	/* DATA STAGE */
 	/* transfer the data payload for this command, if one exists*/
 	if (transfer_length) {
-		pipe = srb->sc_data_direction == DMA_FROM_DEVICE ? 
+		pipe = srb->sc_data_direction == SCSI_DATA_READ ? 
 				us->recv_bulk_pipe : us->send_bulk_pipe;
 		result = usb_stor_bulk_transfer_sg(us, pipe,
 					srb->request_buffer, transfer_length,
@@ -852,7 +842,7 @@
 /*
  * Control/Bulk transport
  */
-int usb_stor_CB_transport(struct scsi_cmnd *srb, struct us_data *us)
+int usb_stor_CB_transport(Scsi_Cmnd *srb, struct us_data *us)
 {
 	unsigned int transfer_length = srb->request_bufflen;
 	int result;
@@ -880,7 +870,7 @@
 	/* DATA STAGE */
 	/* transfer the data payload for this command, if one exists*/
 	if (transfer_length) {
-		unsigned int pipe = srb->sc_data_direction == DMA_FROM_DEVICE ? 
+		unsigned int pipe = srb->sc_data_direction == SCSI_DATA_READ ? 
 				us->recv_bulk_pipe : us->send_bulk_pipe;
 		result = usb_stor_bulk_transfer_sg(us, pipe,
 					srb->request_buffer, transfer_length,
@@ -911,39 +901,35 @@
 	int result;
 
 	/* issue the command */
-	us->iobuf[0] = 0;
 	result = usb_stor_control_msg(us, us->recv_ctrl_pipe,
 				 US_BULK_GET_MAX_LUN, 
 				 USB_DIR_IN | USB_TYPE_CLASS | 
 				 USB_RECIP_INTERFACE,
 				 0, us->ifnum, us->iobuf, 1, HZ);
 
-	US_DEBUGP("GetMaxLUN command result is %d, data is %d\n", 
-		  result, us->iobuf[0]);
-
-	/* if we have a successful request, return the result */
-	if (result >= 0)
-		return us->iobuf[0];
-
 	/* 
 	 * Some devices (i.e. Iomega Zip100) need this -- apparently
 	 * the bulk pipes get STALLed when the GetMaxLUN request is
 	 * processed.   This is, in theory, harmless to all other devices
 	 * (regardless of if they stall or not).
 	 */
-	if (result == -EPIPE) {
+	if (result < 0) {
 		usb_stor_clear_halt(us, us->recv_bulk_pipe);
 		usb_stor_clear_halt(us, us->send_bulk_pipe);
-		/* return the default -- no LUNs */
-		return 0;
 	}
 
-	/* An answer or a STALL are the only valid responses.  If we get
-	 * something else, return an indication of error */
-	return -1;
+	US_DEBUGP("GetMaxLUN command result is %d, data is %d\n", 
+		  result, us->iobuf[0]);
+
+	/* if we have a successful request, return the result */
+	if (result == 1)
+		return us->iobuf[0];
+
+	/* return the default -- no LUNs */
+	return 0;
 }
 
-int usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)
+int usb_stor_Bulk_transport(Scsi_Cmnd *srb, struct us_data *us)
 {
 	struct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;
 	struct bulk_cs_wrap *bcs = (struct bulk_cs_wrap *) us->iobuf;
@@ -956,7 +942,7 @@
 	/* set up the command wrapper */
 	bcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);
 	bcb->DataTransferLength = cpu_to_le32(transfer_length);
-	bcb->Flags = srb->sc_data_direction == DMA_FROM_DEVICE ? 1 << 7 : 0;
+	bcb->Flags = srb->sc_data_direction == SCSI_DATA_READ ? 1 << 7 : 0;
 	bcb->Tag = srb->serial_number;
 	bcb->Lun = srb->device->lun;
 	if (us->flags & US_FL_SCM_MULT_TARG)
@@ -981,14 +967,8 @@
 
 	/* DATA STAGE */
 	/* send/receive data payload, if there is any */
-
-	/* Genesys Logic interface chips need a 100us delay between the
-	 * command phase and the data phase */
-	if (us->pusb_dev->descriptor.idVendor == USB_VENDOR_ID_GENESYS)
-		udelay(100);
-
 	if (transfer_length) {
-		unsigned int pipe = srb->sc_data_direction == DMA_FROM_DEVICE ? 
+		unsigned int pipe = srb->sc_data_direction == SCSI_DATA_READ ? 
 				us->recv_bulk_pipe : us->send_bulk_pipe;
 		result = usb_stor_bulk_transfer_sg(us, pipe,
 					srb->request_buffer, transfer_length,
@@ -1129,11 +1109,11 @@
 		goto Done;
 	}
 
- 	/* Give the device some time to recover from the reset,
- 	 * but don't delay disconnect processing. */
- 	wait_event_interruptible_timeout(us->dev_reset_wait,
- 			test_bit(US_FLIDX_DISCONNECTING, &us->flags),
- 			HZ*6);
+	/* long wait for reset, so unlock to allow disconnects */
+	up(&us->dev_semaphore);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(HZ*6);
+	down(&us->dev_semaphore);
 	if (test_bit(US_FLIDX_DISCONNECTING, &us->flags)) {
 		US_DEBUGP("Reset interrupted by disconnect\n");
 		goto Done;
diff -Naur linuxppc-2.6.9/drivers/usb/storage/transport.h linuxppc-2.6.9-dream/drivers/usb/storage/transport.h
--- linuxppc-2.6.9/drivers/usb/storage/transport.h	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/transport.h	2005-09-19 21:40:06.000000000 +0200
@@ -44,8 +44,7 @@
 #include <linux/config.h>
 #include <linux/blkdev.h>
 #include "usb.h"
-
-struct scsi_cmnd;
+#include "scsi.h"
 
 /* Protocols */
 
@@ -83,9 +82,9 @@
 
 /* command block wrapper */
 struct bulk_cb_wrap {
-	__le32	Signature;		/* contains 'USBC' */
+	__u32	Signature;		/* contains 'USBC' */
 	__u32	Tag;			/* unique per command id */
-	__le32	DataTransferLength;	/* size of data */
+	__u32	DataTransferLength;	/* size of data */
 	__u8	Flags;			/* direction in bit 0 */
 	__u8	Lun;			/* LUN normally 0 */
 	__u8	Length;			/* of of the CDB */
@@ -99,9 +98,9 @@
 
 /* command status wrapper */
 struct bulk_cs_wrap {
-	__le32	Signature;		/* should = 'USBS' */
+	__u32	Signature;		/* should = 'USBS' */
 	__u32	Tag;			/* same as original command */
-	__le32	Residue;		/* amount not transferred */
+	__u32	Residue;		/* amount not transferred */
 	__u8	Status;			/* see below */
 	__u8	Filler[18];
 };
@@ -151,16 +150,16 @@
 
 #define US_CBI_ADSC		0
 
-extern int usb_stor_CBI_transport(struct scsi_cmnd *, struct us_data*);
+extern int usb_stor_CBI_transport(Scsi_Cmnd*, struct us_data*);
 
-extern int usb_stor_CB_transport(struct scsi_cmnd *, struct us_data*);
+extern int usb_stor_CB_transport(Scsi_Cmnd*, struct us_data*);
 extern int usb_stor_CB_reset(struct us_data*);
 
-extern int usb_stor_Bulk_transport(struct scsi_cmnd *, struct us_data*);
+extern int usb_stor_Bulk_transport(Scsi_Cmnd*, struct us_data*);
 extern int usb_stor_Bulk_max_lun(struct us_data*);
 extern int usb_stor_Bulk_reset(struct us_data*);
 
-extern void usb_stor_invoke_transport(struct scsi_cmnd *, struct us_data*);
+extern void usb_stor_invoke_transport(Scsi_Cmnd*, struct us_data*);
 extern void usb_stor_stop_transport(struct us_data*);
 
 extern int usb_stor_control_msg(struct us_data *us, unsigned int pipe,
diff -Naur linuxppc-2.6.9/drivers/usb/storage/unusual_devs.h linuxppc-2.6.9-dream/drivers/usb/storage/unusual_devs.h
--- linuxppc-2.6.9/drivers/usb/storage/unusual_devs.h	2004-10-18 23:54:55.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/unusual_devs.h	2005-09-19 21:40:19.000000000 +0200
@@ -45,6 +45,11 @@
  *
  */
 
+UNUSUAL_DEV(  0x03ee, 0x0000, 0x0000, 0x0245, 
+		"Mitsumi",
+		"CD-R/RW Drive",
+		US_SC_8020, US_PR_CBI, NULL, 0), 
+
 UNUSUAL_DEV(  0x03ee, 0x6901, 0x0000, 0x0100,
 		"Mitsumi",
 		"USB FDD",
@@ -68,16 +73,6 @@
 		US_SC_8070, US_PR_SCM_ATAPI, init_8200e, 0), 
 #endif
 
-/* <torsten.scherer@uni-bielefeld.de>: I don't know the name of the bridge
- * manufacturer, but I've got an external USB drive by the Revoltec company
- * that needs this. otherwise the drive is recognized as /dev/sda, but any
- * access to it blocks indefinitely.
- */
-UNUSUAL_DEV(  0x0402, 0x5621, 0x0103, 0x0103,
-		"Revoltec",
-		"USB/IDE Bridge (ATA/ATAPI)",
-		US_SC_DEVICE, US_PR_DEVICE, NULL, US_FL_FIX_INQUIRY),
-
 /* Deduced by Jonathan Woithe <jwoithe@physics.adelaide.edu.au>
  * Entry needed for flags: US_FL_FIX_INQUIRY because initial inquiry message
  * always fails and confuses drive.
@@ -95,12 +90,6 @@
  		US_SC_SCSI, US_PR_DPCM_USB, NULL, 0 ),
 #endif
 
-/* Patch submitted by Alessandro Fracchetti <al.fracchetti@tin.it> */
-UNUSUAL_DEV(  0x0482, 0x0105, 0x0100, 0x0100,
-		"Kyocera",
-		"Finecam L3",
-		US_SC_SCSI, US_PR_BULK, NULL, US_FL_FIX_INQUIRY),
-
 /* Patch submitted by Philipp Friedrich <philipp@void.at> */
 UNUSUAL_DEV(  0x0482, 0x0100, 0x0100, 0x0100,
 		"Kyocera",
@@ -171,7 +160,7 @@
 UNUSUAL_DEV(  0x04da, 0x0901, 0x0100, 0x0200,
 		"Panasonic",
 		"LS-120 Camera",
-		US_SC_UFI, US_PR_DEVICE, NULL, 0),
+		US_SC_UFI, US_PR_CBI, NULL, 0),
 
 /* From Yukihiro Nakai, via zaitcev@yahoo.com.
  * This is needed for CB instead of CBI */
@@ -212,7 +201,7 @@
 UNUSUAL_DEV(  0x04e6, 0x0006, 0x0100, 0x0205, 
 		"Shuttle",
 		"eUSB MMC Adapter",
-		US_SC_SCSI, US_PR_DEVICE, NULL, 
+		US_SC_SCSI, US_PR_CB, NULL, 
 		US_FL_SINGLE_LUN), 
 
 UNUSUAL_DEV(  0x04e6, 0x0007, 0x0100, 0x0200, 
@@ -284,7 +273,7 @@
 UNUSUAL_DEV(  0x054c, 0x0025, 0x0100, 0x0100, 
 		"Sony",
 		"Memorystick NW-MS7",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_SC_UFI, US_PR_CB, NULL,
 		US_FL_SINGLE_LUN ),
 
 #ifdef CONFIG_USB_STORAGE_ISD200
@@ -308,13 +297,6 @@
 		US_SC_SCSI, US_PR_DEVICE, NULL,
 		US_FL_SINGLE_LUN | US_FL_MODE_XLATE),
 
-/* Submitted by Rajesh Kumble Nayak <nayak@obs-nice.fr> */
-UNUSUAL_DEV(  0x054c, 0x002e, 0x0500, 0x0500, 
-		"Sony",
-		"Handycam HC-85",
-		US_SC_UFI, US_PR_DEVICE, NULL,
-		US_FL_SINGLE_LUN | US_FL_MODE_XLATE),
-
 UNUSUAL_DEV(  0x054c, 0x0032, 0x0000, 0x9999,
 		"Sony",
 		"Memorystick MSC-U01N",
@@ -340,21 +322,6 @@
 		"PEG Mass Storage",
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_INQUIRY ),
-
-/* Submitted by Mike Alborn <malborn@deandra.homeip.net> */
-UNUSUAL_DEV(  0x054c, 0x016a, 0x0000, 0x9999,
-		"Sony",
-		"PEG Mass Storage",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_INQUIRY ),
-		
-/* Submitted by Frank Engel <frankie@cse.unsw.edu.au> */
-UNUSUAL_DEV(  0x054c, 0x0099, 0x0000, 0x9999,
-                "Sony",
-                "PEG Mass Storage",
-                US_SC_DEVICE, US_PR_DEVICE, NULL,
-                US_FL_FIX_INQUIRY ),
-
 		
 UNUSUAL_DEV(  0x057b, 0x0000, 0x0000, 0x0299, 
 		"Y-E Data",
@@ -368,36 +335,17 @@
 		US_SC_DEVICE,  US_PR_DEVICE, NULL,
 		US_FL_SINGLE_LUN),
 
-/* Reported by Johann Cardon <johann.cardon@free.fr>
- * This entry is needed only because the device reports
- * bInterfaceClass = 0xff (vendor-specific)
- */
-UNUSUAL_DEV(  0x057b, 0x0022, 0x0000, 0x9999, 
-		"Y-E Data",
-		"Silicon Media R/W",
-		US_SC_DEVICE, US_PR_DEVICE, NULL, 0),
-
 /* Fabrizio Fellini <fello@libero.it> */
 UNUSUAL_DEV(  0x0595, 0x4343, 0x0000, 0x2210,
 		"Fujifilm",
 		"Digital Camera EX-20 DSC",
-		US_SC_8070, US_PR_DEVICE, NULL, 0 ),
+		US_SC_8070, US_PR_CBI, NULL, 0 ),
 
 UNUSUAL_DEV(  0x059f, 0xa601, 0x0200, 0x0200, 
 		"LaCie",
 		"USB Hard Disk",
 		US_SC_RBC, US_PR_CB, NULL, 0 ), 
 
-/* Submitted by Joel Bourquard <numlock@freesurf.ch>
- * Some versions of this device need the SubClass and Protocol overrides
- * while others don't.
- */
-UNUSUAL_DEV(  0x05ab, 0x0060, 0x1104, 0x1110,
-		"In-System",
-		"PyroGate External CD-ROM Enclosure (FCD-523)",
-		US_SC_SCSI, US_PR_BULK, NULL,
-		US_FL_NEED_OVERRIDE ),
-
 #ifdef CONFIG_USB_STORAGE_ISD200
 UNUSUAL_DEV(  0x05ab, 0x0031, 0x0100, 0x0110,
 		"In-System",
@@ -428,15 +376,15 @@
 UNUSUAL_DEV(  0x05dc, 0x0001, 0x0000, 0x0001,
 		"Lexar",
 		"Jumpshot USB CF Reader",
-		US_SC_SCSI, US_PR_JUMPSHOT, NULL,
-		US_FL_NEED_OVERRIDE | US_FL_MODE_XLATE ),
+		US_SC_DEVICE, US_PR_JUMPSHOT, NULL,
+		US_FL_MODE_XLATE ),
 #endif
 
 /* Reported by Blake Matheny <bmatheny@purdue.edu> */
 UNUSUAL_DEV(  0x05dc, 0xb002, 0x0000, 0x0113,
 		"Lexar",
 		"USB CF Reader",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_SC_SCSI, US_PR_BULK, NULL,
 		US_FL_FIX_INQUIRY ),
 
 /* Reported by Carlos Villegas <cav@uniscope.co.jp>
@@ -444,15 +392,15 @@
  * That is the only reason this entry is needed.
  */
 UNUSUAL_DEV(  0x05e3, 0x0700, 0x0000, 0xffff,
-		"Genesys Logic",
-		"USB to IDE Card Reader",
+		"SIIG",
+		"CompactFlash Card Reader",
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_INQUIRY ),
 
 /* Submitted Alexander Oltu <alexander@all-2.com> */
 UNUSUAL_DEV(  0x05e3, 0x0701, 0x0000, 0xffff, 
-		"Genesys Logic", 
-		"USB to IDE Optical",
+		"", 
+		"USB TO IDE",
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_MODE_XLATE ), 
 
@@ -463,9 +411,16 @@
  *
  * ST818 slim drives (rev 0.02) don't need special care.
 */
-UNUSUAL_DEV(  0x05e3, 0x0702, 0x0000, 0xffff,
-		"Genesys Logic",
-		"USB to IDE Disk",
+UNUSUAL_DEV(  0x05e3, 0x0702, 0x0000, 0x0001,
+		"EagleTec",
+		"External Hard Disk",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_FIX_INQUIRY ),
+
+/* Reported by Henning Schild <henning@wh9.tu-dresden.de> */
+UNUSUAL_DEV(  0x05e3, 0x0702, 0x0113, 0x0113,
+		"EagleTec",
+		"External Hard Disk",
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_INQUIRY ),
 
@@ -490,12 +445,21 @@
 		US_FL_SINGLE_LUN ),
 #endif
 
-/* Reported by Darsen Lu <darsen@micro.ee.nthu.edu.tw> */
-UNUSUAL_DEV( 0x066f, 0x8000, 0x0001, 0x0001,
-		"SigmaTel",
-		"USBMSC Audio Player",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY ),
+/* Following three Minolta cameras reported by Martin Pool
+ * <mbp@sourcefrog.net>.  Originally discovered by Kedar Petankar,
+ * Matthew Geier, Mikael Lofj"ard, Marcel de Boer.
+ */
+UNUSUAL_DEV( 0x0686, 0x4006, 0x0001, 0x0001,
+		"Minolta",
+		"DiMAGE 7",
+		US_SC_SCSI, US_PR_DEVICE, NULL,
+		0 ),
+
+UNUSUAL_DEV( 0x0686, 0x400f, 0x0001, 0x0001,
+		"Minolta",
+		"DiMAGE 7Hi",
+		US_SC_SCSI, US_PR_DEVICE, NULL,
+		0 ),
 
 /* Submitted by Benny Sjostrand <benny@hostmobility.com> */
 UNUSUAL_DEV( 0x0686, 0x4011, 0x0001, 0x0001,
@@ -525,13 +489,11 @@
 		US_SC_SCSI, US_PR_CB, NULL,
 		US_FL_SINGLE_LUN ),
 
-#if !defined(CONFIG_BLK_DEV_UB) && !defined(CONFIG_BLK_DEV_UB_MODULE)
 UNUSUAL_DEV(  0x0781, 0x0002, 0x0009, 0x0009, 
 		"Sandisk",
 		"ImageMate SDDR-31",
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_IGNORE_SER ),
-#endif
 
 UNUSUAL_DEV(  0x0781, 0x0100, 0x0100, 0x0100,
 		"Sandisk",
@@ -669,14 +631,20 @@
  * - Some cameras with idProduct=0x1001 and bcdDevice=0x1000 have
  *   bInterfaceProtocol=0x00 (US_PR_CBI) while others have 0x01 (US_PR_CB).
  *   So don't remove the US_PR_CB override!
- * - Cameras with bcdDevice=0x9009 require the US_SC_8070 override.
  */
-UNUSUAL_DEV( 0x07cf, 0x1001, 0x1000, 0x9999,
+UNUSUAL_DEV( 0x07cf, 0x1001, 0x1000, 0x9009,
 		"Casio",
 		"QV DigitalCamera",
-		US_SC_8070, US_PR_CB, NULL,
+		US_SC_DEVICE, US_PR_CB, NULL,
 		US_FL_NEED_OVERRIDE | US_FL_FIX_INQUIRY ),
 
+/* Later Casio cameras apparently tell the truth */
+UNUSUAL_DEV( 0x07cf, 0x1001, 0x9010, 0x9999,
+		"Casio",
+		"QV DigitalCamera",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_FIX_INQUIRY ),
+
 /* Submitted by Hartmut Wahl <hwahl@hwahl.de>*/
 UNUSUAL_DEV( 0x0839, 0x000a, 0x0001, 0x0001,
 		"Samsung",
@@ -702,7 +670,7 @@
 		"Trumpion",
 		"t33520 USB Flash Card Controller",
 		US_SC_DEVICE, US_PR_BULK, NULL,
-		US_FL_NEED_OVERRIDE | US_FL_MODE_XLATE),
+		US_FL_MODE_XLATE),
 
 /* Trumpion Microelectronics MP3 player (felipe_alfaro@linuxmail.org) */
 UNUSUAL_DEV( 0x090a, 0x1200, 0x0000, 0x9999,
@@ -721,13 +689,13 @@
 UNUSUAL_DEV(  0x097a, 0x0001, 0x0000, 0x0001,
 		"Minds@Work",
 		"Digital Wallet",
- 		US_SC_DEVICE, US_PR_DEVICE, NULL,
+ 		US_SC_SCSI, US_PR_CB, NULL,
 		US_FL_MODE_XLATE ),
 
 UNUSUAL_DEV(  0x0a16, 0x8888, 0x0100, 0x0100,
 		"IBM",
 		"IBM USB Memory Key",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_SC_SCSI, US_PR_BULK, NULL,
 		US_FL_FIX_INQUIRY ),
 
 /* This Pentax still camera is not conformant
@@ -759,21 +727,6 @@
 		0 ),
 #endif
 
-#ifdef CONFIG_USB_STORAGE_DATAFAB
-UNUSUAL_DEV( 0x0c0b, 0xa109, 0x0000, 0xffff,
-	       "Acomdata",
-	       "CF",
-	       US_SC_SCSI, US_PR_DATAFAB, NULL,
-	       US_FL_SINGLE_LUN ),
-#endif
-#ifdef CONFIG_USB_STORAGE_SDDR55
-UNUSUAL_DEV( 0x0c0b, 0xa109, 0x0000, 0xffff,
-	       "Acomdata",
-	       "SM",
-	       US_SC_SCSI, US_PR_SDDR55, NULL,
-	       US_FL_SINGLE_LUN ),
-#endif
-
 /* Submitted by Joris Struyve <joris@struyve.be> */
 UNUSUAL_DEV( 0x0d96, 0x410a, 0x0001, 0xffff,
 		"Medion",
diff -Naur linuxppc-2.6.9/drivers/usb/storage/usb.c linuxppc-2.6.9-dream/drivers/usb/storage/usb.c
--- linuxppc-2.6.9/drivers/usb/storage/usb.c	2004-10-18 23:53:44.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/usb.c	2005-09-19 21:40:19.000000000 +0200
@@ -50,11 +50,6 @@
 #include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/errno.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_device.h>
-
 #include "usb.h"
 #include "scsiglue.h"
 #include "transport.h"
@@ -89,6 +84,8 @@
 
 
 #include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 
@@ -138,9 +135,7 @@
 	{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, US_SC_QIC, US_PR_BULK) },
 	{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, US_SC_UFI, US_PR_BULK) },
 	{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, US_SC_8070, US_PR_BULK) },
-#if !defined(CONFIG_BLK_DEV_UB) && !defined(CONFIG_BLK_DEV_UB_MODULE)
 	{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, US_SC_SCSI, US_PR_BULK) },
-#endif
 
 	/* Terminating entry */
 	{ }
@@ -214,13 +209,11 @@
 	  .useTransport = US_PR_BULK},
 	{ .useProtocol = US_SC_8070,
 	  .useTransport = US_PR_BULK},
-#if !defined(CONFIG_BLK_DEV_UB) && !defined(CONFIG_BLK_DEV_UB_MODULE)
 	{ .useProtocol = US_SC_SCSI,
 	  .useTransport = US_PR_BULK},
-#endif
 
 	/* Terminating entry */
-	{ NULL }
+	{ 0 }
 };
 
 struct usb_driver usb_storage_driver = {
@@ -275,7 +268,6 @@
 static int usb_stor_control_thread(void * __us)
 {
 	struct us_data *us = (struct us_data *)__us;
-	struct Scsi_Host *host = us->host;
 
 	lock_kernel();
 
@@ -293,21 +285,19 @@
 	complete(&(us->notify));
 
 	for(;;) {
+		struct Scsi_Host *host;
 		US_DEBUGP("*** thread sleeping.\n");
 		if(down_interruptible(&us->sema))
 			break;
 			
 		US_DEBUGP("*** thread awakened.\n");
 
-		/* lock the device pointers */
-		down(&(us->dev_semaphore));
-
 		/* if us->srb is NULL, we are being asked to exit */
 		if (us->srb == NULL) {
 			US_DEBUGP("-- exit command received\n");
-			up(&(us->dev_semaphore));
 			break;
 		}
+		host = us->srb->device->host;
 
 		/* lock access to the state */
 		scsi_lock(host);
@@ -318,20 +308,23 @@
 			goto SkipForAbort;
 		}
 
+		/* set the state and release the lock */
+		us->sm_state = US_STATE_RUNNING;
+		scsi_unlock(host);
+
+		/* lock the device pointers */
+		down(&(us->dev_semaphore));
+
 		/* don't do anything if we are disconnecting */
 		if (test_bit(US_FLIDX_DISCONNECTING, &us->flags)) {
 			US_DEBUGP("No command during disconnect\n");
-			goto SkipForDisconnect;
+			us->srb->result = DID_BAD_TARGET << 16;
 		}
 
-		/* set the state and release the lock */
-		us->sm_state = US_STATE_RUNNING;
-		scsi_unlock(host);
-
 		/* reject the command if the direction indicator 
 		 * is UNKNOWN
 		 */
-		if (us->srb->sc_data_direction == DMA_BIDIRECTIONAL) {
+		else if (us->srb->sc_data_direction == SCSI_DATA_UNKNOWN) {
 			US_DEBUGP("UNKNOWN data direction\n");
 			us->srb->result = DID_ERROR << 16;
 		}
@@ -371,6 +364,9 @@
 			us->proto_handler(us->srb, us);
 		}
 
+		/* unlock the device pointers */
+		up(&(us->dev_semaphore));
+
 		/* lock access to the state */
 		scsi_lock(host);
 
@@ -380,7 +376,7 @@
 				   us->srb->result);
 			us->srb->scsi_done(us->srb);
 		} else {
-SkipForAbort:
+			SkipForAbort:
 			US_DEBUGP("scsi command aborted\n");
 		}
 
@@ -393,13 +389,9 @@
 			complete(&(us->notify));
 
 		/* empty the queue, reset the state, and release the lock */
-SkipForDisconnect:
 		us->srb = NULL;
 		us->sm_state = US_STATE_IDLE;
 		scsi_unlock(host);
-
-		/* unlock the device pointers */
-		up(&(us->dev_semaphore));
 	} /* for (;;) */
 
 	/* notify the exit routine that we're actually exiting now 
@@ -432,16 +424,11 @@
 	us->pusb_dev = interface_to_usbdev(intf);
 	us->pusb_intf = intf;
 	us->ifnum = intf->cur_altsetting->desc.bInterfaceNumber;
-	US_DEBUGP("Vendor: 0x%04x, Product: 0x%04x, Revision: 0x%04x\n",
-			us->pusb_dev->descriptor.idVendor,
-			us->pusb_dev->descriptor.idProduct,
-			us->pusb_dev->descriptor.bcdDevice);
-	US_DEBUGP("Interface Subclass: 0x%02x, Protocol: 0x%02x\n",
-			intf->cur_altsetting->desc.bInterfaceSubClass,
-			intf->cur_altsetting->desc.bInterfaceProtocol);
 
-	/* Store our private data in the interface */
+	/* Store our private data in the interface and increment the
+	 * device's reference count */
 	usb_set_intfdata(intf, us);
+	usb_get_dev(us->pusb_dev);
 
 	/* Allocate the device-related DMA-mapped buffers */
 	us->cr = usb_buffer_alloc(us->pusb_dev, sizeof(*us->cr),
@@ -469,6 +456,11 @@
 	struct us_unusual_dev *unusual_dev = &us_unusual_dev_list[id_index];
 	struct usb_device_id *id = &storage_usb_ids[id_index];
 
+	if (unusual_dev->vendorName)
+		US_DEBUGP("Vendor: %s\n", unusual_dev->vendorName);
+	if (unusual_dev->productName)
+		US_DEBUGP("Product: %s\n", unusual_dev->productName);
+
 	/* Store the entries */
 	us->unusual_dev = unusual_dev;
 	us->subclass = (unusual_dev->useProtocol == US_SC_DEVICE) ?
@@ -539,8 +531,6 @@
 	}
 	if (strlen(us->serial) == 0)
 		strcpy(us->serial, "None");
-
-	US_DEBUGP("Vendor: %s,  Product: %s\n", us->vendor, us->product);
 }
 
 /* Get the transport settings */
@@ -728,6 +718,8 @@
 			ep_int = ep;
 		}
 	}
+	US_DEBUGP("Endpoints: In: 0x%p Out: 0x%p Int: 0x%p (Period %d)\n",
+		  ep_in, ep_out, ep_int, ep_int ? ep_int->bInterval : 0);
 
 	if (!ep_in || !ep_out || (us->protocol == US_PR_CBI && !ep_int)) {
 		US_DEBUGP("Endpoint sanity check failed! Rejecting dev.\n");
@@ -764,14 +756,8 @@
 	down(&us->dev_semaphore);
 
 	/* For bulk-only devices, determine the max LUN value */
-	if (us->protocol == US_PR_BULK) {
-		p = usb_stor_Bulk_max_lun(us);
-		if (p < 0) {
-			up(&us->dev_semaphore);
-			return p;
-		}
-		us->max_lun = p;
-	}
+	if (us->protocol == US_PR_BULK)
+		us->max_lun = usb_stor_Bulk_max_lun(us);
 
 	/* Just before we start our control thread, initialize
 	 * the device if it needs initialization */
@@ -780,6 +766,19 @@
 
 	up(&us->dev_semaphore);
 
+	/* Start up our control thread */
+	us->sm_state = US_STATE_IDLE;
+	p = kernel_thread(usb_stor_control_thread, us, CLONE_VM);
+	if (p < 0) {
+		printk(KERN_WARNING USB_STORAGE 
+		       "Unable to start control thread\n");
+		return p;
+	}
+	us->pid = p;
+
+	/* Wait for the thread to start */
+	wait_for_completion(&(us->notify));
+
 	/*
 	 * Since this is a new device, we need to register a SCSI
 	 * host definition with the higher SCSI layers.
@@ -787,61 +786,69 @@
 	us->host = scsi_host_alloc(&usb_stor_host_template, sizeof(us));
 	if (!us->host) {
 		printk(KERN_WARNING USB_STORAGE
-			"Unable to allocate the scsi host\n");
+			"Unable to register the scsi host\n");
 		return -EBUSY;
 	}
 
 	/* Set the hostdata to prepare for scanning */
 	us->host->hostdata[0] = (unsigned long) us;
 
-	/* Start up our control thread */
-	us->sm_state = US_STATE_IDLE;
-	p = kernel_thread(usb_stor_control_thread, us, CLONE_VM);
-	if (p < 0) {
-		printk(KERN_WARNING USB_STORAGE 
-		       "Unable to start control thread\n");
-		return p;
+	return 0;
+}
+
+/* Dissociate from the USB device */
+static void dissociate_dev(struct us_data *us)
+{
+	US_DEBUGP("-- %s\n", __FUNCTION__);
+	down(&us->dev_semaphore);
+
+	/* Free the device-related DMA-mapped buffers */
+	if (us->cr) {
+		usb_buffer_free(us->pusb_dev, sizeof(*us->cr), us->cr,
+				us->cr_dma);
+		us->cr = NULL;
+	}
+	if (us->iobuf) {
+		usb_buffer_free(us->pusb_dev, US_IOBUF_SIZE, us->iobuf,
+				us->iobuf_dma);
+		us->iobuf = NULL;
 	}
-	us->pid = p;
 
-	/* Wait for the thread to start */
-	wait_for_completion(&(us->notify));
+	/* Remove our private data from the interface and decrement the
+	 * device's reference count */
+	usb_set_intfdata(us->pusb_intf, NULL);
+	usb_put_dev(us->pusb_dev);
 
-	return 0;
+	us->pusb_dev = NULL;
+	us->pusb_intf = NULL;
+	up(&us->dev_semaphore);
 }
 
-/* Release all our dynamic resources */
+/* Release all our static and dynamic resources */
 void usb_stor_release_resources(struct us_data *us)
 {
-	US_DEBUGP("-- %s\n", __FUNCTION__);
+	/*
+	 * The host must already have been removed
+	 * and dissociate_dev() must have been called.
+	 */
+
+	/* Finish the SCSI host removal sequence */
+	if (us->host) {
+		us->host->hostdata[0] = 0;
+		scsi_host_put(us->host);
+	}
 
-	/* Kill the control thread.  The SCSI host must already have been
-	 * removed so it won't try to queue any more commands.
+	/* Kill the control thread
+	 *
+	 * Enqueue the command, wake up the thread, and wait for 
+	 * notification that it has exited.
 	 */
 	if (us->pid) {
-
-		/* Wait for the thread to be idle */
-		down(&us->dev_semaphore);
 		US_DEBUGP("-- sending exit command to thread\n");
 		BUG_ON(us->sm_state != US_STATE_IDLE);
-
-		/* If the SCSI midlayer queued a final command just before
-		 * scsi_remove_host() was called, us->srb might not be
-		 * NULL.  We can overwrite it safely, because the midlayer
-		 * will not wait for the command to finish.  Also the
-		 * control thread will already have been awakened.
-		 * That's okay, an extra up() on us->sema won't hurt.
-		 *
-		 * Enqueue the command, wake up the thread, and wait for 
-		 * notification that it has exited.
-		 */
-		scsi_lock(us->host);
 		us->srb = NULL;
-		scsi_unlock(us->host);
-		up(&us->dev_semaphore);
-
-		up(&us->sema);
-		wait_for_completion(&us->notify);
+		up(&(us->sema));
+		wait_for_completion(&(us->notify));
 	}
 
 	/* Call the destructor routine, if it exists */
@@ -850,36 +857,15 @@
 		us->extra_destructor(us->extra);
 	}
 
-	/* Finish the host removal sequence */
-	if (us->host)
-		scsi_host_put(us->host);
-
 	/* Free the extra data and the URB */
 	if (us->extra)
 		kfree(us->extra);
 	if (us->current_urb)
 		usb_free_urb(us->current_urb);
 
-}
-
-/* Dissociate from the USB device */
-static void dissociate_dev(struct us_data *us)
-{
-	US_DEBUGP("-- %s\n", __FUNCTION__);
-
-	/* Free the device-related DMA-mapped buffers */
-	if (us->cr)
-		usb_buffer_free(us->pusb_dev, sizeof(*us->cr), us->cr,
-				us->cr_dma);
-	if (us->iobuf)
-		usb_buffer_free(us->pusb_dev, US_IOBUF_SIZE, us->iobuf,
-				us->iobuf_dma);
-
-	/* Remove our private data from the interface */
-	usb_set_intfdata(us->pusb_intf, NULL);
-
 	/* Free the structure itself */
 	kfree(us);
+	US_DEBUGP("-- %s finished\n", __FUNCTION__);
 }
 
 /* Probe to see if we can drive a newly-connected USB device */
@@ -891,6 +877,9 @@
 	int result;
 
 	US_DEBUGP("USB Mass Storage device detected\n");
+	US_DEBUGP("altsetting is %d, id_index is %d\n",
+			intf->cur_altsetting->desc.bAlternateSetting,
+			id_index);
 
 	/* Allocate the us_data structure and initialize the mutexes */
 	us = (struct us_data *) kmalloc(sizeof(*us), GFP_KERNEL);
@@ -902,7 +891,6 @@
 	init_MUTEX(&(us->dev_semaphore));
 	init_MUTEX_LOCKED(&(us->sema));
 	init_completion(&(us->notify));
-	init_waitqueue_head(&us->dev_reset_wait);
 
 	/* Associate the us_data structure with the USB device */
 	result = associate_dev(us, intf);
@@ -973,8 +961,8 @@
 	/* We come here if there are any problems */
 BadDevice:
 	US_DEBUGP("storage_probe() failed\n");
-	usb_stor_release_resources(us);
 	dissociate_dev(us);
+	usb_stor_release_resources(us);
 	return result;
 }
 
@@ -985,20 +973,20 @@
 
 	US_DEBUGP("storage_disconnect() called\n");
 
-	/* Prevent new USB transfers, stop the current command, and
-	 * interrupt a device-reset delay */
+	/* Prevent new USB transfers and stop the current command */
 	set_bit(US_FLIDX_DISCONNECTING, &us->flags);
 	usb_stor_stop_transport(us);
-	wake_up(&us->dev_reset_wait);
 
-	/* Wait for the current command to finish, then remove the host */
-	down(&us->dev_semaphore);
-	up(&us->dev_semaphore);
+	/* Dissociate from the USB device */
+	dissociate_dev(us);
+
 	scsi_remove_host(us->host);
 
-	/* Wait for everything to become idle and release all our resources */
+	/* TODO: somehow, wait for the device to
+	 * be 'idle' (tasklet completion) */
+
+	/* Release all our other resources */
 	usb_stor_release_resources(us);
-	dissociate_dev(us);
 }
 
 /***********************************************************************
@@ -1031,6 +1019,47 @@
 	 */
 	US_DEBUGP("-- calling usb_deregister()\n");
 	usb_deregister(&usb_storage_driver) ;
+
+#if 0
+	/* While there are still virtual hosts, unregister them
+	 * Note that it's important to do this completely before removing
+	 * the structures because of possible races with the /proc
+	 * interface
+	 */
+	for (next = us_list; next; next = next->next) {
+		US_DEBUGP("-- calling scsi_unregister_host()\n");
+		scsi_unregister_host(&usb_stor_host_template);
+	}
+
+	/* While there are still structures, free them.  Note that we are
+	 * now race-free, since these structures can no longer be accessed
+	 * from either the SCSI command layer or the /proc interface
+	 */
+	while (us_list) {
+		/* keep track of where the next one is */
+		next = us_list->next;
+
+		/* If there's extra data in the us_data structure then
+		 * free that first */
+		if (us_list->extra) {
+			/* call the destructor routine, if it exists */
+			if (us_list->extra_destructor) {
+				US_DEBUGP("-- calling extra_destructor()\n");
+				us_list->extra_destructor(us_list->extra);
+			}
+
+			/* destroy the extra data */
+			US_DEBUGP("-- freeing the data structure\n");
+			kfree(us_list->extra);
+		}
+
+		/* free the structure itself */
+		kfree (us_list);
+
+		/* advance the list pointer */
+		us_list = next;
+	}
+#endif
 }
 
 module_init(usb_stor_init);
diff -Naur linuxppc-2.6.9/drivers/usb/storage/usb.h linuxppc-2.6.9-dream/drivers/usb/storage/usb.h
--- linuxppc-2.6.9/drivers/usb/storage/usb.h	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/storage/usb.h	2005-09-19 21:40:19.000000000 +0200
@@ -48,9 +48,10 @@
 #include <linux/blkdev.h>
 #include <linux/smp_lock.h>
 #include <linux/completion.h>
+#include "scsi.h"
+#include "hosts.h"
 
 struct us_data;
-struct scsi_cmnd;
 
 /*
  * Unusual device list definitions 
@@ -101,9 +102,9 @@
 
 #define US_IOBUF_SIZE		64	/* Size of the DMA-mapped I/O buffer */
 
-typedef int (*trans_cmnd)(struct scsi_cmnd *, struct us_data*);
+typedef int (*trans_cmnd)(Scsi_Cmnd*, struct us_data*);
 typedef int (*trans_reset)(struct us_data*);
-typedef void (*proto_cmnd)(struct scsi_cmnd*, struct us_data*);
+typedef void (*proto_cmnd)(Scsi_Cmnd*, struct us_data*);
 typedef void (*extra_data_destructor)(void *);	 /* extra data destructor   */
 
 /* we allocate one of these for every device that we remember */
@@ -143,7 +144,7 @@
 
 	/* SCSI interfaces */
 	struct Scsi_Host	*host;		 /* our dummy host data */
-	struct scsi_cmnd	*srb;		 /* current srb		*/
+	Scsi_Cmnd		*srb;		 /* current srb		*/
 
 	/* thread information */
 	int			pid;		 /* control thread	 */
@@ -157,10 +158,9 @@
 	dma_addr_t		cr_dma;		 /* buffer DMA addresses */
 	dma_addr_t		iobuf_dma;
 
-	/* mutual exclusion and synchronization structures */
+	/* mutual exclusion structures */
 	struct semaphore	sema;		 /* to sleep thread on   */
-	struct completion	notify;		 /* thread begin/end	 */
-	wait_queue_head_t	dev_reset_wait;  /* wait during reset    */
+	struct completion	notify;		 /* thread begin/end	    */
 
 	/* subdriver information */
 	void			*extra;		 /* Any extra data          */
@@ -179,8 +179,4 @@
 #define scsi_unlock(host)	spin_unlock_irq(host->host_lock)
 #define scsi_lock(host)		spin_lock_irq(host->host_lock)
 
-
-/* Vendor ID list for devices that require special handling */
-#define USB_VENDOR_ID_GENESYS		0x05e3	/* Genesys Logic */
-
 #endif
diff -Naur linuxppc-2.6.9/drivers/usb/usb-skeleton.c linuxppc-2.6.9-dream/drivers/usb/usb-skeleton.c
--- linuxppc-2.6.9/drivers/usb/usb-skeleton.c	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/usb/usb-skeleton.c	2005-09-19 21:40:06.000000000 +0200
@@ -1,15 +1,42 @@
 /*
- * USB Skeleton driver - 2.0
+ * USB Skeleton driver - 1.1
  *
- * Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001-2003 Greg Kroah-Hartman (greg@kroah.com)
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License as
  *	published by the Free Software Foundation, version 2.
  *
- * This driver is based on the 2.6.3 version of drivers/usb/usb-skeleton.c 
- * but has been rewritten to be easy to read and use, as no locks are now
- * needed anymore.
+ *
+ * This driver is to be used as a skeleton driver to be able to create a
+ * USB driver quickly.  The design of it is based on the usb-serial and
+ * dc2xx drivers.
+ *
+ * Thanks to Oliver Neukum, David Brownell, and Alan Stern for their help
+ * in debugging this driver.
+ *
+ *
+ * History:
+ *
+ * 2003-05-06 - 1.1 - changes due to usb core changes with usb_register_dev()
+ * 2003-02-25 - 1.0 - fix races involving urb->status, unlink_urb(), and
+ *			disconnect.  Fix transfer amount in read().  Use
+ *			macros instead of magic numbers in probe().  Change
+ *			size variables to size_t.  Show how to eliminate
+ *			DMA bounce buffer.
+ * 2002_12_12 - 0.9 - compile fixes and got rid of fixed minor array.
+ * 2002_09_26 - 0.8 - changes due to USB core conversion to struct device
+ *			driver.
+ * 2002_02_12 - 0.7 - zero out dev in probe function for devices that do
+ *			not have both a bulk in and bulk out endpoint.
+ *			Thanks to Holger Waechtler for the fix.
+ * 2001_11_05 - 0.6 - fix minor locking problem in skel_disconnect.
+ *			Thanks to Pete Zaitcev for the fix.
+ * 2001_09_04 - 0.5 - fix devfs bug in skel_disconnect. Thanks to wim delvaux
+ * 2001_08_21 - 0.4 - more small bug fixes.
+ * 2001_05_29 - 0.3 - more bug fixes based on review from linux-usb-devel
+ * 2001_05_24 - 0.2 - bug fixes based on review from linux-usb-devel people
+ * 2001_05_01 - 0.1 - first version
  *
  */
 
@@ -19,10 +46,31 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/module.h>
-#include <linux/kref.h>
+#include <linux/smp_lock.h>
+#include <linux/completion.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
 
+#ifdef CONFIG_USB_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
+/* Use our own dbg macro */
+#undef dbg
+#define dbg(format, arg...) do { if (debug) printk(KERN_DEBUG __FILE__ ": " format "\n" , ## arg); } while (0)
+
+
+/* Version Information */
+#define DRIVER_VERSION "v1.0"
+#define DRIVER_AUTHOR "Greg Kroah-Hartman, greg@kroah.com"
+#define DRIVER_DESC "USB Skeleton Driver"
+
+/* Module parameters */
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
 
 /* Define these values to match your devices */
 #define USB_SKEL_VENDOR_ID	0xfff0
@@ -31,8 +79,11 @@
 /* table of devices that work with this driver */
 static struct usb_device_id skel_table [] = {
 	{ USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },
+	/* "Gadget Zero" firmware runs under Linux */
+	{ USB_DEVICE(0x0525, 0xa4a0) },
 	{ }					/* Terminating entry */
 };
+
 MODULE_DEVICE_TABLE (usb, skel_table);
 
 
@@ -41,195 +92,413 @@
 
 /* Structure to hold all of our device specific stuff */
 struct usb_skel {
-	struct usb_device *	udev;			/* the usb device for this device */
+	struct usb_device *	udev;			/* save off the usb device pointer */
 	struct usb_interface *	interface;		/* the interface for this device */
+	unsigned char		minor;			/* the starting minor number for this device */
+	unsigned char		num_ports;		/* the number of ports this device has */
+	char			num_interrupt_in;	/* number of interrupt in endpoints we have */
+	char			num_bulk_in;		/* number of bulk in endpoints we have */
+	char			num_bulk_out;		/* number of bulk out endpoints we have */
+
 	unsigned char *		bulk_in_buffer;		/* the buffer to receive data */
 	size_t			bulk_in_size;		/* the size of the receive buffer */
 	__u8			bulk_in_endpointAddr;	/* the address of the bulk in endpoint */
+
+	unsigned char *		bulk_out_buffer;	/* the buffer to send data */
+	size_t			bulk_out_size;		/* the size of the send buffer */
+	struct urb *		write_urb;		/* the urb used to send data */
 	__u8			bulk_out_endpointAddr;	/* the address of the bulk out endpoint */
-	struct kref		kref;
+	atomic_t		write_busy;		/* true iff write urb is busy */
+	struct completion	write_finished;		/* wait for the write to finish */
+
+	int			open;			/* if the port is open or not */
+	int			present;		/* if the device is not disconnected */
+	struct semaphore	sem;			/* locks this structure */
+};
+
+
+/* prevent races between open() and disconnect() */
+static DECLARE_MUTEX (disconnect_sem);
+
+/* local function prototypes */
+static ssize_t skel_read	(struct file *file, char *buffer, size_t count, loff_t *ppos);
+static ssize_t skel_write	(struct file *file, const char *buffer, size_t count, loff_t *ppos);
+static int skel_ioctl		(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static int skel_open		(struct inode *inode, struct file *file);
+static int skel_release		(struct inode *inode, struct file *file);
+
+static int skel_probe		(struct usb_interface *interface, const struct usb_device_id *id);
+static void skel_disconnect	(struct usb_interface *interface);
+
+static void skel_write_bulk_callback	(struct urb *urb, struct pt_regs *regs);
+
+/*
+ * File operations needed when we register this driver.
+ * This assumes that this driver NEEDS file operations,
+ * of course, which means that the driver is expected
+ * to have a node in the /dev directory. If the USB
+ * device were for a network interface then the driver
+ * would use "struct net_driver" instead, and a serial
+ * device would use "struct tty_driver".
+ */
+static struct file_operations skel_fops = {
+	/*
+	 * The owner field is part of the module-locking
+	 * mechanism. The idea is that the kernel knows
+	 * which module to increment the use-counter of
+	 * BEFORE it calls the device's open() function.
+	 * This also means that the kernel can decrement
+	 * the use-counter again before calling release()
+	 * or should the open() function fail.
+	 */
+	.owner =	THIS_MODULE,
+
+	.read =		skel_read,
+	.write =	skel_write,
+	.ioctl =	skel_ioctl,
+	.open =		skel_open,
+	.release =	skel_release,
 };
-#define to_skel_dev(d) container_of(d, struct usb_skel, kref)
 
-static struct usb_driver skel_driver;
+/* 
+ * usb class driver info in order to get a minor number from the usb core,
+ * and to have the device registered with devfs and the driver core
+ */
+static struct usb_class_driver skel_class = {
+	.name =		"usb/skel%d",
+	.fops =		&skel_fops,
+	.mode =		S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH,
+	.minor_base =	USB_SKEL_MINOR_BASE,
+};
+
+/* usb specific object needed to register this driver with the usb subsystem */
+static struct usb_driver skel_driver = {
+	.owner =	THIS_MODULE,
+	.name =		"skeleton",
+	.probe =	skel_probe,
+	.disconnect =	skel_disconnect,
+	.id_table =	skel_table,
+};
 
-static void skel_delete(struct kref *kref)
-{	
-	struct usb_skel *dev = to_skel_dev(kref);
 
-	usb_put_dev(dev->udev);
+/**
+ *	usb_skel_debug_data
+ */
+static inline void usb_skel_debug_data (const char *function, int size, const unsigned char *data)
+{
+	int i;
+
+	if (!debug)
+		return;
+
+	printk (KERN_DEBUG __FILE__": %s - length = %d, data = ",
+		function, size);
+	for (i = 0; i < size; ++i) {
+		printk ("%.2x ", data[i]);
+	}
+	printk ("\n");
+}
+
+
+/**
+ *	skel_delete
+ */
+static inline void skel_delete (struct usb_skel *dev)
+{
 	kfree (dev->bulk_in_buffer);
+	usb_buffer_free (dev->udev, dev->bulk_out_size,
+				dev->bulk_out_buffer,
+				dev->write_urb->transfer_dma);
+	usb_free_urb (dev->write_urb);
 	kfree (dev);
 }
 
-static int skel_open(struct inode *inode, struct file *file)
+
+/**
+ *	skel_open
+ */
+static int skel_open (struct inode *inode, struct file *file)
 {
-	struct usb_skel *dev;
+	struct usb_skel *dev = NULL;
 	struct usb_interface *interface;
 	int subminor;
 	int retval = 0;
 
+	dbg("%s", __FUNCTION__);
+
 	subminor = iminor(inode);
 
-	interface = usb_find_interface(&skel_driver, subminor);
+	/* prevent disconnects */
+	down (&disconnect_sem);
+
+	interface = usb_find_interface (&skel_driver, subminor);
 	if (!interface) {
 		err ("%s - error, can't find device for minor %d",
 		     __FUNCTION__, subminor);
 		retval = -ENODEV;
-		goto exit;
+		goto exit_no_device;
 	}
 
 	dev = usb_get_intfdata(interface);
 	if (!dev) {
 		retval = -ENODEV;
-		goto exit;
+		goto exit_no_device;
 	}
 
-	/* increment our usage count for the device */
-	kref_get(&dev->kref);
+	/* lock this device */
+	down (&dev->sem);
+
+	/* increment our usage count for the driver */
+	++dev->open;
 
 	/* save our object in the file's private structure */
 	file->private_data = dev;
 
-exit:
+	/* unlock this device */
+	up (&dev->sem);
+
+exit_no_device:
+	up (&disconnect_sem);
 	return retval;
 }
 
-static int skel_release(struct inode *inode, struct file *file)
+
+/**
+ *	skel_release
+ */
+static int skel_release (struct inode *inode, struct file *file)
 {
 	struct usb_skel *dev;
+	int retval = 0;
 
 	dev = (struct usb_skel *)file->private_data;
-	if (dev == NULL)
+	if (dev == NULL) {
+		dbg ("%s - object is NULL", __FUNCTION__);
 		return -ENODEV;
+	}
 
-	/* decrement the count on our device */
-	kref_put(&dev->kref, skel_delete);
-	return 0;
+	dbg("%s - minor %d", __FUNCTION__, dev->minor);
+
+	/* lock our device */
+	down (&dev->sem);
+
+	if (dev->open <= 0) {
+		dbg ("%s - device not opened", __FUNCTION__);
+		retval = -ENODEV;
+		goto exit_not_opened;
+	}
+
+	/* wait for any bulk writes that might be going on to finish up */
+	if (atomic_read (&dev->write_busy))
+		wait_for_completion (&dev->write_finished);
+
+	--dev->open;
+
+	if (!dev->present && !dev->open) {
+		/* the device was unplugged before the file was released */
+		up (&dev->sem);
+		skel_delete (dev);
+		return 0;
+	}
+
+exit_not_opened:
+	up (&dev->sem);
+
+	return retval;
 }
 
-static ssize_t skel_read(struct file *file, char *buffer, size_t count, loff_t *ppos)
+
+/**
+ *	skel_read
+ */
+static ssize_t skel_read (struct file *file, char *buffer, size_t count, loff_t *ppos)
 {
 	struct usb_skel *dev;
 	int retval = 0;
 
 	dev = (struct usb_skel *)file->private_data;
-	
+
+	dbg("%s - minor %d, count = %d", __FUNCTION__, dev->minor, count);
+
+	/* lock this object */
+	down (&dev->sem);
+
+	/* verify that the device wasn't unplugged */
+	if (!dev->present) {
+		up (&dev->sem);
+		return -ENODEV;
+	}
+
 	/* do a blocking bulk read to get data from the device */
-	retval = usb_bulk_msg(dev->udev,
-			      usb_rcvbulkpipe(dev->udev, dev->bulk_in_endpointAddr),
-			      dev->bulk_in_buffer,
-			      min(dev->bulk_in_size, count),
-			      &count, HZ*10);
+	retval = usb_bulk_msg (dev->udev,
+			       usb_rcvbulkpipe (dev->udev,
+						dev->bulk_in_endpointAddr),
+			       dev->bulk_in_buffer,
+			       min (dev->bulk_in_size, count),
+			       &count, HZ*10);
 
 	/* if the read was successful, copy the data to userspace */
 	if (!retval) {
-		if (copy_to_user(buffer, dev->bulk_in_buffer, count))
+		if (copy_to_user (buffer, dev->bulk_in_buffer, count))
 			retval = -EFAULT;
 		else
 			retval = count;
 	}
 
+	/* unlock the device */
+	up (&dev->sem);
 	return retval;
 }
 
-static void skel_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
-{
-	struct usb_skel *dev;
-
-	dev = (struct usb_skel *)urb->context;
-
-	/* sync/async unlink faults aren't errors */
-	if (urb->status && 
-	    !(urb->status == -ENOENT || 
-	      urb->status == -ECONNRESET ||
-	      urb->status == -ESHUTDOWN)) {
-		dbg("%s - nonzero write bulk status received: %d",
-		    __FUNCTION__, urb->status);
-	}
-
-	/* free up our allocated buffer */
-	usb_buffer_free(urb->dev, urb->transfer_buffer_length, 
-			urb->transfer_buffer, urb->transfer_dma);
-}
 
-static ssize_t skel_write(struct file *file, const char *user_buffer, size_t count, loff_t *ppos)
+/**
+ *	skel_write
+ *
+ *	A device driver has to decide how to report I/O errors back to the
+ *	user.  The safest course is to wait for the transfer to finish before
+ *	returning so that any errors will be reported reliably.  skel_read()
+ *	works like this.  But waiting for I/O is slow, so many drivers only
+ *	check for errors during I/O initiation and do not report problems
+ *	that occur during the actual transfer.  That's what we will do here.
+ *
+ *	A driver concerned with maximum I/O throughput would use double-
+ *	buffering:  Two urbs would be devoted to write transfers, so that
+ *	one urb could always be active while the other was waiting for the
+ *	user to send more data.
+ */
+static ssize_t skel_write (struct file *file, const char *buffer, size_t count, loff_t *ppos)
 {
 	struct usb_skel *dev;
+	ssize_t bytes_written = 0;
 	int retval = 0;
-	struct urb *urb = NULL;
-	char *buf = NULL;
 
 	dev = (struct usb_skel *)file->private_data;
 
-	/* verify that we actually have some data to write */
-	if (count == 0)
-		goto exit;
+	dbg("%s - minor %d, count = %d", __FUNCTION__, dev->minor, count);
 
-	/* create a urb, and a buffer for it, and copy the data to the urb */
-	urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!urb) {
-		retval = -ENOMEM;
-		goto error;
+	/* lock this object */
+	down (&dev->sem);
+
+	/* verify that the device wasn't unplugged */
+	if (!dev->present) {
+		retval = -ENODEV;
+		goto exit;
 	}
 
-	buf = usb_buffer_alloc(dev->udev, count, GFP_KERNEL, &urb->transfer_dma);
-	if (!buf) {
-		retval = -ENOMEM;
-		goto error;
+	/* verify that we actually have some data to write */
+	if (count == 0) {
+		dbg("%s - write request of 0 bytes", __FUNCTION__);
+		goto exit;
 	}
 
-	if (copy_from_user(buf, user_buffer, count)) {
+	/* wait for a previous write to finish up; we don't use a timeout
+	 * and so a nonresponsive device can delay us indefinitely.
+	 */
+	if (atomic_read (&dev->write_busy))
+		wait_for_completion (&dev->write_finished);
+
+	/* we can only write as much as our buffer will hold */
+	bytes_written = min (dev->bulk_out_size, count);
+
+	/* copy the data from userspace into our transfer buffer;
+	 * this is the only copy required.
+	 */
+	if (copy_from_user(dev->write_urb->transfer_buffer, buffer,
+			   bytes_written)) {
 		retval = -EFAULT;
-		goto error;
+		goto exit;
 	}
 
-	/* initialize the urb properly */
-	usb_fill_bulk_urb(urb, dev->udev,
-			  usb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),
-			  buf, count, skel_write_bulk_callback, dev);
-	urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+	usb_skel_debug_data (__FUNCTION__, bytes_written,
+			     dev->write_urb->transfer_buffer);
+
+	/* this urb was already set up, except for this write size */
+	dev->write_urb->transfer_buffer_length = bytes_written;
 
 	/* send the data out the bulk port */
-	retval = usb_submit_urb(urb, GFP_KERNEL);
+	/* a character device write uses GFP_KERNEL,
+	 unless a spinlock is held */
+	init_completion (&dev->write_finished);
+	atomic_set (&dev->write_busy, 1);
+	retval = usb_submit_urb(dev->write_urb, GFP_KERNEL);
 	if (retval) {
-		err("%s - failed submitting write urb, error %d", __FUNCTION__, retval);
-		goto error;
+		atomic_set (&dev->write_busy, 0);
+		err("%s - failed submitting write urb, error %d",
+		    __FUNCTION__, retval);
+	} else {
+		retval = bytes_written;
 	}
 
-	/* release our reference to this urb, the USB core will eventually free it entirely */
-	usb_free_urb(urb);
-
 exit:
-	return count;
+	/* unlock the device */
+	up (&dev->sem);
 
-error:
-	usb_buffer_free(dev->udev, count, buf, urb->transfer_dma);
-	usb_free_urb(urb);
 	return retval;
 }
 
-static struct file_operations skel_fops = {
-	.owner =	THIS_MODULE,
-	.read =		skel_read,
-	.write =	skel_write,
-	.open =		skel_open,
-	.release =	skel_release,
-};
 
-/* 
- * usb class driver info in order to get a minor number from the usb core,
- * and to have the device registered with devfs and the driver core
+/**
+ *	skel_ioctl
  */
-static struct usb_class_driver skel_class = {
-	.name =		"usb/skel%d",
-	.fops =		&skel_fops,
-	.mode =		S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH,
-	.minor_base =	USB_SKEL_MINOR_BASE,
-};
+static int skel_ioctl (struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct usb_skel *dev;
+
+	dev = (struct usb_skel *)file->private_data;
+
+	/* lock this object */
+	down (&dev->sem);
+
+	/* verify that the device wasn't unplugged */
+	if (!dev->present) {
+		up (&dev->sem);
+		return -ENODEV;
+	}
+
+	dbg("%s - minor %d, cmd 0x%.4x, arg %ld", __FUNCTION__,
+	    dev->minor, cmd, arg);
+
+	/* fill in your device specific stuff here */
+
+	/* unlock the device */
+	up (&dev->sem);
+
+	/* return that we did not understand this ioctl call */
+	return -ENOTTY;
+}
+
 
+/**
+ *	skel_write_bulk_callback
+ */
+static void skel_write_bulk_callback (struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_skel *dev = (struct usb_skel *)urb->context;
+
+	dbg("%s - minor %d", __FUNCTION__, dev->minor);
+
+	/* sync/async unlink faults aren't errors */
+	if (urb->status && !(urb->status == -ENOENT ||
+				urb->status == -ECONNRESET)) {
+		dbg("%s - nonzero write bulk status received: %d",
+		    __FUNCTION__, urb->status);
+	}
+
+	/* notify anyone waiting that the write has finished */
+	atomic_set (&dev->write_busy, 0);
+	complete (&dev->write_finished);
+}
+
+
+/**
+ *	skel_probe
+ *
+ *	Called by the usb core when a new device is connected that it thinks
+ *	this driver might be interested in.
+ */
 static int skel_probe(struct usb_interface *interface, const struct usb_device_id *id)
 {
+	struct usb_device *udev = interface_to_usbdev(interface);
 	struct usb_skel *dev = NULL;
 	struct usb_host_interface *iface_desc;
 	struct usb_endpoint_descriptor *endpoint;
@@ -237,21 +506,28 @@
 	int i;
 	int retval = -ENOMEM;
 
+	/* See if the device offered us matches what we can accept */
+	if ((udev->descriptor.idVendor != USB_SKEL_VENDOR_ID) ||
+	    (udev->descriptor.idProduct != USB_SKEL_PRODUCT_ID)) {
+		return -ENODEV;
+	}
+
 	/* allocate memory for our device state and initialize it */
-	dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	dev = kmalloc (sizeof(struct usb_skel), GFP_KERNEL);
 	if (dev == NULL) {
-		err("Out of memory");
+		err ("Out of memory");
 		goto error;
 	}
-	memset(dev, 0x00, sizeof(*dev));
-	kref_init(&dev->kref);
+	memset (dev, 0x00, sizeof (*dev));
 
-	dev->udev = usb_get_dev(interface_to_usbdev(interface));
+	init_MUTEX (&dev->sem);
+	dev->udev = udev;
 	dev->interface = interface;
 
 	/* set up the endpoint information */
+	/* check out the endpoints */
 	/* use only the first bulk-in and bulk-out endpoints */
-	iface_desc = interface->cur_altsetting;
+	iface_desc = &interface->altsetting[0];
 	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
 		endpoint = &iface_desc->endpoint[i].desc;
 
@@ -263,9 +539,9 @@
 			buffer_size = endpoint->wMaxPacketSize;
 			dev->bulk_in_size = buffer_size;
 			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
-			dev->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
+			dev->bulk_in_buffer = kmalloc (buffer_size, GFP_KERNEL);
 			if (!dev->bulk_in_buffer) {
-				err("Could not allocate bulk_in_buffer");
+				err("Couldn't allocate bulk_in_buffer");
 				goto error;
 			}
 		}
@@ -275,85 +551,153 @@
 		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
 					== USB_ENDPOINT_XFER_BULK)) {
 			/* we found a bulk out endpoint */
+			/* a probe() may sleep and has no restrictions on memory allocations */
+			dev->write_urb = usb_alloc_urb(0, GFP_KERNEL);
+			if (!dev->write_urb) {
+				err("No free urbs available");
+				goto error;
+			}
 			dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
+
+			/* on some platforms using this kind of buffer alloc
+			 * call eliminates a dma "bounce buffer".
+			 *
+			 * NOTE: you'd normally want i/o buffers that hold
+			 * more than one packet, so that i/o delays between
+			 * packets don't hurt throughput.
+			 */
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulk_out_size = buffer_size;
+			dev->write_urb->transfer_flags = (URB_NO_TRANSFER_DMA_MAP |
+					URB_ASYNC_UNLINK);
+			dev->bulk_out_buffer = usb_buffer_alloc (udev,
+					buffer_size, GFP_KERNEL,
+					&dev->write_urb->transfer_dma);
+			if (!dev->bulk_out_buffer) {
+				err("Couldn't allocate bulk_out_buffer");
+				goto error;
+			}
+			usb_fill_bulk_urb(dev->write_urb, udev,
+				      usb_sndbulkpipe(udev,
+						      endpoint->bEndpointAddress),
+				      dev->bulk_out_buffer, buffer_size,
+				      skel_write_bulk_callback, dev);
 		}
 	}
 	if (!(dev->bulk_in_endpointAddr && dev->bulk_out_endpointAddr)) {
-		err("Could not find both bulk-in and bulk-out endpoints");
+		err("Couldn't find both bulk-in and bulk-out endpoints");
 		goto error;
 	}
 
-	/* save our data pointer in this interface device */
-	usb_set_intfdata(interface, dev);
+	/* allow device read, write and ioctl */
+	dev->present = 1;
 
 	/* we can register the device now, as it is ready */
-	retval = usb_register_dev(interface, &skel_class);
+	usb_set_intfdata (interface, dev);
+	retval = usb_register_dev (interface, &skel_class);
 	if (retval) {
 		/* something prevented us from registering this driver */
-		err("Not able to get a minor for this device.");
-		usb_set_intfdata(interface, NULL);
+		err ("Not able to get a minor for this device.");
+		usb_set_intfdata (interface, NULL);
 		goto error;
 	}
 
+	dev->minor = interface->minor;
+
 	/* let the user know what node this device is now attached to */
-	info("USB Skeleton device now attached to USBSkel-%d", interface->minor);
+	info ("USB Skeleton device now attached to USBSkel-%d", dev->minor);
 	return 0;
 
 error:
-	if (dev)
-		kref_put(&dev->kref, skel_delete);
+	skel_delete (dev);
 	return retval;
 }
 
+
+/**
+ *	skel_disconnect
+ *
+ *	Called by the usb core when the device is removed from the system.
+ *
+ *	This routine guarantees that the driver will not submit any more urbs
+ *	by clearing dev->udev.  It is also supposed to terminate any currently
+ *	active urbs.  Unfortunately, usb_bulk_msg(), used in skel_read(), does
+ *	not provide any way to do this.  But at least we can cancel an active
+ *	write.
+ */
 static void skel_disconnect(struct usb_interface *interface)
 {
 	struct usb_skel *dev;
-	int minor = interface->minor;
+	int minor;
 
-	/* prevent skel_open() from racing skel_disconnect() */
-	lock_kernel();
+	/* prevent races with open() */
+	down (&disconnect_sem);
 
-	dev = usb_get_intfdata(interface);
-	usb_set_intfdata(interface, NULL);
+	dev = usb_get_intfdata (interface);
+	usb_set_intfdata (interface, NULL);
+
+	down (&dev->sem);
+
+	minor = dev->minor;
 
 	/* give back our minor */
-	usb_deregister_dev(interface, &skel_class);
+	usb_deregister_dev (interface, &skel_class);
 
-	unlock_kernel();
+	/* terminate an ongoing write */
+	if (atomic_read (&dev->write_busy)) {
+		usb_unlink_urb (dev->write_urb);
+		wait_for_completion (&dev->write_finished);
+	}
+
+	/* prevent device read, write and ioctl */
+	dev->present = 0;
+
+	up (&dev->sem);
 
-	/* decrement our usage count */
-	kref_put(&dev->kref, skel_delete);
+	/* if the device is opened, skel_release will clean this up */
+	if (!dev->open)
+		skel_delete (dev);
+
+	up (&disconnect_sem);
 
 	info("USB Skeleton #%d now disconnected", minor);
 }
 
-static struct usb_driver skel_driver = {
-	.owner =	THIS_MODULE,
-	.name =		"skeleton",
-	.probe =	skel_probe,
-	.disconnect =	skel_disconnect,
-	.id_table =	skel_table,
-};
 
+
+/**
+ *	usb_skel_init
+ */
 static int __init usb_skel_init(void)
 {
 	int result;
 
 	/* register this driver with the USB subsystem */
 	result = usb_register(&skel_driver);
-	if (result)
-		err("usb_register failed. Error number %d", result);
+	if (result) {
+		err("usb_register failed. Error number %d",
+		    result);
+		return result;
+	}
 
-	return result;
+	info(DRIVER_DESC " " DRIVER_VERSION);
+	return 0;
 }
 
+
+/**
+ *	usb_skel_exit
+ */
 static void __exit usb_skel_exit(void)
 {
 	/* deregister this driver with the USB subsystem */
 	usb_deregister(&skel_driver);
 }
 
+
 module_init (usb_skel_init);
 module_exit (usb_skel_exit);
 
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
diff -Naur linuxppc-2.6.9/drivers/video/Makefile linuxppc-2.6.9-dream/drivers/video/Makefile
--- linuxppc-2.6.9/drivers/video/Makefile	2005-10-01 14:12:19.000000000 +0200
+++ linuxppc-2.6.9-dream/drivers/video/Makefile	2005-06-20 10:46:11.000000000 +0200
@@ -11,6 +11,9 @@
 # Only include macmodes.o if we have FB support and are PPC
 ifeq ($(CONFIG_FB),y)
 obj-$(CONFIG_PPC)                 += macmodes.o
+obj-$(CONFIG_DM56xx)              += cfbfillrect.o cfbimgblt.o cfbcopyarea.o
+obj-$(CONFIG_DM7000)              += cfbfillrect.o cfbimgblt.o cfbcopyarea.o
+obj-$(CONFIG_DM7020)              += cfbfillrect.o cfbimgblt.o cfbcopyarea.o
 endif
 
 # Hardware specific drivers go first
diff -Naur linuxppc-2.6.9/fs/jffs2/compr.c linuxppc-2.6.9-dream/fs/jffs2/compr.c
--- linuxppc-2.6.9/fs/jffs2/compr.c	2004-10-18 23:53:46.000000000 +0200
+++ linuxppc-2.6.9-dream/fs/jffs2/compr.c	2005-06-20 10:46:11.000000000 +0200
@@ -180,6 +180,11 @@
         struct jffs2_compressor *this;
         int ret;
 
+	/* Older code had a bug where it would write non-zero 'usercompr'
+	   fields. Deal with it. */
+	if ((comprtype & 0xff) <= JFFS2_COMPR_ZLIB)
+		comprtype &= 0xff;
+	
 	switch (comprtype & 0xff) {
 	case JFFS2_COMPR_NONE:
 		/* This should be special-cased elsewhere, but we might as well deal with it */
@@ -208,7 +213,7 @@
                                 return ret;
                         }
                 }
-		printk(KERN_WARNING "JFFS2 compression type 0x%02x not avaiable.\n", comprtype);
+		printk(KERN_WARNING "JFFS2 compression type 0x%02x not available.\n", comprtype);
                 spin_unlock(&jffs2_compressor_list_lock);
 		return -EIO;
 	}
diff -Naur linuxppc-2.6.9/fs/partitions/msdos.c linuxppc-2.6.9-dream/fs/partitions/msdos.c
--- linuxppc-2.6.9/fs/partitions/msdos.c	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/fs/partitions/msdos.c	2005-06-20 10:46:11.000000000 +0200
@@ -393,22 +393,9 @@
 		return 0;
 	}
 
-	/*
-	 * Now that the 55aa signature is present, this is probably
-	 * either the boot sector of a FAT filesystem or a DOS-type
-	 * partition table. Reject this in case the boot indicator
-	 * is not 0 or 0x80.
-	 */
 	p = (struct partition *) (data + 0x1be);
-	for (slot = 1; slot <= 4; slot++, p++) {
-		if (p->boot_ind != 0 && p->boot_ind != 0x80) {
-			put_dev_sector(sect);
-			return 0;
-		}
-	}
 
 #ifdef CONFIG_EFI_PARTITION
-	p = (struct partition *) (data + 0x1be);
 	for (slot = 1 ; slot <= 4 ; slot++, p++) {
 		/* If this is an EFI GPT disk, msdos should ignore it. */
 		if (SYS_IND(p) == EFI_PMBR_OSTYPE_EFI_GPT) {
@@ -416,9 +403,8 @@
 			return 0;
 		}
 	}
-#endif
 	p = (struct partition *) (data + 0x1be);
-
+#endif
 	/*
 	 * Look for partitions in two passes:
 	 * First find the primary and DOS-type extended partitions.
diff -Naur linuxppc-2.6.9/include/asm-ppc/ibm4xx.h linuxppc-2.6.9-dream/include/asm-ppc/ibm4xx.h
--- linuxppc-2.6.9/include/asm-ppc/ibm4xx.h	2005-10-01 14:12:19.000000000 +0200
+++ linuxppc-2.6.9-dream/include/asm-ppc/ibm4xx.h	2005-06-20 10:46:11.000000000 +0200
@@ -31,6 +31,14 @@
 #include <platforms/4xx/cpci405.h>
 #endif
 
+#if defined(CONFIG_DM56xx)
+#include <platforms/4xx/dm56xx.h>
+#endif
+
+#if defined(CONFIG_DM7000) || defined(CONFIG_DM7020)
+#include <platforms/4xx/dm70xx.h>
+#endif
+
 #if defined(CONFIG_EP405)
 #include <platforms/4xx/ep405.h>
 #endif
diff -Naur linuxppc-2.6.9/include/asm-ppc/ppc4xx_dma.h linuxppc-2.6.9-dream/include/asm-ppc/ppc4xx_dma.h
--- linuxppc-2.6.9/include/asm-ppc/ppc4xx_dma.h	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/include/asm-ppc/ppc4xx_dma.h	2005-06-20 10:46:11.000000000 +0200
@@ -479,9 +479,7 @@
 	char ch_enable;
 	char tcd_disable;
 	char ece_enable;
-	char td;		/* transfer direction */
 #endif
-
 } ppc_dma_ch_t;
 
 /*
diff -Naur linuxppc-2.6.9/include/linux/ide.h linuxppc-2.6.9-dream/include/linux/ide.h
--- linuxppc-2.6.9/include/linux/ide.h	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/ide.h	2005-06-20 10:46:11.000000000 +0200
@@ -39,7 +39,6 @@
  *
  * REALLY_SLOW_IO can be defined in ide.c and ide-cd.c, if necessary
  */
-#define REALLY_FAST_IO			/* define if ide ports are perfect */
 #define INITIAL_MULT_COUNT	0	/* off=0; on=2,4,8,16,32, etc.. */
 
 #ifndef SUPPORT_SLOW_DATA_PORTS		/* 1 to support slow data ports */
@@ -64,18 +63,6 @@
 #define IDE_NO_IRQ		(-1)
 
 /*
- * IDE_DRIVE_CMD is used to implement many features of the hdparm utility
- */
-#define IDE_DRIVE_CMD			99	/* (magic) undef to reduce kernel size*/
-
-#define IDE_DRIVE_TASK			98
-
-/*
- * IDE_DRIVE_TASKFILE is used to implement many features needed for raw tasks
- */
-#define IDE_DRIVE_TASKFILE		97
-
-/*
  *  "No user-serviceable parts" beyond this point  :)
  *****************************************************************************/
 
@@ -101,13 +88,6 @@
 
 #define DMA_PIO_RETRY	1	/* retrying in PIO */
 
-/*
- * Ensure that various configuration flags have compatible settings
- */
-#ifdef REALLY_SLOW_IO
-#undef REALLY_FAST_IO
-#endif
-
 #define HWIF(drive)		((ide_hwif_t *)((drive)->hwif))
 #define HWGROUP(drive)		((ide_hwgroup_t *)(HWIF(drive)->hwgroup))
 
@@ -197,10 +177,7 @@
 /*
  * Some more useful definitions
  */
-#define IDE_MAJOR_NAME	"hd"	/* the same for all i/f; see also genhd.c */
-#define MAJOR_NAME	IDE_MAJOR_NAME
 #define PARTN_BITS	6	/* number of minor dev bits for partitions */
-#define PARTN_MASK	((1<<PARTN_BITS)-1)	/* a useful bit mask */
 #define MAX_DRIVES	2	/* per interface; 2 assumed by lots of code */
 #define SECTOR_SIZE	512
 #define SECTOR_WORDS	(SECTOR_SIZE / 4)	/* number of 32bit words per sector */
@@ -210,11 +187,7 @@
  * Timeouts for various operations:
  */
 #define WAIT_DRQ	(HZ/10)		/* 100msec - spec allows up to 20ms */
-#if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)
 #define WAIT_READY	(5*HZ)		/* 5sec - some laptops are very slow */
-#else
-#define WAIT_READY	(HZ/10)		/* 100msec - should be instantaneous */
-#endif /* CONFIG_APM || CONFIG_APM_MODULE */
 #define WAIT_PIDENTIFY	(10*HZ)	/* 10sec  - should be less than 3ms (?), if all ATAPI CD is closed at boot */
 #define WAIT_WORSTCASE	(30*HZ)	/* 30sec  - worst case when spinning up */
 #define WAIT_CMD	(10*HZ)	/* 10sec  - maximum wait for an IRQ to happen */
@@ -242,7 +215,7 @@
 typedef enum {	ide_unknown,	ide_generic,	ide_pci,
 		ide_cmd640,	ide_dtc2278,	ide_ali14xx,
 		ide_qd65xx,	ide_umc8672,	ide_ht6560b,
-		ide_pdc4030,	ide_rz1000,	ide_trm290,
+		ide_rz1000,	ide_trm290,
 		ide_cmd646,	ide_cy82c693,	ide_4drives,
 		ide_pmac,	ide_etrax100,	ide_acorn,
 		ide_forced
@@ -256,16 +229,14 @@
 	int		irq;			/* our irq number */
 	int		dma;			/* our dma entry */
 	ide_ack_intr_t	*ack_intr;		/* acknowledge interrupt */
-	void		*priv;			/* interface specific data */
 	hwif_chipset_t  chipset;
-	unsigned long	sata_scr[SATA_NR_PORTS];
-	unsigned long	sata_misc[SATA_NR_PORTS];
 } hw_regs_t;
 
 /*
  * Register new hardware with ide
  */
 int ide_register_hw(hw_regs_t *hw, struct hwif_s **hwifp);
+int ide_register_hw_with_fixup(hw_regs_t *, struct hwif_s **, void (*)(struct hwif_s *));
 
 /*
  * Set up hw_regs_t structure before calling ide_register_hw (optional)
@@ -739,7 +710,6 @@
 	unsigned remap_0_to_1	: 1;	/* 0=noremap, 1=remap 0->1 (for EZDrive) */
 	unsigned blocked        : 1;	/* 1=powermanagment told us not to do anything, so sleep nicely */
 	unsigned vdma		: 1;	/* 1=doing PIO over DMA 0=doing normal DMA */
-	unsigned stroke		: 1;	/* from:  hdx=stroke */
 	unsigned addressing;		/*      : 3;
 					 *  0=28-bit
 					 *  1=48-bit
@@ -747,9 +717,9 @@
 					 *  3=64-bit
 					 */
 	unsigned scsi		: 1;	/* 0=default, 1=ide-scsi emulation */
+	unsigned sleeping	: 1;	/* 1=sleeping & sleep field valid */
 
         u8	quirk_list;	/* considered quirky, set for a specific host */
-        u8	suspend_reset;	/* drive suspend mode flag, soft-reset recovers */
         u8	init_speed;	/* transfer rate set at boot */
         u8	pio_speed;      /* unused by core, used by some drivers for fallback from DMA */
         u8	current_speed;	/* current transfer rate set */
@@ -789,27 +759,6 @@
 	struct gendisk *disk;
 } ide_drive_t;
 
-/*
- * mapping stuff, prepare for highmem...
- * 
- * temporarily mapping a (possible) highmem bio for PIO transfer
- */
-#ifndef CONFIG_IDE_TASKFILE_IO
-
-#define ide_rq_offset(rq) \
-	(((rq)->hard_cur_sectors - (rq)->current_nr_sectors) << 9)
-
-static inline void *ide_map_buffer(struct request *rq, unsigned long *flags)
-{
-	return bio_kmap_irq(rq->bio, flags) + ide_rq_offset(rq);
-}
-
-static inline void ide_unmap_buffer(struct request *rq, char *buffer, unsigned long *flags)
-{
-	bio_kunmap_irq(buffer, flags);
-}
-#endif /* !CONFIG_IDE_TASKFILE_IO */
-
 #define IDE_CHIPSET_PCI_MASK	\
     ((1<<ide_pci)|(1<<ide_cmd646)|(1<<ide_ali14xx))
 #define IDE_CHIPSET_IS_PCI(c)	((IDE_CHIPSET_PCI_MASK >> (c)) & 1)
@@ -848,13 +797,11 @@
 	struct pci_dev  *pci_dev;	/* for pci chipsets */
 	struct ide_pci_device_s	*cds;	/* chipset device struct */
 
-	ide_startstop_t (*rw_disk)(ide_drive_t *, struct request *, sector_t);
+	void (*rw_disk)(ide_drive_t *, struct request *);
 
 #if 0
 	ide_hwif_ops_t	*hwifops;
 #else
-	/* routine is for HBA specific IDENTITY operations */
-	int	(*identify)(ide_drive_t *);
 	/* routine to tune PIO mode for drives */
 	void	(*tuneproc)(ide_drive_t *, u8);
 	/* routine to retune DMA modes for drives */
@@ -887,9 +834,9 @@
 	void (*atapi_input_bytes)(ide_drive_t *, void *, u32);
 	void (*atapi_output_bytes)(ide_drive_t *, void *, u32);
 
-	int (*ide_dma_read)(ide_drive_t *drive);
-	int (*ide_dma_write)(ide_drive_t *drive);
-	int (*ide_dma_begin)(ide_drive_t *drive);
+	int (*dma_setup)(ide_drive_t *);
+	void (*dma_exec_cmd)(ide_drive_t *, u8);
+	void (*dma_start)(ide_drive_t *);
 	int (*ide_dma_end)(ide_drive_t *drive);
 	int (*ide_dma_check)(ide_drive_t *drive);
 	int (*ide_dma_on)(ide_drive_t *drive);
@@ -897,7 +844,6 @@
 	int (*ide_dma_test_irq)(ide_drive_t *drive);
 	int (*ide_dma_host_on)(ide_drive_t *drive);
 	int (*ide_dma_host_off)(ide_drive_t *drive);
-	int (*ide_dma_verbose)(ide_drive_t *drive);
 	int (*ide_dma_lostirq)(ide_drive_t *drive);
 	int (*ide_dma_timeout)(ide_drive_t *drive);
 
@@ -920,12 +866,18 @@
 	dma_addr_t	dmatable_dma;
 	/* Scatter-gather list used to build the above */
 	struct scatterlist *sg_table;
+	int sg_max_nents;		/* Maximum number of entries in it */
 	int sg_nents;			/* Current number of entries in it */
 	int sg_dma_direction;		/* dma transfer direction */
 
 	/* data phase of the active command (currently only valid for PIO/DMA) */
 	int		data_phase;
 
+	unsigned int nsect;
+	unsigned int nleft;
+	unsigned int cursg;
+	unsigned int cursg_ofs;
+
 	int		mmio;		/* hosts iomio (0) or custom (2) select */
 	int		rqsize;		/* max sectors per request */
 	int		irq;		/* our irq number */
@@ -955,6 +907,7 @@
 	unsigned	no_lba48_dma : 1; /* 1 = cannot do LBA48 DMA */
 	unsigned	no_dsc     : 1;	/* 0 default, 1 dsc_overlap disabled */
 	unsigned	auto_poll  : 1; /* supports nop auto-poll */
+	unsigned	sg_mapped  : 1;	/* sg_table and sg_nents are ready */
 
 	struct device	gendev;
 	struct semaphore gendev_rel_sem; /* To deal with device release() */
@@ -981,7 +934,9 @@
 		/* BOOL: protects all fields below */
 	volatile int busy;
 		/* BOOL: wake us up on timer expiry */
-	int sleeping;
+	unsigned int sleeping	: 1;
+		/* BOOL: polling active & poll_timeout field valid */
+	unsigned int polling	: 1;
 		/* current drive */
 	ide_drive_t *drive;
 		/* ptr to current hwif in linked-list */
@@ -1062,8 +1017,8 @@
 
 extern void proc_ide_create(void);
 extern void proc_ide_destroy(void);
-extern void destroy_proc_ide_drives(ide_hwif_t *);
 extern void create_proc_ide_interfaces(void);
+void destroy_proc_ide_interface(ide_hwif_t *);
 extern void ide_add_proc_entries(struct proc_dir_entry *, ide_proc_entry_t *, void *);
 extern void ide_remove_proc_entries(struct proc_dir_entry *, ide_proc_entry_t *);
 read_proc_t proc_ide_read_capacity;
@@ -1090,6 +1045,7 @@
 }
 #else
 static inline void create_proc_ide_interfaces(void) { ; }
+static inline void destroy_proc_ide_interface(ide_hwif_t *hwif) { ; }
 #define PROC_IDE_READ_RETURN(page,start,off,count,eof,len) return 0;
 #endif
 
@@ -1139,9 +1095,8 @@
 	int		(*cleanup)(ide_drive_t *);
 	ide_startstop_t	(*do_request)(ide_drive_t *, struct request *, sector_t);
 	int		(*end_request)(ide_drive_t *, int, int);
-	u8		(*sense)(ide_drive_t *, const char *, u8);
-	ide_startstop_t	(*error)(ide_drive_t *, const char *, u8);
-	ide_startstop_t	(*abort)(ide_drive_t *, const char *);
+	ide_startstop_t	(*error)(ide_drive_t *, struct request *rq, u8, u8);
+	ide_startstop_t	(*abort)(ide_drive_t *, struct request *rq);
 	int		(*ioctl)(ide_drive_t *, struct inode *, struct file *, unsigned int, unsigned long);
 	void		(*pre_reset)(ide_drive_t *);
 	sector_t	(*capacity)(ide_drive_t *);
@@ -1189,12 +1144,7 @@
  */
 extern void ide_execute_command(ide_drive_t *, task_ioreg_t cmd, ide_handler_t *, unsigned int, ide_expiry_t *);
 
-/*
- * Error reporting, in human readable form (luxurious, but a memory hog).
- *
- * (drive, msg, status)
- */
-byte ide_dump_status (ide_drive_t *drive, const char *msg, byte stat);
+ide_startstop_t __ide_error(ide_drive_t *, struct request *, u8, u8);
 
 /*
  * ide_error() takes action based on the error returned by the controller.
@@ -1204,6 +1154,8 @@
  */
 ide_startstop_t ide_error (ide_drive_t *drive, const char *msg, byte stat);
 
+ide_startstop_t __ide_abort(ide_drive_t *, struct request *);
+
 /*
  * Abort a running command on the controller triggering the abort
  * from a host side, non error situation
@@ -1211,14 +1163,6 @@
  */
 extern ide_startstop_t ide_abort(ide_drive_t *, const char *);
 
-/*
- * Issue a simple drive command
- * The drive must be selected beforehand.
- *
- * (drive, command, nsector, handler)
- */
-extern void ide_cmd(ide_drive_t *, u8, u8, ide_handler_t *);
-
 extern void ide_fix_driveid(struct hd_driveid *);
 /*
  * ide_fixstring() cleans up and (optionally) byte-swaps a text string,
@@ -1242,11 +1186,6 @@
 extern int ide_wait_stat(ide_startstop_t *, ide_drive_t *, u8, u8, unsigned long);
 
 /*
- * Return the current idea about the total capacity of this drive.
- */
-extern sector_t current_capacity (ide_drive_t *drive);
-
-/*
  * Start a reset operation for an IDE interface.
  * The caller should return immediately after invoking this.
  */
@@ -1309,8 +1248,6 @@
  */
 extern void ide_end_drive_cmd(ide_drive_t *, u8, u8);
 
-extern void try_to_flush_leftover_data(ide_drive_t *);
-
 /*
  * Issue ATA command and wait for completion.
  * Use for implementing commands in kernel
@@ -1319,9 +1256,6 @@
  */
 extern int ide_wait_cmd(ide_drive_t *, u8, u8, u8, u8, u8 *);
 
-/* (ide_drive_t *drive, u8 *buf) */
-extern int ide_wait_cmd_task(ide_drive_t *, u8 *);
-
 typedef struct ide_task_s {
 /*
  *	struct hd_drive_task_hdr	tf;
@@ -1341,20 +1275,6 @@
 	void			*special;	/* valid_t generally */
 } ide_task_t;
 
-typedef struct pkt_task_s {
-/*
- *	struct hd_drive_task_hdr	pktf;
- *	task_struct_t		pktf;
- *	u8			pkcdb[12];
- */
-	task_ioreg_t		tfRegister[8];
-	int			data_phase;
-	int			command_type;
-	ide_handler_t		*handler;
-	struct request		*rq;		/* copy of request */
-	void			*special;
-} pkt_task_t;
-
 extern u32 ide_read_24(ide_drive_t *);
 
 extern void SELECT_DRIVE(ide_drive_t *);
@@ -1362,42 +1282,6 @@
 extern void SELECT_MASK(ide_drive_t *, int);
 extern void QUIRK_LIST(ide_drive_t *);
 
-extern void ata_input_data(ide_drive_t *, void *, u32);
-extern void ata_output_data(ide_drive_t *, void *, u32);
-extern void atapi_input_bytes(ide_drive_t *, void *, u32);
-extern void atapi_output_bytes(ide_drive_t *, void *, u32);
-extern void taskfile_input_data(ide_drive_t *, void *, u32);
-extern void taskfile_output_data(ide_drive_t *, void *, u32);
-
-#define IDE_PIO_IN	0
-#define IDE_PIO_OUT	1
-
-static inline void __task_sectors(ide_drive_t *drive, char *buf,
-				  unsigned nsect, unsigned rw)
-{
-	/*
-	 * IRQ can happen instantly after reading/writing
-	 * last sector of the datablock.
-	 */
-	if (rw == IDE_PIO_OUT)
-		taskfile_output_data(drive, buf, nsect * SECTOR_WORDS);
-	else
-		taskfile_input_data(drive, buf, nsect * SECTOR_WORDS);
-}
-
-#ifdef CONFIG_IDE_TASKFILE_IO
-static inline void task_bio_sectors(ide_drive_t *drive, struct request *rq,
-				    unsigned nsect, unsigned rw)
-{
-	unsigned long flags;
-	char *buf = rq_map_buffer(rq, &flags);
-
-	process_that_request_first(rq, nsect);
-	__task_sectors(drive, buf, nsect, rw);
-	rq_unmap_buffer(buf, &flags);
-}
-#endif /* CONFIG_IDE_TASKFILE_IO */
-
 extern int drive_is_ready(ide_drive_t *);
 extern int wait_for_ready(ide_drive_t *, int /* timeout */);
 
@@ -1417,7 +1301,6 @@
 extern ide_startstop_t task_no_data_intr(ide_drive_t *);
 extern ide_startstop_t task_in_intr(ide_drive_t *);
 extern ide_startstop_t pre_task_out_intr(ide_drive_t *, struct request *);
-extern ide_startstop_t task_out_intr(ide_drive_t *);
 
 extern int ide_raw_taskfile(ide_drive_t *, ide_task_t *, u8 *);
 
@@ -1427,7 +1310,6 @@
 
 extern int system_bus_clock(void);
 
-extern u8 ide_auto_reduce_xfer(ide_drive_t *);
 extern int ide_driveid_update(ide_drive_t *);
 extern int ide_ata66_check(ide_drive_t *, ide_task_t *);
 extern int ide_config_drive_speed(ide_drive_t *, u8);
@@ -1436,15 +1318,6 @@
 extern int taskfile_lib_get_identify(ide_drive_t *drive, u8 *);
 
 extern int ide_wait_not_busy(ide_hwif_t *hwif, unsigned long timeout);
-ide_startstop_t __ide_do_rw_disk(ide_drive_t *drive, struct request *rq, sector_t block);
-
-/*
- * ide_system_bus_speed() returns what we think is the system VESA/PCI
- * bus speed (in MHz).  This is used for calculating interface PIO timings.
- * The default is 40 for known PCI systems, 50 otherwise.
- * The "idebus=xx" parameter can be used to override this value.
- */
-extern int ide_system_bus_speed(void);
 
 /*
  * ide_stall_queue() can be used by a drive to give excess bandwidth back
@@ -1459,7 +1332,6 @@
 extern void ide_init_subdrivers(void);
 
 extern struct block_device_operations ide_fops[];
-extern ide_proc_entry_t generic_subdriver_entries[];
 
 extern int ata_attach(ide_drive_t *);
 
@@ -1468,7 +1340,7 @@
 extern void ide_scan_pcibus(int scan_direction) __init;
 extern int ide_pci_register_driver(struct pci_driver *driver);
 extern void ide_pci_unregister_driver(struct pci_driver *driver);
-extern void ide_pci_setup_ports(struct pci_dev *dev, struct ide_pci_device_s *d, int autodma, int pciirq, ata_index_t *index);
+void ide_pci_setup_ports(struct pci_dev *, struct ide_pci_device_s *, int, ata_index_t *);
 extern void ide_setup_pci_noise (struct pci_dev *dev, struct ide_pci_device_s *d);
 
 extern void default_hwif_iops(ide_hwif_t *);
@@ -1503,19 +1375,18 @@
 enum {
 	/* Uses ISA control ports not PCI ones. */
 	IDEPCI_FLAG_ISA_PORTS		= (1 << 0),
-
-	IDEPCI_FLAG_FORCE_MASTER	= (1 << 1),
-	IDEPCI_FLAG_FORCE_PDC		= (1 << 2),
+	IDEPCI_FLAG_FORCE_PDC		= (1 << 1),
 };
 
 typedef struct ide_pci_device_s {
 	char			*name;
-	void			(*init_setup)(struct pci_dev *, struct ide_pci_device_s *);
+	int			(*init_setup)(struct pci_dev *, struct ide_pci_device_s *);
 	void			(*init_setup_dma)(struct pci_dev *, struct ide_pci_device_s *, ide_hwif_t *);
 	unsigned int		(*init_chipset)(struct pci_dev *, const char *);
 	void			(*init_iops)(ide_hwif_t *);
 	void                    (*init_hwif)(ide_hwif_t *);
 	void			(*init_dma)(ide_hwif_t *, unsigned long);
+	void			(*fixup)(ide_hwif_t *);
 	u8			channels;
 	u8			autodma;
 	ide_pci_enablebit_t	enablebits[2];
@@ -1525,8 +1396,11 @@
 	u8			flags;
 } ide_pci_device_t;
 
-extern void ide_setup_pci_device(struct pci_dev *, ide_pci_device_t *);
-extern void ide_setup_pci_devices(struct pci_dev *, struct pci_dev *, ide_pci_device_t *);
+extern int ide_setup_pci_device(struct pci_dev *, ide_pci_device_t *);
+extern int ide_setup_pci_devices(struct pci_dev *, struct pci_dev *, ide_pci_device_t *);
+
+void ide_map_sg(ide_drive_t *, struct request *);
+void ide_init_sg_cmd(ide_drive_t *, struct request *);
 
 #define BAD_DMA_DRIVE		0
 #define GOOD_DMA_DRIVE		1
@@ -1534,35 +1408,34 @@
 #ifdef CONFIG_BLK_DEV_IDEDMA
 int __ide_dma_bad_drive(ide_drive_t *);
 int __ide_dma_good_drive(ide_drive_t *);
+int ide_use_dma(ide_drive_t *);
 int __ide_dma_off(ide_drive_t *);
+void ide_dma_verbose(ide_drive_t *);
+ide_startstop_t ide_dma_intr(ide_drive_t *);
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 extern int ide_build_sglist(ide_drive_t *, struct request *);
-extern int ide_raw_build_sglist(ide_drive_t *, struct request *);
 extern int ide_build_dmatable(ide_drive_t *, struct request *);
 extern void ide_destroy_dmatable(ide_drive_t *);
-extern ide_startstop_t ide_dma_intr(ide_drive_t *);
 extern int ide_release_dma(ide_hwif_t *);
 extern void ide_setup_dma(ide_hwif_t *, unsigned long, unsigned int);
-extern int ide_start_dma(ide_hwif_t *, ide_drive_t *, int);
 
 extern int __ide_dma_host_off(ide_drive_t *);
 extern int __ide_dma_off_quietly(ide_drive_t *);
 extern int __ide_dma_host_on(ide_drive_t *);
 extern int __ide_dma_on(ide_drive_t *);
 extern int __ide_dma_check(ide_drive_t *);
-extern int __ide_dma_read(ide_drive_t *);
-extern int __ide_dma_write(ide_drive_t *);
-extern int __ide_dma_begin(ide_drive_t *);
+extern int ide_dma_setup(ide_drive_t *);
+extern void ide_dma_start(ide_drive_t *);
 extern int __ide_dma_end(ide_drive_t *);
-extern int __ide_dma_test_irq(ide_drive_t *);
-extern int __ide_dma_verbose(ide_drive_t *);
 extern int __ide_dma_lostirq(ide_drive_t *);
 extern int __ide_dma_timeout(ide_drive_t *);
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
 #else
+static inline int ide_use_dma(ide_drive_t *drive) { return 0; }
 static inline int __ide_dma_off(ide_drive_t *drive) { return 0; }
+static inline void ide_dma_verbose(ide_drive_t *drive) { ; }
 #endif /* CONFIG_BLK_DEV_IDEDMA */
 
 #ifndef CONFIG_BLK_DEV_IDEDMA_PCI
@@ -1573,6 +1446,9 @@
 extern void ide_hwif_release_regions(ide_hwif_t* hwif);
 extern void ide_unregister (unsigned int index);
 
+void ide_undecoded_slave(ide_hwif_t *);
+
+int probe_hwif_init_with_fixup(ide_hwif_t *, void (*)(ide_hwif_t *));
 extern int probe_hwif_init(ide_hwif_t *);
 
 static inline void *ide_get_hwifdata (ide_hwif_t * hwif)
@@ -1592,7 +1468,8 @@
 extern char *ide_xfer_verbose(u8 xfer_rate);
 extern void ide_toggle_bounce(ide_drive_t *drive, int on);
 extern int ide_set_xfer_rate(ide_drive_t *drive, u8 rate);
-extern byte ide_dump_atapi_status(ide_drive_t *drive, const char *msg, byte stat);
+
+u8 ide_dump_status(ide_drive_t *, const char *, u8);
 
 typedef struct ide_pio_timings_s {
 	int	setup_time;	/* Address setup (ns) minimum */
diff -Naur linuxppc-2.6.9/include/linux/mm.h linuxppc-2.6.9-dream/include/linux/mm.h
--- linuxppc-2.6.9/include/linux/mm.h	2004-10-18 23:53:07.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/mm.h	2005-06-20 10:46:11.000000000 +0200
@@ -41,6 +41,8 @@
 #define MM_VM_SIZE(mm)	TASK_SIZE
 #endif
 
+#define nth_page(page,n) pfn_to_page(page_to_pfn((page)) + (n))
+
 /*
  * Linux kernel virtual memory manager primitives.
  * The idea being to have a "virtual" mm in the same way
diff -Naur linuxppc-2.6.9/include/linux/mtd/cfi.h linuxppc-2.6.9-dream/include/linux/mtd/cfi.h
--- linuxppc-2.6.9/include/linux/mtd/cfi.h	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/mtd/cfi.h	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 
 /* Common Flash Interface structures 
  * See http://support.intel.com/design/flash/technote/index.htm
- * $Id: cfi.h,v 1.45 2004/07/20 02:44:27 dwmw2 Exp $
+ * $Id: cfi.h,v 1.50 2004/11/20 12:46:51 dwmw2 Exp $
  */
 
 #ifndef __MTD_CFI_H__
@@ -145,6 +145,24 @@
 	uint16_t ProtRegAddr;
 	uint8_t  FactProtRegSize;
 	uint8_t  UserProtRegSize;
+	uint8_t  extra[0];
+} __attribute__((packed));
+
+struct cfi_intelext_blockinfo {
+	uint16_t NumIdentBlocks;
+	uint16_t BlockSize;
+	uint16_t MinBlockEraseCycles;
+	uint8_t  BitsPerCell;
+	uint8_t  BlockCap;
+} __attribute__((packed));
+
+struct cfi_intelext_regioninfo {
+	uint16_t NumIdentPartitions;
+	uint8_t  NumOpAllowed;
+	uint8_t  NumOpAllowedSimProgMode;
+	uint8_t  NumOpAllowedSimEraMode;
+	uint8_t  NumBlockTypes;
+	struct cfi_intelext_blockinfo BlockTypes[1];
 } __attribute__((packed));
 
 /* Vendor-Specific PRI for AMD/Fujitsu Extended Command Set (0x0002) */
@@ -177,16 +195,19 @@
 	uint32_t ConfField[1]; /* Not host ordered */
 } __attribute__((packed));
 
-#define P_ID_NONE 0
-#define P_ID_INTEL_EXT 1
-#define P_ID_AMD_STD 2
-#define P_ID_INTEL_STD 3
-#define P_ID_AMD_EXT 4
-#define P_ID_ST_ADV 32
-#define P_ID_MITSUBISHI_STD 256
-#define P_ID_MITSUBISHI_EXT 257
-#define P_ID_SST_PAGE 258
-#define P_ID_RESERVED 65535
+#define P_ID_NONE               0x0000
+#define P_ID_INTEL_EXT          0x0001
+#define P_ID_AMD_STD            0x0002
+#define P_ID_INTEL_STD          0x0003
+#define P_ID_AMD_EXT            0x0004
+#define P_ID_WINBOND            0x0006
+#define P_ID_ST_ADV             0x0020
+#define P_ID_MITSUBISHI_STD     0x0100
+#define P_ID_MITSUBISHI_EXT     0x0101
+#define P_ID_SST_PAGE           0x0102
+#define P_ID_INTEL_PERFORMANCE  0x0200
+#define P_ID_INTEL_DATA         0x0210
+#define P_ID_RESERVED           0xffff
 
 
 #define CFI_MODE_CFI	1
@@ -328,14 +349,12 @@
 
 static inline void cfi_udelay(int us)
 {
-	unsigned long t = us * HZ / 1000000;
-	if (t) {
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(t);
-		return;
+	if (us >= 1000) {
+		msleep((us+999)/1000);
+	} else {
+		udelay(us);
+		cond_resched();
 	}
-	udelay(us);
-	cond_resched();
 }
 
 static inline void cfi_spin_lock(spinlock_t *mutex)
@@ -350,17 +369,26 @@
 
 struct cfi_extquery *cfi_read_pri(struct map_info *map, uint16_t adr, uint16_t size,
 			     const char* name);
-
 struct cfi_fixup {
 	uint16_t mfr;
 	uint16_t id;
-	void (*fixup)(struct map_info *map, void* param);
+	void (*fixup)(struct mtd_info *mtd, void* param);
 	void* param;
 };
 
 #define CFI_MFR_ANY 0xffff
 #define CFI_ID_ANY  0xffff
 
-void cfi_fixup(struct map_info *map, struct cfi_fixup* fixups);
+#define CFI_MFR_AMD 0x0001
+#define CFI_MFR_ST  0x0020 	/* STMicroelectronics */
+
+void cfi_fixup(struct mtd_info *mtd, struct cfi_fixup* fixups);
+
+typedef int (*varsize_frob_t)(struct map_info *map, struct flchip *chip,
+			      unsigned long adr, int len, void *thunk);
+
+int cfi_varsize_frob(struct mtd_info *mtd, varsize_frob_t frob,
+	loff_t ofs, size_t len, void *thunk);
+
 
 #endif /* __MTD_CFI_H__ */
diff -Naur linuxppc-2.6.9/include/linux/mtd/doc2000.h linuxppc-2.6.9-dream/include/linux/mtd/doc2000.h
--- linuxppc-2.6.9/include/linux/mtd/doc2000.h	2004-10-18 23:54:31.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/mtd/doc2000.h	2005-06-20 10:46:11.000000000 +0200
@@ -6,7 +6,7 @@
  * Copyright (C) 2002-2003 Greg Ungerer <gerg@snapgear.com>
  * Copyright (C) 2002-2003 SnapGear Inc
  *
- * $Id: doc2000.h,v 1.22 2003/11/05 10:51:36 dwmw2 Exp $ 
+ * $Id: doc2000.h,v 1.24 2005/01/05 12:40:38 dwmw2 Exp $ 
  *
  * Released under GPL
  */
@@ -89,8 +89,8 @@
 #define WriteDOC_(d, adr, reg)  do{ *(volatile __u16 *)(((unsigned long)adr)+((reg)<<1)) = (__u16)d; wmb();} while(0)
 #define DOC_IOREMAP_LEN 0x4000
 #else
-#define ReadDOC_(adr, reg)      readb(((unsigned long)adr) + (reg))
-#define WriteDOC_(d, adr, reg)  writeb(d, ((unsigned long)adr) + (reg))
+#define ReadDOC_(adr, reg)      readb((void __iomem *)(adr) + (reg))
+#define WriteDOC_(d, adr, reg)  writeb(d, (void __iomem *)(adr) + (reg))
 #define DOC_IOREMAP_LEN 0x2000
 
 #endif
@@ -168,7 +168,7 @@
 
 struct DiskOnChip {
 	unsigned long physadr;
-	unsigned long virtadr;
+	void __iomem *virtadr;
 	unsigned long totlen;
 	unsigned char ChipID; /* Type of DiskOnChip */
 	int ioreg;
diff -Naur linuxppc-2.6.9/include/linux/mtd/flashchip.h linuxppc-2.6.9-dream/include/linux/mtd/flashchip.h
--- linuxppc-2.6.9/include/linux/mtd/flashchip.h	2004-10-18 23:55:07.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/mtd/flashchip.h	2005-06-20 10:46:11.000000000 +0200
@@ -6,7 +6,7 @@
  *
  * (C) 2000 Red Hat. GPLd.
  *
- * $Id: flashchip.h,v 1.14 2004/06/15 16:44:59 nico Exp $
+ * $Id: flashchip.h,v 1.15 2004/11/05 22:41:06 nico Exp $
  *
  */
 
@@ -37,6 +37,8 @@
 	FL_LOCKING,
 	FL_UNLOCKING,
 	FL_POINT,
+	FL_XIP_WHILE_ERASING,
+	FL_XIP_WHILE_WRITING,
 	FL_UNKNOWN
 } flstate_t;
 
diff -Naur linuxppc-2.6.9/include/linux/mtd/gen_probe.h linuxppc-2.6.9-dream/include/linux/mtd/gen_probe.h
--- linuxppc-2.6.9/include/linux/mtd/gen_probe.h	2004-10-18 23:54:37.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/mtd/gen_probe.h	2005-06-20 10:46:11.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * (C) 2001, 2001 Red Hat, Inc.
  * GPL'd
- * $Id: gen_probe.h,v 1.2 2003/11/08 00:51:21 dsaxena Exp $
+ * $Id: gen_probe.h,v 1.3 2004/10/20 22:10:33 dwmw2 Exp $
  */
 
 #ifndef __LINUX_MTD_GEN_PROBE_H__
@@ -10,7 +10,7 @@
 #include <linux/mtd/flashchip.h>
 #include <linux/mtd/map.h> 
 #include <linux/mtd/cfi.h>
-#include <asm/bitops.h>
+#include <linux/bitops.h>
 
 struct chip_probe {
 	char *name;
diff -Naur linuxppc-2.6.9/include/linux/mtd/map.h linuxppc-2.6.9-dream/include/linux/mtd/map.h
--- linuxppc-2.6.9/include/linux/mtd/map.h	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/mtd/map.h	2005-06-20 10:46:11.000000000 +0200
@@ -1,6 +1,6 @@
 
 /* Overhauled routines for dealing with different mmap regions of flash */
-/* $Id: map.h,v 1.43 2004/07/14 13:30:27 dwmw2 Exp $ */
+/* $Id: map.h,v 1.46 2005/01/05 17:09:44 dwmw2 Exp $ */
 
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__
@@ -8,6 +8,7 @@
 #include <linux/config.h>
 #include <linux/types.h>
 #include <linux/list.h>
+#include <linux/mtd/compatmac.h>
 #include <asm/unaligned.h>
 #include <asm/system.h>
 #include <asm/io.h>
@@ -55,6 +56,11 @@
 #define map_bankwidth_is_4(map) (0)
 #endif
 
+/* ensure we never evaluate anything shorted than an unsigned long
+ * to zero, and ensure we'll never miss the end of an comparison (bjd) */
+
+#define map_calc_words(map) ((map_bankwidth(map) + (sizeof(unsigned long)-1))/ sizeof(unsigned long))
+
 #ifdef CONFIG_MTD_MAP_BANK_WIDTH_8
 # ifdef map_bankwidth
 #  undef map_bankwidth
@@ -63,12 +69,12 @@
 #   undef map_bankwidth_is_large
 #   define map_bankwidth_is_large(map) (map_bankwidth(map) > BITS_PER_LONG/8)
 #   undef map_words
-#   define map_words(map) (map_bankwidth(map) / sizeof(unsigned long))
+#   define map_words(map) map_calc_words(map)
 #  endif
 # else
 #  define map_bankwidth(map) 8
 #  define map_bankwidth_is_large(map) (BITS_PER_LONG < 64)
-#  define map_words(map) (map_bankwidth(map) / sizeof(unsigned long))
+#  define map_words(map) map_calc_words(map)
 # endif
 #define map_bankwidth_is_8(map) (map_bankwidth(map) == 8)
 #undef MAX_MAP_BANKWIDTH
@@ -84,11 +90,11 @@
 #  undef map_bankwidth_is_large
 #  define map_bankwidth_is_large(map) (map_bankwidth(map) > BITS_PER_LONG/8)
 #  undef map_words
-#  define map_words(map) (map_bankwidth(map) / sizeof(unsigned long))
+#  define map_words(map) map_calc_words(map)
 # else
 #  define map_bankwidth(map) 16
 #  define map_bankwidth_is_large(map) (1)
-#  define map_words(map) (map_bankwidth(map) / sizeof(unsigned long))
+#  define map_words(map) map_calc_words(map)
 # endif
 #define map_bankwidth_is_16(map) (map_bankwidth(map) == 16)
 #undef MAX_MAP_BANKWIDTH
@@ -104,11 +110,11 @@
 #  undef map_bankwidth_is_large
 #  define map_bankwidth_is_large(map) (map_bankwidth(map) > BITS_PER_LONG/8)
 #  undef map_words
-#  define map_words(map) (map_bankwidth(map) / sizeof(unsigned long))
+#  define map_words(map) map_calc_words(map)
 # else
 #  define map_bankwidth(map) 32
 #  define map_bankwidth_is_large(map) (1)
-#  define map_words(map) (map_bankwidth(map) / sizeof(unsigned long))
+#  define map_words(map) map_calc_words(map)
 # endif
 #define map_bankwidth_is_32(map) (map_bankwidth(map) == 32)
 #undef MAX_MAP_BANKWIDTH
@@ -316,7 +322,7 @@
 			bitpos = (map_bankwidth(map)-1-i)*8;
 #endif
 			orig.x[0] &= ~(0xff << bitpos);
-			orig.x[0] |= buf[i] << bitpos;
+			orig.x[0] |= buf[i-start] << bitpos;
 		}
 	}
 	return orig;
diff -Naur linuxppc-2.6.9/include/linux/mtd/nand.h linuxppc-2.6.9-dream/include/linux/mtd/nand.h
--- linuxppc-2.6.9/include/linux/mtd/nand.h	2004-10-18 23:55:07.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/mtd/nand.h	2005-06-20 10:46:11.000000000 +0200
@@ -5,7 +5,7 @@
  *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.63 2004/07/07 16:29:43 gleixner Exp $
+ * $Id: nand.h,v 1.68 2004/11/12 10:40:37 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -138,6 +138,8 @@
 #define NAND_ECC_HW6_512	4
 /* Hardware ECC 8 byte ECC per 512 Byte data */
 #define NAND_ECC_HW8_512	6
+/* Hardware ECC 12 byte ECC per 2048 Byte data */
+#define NAND_ECC_HW12_2048	7
 
 /*
  * Constants for Hardware ECC
@@ -212,6 +214,18 @@
 	FL_CACHEDPRG,
 } nand_state_t;
 
+/* Keep gcc happy */
+struct nand_chip;
+
+/**
+ * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independend devices
+ * @lock:               protection lock  
+ * @active:		the mtd device which holds the controller currently
+ */
+struct nand_hw_control {
+	spinlock_t	 lock;
+	struct nand_chip *active;
+};
 
 /**
  * struct nand_chip - NAND Private Flash Chip Data
@@ -241,6 +255,7 @@
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
  * @eccmode:		[BOARDSPECIFIC] mode of ecc, see defines 
  * @eccsize: 		[INTERN] databytes used per ecc-calculation
+ * @eccbytes: 		[INTERN] number of ecc bytes per ecc-calculation step
  * @eccsteps:		[INTERN] number of ecc calculation steps per page
  * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering data from array to read regs (tR)
  * @chip_lock:		[INTERN] spinlock used to protect access to this structure and the chip
@@ -265,12 +280,14 @@
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash lookup
  * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
+ * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial bad block scan 
+ * @controller:		[OPTIONAL] a pointer to a hardware controller structure which is shared among multiple independend devices
  * @priv:		[OPTIONAL] pointer to private chip date
  */
  
 struct nand_chip {
-	unsigned long 	IO_ADDR_R;
-	unsigned long 	IO_ADDR_W;
+	void  __iomem	*IO_ADDR_R;
+	void  __iomem 	*IO_ADDR_W;
 	
 	u_char		(*read_byte)(struct mtd_info *mtd);
 	void		(*write_byte)(struct mtd_info *mtd, u_char byte);
@@ -294,6 +311,7 @@
 	int		(*scan_bbt)(struct mtd_info *mtd);
 	int		eccmode;
 	int		eccsize;
+	int		eccbytes;
 	int		eccsteps;
 	int 		chip_delay;
 	spinlock_t	chip_lock;
@@ -317,6 +335,8 @@
 	uint8_t		*bbt;
 	struct nand_bbt_descr	*bbt_td;
 	struct nand_bbt_descr	*bbt_md;
+	struct nand_bbt_descr	*badblock_pattern;
+	struct nand_hw_control  *controller;
 	void		*priv;
 };
 
diff -Naur linuxppc-2.6.9/include/linux/mtd/partitions.h linuxppc-2.6.9-dream/include/linux/mtd/partitions.h
--- linuxppc-2.6.9/include/linux/mtd/partitions.h	2004-10-18 23:55:18.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/mtd/partitions.h	2005-06-20 10:46:11.000000000 +0200
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: partitions.h,v 1.15 2003/07/09 11:15:43 dwmw2 Exp $
+ * $Id: partitions.h,v 1.16 2004/11/16 18:34:40 dwmw2 Exp $
  */
 
 #ifndef MTD_PARTITIONS_H
@@ -64,7 +64,6 @@
 	int (*parse_fn)(struct mtd_info *, struct mtd_partition **, unsigned long);
 };
 
-extern struct mtd_part_parser *get_partition_parser(const char *name);
 extern int register_mtd_parser(struct mtd_part_parser *parser);
 extern int deregister_mtd_parser(struct mtd_part_parser *parser);
 extern int parse_mtd_partitions(struct mtd_info *master, const char **types, 
diff -Naur linuxppc-2.6.9/include/linux/mtd/xip.h linuxppc-2.6.9-dream/include/linux/mtd/xip.h
--- linuxppc-2.6.9/include/linux/mtd/xip.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/include/linux/mtd/xip.h	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,107 @@
+/*
+ * MTD primitives for XIP support
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Nov 2, 2004
+ * Copyright:	(C) 2004 MontaVista Software, Inc.
+ *
+ * This XIP support for MTD has been loosely inspired
+ * by an earlier patch authored by David Woodhouse.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * $Id: xip.h,v 1.2 2004/12/01 15:49:10 nico Exp $
+ */
+
+#ifndef __LINUX_MTD_XIP_H__
+#define __LINUX_MTD_XIP_H__
+
+#include <linux/config.h>
+
+#ifdef CONFIG_MTD_XIP
+
+/*
+ * Function that are modifying the flash state away from array mode must
+ * obviously not be running from flash.  The __xipram is therefore marking
+ * those functions so they get relocated to ram.
+ */
+#define __xipram __attribute__ ((__section__ (".data")))
+
+/*
+ * We really don't want gcc to guess anything.
+ * We absolutely _need_ proper inlining.
+ */
+#include <linux/compiler.h>
+
+/*
+ * Each architecture has to provide the following macros.  They must access
+ * the hardware directly and not rely on any other (XIP) functions since they
+ * won't be available when used (flash not in array mode).
+ *
+ * xip_irqpending()
+ *
+ * 	return non zero when any hardware interrupt is pending.
+ *
+ * xip_currtime()
+ *
+ * 	return a platform specific time reference to be used with
+ * 	xip_elapsed_since().
+ *
+ * xip_elapsed_since(x)
+ *
+ * 	return in usecs the elapsed timebetween now and the reference x as
+ * 	returned by xip_currtime().
+ *
+ * 	note 1: convertion to usec can be approximated, as long as the
+ * 		returned value is <= the real elapsed time.
+ * 	note 2: this should be able to cope with a few seconds without
+ * 		overflowing.
+ */
+
+#if defined(CONFIG_ARCH_SA1100) || defined(CONFIG_ARCH_PXA)
+
+#include <asm/hardware.h>
+#ifdef CONFIG_ARCH_PXA
+#include <asm/arch/pxa-regs.h>
+#endif
+
+#define xip_irqpending()	(ICIP & ICMR)
+
+/* we sample OSCR and convert desired delta to usec (1/4 ~= 1000000/3686400) */
+#define xip_currtime()		(OSCR)
+#define xip_elapsed_since(x)	(signed)((OSCR - (x)) / 4)
+
+#else
+
+#warning "missing IRQ and timer primitives for XIP MTD support"
+#warning "some of the XIP MTD support code will be disabled"
+#warning "your system will therefore be unresponsive when writing or erasing flash"
+
+#define xip_irqpending()	(0)
+#define xip_currtime()		(0)
+#define xip_elapsed_since(x)	(0)
+
+#endif
+
+/*
+ * xip_cpu_idle() is used when waiting for a delay equal or larger than
+ * the system timer tick period.  This should put the CPU into idle mode
+ * to save power and to be woken up only when some interrupts are pending.
+ * As above, this should not rely upon standard kernel code.
+ */
+
+#if defined(CONFIG_CPU_XSCALE)
+#define xip_cpu_idle()  asm volatile ("mcr p14, 0, %0, c7, c0, 0" :: "r" (1))
+#else
+#define xip_cpu_idle()  do { } while (0)
+#endif
+
+#else
+
+#define __xipram
+
+#endif /* CONFIG_MTD_XIP */
+
+#endif /* __LINUX_MTD_XIP_H__ */
diff -Naur linuxppc-2.6.9/include/linux/scatterlist.h linuxppc-2.6.9-dream/include/linux/scatterlist.h
--- linuxppc-2.6.9/include/linux/scatterlist.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/include/linux/scatterlist.h	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,14 @@
+#ifndef _LINUX_SCATTERLIST_H
+#define _LINUX_SCATTERLIST_H
+
+static inline void sg_init_one(struct scatterlist *sg,
+			       u8 *buf, unsigned int buflen)
+{
+	memset(sg, 0, sizeof(*sg));
+
+	sg->page = virt_to_page(buf);
+	sg->offset = offset_in_page(buf);
+	sg->length = buflen;
+}
+
+#endif /* _LINUX_SCATTERLIST_H */
diff -Naur linuxppc-2.6.9/include/linux/usb_ch9.h linuxppc-2.6.9-dream/include/linux/usb_ch9.h
--- linuxppc-2.6.9/include/linux/usb_ch9.h	2004-10-18 23:54:07.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/usb_ch9.h	2005-09-19 21:40:06.000000000 +0200
@@ -68,20 +68,6 @@
 #define USB_REQ_SET_INTERFACE		0x0B
 #define USB_REQ_SYNCH_FRAME		0x0C
 
-/*
- * USB feature flags are written using USB_REQ_{CLEAR,SET}_FEATURE, and
- * are read as a bit array returned by USB_REQ_GET_STATUS.  (So there
- * are at most sixteen features of each type.)
- */
-#define USB_DEVICE_SELF_POWERED		0	/* (read only) */
-#define USB_DEVICE_REMOTE_WAKEUP	1	/* dev may initiate wakeup */
-#define USB_DEVICE_TEST_MODE		2	/* (high speed only) */
-#define USB_DEVICE_B_HNP_ENABLE		3	/* dev may initiate HNP */
-#define USB_DEVICE_A_HNP_SUPPORT	4	/* RH port supports HNP */
-#define USB_DEVICE_A_ALT_HNP_SUPPORT	5	/* other RH port does */
-
-#define USB_ENDPOINT_HALT		0	/* IN/OUT will STALL */
-
 
 /**
  * struct usb_ctrlrequest - SETUP data for a USB device control request
@@ -103,9 +89,9 @@
 struct usb_ctrlrequest {
 	__u8 bRequestType;
 	__u8 bRequest;
-	__le16 wValue;
-	__le16 wIndex;
-	__le16 wLength;
+	__u16 wValue;
+	__u16 wIndex;
+	__u16 wLength;
 } __attribute__ ((packed));
 
 /*-------------------------------------------------------------------------*/
@@ -230,7 +216,7 @@
 	__u8  bLength;
 	__u8  bDescriptorType;
 
-	__le16 wData[1];		/* UTF-16LE encoded */
+	__u16 wData[1];		/* UTF-16LE encoded */
 } __attribute__ ((packed));
 
 /* note that "string" zero is special, it holds language codes that
diff -Naur linuxppc-2.6.9/include/linux/usbdevice_fs.h linuxppc-2.6.9-dream/include/linux/usbdevice_fs.h
--- linuxppc-2.6.9/include/linux/usbdevice_fs.h	2004-10-18 23:53:43.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/usbdevice_fs.h	2005-09-19 21:40:06.000000000 +0200
@@ -63,7 +63,7 @@
 
 struct usbdevfs_disconnectsignal {
 	unsigned int signr;
-	void __user *context;
+	void *context;
 };
 
 #define USBDEVFS_MAXDRIVERNAME 255
@@ -154,6 +154,7 @@
 
 struct dev_state {
 	struct list_head list;      /* state list */
+	struct rw_semaphore devsem; /* protects modifications to dev (dev == NULL indicating disconnect) */ 
 	struct usb_device *dev;
 	struct file *file;
 	spinlock_t lock;            /* protects the async urb lists */
@@ -162,7 +163,7 @@
 	wait_queue_head_t wait;     /* wake up if a request completed */
 	unsigned int discsignr;
 	struct task_struct *disctask;
-	void __user *disccontext;
+	void *disccontext;
 	unsigned long ifclaimed;
 };
 
diff -Naur linuxppc-2.6.9/include/linux/usb_gadget.h linuxppc-2.6.9-dream/include/linux/usb_gadget.h
--- linuxppc-2.6.9/include/linux/usb_gadget.h	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/usb_gadget.h	2005-09-19 21:40:06.000000000 +0200
@@ -6,7 +6,7 @@
  * master many USB gadgets, but the gadgets are only slaved to one host.
  *
  *
- * (C) Copyright 2002-2004 by David Brownell
+ * (c) Copyright 2002-2003 by David Brownell
  * All Rights Reserved.
  *
  * This software is licensed under the GNU GPL version 2.
@@ -73,6 +73,8 @@
  */
 	// NOTE this is analagous to 'struct urb' on the host side,
 	// except that it's thinner and promotes more pre-allocation.
+	//
+	// ISSUE should this be allocated through the device?
 
 struct usb_request {
 	void			*buf;
@@ -114,8 +116,8 @@
 		dma_addr_t *dma, int gfp_flags);
 	void (*free_buffer) (struct usb_ep *ep, void *buf, dma_addr_t dma,
 		unsigned bytes);
-	// NOTE:  on 2.6, drivers may also use dma_map() and
-	// dma_sync_single_*() to directly manage dma overhead. 
+	// NOTE:  on 2.5, drivers may also use dma_map() and
+	// dma_sync_single_*() to manage dma overhead.
 
 	int (*queue) (struct usb_ep *ep, struct usb_request *req,
 		int gfp_flags);
@@ -451,10 +453,7 @@
 struct usb_gadget_ops {
 	int	(*get_frame)(struct usb_gadget *);
 	int	(*wakeup)(struct usb_gadget *);
-	int	(*set_selfpowered) (struct usb_gadget *, int is_selfpowered);
-	int	(*vbus_session) (struct usb_gadget *, int is_active);
-	int	(*vbus_draw) (struct usb_gadget *, unsigned mA);
-	int	(*pullup) (struct usb_gadget *, int is_on);
+	int	(*set_selfpowered) (struct usb_gadget *, int value);
 	int	(*ioctl)(struct usb_gadget *,
 				unsigned code, unsigned long param);
 };
@@ -468,17 +467,6 @@
  * @speed: Speed of current connection to USB host.
  * @is_dualspeed: True if the controller supports both high and full speed
  *	operation.  If it does, the gadget driver must also support both.
- * @is_otg: True if the USB device port uses a Mini-AB jack, so that the
- *	gadget driver must provide a USB OTG descriptor.
- * @is_a_peripheral: False unless is_otg, the "A" end of a USB cable
- *	is in the Mini-AB jack, and HNP has been used to switch roles
- *	so that the "A" device currently acts as A-Peripheral, not A-Host.
- * @a_hnp_support: OTG device feature flag, indicating that the A-Host
- *	supports HNP at this port.
- * @a_alt_hnp_support: OTG device feature flag, indicating that the A-Host
- *	only supports HNP on a different root port.
- * @b_hnp_enable: OTG device feature flag, indicating that the A-Host
- *	enabled HNP support.
  * @name: Identifies the controller hardware type.  Used in diagnostics
  * 	and sometimes configuration.
  * @dev: Driver model state for this abstract device.
@@ -492,14 +480,9 @@
  *
  * Except for the driver data, all fields in this structure are
  * read-only to the gadget driver.  That driver data is part of the
- * "driver model" infrastructure in 2.6 (and later) kernels, and for
+ * "driver model" infrastructure in 2.5 (and later) kernels, and for
  * earlier systems is grouped in a similar structure that's not known
  * to the rest of the kernel.
- *
- * Values of the three OTG device feature flags are updated before the
- * setup() call corresponding to USB_REQ_SET_CONFIGURATION, and before
- * driver suspend() calls.  They are valid only when is_otg, and when the
- * device is acting as a B-Peripheral (so is_a_peripheral is false).
  */
 struct usb_gadget {
 	/* readonly to gadget driver */
@@ -508,11 +491,6 @@
 	struct list_head		ep_list;	/* of usb_ep */
 	enum usb_device_speed		speed;
 	unsigned			is_dualspeed:1;
-	unsigned			is_otg:1;
-	unsigned			is_a_peripheral:1;
-	unsigned			b_hnp_enable:1;
-	unsigned			a_hnp_support:1;
-	unsigned			a_alt_hnp_support:1;
 	const char			*name;
 	struct device			dev;
 };
@@ -547,10 +525,6 @@
  * doesn't support such attempts, or its support has not been enabled
  * by the usb host.  Drivers must return device descriptors that report
  * their ability to support this, or hosts won't enable it.
- *
- * This may also try to use SRP to wake the host and start enumeration,
- * even if OTG isn't otherwise in use.  OTG devices may also start
- * remote wakeup even when hosts don't explicitly enable it.
  */
 static inline int usb_gadget_wakeup (struct usb_gadget *gadget)
 {
@@ -594,107 +568,6 @@
 	return gadget->ops->set_selfpowered (gadget, 0);
 }
 
-/**
- * usb_gadget_vbus_connect - Notify controller that VBUS is powered
- * @gadget:The device which now has VBUS power.
- *
- * This call is used by a driver for an external transceiver (or GPIO)
- * that detects a VBUS power session starting.  Common responses include
- * resuming the controller, activating the D+ (or D-) pullup to let the
- * host detect that a USB device is attached, and starting to draw power
- * (8mA or possibly more, especially after SET_CONFIGURATION).
- *
- * Returns zero on success, else negative errno.
- */
-static inline int
-usb_gadget_vbus_connect(struct usb_gadget *gadget)
-{
-	if (!gadget->ops->vbus_session)
-		return -EOPNOTSUPP;
-	return gadget->ops->vbus_session (gadget, 1);
-}
-
-/**
- * usb_gadget_vbus_draw - constrain controller's VBUS power usage
- * @gadget:The device whose VBUS usage is being described
- * @mA:How much current to draw, in milliAmperes.  This should be twice
- *	the value listed in the configuration descriptor bMaxPower field.
- *
- * This call is used by gadget drivers during SET_CONFIGURATION calls,
- * reporting how much power the device may consume.  For example, this
- * could affect how quickly batteries are recharged.
- *
- * Returns zero on success, else negative errno.
- */
-static inline int
-usb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned mA)
-{
-	if (!gadget->ops->vbus_draw)
-		return -EOPNOTSUPP;
-	return gadget->ops->vbus_draw (gadget, mA);
-}
-
-/**
- * usb_gadget_vbus_disconnect - notify controller about VBUS session end
- * @gadget:the device whose VBUS supply is being described
- *
- * This call is used by a driver for an external transceiver (or GPIO)
- * that detects a VBUS power session ending.  Common responses include
- * reversing everything done in usb_gadget_vbus_connect().
- *
- * Returns zero on success, else negative errno.
- */
-static inline int
-usb_gadget_vbus_disconnect(struct usb_gadget *gadget)
-{
-	if (!gadget->ops->vbus_session)
-		return -EOPNOTSUPP;
-	return gadget->ops->vbus_session (gadget, 0);
-}
-
-/**
- * usb_gadget_connect - software-controlled connect to USB host
- * @gadget:the peripheral being connected
- *
- * Enables the D+ (or potentially D-) pullup.  The host will start
- * enumerating this gadget when the pullup is active and a VBUS session
- * is active (the link is powered).  This pullup is always enabled unless
- * usb_gadget_disconnect() has been used to disable it.
- *
- * Returns zero on success, else negative errno.
- */
-static inline int
-usb_gadget_connect (struct usb_gadget *gadget)
-{
-	if (!gadget->ops->pullup)
-		return -EOPNOTSUPP;
-	return gadget->ops->pullup (gadget, 1);
-}
-
-/**
- * usb_gadget_disconnect - software-controlled disconnect from USB host
- * @gadget:the peripheral being disconnected
- *
- * Disables the D+ (or potentially D-) pullup, which the host may see
- * as a disconnect (when a VBUS session is active).  Not all systems
- * support software pullup controls.
- *
- * This routine may be used during the gadget driver bind() call to prevent
- * the peripheral from ever being visible to the USB host, unless later
- * usb_gadget_connect() is called.  For example, user mode components may
- * need to be activated before the system can talk to hosts.
- *
- * Returns zero on success, else negative errno.
- */
-static inline int
-usb_gadget_disconnect (struct usb_gadget *gadget)
-{
-	if (!gadget->ops->pullup)
-		return -EOPNOTSUPP;
-	return gadget->ops->pullup (gadget, 0);
-}
-
-
 
 /*-------------------------------------------------------------------------*/
 
@@ -728,12 +601,6 @@
  * means the driver will handle setup() requests needed to enumerate (and
  * meet "chapter 9" requirements) then do some useful work.
  *
- * If gadget->is_otg is true, the gadget driver must provide an OTG
- * descriptor during enumeration, or else fail the bind() call.  In such
- * cases, no USB traffic may flow until both bind() returns without
- * having called usb_gadget_disconnect(), and the USB host stack has
- * initialized.
- *
  * Drivers use hardware-specific knowledge to configure the usb hardware.
  * endpoint addressing is only one of several hardware characteristics that
  * are in descriptors the ep0 implementation returns from setup() calls.
@@ -864,15 +731,6 @@
 int usb_gadget_config_buf(const struct usb_config_descriptor *config,
 	void *buf, unsigned buflen, const struct usb_descriptor_header **desc);
 
-/*-------------------------------------------------------------------------*/
-
-/* utility wrapping a simple endpoint selection policy */
-
-extern struct usb_ep *usb_ep_autoconfig (struct usb_gadget *,
-			struct usb_endpoint_descriptor *) __init;
-
-extern void usb_ep_autoconfig_reset (struct usb_gadget *) __init;
-
 #endif  /* __KERNEL__ */
 
 #endif	/* __LINUX_USB_GADGET_H */
diff -Naur linuxppc-2.6.9/include/linux/usb.h linuxppc-2.6.9-dream/include/linux/usb.h
--- linuxppc-2.6.9/include/linux/usb.h	2004-10-18 23:53:51.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/usb.h	2005-09-19 21:40:06.000000000 +0200
@@ -14,14 +14,23 @@
 #include <linux/delay.h>	/* for mdelay() */
 #include <linux/interrupt.h>	/* for in_interrupt() */
 #include <linux/list.h>		/* for struct list_head */
-#include <linux/kref.h>		/* for struct kref */
 #include <linux/device.h>	/* for struct device */
 #include <linux/fs.h>		/* for struct file_operations */
 #include <linux/completion.h>	/* for struct completion */
 #include <linux/sched.h>	/* for current && schedule_timeout */
 
+
+static __inline__ void wait_ms(unsigned int ms)
+{
+	if(!in_interrupt()) {
+		current->state = TASK_UNINTERRUPTIBLE;
+		schedule_timeout(1 + ms * HZ / 1000);
+	}
+	else
+		mdelay(ms);
+}
+
 struct usb_device;
-struct usb_driver;
 
 /*-------------------------------------------------------------------------*/
 
@@ -77,6 +86,8 @@
  *	number from the USB core by calling usb_register_dev().
  * @dev: driver model's view of this device
  * @class_dev: driver model's class view of this device.
+ * @released: wait for the interface to be released when changing
+ *	configurations.
  *
  * USB device drivers attach to interfaces on a physical device.  Each
  * interface encapsulates a single high level function, such as feeding
@@ -112,9 +123,11 @@
 					 * active alternate setting */
 	unsigned num_altsetting;	/* number of alternate settings */
 
+	struct usb_driver *driver;	/* driver */
 	int minor;			/* minor number this interface is bound to */
 	struct device dev;		/* interface specific device info */
 	struct class_device *class_dev;
+	struct completion *released;	/* wait for release */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
 #define	interface_to_usbdev(intf) \
@@ -130,49 +143,15 @@
 	dev_set_drvdata(&intf->dev, data);
 }
 
-struct usb_interface *usb_get_intf(struct usb_interface *intf);
-void usb_put_intf(struct usb_interface *intf);
-
 /* this maximum is arbitrary */
 #define USB_MAXINTERFACES	32
 
 /**
- * struct usb_interface_cache - long-term representation of a device interface
- * @num_altsetting: number of altsettings defined.
- * @ref: reference counter.
- * @altsetting: variable-length array of interface structures, one for
- *	each alternate setting that may be selected.  Each one includes a
- *	set of endpoint configurations.  They will be in no particular order.
- *
- * These structures persist for the lifetime of a usb_device, unlike
- * struct usb_interface (which persists only as long as its configuration
- * is installed).  The altsetting arrays can be accessed through these
- * structures at any time, permitting comparison of configurations and
- * providing support for the /proc/bus/usb/devices pseudo-file.
- */
-struct usb_interface_cache {
-	unsigned num_altsetting;	/* number of alternate settings */
-	struct kref ref;		/* reference counter */
-
-	/* variable-length array of alternate settings for this interface,
-	 * stored in no particular order */
-	struct usb_host_interface altsetting[0];
-};
-#define	ref_to_usb_interface_cache(r) \
-		container_of(r, struct usb_interface_cache, ref)
-#define	altsetting_to_usb_interface_cache(a) \
-		container_of(a, struct usb_interface_cache, altsetting[0])
-
-/**
  * struct usb_host_config - representation of a device's configuration
  * @desc: the device's configuration descriptor.
- * @interface: array of pointers to usb_interface structures, one for each
- *	interface in the configuration.  The number of interfaces is stored
- *	in desc.bNumInterfaces.  These pointers are valid only while the
- *	the configuration is active.
- * @intf_cache: array of pointers to usb_interface_cache structures, one
- *	for each interface in the configuration.  These structures exist
- *	for the entire life of the device.
+ * @interface: array of usb_interface structures, one for each interface
+ *	in the configuration.  The number of interfaces is stored in
+ *	desc.bNumInterfaces.
  * @extra: pointer to buffer containing all extra descriptors associated
  *	with this configuration (those preceding the first interface
  *	descriptor).
@@ -206,10 +185,6 @@
 	 * stored in no particular order */
 	struct usb_interface *interface[USB_MAXINTERFACES];
 
-	/* Interface information available even when this is not the
-	 * active configuration */
-	struct usb_interface_cache *intf_cache[USB_MAXINTERFACES];
-
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;
 };
@@ -241,9 +216,6 @@
 	struct device *controller;	/* host/master side hardware */
 	int busnum;			/* Bus number (in order of reg) */
 	char *bus_name;			/* stable id (PCI slot_name etc) */
-	u8 otg_port;			/* 0, or number of OTG/HNP port */
-	unsigned is_b_host:1;		/* true during some HNP roleswitches */
-	unsigned b_hnp_enable:1;	/* OTG: did A-Host enable HNP? */
 
 	int devnum_next;		/* Next open device number in round-robin allocation */
 
@@ -294,6 +266,8 @@
 	struct semaphore serialize;
 
 	unsigned int toggle[2];		/* one bit for each endpoint ([0] = IN, [1] = OUT) */
+	unsigned int halted[2];		/* endpoint halts; one bit per endpoint # & direction; */
+					/* [0] = IN, [1] = OUT */
 	int epmaxpacketin[16];		/* INput endpoint specific maximums */
 	int epmaxpacketout[16];		/* OUTput endpoint specific maximums */
 
@@ -335,7 +309,6 @@
 
 /* mostly for devices emulating SCSI over USB */
 extern int usb_reset_device(struct usb_device *dev);
-extern int __usb_reset_device(struct usb_device *dev);
 
 extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
@@ -345,21 +318,7 @@
 /* used these for multi-interface device registration */
 extern int usb_driver_claim_interface(struct usb_driver *driver,
 			struct usb_interface *iface, void* priv);
-
-/**
- * usb_interface_claimed - returns true iff an interface is claimed
- * @iface: the interface being checked
- *
- * Returns true (nonzero) iff the interface is claimed, else false (zero).
- * Callers must own the driver model's usb bus readlock.  So driver
- * probe() entries don't need extra locking, but other call contexts
- * may need to explicitly claim that lock.
- *
- */
-static inline int usb_interface_claimed(struct usb_interface *iface) {
-	return (iface->dev.driver != NULL);
-}
-
+extern int usb_interface_claimed(struct usb_interface *iface);
 extern void usb_driver_release_interface(struct usb_driver *driver,
 			struct usb_interface *iface);
 const struct usb_device_id *usb_match_id(struct usb_interface *interface,
@@ -651,12 +610,14 @@
  *	it likes with the URB, including resubmitting or freeing it.
  * @iso_frame_desc: Used to provide arrays of ISO transfer buffers and to 
  *	collect the transfer status for each buffer.
+ * @timeout: If set to zero, the urb will never timeout.  Otherwise this is
+ *	the time in jiffies that this urb will timeout in.
  *
  * This structure identifies USB transfer requests.  URBs must be allocated by
  * calling usb_alloc_urb() and freed with a call to usb_free_urb().
  * Initialization may be done using various usb_fill_*_urb() functions.  URBs
  * are submitted using usb_submit_urb(), and pending requests may be canceled
- * using usb_unlink_urb() or usb_kill_urb().
+ * using usb_unlink_urb().
  *
  * Data Transfer Buffers:
  *
@@ -680,12 +641,10 @@
  *
  * Initialization:
  *
- * All URBs submitted must initialize the dev, pipe, transfer_flags (may be
- * zero), and complete fields.
+ * All URBs submitted must initialize dev, pipe,
+ * transfer_flags (may be zero), complete, timeout (may be zero).
  * The URB_ASYNC_UNLINK transfer flag affects later invocations of
- * the usb_unlink_urb() routine.  Note: Failure to set URB_ASYNC_UNLINK
- * with usb_unlink_urb() is deprecated.  For synchronous unlinks use
- * usb_kill_urb() instead.
+ * the usb_unlink_urb() routine.
  *
  * All URBs must also initialize 
  * transfer_buffer and transfer_buffer_length.  They may provide the
@@ -703,7 +662,7 @@
  * URB_NO_SETUP_DMA_MAP indicate which buffers have already been mapped.
  * URB_NO_SETUP_DMA_MAP is ignored for non-control URBs.
  *
- * Interrupt URBs must provide an interval, saying how often (in milliseconds
+ * Interrupt UBS must provide an interval, saying how often (in milliseconds
  * or, for highspeed devices, 125 microsecond units)
  * to poll for transfers.  After the URB has been submitted, the interval
  * field reflects how the transfer was actually scheduled.
@@ -758,13 +717,11 @@
 struct urb
 {
 	/* private, usb core and host controller only fields in the urb */
-	struct kref kref;		/* reference count of the URB */
 	spinlock_t lock;		/* lock for the URB */
+	atomic_t count;			/* reference count of the URB */
 	void *hcpriv;			/* private data for host controller */
 	struct list_head urb_list;	/* list pointer to all active urbs */
 	int bandwidth;			/* bandwidth for INT/ISO request */
-	atomic_t use_count;		/* concurrent submissions counter */
-	u8 reject;			/* submissions will fail */
 
 	/* public, documented fields in the urb that can be used by drivers */
 	struct usb_device *dev; 	/* (in) pointer to associated device */
@@ -781,6 +738,7 @@
 	int number_of_packets;		/* (in) number of ISO packets */
 	int interval;			/* (modify) transfer interval (INT/ISO) */
 	int error_count;		/* (return) number of ISO errors */
+	int timeout;			/* (in) timeout, in jiffies */
 	void *context;			/* (in) context for completion */
 	usb_complete_t complete;	/* (in) completion routine */
 	struct usb_iso_packet_descriptor iso_frame_desc[0];	/* (in) ISO ONLY */
@@ -899,7 +857,6 @@
 extern struct urb *usb_get_urb(struct urb *urb);
 extern int usb_submit_urb(struct urb *urb, int mem_flags);
 extern int usb_unlink_urb(struct urb *urb);
-extern void usb_kill_urb(struct urb *urb);
 
 #define HAVE_USB_BUFFERS
 void *usb_buffer_alloc (struct usb_device *dev, size_t size,
@@ -934,11 +891,6 @@
 	void *data, int len, int *actual_length,
 	int timeout);
 
-/* selective suspend/resume */
-extern int usb_suspend_device(struct usb_device *dev, u32 state);
-extern int usb_resume_device(struct usb_device *dev);
-
-
 /* wrappers around usb_control_msg() for the most common standard requests */
 extern int usb_get_descriptor(struct usb_device *dev, unsigned char desctype,
 	unsigned char descindex, void *buf, int size);
@@ -952,6 +904,7 @@
 /* wrappers that also update important state inside usbcore */
 extern int usb_clear_halt(struct usb_device *dev, int pipe);
 extern int usb_reset_configuration(struct usb_device *dev);
+extern int usb_set_configuration(struct usb_device *dev, int configuration);
 extern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);
 
 /*
@@ -1079,6 +1032,10 @@
 #define	usb_dotoggle(dev, ep, out)  ((dev)->toggle[out] ^= (1 << (ep)))
 #define usb_settoggle(dev, ep, out, bit) ((dev)->toggle[out] = ((dev)->toggle[out] & ~(1 << (ep))) | ((bit) << (ep)))
 
+/* Endpoint halt control/status ... likewise USE WITH CAUTION */
+#define usb_endpoint_running(dev, ep, out) ((dev)->halted[out] &= ~(1 << (ep)))
+#define usb_endpoint_halted(dev, ep, out) ((dev)->halted[out] & (1 << (ep)))
+
 
 static inline unsigned int __create_pipe(struct usb_device *dev, unsigned int endpoint)
 {
diff -Naur linuxppc-2.6.9/include/linux/usb_otg.h linuxppc-2.6.9-dream/include/linux/usb_otg.h
--- linuxppc-2.6.9/include/linux/usb_otg.h	2004-10-18 23:55:35.000000000 +0200
+++ linuxppc-2.6.9-dream/include/linux/usb_otg.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,118 +0,0 @@
-// include/linux/usb_otg.h 
-
-/*
- * These APIs may be used between USB controllers.  USB device drivers
- * (for either host or peripheral roles) don't use these calls; they
- * continue to use just usb_device and usb_gadget.
- */
-
-
-/* OTG defines lots of enumeration states before device reset */
-enum usb_otg_state {
-	OTG_STATE_UNDEFINED = 0,
-
-	/* single-role peripheral, and dual-role default-b */
-	OTG_STATE_B_IDLE,
-	OTG_STATE_B_SRP_INIT,
-	OTG_STATE_B_PERIPHERAL,
-
-	/* extra dual-role default-b states */
-	OTG_STATE_B_WAIT_ACON,
-	OTG_STATE_B_HOST,
-
-	/* dual-role default-a */
-	OTG_STATE_A_IDLE,
-	OTG_STATE_A_WAIT_VRISE,
-	OTG_STATE_A_WAIT_BCON,
-	OTG_STATE_A_HOST,
-	OTG_STATE_A_SUSPEND,
-	OTG_STATE_A_PERIPHERAL,
-	OTG_STATE_A_WAIT_VFALL,
-	OTG_STATE_A_VBUS_ERR,
-};
-
-/*
- * the otg driver needs to interact with both device side and host side
- * usb controllers.  it decides which controller is active at a given
- * moment, using the transceiver, ID signal, HNP and sometimes static
- * configuration information (including "board isn't wired for otg").
- */
-struct otg_transceiver {
-	struct device		*dev;
-	const char		*label;
-
-	u8			default_a;
-	enum usb_otg_state	state;
-
-	struct usb_bus		*host;
-	struct usb_gadget	*gadget;
-
-	/* to pass extra port status to the root hub */
-	u16			port_status;
-	u16			port_change;
-
-	/* bind/unbind the host controller */
-	int 	(*set_host)(struct otg_transceiver *otg,
-				struct usb_bus *host);
-
-	/* bind/unbind the peripheral controller */
-	int	(*set_peripheral)(struct otg_transceiver *otg,
-				struct usb_gadget *gadget);
-
-	/* effective for B devices, ignored for A-peripheral */
-	int	(*set_power)(struct otg_transceiver *otg,
-				unsigned mA);
-
-	/* for B devices only:  start session with A-Host */
-	int	(*start_srp)(struct otg_transceiver *otg);
-
-	/* start or continue HNP role switch */
-	int	(*start_hnp)(struct otg_transceiver *otg);
-
-};
-
-
-/* for board-specific init logic */
-extern int otg_set_transceiver(struct otg_transceiver *);
-
-
-/* for usb host and peripheral controller drivers */
-extern struct otg_transceiver *otg_get_transceiver(void);
-
-static inline int
-otg_start_hnp(struct otg_transceiver *otg)
-{
-	return otg->start_hnp(otg);
-}
-
-
-/* for HCDs */
-static inline int
-otg_set_host(struct otg_transceiver *otg, struct usb_bus *host)
-{
-	return otg->set_host(otg, host);
-}
-
-
-/* for usb peripheral controller drivers */
-static inline int
-otg_set_peripheral(struct otg_transceiver *otg, struct usb_gadget *periph)
-{
-	return otg->set_peripheral(otg, periph);
-}
-
-static inline int
-otg_set_power(struct otg_transceiver *otg, unsigned mA)
-{
-	return otg->set_power(otg, mA);
-}
-
-static inline int
-otg_start_srp(struct otg_transceiver *otg)
-{
-	return otg->start_srp(otg);
-}
-
-
-/* for OTG controller drivers (and maybe other stuff) */
-extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);
diff -Naur linuxppc-2.6.9/include/mtd/mtd-abi.h linuxppc-2.6.9-dream/include/mtd/mtd-abi.h
--- linuxppc-2.6.9/include/mtd/mtd-abi.h	2004-10-18 23:54:32.000000000 +0200
+++ linuxppc-2.6.9-dream/include/mtd/mtd-abi.h	2005-06-20 10:46:11.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: mtd-abi.h,v 1.5 2004/06/22 09:29:35 gleixner Exp $
+ * $Id: mtd-abi.h,v 1.7 2004/11/23 15:37:32 gleixner Exp $
  *
  * Portions of MTD ABI definition which are shared by kernel and user space 
  */
@@ -7,6 +7,11 @@
 #ifndef __MTD_ABI_H__
 #define __MTD_ABI_H__
 
+#ifndef __KERNEL__ /* Urgh. The whole point of splitting this out into
+		    separate files was to avoid #ifdef __KERNEL__ */
+#define __user
+#endif
+
 struct erase_info_user {
 	uint32_t start;
 	uint32_t length;
@@ -35,6 +40,7 @@
 #define MTD_XIP			32	// eXecute-In-Place possible
 #define MTD_OOB			64	// Out-of-band data (NAND flash)
 #define MTD_ECC			128	// Device capable of automatic ECC
+#define MTD_NO_VIRTBLOCKS	256	// Virtual blocks not allowed
 
 // Some common devices / combinations of capabilities
 #define MTD_CAP_ROM		0
diff -Naur linuxppc-2.6.9/lib/Kconfig linuxppc-2.6.9-dream/lib/Kconfig
--- linuxppc-2.6.9/lib/Kconfig	2004-10-18 23:54:32.000000000 +0200
+++ linuxppc-2.6.9-dream/lib/Kconfig	2005-06-20 10:46:11.000000000 +0200
@@ -39,5 +39,23 @@
 config ZLIB_DEFLATE
 	tristate
 
+#
+# reed solomon support is select'ed if needed
+#
+config REED_SOLOMON
+	tristate
+	
+config REED_SOLOMON_ENC8
+	boolean
+
+config REED_SOLOMON_DEC8
+	boolean
+
+config REED_SOLOMON_ENC16
+	boolean
+
+config REED_SOLOMON_DEC16
+	boolean
+
 endmenu
 
diff -Naur linuxppc-2.6.9/lib/Makefile linuxppc-2.6.9-dream/lib/Makefile
--- linuxppc-2.6.9/lib/Makefile	2004-10-18 23:53:08.000000000 +0200
+++ linuxppc-2.6.9-dream/lib/Makefile	2005-06-20 10:46:11.000000000 +0200
@@ -22,6 +22,7 @@
 
 obj-$(CONFIG_ZLIB_INFLATE) += zlib_inflate/
 obj-$(CONFIG_ZLIB_DEFLATE) += zlib_deflate/
+obj-$(CONFIG_REED_SOLOMON) += reed_solomon/
 
 hostprogs-y	:= gen_crc32table
 clean-files	:= crc32table.h
diff -Naur linuxppc-2.6.9/lib/reed_solomon/decode_rs.c linuxppc-2.6.9-dream/lib/reed_solomon/decode_rs.c
--- linuxppc-2.6.9/lib/reed_solomon/decode_rs.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/lib/reed_solomon/decode_rs.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,272 @@
+/* 
+ * lib/reed_solomon/decode_rs.c
+ *
+ * Overview:
+ *   Generic Reed Solomon encoder / decoder library
+ *   
+ * Copyright 2002, Phil Karn, KA9Q
+ * May be used under the terms of the GNU General Public License (GPL)
+ *
+ * Adaption to the kernel by Thomas Gleixner (tglx@linutronix.de)
+ *
+ * $Id: decode_rs.c,v 1.6 2004/10/22 15:41:47 gleixner Exp $
+ *
+ */
+
+/* Generic data width independent code which is included by the 
+ * wrappers.
+ */
+{ 
+	int deg_lambda, el, deg_omega;
+	int i, j, r, k, pad;
+	int nn = rs->nn;
+	int nroots = rs->nroots;
+	int fcr = rs->fcr;
+	int prim = rs->prim;
+	int iprim = rs->iprim;
+	uint16_t *alpha_to = rs->alpha_to;
+	uint16_t *index_of = rs->index_of;
+	uint16_t u, q, tmp, num1, num2, den, discr_r, syn_error;
+	/* Err+Eras Locator poly and syndrome poly The maximum value
+	 * of nroots is 8. So the necessary stack size will be about
+	 * 220 bytes max.
+	 */
+	uint16_t lambda[nroots + 1], syn[nroots];
+	uint16_t b[nroots + 1], t[nroots + 1], omega[nroots + 1];
+	uint16_t root[nroots], reg[nroots + 1], loc[nroots];
+	int count = 0;
+	uint16_t msk = (uint16_t) rs->nn;
+
+	/* Check length parameter for validity */
+	pad = nn - nroots - len;
+	if (pad < 0 || pad >= nn)
+		return -ERANGE;
+		
+	/* Does the caller provide the syndrome ? */
+	if (s != NULL) 
+		goto decode;
+
+	/* form the syndromes; i.e., evaluate data(x) at roots of
+	 * g(x) */
+	for (i = 0; i < nroots; i++)
+		syn[i] = (((uint16_t) data[0]) ^ invmsk) & msk;
+
+	for (j = 1; j < len; j++) {
+		for (i = 0; i < nroots; i++) {
+			if (syn[i] == 0) {
+				syn[i] = (((uint16_t) data[j]) ^ 
+					  invmsk) & msk;
+			} else {
+				syn[i] = ((((uint16_t) data[j]) ^
+					   invmsk) & msk) ^ 
+					alpha_to[rs_modnn(rs, index_of[syn[i]] +
+						       (fcr + i) * prim)];
+			}
+		}
+	}
+
+	for (j = 0; j < nroots; j++) {
+		for (i = 0; i < nroots; i++) {
+			if (syn[i] == 0) {
+				syn[i] = ((uint16_t) par[j]) & msk;
+			} else {
+				syn[i] = (((uint16_t) par[j]) & msk) ^ 
+					alpha_to[rs_modnn(rs, index_of[syn[i]] +
+						       (fcr+i)*prim)];
+			}
+		}
+	}
+	s = syn;
+
+	/* Convert syndromes to index form, checking for nonzero condition */
+	syn_error = 0;
+	for (i = 0; i < nroots; i++) {
+		syn_error |= s[i];
+		s[i] = index_of[s[i]];
+	}
+
+	if (!syn_error) {
+		/* if syndrome is zero, data[] is a codeword and there are no
+		 * errors to correct. So return data[] unmodified
+		 */
+		count = 0;
+		goto finish;
+	}
+
+ decode:
+	memset(&lambda[1], 0, nroots * sizeof(lambda[0]));
+	lambda[0] = 1;
+
+	if (no_eras > 0) {
+		/* Init lambda to be the erasure locator polynomial */
+		lambda[1] = alpha_to[rs_modnn(rs, 
+					      prim * (nn - 1 - eras_pos[0]))];
+		for (i = 1; i < no_eras; i++) {
+			u = rs_modnn(rs, prim * (nn - 1 - eras_pos[i]));
+			for (j = i + 1; j > 0; j--) {
+				tmp = index_of[lambda[j - 1]];
+				if (tmp != nn) {
+					lambda[j] ^= 
+						alpha_to[rs_modnn(rs, u + tmp)];
+				}
+			}
+		}
+	}
+
+	for (i = 0; i < nroots + 1; i++)
+		b[i] = index_of[lambda[i]];
+
+	/*
+	 * Begin Berlekamp-Massey algorithm to determine error+erasure
+	 * locator polynomial
+	 */
+	r = no_eras;
+	el = no_eras;
+	while (++r <= nroots) {	/* r is the step number */
+		/* Compute discrepancy at the r-th step in poly-form */
+		discr_r = 0;
+		for (i = 0; i < r; i++) {
+			if ((lambda[i] != 0) && (s[r - i - 1] != nn)) {
+				discr_r ^= 
+					alpha_to[rs_modnn(rs, 
+							  index_of[lambda[i]] +
+							  s[r - i - 1])];
+			}
+		}
+		discr_r = index_of[discr_r];	/* Index form */
+		if (discr_r == nn) {
+			/* 2 lines below: B(x) <-- x*B(x) */
+			memmove (&b[1], b, nroots * sizeof (b[0]));
+			b[0] = nn;
+		} else {
+			/* 7 lines below: T(x) <-- lambda(x)-discr_r*x*b(x) */
+			t[0] = lambda[0];
+			for (i = 0; i < nroots; i++) {
+				if (b[i] != nn) {
+					t[i + 1] = lambda[i + 1] ^ 
+						alpha_to[rs_modnn(rs, discr_r +
+								  b[i])];
+				} else
+					t[i + 1] = lambda[i + 1];
+			}
+			if (2 * el <= r + no_eras - 1) {
+				el = r + no_eras - el;
+				/*
+				 * 2 lines below: B(x) <-- inv(discr_r) *
+				 * lambda(x)
+				 */
+				for (i = 0; i <= nroots; i++) {
+					b[i] = (lambda[i] == 0) ? nn :
+						rs_modnn(rs, index_of[lambda[i]]
+							 - discr_r + nn);
+				}
+			} else {
+				/* 2 lines below: B(x) <-- x*B(x) */
+				memmove(&b[1], b, nroots * sizeof(b[0]));
+				b[0] = nn;
+			}
+			memcpy(lambda, t, (nroots + 1) * sizeof(t[0]));
+		}
+	}
+
+	/* Convert lambda to index form and compute deg(lambda(x)) */
+	deg_lambda = 0;
+	for (i = 0; i < nroots + 1; i++) {
+		lambda[i] = index_of[lambda[i]];
+		if (lambda[i] != nn)
+			deg_lambda = i;
+	}
+	/* Find roots of error+erasure locator polynomial by Chien search */
+	memcpy(&reg[1], &lambda[1], nroots * sizeof(reg[0]));
+	count = 0;		/* Number of roots of lambda(x) */
+	for (i = 1, k = iprim - 1; i <= nn; i++, k = rs_modnn(rs, k + iprim)) {
+		q = 1;		/* lambda[0] is always 0 */
+		for (j = deg_lambda; j > 0; j--) {
+			if (reg[j] != nn) {
+				reg[j] = rs_modnn(rs, reg[j] + j);
+				q ^= alpha_to[reg[j]];
+			}
+		}
+		if (q != 0)
+			continue;	/* Not a root */
+		/* store root (index-form) and error location number */
+		root[count] = i;
+		loc[count] = k;
+		/* If we've already found max possible roots,
+		 * abort the search to save time
+		 */
+		if (++count == deg_lambda)
+			break;
+	}
+	if (deg_lambda != count) {
+		/*
+		 * deg(lambda) unequal to number of roots => uncorrectable
+		 * error detected
+		 */
+		count = -1;
+		goto finish;
+	}
+	/*
+	 * Compute err+eras evaluator poly omega(x) = s(x)*lambda(x) (modulo
+	 * x**nroots). in index form. Also find deg(omega).
+	 */
+	deg_omega = deg_lambda - 1;
+	for (i = 0; i <= deg_omega; i++) {
+		tmp = 0;
+		for (j = i; j >= 0; j--) {
+			if ((s[i - j] != nn) && (lambda[j] != nn))
+				tmp ^=
+				    alpha_to[rs_modnn(rs, s[i - j] + lambda[j])];
+		}
+		omega[i] = index_of[tmp];
+	}
+
+	/*
+	 * Compute error values in poly-form. num1 = omega(inv(X(l))), num2 =
+	 * inv(X(l))**(fcr-1) and den = lambda_pr(inv(X(l))) all in poly-form
+	 */
+	for (j = count - 1; j >= 0; j--) {
+		num1 = 0;
+		for (i = deg_omega; i >= 0; i--) {
+			if (omega[i] != nn)
+				num1 ^= alpha_to[rs_modnn(rs, omega[i] + 
+							i * root[j])];
+		}
+		num2 = alpha_to[rs_modnn(rs, root[j] * (fcr - 1) + nn)];
+		den = 0;
+
+		/* lambda[i+1] for i even is the formal derivative
+		 * lambda_pr of lambda[i] */
+		for (i = min(deg_lambda, nroots - 1) & ~1; i >= 0; i -= 2) {
+			if (lambda[i + 1] != nn) {
+				den ^= alpha_to[rs_modnn(rs, lambda[i + 1] + 
+						       i * root[j])];
+			}
+		}
+		/* Apply error to data */
+		if (num1 != 0 && loc[j] >= pad) {
+			uint16_t cor = alpha_to[rs_modnn(rs,index_of[num1] + 
+						       index_of[num2] +
+						       nn - index_of[den])];
+			/* Store the error correction pattern, if a
+			 * correction buffer is available */
+			if (corr) {
+				corr[j] = cor;
+			} else {
+				/* If a data buffer is given and the
+				 * error is inside the message,
+				 * correct it */
+				if (data && (loc[j] < (nn - nroots)))
+					data[loc[j] - pad] ^= cor;
+			}
+		}
+	}
+
+finish:
+	if (eras_pos != NULL) {
+		for (i = 0; i < count; i++)
+			eras_pos[i] = loc[i] - pad;
+	}
+	return count;
+
+}
diff -Naur linuxppc-2.6.9/lib/reed_solomon/encode_rs.c linuxppc-2.6.9-dream/lib/reed_solomon/encode_rs.c
--- linuxppc-2.6.9/lib/reed_solomon/encode_rs.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/lib/reed_solomon/encode_rs.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,54 @@
+/* 
+ * lib/reed_solomon/encode_rs.c
+ *
+ * Overview:
+ *   Generic Reed Solomon encoder / decoder library
+ *   
+ * Copyright 2002, Phil Karn, KA9Q
+ * May be used under the terms of the GNU General Public License (GPL)
+ *
+ * Adaption to the kernel by Thomas Gleixner (tglx@linutronix.de)
+ *
+ * $Id: encode_rs.c,v 1.4 2004/10/22 15:41:47 gleixner Exp $
+ *
+ */
+
+/* Generic data width independent code which is included by the 
+ * wrappers.
+ * int encode_rsX (struct rs_control *rs, uintX_t *data, int len, uintY_t *par)
+ */
+{
+	int i, j, pad;
+	int nn = rs->nn;
+	int nroots = rs->nroots;
+	uint16_t *alpha_to = rs->alpha_to;
+	uint16_t *index_of = rs->index_of;
+	uint16_t *genpoly = rs->genpoly;
+	uint16_t fb;
+	uint16_t msk = (uint16_t) rs->nn;
+
+	/* Check length parameter for validity */
+	pad = nn - nroots - len;
+	if (pad < 0 || pad >= nn)
+		return -ERANGE;
+
+	for (i = 0; i < len; i++) {
+		fb = index_of[((((uint16_t) data[i])^invmsk) & msk) ^ par[0]];
+		/* feedback term is non-zero */
+		if (fb != nn) {	
+			for (j = 1; j < nroots; j++) {
+				par[j] ^= alpha_to[rs_modnn(rs, fb + 
+							 genpoly[nroots - j])];
+			}
+		}
+		/* Shift */
+		memmove(&par[0], &par[1], sizeof(uint16_t) * (nroots - 1));
+		if (fb != nn) {
+			par[nroots - 1] = alpha_to[rs_modnn(rs, 
+							    fb + genpoly[0])];
+		} else {
+			par[nroots - 1] = 0;
+		}
+	}
+	return 0;
+}
diff -Naur linuxppc-2.6.9/lib/reed_solomon/Makefile linuxppc-2.6.9-dream/lib/reed_solomon/Makefile
--- linuxppc-2.6.9/lib/reed_solomon/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/lib/reed_solomon/Makefile	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,6 @@
+#
+# This is a modified version of reed solomon lib, 
+#
+
+obj-$(CONFIG_REED_SOLOMON) += reed_solomon.o
+
diff -Naur linuxppc-2.6.9/lib/reed_solomon/reed_solomon.c linuxppc-2.6.9-dream/lib/reed_solomon/reed_solomon.c
--- linuxppc-2.6.9/lib/reed_solomon/reed_solomon.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.6.9-dream/lib/reed_solomon/reed_solomon.c	2005-06-20 10:46:11.000000000 +0200
@@ -0,0 +1,335 @@
+/* 
+ * lib/reed_solomon/rslib.c
+ *
+ * Overview:
+ *   Generic Reed Solomon encoder / decoder library
+ *   
+ * Copyright (C) 2004 Thomas Gleixner (tglx@linutronix.de)
+ *
+ * Reed Solomon code lifted from reed solomon library written by Phil Karn
+ * Copyright 2002 Phil Karn, KA9Q
+ *
+ * $Id: rslib.c,v 1.5 2004/10/22 15:41:47 gleixner Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Description:
+ *	
+ * The generic Reed Solomon library provides runtime configurable
+ * encoding / decoding of RS codes.
+ * Each user must call init_rs to get a pointer to a rs_control
+ * structure for the given rs parameters. This structure is either
+ * generated or a already available matching control structure is used.
+ * If a structure is generated then the polynomial arrays for
+ * fast encoding / decoding are built. This can take some time so
+ * make sure not to call this function from a time critical path.
+ * Usually a module / driver should initialize the necessary 
+ * rs_control structure on module / driver init and release it
+ * on exit.
+ * The encoding puts the calculated syndrome into a given syndrome 
+ * buffer. 
+ * The decoding is a two step process. The first step calculates
+ * the syndrome over the received (data + syndrome) and calls the
+ * second stage, which does the decoding / error correction itself.
+ * Many hw encoders provide a syndrome calculation over the received
+ * data + syndrome and can call the second stage directly.
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/rslib.h>
+#include <linux/slab.h>
+#include <asm/semaphore.h>
+
+/* This list holds all currently allocated rs control structures */
+static LIST_HEAD (rslist);
+/* Protection for the list */
+static DECLARE_MUTEX(rslistlock);
+
+/** 
+ * rs_init - Initialize a Reed-Solomon codec
+ *
+ * @symsize:	symbol size, bits (1-8)
+ * @gfpoly:	Field generator polynomial coefficients
+ * @fcr:	first root of RS code generator polynomial, index form
+ * @prim:	primitive element to generate polynomial roots
+ * @nroots:	RS code generator polynomial degree (number of roots)
+ *
+ * Allocate a control structure and the polynom arrays for faster
+ * en/decoding. Fill the arrays according to the given parameters
+ */
+static struct rs_control *rs_init(int symsize, int gfpoly, int fcr, 
+				   int prim, int nroots)
+{
+	struct rs_control *rs;
+	int i, j, sr, root, iprim;
+
+	/* Allocate the control structure */
+	rs = kmalloc(sizeof (struct rs_control), GFP_KERNEL);
+	if (rs == NULL)
+		return NULL;
+
+	INIT_LIST_HEAD(&rs->list);
+
+	rs->mm = symsize;
+	rs->nn = (1 << symsize) - 1;
+	rs->fcr = fcr;
+	rs->prim = prim;
+	rs->nroots = nroots;
+	rs->gfpoly = gfpoly;
+
+	/* Allocate the arrays */
+	rs->alpha_to = kmalloc(sizeof(uint16_t) * (rs->nn + 1), GFP_KERNEL);
+	if (rs->alpha_to == NULL)
+		goto errrs;
+
+	rs->index_of = kmalloc(sizeof(uint16_t) * (rs->nn + 1), GFP_KERNEL);
+	if (rs->index_of == NULL)
+		goto erralp;
+
+	rs->genpoly = kmalloc(sizeof(uint16_t) * (rs->nroots + 1), GFP_KERNEL);
+	if(rs->genpoly == NULL)
+		goto erridx;
+
+	/* Generate Galois field lookup tables */
+	rs->index_of[0] = rs->nn;	/* log(zero) = -inf */
+	rs->alpha_to[rs->nn] = 0;	/* alpha**-inf = 0 */
+	sr = 1;
+	for (i = 0; i < rs->nn; i++) {
+		rs->index_of[sr] = i;
+		rs->alpha_to[i] = sr;
+		sr <<= 1;
+		if (sr & (1 << symsize))
+			sr ^= gfpoly;
+		sr &= rs->nn;
+	}
+	/* If it's not primitive, exit */
+	if(sr != 1)
+		goto errpol;
+
+	/* Find prim-th root of 1, used in decoding */
+	for(iprim = 1; (iprim % prim) != 0; iprim += rs->nn);
+	/* prim-th root of 1, index form */
+	rs->iprim = iprim / prim;
+
+	/* Form RS code generator polynomial from its roots */
+	rs->genpoly[0] = 1;
+	for (i = 0, root = fcr * prim; i < nroots; i++, root += prim) {
+		rs->genpoly[i + 1] = 1;
+		/* Multiply rs->genpoly[] by  @**(root + x) */
+		for (j = i; j > 0; j--) {
+			if (rs->genpoly[j] != 0) {
+				rs->genpoly[j] = rs->genpoly[j -1] ^ 
+					rs->alpha_to[rs_modnn(rs, 
+					rs->index_of[rs->genpoly[j]] + root)];
+			} else
+				rs->genpoly[j] = rs->genpoly[j - 1];
+		}
+		/* rs->genpoly[0] can never be zero */
+		rs->genpoly[0] = 
+			rs->alpha_to[rs_modnn(rs, 
+				rs->index_of[rs->genpoly[0]] + root)];
+	}
+	/* convert rs->genpoly[] to index form for quicker encoding */
+	for (i = 0; i <= nroots; i++)
+		rs->genpoly[i] = rs->index_of[rs->genpoly[i]];
+	return rs;
+
+	/* Error exit */
+errpol:
+	kfree(rs->genpoly);
+erridx:
+	kfree(rs->index_of);
+erralp:
+	kfree(rs->alpha_to);
+errrs:
+	kfree(rs);
+	return NULL;
+}
+
+
+/** 
+ *  free_rs - Free the rs control structure, if its not longer used
+ *
+ *  @rs:	the control structure which is not longer used by the
+ *		caller
+ */
+void free_rs(struct rs_control *rs)
+{
+	down(&rslistlock);
+	rs->users--;
+	if(!rs->users) {
+		list_del(&rs->list);
+		kfree(rs->alpha_to);
+		kfree(rs->index_of);
+		kfree(rs->genpoly);
+		kfree(rs);
+	}
+	up(&rslistlock);
+}
+
+/** 
+ * init_rs - Find a matching or allocate a new rs control structure
+ *
+ *  @symsize:	the symbol size (number of bits)
+ *  @gfpoly:	the extended Galois field generator polynomial coefficients,
+ *		with the 0th coefficient in the low order bit. The polynomial
+ *		must be primitive;
+ *  @fcr:  	the first consecutive root of the rs code generator polynomial 
+ *		in index form
+ *  @prim:	primitive element to generate polynomial roots
+ *  @nroots:	RS code generator polynomial degree (number of roots)
+ */
+struct rs_control *init_rs(int symsize, int gfpoly, int fcr, int prim, 
+			   int nroots)
+{
+	struct list_head	*tmp;
+	struct rs_control	*rs;
+
+	/* Sanity checks */
+	if (symsize < 1)
+		return NULL;
+	if (fcr < 0 || fcr >= (1<<symsize))
+    		return NULL;
+	if (prim <= 0 || prim >= (1<<symsize))
+    		return NULL;
+	if (nroots < 0 || nroots >= (1<<symsize) || nroots > 8)
+		return NULL;
+	
+	down(&rslistlock);
+
+	/* Walk through the list and look for a matching entry */
+	list_for_each(tmp, &rslist) {
+		rs = list_entry(tmp, struct rs_control, list);
+		if (symsize != rs->mm)
+			continue;
+		if (gfpoly != rs->gfpoly)
+			continue;
+		if (fcr != rs->fcr)
+			continue;	
+		if (prim != rs->prim)
+			continue;	
+		if (nroots != rs->nroots)
+			continue;
+		/* We have a matching one already */
+		rs->users++;
+		goto out;
+	}
+
+	/* Create a new one */
+	rs = rs_init(symsize, gfpoly, fcr, prim, nroots);
+	if (rs) {
+		rs->users = 1;
+		list_add(&rs->list, &rslist);
+	}
+out:	
+	up(&rslistlock);
+	return rs;
+}
+
+#ifdef CONFIG_REED_SOLOMON_ENC8
+/** 
+ *  encode_rs8 - Calculate the parity for data values (8bit data width)
+ *
+ *  @rs:	the rs control structure
+ *  @data:	data field of a given type
+ *  @len:	data length 
+ *  @par:	parity data, must be initialized by caller (usually all 0)
+ *  @invmsk:	invert data mask (will be xored on data)
+ *
+ *  The parity uses a uint16_t data type to enable
+ *  symbol size > 8. The calling code must take care of encoding of the
+ *  syndrome result for storage itself.
+ */
+int encode_rs8(struct rs_control *rs, uint8_t *data, int len, uint16_t *par, 
+	       uint16_t invmsk)
+{
+#include "encode_rs.c"
+}
+EXPORT_SYMBOL_GPL(encode_rs8);
+#endif
+
+#ifdef CONFIG_REED_SOLOMON_DEC8
+/** 
+ *  decode_rs8 - Decode codeword (8bit data width)
+ *
+ *  @rs:	the rs control structure
+ *  @data:	data field of a given type
+ *  @par:	received parity data field
+ *  @len:	data length
+ *  @s:		syndrome data field (if NULL, syndrome is calculated)
+ *  @no_eras:	number of erasures
+ *  @eras_pos:	position of erasures, can be NULL
+ *  @invmsk:	invert data mask (will be xored on data, not on parity!)
+ *  @corr:	buffer to store correction bitmask on eras_pos
+ *
+ *  The syndrome and parity uses a uint16_t data type to enable
+ *  symbol size > 8. The calling code must take care of decoding of the
+ *  syndrome result and the received parity before calling this code.
+ */
+int decode_rs8(struct rs_control *rs, uint8_t *data, uint16_t *par, int len,
+	       uint16_t *s, int no_eras, int *eras_pos, uint16_t invmsk, 
+	       uint16_t *corr)
+{
+#include "decode_rs.c"
+}
+EXPORT_SYMBOL_GPL(decode_rs8);
+#endif
+
+#ifdef CONFIG_REED_SOLOMON_ENC16
+/**
+ *  encode_rs16 - Calculate the parity for data values (16bit data width)
+ *
+ *  @rs:	the rs control structure
+ *  @data:	data field of a given type
+ *  @len:	data length 
+ *  @par:	parity data, must be initialized by caller (usually all 0)
+ *  @invmsk:	invert data mask (will be xored on data, not on parity!)
+ *
+ *  Each field in the data array contains up to symbol size bits of valid data.
+ */
+int encode_rs16(struct rs_control *rs, uint16_t *data, int len, uint16_t *par, 
+	uint16_t invmsk)
+{
+#include "encode_rs.c"
+}
+EXPORT_SYMBOL_GPL(encode_rs16);
+#endif
+
+#ifdef CONFIG_REED_SOLOMON_DEC16
+/** 
+ *  decode_rs16 - Decode codeword (16bit data width)
+ *
+ *  @rs:	the rs control structure
+ *  @data:	data field of a given type
+ *  @par:	received parity data field
+ *  @len:	data length
+ *  @s:		syndrome data field (if NULL, syndrome is calculated)
+ *  @no_eras:	number of erasures
+ *  @eras_pos:	position of erasures, can be NULL
+ *  @invmsk:	invert data mask (will be xored on data, not on parity!) 
+ *  @corr:	buffer to store correction bitmask on eras_pos
+ *
+ *  Each field in the data array contains up to symbol size bits of valid data.
+ */
+int decode_rs16(struct rs_control *rs, uint16_t *data, uint16_t *par, int len,
+		uint16_t *s, int no_eras, int *eras_pos, uint16_t invmsk, 
+		uint16_t *corr)
+{
+#include "decode_rs.c"
+}
+EXPORT_SYMBOL_GPL(decode_rs16);
+#endif
+
+EXPORT_SYMBOL_GPL(init_rs);
+EXPORT_SYMBOL_GPL(free_rs);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Reed Solomon encoder/decoder");
+MODULE_AUTHOR("Phil Karn, Thomas Gleixner");
+
diff -Naur linuxppc-2.6.9/Makefile linuxppc-2.6.9-dream/Makefile
--- linuxppc-2.6.9/Makefile	2004-10-18 23:54:38.000000000 +0200
+++ linuxppc-2.6.9-dream/Makefile	2005-06-20 10:46:10.000000000 +0200
@@ -190,8 +190,8 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH		?= ppc
+CROSS_COMPILE	?= powerpc-tuxbox-linux-gnu-
 
 # Architecture as present in compile.h
 UTS_MACHINE := $(ARCH)
